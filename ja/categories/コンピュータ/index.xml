<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>コンピュータ on 向叔の手帳</title>
        <link>https://ttf248.life/ja/categories/%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF/</link>
        <description>Recent content in コンピュータ on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Wed, 28 May 2025 09:47:38 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/categories/%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>GitHub Pages のサプライズ：複数の Pages をデプロイする</title>
        <link>https://ttf248.life/ja/p/github-pages-easter-egg-deploy-multiple-sites/</link>
        <pubDate>Wed, 28 May 2025 02:55:54 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/github-pages-easter-egg-deploy-multiple-sites/</guid>
        <description>&lt;p&gt;最近、体内時計が少し狂っていて、深夜2時過ぎまでGitHub Pagesのデプロイに手を出していた。&lt;/p&gt;
&lt;p&gt;終わった後、やっとご飯を食べに行ったんだけど、食べた直後に眠くなり、食べて帰ってきて8時半くらいには、眠くて、少し仮眠ったらそのまま寝てしまい、起きたらもう午前2時過ぎだった。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;まだ始動もせず消滅したカテゴリー：AI 研習社&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;ツッコミ&#34;&gt;ツッコミ
&lt;/h2&gt;&lt;p&gt;昨日まで「フロントエンドをいじらない」と言っていたのに、今日はフロントエンドではなく、UI/UXの体験についていじっている。&lt;/p&gt;
&lt;h2 id=&#34;プロジェクト&#34;&gt;プロジェクト
&lt;/h2&gt;&lt;p&gt;ご紹介いたします、旧友の&lt;a class=&#34;link&#34; href=&#34;https://github.com/ttf248/ai-coding-demo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ttf248/ai-coding-demo&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;その通り、元々選択した株のプロジェクトですね。このプロジェクトで全体の構造を再構築し、今後のAIプログラミング関連の内容はこちらに統合します。&lt;/p&gt;
&lt;h2 id=&#34;複数のpagesを配置する&#34;&gt;複数のPagesを配置する
&lt;/h2&gt;&lt;p&gt;プロジェクトは &lt;a class=&#34;link&#34; href=&#34;https://cnb.cool/ttf248/ai-coding-demo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cnb.cool/ttf248/ai-coding-demo&lt;/a&gt; にホストされていますが、よく知られた理由により、中国国内では Pages の公開がサポートされていません。そのため、海外の GitHub で公開する必要があります。&lt;/p&gt;
&lt;p&gt;ブログは海外のGithubに公開されているものです。まだ試したことがなく、複数のプロジェクトでpagesを公開しようとしています。現在取り組んでいるプロジェクトは従来のブログサイトではなく、単に多くのドキュメントがあり、いくつかの静的なhtmlデザインが重ねられています。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/github-pages-easter-egg-deploy-multiple-sites/20250528030230.png&#34;
	width=&#34;798&#34;
	height=&#34;530&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;pages&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;150&#34;
		data-flex-basis=&#34;361px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;はい、このページは私が最初にクリックして気づいたのですが、複数のプロジェクトをデプロイしたpagesはブログの公開に影響を与えず、ブログのドメイン下に新しいパスが追加されるだけです。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://ttf248.life/ai-coding-demo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ttf248.life/ai-coding-demo/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ここ見ると思わず「完璧」と叫んでしまう。&lt;/p&gt;
&lt;h2 id=&#34;エーアイけんしゅうしゃ&#34;&gt;エーアイけんしゅうしゃ
&lt;/h2&gt;&lt;p&gt;昨日新設したカテゴリーで、AIを使って多くのコンピュータのコースを学習しようと考えた。例えば、アルゴリズムや LeetCode の問題演習など。&lt;/p&gt;
&lt;p&gt;毎回の学習記録をブログに投稿し、知識データベースを構築。新カテゴリ「AI 研習会」を作成しました。&lt;/p&gt;
&lt;p&gt;今のところ、異なるコースごとに新しいプロジェクトを作成し、学習ノートは各プロジェクトのReadme.mdにまとめて記述するのが良いようだ。&lt;/p&gt;</description>
        </item>
        <item>
        <title>古い弱点、花の華やかさに目が奪われる。</title>
        <link>https://ttf248.life/ja/p/old-ailment-stunning-flowers/</link>
        <pubDate>Mon, 26 May 2025 23:54:12 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/old-ailment-stunning-flowers/</guid>
        <description>&lt;p&gt;長年バックエンド開発に注力してきましたが、最近、フロントエンドインターフェースを実現するために &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 编程，并涉足了一些前端相关的内容。然而，在这段折腾的过程中，我逐渐意识到自己又陷入了一个老毛病——繁花迷人眼。总想着用 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; を試み始めましたが、実際には、そのような試みは現在の仕事にほとんど役立たず、むしろ気を散らすだけでした。&lt;/p&gt;
&lt;h2 id=&#34;aiの適用シーン&#34;&gt;AIの適用シーン
&lt;/h2&gt;&lt;p&gt;小規模プロジェクトにおいて、AIツールは特に大きな効果を発揮します。独立性が高く、システムとの結合度が低く、ビジネスロジックが単純な関数を記述する際には、いっそうその手腕が光ります。これらのタスクは通常、明確な入力と出力があり、コンテキスト依存性が少ないため、現在のAIによるプログラミング支援の能力範囲に最適です。&lt;/p&gt;
&lt;p&gt;しかし、複雑なシステムアーキテクチャや高度なビジネスロジックに直面すると、AIの限界が徐々に明らかになる。一見妥当に見えるが、実際にはプロジェクトの真のニーズからかけ離れたコードを生成したり、原因究明が困難な潜在的な問題を導入したりする可能性がある。そのような状況では、AIは完全なコードジェネレーターとしてではなく、むしろ補助ツールとして活用すべきである。生成されたコードについては厳格なレビューとテストを行い、実際の要件を満たしていることを確認する必要がある。&lt;/p&gt;
&lt;h2 id=&#34;間違いと学習の代償&#34;&gt;間違いと学習の代償
&lt;/h2&gt;&lt;p&gt;AIによるフロントエンドコード生成を試みる中で、多くの課題に直面しました。フロントエンドは得意分野ではないため、問題の特定には時間と労力がかかります。プロンプトを調整してAIにコードを書き直しても、初級的なエラーを避けることは難しいです。この繰り返しの試行錯誤は時間を浪費するだけでなく、現在のリソースを慣れない領域での模索ではなく、バックエンドのビジネスロジックに集中すべきだと気づかされました。&lt;/p&gt;
&lt;p&gt;週末に完了したプロジェクトを振り返ると、バックエンド開発とユーザーインタラクションロジックに集中し、コンソールで機能を実装することが現時点で最も効率的な選択だと確信する。より多くの時間とエネルギーがある時に、フロントエンドの知識を体系的に学ぶ方が良い戦略かもしれない。&lt;/p&gt;
&lt;h2 id=&#34;フロントエンド学習計画&#34;&gt;フロントエンド学習計画
&lt;/h2&gt;&lt;p&gt;フロントエンド技術のスタックは複雑で多様なため、すぐに習得することは現実的ではありません。まずは Vue.js や React.js のようなフレームワークを一つ選び、そのコアコンセプトと使い方を深く学習する予定です。基礎知識に慣れてからこそ、AI を活用してフロントエンドコードを生成することで初めて、不慣れによるエラーや時間浪費を効果的に回避できます。&lt;/p&gt;
&lt;p&gt;結局、現段階ではバックエンド開発に重点を置き、着実にコアスキルを向上させることが重要だ。時機が整ったら、フロントエンドとAIの組み合わせを探求するのも良いかもしれないし、より大きな成果が得られるかもしれない。&lt;/p&gt;</description>
        </item>
        <item>
        <title>フォークされたリポジトリへのPull Requestのマージ</title>
        <link>https://ttf248.life/ja/p/merge-pullrequest-to-fork-repository/</link>
        <pubDate>Wed, 07 May 2025 18:44:03 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/merge-pullrequest-to-fork-repository/</guid>
        <description>&lt;p&gt;GitHub プロフィール統計情報ジェネレーターで、ユーザーは自身の GitHub プロフィールに様々な統計情報やグラフを表示できます。多様なカスタマイズオプションが用意されており、ユーザーのニーズに合わせて調整可能です。&lt;/p&gt;
&lt;p&gt;筆者は倉庫の管理をプロジェクトごとに分けていますが、GitHubでは倉庫のグループ化がサポートされていないため、異なる組織に分割して対応しています。最新ブランチは複数の組織にまたがる倉庫の統計に対応していないため、筆者はフォークしたブランチに該当コードをマージしました。&lt;/p&gt;
&lt;h2 id=&#34;最終効果&#34;&gt;最終効果
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://github-readme-stats-chi-one-17.vercel.app/api?username=ttf248&amp;amp;hide_title=true&amp;amp;show_icons=true&amp;amp;hide=contribs&amp;amp;line_height=24&amp;amp;include_all_commits=true&amp;amp;count_private=true&amp;amp;bg_color=0000&amp;amp;text_color=8A919F&amp;amp;locale=cn&amp;amp;role=OWNER,COLLABORATOR,ORGANIZATION_MEMBER&amp;amp;timstamp=1746608356&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;GitHub Stats&#34;
	
	
&gt;
&lt;img src=&#34;https://github-readme-stats-chi-one-17.vercel.app/api/top-langs/?username=ttf248&amp;amp;hide_title=true&amp;amp;hide=html,javascript,css&amp;amp;layout=compact&amp;amp;bg_color=0000&amp;amp;text_color=8A919F&amp;amp;locale=cn&amp;amp;role=OWNER,COLLABORATOR,ORGANIZATION_MEMBER&amp;amp;timstamp=1746608356&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Top Languages&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;プルリクエスト元のurl&#34;&gt;プルリクエスト元のURL
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/anuraghazra/github-readme-stats/pull/2459&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Adds the ability to include data from organization repositories&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;フォークされたリポジトリへのpull-requestのマージ&#34;&gt;フォークされたリポジトリへのPull Requestのマージ
&lt;/h2&gt;&lt;p&gt;特定の &lt;strong&gt;Pull Request (PR)&lt;/strong&gt; をあなたの &lt;strong&gt;fork 的仓库&lt;/strong&gt; に統合する方法はいくつかあり、それは何をしたいかによります。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;フォークにPRをマージしますか、それとも？&lt;/li&gt;
&lt;li&gt;他の人のフォークからPRをあなたのフォークにマージする、または&lt;/li&gt;
&lt;li&gt;フォークされたリポジトリからのプルリクエストをマージする (例：誰かがあなたのフォークにプルリクエストを提出した場合)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;まず、最も一般的なシナリオをご紹介します：&lt;strong&gt;你 fork 了一个仓库，想把上游的某个 PR 合并到你的 fork&lt;/strong&gt;。手順は以下の通りです👇：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;方法一コマンドライン方式最も汎用的&#34;&gt;方法一：コマンドライン方式（最も汎用的）
&lt;/h3&gt;&lt;h4 id=&#34;ステップ1自分のフォークをクローンする&#34;&gt;ステップ1：自分のフォークをクローンする
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/你的用户名/仓库名.git
cd 仓库名
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;ステップ-2upstreamオリジナルリポジトリのアドレスを追加&#34;&gt;ステップ 2：upstream（オリジナルリポジトリのアドレス）を追加
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git remote add upstream https://github.com/原作者用户名/仓库名.git
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;ステップ3アップストリームのprブランチをリベースする&#34;&gt;ステップ3：アップストリームのPRブランチをリベースする。
&lt;/h4&gt;&lt;p&gt;PR番号（例：PR#123）を見つけます。&lt;/p&gt;
&lt;p&gt;このPRのコードは、次のように取得できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git fetch upstream pull/123/head:pr-123
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;ステップ４ブランチの切り替えとマージ&#34;&gt;ステップ４：ブランチの切り替えとマージ
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git checkout main    # 或者你自己的目标分支
git merge pr-123
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;もしすべてが正常であれば、あなたのフォークしたGitHubリポジトリにプッシュできます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git push origin main
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;方法二github-网页界面简单但有限-第二の方法githubウェブインターフェース簡単だが機能は限られている&#34;&gt;方法二：GitHub 网页界面（简单但有限） 第二の方法：GitHubウェブインターフェース（簡単だが機能は限られている）
&lt;/h3&gt;&lt;p&gt;GitHubのウェブページで、あるPRがアップストリームリポジトリへのものである場合、あなたは：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PRページにアクセスしてください。&lt;/li&gt;
&lt;li&gt;右上隅の「&lt;strong&gt;Commits&lt;/strong&gt;」または「&lt;strong&gt;Files changed&lt;/strong&gt;」をクリックして、このPRがどのブランチに基づいているかを確認してください。&lt;/li&gt;
&lt;li&gt;あなたのフォークページで新しいブランチを作成し、手動でPRのコミットをcherry-pickしてください。（Gitの知識が必要です。）&lt;/li&gt;
&lt;li&gt;または「&lt;strong&gt;Open in GitHub Desktop&lt;/strong&gt;」をクリックし、GUIツールで結合してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;-他の人があなたのフォークにprをリクエストしてきた場合&#34;&gt;🚀 他の人があなたのフォークにPRをリクエストしてきた場合。
&lt;/h3&gt;&lt;p&gt;PRページに直接入り、「&lt;strong&gt;Merge pull request&lt;/strong&gt;」ボタンをクリックしてください。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;今の状況（例えばPRリンクや、ウェブページかコマンドラインか）に合わせて、手順を詳しく説明しましょうか？具体的なURLを送っていただければ、一番簡単な方法を分析します。&lt;/p&gt;</description>
        </item>
        <item>
        <title>コミットメッセージの修正履歴（Git）</title>
        <link>https://ttf248.life/ja/p/git-modify-commit-message/</link>
        <pubDate>Wed, 07 May 2025 18:38:31 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/git-modify-commit-message/</guid>
        <description>&lt;p&gt;スクリプトは、git filter-branch を使用して、Git の履歴コミットの作成者情報を一括で修正するものです。&lt;/p&gt;
&lt;p&gt;提供されたスクリプトは、Git リポジトリの過去のコミットをまとめて変更するためのもので、全体的なコンセプトは正しいですが、(&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 的 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; 中使用数组（如 &lt;strong&gt;INLINE_CODE_2&lt;/strong&gt;）可能会导致兼容性问题，因为某些 shell 环境（如 &lt;strong&gt;INLINE_CODE_3&lt;/strong&gt;）では配列構文はサポートされていません。&lt;/p&gt;
&lt;p&gt;互換性を高めるため、配列をスペースで区切られた文字列に置き換え、&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; ループを使用して各古いメールアドレスを反復処理することを推奨します。以下は修正後のスクリプト例です。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh

git filter-branch --env-filter &#39;
OLD_EMAILS=&amp;quot;TianlongXiang51@gmail.com nick@qq.com tianlongxiang51@gmail.com&amp;quot;
CORRECT_NAME=&amp;quot;tianlong.xiang&amp;quot;
CORRECT_EMAIL=&amp;quot;tianlong.xiang@foxmail.com&amp;quot;

for OLD_EMAIL in $OLD_EMAILS
do
    if [ &amp;quot;$GIT_COMMITTER_EMAIL&amp;quot; = &amp;quot;$OLD_EMAIL&amp;quot; ]
    then
        export GIT_COMMITTER_NAME=&amp;quot;$CORRECT_NAME&amp;quot;
        export GIT_COMMITTER_EMAIL=&amp;quot;$CORRECT_EMAIL&amp;quot;
    fi
    if [ &amp;quot;$GIT_AUTHOR_EMAIL&amp;quot; = &amp;quot;$OLD_EMAIL&amp;quot; ]
    then
        export GIT_AUTHOR_NAME=&amp;quot;$CORRECT_NAME&amp;quot;
        export GIT_AUTHOR_EMAIL=&amp;quot;$CORRECT_EMAIL&amp;quot;
    fi
done
&#39; --tag-name-filter cat -- --branches --tags
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;スクリプト実行前に、予期せぬ事態を防ぐため、リポジトリのバックアップを推奨します。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;この操作はGitの履歴を上書きし、コミットの作成者情報を変更するため、コミットハッシュ値が変化する可能性があります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;変更をリモートリポジトリにプッシュ済みの場合は、強制プッシュが必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git push --force --tags origin &#39;refs/heads/*&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;強制プッシュは慎重に行ってください。特に複数人で共同作業しているプロジェクトでは、他者に影響を与えないよう注意が必要です。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;倉庫内の重複しない著者メールアドレスを統計する。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git log --format=&#39;%an &amp;lt;%ae&amp;gt;&#39; | sort -u
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>暇つぶしに、中国の水墨画風のテーマをデザインしてみようかな。</title>
        <link>https://ttf248.life/ja/p/chinese-ink-style-theme/</link>
        <pubDate>Tue, 08 Apr 2025 03:42:47 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/chinese-ink-style-theme/</guid>
        <description>&lt;p&gt;カラフルなホームページを見飽きたので、急にシンプルなデザインにしたくなり、中国の水墨画風のテーマを作りたい。&lt;/p&gt;
&lt;p&gt;スタイルシートは現在、要素ごとに特定のスタイルが設定され、テーマのデフォルトスタイルを上書きするように変更されています。&lt;/p&gt;
&lt;p&gt;再構築なしでAIに直接新しいテーマを生成させると、結果は非常に不安定です。&lt;/p&gt;
&lt;p&gt;たまたまtrae claudeの大規模言語モデルの待ち行列に遭遇し、VSCodeエージェントモードに切り替えたところ、効果は非常に悪く、修正したものはデザイン性が全くない。&lt;/p&gt;
&lt;p&gt;結局、やはり自分自身がフロントエンドを理解していないため、AIに効果的にタスクを分解して割り当てることができない。&lt;/p&gt;</description>
        </item>
        <item>
        <title>コードを書かずに、カスタム銘柄選択モジュールを設計・開発する。</title>
        <link>https://ttf248.life/ja/p/no-code-design-develop-custom-stock-module/</link>
        <pubDate>Thu, 27 Feb 2025 23:20:39 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/no-code-design-develop-custom-stock-module/</guid>
        <description>&lt;p&gt;先月、Cursor を試用しましたが、無料枠の制限により、複雑な機能開発は行わず、簡単なテストにとどまりました。その際、ByteDance も同様の商品をリリースしていることがわかり、両者とも基盤となる大規模言語モデルは Claude-3.5 です。&lt;/p&gt;
&lt;p&gt;バイトのプロダクトTrae、まずMac版が先行してリリースされ、今年の2月になってようやくWindows版も登場しました。大手企業のものはやはり良いですね。無料で利用でき、お金を払わずにClaude-3.5を無制限に使えるのは素晴らしいです。このモデルの効果はなかなか良いです。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;結局、K線図の開発でつまずいてしまいました。Reactの知識がほとんどないため、諦めざるを得ませんでした。開発を続けたい場合は、筆者がフロントエンドの基礎知識を補強し、タスクをより細かく分割する必要があります。いきなり「K線図の開発」という大きな課題を与えるのではなくです。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;発見された問題&#34;&gt;発見された問題
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;海外のAIモデルを利用するため、Vue3 + Element-Plus の学習データが不足しているため、React をフロントエンドフレームワークとして採用しました。&lt;/li&gt;
&lt;li&gt;可能性はありますが、文法的な誤りが発生する可能性があり、手動での修正が必要です。&lt;/li&gt;
&lt;li&gt;複雑な問題の解決には、手動での指示が必要です。&lt;/li&gt;
&lt;li&gt;コード構造の最適化には人的指導が必要です。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最も時間がかかったのは、フロントエンドコードをコンテナにパッケージ化することです。筆者は全くの初心者__INLINE_CODE_0__ __INLINE_CODE_1__で、概念がありませんでした。途中で助けを借りたおかげで、ようやく対応するロジックを理解することができました。フロントエンドの開発環境（devモード）とビルドモードでは、コードのチェックに関して大きな違いがあります。バックエンドデータベースとサービスのコンテナスクリプトは、合わせて5分で終わりました。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AI 目前更多的提高开发的效率，你有基础是最好的，并不是 AI 会帮你解决所有的问题&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;倉庫住所&#34;&gt;倉庫住所
&lt;/h2&gt;&lt;p&gt;タイトル通り、今回は書かずにAIと直接対話し、独自の株式モジュールを設計・開発します。最終的に何ができるか見てみましょう。&lt;/p&gt;
&lt;p&gt;倉庫住所：&lt;a class=&#34;link&#34; href=&#34;https://github.com/ttf248/trae-demo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ttf248/trae-demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;詳細な使用方法は、リポジトリのREADME.mdファイルを参照してください。&lt;/p&gt;
&lt;p&gt;倉庫には多くの提出記録が含まれており、そのほとんどが私とTraeとの会話記録、そして私がTraeのいくつかの機能をテストした記録です。それぞれの機能を実現するために手動介入を行ったかどうかを注記しています。&lt;/p&gt;
&lt;h2 id=&#34;prompt&#34;&gt;Prompt
&lt;/h2&gt;&lt;p&gt;プロジェクトはゼロから作成され、以下にプロンプトを示します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;基于项目原型图，开发功能：自选股，需要支持合约的新增、删除、修改、查询。自选股界面需要展示基础的行情数据。支持多个不同的市场切换。

前端：react
后端：golang gin gorm
数据库：PostgreSQL

服务端需要支持跨域请求，同时需要考虑数据的校验和错误处理，如果后端服务不可用，前端需要告警提示。

后端需要展示请求和应答的日志；前端也打印通讯的日志，方便排查问题。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ユーザーインターフェースとインタラクションの最適化&#34;&gt;ユーザーインターフェースとインタラクションの最適化
&lt;/h2&gt;&lt;p&gt;フロントエンドの設計は完全にGrokに依存しており、まずTraeでプロダクトの原型を作成しましたが、デザイン性は欠けていました。使用しているモデルはコード生成能力は高いものの、他の能力が弱いので、Grokを使ってフロントエンドUIを最適化する必要があります。&lt;/p&gt;
&lt;p&gt;現在のインターフェースのスクリーンショットをGrokにアップロードし、UI最適化のアドバイスをもらう。その中から手動で評価したものをTaeにコピーして実行し、効果を確認する。&lt;/p&gt;
&lt;h3 id=&#34;技術スタック&#34;&gt;技術スタック
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;フロントエンド：React + TypeScript&lt;/li&gt;
&lt;li&gt;バックエンド：Golang + Gin + GORM&lt;/li&gt;
&lt;li&gt;データベース：PostgreSQL 17&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;システムアーキテクチャ&#34;&gt;システムアーキテクチャ
&lt;/h2&gt;&lt;h2 id=&#34;バックエンドアーキテクチャ&#34;&gt;バックエンドアーキテクチャ
&lt;/h2&gt;&lt;p&gt;バックエンドはGolangのGinフレームワークでRESTful APIを実装しており、主なモジュールは以下の通りです。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;GORM を ORM フレームワークとして使用する。&lt;/li&gt;
&lt;li&gt;環境変数でデータベース接続を設定することを推奨します。&lt;/li&gt;
&lt;li&gt;自動データベーステーブル移行&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;RESTful API 設計&lt;/li&gt;
&lt;li&gt;統一されたエラー処理メカニズム&lt;/li&gt;
&lt;li&gt;内蔵リクエストログ&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ローカル開発環境でのクロスドメインをサポート&lt;/li&gt;
&lt;li&gt;設定可能なCORSポリシー&lt;/li&gt;
&lt;li&gt;Cookie 跨ドメイン対応&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;フロントエンドアーキテクチャ&#34;&gt;フロントエンドアーキテクチャ
&lt;/h2&gt;&lt;p&gt;React + TypeScript を使用して構築され、以下の機能を実装しています：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;株式リスト表示&lt;/li&gt;
&lt;li&gt;銘柄選択管理&lt;/li&gt;
&lt;li&gt;市場データ表示&lt;/li&gt;
&lt;li&gt;エラー通知メカニズム&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>プロトバッファのゼロ値の落とし穴：デフォルト値がビジネスロジックを密かに破滅させる</title>
        <link>https://ttf248.life/ja/p/protobuf-zero-value-traps/</link>
        <pubDate>Thu, 20 Feb 2025 15:26:51 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/protobuf-zero-value-traps/</guid>
        <description>&lt;p&gt;米国株には3つの取引時間帯があり、それぞれ盤前、盤中、盤後です。データインターフェースは、可能な限り帯域幅を節約するため、最初に全量データを送信し、その後はすべてのフィールドで増分データのみをプッシュするロジックを採用しています。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;なぜ最適な方法を使わないのか？異なるプロジェクトチームが関わっていて、すでに何年も稼働しているものもある。当方は新規連携なので、できる限り互換性を保つしかない。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;一連の問題&#34;&gt;一連の問題
&lt;/h2&gt;&lt;p&gt;概要だけ見れば、まだ問題なさそうに見えるかもしれない。しかし、システムアーキテクチャに問題が持ち込まれ、一連の問題を引き起こしている。先の問題を解決したと思えば、また新しい問題が発生し、それは以前の問題が原因だ。&lt;/p&gt;
&lt;h3 id=&#34;取引期間を識別できません&#34;&gt;取引期間を識別できません。
&lt;/h3&gt;&lt;p&gt;既知ディスク上の段階定義は、&lt;code&gt;protobuf&lt;/code&gt; 中定义为 0，但是在收到数据的时候由于是增量推送，业务方无法有效识别这个__INLINE_CODE_1__がデフォルト値か、実際のビジネス値かを指すものとします。&lt;/p&gt;
&lt;p&gt;毎回0を受け取ると、この0が新しいクォート設定の値なのか、protobufのデフォルト値なのかを判断できない。&lt;/p&gt;
&lt;h3 id=&#34;オプション導入&#34;&gt;オプション導入
&lt;/h3&gt;&lt;p&gt;Since protobuf release 3.15, proto3 supports using the optional keyword (just as in proto2) to give a scalar field presence information&lt;/p&gt;
&lt;p&gt;グループ内の通信プロトコルは、&lt;strong&gt;&lt;em&gt;5&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;3&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;6&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;4&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;7&lt;/em&gt;&lt;/strong&gt; に基づいており、プロジェクトの基盤が静的ライブラリとして提供されているため、コンパイルチェーン全体をアップグレードする必要があり、コストは非常に高い。&lt;/p&gt;
&lt;h3 id=&#34;gccのバージョン問題&#34;&gt;GCCのバージョン問題
&lt;/h3&gt;&lt;p&gt;なんとか案を思いついたものの、基盤で2つの異なるバージョンをリリースし、可能な限り &lt;code&gt;protobuf&lt;/code&gt; 新版本的编译依赖传播。但是在编译的时候，发现 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; 版本太低，不支持 &lt;strong&gt;INLINE_CODE_2&lt;/strong&gt; の新機能を抑制する。&lt;/p&gt;
&lt;p&gt;チーム内でよく使用されるサーバーの種類：CentOS 7、CentOS 8。CentOS 7 のデフォルトバージョンは 7.4 以上であるため、CentOS 7 はサポートできません。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=82461&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Bug 82461 - [7 Regression] Temporary required for brace-initializing (non-literal-type) member variable&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;最終、関連サービスのデプロイやコンパイルサーバーをCentOS 8に移行することで、この問題が解決した。&lt;/p&gt;
&lt;h2 id=&#34;合理な列挙&#34;&gt;合理な列挙
&lt;/h2&gt;&lt;p&gt;問題全体を振り返ると、実はもっと簡単で効率的な解決策があります。それは、列挙の定義を0からではなく1から始めるように調整することです。これにより、デフォルト値とビジネス値を効果的に区別でき、上記の様々な問題を回避できます。&lt;/p&gt;
&lt;h3 id=&#34;なぜ1から始めるのが妥当だろうか&#34;&gt;なぜ1から始めるのが妥当だろうか？
&lt;/h3&gt;&lt;p&gt;__INLINE_CODE_0__において、列挙型のデフォルト値は常に0に固定されています。もしビジネス上の意味を持つ値を0として定義した場合（例えば「盤中」）、増分プッシュ時に受信した0がビジネス値なのか未設定のデフォルト値なのかを判断することができません。しかし、列挙型を1から開始して定義すれば、0を有意義でないデフォルト値や「不明」な状態として保持できるため、問題は解決されます。&lt;/p&gt;
&lt;p&gt;推奨される実践：&lt;/p&gt;
&lt;p&gt;プロトバッファの列挙型を設計する際は、常に 0 を無意味なデフォルト値として定義してください（例：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 或 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt;）。
実際のビジネス値を1から割り当て、デフォルト値の0と区別する。&lt;/p&gt;
&lt;p&gt;この小さな調整により、取引セッションの識別問題を解決するだけでなく、将来のプロトコル設計のための貴重な経験となりました。&lt;/p&gt;</description>
        </item>
        <item>
        <title>バックエンドサービスTCP通信異常のトラブルシューティング</title>
        <link>https://ttf248.life/ja/p/backend-service-tcp-communication-troubleshooting/</link>
        <pubDate>Fri, 14 Feb 2025 22:54:13 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/backend-service-tcp-communication-troubleshooting/</guid>
        <description>&lt;p&gt;ビジネスモデル：バックエンドサービスはTCP経由でグループのマーケットデータゲートウェイと接続を確立します。接続時にはまず認証リクエストを送信し、その後、継続的にハートビートパケットを送信して接続状態を維持します。
しかし、ある日、サービス接続が切れたという警告メッセージを受け取りました。詳細なログ調査の結果、バックグラウンドサービスは継続的にハートビートを送信しているものの、相手からの応答はなく、それでも接続は切断されませんでした。&lt;/p&gt;
&lt;h2 id=&#34;現場概説&#34;&gt;現場概説
&lt;/h2&gt;&lt;p&gt;元々会社で残業中、プロジェクトの進捗を詰めていたところ、仕事グループに突然警告メッセージが飛び込んできた。最初はよくあるエラーかと思ったが、ネットワークタイムアウトで心跳送信が失敗し、結果としてサービス接続が切れたのだろうと推測した。しかし、ログを詳しく調査した結果、実際はそうではなかった。バックエンドから認証ログインメッセージは送信されているものの、応答がないまま、心跳パケットは継続的に送られ続けており、相手側からは一切の心跳データが返されていない。ログを詳細に分析した結果、以下の重要な問題点が明らかになった：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;認証メッセージに対する応答なし：相手のシステムが再起動中の可能性が高く、認証メッセージがタイムリーに処理されなかったと考えられます。&lt;/li&gt;
&lt;li&gt;認証に失敗したにも関わらずハートビートデータが送信される事象について調査した結果、プログラムのロジック上の欠陥であることが判明しました。ハートビート送信関数における判断ロジックに問題があり、接続状態のみを検証し、認証状態の検証を怠っていました。&lt;/li&gt;
&lt;li&gt;サービス接続が切断されない場合、切断を促すことで再接続メカニズムを起動し、再度認証メッセージを送信できます。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;現在、まだ最後の解決すべき問題が残っています — なぜサービスが切断されていないのかです。この問題を解決するには、より詳細な調査が必要です。&lt;/p&gt;
&lt;h2 id=&#34;ネットワークデータパケットの解析&#34;&gt;ネットワークデータパケットの解析
&lt;/h2&gt;&lt;p&gt;ネットワークデータパケットを捕捉し、さらに分析するために。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/backend-service-tcp-communication-troubleshooting/20250220151952.png&#34;
	width=&#34;1126&#34;
	height=&#34;202&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;tcpdump&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;557&#34;
		data-flex-basis=&#34;1337px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;グラフのデータから、心拍は常に正常に送信されていることがわかりますが、相手サーバーからの応答はなく、代わりに &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; が与えられているため、接続は自動的に切断されません。&lt;/p&gt;
&lt;h2 id=&#34;一般的なフラグの説明&#34;&gt;一般的なフラグの説明
&lt;/h2&gt;&lt;p&gt;TCPプロトコルにおいて、&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;（Push）和 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt;（Acknowledgment）は、データ転送とフロー制御を管理する上で重要なフラグです。その役割は以下の通りです。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;1-pshpush-flag&#34;&gt;&lt;strong&gt;1. PSH（Push Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;:
受信側は、バッファ内のデータを可能な限り速やかに上位アプリケーションへプッシュし、オペレーティングシステムバッファに一時保存しないこと。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;典型场景&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;クライアントがリクエストを送信する際（例えば、&lt;code&gt;GET /index.html&lt;/code&gt;）会设置 &lt;code&gt;PSH&lt;/code&gt;）、サーバーに即時応答を期待します。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;入力時に毎回 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; がトリガーされ、入力文字がリアルタイムで送信されます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;動画ストリーミングやオンラインゲームなどの低遅延シーンでは、&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; を用いて遅延を削減することがあります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PSH&lt;/code&gt; は必須ではなく、受信側は無視しても構いません（ただし、データは通常通り処理する必要があります）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;送信者は &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; を設定しない場合があるため、受信者は自身のバッファリングポリシーに基づいてデータをいつプッシュするか決定します。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2-ackacknowledgment-flag&#34;&gt;&lt;strong&gt;2. ACK（Acknowledgment Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;:
受信確認（前続データセグメントの受信が完了したことを示す）であり、次を受信するべきバイトのシーケンス番号です。これはTCP信頼性のある転送の中核をなすメカニズムです。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;工作原理&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;受信者は、送信者がデータセグメントを送信する際に添付する情報（&lt;code&gt;ACK&lt;/code&gt; 值（例如 &lt;code&gt;ACK = 序列号 + 数据长度&lt;/code&gt;）を持つ。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;受信側はデータを受信後、__INLINE_CODE_0__メッセージを生成し、受信確認済みデータのシーケンス番号を示す。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;送信者は、対応する &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; を受信した場合のみ、未確認のデータを再送します。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;送信者は、インラインのイタリック体5、太字4、インラインのイタリック体6、太字3、インラインのイタリック体7を送信しました。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;受信者が &lt;code&gt;100~199&lt;/code&gt; 中的某些数据，会通过 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; を受け取らない場合、送信者は再送を通知する。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;申し訳ありませんが翻訳する中国語のテキストが提供されていませんテキストを提供してください&#34;&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。
&lt;/h3&gt;&lt;p&gt;TCPパケットにおいて、&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 和 __INLINE_CODE_1__は同時に出現することがあり、主に以下の状況で確認されます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;HTTP 请求响应&lt;/strong&gt;:
クライアントが、&lt;code&gt;POST&lt;/code&gt; 请求时（含数据），会设置 &lt;code&gt;PSH&lt;/code&gt; 和 &lt;strong&gt;INLINE_CODE_2&lt;/strong&gt;（以前の応答を確認）を送信します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Client → Server: SYN, ACK=1 → 建立连接
Client → Server: PSH, ACK=1, 数据 → 发送请求数据
Server → Client: PSH, ACK=数据长度+1 → 返回响应
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SSH 握手后传输命令&lt;/strong&gt;:
クライアントがコマンドを入力後、&lt;code&gt;PSH&lt;/code&gt;BOLD_2&lt;code&gt;ACK&lt;/code&gt; が含まれるデータセグメントを送信し、コマンドの即時伝送とサーバーでの処理を保証します。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;申し訳ありませんが翻訳する中国語のテキストが提供されていませんテキストを提供してください-1&#34;&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;フラグ&lt;/th&gt;
&lt;th&gt;名&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;同期　初期化接続（三次握手）&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FIN&lt;/td&gt;
&lt;td&gt;終了&lt;/td&gt;
&lt;td&gt;エレガントな接続のクローズ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;リセット&lt;/td&gt;
&lt;td&gt;強制終了 (異常時)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;URG&lt;/td&gt;
&lt;td&gt;緊急&lt;/td&gt;
&lt;td&gt;緊急ポインタをマークする（ほとんど使用しない）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h3 id=&#34;申し訳ありませんが翻訳する中国語のテキストが提供されていませんテキストを提供してください-2&#34;&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;遅延の低減に焦点を当てる。&lt;/li&gt;
&lt;li&gt;データの完全性と順序を保つことが重要です。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;両者は協調して働き、TCPプロトコルの効率と信頼性のバランスを取っています。&lt;/p&gt;</description>
        </item>
        <item>
        <title>ローカルにDeepSeek-R1をデプロイ</title>
        <link>https://ttf248.life/ja/p/ollama-local-deployment-deepseek-r1/</link>
        <pubDate>Fri, 07 Feb 2025 22:41:02 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/ollama-local-deployment-deepseek-r1/</guid>
        <description>&lt;p&gt;Ollamaは、ユーザーがローカルで大規模言語モデル（LLM）を実行・デプロイできるように設計されたオープンソースのAIツールです。クラウドサービスに依存することなく、GPTのようなモデルをローカルマシン上で利用するための、便利で効率的な方法を提供し、様々なモデルに対応しています。また、パフォーマンスの最適化に重点を置いており、リソースが限られたデバイスでもスムーズに動作するようにしています。&lt;/p&gt;
&lt;p&gt;Ollama を使用すれば、ユーザーはテキストベースのAIアプリケーションを利用でき、データプライバシーや高額なAPI利用料金を心配することなく、ローカルにデプロイされたモデルと対話できます。様々なモデルをコマンドラインインターフェース（CLI）から呼び出し、自然言語処理や質問応答などのタスクを実行できます。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Ollamaは様々なモデルの試用に向いていますが、Windows版をテストしたところ、ハードウェアの性能を十分に発揮できませんでした。原因はWindows版にあるのかもしれません。Linux版の方が良いかもしれません。32bパラメータのモデルをデプロイしても、メモリやGPUの負荷が低いにも関わらず、応答速度が非常に遅いです。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;ハードウェア概要&#34;&gt;ハードウェア概要
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;OS：Win11&lt;/li&gt;
&lt;li&gt;CPU：i7-10700K&lt;/li&gt;
&lt;li&gt;メモリ：40GB&lt;/li&gt;
&lt;li&gt;グラフィックボード：RTX 3060 12GB&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;環境準備&#34;&gt;環境準備
&lt;/h2&gt;&lt;p&gt;新たにシステム環境変数を追加し、今後の利用を容易にします。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;set OLLAMA_MODELS=E:\ollama&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
この変数は、Ollamaモデルの保存パスを指定します。&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; はフォルダパスであり、すべてのローカルモデルファイルがそのディレクトリに格納されます。Ollamaは、このパスに基づいてダウンロードまたはデプロイした言語モデルを読み込み使用します。モデルファイルを別の場所に保存する場合は、このパスを変更するだけです。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;set OLLAMA_HOST=127.0.0.1:8000&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
この環境変数は、Ollama サービスが利用するホストとポートを設定します。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; はローカルアドレス（localhost）を意味し、Ollama サービスはローカルからのリクエストのみを待ち受けます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; は、指定されたポート番号で、Ollamaサービスが8000ポートでリクエストを待機し処理することを示します。必要に応じてポート番号を変更できますが、そのポートが他のアプリケーションによって使用されていないことを確認してください。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;set OLLAMA_ORIGINS=*&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
この環境変数は、Ollama サービスにアクセスできるリクエストのソースを制御します。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;あらゆるソース（すべてのドメインとIPアドレス）からのアクセスを許可します。これは通常、開発およびデバッグ環境で使用され、本番環境ではセキュリティを高めるために、特定のドメインまたはIPのみがサービスにアクセスできるように制限することが一般的です。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;deepseek-r1-モデルのデプロイ&#34;&gt;DeepSeek-R1 モデルのデプロイ
&lt;/h2&gt;&lt;p&gt;インストールは簡単ですので、詳細は割愛します。&lt;/p&gt;
&lt;p&gt;インストール後の検証：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\core&amp;gt;ollama -v
ollama version is 0.5.11
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;モデルのデプロイについては、公式ウェブサイトのモデルページを参照し、対応するパラメータを持つモデルを選択してください。&lt;/p&gt;
&lt;p&gt;14bパラメータは会話コンテキストを効果的に記憶できるが、より小さいパラメータのバージョンでは記憶できない。32bパラメータ版はローカル環境での動作が重く、さらなるテストは実施していない。&lt;/p&gt;
&lt;h2 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.ollama.com/library/deepseek-r1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.ollama.com/library/deepseek-r1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://mp.weixin.qq.com/s/SPEvYTmTBxhoEkJqm1yPmw&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mp.weixin.qq.com/s/SPEvYTmTBxhoEkJqm1yPmw&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/x18990027/article/details/145368094&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/x18990027/article/details/145368094&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>PowerShell 7 と永続化設定コマンドライン予測ビュー</title>
        <link>https://ttf248.life/ja/p/powershell-7-persisting-settings-command-line-prediction-view/</link>
        <pubDate>Fri, 07 Feb 2025 22:19:12 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/powershell-7-persisting-settings-command-line-prediction-view/</guid>
        <description>&lt;p&gt;Linuxのzshに慣れていましたが、ブログを書こうとしてPowerShell 7がコマンドライン予測ビューの永続化もサポートしていることを知り、試してみたところ、なかなか便利でした。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;何らかの操作をしたのか、機能が有効になったのかは不明だが、とにかく存在するようになった。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;現代の多様なオペレーティングシステム環境において、システム管理者や開発者は、システム管理および自動化タスクに対応できる、クロスプラットフォームで効率的かつ強力なツールを求めています。PowerShell 7はまさに、そうした注目を集めているツールであり、強力なスクリプト作成機能に加え、Windows、Linux、macOSといった複数のオペレーティングシステム上で動作し、ユーザーに前例のない利便性をもたらします。&lt;/p&gt;
&lt;h2 id=&#34;powershell-7クロスプラットフォームの強力なツール&#34;&gt;PowerShell 7：クロスプラットフォームの強力なツール
&lt;/h2&gt;&lt;h3 id=&#34;クロスプラットフォーム機能&#34;&gt;クロスプラットフォーム機能
&lt;/h3&gt;&lt;p&gt;PowerShell 7は、プラットフォームの制約を取り払い、Windows環境でのエンタープライズサーバー管理、Linux環境でのシステム運用、macOS上での日常的な開発タスクまで、統一されたPowerShell 7ツールで利用できます。これにより、作業効率が向上し、プラットフォームの違いによる学習コストや操作の複雑さが軽減されます。&lt;/p&gt;
&lt;h3 id=&#34;強力な機能&#34;&gt;強力な機能
&lt;/h3&gt;&lt;p&gt;強力なスクリプト作成機能を備え、オブジェクト指向プログラミング、関数、モジュールなどの高度なプログラミング機能に対応しています。PowerShell 7を通じて、ユーザーはファイルシステムを容易に操作し、ファイルの作成、削除、コピー、移動などを行うことができます。レジストリへのアクセスと修正も可能で、システムの構成を詳細に調整できます。また、プロセスやサービスを管理し、システム動作状態の効率的な監視と制御を実現します。さらに、PowerShell 7はActive Directoryでのユーザーおよび権限管理、Azureクラウドプラットフォーム上でのリソース割り当てと管理など、様々なWindowsおよび非Windows技術との連携も可能です。&lt;/p&gt;
&lt;h3 id=&#34;オープンソースエコシステム&#34;&gt;オープンソースエコシステム
&lt;/h3&gt;&lt;p&gt;PowerShell 7はオープンソースであり、その特性により、世界中の開発者や愛好家が積極的に開発と改善に参加できます。多数のオープンソースモジュールやツールが次々と登場し、PowerShell 7 の機能と応用範囲を広げています。ユーザーはニーズに合わせてオープンソースコミュニティから適切なモジュールを見つけたり、コードを寄稿してコミュニティ全体の発展に貢献したりすることができます。&lt;/p&gt;
&lt;h3 id=&#34;互換性と安定性&#34;&gt;互換性と安定性
&lt;/h3&gt;&lt;p&gt;PowerShell 7は、古いバージョンのPowerShellとの互換性を維持しつつ、多くの新機能と改善を導入しています。これらの改善はパフォーマンスの向上に加え、安定性も強化しており、ユーザーはよりスムーズにタスクを完了でき、ソフトウェアの不具合による中断を減らすことができます。&lt;/p&gt;
&lt;h2 id=&#34;コマンドライン予測ビューを開く&#34;&gt;コマンドライン予測ビューを開く
&lt;/h2&gt;&lt;p&gt;PowerShell 7の多くの便利な機能の中でも、__INLINE_CODE_0__コマンドは、ユーザーのコマンドライン入力体験を向上させる実用的なツールです。&lt;/p&gt;
&lt;p&gt;コマンドの実行なしでもオートコンプリートは機能しますが、それは行内での補完に限られます。有効にすると予測ビューが表示され、考えられるすべての補完候補をリスト形式で表示します。ユーザーは上下キーで必要な候補を選択でき、入力の正確性と効率が向上します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/powershell-7-persisting-settings-command-line-prediction-view/20250207222546.png&#34;
	width=&#34;814&#34;
	height=&#34;205&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;powershell7&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;397&#34;
		data-flex-basis=&#34;952px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;コマンドを永続的に有効にする方法&#34;&gt;コマンドを永続的に有効にする方法
&lt;/h2&gt;&lt;p&gt;PowerShellを起動するたびに &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; コマンドが有効になるようにするには、PowerShellのプロファイルにそれを追加できます。PowerShellのプロファイルは特別なスクリプトで、PowerShellの起動時に自動的に実行されます。&lt;/p&gt;
&lt;h3 id=&#34;設定構成ファイルパス&#34;&gt;設定構成ファイルパス
&lt;/h3&gt;&lt;p&gt;PowerShellでは、__INLINE_CODE_0__変数を使って設定ファイルのパスを確認できます。そのパスにファイルが存在しない場合、ユーザーは手動で作成できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo $PROFILE
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;設定ファイルを開く&#34;&gt;設定ファイルを開く
&lt;/h3&gt;&lt;p&gt;テキストエディタ（強力なNotepad++や軽量のVisual Studio Codeなど）で、__INLINE_CODE_0__変数から取得される設定ファイルパスに対応するファイルを開きます。&lt;/p&gt;
&lt;h3 id=&#34;追加命令&#34;&gt;追加命令
&lt;/h3&gt;&lt;p&gt;開いている設定ファイルに、&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; コマンドを追加してください。コマンドの記述ミスがないように注意し、設定ファイルが実行時に正しく有効になるようにしてください。&lt;/p&gt;
&lt;h3 id=&#34;設定ファイルを保存&#34;&gt;設定ファイルを保存
&lt;/h3&gt;&lt;p&gt;コマンドが完了したら、設定ファイルを保存し、テキストエディタを閉じます。これで、設定ファイルには毎回 PowerShell を起動する際に実行したいコマンドが含まれています。&lt;/p&gt;
&lt;h3 id=&#34;設定確認&#34;&gt;設定確認
&lt;/h3&gt;&lt;p&gt;現在のPowerShellウィンドウを閉じ、再起動します。新しく起動したPowerShellでコマンドを入力すると、コマンドライン入力予測ビューがリスト形式で表示されるはずです。これにより、設定が正常に適用されていることが確認できます。&lt;/p&gt;
&lt;p&gt;上記の手順を通じて、私たちは PowerShell 7 の強力な機能と特徴を深く理解するだけでなく、コマンドライン入力による予測ビューのスタイル設定によって操作性を向上させる方法や、これらの設定を持続的に有効にする方法も習得しました。これらの知識が、PowerShell 7 を使用する際にスムーズに作業を進め、様々なシステム管理および自動化タスクを効率的に完了できるよう役立つことを願っています。&lt;/p&gt;
&lt;h2 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/PowerShell/PowerShell/releases&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/PowerShell/PowerShell/releases&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.v2ex.com/t/911909&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.v2ex.com/t/911909&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>atopツールによるLinuxシステム指標の監視：インストール、設定と利用完全ガイド</title>
        <link>https://ttf248.life/ja/p/using-atop-to-monitor-linux-system-metrics-installation-configuration-and-usage-guide/</link>
        <pubDate>Thu, 06 Feb 2025 22:48:55 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/using-atop-to-monitor-linux-system-metrics-installation-configuration-and-usage-guide/</guid>
        <description>&lt;p&gt;Linuxシステム運用において、システムリソースとプロセス状態をリアルタイムかつ包括的に監視することは非常に重要です。atopは強力な監視ツールであり、この目標を容易に達成するのに役立ちます。本稿では、Linuxインスタンスにおけるatop監視ツールのインストール、設定、使用方法について詳細に説明します。&lt;/p&gt;
&lt;h2 id=&#34;一atopツール紹介&#34;&gt;一、atopツール紹介
&lt;/h2&gt;&lt;p&gt;atopは、Linuxシステムのリソースとプロセスを監視するためのツールです。システムおよびプロセスの活動を記録し、すべてのプロセスの実行状況を報告します。CPU、メモリ、ディスク、ネットワークなどのリソース使用状況やプロセス状態に関するデータを収集し、ログファイルとして保存できます。各プロセスについて、CPU使用率、メモリ増加量、ディスク使用率、優先度、ユーザー名、状態、終了コードなどの主要な情報を取得可能です。さらに、atopの設定ファイルを通じて、ログの収集頻度、ログファイルの保存パス、ローテーションポリシーなどのパラメータをカスタマイズできます。&lt;/p&gt;
&lt;h2 id=&#34;二atopツールのインストール&#34;&gt;二、atopツールのインストール
&lt;/h2&gt;&lt;p&gt;様々なLinuxディストリビューションでのatopのインストール方法は若干異なります。以下では、一般的なOSを例として説明します。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Alibaba Cloud Linux 3/2、CentOS 7/8、Fedora、Rocky Linux 9&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;実行インストールコマンド：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;atopサービスを開始します。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;Ubuntu / Debian&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ソフトウェアリポジトリの更新：&lt;/li&gt;
&lt;li&gt;実行インストールコマンド：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;atopサービスを開始します。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;CentOS Stream 9&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ダウンロードしてインストール：&lt;/li&gt;
&lt;li&gt;atopサービスを開始します。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;openSUSE&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;実行インストールコマンド：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;atopサービスを開始します。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;もし上記に挙げられているオペレーティングシステムに利用しているディストリビューションが含まれていない場合は、atop公式サイトでインストール情報を確認してください。&lt;/p&gt;
&lt;h2 id=&#34;監視期間とログ保持期間の設定&#34;&gt;監視期間とログ保持期間の設定
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Alibaba Cloud Linux 3/2、CentOS 7/8およびFedoraシステムでは、atopの構成ファイルは*&lt;strong&gt;；在Ubuntu、Debian和openSUSE系统中，配置文件是&lt;/strong&gt;*です。&lt;/li&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ログファイル記録オプションを制御します。デフォルトは空です。&lt;/li&gt;
&lt;li&gt;監視期間はデフォルトで600秒です。過去のログを追跡する場合は、必要に応じてこの頻度を調整することをお勧めします。&lt;/li&gt;
&lt;li&gt;ログ保持期間、デフォルト28日。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;斜体&lt;/em&gt;&lt;strong&gt;太字&lt;/strong&gt;&lt;em&gt;斜体&lt;/em&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;コマンドを実行して設定ファイルを開きます。&lt;/li&gt;
&lt;li&gt;Alibaba Cloud Linux 3/2、CentOS 7/8、Fedoraシステムにおいて：&lt;/li&gt;
&lt;li&gt;Ubuntu、Debian、openSUSE、CentOS Stream 9、Rocky Linux 9 システムにおいて：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;__INLINE_CODE_0__を選択して編集モードに入り、必要に応じて設定パラメータを調整します。例えば、監視サイクルを30秒に修正し、ログ保持期間を7日に設定し、ログパスはデフォルトのままにします。&lt;/li&gt;
&lt;li&gt;押して、保存して終了します。&lt;/li&gt;
&lt;li&gt;サービスを再起動して設定を有効にする：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;LOGOPTS=&amp;quot;&amp;quot;
LOGINTERVAL=30
LOGGENERATIONS=7
LOGPATH=/var/log/atop 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;四atopツールを使用する&#34;&gt;四、atopツールを使用する
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;対話型コマンドモードでは、以下のよく使用されるコマンドがあります。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;デフォルトの統合出力ビューに戻ります。&lt;/li&gt;
&lt;li&gt;プロセスの一覧を完全なコマンドラインと共に表示します。&lt;/li&gt;
&lt;li&gt;プロセスメモリ使用率で降順にフィルタリングします。&lt;/li&gt;
&lt;li&gt;プロセスディスク使用率で降順にフィルタリングします。&lt;/li&gt;
&lt;li&gt;プロセス資源の総合利用率で降順にフィルタリングします。&lt;/li&gt;
&lt;li&gt;プロセスネットワーク利用率で降順にフィルタリングします。&lt;/li&gt;
&lt;li&gt;次の監視収集ポイントへ移動します。&lt;/li&gt;
&lt;li&gt;前の監視ポイントへ移動します。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;斜体&lt;/em&gt;&lt;strong&gt;太字&lt;/strong&gt;&lt;em&gt;斜体&lt;/em&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ホスト名、情報サンプリングの日付と時刻。&lt;/li&gt;
&lt;li&gt;プロセス全体の実行状況。カーネルモードおよびユーザーモードの実行時間、プロセスの総数、各種状態のプロセス数などを含む。&lt;/li&gt;
&lt;li&gt;CPU全体の利用状況で、各フィールドの数値の合計は__INLINE_CODE_0__（NはCPUコア数）です。カーネルモード、ユーザーモード、割り込み、アイドル、ディスクI/O待ちなどの時間割合を含みます。&lt;/li&gt;
&lt;li&gt;CPU負荷状況：過去1分間、5分間、15分間の実行キューの平均プロセス数、コンテキストスイッチ回数、割り込み発生回数。&lt;/li&gt;
&lt;li&gt;メモリ使用状況。物理メモリ合計、空きメモリ、ページキャッシュメモリ、ファイルキャッシュメモリ、カーネル使用メモリなどを含む。&lt;/li&gt;
&lt;li&gt;スワップ領域の使用状況を示します。割り当てられた合計サイズと利用可能なスワップ領域のサイズが含まれます。&lt;/li&gt;
&lt;li&gt;仮想メモリのページング状況、例えばスワップインおよびスワップアウトされたページ数。&lt;/li&gt;
&lt;li&gt;ディスクの使用状況。各ディスクデバイスごとに1行で、デバイス識別子、ビジー状態の時間割合、読み書きリクエスト数を示します。&lt;/li&gt;
&lt;li&gt;ネットワーク状況を表示し、転送層のTCPとUDP、IP層、および各アクティブポートでの受信・送信パケットサイズを示します。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;5秒ごとにシステム指標を確認する。&lt;/li&gt;
&lt;li&gt;現在時刻の5分後（合計30回、10秒間隔）にシステム指標を確認します。&lt;/li&gt;
&lt;li&gt;現在時刻の10分後のシステム指標を確認し（10回、60秒間隔で）、結果をファイルに書き込む：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;起動後、データはデフォルトで__INLINE_CODE_0__ディレクトリに保存されます。確認する際は、指定した日付のログファイルが存在することを確認してください。存在しない場合、エラーが発生します。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;当日の履歴指標ログを確認：&lt;/li&gt;
&lt;li&gt;昨日のヒストリ指標ログを見る：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;指定日の過去の指標ログを確認します。例：2024年11月06日&lt;/li&gt;
&lt;li&gt;指定された日付から指定時間以降の履歴指標ログを表示します。例：2024年11月06日14:00以降：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;指定された日付範囲内の過去の指標ログを表示します。例えば、2024年11月5日の00:04～00:08：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;現在のシステムにおけるCPU使用率レポートを1分間（12回、5秒間隔で）：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当日指定時間帯のメモリ指標レポートを確認します。例：18:00～18:01。&lt;/li&gt;
&lt;li&gt;指定された日付の指定時間帯におけるメモリ指標レポートを確認します。例えば、2024年11月5日18:00～18:01：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;その他操作&#34;&gt;その他操作
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;毎日atop指標ログファイルを生成したい場合は、以下の手順を実行してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;必要に応じて、監視期間、ログ保持時間、およびログ保存パスを調整できます。&lt;/li&gt;
&lt;li&gt;コマンド実行で、毎日ログローテーション関連サービスの起動設定を行い、サービスを開始します。&lt;/li&gt;
&lt;li&gt;ビジネスがログ処理に複雑な要件を持つ場合、logrotateやカスタムスクリプトを組み合わせてログ管理を実現できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;加载可选的netatop内核模块&lt;/strong&gt;: ネットワーク利用率の監視が必要な場合は、netatopモジュール（atopではデフォルトでインストールされていません）をインストールします。例として、Alibaba Cloud Linux 3システムの場合：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;カーネル開発パッケージのインストールとコンパイルに必要なソフトウェア環境：&lt;code&gt;sudo yum install -y kernel-devel dkms elfutils-libelf-devel&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最新バージョンのnetatopソースコードを、指定のディレクトリにダウンロードします。&lt;/li&gt;
&lt;li&gt;ソースコードを解凍し、ソースディレクトリへ移動します。&lt;/li&gt;
&lt;li&gt;ソースコードからモジュールとデーモンを構築・インストール：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;netatopサービスを開始します。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;atopツールは機能が強力で柔軟性があり、適切なインストール、設定、利用によって、Linuxシステムの稼働状況をより深く理解し、潜在的な問題を早期に発見・解決できます。本稿が皆様のLinuxシステム監視スキル向上の一助となれば幸いです。&lt;/p&gt;
&lt;h2 id=&#34;参考リンク&#34;&gt;参考リンク
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Visual Studio で「非対応」の PDB ファイルを読み込む</title>
        <link>https://ttf248.life/ja/p/visual-studio-loading-unmatched-pdb-files/</link>
        <pubDate>Thu, 23 Jan 2025 20:04:33 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/visual-studio-loading-unmatched-pdb-files/</guid>
        <description>&lt;p&gt;Windows 環境で Visual Studio でプログラムをデバッグする際、pdb ファイルと実行ファイルが一致しない場合、「シンボルファイルを読み込めません」というエラーが表示されます。プログラムがクラッシュし、ダンプファイルが生成された場合でも、不一致の pdb ファイルが存在すると、Visual Studio は正常にクラッシュ現場に入りません。&lt;/p&gt;
&lt;h2 id=&#34;pdbファイルとは何か&#34;&gt;pdbファイルとは何か。
&lt;/h2&gt;&lt;p&gt;PDBファイルは、Microsoftが提供するデバッグ情報ファイルで、プログラムのデバッグに用いられます。PDBファイルには、プログラムのシンボルテーブル、ソースコードファイル名、行番号などの情報が含まれます。プログラムのコンパイル時に生成され、デバッグに使用されます。&lt;/p&gt;
&lt;h2 id=&#34;windbg-デバッグ&#34;&gt;WinDbg デバッグ
&lt;/h2&gt;&lt;p&gt;WinDbgは、Microsoftが提供するデバッグツールで、Windowsプログラムのデバッグに利用できます。WinDbgは互換性のないpdbファイルを読み込めますが、手動でのロードが必要です。__INLINE_CODE_0__コマンドを使用することで、互換性のないpdbファイルを強制的にロードできます。&lt;/p&gt;
&lt;p&gt;しかし、WinDbg は Visual Studio ほど使いやすくないので、Visual Studio でもミスマッチの PDB ファイルをロードできるようにしたいと考えています。&lt;/p&gt;
&lt;h2 id=&#34;visual-studio-で互換性のない-pdb-ファイルを読み込む&#34;&gt;Visual Studio で互換性のない PDB ファイルを読み込む
&lt;/h2&gt;&lt;p&gt;ソースコードは通常、gitで管理されているため、対応するバージョンのコードを容易に見つけられ、再コンパイルして対応するpdbファイルを生成できます。なぜロードできないのでしょうか？主な原因はメタデータが一致しないことです。&lt;/p&gt;
&lt;p&gt;小さなツールがあり、実行可能ファイルの情報に基づいてメタデータを修正し、Visual Studioが読み込める新しいpdbファイルを生成する。&lt;/p&gt;
&lt;p&gt;ダウンロード先：&lt;a class=&#34;link&#34; href=&#34;https://www.debuginfo.com/tools/chkmatch.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.debuginfo.com/tools/chkmatch.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;サイトキャッシュアドレス：&lt;a class=&#34;link&#34; href=&#34;chkmatch.zip&#34; &gt;chkmatch.zip&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ChkMatch utility can be used to check whether an executable and debug information file match. It can also be used to enforce matching between an executable and debug information file, if they are compatible.

For more information about debug information matching and related issues, see this article.

Supported debug information formats: DBG, PDB 2.0, PDB 7.0.

chkmatch [-c ExeFile DebugInfoFile ] |
         [-m ExeFile DebugInfoFile]
-c
Check matching between the executable and the debug information file.
-m
Make the executable and the debug information file match.
ExeFile
The name of the executable file.
DebugInfoFile
The name of the debug information file.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;chkmatch-を使用する&#34;&gt;chkmatch を使用する
&lt;/h2&gt;&lt;p&gt;まずチェック処理を実行し、不一致の原因を分析後、署名不一致を通知します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\tianlong.xiang\Downloads\chkmatch&amp;gt;ChkMatch.exe -c &amp;quot;D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe&amp;quot; E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb
ChkMatch - version 1.0
Copyright (C) 2004 Oleg Starodumov
http://www.debuginfo.com/


Executable: D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe
Debug info file: E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb

Executable:
TimeDateStamp: c26d9be3
Debug info: 2 ( CodeView )
TimeStamp: f86b0a4f  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 122  RVA: 001cdc44  FileOffset: 001cbe44
CodeView format: RSDS
Signature: {428c9b95-39a3-4a8d-a8e5-7be453684757}  Age: 1
PdbFile: D:\stock_UAT\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\obj\Release\YinTrade.Main.pdb
Debug info: 16 ( Unknown )
TimeStamp: 00000000  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 0  RVA: 00000000  FileOffset: 00000000

Debug information file:
Format: PDB 7.00
Signature: {06fae08e-c0a2-4f3d-9c7c-dfc684445dd1}  Age: 1

Result: Unmatched (reason: Signature mismatch)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;その後、pdbファイルとexeファイルを一致させるよう修正を実行します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\tianlong.xiang\Downloads\chkmatch&amp;gt;ChkMatch.exe -m &amp;quot;D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe&amp;quot; E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb
ChkMatch - version 1.0
Copyright (C) 2004 Oleg Starodumov
http://www.debuginfo.com/


Executable: D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe
Debug info file: E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb

Executable:
TimeDateStamp: c26d9be3
Debug info: 2 ( CodeView )
TimeStamp: f86b0a4f  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 122  RVA: 001cdc44  FileOffset: 001cbe44
CodeView format: RSDS
Signature: {428c9b95-39a3-4a8d-a8e5-7be453684757}  Age: 1
PdbFile: D:\stock_UAT\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\obj\Release\YinTrade.Main.pdb
Debug info: 16 ( Unknown )
TimeStamp: 00000000  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 0  RVA: 00000000  FileOffset: 00000000

Debug information file:
Format: PDB 7.00
Signature: {06fae08e-c0a2-4f3d-9c7c-dfc684445dd1}  Age: 1

Writing to the debug information file...
Result: Success.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/38147487/forcing-to-load-unmatched-symbols-in-visual-studio-2015-debugger&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;forcing-to-load-unmatched-symbols-in-visual-studio-2015-debugger&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Cursor AI プログラミングIDE 体験版</title>
        <link>https://ttf248.life/ja/p/cursor-ai-programming-ide-trial/</link>
        <pubDate>Thu, 23 Jan 2025 19:30:13 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cursor-ai-programming-ide-trial/</guid>
        <description>&lt;p&gt;あっという間に一年が過ぎ、仕事において最も大きな変化は、やはりAIの関与が顕著に高まっていることだ。これまで、開発言語間の切り替えには、それぞれの言語特有のAPIインターフェースを理解する必要があったが、今ではこれらの基礎コードもAIによって生成されるようになった。これは開発者にとって非常にありがたいことだ。&lt;/p&gt;
&lt;h2 id=&#34;chatgpt&#34;&gt;ChatGPT
&lt;/h2&gt;&lt;p&gt;23年にも簡単な入門記事を2つほど書いた頃から、気がつけばもう25年。目に見えるような進歩は感じられず、自分自身の理解を確立し、タスクを適切に分割でき、何よりもAI生成コードのバグを見抜くことが重要だ。&lt;/p&gt;
&lt;h2 id=&#34;github-copilot&#34;&gt;Github copilot
&lt;/h2&gt;&lt;p&gt;いつだったか覚えていないが、シンガポールにサーバーを設置したという資料を見た。これにより、ローカルで利用でき、それ以来、長期間VPNを使用する必要はなくなった。ログイン時のみVPNが必要だが、ログイン後であれば閉じることもできる。&lt;/p&gt;
&lt;p&gt;普段使いでは、より多くの場合は Github Copilot を使っています。このプラグインは、VS Code や Visual Studio で直接使用でき、2つのソフトウェア間での切り替えが不要です。ChatGPT と比較して、Github Copilot の方がプロジェクトのサポートが充実しており、操作性も優れています。さらに、ローカルファイルの一部を &lt;strong&gt;“训练”AI&lt;/strong&gt; として提供することで、プロジェクトに合ったコードを生成できます。&lt;/p&gt;
&lt;h2 id=&#34;cursor-ai&#34;&gt;Cursor AI
&lt;/h2&gt;&lt;p&gt;最近、新しいAIプログラミングIDEのCursor AIを見ました。このIDEはGithub Copilotをベースにしていますが、さらにスマートで、ファイル作成も支援してくれます。&lt;/p&gt;
&lt;p&gt;軽く使ってみたところ、まだ悪くない感じだが、既存プロジェクトの理解はまだ足りない。ローカルプロジェクトファイルが多い場合や、大規模なリファクタリング・最適化調整には、やはり&lt;strong&gt;开发者拆分任务&lt;/strong&gt;が必要だ。&lt;/p&gt;
&lt;p&gt;curso のプロジェクトに切り替えて、以下の内容を入力してください：個人用履歴書ウェブページの作成、複数の異なるスタイルへの切り替えをサポートし、データ表示用の個人情報を忘れずに埋めてください。&lt;/p&gt;
&lt;p&gt;何度か試行錯誤をすれば、次のようなウェブページを入手できます。もちろん、このウェブページはまだシンプルですが、初心者には良いでしょう。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;現在、新規登録ユーザーは高機能APIを150回無料で試用できます。有料ユーザーは高機能APIの利用回数が5000回に制限されます。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/p&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43; ビット演算の基礎：ビットごとの値の取得とフラグ設定</title>
        <link>https://ttf248.life/ja/p/cpp-bitwise-operations-basics-flags/</link>
        <pubDate>Fri, 17 Jan 2025 02:23:56 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cpp-bitwise-operations-basics-flags/</guid>
        <description>&lt;p&gt;実際のC++開発において、ビット演算は一般的な技術であり、特にシステム状態、フラグ、または制御ビットを扱う際には、非常に効率的な解決策を提供します。本稿では、例を通して、ビット演算を使用して特定のフラグを取得および設定する方法について解説します。&lt;/p&gt;
&lt;h3 id=&#34;ビット演算の基本概念&#34;&gt;ビット演算の基本概念
&lt;/h3&gt;&lt;p&gt;コンピュータでは、データは2進数のビット（0と1）で保存されます。ビット演算とは、これらの2進数ビットに対して行う操作のことです。C++にはいくつかの一般的なビット演算子があります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;按位与（&amp;amp;）&lt;/strong&gt;: あるビットが1であるかを確認するためのもの。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按位或（|）&lt;/strong&gt;: あるビットを1に設定する。&lt;/li&gt;
&lt;li&gt;反転操作用。&lt;/li&gt;
&lt;li&gt;すべてのビットを反転する。&lt;/li&gt;
&lt;li&gt;すべての桁をいくつかずらす。&lt;/li&gt;
&lt;li&gt;すべての桁をいくつかずらす。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この例では、一連のビット演算を __ 类型的变量 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; に適用し、異なるフラグによって異なる状態を表します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;flowchart LR
    A[原始数值: 00010000] --&amp;gt; B[左移: 00010000 &amp;lt;&amp;lt; 1]
    B --&amp;gt; C[结果: 00100000]
    C --&amp;gt; D[右移: 00100000 &amp;gt;&amp;gt; 1]
    D --&amp;gt; E[结果: 00010000]

    subgraph 左移操作
        direction LR
        A --&amp;gt; B --&amp;gt; C
    end

    subgraph 右移操作
        direction LR
        C --&amp;gt; D --&amp;gt; E
    end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;要求分析&#34;&gt;要求分析
&lt;/h3&gt;&lt;p&gt;題の説明に基づき、異なる状態を表す16ビットのフラグがあります。これらの状態は、様々な二進数のビットによって示され、各ビットは特定の意味に対応しています。例えば：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;失敗したか&lt;/li&gt;
&lt;li&gt;圧縮されていますか？&lt;/li&gt;
&lt;li&gt;増分は必要ですか？&lt;/li&gt;
&lt;li&gt;続編はありますか？&lt;/li&gt;
&lt;li&gt;通常のリクエストまたはログアウト&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ビット演算を使用する&#34;&gt;ビット演算を使用する
&lt;/h3&gt;&lt;p&gt;これらのフラグは、ビット演算を用いて設定および取得します。具体的には：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;あるビットの値（0または1）を取得する。&lt;/li&gt;
&lt;li&gt;あるビットを1に設定する。&lt;/li&gt;
&lt;li&gt;設定特定のビットを0にする。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;まず、これらのフラグを保存するために、ある__INLINE_CODE_0__ 类型的变量 __INLINE_CODE_1__を定義します。その後、ビット演算を用いて、対応するフラグをチェックし設定します。&lt;/p&gt;
&lt;h3 id=&#34;cサンプルコード&#34;&gt;C++サンプルコード
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;bitset&amp;gt;

// 定义标志位常量
const unsigned short BIT_0_FAIL = 1 &amp;lt;&amp;lt; 0;    // bit0 是否失败
const unsigned short BIT_1_COMPRESSED = 1 &amp;lt;&amp;lt; 1; // bit1 是否压缩
const unsigned short BIT_2_INCREMENT = 1 &amp;lt;&amp;lt; 2;  // bit2 是否增量
const unsigned short BIT_3_HAS_MORE = 1 &amp;lt;&amp;lt; 3;   // bit3 是否有后续包
const unsigned short BIT_5_CANCEL = 1 &amp;lt;&amp;lt; 5;     // bit5 正常请求(0)或注销(1)

// 检查某一位是否为1
bool isBitSet(unsigned short wInfo, unsigned short bitMask) {
    return (wInfo &amp;amp; bitMask) != 0;
}

// 设置某一位为1
void setBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo |= bitMask;
}

// 清除某一位（设置为0）
void clearBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo &amp;amp;= ~bitMask;
}

int main() {
    // 假设wInfo的初始值为0
    unsigned short wInfo = 0;

    // 设置bit0（失败标志）
    setBit(wInfo, BIT_0_FAIL);
    
    // 设置bit1（压缩标志）
    setBit(wInfo, BIT_1_COMPRESSED);
    
    // 打印wInfo的二进制值
    std::cout &amp;lt;&amp;lt; &amp;quot;wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    // 检查各个标志位
    std::cout &amp;lt;&amp;lt; &amp;quot;bit0 (是否失败): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_0_FAIL) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit1 (是否压缩): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_1_COMPRESSED) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit2 (是否增量): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_2_INCREMENT) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit3 (是否有后续包): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_3_HAS_MORE) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit5 (是否注销): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_5_CANCEL) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;

    // 清除bit1（压缩标志）
    clearBit(wInfo, BIT_1_COMPRESSED);
    
    // 打印更新后的wInfo
    std::cout &amp;lt;&amp;lt; &amp;quot;Updated wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;コードを実行し、旧友を推薦します：&lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wInfo (in binary): 0000000000000011
bit0 (是否失败): 是
bit1 (是否压缩): 是
bit2 (是否增量): 否
bit3 (是否有后续包): 否
bit5 (是否注销): 否
Updated wInfo (in binary): 0000000000000001
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;コード解説&#34;&gt;コード解説
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;変位操作（インラインitalic_10、インラインitalic_11、インラインitalic_12、インラインitalic_13、インラインitalic_14など）を使用します。これにより、各フラグビットにユニークな二進数位置を割り当てることができます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;太字_4：斜体_8____太字_5：斜体_9____太字_6：斜体_10____太字_7：斜体_11____。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定されたフラグの位置を1にする。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特定のフラグの位置を0にする。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;まとめ&#34;&gt;まとめ
&lt;/h3&gt;&lt;p&gt;ビット演算を用いることで、複数の状態フラグを効率的に処理できます。特に、組み込み開発やネットワークプロトコル、システムの状態管理など、多くの場面で役立ちます。ビットフラグは、複数の二進数状態を表す際に、省スペースかつ高効率を実現します。&lt;/p&gt;
&lt;p&gt;このブログが、C++ でのビット演算を使ったビット値の取得と設定を理解するのに役立つことを願っています。これらのスキルを習得することは、効率的で保守しやすいコードを書く上で非常に役立ちます！&lt;/p&gt;</description>
        </item>
        <item>
        <title>デスクトップPCを2.5Gネットワークカードにアップグレードし、ローカルエリアネットワークの接続を高速化。</title>
        <link>https://ttf248.life/ja/p/desktop-upgrade-to-25g-network-card-accelerate-lan-interconnection/</link>
        <pubDate>Fri, 10 Jan 2025 00:37:52 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/desktop-upgrade-to-25g-network-card-accelerate-lan-interconnection/</guid>
        <description>&lt;p&gt;デスクトップPCのハードウェア、立て続けに登場。以前の記事で言ったPCIe変換アダプターだが、古いSSDはどうなったのだろう？もちろん無駄にしたわけにはいかない。故障もなく、新たに購入した&lt;code&gt;机械师创物者Mini-3765H&lt;/code&gt;（昨年）に取り付けた。&lt;/p&gt;
&lt;p&gt;新しいマシン、ハードウェアのスペックはやはり素晴らしい。2.5Gデュアルポート、PCIE4.0、Wi-Fi 6。&lt;/p&gt;
&lt;p&gt;最近引っ越したため、部屋に個別のルーターがなく、全てを無線ネットワークで接続しています。ASUSのマザーボード搭載デスクトップPCの無線LANカードの性能がイマイチだったり、ルーターの無線アクセスやローカルネットワーク間のアップロード速度が遅いことが原因で、PC間の通信速度が十分ではありません。そこで新しい2.5GのNICを購入し、デスクトップPCにインストールしました。&lt;/p&gt;
&lt;p&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/p&gt;
&lt;h2 id=&#34;ネットワーク説明&#34;&gt;ネットワーク説明
&lt;/h2&gt;&lt;p&gt;両方のマシンは引き続き元の無線LANカードでインターネットに接続しているが、マシンの間は有線LANで直接接続し、両端とも2.5Gのネットワークカードを使用している。有線LANでの直接接続方法はここでは説明しない。オンラインには多くのチュートリアルがあるので、検索して確認すること。ファイアウォール設定を忘れずに解除し、どちらかのマシンをゲートウェイとして指定すればよい。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
    A[机器1&amp;lt;br&amp;gt;IP: 192.168.4.1&amp;lt;br&amp;gt;子网掩码: 255.255.255.0&amp;lt;br&amp;gt;默认网关: - &amp;lt;br&amp;gt;自动获取DNS] --&amp;gt;|网线直连（2.5G）| B[机器2&amp;lt;br&amp;gt;IP: 192.168.4.2&amp;lt;br&amp;gt;子网掩码: 255.255.255.0&amp;lt;br&amp;gt;默认网关: 192.168.4.1&amp;lt;br&amp;gt;自动获取DNS];
    A --&amp;gt;|无线网卡| Internet;
    B --&amp;gt;|无线网卡| Internet;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;二つのネットワークセグメントの速度測定&#34;&gt;二つのネットワークセグメントの速度測定
&lt;/h2&gt;&lt;h3 id=&#34;ルーターlan&#34;&gt;ルーター、LAN
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\core\Desktop\iperf-3.1.3-win32&amp;gt;iperf3.exe -c 192.168.3.237
Connecting to host 192.168.3.237, port 5201
[  4] local 192.168.3.122 port 1656 connected to 192.168.3.237 port 5201
[ ID] Interval           Transfer     Bandwidth
[  4]   0.00-1.00   sec  9.17 MBytes  76.7 Mbits/sec
[  4]   1.00-2.00   sec  9.91 MBytes  83.2 Mbits/sec
[  4]   2.00-3.00   sec  8.74 MBytes  73.3 Mbits/sec
[  4]   3.00-4.00   sec  10.2 MBytes  85.2 Mbits/sec
[  4]   4.00-5.00   sec  9.23 MBytes  77.1 Mbits/sec
[  4]   5.00-6.00   sec  8.80 MBytes  73.9 Mbits/sec
[  4]   6.00-7.01   sec  8.00 MBytes  66.8 Mbits/sec
[  4]   7.01-8.00   sec  7.69 MBytes  64.9 Mbits/sec
[  4]   8.00-9.01   sec  9.72 MBytes  81.1 Mbits/sec
[  4]   9.01-10.01  sec  7.63 MBytes  63.6 Mbits/sec
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bandwidth
[  4]   0.00-10.01  sec  89.0 MBytes  74.6 Mbits/sec                  sender
[  4]   0.00-10.01  sec  89.0 MBytes  74.6 Mbits/sec                  receiver

iperf Done.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;ダイレクトlan&#34;&gt;ダイレクトLAN
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\core\Desktop\iperf-3.1.3-win32&amp;gt;iperf3.exe -c 192.168.4.1
Connecting to host 192.168.4.1, port 5201
[  4] local 192.168.4.2 port 1524 connected to 192.168.4.1 port 5201
[ ID] Interval           Transfer     Bandwidth
[  4]   0.00-1.01   sec   178 MBytes  1.48 Gbits/sec
[  4]   1.01-2.00   sec   204 MBytes  1.72 Gbits/sec
[  4]   2.00-3.00   sec   214 MBytes  1.80 Gbits/sec
[  4]   3.00-4.00   sec   229 MBytes  1.92 Gbits/sec
[  4]   4.00-5.00   sec   202 MBytes  1.69 Gbits/sec
[  4]   5.00-6.00   sec   213 MBytes  1.79 Gbits/sec
[  4]   6.00-7.00   sec   230 MBytes  1.93 Gbits/sec
[  4]   7.00-8.00   sec   192 MBytes  1.61 Gbits/sec
[  4]   8.00-9.00   sec   220 MBytes  1.84 Gbits/sec
[  4]   9.00-10.00  sec   230 MBytes  1.93 Gbits/sec
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bandwidth
[  4]   0.00-10.00  sec  2.06 GBytes  1.77 Gbits/sec                  sender
[  4]   0.00-10.00  sec  2.06 GBytes  1.77 Gbits/sec                  receiver

iperf Done.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>華碩マザーボードZ490、ディスクが多くなるとたまに認識しない。</title>
        <link>https://ttf248.life/ja/p/asus-motherboard-z490-too-many-disks-intermittent-disk-recognition/</link>
        <pubDate>Fri, 10 Jan 2025 00:08:51 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/asus-motherboard-z490-too-many-disks-intermittent-disk-recognition/</guid>
        <description>&lt;p&gt;前回の続きで、無線LANカードが認識されない問題が発生しました。パーティションを再構築する前に、ネットで他の解決策も調べましたが、例えばマザーボードの電池を取り外して15分間断電したり、最新バージョンのBIOSドライバにアップデートしたりといった方法がありましたが、どれも効果はありませんでした。&lt;/p&gt;
&lt;p&gt;まだやるべきことがあると思って、モバイルデータ通信に切り替えて、リビングから部屋までLANケーブルを引っ張ったところ、また問題が発生し、有線ネットワークも認識されない。思い切ってOSを再インストールしたが、起動パーティションが見つからない。もしずっと問題が起きていなければ、こんなに色々試していない。ASUSのこのディスクの競合は、偶発的に発生し、システム再起動時に不安定になることが原因だ。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;先週、卓上に長江メモリの2TB M.2インターフェースSSDを設置したところ、その後再起動できず、昨日まで電源を切ることができなかった。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;20250110002801.png&#34; &gt;磁盘全家福&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;システム再インストール&#34;&gt;システム再インストール
&lt;/h2&gt;&lt;p&gt;計算によると2年ぶりにOSを再インストールしたことになる。Cドライブの容量が足りなくなったので、Windows特有の問題で、日々のソフトウェアがCドライブに何かデータを保存したがる。そこで、OSを再インストールすることにした。OSを再インストールした後、ネットワークカードの問題は正常になり、次の日には普段の開発環境に戻し、システムバックアップの準備をしたところ、新しい問題が発生した。システムの再起動後、ブートパーティションが見つからない。&lt;/p&gt;
&lt;p&gt;前の記事の手順に従ってブートパーティションを再構築しましたが、不安定で、再起動後にブートパーティションが読み込まれない可能性があります。ケースの改造を疑いつつ、HDDケーブルに問題がないか確認しましたが、何度調べても異常は見当たりませんでした。&lt;/p&gt;
&lt;h2 id=&#34;記憶の回帰&#34;&gt;記憶の回帰
&lt;/h2&gt;&lt;p&gt;数年前にこの機械は一度SSDを増設したことがあり、その際、PCIE変換器（グラフィックカードのインターフェースに接続）を使用して、直接マザーボードに取り付けませんでした。今回、直接マザーボードに取り付けたため、マザーボードの問題かもしれません。&lt;/p&gt;
&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;20250110002148.png&#34; &gt;固态转换器&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;マザーボード取扱説明書&#34;&gt;マザーボード取扱説明書
&lt;/h2&gt;&lt;p&gt;マザーボードの説明書に問題があり、記載されているSATAインターフェースの位置と実際の場所が異なっている。ディスクが多く、すべてのインターフェースにHDDが取り付けられており、古いSSDもSATAインターフェースであるため、マザーボードの説明書によるとインターフェース間に競合が発生するはずだが、実際にテストしたところ、この競合は不安定に発生し、発生すると対応するディスクを読み込めなくなる。まさにそのディスクがシステムディスクであり、ブート領域も同じディスク上にあるため、起動時にブートロードの失敗が発生する。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/asus-motherboard-z490-too-many-disks-intermittent-disk-recognition/20250110002401.png&#34;
	width=&#34;807&#34;
	height=&#34;847&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Z490&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;95&#34;
		data-flex-basis=&#34;228px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;解決策&#34;&gt;解決策
&lt;/h2&gt;&lt;p&gt;PCIE変換器にSSDを再インストールすると、マザーボードのSATAポートとの競合がなくなり、システムは正常に起動する。&lt;/p&gt;</description>
        </item>
        <item>
        <title>ESPパーティション、GPTパーティションテーブル、そしてWindowsオペレーティングシステムの協調の秘密を探る</title>
        <link>https://ttf248.life/ja/p/exploring-esp-gpt-and-windows-cooperation/</link>
        <pubDate>Thu, 09 Jan 2025 23:58:20 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/exploring-esp-gpt-and-windows-cooperation/</guid>
        <description>&lt;p&gt;昨日の退勤後、帰宅していつものようにデスクトップPCを起動したところ、システムは正常に起動したがワイヤレスLANカードが読み込まれない。カードの接触不良かと思い、分解してワイヤレスLANカードを再インストールしたが、さらに問題が悪化し、システムが直接起動せず、ブートローダーが失敗した。&lt;/p&gt;
&lt;p&gt;久しぶりなのでデスクトップPCのいじり、ちょっとパーティションの知識が薄れてる。DisGeniusで空き領域を再パーティション化（通常はディスク前方）、ESPパーティションとして割り当てる（デフォルト300M）、PEシステムに入ってブートを再構築。関連情報はネットで調べれば見つかる。&lt;/p&gt;
&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;20250110000433.png&#34; &gt;新建ESP分区&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;20250110000509.png&#34; &gt;可以去掉MSR分区&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;コンピュータのストレージの世界において、ESPパーティション、GPTパーティションテーブル、そしてWindowsオペレーティングシステムは密接に結びついており、それぞれが独自の重要な役割を果たし、システムの安定稼働と効率的な管理を支えています。しかし、それらを深く理解する前に、必ず言及しなければならないのが、「先駆者」であるMBRパーティション形式です。この形式は、その後の技術との相互映照によって、テクノロジーの進化の軌跡を際立たせています。それでは、今日、これらの内在的な関連性と巧妙さを詳しく見ていきましょう。&lt;/p&gt;
&lt;h2 id=&#34;一mbrパーティションテーブル従来のhddの基礎&#34;&gt;一、MBRパーティションテーブル──従来のHDDの「基礎」
&lt;/h2&gt;&lt;p&gt;MBR（マスターブートレコード）は、パソコン黎明期から存在する技術で、長らくハードディスクのパーティション領域を支配してきました。&lt;/p&gt;
&lt;h3 id=&#34;基本アーキテクチャ&#34;&gt;基本アーキテクチャ
&lt;/h3&gt;&lt;p&gt;それはハードディスクの最初のセクタ、すなわち0セクタに位置し、512バイトの領域を占有します。この512バイトは主に3つの部分で構成されます。まず、コンピュータ起動時にオペレーティングシステムのブートローダをロードする責任を持つブートプログラムコードがあり、通常446バイトです。次に、ディスクパーティションテーブルがあり、64バイトを占有し、最大4つのプライマリパーティション情報を定義できます。各パーティション記述は16バイトを占有し、パーティションの開始ヘッド、セクタ、シリンダ、およびパーティションタイプ、サイズなどの重要なパラメータを記録します。最後に、2バイトがMBR終了フラグ「55 AA」としてあり、このセクタが有効なMBRであることを示しています。&lt;/p&gt;
&lt;h3 id=&#34;歴史的功績と限界&#34;&gt;歴史的功績と限界
&lt;/h3&gt;&lt;p&gt;かつてMBRパーティションテーブルは、個人用コンピューターの比較的単純なストレージ要件を十分に満たしていました。これにより、オペレーティングシステムはハードディスクのパーティションを円滑に認識し、データの順序付けられた保存と読み込みを実現できました。しかし、時代が進むにつれて、その限界がますます明らかになりました。一方、64バイトという制限されたパーティションテーブルスペースにより、最大で4つのプライマリパーティションしか作成できず、より多くのパーティションを作成するには、拡張パーティションや論理パーティションといったやや複雑な方法が必要となり、ディスク管理の利便性を損ないました。他方、最大2TBまでのハードディスク容量しかサポートしておらず、現在の数TBから数十TBという大容量ハードディスクに対しては力不足であり、ストレージ技術のさらなる発展を阻害するボトルネックとなっていました。&lt;/p&gt;
&lt;h2 id=&#34;espパーティション---システムの見えない起動キー&#34;&gt;ESPパーティション - システムの「見えない起動キー」
&lt;/h2&gt;&lt;p&gt;ESPは、EFI System Partitionの略で、UEFI（Unified Extensible Firmware Interface）規格に基づくコンピューターに不可欠な特殊なパーティションです。&lt;/p&gt;
&lt;h3 id=&#34;機能-特徴&#34;&gt;機能 特徴
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;コンピューターの電源を入れると、UEFIファームウェアはまずHDD上のESPパーティションを探し、そこに保存されているブートローダー（Windows Boot Managerなど）を読み込み、OSを起動します。これは正確な鍵であり、システム起動への扉を開きます。これがないと、システムは起動時に迷い、方向性を見失います。&lt;/li&gt;
&lt;li&gt;ESP パーティションには、システム起動時に不可欠なデバイスドライバが格納されており、これにより、ハードウェア（HDD コントローラ、グラフィックカードなど）が初期起動段階で正常に動作し、その後のオペレーティングシステムの円滑な引き継ぎを可能にします。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;空間要件とフォーマット&#34;&gt;空間要件とフォーマット
&lt;/h3&gt;&lt;p&gt;通常、ESPパーティションの推奨サイズは100MB～500MBで、一般的に200MB程度割り当てれば基本的な要件は満たされます。ファイルシステム形式はFAT32である必要があり、これはUEFIファームウェアが起動ファイルを読み取るためにFAT32形式のみを認識するため、互換性とクロスプラットフォーム性を確保します。&lt;/p&gt;
&lt;h2 id=&#34;gptパーティション表ハードディスクのスマート管理係&#34;&gt;GPTパーティション表──ハードディスクの「スマート管理係」
&lt;/h2&gt;&lt;p&gt;GPT（GUIDパーティションテーブル）は、従来のMBRパーティションテーブルに代わる新しいパーティション方式です。&lt;/p&gt;
&lt;h3 id=&#34;強み発揮&#34;&gt;強み発揮
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;現代のデータ爆発時代において、大容量ハードディスクが次々と登場しています。GPTパーティションテーブルはMBRの2TBという容量制限を突破し、理論上は最大9.4ZB（ゼタバイト、1ZB=1024EB、1EB=1024PB、1PB=1024TB）という超大容量のストレージスペースを実現し、膨大なデータストレージを可能にします。&lt;/li&gt;
&lt;li&gt;MBR とは異なり、最大で4つのプライマリパーティションしか作成できないのに対し、GPTでは最大128個までのパーティションを作成できるため、ユーザーやシステム管理者は複数のシステムパーティションやデータパーティションを割り当てたり、特殊な用途のためにパーティションを予約したりするなど、非常に柔軟に対応できます。&lt;/li&gt;
&lt;li&gt;GPTパーティションテーブルは冗長バックアップ機構を採用しており、ディスクのヘッダー部とテール部にそれぞれ1つずつパーティションテーブル情報を保存しています。これにより、万が一、パーティションテーブルが破損した場合でも、別のバックアップから自動的に復旧できるため、パーティションテーブルの故障によるデータ損失のリスクを大幅に低減し、データの安全性を確保します。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;構造分析&#34;&gt;構造分析
&lt;/h3&gt;&lt;p&gt;GPTパーティションテーブルは、保護MBR（従来のBIOSとの互換性を保つために残された小規模なMBR構造ですが、実際のパーティション管理には使用されません）、GPTヘッダー（パーティションテーブルのバージョン、パーティション数、パーティションテーブルサイズなどの基本情報を格納）、そしてパーティションエントリ配列（各パーティションのエントリは、開始セクタ、終了セクタ、パーティションタイプGUID、パーティションの一意な識別子などの重要な情報を詳細に記録）で構成されます。これらの構造が連携し、ハードディスクスペースを正確に計画・管理します。&lt;/p&gt;
&lt;h2 id=&#34;windowsオペレーティングシステムユーザーのデジタルインタラクション空間&#34;&gt;Windowsオペレーティングシステム──ユーザーの「デジタルインタラクション空間」
&lt;/h2&gt;&lt;p&gt;Windowsは、世界中で広く利用されているオペレーティングシステムであり、人とコンピューターハードウェア間の友好的な橋渡しをしています。&lt;/p&gt;
&lt;h3 id=&#34;espパーティションとgptパーティションテーブルの統合&#34;&gt;ESPパーティションとGPTパーティションテーブルの統合
&lt;/h3&gt;&lt;p&gt;UEFI起動のWindowsシステムインストールプロセスでは、インストーラが自動的にESPパーティションを作成し、起動ファイルをそこに展開します。同時に、ディスクはGPTパーティションテーブル形式で初期化され、システム予約パーティション（システム重要ファイルを格納する領域、従来のBIOSにおけるシステムブートファイル領域に類似）、Windowsシステムパーティション（システムコアファイルをインストールする場所）、およびその他のユーザー定義データパーティションが作成されます。WindowsシステムはGPTパーティションテーブルによって各パーティションを正確に識別し、ESPパーティションを通じてスムーズに起動します。これら三者がシームレスに連携し、ユーザーに快適な起動と使用体験を提供します。&lt;/p&gt;
&lt;h3 id=&#34;システム管理と最適化の基盤&#34;&gt;システム管理と最適化の基盤
&lt;/h3&gt;&lt;p&gt;Windowsは動作中にGPTパーティションテーブルの利点を最大限に活用してディスク管理を行います。例えば、ディスク管理ツールではGPTパーティションを容易に識別でき、ユーザーはパーティションの作成、削除、フォーマット、サイズ変更などの操作を簡単に行い、様々な段階でのデータストレージニーズに対応できます。また、システム更新やソフトウェアインストールといったプロセスもパーティション構成と密接に関連しており、適切なパーティション設計はシステムのパフォーマンスと安定性を向上させ、ディスク容量不足やパーティションの混乱による問題発生のリスクを軽減します。&lt;/p&gt;
&lt;h2 id=&#34;五実践のヒント保守とトラブルシューティング&#34;&gt;五、実践のヒント：保守とトラブルシューティング
&lt;/h2&gt;&lt;p&gt;それらの密接な関係性を理解すれば、日々のメンテナンスとトラブルシューティングに手順がある。&lt;/p&gt;
&lt;h3 id=&#34;ディスクスペース管理&#34;&gt;ディスクスペース管理
&lt;/h3&gt;&lt;p&gt;ESP パーティションの空き容量を定期的に確認し、過剰な起動項目関連ソフトウェアのインストールによる容量不足を防ぎ、システム起動への影響を避けてください。GPT パーティション下のデータパーティションでは、適切なストレージ計画を立て、不要なファイルを適宜削除し、単一パーティションの容量オーバーによるシステム動作への影響を防いでください。&lt;/p&gt;
&lt;h3 id=&#34;トラブルシューティング開始&#34;&gt;トラブルシューティング開始
&lt;/h3&gt;&lt;p&gt;システム起動に失敗した場合、まずESPパーティションが破損していないか、ファイルが失われていないかを確認してください。UEFIファームウェアに付属の起動項目修復ツールを使用するか、Windowsインストールメディアから回復環境に入り、ESPパーティションの起動ファイルを再構築できます。GPTパーティションテーブルの故障が疑われる場合は、ディスクツール（DiskGeniusなど）を使用してパーティションテーブルの完全性を確認し、バックアップされたパーティション情報を利用してパーティションテーブルを修復し、失われたパーティションを見つけ直してください。&lt;/p&gt;
&lt;p&gt;ESP パーティション、GPT ディスク構造、そして Windows オペレーティングシステムは、まるで精密に連携するチームのように、それぞれの得意分野を発揮し、安定かつ効率的なコンピューター環境を作り上げています。これらを深く理解することで、システムインストールやメンテナンスをスムーズに行えるだけでなく、コンピューターの基盤となる動作原理を把握し、デジタル世界を自由に旅することができます。同時に、MBR ディスク構造の盛衰を振り返ることは、技術進歩の力に感銘を与えられます。それは、増大するデータストレージのニーズに対応するため、ストレージ技術を常に前進させています。&lt;/p&gt;</description>
        </item>
        <item>
        <title>GCC、GLIBC と C&#43;&#43; プログラムの互換性問題に関する深い理解</title>
        <link>https://ttf248.life/ja/p/deep-understanding-gcc-glibc-cpp-compatibility-issues/</link>
        <pubDate>Mon, 06 Jan 2025 19:51:16 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/deep-understanding-gcc-glibc-cpp-compatibility-issues/</guid>
        <description>&lt;p&gt;C++開発において、GCCとGLIBCは欠かせない主要な要素であり、プログラム公開後の互換性の問題も開発者を悩ませることがよくある。本稿では、これらの本質を深く分析し、互換性の問題の根本原因とその対策について探求する。&lt;/p&gt;
&lt;h2 id=&#34;一gcc堅固なコンパイラの基礎&#34;&gt;一、GCC：堅固なコンパイラの基礎
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;GCC（GNU コンパイラ コレクション）は、GNUプロジェクトが開発したオープンソースのコンパイラスイートです。C、C++、Objective-C、Fortran、Ada、Goなど、多様な主要言語に対応し、クロス言語開発のためのワンストップソリューションを提供します。&lt;/li&gt;
&lt;li&gt;C++ を例にとると、クラス、テンプレート、関数オーバーロードといった複雑な機能を含むソースファイルを記述した際、GCC は C++ の厳格な文法と意味規則に基づいて、高レベルの C++ コードを、基盤となる機械が理解し実行できる命令シーケンスに変換します。このプロセスには、語彙解析、構文解析、意味解析、最適化、コード生成といった複数の精緻な段階が含まれます。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;GCCはまず、ソースファイルを前処理します。この際、すべての&lt;code&gt;#&lt;/code&gt;、&lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt;、&lt;strong&gt;INLINE_CODE_3&lt;/strong&gt;、&lt;strong&gt;INLINE_CODE_4&lt;/strong&gt;、&lt;strong&gt;INLINE_CODE_5&lt;/strong&gt;、&lt;code&gt;3.14159&lt;/code&gt;を処理し、前処理後、ソースファイルは初期段階で「拡充」されます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编译阶段&lt;/strong&gt;: プリプロセスされたファイルはコンパイル段階に入り、GCC は C++ 言語標準に基づいてソースファイルをアセンブリ言語コードに変換します。クラスの継承、ポリモーフィズムの実装、関数呼び出しパラメータのマッチングなど、コード構造を厳密にチェックし、文法や意味に合致しないエラーが見つかると、速やかにエラーを出力してコンパイルプロセスを停止します。例えば、関数宣言と定義のパラメータリストが不一致の場合、GCC は問題箇所を正確に特定します。&lt;/li&gt;
&lt;li&gt;アセンブラは、前段階で生成されたアセンブリコードを機械語に変換し、__INLINE_CODE_0__という拡張子のオブジェクトファイルを生成します。これらのオブジェクトファイルには、機械が直接実行できるバイナリ命令が含まれていますが、通常、完全なプログラムは複数のモジュールから構成され、関数や変数の参照関係が解決されていないため、単独で実行することはできません。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链接阶段&lt;/strong&gt;：これは実行可能ファイルを生成する最後のスプリント段階です。リンカは、複数のオブジェクトファイルと必要なライブラリファイル（静的ライブラリまたは動的ライブラリ）を統合します。例えば、C++標準テンプレートライブラリのコンテナクラスを使用する場合、リンク時に対応するライブラリの実装コードを見つける必要があり、プログラム実行時に__INLINE_CODE_0__、__INLINE_CODE_1__などのコンテナ機能を正しく呼び出せるようにし、最終的に完全な実行可能プログラムを生成します。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二glibccプログラムを支える舞台裏&#34;&gt;二、GLIBC：C++プログラムを支える舞台裏
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;GLIBCは、GNU C Libraryのことであり、C標準ライブラリのGNUエコシステムにおける具体的な実装です。名前がCを強調していますが、C++プログラムも同様に強く依存しており、なぜならC++はCの基礎部分を受け継いでいるからです。メモリ管理など、膨大な基礎関数を提供し、C++初期の開発や、パフォーマンスを重視し、簡潔さを追求する場面で頻繁に使用されます。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;GLIBCは、OSとアプリケーションをつなぐ重要な橋渡し役です。Linuxシステムにおいて、C++プログラムがファイルを開くといったシステムコールを行う際（例えば、__INLINE_CODE_0__関数を使用し、その基盤としてGLIBCの実装に依存する場合）、GLIBCはプログラムのリクエストをOSカーネルが定める方法でラップしてカーネルに渡し、カーネル処理完了後、結果をアプリケーションに返します。これにより、アプリケーションはOSの複雑なシステムコールインターフェースの詳細を深く理解することなく、ファイルシステム、ネットワーク、プロセス管理などの様々なシステムリソースを容易に使用できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cプログラム公開後の互換性問題の考察&#34;&gt;C++プログラム公開後の互換性問題の考察
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;異なる Linux ディストリビューションは、しばしば異なるバージョンの GLIBC を搭載しています。C++ プログラムが高バージョン GLIBC 環境でコンパイルされると、意図せずしてそのバージョンで新たに追加された関数機能を利用したり、より最適化された関数実装に依存したりすることがあります。例えば、新しい GLIBC バージョンではメモリ割り当てアルゴリズムが改善されており、プログラムはその新アルゴリズムを頻繁に利用することでパフォーマンスを向上させます。しかし、このプログラムを低バージョン GLIBC システムで実行すると、対応する関数が見つからない（低バージョンで導入されていないため）あるいは関数動作が異常になる（旧版の実装ロジックと新版のずれ）といった問題が発生し、プログラムがクラッシュしたり、誤った結果を生み出したりする可能性があります。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;同じGCCコンパイラを使用した場合でも、バージョンによってコード生成、標準ライブラリのサポート、C++機能の実装に差異があります。最新バージョンのGCCは、C++20の新機能（モジュールやコルーチンなど）を完全にサポートしていますが、古いバージョンのGCCでこれらの機能を活用したプログラムをコンパイルすると、構文エラーが発生したり、最適化戦略の違いにより生成される機械語の効率やメモリ使用量が大きく異なり、パフォーマンスが要求される環境下では、異なる環境での挙動に大きな違いが生じる可能性があります。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;C++プログラムは、x86、ARM、PowerPCなどの異なるハードウェアシステムアーキテクチャ上で動作する必要がある場合があります。各アーキテクチャには独自の命令セット、メモリレイアウト、データアライメント要件があります。例えば、データアライメントに関して、x86アーキテクチャで正常に動作する構造体データの格納順序が、ARMアーキテクチャではアライメント規則の違いによりメモリアクセス異常を引き起こし、プログラムエラーにつながる可能性があります。また、GCCは異なるアーキテクチャ向けにコンパイルすると生成される機械語が大きく異なり、プログラム中にハードコードされたアーキテクチャ依存の命令や仮定があれば、クロスアーキテクチャでの動作時に頻繁な障害が発生します。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;互換性の問題への対応策&#34;&gt;互換性の問題への対応策
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;静的にリンクされたライブラリを使用することを検討してください。プログラムが依存する GLIBC などのライブラリコードを直接実行ファイルにパッケージングすることで、プログラムの実行時に特定の GLIBC のバージョンに依存する必要がなくなり、GLIBC のバージョン不一致による問題を効果的に回避できます。ただし、静的リンクは実行ファイルのサイズを大幅に増加させるため、ストレージリソースが限られている場合は、メリットとデメリットを比較検討する必要があります。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Dockerなどのコンテナ化技術を活用し、C++プログラムとその実行環境（特定のバージョンのGCC、GLIBCなど）を独立したコンテナにパッケージングします。これにより、基盤となるOSが異なってもコンテナ内部は開発時の環境を維持し、プログラムの期待通りの動作を保証するとともに、異なる環境へのデプロイメントの複雑さを大幅に軽減できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;包括様々なGLIBCバージョン、GCCバージョン、および一般的なシステムアーキテクチャを網羅した、包括的な互換性テスト体系を構築する。開発プロセスにおいて、継続的インテグレーションツールを用いて、複数の環境で定期的に自動テストを実施し、互換性の問題を早期に発見・修正することで、潜在的なリスクを未然に防ぎ、リリース後の安定性を確保する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上記を総合すると、GCCおよびGLIBCの動作メカニズムを深く理解し、C++プログラムの互換性問題の根本原因を正確に把握し、柔軟な対応策を用いることは、あらゆるC++開発者が堅牢でクロスプラットフォームなアプリケーションを構築するために不可欠なスキルです。そうすることで初めて、私たちのC++作品は多様な技術エコシステムの中で円滑に進むことができるでしょう。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Windowsに標準搭載されているディスククリーンアップツール：ストレージ</title>
        <link>https://ttf248.life/ja/p/windows-disk-cleanup-storage/</link>
        <pubDate>Mon, 06 Jan 2025 19:29:45 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/windows-disk-cleanup-storage/</guid>
        <description>&lt;p&gt;どのバージョンからかはっきりしないが、__INLINE_CODE_0__において、ディスククリーンアップツールは大幅に改善され、よりスマートになった。&lt;/p&gt;
&lt;p&gt;公式ツールなので、ファイルは誤って削除されることはなく、広告やポップアップ、バックグラウンドプロセスなど、不要なものは一切ありません。&lt;/p&gt;
&lt;p&gt;ディスククリーンアップツールを開くには、上記手順に従ってください。&lt;/p&gt;
&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;20250106194453.png&#34; &gt;存储界面&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通常ユーザーは、&lt;code&gt;清理建议&lt;/code&gt;を選択すればよいです。システムはあなたの利用状況に応じて、いくつかの提案を提示します。&lt;/p&gt;
&lt;p&gt;開発者として、筆者はディスク上に多くの仮ファイルを持っているため、&lt;code&gt;临时文件&lt;/code&gt;，里面包含了很多临时文件，比如&lt;code&gt;Visual Studio&lt;/code&gt;的临时文件，&lt;code&gt;Windows Update&lt;/code&gt;のような仮ファイルを削除しています。&lt;/p&gt;
&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;Snipaste_2024-12-19_13-39-51.png&#34; &gt;临时文件&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>Docker国内镜像代理切れ</title>
        <link>https://ttf248.life/ja/p/docker-domestic-mirror-failure/</link>
        <pubDate>Sat, 04 Jan 2025 18:29:25 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/docker-domestic-mirror-failure/</guid>
        <description>&lt;p&gt;国内サーバーにDockerをデプロイし、デプロイ後、もし社内イメージレジストリがない場合、開発者がまず行うべきことは、国内のイメージ加速アドレスを設定することです。今日、ちょうどサーバーがあり、イメージ加速アドレスを設定しましたが、イメージのpullができません。&lt;/p&gt;
&lt;p&gt;エラー情報：&lt;/p&gt;
&lt;p&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/p&gt;
&lt;h2 id=&#34;トラブルシューティングと修理の試み&#34;&gt;トラブルシューティングと修理の試み
&lt;/h2&gt;&lt;p&gt;当初、別のミラーの加速アドレスに切り替えることを試みましたが、期待した効果はなく、問題は依然として解決していません。&lt;/p&gt;
&lt;p&gt;続いて、ローカルDNS設定の修正に取り組み、ネットワーク解析レベルで突破口を探りましたが、試行錯誤の結果、残念ながら問題は解消されませんでした。&lt;/p&gt;
&lt;p&gt;現時点でローカルネットワークの安定性が疑われているため、すぐにスマートフォンWi-Fiスポットに切り替えて、考えられるローカルネットワークの問題点を回避しようとしましたが、結果は落胆するもので、問題は全く改善しませんでした。&lt;/p&gt;
&lt;h2 id=&#34;問題の拡大&#34;&gt;問題の拡大
&lt;/h2&gt;&lt;p&gt;手元に&lt;strong&gt;几台部署于国内的服务器&lt;/strong&gt;がいくつかあり、それぞれにDocker環境はインストールされています。これらのサーバーでイメージのpullを試みましたが、別のアプローチを期待していたのですが、例外なくすべて失敗し、エラーメッセージも全く同じでした。これは問題が特定のデバイスに限定されたものではないことを示しています。&lt;/p&gt;
&lt;p&gt;さらに調査した結果、ミラープロキシが一時的に機能しなくなったようです。この緊急時に、すぐに海外のサーバーに切り替えて試してみたところ、幸いなことに、ミラーからの取得はここで正常に戻りました。これは、問題の原因が国内のネットワーク経路または関連設定にある可能性が高いことを意味します。&lt;/p&gt;
&lt;h2 id=&#34;戦術変更間接解決&#34;&gt;戦術変更：間接解決
&lt;/h2&gt;&lt;p&gt;国内の直接的なミラーからのイメージ取得経路が重重なる阻害を受けている一方、海外ミラーは正常にアクセスできるため、プロジェクトを迅速に進めるため、回り道をすることに決定しました。まず海外サーバーへ切り替え、必要なイメージをスムーズに取得した後、国内ミラーリポジトリへプッシュし、「データブリッジ」を構築します。&lt;/p&gt;
&lt;p&gt;同時に、Dockerfile ファイルを修正し、イメージのアドレスを国内環境に適合するものに変更後、再度ビルドを行い、最終的にデプロイに成功しました。&lt;/p&gt;</description>
        </item>
        <item>
        <title>CentOS 8 Stream EOL</title>
        <link>https://ttf248.life/ja/p/centos-8-stream-eol/</link>
        <pubDate>Sat, 16 Nov 2024 23:24:50 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/centos-8-stream-eol/</guid>
        <description>&lt;p&gt;配信前のオープンソース開発プラットフォーム。
オープンソースオペレーティングシステムのライフサイクルに初めて注目しました。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;期限切れです、何か問題がありますか？セキュリティの問題以外に、DNFが使えなくなりました。最近ツールをインストールしようとしたときにDNFが失敗し、ミラーを確認したところ、&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; の有効期限が切れていました。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;centos-streamのご紹介&#34;&gt;CentOS Streamのご紹介
&lt;/h2&gt;&lt;h3 id=&#34;位置付けと役割&#34;&gt;位置付けと役割
&lt;/h3&gt;&lt;p&gt;CentOS Streamは、Fedora Linux（上流開発）とRHEL（Red Hat Enterprise Linux、下流開発）の中間に位置し、橋渡し役を果たします。&lt;/p&gt;
&lt;p&gt;最新Red Hat系のLinux機能を試すためのバージョンとして考えられ、最新技術を体験したいユーザーに適しています。&lt;/p&gt;
&lt;h3 id=&#34;誕生と背景&#34;&gt;誕生と背景
&lt;/h3&gt;&lt;p&gt;時の経過とともに、Red Hat社は企業向けLinuxプラットフォームをより効果的に発展させる方法を模索し、CentOS Streamを発表しました。&lt;/p&gt;
&lt;p&gt;CentOS 8は2021年末にサポート終了となり、その代替としてCentOS Streamがアップデートされ続け、CentOSプロジェクトの将来的な方向性となっています。&lt;/p&gt;
&lt;h3 id=&#34;特徴と利点&#34;&gt;特徴と利点
&lt;/h3&gt;&lt;p&gt;CentOS Streamは、より迅速なアップデートを提供するローリングリリース型のLinuxディストリビューションです。コミュニティ、パートナー、顧客の参加を促進し、ユーザーがRed Hat Enterprise Linuxに、より迅速かつ直接的に貢献できる透明性と機会を高めます。&lt;/p&gt;
&lt;p&gt;CentOS Streamの内容は、Red Hatが次期安定版RHELに組み込む予定のソフトウェアであり、コミュニティメンバーが開発・テストするための安定したABI/APIを提供します。&lt;/p&gt;
&lt;h3 id=&#34;利用シーンとターゲットユーザー&#34;&gt;利用シーンとターゲットユーザー
&lt;/h3&gt;&lt;p&gt;CentOS Streamは、最新のLinux機能アップデートを継続的に受けたいCentOSユーザーや、Red Hat Enterprise Linuxの開発に貢献したい開発者およびパートナーに適しています。&lt;/p&gt;
&lt;p&gt;コミュニティのメンバー、Red Hat パートナー、およびその他の関係者が、より安定した予測可能な Linux エコシステムの中で革新的なオープンソースソフトウェアを最大限に活用できるよう支援することを目的としています。&lt;/p&gt;
&lt;h2 id=&#34;申し訳ありませんが翻訳する中国語のテキストが提供されていませんテキストを提供していただければ日本語に翻訳します&#34;&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Release&lt;/th&gt;
&lt;th&gt;Released&lt;/th&gt;
&lt;th&gt;Active Support&lt;/th&gt;
&lt;th&gt;Security Support&lt;/th&gt;
&lt;th&gt;Latest&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;3 years ago (15 Sep 2021)&lt;/td&gt;
&lt;td&gt;Ends in 2 years and 6 months (31 May 2027)&lt;/td&gt;
&lt;td&gt;Ends in 2 years and 6 months (31 May 2027)&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;5 years ago (24 Sep 2019)&lt;/td&gt;
&lt;td&gt;Ended 5 months and 3 weeks ago (31 May 2024)&lt;/td&gt;
&lt;td&gt;Ended 5 months and 3 weeks ago (31 May 2024)&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;解決策&#34;&gt;解決策
&lt;/h2&gt;&lt;p&gt;面倒くさいバージョンアップは避け、長期サポート版を選択した。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Hugo Module カスタマイズ、テーマ改修：アイデア解説</title>
        <link>https://ttf248.life/ja/p/hugo-module-custom-theme-ideas/</link>
        <pubDate>Fri, 15 Nov 2024 22:01:17 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/hugo-module-custom-theme-ideas/</guid>
        <description>&lt;p&gt;過去のコミット履歴を振り返ると、サイトは何度もテーマを変更しており、その度にカスタマイズが施されている。ここでは、カスタマイズしたテーマのアイデアについて記録しておく。筆者の__INLINE_CODE_0__也有个仓库，短暂的维护过even主题，后来由于强迫症，非想要升级__INLINE_CODE_1__BOLD_4&lt;code&gt;stack&lt;/code&gt;テーマ。&lt;/p&gt;
&lt;h2 id=&#34;ユゴのモジュール化&#34;&gt;ユゴのモジュール化
&lt;/h2&gt;&lt;p&gt;モジュール化と聞くと、NginxのモジュールやIDEAプラグインなどが思い浮かぶかもしれません。通常、いくつかのモジュールをアップロードすることで、差別化されたニーズを満たすことができます。皆がこのモジュール方式を好む主な理由は、柔軟性が高く、大した労力なしに自身のニーズに対応できるからです。多くの場合、全体としては似ていても、細部には差異が存在します。これもまた、技術的な複雑さだけでなく、ビジネスの複雑さも示しています。ほとんどの場合、私たちはビジネスの複雑さに直面します。これはまさに、ソフトウェア業界における「隔行如隔山」という言葉を最もよく表していると言えるでしょう。現在では、インターネット業界だけでなく、金融業界や伝統的な製造業に至るまで、情報化システムを活用して企業の生産と管理を支援しています。同じ休暇申請システムでも、同じ業界の異なる企業間でも差異が生じることがあります。&lt;/p&gt;
&lt;p&gt;そのモジュールは、一般的にイメージされるモジュールとは少し異なり、機能単位で多様なニーズに対応するのではなく、ディレクトリ構造を主体として同一の構造を識別します。&lt;/p&gt;
&lt;p&gt;資料リンク：&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@sunwei.xyz/07-hugo%E6%9E%B6%E6%9E%84-hugo%E7%9A%84%E6%A8%A1%E5%9D%97-8ef5a520a822&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;07. Hugo架构 — Hugo的模块&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[[imports]]
path = &amp;quot;github.com/CaiJimmy/hugo-theme-stack/v3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;その方法はまだ使えるが、本稿では推奨しない。テーマに更新があった場合、保守が煩雑になるため、個別のGitリポジトリでテーマを管理する必要がある。&lt;/p&gt;
&lt;h2 id=&#34;申し訳ありませんが翻訳する中国語のテキストが提供されていませんテキストを提供していただければ日本語に翻訳します&#34;&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。
&lt;/h2&gt;&lt;p&gt;モジュール化の基礎概念を理解していれば、カスタムテーマの理解は非常に簡単になるでしょう。現在のテーマも、複数の異なるモジュールが組み合わさったもので、変更したいモジュールがあれば、対応するテンプレートファイルを修正すればよいのです。&lt;/p&gt;
&lt;p&gt;公式ドキュメントより：&lt;/p&gt;
&lt;p&gt;Using this method, there won&amp;rsquo;t be any file under &lt;code&gt;themes&lt;/code&gt; directory. In order to modify the theme, you will have to copy the file you want to modify to the same directory under &lt;code&gt;layouts&lt;/code&gt; directory.&lt;/p&gt;
&lt;p&gt;For example, in order to modify the &lt;code&gt;themes/hugo-theme-stack/layouts/partials/head/custom.html&lt;/code&gt; file, you will have to copy it to &lt;code&gt;layouts/partials/head/custom.html&lt;/code&gt; and modify it there (copy the code from theme&amp;rsquo;s repository). The same applies to &lt;code&gt;assets&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt; directories。&lt;/p&gt;
&lt;h2 id=&#34;テンプレートファイルを見つけるには&#34;&gt;テンプレートファイルを見つけるには。
&lt;/h2&gt;&lt;h3 id=&#34;正統な考え方&#34;&gt;正統な考え方
&lt;/h3&gt;&lt;p&gt;テーマのソースコードファイルを確認し、設計思想を理解した上で、対応するテンプレートファイルを修正すればよい。&lt;/p&gt;
&lt;h3 id=&#34;乱暴な考え方&#34;&gt;乱暴な考え方
&lt;/h3&gt;&lt;p&gt;筆者はフロントエンドコードに詳しくないので、時には乱暴な方法を取ることがあります。例えば、ブラウザで該当のページを開き、変更したい箇所を見つけて、__INLINE_CODE_0__的方式，定位到__INLINE_CODE_1__を使ってテーマソースコード内で検索し、対応するファイルを見つけたら、コピーしてサイトディレクトリに置き、修正すればよいのです。&lt;/p&gt;
&lt;h2 id=&#34;ちょっとしたコツ&#34;&gt;ちょっとしたコツ
&lt;/h2&gt;&lt;p&gt;公式には、スタイルをカスタマイズするためのファイルが用意されています。変更箇所は複数のファイルに分割し、&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; ファイルでそれらのファイルを読み込むことで、より効果的にスタイルファイルを管理できます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/hugo-module-custom-theme-ideas/image.png&#34;
	width=&#34;141&#34;
	height=&#34;375&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;37&#34;
		data-flex-basis=&#34;90px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;変更点まとめ-6時間&#34;&gt;変更点まとめ (6時間)
&lt;/h2&gt;&lt;p&gt;今は、&lt;em&gt;強調&lt;/em&gt; &lt;strong&gt;太字&lt;/strong&gt; &lt;em&gt;さらに強調&lt;/em&gt; は、簡単に片付けられる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全体：グローバルテキストスタイル。以前の &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 融合 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; の表示スタイルを引き継ぎ、中国語に最適化されています。&lt;/li&gt;
&lt;li&gt;ホームページ：右側のナビゲーションにマウスインタラクションアニメーションを追加&lt;/li&gt;
&lt;li&gt;トップページ：記事に要約プレビューを追加しました（時間がかかったため、多少の裏手取りをしています）。&lt;/li&gt;
&lt;li&gt;スクロールバー：スタイルを少し修正しました。&lt;/li&gt;
&lt;li&gt;コードブロックに、&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; コードハイライトプラグインを導入し、コードブロックのスタイルを改善しました。&lt;/li&gt;
&lt;li&gt;一部内容は転載、新規に著作者情報表示、元リンク表示&lt;/li&gt;
&lt;li&gt;アーカイブページ：上部のカテゴリ画像、テーマのカラーオーバーレイを削除し、オリジナル画像をそのまま表示。&lt;/li&gt;
&lt;li&gt;年ごとの分類による統計表示パネルを追加しました。&lt;/li&gt;
&lt;li&gt;アーカイブページ：2列表示レイアウト&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;スクリプトで、カスタム変数を利用して概要プレビューを実現します。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;コードの再利用率が極端に高いのも問題になり、ある部分を変更すると他の部分にも影響が出てくるため、テーマを修正する際は、既存のロジックを壊さないように注意が必要です。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;コメント欄&#34;&gt;コメント欄
&lt;/h3&gt;&lt;p&gt;この男の修正はさらに完璧になった：&lt;a class=&#34;link&#34; href=&#34;https://blog.reincarnatey.net/2024/0719-better-waline/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.reincarnatey.net/2024/0719-better-waline/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ストライク_11__&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;推奨ページ、メールお問い合わせ。当サイトではコメント欄は開放しておりません。&lt;/p&gt;
&lt;/blockquote&gt;</description>
        </item>
        <item>
        <title>Linuxバックエンドサービスにおける大量の文字列データ処理 - 効率が低い</title>
        <link>https://ttf248.life/ja/p/linux-backend-slow-string-processing/</link>
        <pubDate>Wed, 13 Nov 2024 19:42:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-backend-slow-string-processing/</guid>
        <description>&lt;p&gt;C++開発の過去プロジェクトにおいて、カスタムプロトコルを用いて通信しており、そのプロトコルは二次元配列の形式を採用していました。大量データを処理する際、ログ生成のために配列を走査しシリアライズを行う必要がありましたが、効率が悪く、高負荷時にシステムが顕著にカクつくという問題が発生しました。この件について、ビジネス部門からシステムの動作不良に関するフィードバックがありました。&lt;/p&gt;
&lt;h2 id=&#34;問題特定&#34;&gt;問題特定
&lt;/h2&gt;&lt;p&gt;問題の調査において、まずシステムを性能解析したところ、大量データを処理する際にCPU使用率が顕著に増加し、システム応答時間が長くなっていることが判明しました。システムのログを分析した結果、二次元配列の処理における効率の低いシリアライズ操作が多く存在することがわかり、これがシステムパフォーマンスの低下を引き起こしていると考えられます。&lt;/p&gt;
&lt;p&gt;ツール切り取りサービスの スレッド情報を確認した結果、ログスレッドの大部分の時間文字列の結合処理に費やされていることが判明しました。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ここが今日のポイントです。異なる加算方法によって、効率は大きく異なります。過去のコードでは &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 演算子を使用しており、この方法は頻繁に一時オブジェクトを作成するため、非常に低速です。それが非効率的だと知っていても、どれほど非効率的なのかを理解していないようなものです。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;デモ検証&#34;&gt;デモ検証
&lt;/h2&gt;&lt;p&gt;プロジェクトコードに基づいて、業務ロジックを抽出し、文字列結合の効率問題を検証するための簡単なデモを作成しました。&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 下的 __INLINE_CODE_1__BOLD_6&lt;code&gt;linux&lt;/code&gt; 下的 &lt;strong&gt;INLINE_CODE_3&lt;/strong&gt; 编译器，__INLINE_CODE_4__モードでコンパイル実行し、効率を比較します。&lt;/p&gt;
&lt;h3 id=&#34;主なポイント&#34;&gt;主なポイント
&lt;/h3&gt;&lt;p&gt;プロジェクトでは手法4を使用しており、テストデータを入手する前に、読者はどの方法が最も効率的か、またどれが最も非効率かを考えてみることができます。結果を見たときは、やはり驚きました。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;各フィールドを文字列に連結します。&lt;/li&gt;
&lt;li&gt;流（ストリーム）を使用して各フィールドを結合すると、この方法がより効率的です。特に大量のデータを結合する場合に有効です。&lt;/li&gt;
&lt;li&gt;事前に文字列に十分なメモリを割り当てることで、メモリ再配置のオーバーヘッドを削減し、パフォーマンスが向上します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;太字_1&lt;/strong&gt;インライン&lt;strong&gt;イタリック_3&lt;/strong&gt;、&lt;strong&gt;太字_2&lt;/strong&gt;：文字列を連結するたびに新しい一時的な文字列オブジェクトが作成されるため、特に大規模な連結ではパフォーマンスが低下します。これは、連結ごとに新しいメモリの割り当てとコピーが発生するためです。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参照結果から、プロジェクトは効率が最も悪い方法が選択されたことが分かります。&lt;/p&gt;
&lt;p&gt;さらに、異なるプラットフォームのコンパイラ最適化効率を分析すると、Microsoftの&lt;code&gt;visual studio&lt;/code&gt; 一如既往的优秀，针对字符串的优化效率很高，而 &lt;code&gt;gcc&lt;/code&gt;コンパイラは、この点において若干見劣りする。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;コードを異なるマシンで実行した場合、データの比較は直接的な意味を持たないため、それぞれの結合方法間の差異を比較するのが適切です。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;windows 平台下的 vs2022 编译器

----------------------------------------
Data Generation Time: 0.054 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.053 seconds.
+ ostringstream Data merging took: 0.054 seconds.
+ Pre-reserved Data merging took: 0.045 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 16.108 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;linux 平台下的 gcc8.5 编译器
----------------------------------------
Data Generation Time: 0.108 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.100 seconds.
+ ostringstream Data merging took: 0.083 seconds.
+ Pre-reserved Data merging took: 0.057 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 29.298 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完全コード&#34;&gt;完全コード
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;random&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;iomanip&amp;gt;

typedef std::vector&amp;lt;std::string&amp;gt; DataRow;
typedef std::vector&amp;lt;DataRow&amp;gt; DataGroup;

struct ResponsePackage
{
    std::string ErrorInfo;
    DataRow Head;
    std::string ClientId;
    std::string UUID;
    std::string MsgID;
    std::string SessionID;
    std::string ExtraInfo1;
    std::string ExtraInfo2;
    DataGroup DataBody;
};

// Generate specified length of random string
std::string generateRandomString(size_t length)
{
    const char charset[] = &amp;quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&amp;quot;;
    const size_t max_index = sizeof(charset) - 1;
    std::string random_string;
    random_string.reserve(length);

    std::random_device rd;
    std::mt19937 generator(rd());
    std::uniform_int_distribution&amp;lt;&amp;gt; distribution(0, max_index);

    for (size_t i = 0; i &amp;lt; length; ++i)
    {
        random_string += charset[distribution(generator)];
    }

    return random_string;
}

void create_large_string()
{
    // Example request package with 50 fields
    ResponsePackage requestPackage;

    requestPackage.Head = {
        &amp;quot;Field1&amp;quot;, &amp;quot;Field2&amp;quot;, &amp;quot;Field3&amp;quot;, &amp;quot;Field4&amp;quot;, &amp;quot;Field5&amp;quot;,
        &amp;quot;Field6&amp;quot;, &amp;quot;Field7&amp;quot;, &amp;quot;Field8&amp;quot;, &amp;quot;Field9&amp;quot;, &amp;quot;Field10&amp;quot;,
        &amp;quot;Field11&amp;quot;, &amp;quot;Field12&amp;quot;, &amp;quot;Field13&amp;quot;, &amp;quot;Field14&amp;quot;, &amp;quot;Field15&amp;quot;,
        &amp;quot;Field16&amp;quot;, &amp;quot;Field17&amp;quot;, &amp;quot;Field18&amp;quot;, &amp;quot;Field19&amp;quot;, &amp;quot;Field20&amp;quot;,
        &amp;quot;Field21&amp;quot;, &amp;quot;Field22&amp;quot;, &amp;quot;Field23&amp;quot;, &amp;quot;Field24&amp;quot;, &amp;quot;Field25&amp;quot;,
        &amp;quot;Field26&amp;quot;, &amp;quot;Field27&amp;quot;, &amp;quot;Field28&amp;quot;, &amp;quot;Field29&amp;quot;, &amp;quot;Field30&amp;quot;,
        &amp;quot;Field31&amp;quot;, &amp;quot;Field32&amp;quot;, &amp;quot;Field33&amp;quot;, &amp;quot;Field34&amp;quot;, &amp;quot;Field35&amp;quot;,
        &amp;quot;Field36&amp;quot;, &amp;quot;Field37&amp;quot;, &amp;quot;Field38&amp;quot;, &amp;quot;Field39&amp;quot;, &amp;quot;Field40&amp;quot;,
        &amp;quot;Field41&amp;quot;, &amp;quot;Field42&amp;quot;, &amp;quot;Field43&amp;quot;, &amp;quot;Field44&amp;quot;, &amp;quot;Field45&amp;quot;,
        &amp;quot;Field46&amp;quot;, &amp;quot;Field47&amp;quot;, &amp;quot;Field48&amp;quot;, &amp;quot;Field49&amp;quot;, &amp;quot;Field50&amp;quot;
    };

    requestPackage.ClientId = &amp;quot;ClientID&amp;quot;;
    requestPackage.UUID = &amp;quot;UUID&amp;quot;;
    requestPackage.MsgID = &amp;quot;MsgID&amp;quot;;
    requestPackage.SessionID = &amp;quot;SessionID&amp;quot;;
    requestPackage.ExtraInfo1 = &amp;quot;ExtraInfo1&amp;quot;;
    requestPackage.ExtraInfo2 = &amp;quot;ExtraInfo2&amp;quot;;

    // Start timing for data generation
    auto start_gen = std::chrono::high_resolution_clock::now();

    // Generate 10,000 rows of data, each with 50 fields
    for (size_t i = 0; i &amp;lt; 10000; ++i)
    {
        DataRow dataRow(50, &amp;quot;This is a test string&amp;quot;);
        requestPackage.DataBody.push_back(dataRow);
    }

    // End timing for data generation
    auto end_gen = std::chrono::high_resolution_clock::now();
    std::chrono::duration&amp;lt;double&amp;gt; duration_gen = end_gen - start_gen;

    // Display result generation time
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Generation Time: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_gen.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    // Data merging using different methods
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Performance:\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    {
        // Method 1: Using &#39;+=&#39; string concatenation
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (+=) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 2: Using ostringstream
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::ostringstream bodys;
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::ostringstream body;
            body &amp;lt;&amp;lt; &amp;quot;This is a test string&amp;quot;;
            for (auto&amp;amp; item : vec)
            {
                body &amp;lt;&amp;lt; item &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            }
            bodys &amp;lt;&amp;lt; body.str() &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ ostringstream Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 3: Pre-allocated memory
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys;
        bodys.reserve(1000 * 50 * 20); // Pre-allocate enough memory
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            body.reserve(50 * 20); // Pre-allocate memory for each row
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Pre-reserved Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 4: Using &#39;bodys = bodys + body + &amp;quot;\n&amp;quot;&#39;
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body = body + item + &amp;quot; &amp;quot;; // Note the use of &#39;body = body + item&#39;
            }
            bodys = bodys + body + &amp;quot;\n&amp;quot;; // Again, using &#39;bodys = bodys + body&#39;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (bodys = bodys + body + \&amp;quot;\\n\&amp;quot;) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Complete.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;
}

int main()
{
    try
    {
        create_large_string();
    }
    catch (const std::exception&amp;amp; e)
    {
        std::cerr &amp;lt;&amp;lt; &amp;quot;Caught exception: &amp;quot; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\nProgram finished.\n&amp;quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43;ラムダ式におけるパラメータのライフサイクル</title>
        <link>https://ttf248.life/ja/p/cpp-lambda-parameter-lifetime/</link>
        <pubDate>Wed, 13 Nov 2024 19:23:02 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cpp-lambda-parameter-lifetime/</guid>
        <description>&lt;p&gt;C++において、ラムダ式は便利な匿名関数であり、外部変数をキャプチャしてその内部で使用できます。これにより、ラムダは柔軟なプログラミングツールとなります。ただし、ラムダ式のパラメータのライフサイクルは特に注意すべき点であり、特にキャプチャとパラメータの受け渡しにおいて重要です。&lt;/p&gt;
&lt;h3 id=&#34;ラムダ式パラメータのライフサイクル&#34;&gt;ラムダ式パラメータのライフサイクル
&lt;/h3&gt;&lt;p&gt;ラムダ式のパラメータの寿命は、通常、他のC++関数と同様です。関数のパラメータは、関数呼び出し中に存在し、呼び出しが終了すると寿命を終えます。ただし、ラムダ式が外部変数にキャプチャする場合、パラメータの寿命はそのキャプチャ方法の影響を受けます。&lt;/p&gt;
&lt;h3 id=&#34;キャプチャとパラメータのライフサイクルとの関係&#34;&gt;キャプチャとパラメータのライフサイクルとの関係
&lt;/h3&gt;&lt;h4 id=&#34;21-外部変数の捕捉&#34;&gt;2.1 外部変数の捕捉
&lt;/h4&gt;&lt;p&gt;C++のラムダ式は、外部変数を2つの方法でキャプチャできます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;値のキャプチャにより、外部変数の値がラムダ内にコピーされ、そのコピーの寿命はラムダの寿命によって制御されます。&lt;/li&gt;
&lt;li&gt;クローズチャ、外部変数の参照は保持され、ラムダ内の参照は元の外部変数を示し、ライフサイクルは外部変数に依存します。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda_by_value = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };  // 捕获x的副本
auto lambda_by_reference = [&amp;amp;x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };  // 捕获x的引用

lambda_by_value();  // 打印10
lambda_by_reference();  // 打印10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;捕捉された変数のライフサイクルは以下の通りです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;キャプチャされた時点での外部変数の値がラムダにコピーされ、ラムダのライフサイクル終了時にそのコピーが破棄されます。&lt;/li&gt;
&lt;li&gt;ラムダが外部変数の参照を持つこと、&lt;strong&gt;外部变量必须在lambda使用之前有效，否则会导致未定义行为&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ラムダパラメータ&#34;&gt;ラムダパラメータ
&lt;/h4&gt;&lt;p&gt;ラムダのパラメータは通常の関数パラメータと同様で、そのライフサイクルはラムダ関数内に限定されます。つまり、ラムダ呼び出し時にパラメータが作成され、呼び出し終了後にはパラメータのライフサイクルも終了します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto lambda = [](int a, int b) {
    std::cout &amp;lt;&amp;lt; a + b &amp;lt;&amp;lt; std::endl;
};
lambda(5, 10);  // a和b在这里是lambda的参数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この例では、&lt;code&gt;a&lt;/code&gt;BOLD_2&lt;code&gt;b&lt;/code&gt;はラムダ式の引数であり、ラムダ式の呼び出し時に作成され、実行終了後に破棄されます。&lt;/p&gt;
&lt;h3 id=&#34;キャプチャした外部変数のライフサイクル問題&#34;&gt;キャプチャした外部変数のライフサイクル問題
&lt;/h3&gt;&lt;h4 id=&#34;ラムダ関数外でキャプチャされた変数が有効か&#34;&gt;ラムダ関数外でキャプチャされた変数が有効か。
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;ラムダ関数は、呼び出し後も外部変数のコピーを保持するため、外部変数が破棄されても、そのコピー内での利用は安全です。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x 在lambda调用后修改
lambda();  // 打印10，捕获的是x的副本
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;ラムダ関数が外部変数の参照を捕捉する場合、その参照へのアクセスは外部変数のライフサイクルに依存します。外部変数がラムダ関数の実行前に破棄されると、ダングリング参照が発生し、未定義の動作につながる可能性があります。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [&amp;amp;x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x 在lambda调用前修改
lambda();  // 打印20，捕获的是x的引用
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;ラムダの実行順序が確定しない場合、キャプチャされた外部変数がラムダ実行時に有効であることを保証することが重要です。&lt;/p&gt;
&lt;/blockquote&gt;</description>
        </item>
        <item>
        <title>Win11 Logitech G431 ヘッドホン ドライバ インストール</title>
        <link>https://ttf248.life/ja/p/win11-logitech-g431-headphone-driver-installation/</link>
        <pubDate>Wed, 05 Jun 2024 07:20:17 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/win11-logitech-g431-headphone-driver-installation/</guid>
        <description>&lt;p&gt;続きから、帰宅してGhubのアップデートがあるのを見つけて少し嬉しい。カスタマーサポートで報告されていた問題駆動が正常にロードできない問題は解決したとのことだが、色々試しても再インストールやアンインストールしても、やはり正常に使えない。&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景
&lt;/h2&gt;&lt;p&gt;引き続きカスタマーサポートに連絡し対応策を確認したところ、エンジニアによるリモートサポートが可能とのことでしたが、エンジニアの勤務時間と私の勤務時間が完全に重なっており、残念ながら諦めざるを得ませんでした。以前の問題切り分けで残しておいた資料を調べ、手動でのドライバインストールを試すことにします。&lt;/p&gt;
&lt;h2 id=&#34;ドライバーのインストールパッケージを取得する&#34;&gt;ドライバーのインストールパッケージを取得する
&lt;/h2&gt;&lt;p&gt;ロジクールは個別のデバイスドライバを直接提供していません。ドライバファイルをどのように入手できますか？&lt;/p&gt;
&lt;p&gt;前回のリセット時に残ったシステムイメージインストールパッケージを利用して、ローカル仮想マシンで再度システムをリセットできます。完全にクリーンな状態のシステムに、Ghubを個別にデプロイし、ヘッドホンデバイスを仮想マシンに介入させます。すると、ドライバーのパスを見つけられ、それをコピーアウトすることで完了です。&lt;/p&gt;
&lt;p&gt;関連パス：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C:\ProgramData\LGHUB&lt;/li&gt;
&lt;li&gt;C:\Windows\System32\DriverStore\FileRepository\logi_audio.inf_amd64_010b035044e24be4&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;デバイスマネージャー&#34;&gt;デバイスマネージャー
&lt;/h2&gt;&lt;p&gt;Win11システムで手動でドライバーファイルを管理する方法を、まずは簡単に整理します。この部分について、&lt;strong&gt;重点は2つ目のパスを見つける方法です。&lt;/strong&gt; システムに標準搭載されているドライバーが2つあり、ロジクール製が1つあります。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;20240605073331.png&#34; &gt;驱动管理器&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;上記の画像中の2つ目のドライバは、ロジクール製です。現在のデバイスのドライバを分析し、仮想マシン内で全てのドライバパスを探します。まずlogiで始まるファイルを見つけ、ファイルの比較を行うことで、ドライバファイルを特定できます。フォルダ全体をコピーすれば、ドライバインストールパッケージを入手できます。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;20240605073933.png&#34; &gt;驱动安装包&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;ドライバーのインストール&#34;&gt;ドライバーのインストール
&lt;/h2&gt;&lt;p&gt;デバイスマネージャーの画面で、「ドライバーを更新」をクリックし、「私のコンピューターを参照してドライバーを選択」に進むと、以下の画面になります。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;20240605074130.png&#34; &gt;驱动安装&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;もちろん、開くと普通のUSBドライバとしてしか見えますが、ディスクからインストールを選択し、パスは先ほどコピーしたフォルダを指定してください。インストール後、プルダウンメニューにロジテック独自のドライバが表示されるので、デバイスドライバを新しくインストールされたドライバに切り替えてください。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;20240605074208.png&#34; &gt;磁盘安装&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;人体工学デバイスドライバ&#34;&gt;人体工学デバイスドライバ
&lt;/h2&gt;&lt;p&gt;このデバイスのドライバはシステム提供のもので、感嘆符 (!) が付いていないか確認してください。もしあれば、ドライバ選択画面に入り、別の種類のドライバに一時的に切り替えた後、元のドライバに戻すと正常に戻ります。&lt;/p&gt;
&lt;h2 id=&#34;完了&#34;&gt;完了
&lt;/h2&gt;&lt;p&gt;ヘッドホンマイクの音量が通常に戻り、おなじみのイアホン機能も復帰しました。&lt;/p&gt;
&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;20240605074823.png&#34; &gt;侧音&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>ロジクールヘッドホン、ドライバのインストールに失敗</title>
        <link>https://ttf248.life/ja/p/logitech-headset-driver-installation-failed/</link>
        <pubDate>Fri, 31 May 2024 21:46:12 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/logitech-headset-driver-installation-failed/</guid>
        <description>&lt;p&gt;もしこれらのことについて全く理解できないなら、最初から公式のカスタマーサポートに連絡していれば、こんなにも時間を費やすことはなかったでしょう。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/logitech-headset-driver-installation-failed/20240531220709.png&#34;
	width=&#34;693&#34;
	height=&#34;489&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;GHUB&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;141&#34;
		data-flex-basis=&#34;340px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;最近、自宅の開発用のデスクトップPCのCドライブの容量が足りなくなり、特に出番のある256GBのSSDをCドライブ用に割り当てましたが、しょっちゅう色々いじってばかりいました。上海へ引っ越して以来、様々な用事で忙しく、ようやく先週、システムを再インストールしました。&lt;/p&gt;
&lt;p&gt;システムのリセットは順調に進み、普段使うソフトウェアや開発環境の構築にも問題がありませんでした。数日後、リラックスしてゲームをしようとした時、マウスとヘッドセットのドライバがまだインストールされていないことに気づきました。これらのデバイスはどちらもロジクール製なので、ハードウェアを自動認識しドライバをインストールするGHUBというソフトウェアをダウンロードしました。&lt;/p&gt;
&lt;p&gt;しかし、予期せぬことが起こった。マウスのドライバは問題なくインストールされたものの、イヤホンのドライバは「読み込み中」の状態が続いた。最新版Windows 11とロジクルのドライバが互換性がないせいかもしれないと思い、資料を探して手動でドライバをインストールしようとしたが、やはり解決しなかった。&lt;/p&gt;
&lt;p&gt;これらのデバイスのドライバは、それぞれどのような役割を果たしているのか簡単に説明します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;マウスのドライバは主に、マウスの移動速度などの機能を調整するものです。マクロ機能はあまり使いませんが、以前に記憶した設定を復元するだけで十分です。&lt;/li&gt;
&lt;li&gt;ヘッドホンのドライバは主にモニター機能に使われ、チームボイス時に自分の声をモニタリングするのに便利です。システム側のマイク設定にも同様の機能はありますが、ドライバによる実装の方が効果的です。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;何度か試しましたが、イヤホンのドライバーが正常に読み込まれません。今日、ようやくカスタマーサービスに問い合わせてみました。状況を確認してもらうと、最近サーバーに問題があり、ドライバーのダウンロードが異常になっているとのことでした。現在対応中であり、次回アップデートで問題が解決する見通しです。&lt;/p&gt;
&lt;p&gt;まだイヤホンドライバーの問題は解決できていないが、少なくとも原因は分かったので、早く解決することを願っている。&lt;/p&gt;
&lt;h2 id=&#34;マウスドライバー設定&#34;&gt;マウスドライバー設定
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/logitech-headset-driver-installation-failed/20240531220930.png&#34;
	width=&#34;1024&#34;
	height=&#34;768&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;G502&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;133&#34;
		data-flex-basis=&#34;320px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/logitech-headset-driver-installation-failed/20240531220903.png&#34;
	width=&#34;1024&#34;
	height=&#34;768&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;G502&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;133&#34;
		data-flex-basis=&#34;320px&#34;
	
&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>Python辞書にカスタムオブジェクトを格納する際の、参照とdeepcopyの重要性</title>
        <link>https://ttf248.life/ja/p/python-dictionary-custom-objects-reference-vs-deepcopy/</link>
        <pubDate>Fri, 22 Mar 2024 01:08:05 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/python-dictionary-custom-objects-reference-vs-deepcopy/</guid>
        <description>&lt;p&gt;Pythonプログラミングにおいて、辞書は非常に強力なデータ構造であり、キーと値を関連付けて、効率的にデータを検索および操作できます。辞書にカスタムオブジェクトを格納しようとすると、重要な概念に遭遇します。Pythonにおけるオブジェクトの代入は、実際にはオブジェクト自体の深いコピーではなく、参照による代入です。つまり、カスタムオブジェクトを辞書に格納する場合、辞書にはそのオブジェクトへの参照が格納され、オブジェクトの新しいコピーではありません。&lt;/p&gt;
&lt;h2 id=&#34;カスタムオブジェクトの保存に関する基本的な例&#34;&gt;カスタムオブジェクトの保存に関する基本的な例
&lt;/h2&gt;&lt;p&gt;仮に、単純な &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; クラスがあるとします。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

# 创建一个 Person 对象
p1 = Person(&amp;quot;Alice&amp;quot;, 30)

# 将对象存储到字典中
people_dict = {}
people_dict[&amp;quot;alice&amp;quot;] = p1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この例では、&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 字典现在包含一个键为 __INLINE_CODE_1__BOLD_6&lt;code&gt;Person&lt;/code&gt;BOLD_7&lt;code&gt;p1&lt;/code&gt; 对象的引用。如果我们修改 &lt;code&gt;p1&lt;/code&gt; の属性：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;p1.age = 31
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;辞書を通してオブジェクトにアクセスすると、その年齢も更新されていることがわかります。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(people_dict[&amp;quot;alice&amp;quot;].age)  # 输出：31
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;辞書に格納されているのは、&lt;code&gt;Person&lt;/code&gt;オブジェクトの独立したコピーではなく、同じメモリのアドレスを指す参照です。&lt;/p&gt;
&lt;h2 id=&#34;深いコピーと浅いコピーの違い&#34;&gt;深いコピーと浅いコピーの違い
&lt;/h2&gt;&lt;p&gt;ネストされたデータ構造やカスタムオブジェクトを扱う場合、この参照の挙動により予期せぬ結果が生じる可能性がある。例えば、カスタムオブジェクトに可変型の属性（リストや別のカスタムオブジェクトなど）が含まれている場合、そのようなオブジェクトを直接辞書に格納し、それを変更すると、辞書を通して取得したオブジェクトも影響を受ける。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Address:
    def __init__(self, street, city):
        self.street = street
        self.city = city

class Person:
    def __init__(self, name, age, address):
        self.name = name
        self.age = age
        self.address = address

address = Address(&amp;quot;Main St.&amp;quot;, &amp;quot;Springfield&amp;quot;)
p1 = Person(&amp;quot;Bob&amp;quot;, 40, address)
people_dict[&amp;quot;bob&amp;quot;] = p1

# 修改原始地址对象
address.city = &amp;quot;Shelbyville&amp;quot;

# 字典中的人的地址也变了
print(people_dict[&amp;quot;bob&amp;quot;].address.city)  # 输出：Shelbyville
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/p&gt;
&lt;p&gt;このような共有状態がもたらす問題を避けるために、辞書にオブジェクトの完全なコピーを格納し、参照ではなく、ということが必要な場合があります。Python は、この目的を達成するための &lt;strong&gt;copy&lt;/strong&gt;() 関数を提供します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import copy

# 使用深拷贝存储对象
people_dict[&amp;quot;bob_deepcopy&amp;quot;] = copy.deepcopy(p1)

# 此时即使修改原始地址对象，深拷贝的对象不会受影响
address.city = &amp;quot;Capital City&amp;quot;
print(people_dict[&amp;quot;bob&amp;quot;].address.city)  # 输出：Capital City
print(people_dict[&amp;quot;bob_deepcopy&amp;quot;].address.city)  # 输出：Shelbyville
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要するに、Pythonで辞書を使ってカスタムオブジェクトを保存する場合、デフォルトではオブジェクトへの参照が格納されることに注意してください。独立した状態を維持する必要がある場合は、予期せぬデータ変更を防ぐために、深コピーを使用してください。&lt;/p&gt;</description>
        </item>
        <item>
        <title>新しく設置したギガ光ファイバー、なぜ速度測定では100メガにしか見えないのか？</title>
        <link>https://ttf248.life/ja/p/new-gigabit-fiber-slow-speed/</link>
        <pubDate>Mon, 18 Mar 2024 00:29:02 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/new-gigabit-fiber-slow-speed/</guid>
        <description>&lt;p&gt;家庭のネットワークを光速のようにしたいですか？ 鍵は、LANケーブルの選択、ONU（光回線終端装置）とルーターの設定、そして些細なことへの注意です。 このブログでは、カテゴリー6 LANケーブルでギガビットネットワークを構築する方法、簡単なデバイスチェックと設定でネットワーク速度を最大限に引き出す方法をご紹介します。 さあ、一緒に探求して、家庭のインターネット回線を加速させましょう！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;image.png&#34; &gt;手动修复&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;第1章ネットワーク伝送媒体の徹底分析&#34;&gt;第1章：ネットワーク伝送媒体の徹底分析
&lt;/h2&gt;&lt;p&gt;ギガビットネットワーク接続を実現する上で、情報を高速伝送する媒体であるLANケーブルは極めて重要な役割を果たします。以下に、カテゴリー5、カテゴリー6、カテゴリー7のLANケーブルについて詳しく解説します。&lt;/p&gt;
&lt;h3 id=&#34;大声で叫ぶ&#34;&gt;大声で叫ぶ。
&lt;/h3&gt;&lt;p&gt;5種類のLANケーブル（CAT5とも呼ばれる）は、比較的初期に普及したツイストペアケーブルの一種で、各芯線が精密な螺旋構造によって設計され、クロストークを低減しています。主に10/100Mbpsの高速イーサネットで使用され、最大伝送周波数はおよそ100MHzです。過去には広く利用されていましたが、現在のギガビット以上の高速通信ニーズに対しては、物理的な限界から5種類のLANケーブルでは要求を満たすことができません。&lt;/p&gt;
&lt;h3 id=&#34;heading&#34;&gt;
&lt;/h3&gt;&lt;p&gt;技術の発展に伴い、六類ケーブルが登場しました。五類ケーブルと比較して、六類ケーブルはより厳格な製造基準と高度な構造設計を採用しており、耐干渉性と伝送効率が大幅に向上しています。1Gbpsまでのデータ転送速度をサポートし、理想的な条件下では100メートルの伝送距離を実現します。これはまさにギガビットネットワークのアクセスニーズに合致しています。&lt;/p&gt;
&lt;h3 id=&#34;３&#34;&gt;３．
&lt;/h3&gt;&lt;p&gt;カテゴリー7のケーブルは、現在のツイストペア技術における最高水準を示しています。伝送速度が飛躍的に向上しており、理論上最大10Gbpsの超高速通信をサポートするだけでなく、各線対間のシールドと全体の外側のシールドを含む完全なシールドシステムを採用し、外部電磁干渉や近接クロストークを大幅に低減することで、データ転送の安定性と正確性を確保しています。ただし、カテゴリー7ケーブルは主に将来の10ギガビットイーサネットや特定の高要求な環境で使用されます。&lt;/p&gt;
&lt;p&gt;ギガホームネットワーク環境において、ギガファイバーの潜在能力を最大限に引き出すためには、カテゴリー6ケーブルを選択することが最も経済的かつ効率的な選択です。同時に、すべての接続ケーブルの品質が適切であることを確認し、標準的な配線方法を厳守することも、ネットワーク性能を確保する上で重要な要素となります。&lt;/p&gt;
&lt;h2 id=&#34;第2章ネットワークの中枢機器光回線終端装置ルーターlanポート帯域の影響を詳細に調査&#34;&gt;第2章：ネットワークの中枢機器（光回線終端装置、ルーターLANポート帯域）の影響を詳細に調査
&lt;/h2&gt;&lt;h3 id=&#34;光猫とlanポート帯域幅の重要性&#34;&gt;光猫とLANポート帯域幅の重要性
&lt;/h3&gt;&lt;p&gt;光ネコ（こうねこ）、正式名称は光ファイバーモデムであり、家庭ブロードバンド接続の中核機器です。光ファイバー内の光信号をデジタル信号に変換し、家庭内ネットワーク機器が利用できるようにする機能があります。ギガ光ファイバーユーザーにとって、光ネコがギガ伝送に対応しているかどうかが特に重要になります。光ネコのWANポートがギガビットに対応していない場合、戸別線路の光ファイバー速度がどれだけ高くても、このボトルネックによって100Mbps以内に制限されてしまいます。同様に、光ネコのLANポートもギガビット出力能力を備えている必要があり、そうでないと接続されたルーターやその他のデバイスは真のギガビット速度を得ることができません。&lt;/p&gt;
&lt;h3 id=&#34;ルーターlanポートの帯域幅の役割&#34;&gt;ルーターLANポートの帯域幅の役割
&lt;/h3&gt;&lt;p&gt;ルーターのLANポートは、受信したデータを各端末デバイスに配信する役割を担います。ルーターのLANポートが100Mbpsの場合、他の機器の設定に関わらず、100Mbpsの速度でしかローカルネットワーク通信を実現できません。そのため、ギガホームネットワークを構築する際は、ルーターのWANポートがギガデータを受信できること、そしてLANポートもギガレベルのデータ出力能力を提供できるようにすることが重要です。そうすることで、家庭内のすべてのスマートデバイスが高速ネットワークが生み出す快適な体験を享受できます。&lt;/p&gt;
&lt;p&gt;さらに注意すべき点として、一部の古いまたは低価格帯のルーターにはLANポートの自動速度ネゴシエーション機能が存在する場合があります。そのため、ルーター自体がギガビットに対応していても、ケーブルやデバイスの互換性などの理由で100Mbpsモードに降格することがあります。したがって、正しいルーター設定を行い、強制ギガビットモードを有効にし、ギガビットスイッチまたは直接接続されたデバイスと組み合わせることが、全ギガビットネットワークを実現するための重要なステップとなります。&lt;/p&gt;
&lt;p&gt;アップグレード後は、必ずギガ光ファイバー対応のONUとルーターに交換し、全ての機器インターフェースがギガビットに対応していることを確認してください。&lt;/p&gt;
&lt;h2 id=&#34;第3章隠された謎一本途切れられた細い線がテラビットネットワークにどう影響するか&#34;&gt;第3章：隠された謎—一本途切れられた細い線がテラビットネットワークにどう影響するか
&lt;/h2&gt;&lt;h3 id=&#34;サブスレッドの障害とネットワークパフォーマンスの低下&#34;&gt;サブスレッドの障害とネットワークパフォーマンスの低下
&lt;/h3&gt;&lt;p&gt;測速中はネットワーク接続は常に良好で、明らかな断線は見られませんでした。新しく導入された回線のため、配電盤内が整理整頓されておらず、光モデムのケーブルや電源コンセントの位置を調整している際に、たまたまギガビットに達することがありました。&lt;/p&gt;
&lt;p&gt;先行きの資料に基づき、LANケーブルの型番やONUのLAN口速度を分析・検証した結果、原因はLANケーブル内部の茶色のサブワイヤーが断線していたことが判明しました。&lt;/p&gt;
&lt;p&gt;設置の際に、水晶頭を取り付ける職人がケーブルを少し強く引っ張りすぎたことが原因で、内部の細い線が半分ほど断線していました。その後、光回線のモデムの位置を頻繁に移動させた結果、完全に断線しました。&lt;/p&gt;
&lt;h3 id=&#34;6種類のlanケーブルの8本の線の機能解説&#34;&gt;6種類のLANケーブルの8本の線の機能解説
&lt;/h3&gt;&lt;p&gt;六類網線は、TIA/EIA-568-B規格に準拠し、8芯のツイストペアケーブルで構成され、カラーコードは以下の通りです。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;白橙 / 橙&lt;/li&gt;
&lt;li&gt;白緑 / 緑&lt;/li&gt;
&lt;li&gt;藍 / 青&lt;/li&gt;
&lt;li&gt;茶色 / 濃茶&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ギガビットイーサネット（1000BASE-T）規格において、この8本のケーブルのうち4対が同時に動作し、それぞれ以下の役割を担います。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;白橙と橙のこのペアの線（1&amp;amp;2）は、データ送信（Tx+/-）に使用されます。&lt;/li&gt;
&lt;li&gt;白緑と緑のペア（3&amp;amp;6）は、データ受信（Rx+/-）に使用されます。&lt;/li&gt;
&lt;li&gt;白藍と青のペア（4&amp;amp;5）および白茶と茶のペア（7&amp;amp;8）は、ギガビットイーサネットでは通常はメインで使用されませんが、一部の高機能アプリケーション（例えば、特定のPoE給電や将来的な技術拡張）において有効になる可能性があります。一方、従来の100Mbpsネットワークでは、1, 2, 3, 6の4本の線を使用するだけで十分です。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;切断されたファイバーがネットワーク速度に与える影響&#34;&gt;切断されたファイバーがネットワーク速度に与える影響
&lt;/h3&gt;&lt;p&gt;上記の状況において、茶色のサブワイヤー（茶線または茶白線）が切れると、理論上はギガビットネットワーク環境では速度低下が生じます。なぜなら、ギガビットネットワークは全4対の線が双方向通信を行うことで高速を実現しているからです。しかしながら、家庭用ネットワーク機器にはオートネゴシエーション機能があり、ケーブルに問題が発生した場合、正常動作する低速モード、すなわち100Mbpsモードに切り替わります。これにより、サブワイヤーが切れても接続は維持され、100Mbpsで動作することが説明できます。&lt;/p&gt;
&lt;p&gt;要するに、単一の茶色のサブファイバーが切断されても、100Gbpsネットワークの基本的な動作には影響しませんが、ギガビットネットワーク環境下では、それが速度を制限する重要な要因となり得ます。徹底的な診断と修復を行うことで初めて、ギガ光ファイバーの潜在能力を最大限に発揮できます。これは、同様の問題に遭遇した場合、一見すると接続に影響がないように見える小さな故障であっても、ネットワークインフラストラクチャの潜在的な問題を無視してはならないことを示唆しています。そうした問題が高速ネットワーク体験の隠れた障害となる可能性があるからです。&lt;/p&gt;</description>
        </item>
        <item>
        <title>WPFのUIスレッドとフリーズ問題、およびその解決策</title>
        <link>https://ttf248.life/ja/p/wpf-ui-thread-and-freezing-issues-solutions/</link>
        <pubDate>Tue, 12 Mar 2024 07:12:21 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/wpf-ui-thread-and-freezing-issues-solutions/</guid>
        <description>&lt;p&gt;デスクトップアプリケーションを開発する際、特にWindows Presentation Foundation (WPF) フレームワークを使用してリッチクライアントアプリケーションを構築する場合、ユーザーインターフェース（UI）スレッドを正しく処理することは、アプリケーションの滑らかさと応答性を保証するために不可欠です。UI スレッド、別名メインスレッドは、ウィンドウやコントロールイベントの処理、レイアウト計算、およびインターフェースの描画を担当するコアスレッドです。UI 要素とのインタラクションに関わる操作はすべて UI スレッド上で実行されるべきであり、これは WPF および他のほとんどの GUI フレームワークが遵守する基本原則です。&lt;/p&gt;
&lt;h2 id=&#34;uiスレッドとは何ですか&#34;&gt;UIスレッドとは何ですか？
&lt;/h2&gt;&lt;p&gt;WPFアプリケーションの起動時にOSによって作成され、初期化されるUIスレッドは、アプリケーションのメインウィンドウを管理します。このスレッドのみがUIコンポーネントの状態に直接アクセスし、変更できます。ボタンクリックやテキストボックスへの入力、ウィンドウサイズ変更など、ユーザーインタラクションによって発生するすべてのイベントはこのスレッド上で処理されます。また、WPFの依存プロパティシステム、データバインディングメカニズム、およびレイアウトロジックもUIスレッド上で同期的に実行されます。&lt;/p&gt;
&lt;h2 id=&#34;動作不良とその原因&#34;&gt;動作不良とその原因
&lt;/h2&gt;&lt;p&gt;UIスレッドが長時間占有またはブロックされると、例えば時間のかかる計算処理や大量のデータ読み込み、データベースクエリなどのI/O集約型タスクを実行すると、UIスレッドはユーザーからのインタラクション要求にタイムリーに応答できなくなり、結果として画面がフリーズ（応答なし）したように見える。これにより、アプリケーションの遅延や不具合が顕著になり、最悪の場合「Application Not Responding」（ANR）警告が表示されることがある。&lt;/p&gt;
&lt;h2 id=&#34;uiスレッドの2つの基本ルール&#34;&gt;UIスレッドの2つの基本ルール
&lt;/h2&gt;&lt;p&gt;上記のような状況を避けるため、WPF開発者は以下の2つの重要なルールに従うべきです。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;UIスレッドがユーザーの入力にタイムリーに応答し、画面の変化をレンダリングできるように、UIスレッドをブロックする可能性のある操作は、可能な限りバックグラウンドスレッドで実行する必要があります。&lt;/li&gt;
&lt;li&gt;WPFのセキュリティ機構により、UI要素の変更はUIスレッドでのみ許可されます。他のスレッドから直接UIの状態を変更しようとすると例外が発生します。したがって、バックグラウンドスレッドで計算やデータ準備が完了した場合でも、適切なクロススレッド通信メカニズムを通じて結果をUIに表示する必要があります。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;非同期プログラミングとスレッドセーフな更新&#34;&gt;非同期プログラミングとスレッドセーフな更新
&lt;/h2&gt;&lt;p&gt;UIの応答性を維持しつつ、時間のかかるタスクを実行するために、WPFは開発者がこの目標を達成するのを支援するための様々な非同期プログラミングモデルとツールを提供します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WPFのDispatcherクラスを使用すると、タスクをUIスレッドのタスクキューに投入して実行できます。バックグラウンドスレッドから安全にUIを更新するために、&lt;code&gt;Dispatcher.Invoke&lt;/code&gt;或&lt;code&gt;Dispatcher.BeginInvoke&lt;/code&gt;メソッドを利用できます。&lt;/li&gt;
&lt;li&gt;C#の非同期機能を利用することで、非同期メソッドを記述し、その中で__INLINE_CODE_0__キーワードを使用してバックグラウンドタスク完了を待機し、完了後に自動的にUIスレッドで後続のUI更新コードを実行できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;事例&#34;&gt;事例
&lt;/h2&gt;&lt;h3 id=&#34;__inline_code_0__メソッドでuiを更新する&#34;&gt;__INLINE_CODE_0__メソッドでUIを更新する。
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private void Button_Click(object sender, RoutedEventArgs e)
{
    // 假设这是一个耗时操作
    Task.Run(() =&amp;gt;
    {
        var result = LongRunningOperation(); // 这里是模拟一个耗时计算的方法
        
        // 当耗时操作完成后，在UI线程上更新UI
        Application.Current.Dispatcher.Invoke(() =&amp;gt;
        {
            LabelStatus.Text = $&amp;quot;计算结果: {result}&amp;quot;;
        });
    });
}

private string LongRunningOperation()
{
    // 模拟耗时操作
    Thread.Sleep(5000);
    return &amp;quot;已完成&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用__斜体_3__粗体_2__斜体_4__&#34;&gt;使用__斜体_3__粗体_2__斜体_4__
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private async void Button_ClickAsync(object sender, RoutedEventArgs e)
{
    Button button = sender as Button;
    button.IsEnabled = false; // 防止用户重复点击

    try
    {
        // 开启后台任务
        var result = await Task.Run(() =&amp;gt; LongRunningOperation());

        // 在后台任务完成后，自动切换回UI线程更新UI
        LabelStatus.Text = $&amp;quot;计算结果: {result}&amp;quot;;
    }
    catch (Exception ex)
    {
        MessageBox.Show($&amp;quot;发生错误: {ex.Message}&amp;quot;);
    }
    finally
    {
        button.IsEnabled = true; // 重新启用按钮
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>GCCバージョンアップによりプログラムがクラッシュ：非標準コードの潜在的な問題</title>
        <link>https://ttf248.life/ja/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</link>
        <pubDate>Sun, 10 Mar 2024 23:19:06 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</guid>
        <description>&lt;p&gt;同一のビジネスコードの場合、プログラムは CentOS 7 環境で正常にコンパイルされ実行されたが、CentOS 8 に切り替えて更新版 GCC でコンパイルするとクラッシュした。問題は &lt;strong&gt;Release 模式&lt;/strong&gt; の場合にのみ発生し、&lt;strong&gt;Debug 模式&lt;/strong&gt; では全く問題なかった。今回初めてこのような事態に遭遇したが、3 日間の調査の結果、ようやく原因を突き止めた。&lt;/p&gt;
&lt;h3 id=&#34;問題特定&#34;&gt;問題特定
&lt;/h3&gt;&lt;p&gt;徹底的な調査の結果、問題の根本原因は &lt;strong&gt;函数缺少返回值&lt;/strong&gt; にありました。リリースモードでは、GCC の新バージョンがより多くの最適化を行うため、元々明示的な戻り値を持たない関数が実行中に予期せぬ動作を起こし、クラッシュを引き起こしました。結論として、&lt;strong&gt;编译器的警告不容忽视，尤其是在老项目中，部分警告可能被无视，但也应当避免屏蔽所有警告&lt;/strong&gt; です。&lt;/p&gt;
&lt;h3 id=&#34;環境説明&#34;&gt;環境説明
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39)
Copyright © 2015 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 8.5.0 20210514 (Red Hat 8.5.0-21)
Copyright (C) 2018 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;クラッシュ現象&#34;&gt;クラッシュ現象
&lt;/h3&gt;&lt;p&gt;プログラムクラッシュのスタックを解析した結果、以下のスタック情報が見られました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[New LWP 1385902]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib64/libthread_db.so.1&amp;quot;.
Core was generated by `./pstack_main`.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007ffe894b4420 in ?? ()
(gdb) bt
#0  0x00007ffe894b4420 in ?? ()
#1  0x00000000004008e9 in main ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このスタックは直感的ではなく、クラッシュした関数のスタック情報が &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; と表示されているため、問題の特定がより複雑になっています。&lt;/p&gt;
&lt;h3 id=&#34;コード例&#34;&gt;コード例
&lt;/h3&gt;&lt;p&gt;問題をより良く理解するために、クラッシュを再現する最小限のコード例を以下に示します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int test() {
    std::cout &amp;lt;&amp;lt; &amp;quot;1&amp;quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    test();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;そのコード内の &lt;code&gt;test()&lt;/code&gt; 函数显然没有显式返回一个值，而它的返回类型是 &lt;code&gt;int&lt;/code&gt;。根据 C++ 规范，当一个函数声明为 &lt;strong&gt;INLINE_CODE_2&lt;/strong&gt; 型では、必ず値を返す必要がある。さもなくば、未定義の動作を引き起こす可能性がある。&lt;/p&gt;
&lt;h3 id=&#34;コンパイル警告&#34;&gt;コンパイル警告
&lt;/h3&gt;&lt;p&gt;プロジェクトにおいて、CMakeスクリプトが多くのコンパイル時の警告を抑制しており、その中には以下の警告が含まれています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/root/pstack/main.cpp: In function ‘int test()’:
/root/pstack/main.cpp:7:1: warning: no return statement in function returning non-void [-Wreturn-type]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この警告は、__INLINE_CODE_0__関数が値を返さないことを示しており、これが問題の根本原因です。高バージョンGCC（例えば8.5.0）は、コードを最適化する際に、このような未定義の振る舞いに対して不安定な最適化を行い、プログラムをクラッシュさせる可能性があります。&lt;/p&gt;
&lt;h3 id=&#34;アセンブリコードの差異&#34;&gt;アセンブリコードの差異
&lt;/h3&gt;&lt;p&gt;GCCコンパイラ最適化の差異を説明するため、異なるバージョンのGCCが生成するアセンブリコードを比較しました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;アセンブリコードは冗長であり、標準出力ストリーム（&lt;code&gt;std::cout&lt;/code&gt;）的处理逻辑。这表明编译器进行了更保守的优化，未对 &lt;code&gt;test()&lt;/code&gt;関数における戻り値の欠落問題など）に対する過剰な最適化が含まれているため、クラッシュを回避できた可能性がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新しいGCCでは、より多くの最適化が行われ、コード量が削減されました。しかし、この最適化により、戻り値がない関数の実行時に動作が不安定になり、プログラムがクラッシュする可能性があります。&lt;/p&gt;
&lt;h3 id=&#34;結論&#34;&gt;結論
&lt;/h3&gt;&lt;p&gt;今回の問題の調査を通じて、C++において、&lt;strong&gt;函数返回值必须明确&lt;/strong&gt;（特に__INLINE_CODE_0__ 时，必须提供一个返回值。对于使用较旧版本编译器的项目，升级到新版本的 GCC 时，可能会遇到更多的优化和更严格的警告机制。因此，我们建议在编译时 **関数宣言の場合）、すべての警告を無視するのではなく、選択的に処理することが重要であると深く認識しました。特に、関数戻り値や型の一致など、一般的な問題には注意が必要です。&lt;/p&gt;
&lt;p&gt;最終、&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 関数に返り値を追加することで問題が解決し、プログラムは正常に動作するようになった。&lt;/p&gt;</description>
        </item>
        <item>
        <title>VMware仮想マシンのCPUリソース使用量異常</title>
        <link>https://ttf248.life/ja/p/vmware-virtual-machine-cpu-resource-usage-anomaly/</link>
        <pubDate>Sun, 10 Mar 2024 22:14:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/vmware-virtual-machine-cpu-resource-usage-anomaly/</guid>
        <description>&lt;p&gt;バックグラウンド：ローカルマシンにWindows版の業務システムがデプロイされており、CPUリソース使用率は約5%。VMwareにインストールされたCentOS8上にLinux版業務システムをデプロイしたところ、リソース使用量が異常です。&lt;/p&gt;
&lt;h2 id=&#34;問題説明&#34;&gt;問題説明
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;ホストOS：Windows 10 Enterprise&lt;/li&gt;
&lt;li&gt;vmware：17.5&lt;/li&gt;
&lt;li&gt;仮想マシン：CentOS 8&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;仮想マシンリソースの割り当ては__INLINE_CODE_0__です。ビジネスシステムを起動します。ビジネスシステムは仮想マシンLinuxにデプロイされており、仮想マシン内部のtopコマンドでシステムリソースの使用状況を確認したところ、CPU使用率は高くありませんでした。一方、外側のWindowsシステムではタスクマネージャーでCPUリソースの使用率が非常に高いことが確認でき、プロセスを確認するとVMwareプロセスがCPUリソースを大量に消費していました。&lt;/p&gt;
&lt;p&gt;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+
|         Windows           |
|                           |
|   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+  |
|   |      VMware        |  |
|   |      Program       |  |
|   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+  |
|                           |
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+&lt;/p&gt;
&lt;h2 id=&#34;知識点&#34;&gt;知識点
&lt;/h2&gt;&lt;p&gt;この問題の切り分けは順調に進まず、原因が通常のビジネスシステムではなく、仮想マシン自体の問題にあることが判明しました。いかにして発想を通常のビジネスコードからシステム負荷へ、そして負荷データの異常からソフト割り込みへと転換し、最終的に何がVMwareソフト割り込みの効率に影響を与えるかを特定するか？ 本稿ではまず各知識点を解説し、最後に解決策を示します。&lt;/p&gt;
&lt;h3 id=&#34;hyper-v&#34;&gt;hyper-v
&lt;/h3&gt;&lt;p&gt;Windows オペレーティングシステムの仮想化技術は大きな変革を遂げました。Microsoft が WSL を初めてリリースした際、Hyper-V サービスを有効にすると VMware 仮想マシンが同時に使用できませんでした。しかし、その後のバージョンで VMware は Hyper-V サービスとの互換性が得られました。&lt;/p&gt;
&lt;h3 id=&#34;システム負荷&#34;&gt;システム負荷
&lt;/h3&gt;&lt;p&gt;Linuxシステムにおいて、「ロード」（load）とは、実行中または実行待ちのプロセスの数を指します。通常、ロードは1分間、5分間、および15分間の実行キュー内の平均プロセス数を示す3つの数字で表されます。これらの数値は、「uptime」コマンドや「top」コマンドを実行することで確認できます。&lt;/p&gt;
&lt;p&gt;具体的には、この3つの数字はそれぞれ以下のものを表します。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;過去1分間の実行キューの平均プロセス数。&lt;/li&gt;
&lt;li&gt;過去5分間の実行キューの平均プロセス数。&lt;/li&gt;
&lt;li&gt;過去15分間の実行キューの平均プロセス数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;負荷とは、システム内で実行待ちのプロセス数を指します。この数がシステムの論理 CPU 数よりも高い場合、システム負荷が高いことを示し、多くのプロセスがプロセッサリソースを待機していることを意味します。これにより、システムが遅くなったり、応答しなくなったりする可能性があります。その程度やシステムの構成・性能によって異なります。&lt;/p&gt;
&lt;p&gt;理想的には、負荷はシステムの論理 CPU 数範囲内に維持し、システム性能を最適化することが望ましいです。もし負荷が継続的に CPU 数を超えた場合、システム内のプロセスを分析し、高負荷の原因を特定した上で、システムリソースの割り当て調整やプロセスの実行方法の最適化などの対策を講じる必要があるかもしれません。&lt;/p&gt;
&lt;h3 id=&#34;負荷解析-mpstat&#34;&gt;負荷解析 mpstat
&lt;/h3&gt;&lt;p&gt;負荷解析の手順：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;安装 sysstat&lt;/strong&gt;:
もし、あなたのシステムに &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; がインストールされていない場合は、システムに適したパッケージ管理ツールでインストールしてください。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;运行 mpstat&lt;/strong&gt;:
使用リソースの使用状況を表示&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;01:32:33 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
01:32:35 PM  all    0.00    0.00    0.26    0.00    3.73    0.26    0.00    0.00    0.00   95.76
01:32:35 PM    0    0.00    0.00    0.51    0.00    3.57    0.00    0.00    0.00    0.00   95.92
01:32:35 PM    1    0.00    0.00    0.00    0.00    3.59    0.51    0.00    0.00    0.00   95.90
01:32:35 PM    2    0.00    0.00    0.00    0.00    4.15    0.00    0.00    0.00    0.00   95.85
01:32:35 PM    3    0.00    0.00    0.52    0.00    3.61    0.52    0.00    0.00    0.00   95.36
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分析输出&lt;/strong&gt;:
出力には、各CPUの利用率とシステムの平均負荷が含まれます。平均負荷と各CPUの利用率に特に注意を払うことで、システムの負荷状況を把握できます。負荷が高い場合は、原因となっているプロセスやパフォーマンスボトルネックをさらに分析できます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;结合其他工具&lt;/strong&gt;:
様々なツールを用いてシステムパフォーマンスを総合的に分析します。複数のツールの出力を組み合わせることで、システムの負荷状況をより詳細に把握し、パフォーマンス問題の根本原因を特定できます。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;中断&#34;&gt;中断
&lt;/h3&gt;&lt;p&gt;ここでは詳細な説明は省略します。
推奨：&lt;a class=&#34;link&#34; href=&#34;https://www.codedump.info/post/20200522-sgfap-softirq/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《面向应用开发者的系统指南》CPU篇之软中断&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;頻繁なソフト割り込みの発生は、システム負荷に現れる。&lt;/p&gt;
&lt;h2 id=&#34;問題の切り分け&#34;&gt;問題の切り分け
&lt;/h2&gt;&lt;p&gt;CPUの観点だけで問題を特定できない場合、システムに異常が発生している可能性を疑うべきではないでしょうか？ Linuxオペレーティングシステムの負荷が高すぎて、VMwareが過剰なCPUリソースを消費しているのかもしれません。使用率（&lt;code&gt;mpstat&lt;/code&gt;BOLD_3&lt;code&gt;irq&lt;/code&gt;占用异常，单核接近25%，而在正常情况下，启动业务进程空跑时，&lt;code&gt;irq&lt;/code&gt;）は約5%であるはずです。&lt;/p&gt;
&lt;p&gt;グループ内チームメイトの開発環境では、彼のCentOS 7はVMware上にデプロイされており、リソース使用率は正常に表示されている。一方、上海の開発環境では、同様にVMwareだが、ホストのCPUリソース状況を直接観察できない。この際、VMware仮想マシン、Linuxオペレーティングシステム、そしてGCCバージョンという複数の変数が存在する。&lt;/p&gt;
&lt;p&gt;深圳のテスト環境を分析すると、物理マシン上に古いバージョンのGCCコンパイルサービスが稼働しており、CentOS 8上で動作している。興味深いことに、深圳環境では &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; の占有は正常である。&lt;/p&gt;
&lt;p&gt;問題の切り分けのため、より新しいバージョンの GCC でコンパイルしたプログラムを深セン環境にデプロイしてテストした結果、すべて正常でした。&lt;/p&gt;
&lt;p&gt;問題はより明確になりつつあり、オペレーティングシステムに問題があるのではないかと疑い始めています。結局のところ、CentOS 8 は公式サポートが終了しています。しかし、クリーンな CentOS 7 と CentOS 8 を再デプロイしても、問題は依然として存在します。&lt;/p&gt;
&lt;p&gt;今のところ、唯一の不確定要素であるVMware仮想マシンソフトウェアを疑い始めています。すると突然、Hyper-V技術が頭に浮かびました。以前にHyper-Vが有効になっていて、完全にシャットダウンされなかったためにこの問題が発生しているのでしょうか？結局のところ、ソフト割り込みも仮想マシンソフトウェアによって実現されます。異なる仮想化技術にバグは存在しないのでしょうか？これらの問題について深く考察し、調査する必要があります。&lt;/p&gt;
&lt;h2 id=&#34;結論&#34;&gt;結論
&lt;/h2&gt;&lt;p&gt;マイクロソフトの公式ドキュメントによると、ローカルのHyper-Vサービスを完全に停止したところ、VMwareがホスト上で正常に復旧しました。これで問題はついに解決しました。当初述べたように、この経験は紆余曲折があり、総合的な分析と判断が必要でした。また、今回初めて問題の切り分けを行い、仮想マシンレベルまで特定に至りました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Disable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V-Hypervisor
bcdedit /set hypervisorlaunchtype off
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/application-management/virtualization-apps-not-work-with-hyper-v&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/application-management/virtualization-apps-not-work-with-hyper-v&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43;プログラミングの落とし穴：`std::map` の誤った使用によるプログラムクラッシュの詳細解説</title>
        <link>https://ttf248.life/ja/p/cpp-programming-traps-std-map-crash-details/</link>
        <pubDate>Sun, 10 Mar 2024 22:03:06 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cpp-programming-traps-std-map-crash-details/</guid>
        <description>&lt;p&gt;C++プログラミングにおける&lt;code&gt;__INLINE_CODE_0__&lt;/code&gt;コンテナの誤った使用が、プログラムのクラッシュを引き起こす可能性があることを明らかにすることを目的としています。角括弧演算子で存在しないキーにアクセスしようとすると、自動的に空要素が追加されます。この誤解を深く分析し、サンプルコードを通じて潜在的なリスクを示します。&lt;/p&gt;
&lt;p&gt;単純な値を格納する分には問題ありませんが、ポインタを格納すると問題が生じます。ポインタはアドレスであり、初期化されていない場合、そのアドレスは未確定となり、プログラムのクラッシュにつながる可能性があります。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;C++標準ライブラリにおいて、``std::map&lt;code&gt;是一种关联容器，它按照键（key）的升序存储元素，并提供了高效的关键字查找功能。然而，新手开发者有时会因为对&lt;/code&gt;std::map&lt;code&gt;BOLD_6&lt;/code&gt;[]&lt;code&gt;BOLD_7&lt;/code&gt;[]&lt;code&gt; 访问一个不存在的键时，__INLINE_CODE_4__&lt;/code&gt;は新しいキーバリューペアを挿入し、デフォルトコンストラクタを用いてキーに対応する値の型を初期化します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int main() {
    std::map&amp;lt;std::string, int&amp;gt; myMap;
    
    // 错误的用法：假设这里试图访问一个不存在的键并认为会得到0
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for &#39;nonexistent_key&#39;: &amp;quot; &amp;lt;&amp;lt; myMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;

    // 实际上，上述行代码创建了一个新的键值对，其中值被默认初始化为int的默认值（通常是0）
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記のコードはプログラムを直接クラッシュさせることはありませんが、このような暗黙的な挿入処理は、リソースリークや予期せぬ状態変化といった副作用を引き起こす可能性があります。さらに悪いことに、マルチスレッド環境で未初期化のメモリ領域に同時にアクセスすると、プログラムがクラッシュする可能性もあります。&lt;/p&gt;
&lt;p&gt;類似の問題を防ぐため、__INLINE_CODE_0__BOLD_3&lt;code&gt;std::map::count()&lt;/code&gt;BOLD_4&lt;code&gt;std::map::insert()&lt;/code&gt;要素を明示的に挿入することを推奨します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::map&amp;lt;std::string, int&amp;gt; safeMap;
if (safeMap.count(&amp;quot;nonexistent_key&amp;quot;) == 0) {
    std::cout &amp;lt;&amp;lt; &amp;quot;Key does not exist.&amp;quot; &amp;lt;&amp;lt; std::endl;
} else {
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for existing key: &amp;quot; &amp;lt;&amp;lt; safeMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;
}

// 或者明确插入一个键值对，指定初始值
safeMap.insert({ &amp;quot;new_key&amp;quot;, 0 });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;もしmapコンテナ内にポインタ型のオブジェクトが格納されている場合、要素の自動挿入は初期化されていないポインタを保持し、そのポインタに対するいかなる操作もプログラムクラッシュを引き起こす可能性があります。&lt;/p&gt;</description>
        </item>
        <item>
        <title>pstackでプロセスフリーズを調査</title>
        <link>https://ttf248.life/ja/p/pstack-troubleshooting-process-hang/</link>
        <pubDate>Sat, 24 Feb 2024 23:55:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/pstack-troubleshooting-process-hang/</guid>
        <description>&lt;p&gt;ソフトウェア開発や運用において、プロセスがフリーズする状況に遭遇することがあります。この状況はシステムパフォーマンスの低下やサービス停止を引き起こす可能性があります。本稿では、pstackツールを使用してプロセスフリーズの問題をトラブルシューティングする方法について説明します。プロセスのスタック情報を分析することで、問題の原因を特定し解決策を見つけます。&lt;/p&gt;
&lt;p&gt;風控システムの子サービスが応答停止し、風控サービスが利用不能に。サービス可用性モニタリングの不足により、プロセス応答停止をタイムリーに検知できず、システムが利用不能となった。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;プロセスデッドロックとは、プロセスが応答しなくなるものの、終了しない状態を指します。これは、デッドロック、リソース枯渇、例外など、様々な原因で発生する可能性があります。このような問題を解決するためには、pstackツールを使用してプロセスのスタック情報を分析し、問題の根本原因を特定することができます。&lt;/p&gt;
&lt;h2 id=&#34;手順&#34;&gt;手順
&lt;/h2&gt;&lt;p&gt;pstack は、一般的に gdb（GNU デバッガー）と共に提供される便利なツールです。以下のコマンドでインストールできます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt-get install gdb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;プロセスIDの取得：まず、スリープ状態のプロセスのプロセスID（PID）を取得する必要があります。psコマンドを使用して、すべてのプロセスをリストし、調査対象のプロセスIDを見つけます。
pstack ツールを使用してプロセススタックを解析します。プロセス ID を取得したら、pstack ツールでそのプロセスのスタック情報を入手できます。以下のコマンドを実行してください:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pstack &amp;lt;PID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このプロセスが実行中の関数呼び出しシーケンスを表示し、スタック情報を出力します。これらの情報から、プロセスの停止位置を特定し、問題の箇所を突き止めることができます。&lt;/p&gt;
&lt;p&gt;スタック情報を解析することで、プロセスの応答なしの原因を特定できます。デッドロックや無限ループ、その他の異常が発見される可能性があります。状況に応じて、ロックの解放やコードロジックの修正などの対応策を講じてください。&lt;/p&gt;
&lt;h2 id=&#34;事例&#34;&gt;事例
&lt;/h2&gt;&lt;p&gt;簡単なデモで、メイン関数起動後、新しいスレッドを作成し、実際の実行関数が無限ループに入り、プログラムが正常に終了せず、フリーズした状態になる。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cmake_minimum_required(VERSION 3.0.0)
project(pstack_main VERSION 0.1.0 LANGUAGES C CXX)

include(CTest)
enable_testing()

# 查找线程库
find_package(Threads REQUIRED)

add_executable(pstack_main main.cpp)

# 链接线程库
target_link_libraries(pstack_main PRIVATE Threads::Threads)

set(CPACK_PROJECT_NAME ${PROJECT_NAME})
set(CPACK_PROJECT_VERSION ${PROJECT_VERSION})
include(CPack)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;
#include &amp;lt;chrono&amp;gt;

void infiniteLoop() {
    while (true) {
        // 主线程进入死循环
    }
}

int main() {
    std::thread thread(infiniteLoop); // 创建一个线程，执行死循环函数
    thread.join(); // 等待线程结束
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;プログラム起動、pstack結果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Thread 2 (Thread 0x7eff3619b700 (LWP 1315017)):
#0  infiniteLoop () at /root/pstack/main.cpp:6
#1  0x0000000000402ca9 in std::__invoke_impl&amp;lt;void, void (*)()&amp;gt; (__f=@0x2260eb8: 0x4029a6 &amp;lt;infiniteLoop()&amp;gt;) at /usr/include/c++/8/bits/invoke.h:60
#2  0x0000000000402b02 in std::__invoke&amp;lt;void (*)()&amp;gt; (__fn=@0x2260eb8: 0x4029a6 &amp;lt;infiniteLoop()&amp;gt;) at /usr/include/c++/8/bits/invoke.h:95
#3  0x0000000000403150 in std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt;::_M_invoke&amp;lt;0ul&amp;gt; (this=0x2260eb8) at /usr/include/c++/8/thread:244
#4  0x0000000000403126 in std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt;::operator() (this=0x2260eb8) at /usr/include/c++/8/thread:253
#5  0x000000000040310a in std::thread::_State_impl&amp;lt;std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt; &amp;gt;::_M_run (this=0x2260eb0) at /usr/include/c++/8/thread:196
#6  0x00007eff36bceb23 in execute_native_thread_routine () from /lib64/libstdc++.so.6
#7  0x00007eff36ea91ca in start_thread () from /lib64/libpthread.so.0
#8  0x00007eff361d58d3 in clone () from /lib64/libc.so.6
Thread 1 (Thread 0x7eff372e1740 (LWP 1315016)):
#0  0x00007eff36eaa6cd in __pthread_timedjoin_ex () from /lib64/libpthread.so.0
#1  0x00007eff36bceda7 in std::thread::join() () from /lib64/libstdc++.so.6
#2  0x00000000004029d2 in main () at /root/pstack/main.cpp:13
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;確認できるところによると、プロセスのフリーズの原因は無限ループです。メインスレッドが無限ループに入り、サブスレッドが終了できず、結果としてプロセスがフリーズします。&lt;/p&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43;関数呼び出しにかかる時間</title>
        <link>https://ttf248.life/ja/p/cpp-function-call-timing/</link>
        <pubDate>Wed, 24 Jan 2024 14:11:33 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cpp-function-call-timing/</guid>
        <description>&lt;p&gt;設計のSDKについて、様々なコールバック関数実装方法で時間のかかるテストを実施しました。最近C++の関数プログラミングを調べていますが、関数がファーストクラスオブジェクトとなり、プログラム内で流通すると、パフォーマンスに違いはありますか？&lt;/p&gt;
&lt;p&gt;先行きのリンク：&lt;a class=&#34;link&#34; href=&#34;https://ttf248.life/ja/p/compiler-callback-function-performance-testing/&#34; &gt;编译器、回调函数、性能测试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大佬も同様のテストをしており、コードを拝借した。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;実行プラットフォームは、引き続き弊社の旧友、&lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt;です。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;cassert&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

int add_one(int input) { return input + 1; }

bool validate_vector_add_one(std::vector&amp;lt;int&amp;gt; const&amp;amp; input_vector,
                             std::vector&amp;lt;int&amp;gt; const&amp;amp; output_vector)
{
    bool is_valid{true};
    for (size_t i{0}; i &amp;lt; input_vector.size(); ++i)
    {
        if (output_vector.at(i) != input_vector.at(i) + 1)
        {
            is_valid = false;
            break;
        }
    }
    return is_valid;
}

void reset_vector(std::vector&amp;lt;int&amp;gt;&amp;amp; input_vector)
{
    for (size_t i{0}; i &amp;lt; input_vector.size(); ++i)
    {
        input_vector.at(i) = 0;
    }
}

template &amp;lt;typename T, typename Func&amp;gt;
void unitary_function_pass_by_lambda_function(T&amp;amp; output, T const&amp;amp; input,
                                              Func const func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_std_function_value(T&amp;amp; output, T const&amp;amp; input,
                                                 std::function&amp;lt;T(T)&amp;gt; const func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_std_function_reference(
    T&amp;amp; output, T const&amp;amp; input, std::function&amp;lt;T(T)&amp;gt; const&amp;amp; func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_function_pointer(T&amp;amp; output, T const&amp;amp; input,
                                               T (*func)(T))
{
    output = func(input);
}

int main()
{
    // Set floating point format std::cout with 3 decimal places.
    std::cout.precision(3);

    size_t const num_elements{10000000};
    std::vector&amp;lt;int&amp;gt; input_vector(num_elements, 0);
    std::vector&amp;lt;int&amp;gt; output_vector(num_elements, 0);

    auto const lambda_function_add_one{[](int const&amp;amp; input) -&amp;gt; int
                                       { return input + 1; }};
    std::function&amp;lt;int(int)&amp;gt; const std_function_add_one{lambda_function_add_one};

    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a function pointer: &amp;quot; &amp;lt;&amp;lt; sizeof(&amp;amp;add_one)
              &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a std::function pointer: &amp;quot;
              &amp;lt;&amp;lt; sizeof(&amp;amp;std_function_add_one) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a std::function: &amp;quot; &amp;lt;&amp;lt; sizeof(std_function_add_one)
              &amp;lt;&amp;lt; std::endl;

    // Call function frequently in a vanilla way.
    // The compiler knows what function to call at compile time and can optimize
    // the code.
    // This is the best performance we could get.
    std::chrono::steady_clock::time_point const time_start_vanilla{
        std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        output_vector.at(i) = add_one(input_vector.at(i));
    }
    std::chrono::steady_clock::time_point const time_end_vanilla{
        std::chrono::steady_clock::now()};
    auto const time_elapsed_vanilla{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(time_end_vanilla -
                                                             time_start_vanilla)
            .count()};
    float const latency_vanilla{time_elapsed_vanilla /
                                static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass Vanilla: &amp;quot; &amp;lt;&amp;lt; latency_vanilla &amp;lt;&amp;lt; &amp;quot; ns&amp;quot;
              &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // Sometimes, we don&#39;t know what function to call at compile time.
    // We can use std::function to pass a function as an argument.
    // In this case, we pass the std::function by value.
    // Because the size of a std::function is 32 bytes, passing by value
    // results in a lot of copying and bad performance.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_std_function_value{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_std_function_value(
            output_vector.at(i), input_vector.at(i), std_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_std_function_value{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_std_function_value{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_std_function_value -
            time_start_pass_by_std_function_value)
            .count()};
    float const latency_pass_by_std_function_value{
        time_elapsed_pass_by_std_function_value /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Std Function Value: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_std_function_value &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // Instead of passing the std::function by value, we can pass it by
    // reference (pointer). In this case, object copying is eliminated. The
    // performance is better than passing the std::function by value. However,
    // the performance is still not as good as the vanilla way.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_std_function_reference{
            std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_std_function_reference(
            output_vector.at(i), input_vector.at(i), std_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_std_function_reference{
            std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_std_function_reference{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_std_function_reference -
            time_start_pass_by_std_function_reference)
            .count()};
    float const latency_pass_by_std_function_reference{
        time_elapsed_pass_by_std_function_reference /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Std Function Reference: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_std_function_reference &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // std::function is a general purpose wrapper for function pointers,
    // callable objects, and lambda functions. Because it&#39;s general purpose,
    // it&#39;s not as efficient as a function pointer. In this case, we pass a
    // function pointer to a function. The performance is better than passing
    // the std::function by reference.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_function_pointer{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_function_pointer(output_vector.at(i),
                                                  input_vector.at(i), &amp;amp;add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_function_pointer{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_function_pointer{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_function_pointer -
            time_start_pass_by_function_pointer)
            .count()};
    float const latency_pass_by_function_pointer{
        time_elapsed_pass_by_function_pointer /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Function Pointer: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_function_pointer &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // We can also pass a lambda function to a function.
    // The compiler knows what function to call at compile time and can optimize
    // the code. The performance is also better than passing the std::function
    // by reference.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_lambda_function{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_lambda_function(
            output_vector.at(i), input_vector.at(i), lambda_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_lambda_function{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_lambda_function{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_lambda_function -
            time_start_pass_by_lambda_function)
            .count()};
    float const latency_pass_by_lambda_function{
        time_elapsed_pass_by_lambda_function /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Lambda Function: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_lambda_function &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 组里常规也就开启 O2 优化，编译选用了 gcc13，不同版本的 gcc 性能耗时略有不同，版本越高 lambda 效果越好
The size of a function pointer: 8
The size of a std::function pointer: 8
The size of a std::function: 32
Latency Pass Vanilla: 0.418 ns
Latency Pass By Std Function Value: 3.47 ns
Latency Pass By Std Function Reference: 1.36 ns
Latency Pass By Function Pointer: 0.396 ns
Latency Pass By Lambda Function: 0.44 ns
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leimao.github.io/blog/CPP-Function-Call-Performance/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://leimao.github.io/blog/CPP-Function-Call-Performance/&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>プログラムをデバッグからどのようにして回避するか。</title>
        <link>https://ttf248.life/ja/p/program-how-to-anti-debug/</link>
        <pubDate>Tue, 23 Jan 2024 19:46:36 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/program-how-to-anti-debug/</guid>
        <description>&lt;p&gt;ふと思いで、新しい壁紙を探してみる。普段は黒系のシリーズを使っているが、一部にカラフルな要素を取り入れて、デスクトップにアイコンを配置したい。他の色合いの壁紙だとアイコンが見えづらい。&lt;/p&gt;
&lt;p&gt;アセンブリコードをしばらく見つめて考えてみたが、理解できなかった。&lt;code&gt;AI&lt;/code&gt;に頼ってみると、命令は説明されたものの、状況の説明はない。特定の状況下でのみ使用される命令であることは確かで、通常のコードではこのような書き方はしない。&lt;/p&gt;
&lt;p&gt;現今は検索エンジンの方が良いでしょう、アセンブリの知識が足りません。&lt;/p&gt;
&lt;h2 id=&#34;壁紙&#34;&gt;壁紙
&lt;/h2&gt;&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;Snipaste_2024-01-23_19-50-53.png&#34; &gt;黑色汇编壁纸&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;アセンブリコード&#34;&gt;アセンブリコード
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;PUSHFD
MOV DWORD PTR [ESP],0X100
POPFD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;実用的な応用シーン&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool IsDebugged()
{
    __try
    {
        __asm
        {
            pushfd
            mov dword ptr [esp], 0x100
            popfd
            nop
        }
        return true;
    }
    __except(GetExceptionCode() == EXCEPTION_SINGLE_STEP
        ? EXCEPTION_EXECUTE_HANDLER
        : EXCEPTION_CONTINUE_EXECUTION)
    {
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;説明&#34;&gt;説明
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;斜体_3&lt;/strong&gt;&lt;strong&gt;強調_2__斜体_4__&lt;/strong&gt;、コードをトレースするとこのフラグがデバッガによってクリアされるため、この例外が見えなくなります。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;実際のテストでは、検出デバッグの関数をステップオーバーするとデバッグが検知されないことがわかった。デバッグ関数実行時にステップインした場合のみ検知される。(資料調査、未検証)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h2&gt;&lt;p&gt;関連資料は、ウェブサイトの英語版を翻訳したもので、様々なデバッグ対策技術について解説しています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://anti-debug.checkpoint.com/techniques/assembly.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://anti-debug.checkpoint.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://song-10.gitee.io/2021/08/08/Reverse-2021-08-08-anti-debug/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://song-10.gitee.io/2021/08/08/Reverse-2021-08-08-anti-debug/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>焦点インタビュー/CCTVビデオファイルのダウンロード方法</title>
        <link>https://ttf248.life/ja/p/how-to-download-focus-interview-cctv-video-files/</link>
        <pubDate>Tue, 23 Jan 2024 19:23:35 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/how-to-download-focus-interview-cctv-video-files/</guid>
        <description>&lt;p&gt;最近、ある人が「焦点訪談の動画をダウンロードするにはどうすればいいか」と問い合わせてきた。頭に思い浮かんだのは、やはり何かしらの方法で暗号化されているのだろう、と思ったのだが、簡単に処理できた。&lt;/p&gt;
&lt;h2 id=&#34;ダウンローダー&#34;&gt;ダウンローダー
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/nilaoda/N_m3u8DL-CLI&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/nilaoda/N_m3u8DL-CLI&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オープンソースのコマンドライン m3u8/HLS/DASH ダウンローダー。標準的な AES-128-CBC 復号化、マルチスレッド、カスタムリクエストヘッダなどをサポート。簡体字中国語、繁体字中国語、英語をサポート。&lt;/p&gt;
&lt;h2 id=&#34;ブラウザ拡張機能&#34;&gt;ブラウザ拡張機能
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://microsoftedge.microsoft.com/addons/detail/ngjclnbcdbahekojpkhancmiobdahemb&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Live Stream Downloader&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;自信蜜&#34;&gt;自信蜜
&lt;/h2&gt;&lt;p&gt;住所を入手したと思ったのに、結局何も解決せず、セグメントの内容を正常に解析できず。資料を確認すると、公式側でダウンロードアドレスが処理されており、プラグインが解析した &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; を手動でコピー＆リプレースする必要がある。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;https://newcntv.qcloudcdn.com/asp/hls/2000/0303000a/3/default/***********************/2000.m3u8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2024年1月まで、住所テストは有効です。今後の変更については、ご自身でウェブページを解析してください。&lt;/p&gt;
&lt;p&gt;過去のアドレスのバックアップ：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://jln.cn/post/517.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://jln.cn/post/517.html&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>一括でSQL Serverデータベースディスクファイル権限を修正する</title>
        <link>https://ttf248.life/ja/p/bulk-modify-sqlserver-database-disk-file-permissions/</link>
        <pubDate>Tue, 23 Jan 2024 19:06:36 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/bulk-modify-sqlserver-database-disk-file-permissions/</guid>
        <description>&lt;p&gt;会社セキュリティポリシーの変更により、__INLINE_CODE_0__最终还是搬迁回家作为备用服务器，顺带重装机器系统，__INLINE_CODE_1__BOLD_4&lt;code&gt;windows server&lt;/code&gt;。 активацииの方法が非正規なので、自宅での使用であれば активации しなくても問題ないようです。&lt;/p&gt;
&lt;p&gt;非正規品による起動で、Microsoftの検出がトリガーされました（半月ほど正常に動作していました）。サーバーを起動して1時間で自動的にシャットダウンされ、システムログを確認した結果、海賊版ソフトウェアが原因であることが判明しました。&lt;/p&gt;
&lt;p&gt;どうにもならない、システムを再度インストールせざるを得ない状況だ。__INLINE_CODE_0__も再インストールが必要になりそう。毎回面倒くさい作業になる。ファイルアクセス権が厳しく制限されているため、データベースを正常に追記できない。&lt;/p&gt;
&lt;h2 id=&#34;エラーメッセージ&#34;&gt;エラーメッセージ
&lt;/h2&gt;&lt;p&gt;システムを再インストール後、__INLINE_CODE_0__は追加データベースで5120エラーが発生し、オペレーティングシステムによるアクセス拒否となる可能性があります。&lt;/p&gt;
&lt;h2 id=&#34;スクリプト処理&#34;&gt;スクリプト処理
&lt;/h2&gt;&lt;p&gt;前のリンク：&lt;a class=&#34;link&#34; href=&#34;https://ttf248.life/ja/p/bulk-update-local-git-repository-and-legacy-permission-issues/&#34; &gt;批量更新本地Git仓库&lt;/a&gt; 。おなじみのスクリプトですが、フォルダをトラバースしながらファイルの権限を変更します。現在、完全に編集可能な権限を持っています。&lt;/p&gt;
&lt;p&gt;オンラインのチュートリアルはほとんど手動修正を要求するけど、彼らは毎回数ファイルしか変更しないの？私は毎回大量のファイルを抱えて、全て手作業で対応しなければならないから、精神が疲弊するわ。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$currentUserName = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8
$rootDirectory = &amp;quot;D:\data\2013_RujiaInfo&amp;quot;

Get-ChildItem -Path $rootDirectory -Recurse | ForEach-Object {
    $itemPath = $_.FullName

    if ($_ -is [System.IO.DirectoryInfo]) {
        $icaclsResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            Write-Host &amp;quot;已更改文件夹 $itemPath 的所有者为 $currentUserName&amp;quot;
            # 授予当前用户写入权限
            Invoke-Expression &amp;quot;icacls `&amp;quot;$itemPath`&amp;quot; /grant `&amp;quot;$($currentUserName):(OI)(CI)F`&amp;quot;&amp;quot;
            Write-Host &amp;quot;已授予 $currentUserName 编辑文件夹的权限&amp;quot;
        } else {
            Write-Host &amp;quot;无法更改文件夹 $itemPath 的所有者。错误信息: $icaclsResult&amp;quot;
        }
    } else {
        $takeownResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            # 授予当前用户写入权限
            Invoke-Expression &amp;quot;icacls `&amp;quot;$itemPath`&amp;quot; /grant `&amp;quot;$($currentUserName):(F)`&amp;quot;&amp;quot;
            Write-Host &amp;quot;已授予 $currentUserName 编辑文件的权限&amp;quot;
        } else {
            Write-Host &amp;quot;无法更改文件 $itemPath 的所有者。错误信息: $takeownResult&amp;quot;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Linuxシステムベンチマークテスト</title>
        <link>https://ttf248.life/ja/p/linux-system-benchmark-test/</link>
        <pubDate>Tue, 09 Jan 2024 10:56:23 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-system-benchmark-test/</guid>
        <description>&lt;p&gt;Windows プラットフォームには魯大师（ユーエンターマスター）というベンチマークソフトがあり、データが正確とは言えないまでも、ある程度の参考になる。もちろん他のプロフェッショナルなベンチマークソフトもあるが、Linux システムでは特によく合うものがなかなか見つからない。&lt;/p&gt;
&lt;p&gt;Sysbenchは、CPU、メモリ、ファイルI/O、スレッドパフォーマンスなどをテストできる多機能なベンチマークツールです。様々なパフォーマンステストタスクにsysbenchを使用できます。&lt;/p&gt;
&lt;p&gt;テスト用にちょうど3台の機械があります：メカニストミニローカルホスト、アリババクラウド開発雲サーバー、ファーウェイクラウド開発サーバー。&lt;/p&gt;
&lt;h2 id=&#34;sysbenchのインストール&#34;&gt;Sysbenchのインストール
&lt;/h2&gt;&lt;p&gt;ほとんどのLinuxディストリビューションでは、パッケージマネージャーを使用してSysbenchをインストールできます。例えば、CentOS 8では、以下のコマンドでインストールできます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo dnf install sysbench
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sysbench-の使用例&#34;&gt;Sysbench の使用例
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CPU性能テスト：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;メモリ読み出し性能テスト：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;テストファイルI/O性能：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysbench --test=fileio --file-test-mode=rndrw prepare
sysbench --test=fileio --file-test-mode=rndrw run
sysbench --test=fileio --file-test-mode=rndrw cleanup
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;マルチスレッドパフォーマンスのテスト: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;MySQLデータベースのパフォーマンスをテストする（データベースの最大接続数を調整する必要があります）。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword --oltp-table-size=1000000 prepare
sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword --max-time=60 --oltp-read-only=off --oltp-test-mode=complex --max-requests=0 run
sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword cleanup
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;データレポートパオフェン&#34;&gt;データレポート（パオフェン）
&lt;/h2&gt;&lt;meta http-equiv=&#34;Content-Type&#34; content=&#34;text/html; charset=utf-8&#34;&gt;&lt;link type=&#34;text/css&#34; rel=&#34;stylesheet&#34; href=&#34;resources/sheet.css&#34; &gt;
&lt;style type=&#34;text/css&#34;&gt;.ritz .waffle a { color: inherit; }.ritz .waffle .s0{background-color:#ffffff;text-align:left;color:#000000;font-family:&#39;Arial&#39;;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}&lt;/style&gt;&lt;div class=&#34;ritz grid-container&#34; dir=&#34;ltr&#34;&gt;&lt;table class=&#34;waffle&#34; cellspacing=&#34;0&#34; cellpadding=&#34;0&#34;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th class=&#34;row-header freezebar-origin-ltr&#34;&gt;&lt;/th&gt;&lt;th id=&#34;0C0&#34; style=&#34;width:100px;&#34; class=&#34;column-headers-background&#34;&gt;A&lt;/th&gt;&lt;th id=&#34;0C1&#34; style=&#34;width:421px;&#34; class=&#34;column-headers-background&#34;&gt;B&lt;/th&gt;&lt;th id=&#34;0C2&#34; style=&#34;width:398px;&#34; class=&#34;column-headers-background&#34;&gt;C&lt;/th&gt;&lt;th id=&#34;0C3&#34; style=&#34;width:422px;&#34; class=&#34;column-headers-background&#34;&gt;D&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R0&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;1&lt;/div&gt;&lt;/th&gt;&lt;td&gt;&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;本地机械师&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;阿里云&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;华为云&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R1&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;2&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;系统配置&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;System Information&lt;br&gt;  Operating System              Ubuntu 23.04&lt;br&gt;  Kernel                        Linux 6.2.0-36-generic x86_64&lt;br&gt;  Model                         Machenike Machenike DT Computer&lt;br&gt;  Motherboard                   Machenike Machenike DT Computer&lt;br&gt;  BIOS                          American Megatrends International, LLC.&lt;br&gt;DB19V012&lt;br&gt;&lt;br&gt;CPU Information&lt;br&gt;  Name                          Intel Core i7-12650H&lt;br&gt;  Topology                      1 Processor, 10 Cores, 16 Threads&lt;br&gt;  Identifier                    GenuineIntel Family 6 Model 154 Stepping 3&lt;br&gt;  Base Frequency                4.60 GHz&lt;br&gt;  L1 Instruction Cache          32.0 KB x 8&lt;br&gt;  L1 Data Cache                 48.0 KB x 8&lt;br&gt;  L2 Cache                      1.25 MB x 2&lt;br&gt;  L3 Cache                      24.0 MB&lt;br&gt;&lt;br&gt;Memory Information&lt;br&gt;  Size                          62.6 GB&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;System Information&lt;br&gt;  Operating System              CentOS Stream 8&lt;br&gt;  Kernel                        Linux 4.18.0-513.el8.x86_64 x86_64&lt;br&gt;  Model                         Alibaba Cloud Alibaba Cloud ECS&lt;br&gt;  Motherboard                   N/A&lt;br&gt;  BIOS                          SeaBIOS 449e491&lt;br&gt;&lt;br&gt;CPU Information&lt;br&gt;  Name                          Intel(R) Xeon(R) Platinum&lt;br&gt;  Topology                      1 Processor, 1 Core, 2 Threads&lt;br&gt;  Identifier                    GenuineIntel Family 6 Model 85 Stepping 4&lt;br&gt;  Base Frequency                2.50 GHz&lt;br&gt;  L1 Instruction Cache          32.0 KB&lt;br&gt;  L1 Data Cache                 32.0 KB&lt;br&gt;  L2 Cache                      1.00 MB&lt;br&gt;  L3 Cache                      33.0 MB&lt;br&gt;&lt;br&gt;Memory Information&lt;br&gt;  Size                          1.65 GB&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;System Information&lt;br&gt;  Operating System              Ubuntu 22.04.1 LTS&lt;br&gt;  Kernel                        Linux 5.15.0-60-generic x86_64&lt;br&gt;  Model                         OpenStack Foundation OpenStack Nova&lt;br&gt;  Motherboard                   N/A&lt;br&gt;  BIOS                          SeaBIOS&lt;br&gt;rel-1.10.2-0-g5f4c7b1-20181220_000000-szxrtosci10000&lt;br&gt;&lt;br&gt;CPU Information&lt;br&gt;  Name                          Intel(R) Xeon(R) Gold 6278C CPU @ 2.60GHz&lt;br&gt;  Topology                      1 Processor, 1 Core, 2 Threads&lt;br&gt;  Identifier                    GenuineIntel Family 6 Model 85 Stepping 7&lt;br&gt;  Base Frequency                2.60 GHz&lt;br&gt;  L1 Instruction Cache          32.0 KB&lt;br&gt;  L1 Data Cache                 32.0 KB&lt;br&gt;  L2 Cache                      1.00 MB&lt;br&gt;  L3 Cache                      35.8 MB&lt;br&gt;&lt;br&gt;Memory Information&lt;br&gt;  Size                          3.64 GB&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R2&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;3&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;CPU&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Prime numbers limit: 10000&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;CPU speed:&lt;br&gt;    events per second:  4032.48&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0004s&lt;br&gt;    total number of events:              40330&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.25&lt;br&gt;         avg:                                    0.25&lt;br&gt;         max:                                    0.73&lt;br&gt;         95th percentile:                        0.25&lt;br&gt;         sum:                                 9997.55&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           40330.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9975/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Prime numbers limit: 10000&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;CPU speed:&lt;br&gt;    events per second:  1062.51&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0008s&lt;br&gt;    total number of events:              10628&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.91&lt;br&gt;         avg:                                    0.94&lt;br&gt;         max:                                   22.84&lt;br&gt;         95th percentile:                        1.06&lt;br&gt;         sum:                                 9993.46&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           10628.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9935/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Prime numbers limit: 10000&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;CPU speed:&lt;br&gt;    events per second:  1125.56&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0005s&lt;br&gt;    total number of events:              11258&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.86&lt;br&gt;         avg:                                    0.89&lt;br&gt;         max:                                    1.70&lt;br&gt;         95th percentile:                        0.99&lt;br&gt;         sum:                                 9995.40&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           11258.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9954/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R3&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;4&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;内存&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Running memory speed test with the following options:&lt;br&gt;  block size: 1KiB&lt;br&gt;  total size: 102400MiB&lt;br&gt;  operation: write&lt;br&gt;  scope: global&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;Total operations: 101993199 (10198146.52 per second)&lt;br&gt;&lt;br&gt;99602.73 MiB transferred (9959.13 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0001s&lt;br&gt;    total number of events:              101993199&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.00&lt;br&gt;         max:                                    0.03&lt;br&gt;         95th percentile:                        0.00&lt;br&gt;         sum:                                 4059.50&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           101993199.0000/0.00&lt;br&gt;    execution time (avg/stddev):   4.0595/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Running memory speed test with the following options:&lt;br&gt;  block size: 1KiB&lt;br&gt;  total size: 102400MiB&lt;br&gt;  operation: write&lt;br&gt;  scope: global&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;Total operations: 48418803 (4841004.79 per second)&lt;br&gt;&lt;br&gt;47283.99 MiB transferred (4727.54 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0001s&lt;br&gt;    total number of events:              48418803&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.00&lt;br&gt;         max:                                   25.26&lt;br&gt;         95th percentile:                        0.00&lt;br&gt;         sum:                                 4578.95&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           48418803.0000/0.00&lt;br&gt;    execution time (avg/stddev):   4.5789/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Running memory speed test with the following options:&lt;br&gt;  block size: 1KiB&lt;br&gt;  total size: 102400MiB&lt;br&gt;  operation: write&lt;br&gt;  scope: global&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;Total operations: 57056904 (5704765.11 per second)&lt;br&gt;&lt;br&gt;55719.63 MiB transferred (5571.06 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0001s&lt;br&gt;    total number of events:              57056904&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.00&lt;br&gt;         max:                                    0.06&lt;br&gt;         95th percentile:                        0.00&lt;br&gt;         sum:                                 4556.06&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           57056904.0000/0.00&lt;br&gt;    execution time (avg/stddev):   4.5561/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R4&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;5&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;硬盘&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;2147483648 bytes written in 1.81 seconds (1129.59 MiB/sec).&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Extra file open flags: (none)&lt;br&gt;128 files, 16MiB each&lt;br&gt;2GiB total file size&lt;br&gt;Block size 16KiB&lt;br&gt;Number of IO requests: 0&lt;br&gt;Read/Write ratio for combined random IO test: 1.50&lt;br&gt;Periodic FSYNC enabled, calling fsync() each 100 requests.&lt;br&gt;Calling fsync() at the end of test, Enabled.&lt;br&gt;Using synchronous I/O mode&lt;br&gt;Doing random r/w test&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;File operations:&lt;br&gt;    reads/s:                      3373.41&lt;br&gt;    writes/s:                     2248.94&lt;br&gt;    fsyncs/s:                     7201.80&lt;br&gt;&lt;br&gt;Throughput:&lt;br&gt;    read, MiB/s:                  52.71&lt;br&gt;    written, MiB/s:               35.14&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0127s&lt;br&gt;    total number of events:              128288&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.08&lt;br&gt;         max:                                    5.14&lt;br&gt;         95th percentile:                        0.34&lt;br&gt;         sum:                                 9977.78&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           128288.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9778/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;2147483648 bytes written in 19.29 seconds (106.16 MiB/sec).&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Extra file open flags: (none)&lt;br&gt;128 files, 16MiB each&lt;br&gt;2GiB total file size&lt;br&gt;Block size 16KiB&lt;br&gt;Number of IO requests: 0&lt;br&gt;Read/Write ratio for combined random IO test: 1.50&lt;br&gt;Periodic FSYNC enabled, calling fsync() each 100 requests.&lt;br&gt;Calling fsync() at the end of test, Enabled.&lt;br&gt;Using synchronous I/O mode&lt;br&gt;Doing random r/w test&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;File operations:&lt;br&gt;    reads/s:                      1593.12&lt;br&gt;    writes/s:                     1062.08&lt;br&gt;    fsyncs/s:                     3406.64&lt;br&gt;&lt;br&gt;Throughput:&lt;br&gt;    read, MiB/s:                  24.89&lt;br&gt;    written, MiB/s:               16.60&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0164s&lt;br&gt;    total number of events:              60600&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.16&lt;br&gt;         max:                                   31.32&lt;br&gt;         95th percentile:                        0.54&lt;br&gt;         sum:                                 9956.30&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           60600.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9563/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;2147483648 bytes written in 18.29 seconds (111.98 MiB/sec).&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Extra file open flags: (none)&lt;br&gt;128 files, 16MiB each&lt;br&gt;2GiB total file size&lt;br&gt;Block size 16KiB&lt;br&gt;Number of IO requests: 0&lt;br&gt;Read/Write ratio for combined random IO test: 1.50&lt;br&gt;Periodic FSYNC enabled, calling fsync() each 100 requests.&lt;br&gt;Calling fsync() at the end of test, Enabled.&lt;br&gt;Using synchronous I/O mode&lt;br&gt;Doing random r/w test&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;File operations:&lt;br&gt;    reads/s:                      1665.88&lt;br&gt;    writes/s:                     1110.59&lt;br&gt;    fsyncs/s:                     3563.77&lt;br&gt;&lt;br&gt;Throughput:&lt;br&gt;    read, MiB/s:                  26.03&lt;br&gt;    written, MiB/s:               17.35&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0112s&lt;br&gt;    total number of events:              63355&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.16&lt;br&gt;         max:                                  205.01&lt;br&gt;         95th percentile:                        0.78&lt;br&gt;         sum:                                 9972.64&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           63355.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9726/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R5&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;6&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;多线程&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 4&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0002s&lt;br&gt;    total number of events:              197956&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.16&lt;br&gt;         avg:                                    0.20&lt;br&gt;         max:                                    0.34&lt;br&gt;         95th percentile:                        0.21&lt;br&gt;         sum:                                39970.47&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           49489.0000/5.70&lt;br&gt;    execution time (avg/stddev):   9.9926/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 4&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0174s&lt;br&gt;    total number of events:              18360&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.57&lt;br&gt;         avg:                                    2.18&lt;br&gt;         max:                                   32.77&lt;br&gt;         95th percentile:                        2.61&lt;br&gt;         sum:                                40050.41&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           4590.0000/94.36&lt;br&gt;    execution time (avg/stddev):   10.0126/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 4&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0004s&lt;br&gt;    total number of events:              28536&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.23&lt;br&gt;         avg:                                    1.40&lt;br&gt;         max:                                    3.56&lt;br&gt;         95th percentile:                        1.47&lt;br&gt;         sum:                                39975.16&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           7134.0000/39.87&lt;br&gt;    execution time (avg/stddev):   9.9938/0.01&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;h2 id=&#34;追記&#34;&gt;追記
&lt;/h2&gt;&lt;p&gt;完全にレイアウトできず、表形式にできない場合、表示効果が著しく悪くなる。カスタムテーマによるページ幅の制限があり、ページの構成を調整し、幅をパーセント指定に変更した。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;シンプルな方法としては、TablesGeneratorのようなオンラインツールでHTMLテーブルを生成する（複雑な内容は向いていない）。&lt;/li&gt;
&lt;li&gt;またはGoogleドキュメントで作成し、HTMLとしてダウンロードしてブログにコピーする。（簡単で最終的に採用）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;設定でunsafeオプションが有効になっていることを確認し、ページごとに幅を設定してください。&lt;/p&gt;
&lt;p&gt;Hugoにおいて、ページごとに幅を設定できます。これは、ページのFront Matterにカスタムパラメータを追加することで実現可能です。以下はその例です。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Markdown ページの前マター（通常はファイルの先頭部分）に、例えば &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; のようなカスタムパラメータを追加してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;---
title: &amp;quot;我的页面&amp;quot;
date: 2024-01-09
custom_width: &amp;quot;800px&amp;quot;  # 设置宽度为 800 像素
---

正文内容...
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;あなたのHugoテーマで、対応するシングルページテンプレートファイルを見つけてください（例：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;シングルページテンプレートにおいて、Front Matterに &lt;code&gt;custom_width&lt;/code&gt;BOLD_2&lt;code&gt;div&lt;/code&gt; が存在するか確認してください。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{{ define &amp;quot;main&amp;quot; }}
  &amp;lt;div style=&amp;quot;max-width: {{ with .Params.custom_width }}{{ . }}{{ else }}100%{{ end }}; margin: 0 auto;&amp;quot;&amp;gt;
    {{ .Content }}
  &amp;lt;/div&amp;gt;
{{ end }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この例では、インラインスタイル（__INLINE_CODE_0__属性）为 __INLINE_CODE_1__BOLD_7&lt;code&gt;max-width&lt;/code&gt;BOLD_8&lt;code&gt;custom_width&lt;/code&gt; 参数时，宽度默认为100%。&lt;code&gt;margin: 0 auto;&lt;/code&gt; 用于将 &lt;strong&gt;INLINE_CODE_5&lt;/strong&gt;）の要素を中心に配置しています。&lt;/p&gt;
&lt;p&gt;実際の応用では、テーマ構造やCSSスタイルの詳細に応じて、上記の例を調整する必要があるかもしれません。スタイルを調整する際は、テーマの一貫性と可読性を保つようにしてください。&lt;/p&gt;
&lt;p&gt;有効化されたテーマが若干異なるため、サイトのカスタム設定の&lt;code&gt;CSS&lt;/code&gt;構成を最終調整しました。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Gitが無効なHTTPリポジトリ</title>
        <link>https://ttf248.life/ja/p/git-disable-http-repositories/</link>
        <pubDate>Mon, 08 Jan 2024 21:22:04 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/git-disable-http-repositories/</guid>
        <description>&lt;p&gt;ソフトウェアのバージョンを更新する習慣があり、どのバージョンの&lt;code&gt;Git&lt;/code&gt;BOLD_2&lt;code&gt;Http&lt;/code&gt;リポジトリからコードをプルすればよいか分からない。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;fatal: Unencrypted HTTP is not supported for GitLab. Ensure the repository remote URL is using HTTPS
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;背景説明&#34;&gt;背景説明
&lt;/h2&gt;&lt;p&gt;環境：Windowsプラットフォーム、これまでずっとTortoiseGitを使ってgitを操作しており、秘密鍵の設定もTortoiseGit経由で行ってきた。以前に一度スクリプトを作成し、ローカルのリポジトリを一括で更新したことがある。&lt;/p&gt;
&lt;p&gt;先行きのリンク：&lt;a class=&#34;link&#34; href=&#34;https://ttf248.life/ja/p/bulk-update-local-git-repository-and-legacy-permission-issues/&#34; &gt;批量更新本地Git仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コードアップデート中にエラーが発生し、リポジトリが正常に更新されなくなりました。&lt;code&gt;Git&lt;/code&gt;应该提供了配置，让我继续使用&lt;code&gt;http&lt;/code&gt;のアップデートでリポジトリを更新しようとしたのですが、該当する設定項目が見つかりませんでした。&lt;/p&gt;
&lt;p&gt;最も簡単な解決策は、&lt;code&gt;ssh&lt;/code&gt;协议来更新仓库，公司配置的&lt;code&gt;gitlab&lt;/code&gt;短期内不会提供&lt;code&gt;https&lt;/code&gt;プロトコルに切り替えることです。&lt;/p&gt;
&lt;h2 id=&#34;遺棄問題&#34;&gt;遺棄問題
&lt;/h2&gt;&lt;p&gt;前面でバッチ更新スクリプトを作成する際、本来は__INLINE_CODE_0__的方式拉取仓库，也没细查是因为什么，通过小乌龟配置的__INLINE_CODE_1__の設定情報をconfigに同期させるはずだったが、それが実行されず、コマンドラインからの実行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git pull #提示没有权限，无法正常更新仓库
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;コマンドでキー設定を確認することも正しいです。&lt;/p&gt;
&lt;p&gt;もしTortoiseGitで問題なくコードをプルできるのに、コマンドラインでgit pullを実行した際に鍵のエラーが表示される場合、これはTortoiseGitがPuTTYのSSHキーを使用しているのに対し、コマンドラインがOpenSSHのSSHキーを使用していることが原因かもしれません。&lt;/p&gt;
&lt;p&gt;小烏亀のキー設定は、システム.sshフォルダから鍵ファイルを読み込まず、インターフェースのリポジトリ設定時に個別に鍵ファイルのパスを設定します。便利なテクニックとして、最初にリポジトリを構成した際に鍵を設定すれば、他のリポジトリもこの鍵ファイルを再利用できます。PuTTYで鍵をロードすると、すぐに終了せず、プロキシサービスを開始します。&lt;/p&gt;
&lt;p&gt;グローバル設定を調整し、システムデフォルトの__INLINE_CODE_0__設定を使用しないことで、Git Bash は TortoisePlink を使用して SSH 接続を行います。この構成は、TortoiseGit に付属する PuTTY ツールを使用する場合に適しています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global core.sshCommand &amp;quot;&#39;C:/Program Files/TortoiseGit/bin/TortoisePlink.exe&#39; -batch -ssh&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;設定された実行ファイルパスを、必要に応じて小烏龜のパスに合わせて変更してください。完全なパスが設定されているため、システム環境変数への追加は不要です。&lt;/p&gt;</description>
        </item>
        <item>
        <title>AIプログラミングとタスク分解</title>
        <link>https://ttf248.life/ja/p/ai-programming-and-task-decomposition/</link>
        <pubDate>Fri, 22 Dec 2023 08:44:26 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/ai-programming-and-task-decomposition/</guid>
        <description>&lt;p&gt;2年前にサイトに追加したコード領域のコピー機能の開発で、あれほど手間取ったのに、最終的な表示は少し期待外れだった。半熟前任開発者として、動けば良いやと諦め、そのままにしてきた。今年は__INLINE_CODE_0__で小程序を開発し、フロントエンド開発にも慣れたので、改めて（AIによる再設計）。&lt;/p&gt;
&lt;p&gt;悟道：任務分解され、多くの小任務が __INLINE_CODE_0__开发起来还是顺手的。已经倒闭的小程序，__INLINE_CODE_1__BOLD_5&lt;code&gt;AI&lt;/code&gt;提供，拆解了多个任务交付，人工进行项目代码的&lt;code&gt;组装&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;前文&#34;&gt;前文
&lt;/h2&gt;&lt;p&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;CSSとJavaScriptのコードを設計し、class=&amp;ldquo;highlight&amp;rdquo; のウェブ要素を特定。その要素のコンテナ内にコピーボタンを追加し、コードをコピーする機能を実装する。&lt;/p&gt;
&lt;p&gt;最初の草稿のコードには問題があり、再生成した草稿はほぼ使用可能だが、コピー元の内容が正しくなく、重複するテキストが含まれている。再度最適化を促し、手動で主要なカラーデザインと適用されるエフェクトを指定する必要がある。&lt;/p&gt;
&lt;p&gt;ボタンのサイズと色に関して特定の要件があるとのこと、承知いたしました。これらの要件に合わせてボタンのデザインを再設計できます。以下に、ご提示いただいたカラースキームを取り入れ、ボタンのサイズを最適化した調整後のCSSスタイルを示します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.copy-btn {
  position: absolute;
  top: 2px; /* 调整位置 */
  right: 2px;
  padding: 3px 6px; /* 缩小尺寸 */
  font-size: 12px; /* 减小字体大小 */
  background-color: #8FD1E1; /* 按钮背景色 */
  color: #272822; /* 文字颜色 */
  border: 1px solid #272822; /* 边框颜色 */
  border-radius: 3px; /* 圆角 */
  cursor: pointer;
  opacity: 0.7; /* 默认半透明 */
  transition: opacity 0.3s ease, background-color 0.3s ease; /* 平滑过渡效果 */
}

.copy-btn:hover {
  opacity: 1; /* 鼠标悬停时不透明 */
  background-color: #A3D4E5; /* 鼠标悬停时的背景色 */
}

.highlight {
  position: relative;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このスタイルでは、ボタンのサイズとフォントサイズを小さくし、より洗練された印象にしました。また、ボタンのデフォルト状態は半透明で、マウスオーバー時に不透明になり、背景色がわずかに明るくなることで視覚的なフィードバックを提供します。このようなデザインは、お客様の色に関する要件を満たしつつ、モダンさとユーザビリティを維持しています。&lt;/p&gt;
&lt;p&gt;対応する、より簡単なものを提示しました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;document.addEventListener(&#39;DOMContentLoaded&#39;, function() {
  // 查找所有 .highlight 元素
  const highlights = document.querySelectorAll(&#39;.highlight&#39;);

  highlights.forEach(function(highlight) {
    // 创建复制按钮
    const copyBtn = document.createElement(&#39;button&#39;);
    copyBtn.textContent = &#39;复制&#39;;
    copyBtn.classList.add(&#39;copy-btn&#39;);

    // 将按钮添加到每个 .highlight 元素中
    highlight.appendChild(copyBtn);

    // 添加点击事件监听器
    copyBtn.addEventListener(&#39;click&#39;, function() {
      // 假设 .highlight 下的第一个 &amp;lt;code&amp;gt; 元素包含要复制的代码
      const code = highlight.querySelector(&#39;code&#39;) ? highlight.querySelector(&#39;code&#39;).textContent : &#39;&#39;;

      navigator.clipboard.writeText(code).then(() =&amp;gt; {
        // 显示复制成功信息
        copyBtn.textContent = &#39;已复制!&#39;;
        setTimeout(() =&amp;gt; {
          copyBtn.textContent = &#39;复制&#39;;
        }, 2000);
      }).catch(err =&amp;gt; {
        console.error(&#39;复制失败: &#39;, err);
      });
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;追記&#34;&gt;追記
&lt;/h2&gt;&lt;p&gt;コード領域の右上、上部にコピーボタンを追加することを期待していたのですが、フロントエンドについて十分な理解がないため、キーワードで正確に機能を説明できず、&lt;code&gt;AI&lt;/code&gt; と何度かやり取りしても、期待通りの結果が得られませんでした。&lt;/p&gt;
&lt;p&gt;時間の経過とともに、&lt;code&gt;AI&lt;/code&gt;がプログラミングにどの程度影響を与えるか、まだわからない。&lt;/p&gt;</description>
        </item>
        <item>
        <title>クラウドサーバーとスクリプトキッド</title>
        <link>https://ttf248.life/ja/p/cloud-servers-and-script-kids/</link>
        <pubDate>Mon, 20 Nov 2023 15:08:53 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cloud-servers-and-script-kids/</guid>
        <description>&lt;p&gt;ダブルイレブンに合わせてキャンペーンを実施中、アリババクラウドが新たにサーバーを入手しました。経済的なバージョンで、年間99元と安価です。スペックは高くありませんが、踏み台として自宅のサービスを代理するのにも適しています。キャンペーンは2026年まで続きます。&lt;/p&gt;
&lt;p&gt;上海エリアのサーバーを特別に選び、自宅のマシンに低遅延プロキシを設定しました。Windows 11とWindows Server 2022を使用していますが、Server版は後からデプロイしたものです。使用中にアクセス拒否のエラーを受けました。サーバーのアップデートだと思って待っていたのですが、5分後に再度試みると、やはりログインできず、関連するエラーを検索すると、「誰かがログインを試みているため、パスワードの入力回数が多すぎるため、現在ログインできません」というメッセージが表示されています。&lt;/p&gt;
&lt;p&gt;以前にもセキュリティ攻撃のスクリプトに触れたことがあり、すぐにこれらのログインは正常な行動ではないと察せられた。誰かがサービスを攻撃し、ログインサーバーをブルートフォースで破ろうとしているのだろう。サーバーのファイアウォール設定は手抜きで、ホワイトリストを設定していなかった。2台のマシンの3389ポートをプロキシしており、公衆ネットワークに晒されていた。まさに池の中の餌のようなものだ。スクリプトキッドが攻撃していることが分かったので、次の手順は簡単だ。ファイアウォールにホワイトリストを設定し、会社のIPアドレスと自宅のIPアドレスのみがプロキシサービスにアクセスできるようにする。&lt;/p&gt;
&lt;p&gt;以前はプロキシサーバー側に実行ログが設定されていなかったのですが、ログを有効にしたら見ていて面白いことになりました。全国各地のプロキシIPアドレスが私のサーバーへのログインを試みています。幸いなことに、server版のマシンがあったので問題に気づきました。そうでないと、win11 のマシンはいつか必ず突破されるところでした。パスワードの設定は比較的簡単でした。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;2023/11/17 16:51:14 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [101.43.98.211:50486]
2023/11/17 16:51:14 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [218.93.202.63:56970]
2023/11/17 16:51:14 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [222.179.106.174:60812]
2023/11/17 16:51:15 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [58.16.204.238:2839]
2023/11/17 16:51:15 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [124.223.47.24:50274]
2023/11/17 16:51:16 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [43.248.128.22:55883]
2023/11/17 16:51:16 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [43.143.53.138:56955]
2023/11/17 16:51:16 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [43.228.7.250:61550]
2023/11/17 16:51:16 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [125.76.228.9:55842]
2023/11/17 16:51:17 [I] [proxy.go:204] [4dfcc2259937dcb9] [winserver-remote] get a user connection [91.240.118.187:49326]
2023/11/17 16:51:17 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [91.240.118.187:49324]
2023/11/17 16:51:17 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [89.248.163.79:51712]
2023/11/17 16:51:18 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [218.63.75.24:62387]
2023/11/17 16:51:19 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [103.186.109.227:51396]
2023/11/17 16:51:20 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [116.233.234.104:51567]
2023/11/17 16:51:20 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [222.187.193.202:51585]
2023/11/17 16:51:20 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [59.48.98.42:57489]
2023/11/17 16:51:20 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [146.56.241.134:53558]
2023/11/17 16:51:21 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [222.179.106.174:30620]
2023/11/17 16:51:23 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [183.14.214.51:62128]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ついでにLinuxサービスのログインログを確認したところ、アリババクラウドのこのマシン以外に、友人のHuawei Cloudのマシンもあった。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo grep &amp;quot;Failed password&amp;quot; /var/log/secure  centos系列
sudo grep &amp;quot;Failed password&amp;quot; /var/log/auth.log  ubuntu系列
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Nov 16 04:46:34 aliyun-sh sshd[156625]: Failed password for root from 120.55.164.64 port 53410 ssh2
Nov 16 04:46:34 aliyun-sh sshd[156623]: Failed password for root from 111.16.215.122 port 36548 ssh2
Nov 16 04:46:58 aliyun-sh sshd[156630]: Failed password for invalid user share from 139.9.233.78 port 53872 ssh2
Nov 16 04:47:23 aliyun-sh sshd[156634]: Failed password for invalid user spark from 139.9.233.78 port 36134 ssh2
Nov 16 04:47:26 aliyun-sh sshd[156636]: Failed password for root from 120.55.164.64 port 46142 ssh2
Nov 16 04:47:47 aliyun-sh sshd[156640]: Failed password for root from 111.16.215.122 port 42962 ssh2
Nov 16 04:48:24 aliyun-sh sshd[156652]: Failed password for root from 120.55.164.64 port 38868 ssh2
Nov 16 04:48:25 aliyun-sh sshd[156654]: Failed password for root from 111.16.215.122 port 46164 ssh2
Nov 16 04:48:39 aliyun-sh sshd[156657]: Failed password for invalid user test from 139.9.233.78 port 39386 ssh2
Nov 16 04:48:50 aliyun-sh sshd[156659]: Failed password for root from 111.16.215.122 port 38892 ssh2
Nov 16 04:48:53 aliyun-sh sshd[156662]: Failed password for root from 120.55.164.64 port 49348 ssh2
Nov 16 04:48:53 aliyun-sh sshd[156664]: Failed password for invalid user test from 139.9.233.78 port 49864 ssh2
Nov 16 04:50:02 aliyun-sh sshd[156672]: Failed password for root from 111.16.215.122 port 45294 ssh2
Nov 16 04:50:30 aliyun-sh sshd[156680]: Failed password for invalid user zabbix from 139.9.233.78 port 52206 ssh2
Nov 16 04:50:50 aliyun-sh sshd[156683]: Failed password for root from 120.55.164.64 port 34820 ssh2
Nov 16 04:50:51 aliyun-sh sshd[156685]: Failed password for root from 111.16.215.122 port 58978 ssh2
Nov 16 04:51:18 aliyun-sh sshd[156689]: Failed password for root from 120.55.164.64 port 45306 ssh2
Nov 16 04:51:25 aliyun-sh sshd[156692]: Failed password for root from 111.16.215.122 port 33938 ssh2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;そのHuawei Cloudの機械は起動してから時間が経っており、辞書攻撃の中盤に入りつつあり、色々な奇妙なユーザーが現れ始めている。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Nov 16 20:30:35 hecs-411458 sshd[182965]: Failed password for invalid user oeh from 39.129.9.180 port 26459 ssh2
Nov 16 20:32:17 hecs-411458 sshd[182967]: Failed password for invalid user dnu from 39.129.9.180 port 27079 ssh2
Nov 16 20:34:12 hecs-411458 sshd[182971]: Failed password for invalid user rq from 39.129.9.180 port 27742 ssh2
Nov 16 20:36:07 hecs-411458 sshd[182979]: Failed password for invalid user zw from 39.129.9.180 port 28415 ssh2
Nov 16 20:37:59 hecs-411458 sshd[182981]: Failed password for invalid user egi from 39.129.9.180 port 29068 ssh2
Nov 16 20:39:52 hecs-411458 sshd[182984]: Failed password for invalid user bjb from 39.129.9.180 port 29723 ssh2
Nov 16 20:41:53 hecs-411458 sshd[182988]: Failed password for invalid user hna from 39.129.9.180 port 30375 ssh2
Nov 16 20:43:46 hecs-411458 sshd[182994]: Failed password for invalid user gar from 39.129.9.180 port 31036 ssh2
Nov 16 20:45:40 hecs-411458 sshd[183003]: Failed password for invalid user mze from 39.129.9.180 port 31703 ssh2
Nov 16 20:47:35 hecs-411458 sshd[183007]: Failed password for invalid user tmh from 39.129.9.180 port 32381 ssh2
Nov 16 21:23:01 hecs-411458 sshd[183047]: Failed password for invalid user amax from 112.4.65.118 port 41188 ssh2
Nov 16 22:31:20 hecs-411458 sshd[183116]: Failed password for root from 211.228.203.123 port 60213 ssh2
Nov 16 22:53:44 hecs-411458 sshd[183162]: Failed password for root from 112.132.249.164 port 39272 ssh2
Nov 17 11:44:26 hecs-411458 sshd[184811]: Failed password for invalid user jsh from 43.157.103.27 port 54608 ssh2
Nov 17 11:47:23 hecs-411458 sshd[184818]: Failed password for invalid user mrunal from 43.157.103.27 port 50448 ssh2
Nov 17 11:48:46 hecs-411458 sshd[184820]: Failed password for invalid user robertsheen from 43.157.103.27 port 50560 ssh2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;追記&#34;&gt;追記
&lt;/h2&gt;&lt;p&gt;自作サーバーの開発ですが、Windows の公衆網アクセスにはホワイトリスト設定が必要で、Linux ではパスワードログインを禁止し、秘鍵ファイルによるログインを推奨します。&lt;/p&gt;</description>
        </item>
        <item>
        <title>一括でローカルGitリポジトリと、過去の権限問題を更新する。</title>
        <link>https://ttf248.life/ja/p/bulk-update-local-git-repository-and-legacy-permission-issues/</link>
        <pubDate>Thu, 19 Oct 2023 14:16:22 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/bulk-update-local-git-repository-and-legacy-permission-issues/</guid>
        <description>&lt;p&gt;チーム内のプロジェクト間には依存関係があり、過去の経緯から&lt;code&gt;submodule&lt;/code&gt;を用いて依存関係を維持していないため、日々の開発では倉庫コードを手動で順番に更新する必要がある。そうしないと、様々な奇妙な問題が発生する可能性がある。&lt;/p&gt;
&lt;p&gt;オンラインの資料を参考に、構造は基本的に類似しているので、ローカルで手動で倉庫ディレクトリ &lt;strong&gt;git_list.txt&lt;/strong&gt; を維持し、スクリプトを作成してディレクトリをトラバースさせ、一度実行して更新した後、作業前にスクリプトを実行する。&lt;/p&gt;
&lt;h2 id=&#34;linux&#34;&gt;linux
&lt;/h2&gt;&lt;p&gt;create new file: batch_pull.sh&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash

echo &amp;quot;============ 更新仓库 ===================&amp;quot;

# 检查 git_list.txt 是否存在
if [ ! -f &amp;quot;git_list.txt&amp;quot; ]; then
  echo &amp;quot;git_list.txt 文件不存在！请创建并添加要拉取的 git 仓库 URL。&amp;quot;
  exit 1
else
  echo &amp;quot;============ 检测到了 git 仓库清单文件 ====&amp;quot;
fi

# 逐行读取 git_list.txt 中的 URL，并执行拉取操作
while read -r url; do
  if [ -d &amp;quot;$url&amp;quot; ]; then
    cd &amp;quot;$url&amp;quot; || continue
    git pull
    cd ..
    echo &amp;quot;Pull $url 完成！&amp;quot;
    echo &amp;quot;========================================&amp;quot;
  else
    echo &amp;quot;目录 $url 不存在，跳过拉取。&amp;quot;
  fi
done &amp;lt; &amp;quot;git_list.txt&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;windows&#34;&gt;windows
&lt;/h2&gt;&lt;p&gt;create a new file: batch_pull.bat&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bat&#34;&gt;@echo off
chcp 65001 &amp;gt; nul
rem 进入脚本所在目录
cd /d &amp;quot;%~dp0&amp;quot;

rem 检查 git_list.txt 是否存在
if not exist &amp;quot;git_list.txt&amp;quot; (
  echo git_list.txt 文件不存在！请创建并添加要拉取的 git 仓库 URL。
  exit /b 1
) else (
  echo ============ 检测到了 git 仓库清单文件 ====
)

rem 逐行读取 git_list.txt 中的 URL，并执行拉取操作
for /f %%i in (git_list.txt) do (
  if exist &amp;quot;%%i&amp;quot; (
    pushd &amp;quot;%%i&amp;quot;
    git pull
    popd
    echo Pull %%i 完成！
    echo ========================================
  ) else (
    echo 目录 %%i 不存在，跳过拉取。
  )
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;歴史的遺棄問題&#34;&gt;歴史的遺棄問題
&lt;/h3&gt;&lt;p&gt;システム再インストール後に遭遇した「unsafe repository (&amp;rsquo;/home/repon&amp;rsquo;は他のユーザーが所有している)」という致命的なエラーについて。&lt;/p&gt;
&lt;p&gt;オンラインで推奨されている方法は、主に__INLINE_CODE_0__に由来します。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;倉庫ディレクトリへの信頼追加: &lt;code&gt;git config --global --add safe.directory /home/repon&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;手動で設定ファイルを変更し、信頼ディレクトリを指定してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[safe]
    directory = /home/repon
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;処理後、倉庫の更新は正常になりましたが、毎回 __INLINE_CODE_0__コンソールで多数の警告メッセージが表示され、ユーザー所有者のエラーが示されています。&lt;/p&gt;
&lt;h3 id=&#34;デスクトップのosを入れ替える&#34;&gt;デスクトップのOSを入れ替える
&lt;/h3&gt;&lt;p&gt;開発した機械、久しぶりにOSを入れ直したらシステムファイルが爆発してどうしようもない状態に。仕方なくOSを入れ直したが、また同じ権限の問題が発生し、以前のスクリプトが動かない。権限の設定が不完全だったようだ。&lt;/p&gt;
&lt;p&gt;新しいプランを使用し、&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;，这样__INLINE_CODE_1__を追加すると、すべてのディレクトリが自動的に信頼されます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global --add safe.directory &amp;quot;*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;不明な問題です。ユーザー権限の問題か、皆が&lt;code&gt;windows&lt;/code&gt;平台其实也有类似&lt;code&gt;chown&lt;/code&gt;のコマンドに慣れていないのか。フォルダの所有者を変更する必要がある場合、ディレクトリが少ないなら手動で変更することもできます。しかし、このワークステーションにはドメイン情報が追加されており、会社のドメインに異常があるか、ローカルシステムの設定に異常があるかわかりません。ユーザーリストにログインに使用しているユーザーが見つからず、最終的にはコマンドラインで処理しました。&lt;/p&gt;
&lt;p&gt;管理者権限で、&lt;code&gt;powershell&lt;/code&gt;BOLD_3&lt;code&gt;change_ower.ps1&lt;/code&gt;，记得调整脚本文件编码为&lt;code&gt;gbk&lt;/code&gt;を実行し、中国語のオペレーティングシステムを使用してください。そうしないと文字化けします。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;# 获取当前用户的用户名
$currentUserName = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name

# 设置 PowerShell 的字符编码为 UTF-8
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8

# 要更改所有者的根目录路径
$rootDirectory = &amp;quot;G:\workspace&amp;quot;  # 替换为实际的目录路径

# 递归遍历目录并更改文件和文件夹的所有者
Get-ChildItem -Path $rootDirectory -Recurse | ForEach-Object {
    $itemPath = $_.FullName

    # 检查是文件还是文件夹
    if ($_ -is [System.IO.DirectoryInfo]) {
        # 如果是文件夹，使用 icacls 更改所有者权限
        $icaclsResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            Write-Host &amp;quot;已更改文件夹 $itemPath 的所有者为 $currentUserName&amp;quot;
        } else {
            Write-Host &amp;quot;无法更改文件夹 $itemPath 的所有者。错误信息: $icaclsResult&amp;quot;
        }
    } else {
        # 如果是文件，使用 icacls 更改所有者权限
        $takeownResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            # Write-Host &amp;quot;已更改文件 $itemPath 的所有者为 $currentUserName&amp;quot;
        } else {
            Write-Host &amp;quot;无法更改文件 $itemPath 的所有者。错误信息: $takeownResult&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;予期せぬ事態が発生し、スクリプト実行時の中国語情報が文字化けしてしまいました。コンソール文字エンコーディングやスクリプトのエンコードを調整しても改善せず、頭が働いていないような状態でした。コントロールパネルの地域-言語設定のベータ機能を試し、グローバルにUnicodeエンコードを有効にしたところ、スクリプトは正常に動作するようになりました。しかし、複数の開発ソフトウェアが正常に機能しなくなりました。後で資料を整理したところ、スクリプトファイルのエンコードを &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; に設定する必要があることに気づきました。&lt;/p&gt;
&lt;h2 id=&#34;資料&#34;&gt;資料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://ganzhixiong.com/p/f1b9f4fc/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ganzhixiong.com/p/f1b9f4fc/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/71901632/fatal-error-unsafe-repository-home-repon-is-owned-by-someone-else&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stackoverflow.com/questions/71901632/fatal-error-unsafe-repository-home-repon-is-owned-by-someone-else&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>WPF学習資料</title>
        <link>https://ttf248.life/ja/p/wpf-learning-resources/</link>
        <pubDate>Tue, 17 Oct 2023 10:49:24 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/wpf-learning-resources/</guid>
        <description>&lt;p&gt;未着手の小さなプログラム開発のバグがまだ埋まっていないのに、新たに一つ&lt;strong&gt;WPF&lt;/strong&gt;を作り出してしまい、最近は社内も不安定な状況。リモートでの共同作業やコミュニケーションは効率が悪く、思い切ってクライアント側のUI開発を引き受けた。&lt;/p&gt;
&lt;h2 id=&#34;wpf&#34;&gt;WPF
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;推奨 リンク：&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/dotnet/desktop/wpf/introduction-to-wpf?view=netframeworkdesktop-4.8&amp;amp;preserve-view=true&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 微软官网学习资料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;道を&lt;strong&gt;極め&lt;/strong&gt;、基礎となる枠組みの概念を&lt;strong&gt;理解&lt;/strong&gt;すれば、その後の道は容易に迷うことはない。&lt;/p&gt;
&lt;p&gt;以前に__INLINE_CODE_0__BOLD_2&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/zh7791/p/11502696.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 基础总结(学习建议)&lt;/a&gt;がありましたが、内容は短く、経験豊富な読者の学習ルート設計に適しています。&lt;/p&gt;
&lt;p&gt;初心者向けには、&lt;a class=&#34;link&#34; href=&#34;http://www.wpfsoft.com/introduction&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 中文网&lt;/a&gt; をおすすめします。基礎概念から始まり、発展の歴史、そして基盤となるクラスの認知論まで、ゼロから解説しています。このサイトもまた偶然の良いタイミングでした。今年の8月に作者が公開したもので、読者のコース購入を目的としていますが、こちらのスケジュールとちょうど合致しました。もう少し遅れていたら、おそらく縁はなかったでしょう。&lt;/p&gt;
&lt;p&gt;最も信頼できる学習資料は、もちろんマイクロソフトの公式サイトのものですが、やや退屈なので、新しい読者は辛抱強く学ぶ必要があります。&lt;/p&gt;
&lt;p&gt;古典的な電子書籍も多いですが、あまりおすすめできません。日々の仕事が忙しく、じっくり読書する時間がなかなか取れません。そのため、集中して読むのは難しいため、プロジェクト演習の方が向いています。&lt;/p&gt;
&lt;h2 id=&#34;c-と-net-のリリース履歴&#34;&gt;C# と .NET のリリース履歴
&lt;/h2&gt;&lt;p&gt;以前学習した言語に比べると、ここ数年で新機能のリリースが少し多くなり、文法も毎年バージョンアップされている。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/C_Sharp_%28programming_language%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://en.wikipedia.org/wiki/C_Sharp_(programming_language)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;公式学習資料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/dotnet/csharp/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/dotnet/csharp/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/dotnet/core/tutorials/with-visual-studio?pivots=dotnet-7-0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/dotnet/core/tutorials/with-visual-studio?pivots=dotnet-7-0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>分散型LAN ZeroTier</title>
        <link>https://ttf248.life/ja/p/zero-tier-remote-lan/</link>
        <pubDate>Tue, 19 Sep 2023 04:58:03 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/zero-tier-remote-lan/</guid>
        <description>&lt;p&gt;オフィスに新しい&lt;code&gt;mini&lt;/code&gt;主机，想着配置配置环境方便，在家偶尔也有访问的需求，临时部署内网穿透。按照以往的经验，部署&lt;code&gt;frp&lt;/code&gt;服务，指定端口转发，需要一台公网的服务器，连接的质量取决于公网服务器的宽带质量。折腾一点新鲜的&lt;code&gt;Zerotier&lt;/code&gt;虚拟机局域网，类似于&lt;code&gt;VPN&lt;/code&gt;を購入し、ローカルで仮想NICを作成しました。すべてのマシンを仮想ネットワークに参加させました。&lt;/p&gt;
&lt;h2 id=&#34;zerotierとは&#34;&gt;Zerotierとは？
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ZeroTier&lt;/code&gt;BOLD_3&lt;code&gt;SD-WAN&lt;/code&gt;）解决方案，它允许用户在不同地理位置的设备之间创建安全的虚拟网络。通过&lt;code&gt;ZeroTier&lt;/code&gt;、複数のコンピューター、サーバー、デバイスをあたかも同一のローカルネットワークに接続されているかのように、仮想的で暗号化されたネットワークに簡単に接続できます。これにより、プログラマーやIT専門家は、複雑なネットワーク設定やVPN構成なしに、異なる場所間で安全にデータとリソースを共有できます。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;ゼロタイアーネットワークは、インターネット経由で様々なデバイスを接続し、あたかも同一の物理ネットワークにいるかのように動作する、仮想的なグローバルなローカルエリアネットワークです。複数のサブネットを含み、すべてのデバイスはゼロタイアーの技術によって接続されています。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;惑星サーバーはZerotierネットワークの重要な構成要素の一つです。グローバル規模で動作し、Zerotierネットワーク全体のトポロジー構造、ルーティング情報、およびネットワーク状態を維持・管理します。惑星サーバーはネットワーク全体を制御する中心的な役割を果たしますが、データ転送は直接行いません。ユーザーデバイスがZerotierネットワークに参加するには、少なくとも1つの惑星サーバーに接続する必要があります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;転送サーバーはZerotierネットワークにおける補助ノードであり、デバイス間のダイレクト接続を確立するのに役立ちます。デバイスが直接接続できない場合、転送サーバーを通じてデータを送信できます。これにより、ネットワークの到達性とパフォーマンスが向上します。転送サーバーは通常、世界中に配置され、データ伝送の中継地点として機能します。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;全体として、Zerotierは、惑星サーバーとリレーサーバーの協力を通じて、世界中で仮想ローカルエリアネットワークを構築し、デバイス間の安全かつ高速な通信を実現します。惑星サーバーはグローバルネットワーク管理を担当し、リレーサーバーは必要に応じてデバイス間の通信接続を支援します。&lt;/p&gt;
&lt;h2 id=&#34;インストールとデプロイ&#34;&gt;インストールとデプロイ
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;ZeroTier の公式サイト（&lt;a class=&#34;link&#34; href=&#34;https://www.zerotier.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.zerotier.com/&lt;/a&gt;）からインストールファイルとドキュメントを入手してください。&lt;/li&gt;
&lt;li&gt;お客様のオペレーティングシステムに合わせて、ZeroTier Oneクライアントをダウンロードしてインストールしてください。Windows、macOS、Linuxなど、多くのプラットフォームに対応しています。&lt;/li&gt;
&lt;li&gt;インストール後、ZeroTier Oneクライアントを起動してください。&lt;/li&gt;
&lt;li&gt;ZeroTierアカウントを登録してください。まだアカウントをお持ちでない場合は。クライアントで作成できます。&lt;/li&gt;
&lt;li&gt;ZeroTierアカウントにログインし、新しいネットワークを作成してください。ネットワークには一意の16桁のIDが割り当てられ、覚えておく必要があります。&lt;/li&gt;
&lt;li&gt;デバイスにこのネットワークを追加してください。クライアントでネットワークIDを入力するか、QRコードスキャン機能を使用できます。&lt;/li&gt;
&lt;li&gt;ZeroTierクライアントをインストールして設定したデバイスは、同じ仮想ネットワークに追加されます。これらのデバイス間では、あたかも同一のローカルエリアネットワークに接続されているかのように直接通信できるようになります。&lt;/li&gt;
&lt;li&gt;ZeroTierのコントロールパネルで、ネットワーク設定の管理、デバイスの追加、ネットワークトラフィックの監視などが行えます。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;インストールとデプロイ-moon&#34;&gt;インストールとデプロイ moon
&lt;/h2&gt;&lt;p&gt;国内の通信事業者は多くの場合、それを禁止しています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -s https://install.zerotier.com/ | sudo bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;インストールが成功したか確認してください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zerotier-cli info
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ローカルネットワークに参加する&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zerotier-cli join network-id
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;作成&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd /var/lib/zerotier-one &amp;amp;&amp;amp; sudo zerotier-idtool initmoon identity.public &amp;gt; moon.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;設定ファイルを編集し、__INLINE_CODE_0__ノードを &amp;ldquo;サーバーのパブリックIP/9993&amp;rdquo; に調整します。&lt;/p&gt;
&lt;p&gt;署名設定を生成し、&lt;code&gt;moons.d&lt;/code&gt;フォルダを作成。既存ファイルをそこに移動後、サービスを再起動してください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo zerotier-idtool genmoon moon.json
mkdir moons.d &amp;amp;&amp;amp; mv 000000eb444ec0d8.moon moons.d/
systemctl restart zerotier-one.service
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;クライアントノードはmoonサーバーに参加し、IDはJSON設定ファイル内のidフィールドから取得します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zerotier-cli.bat orbit ztaddr ztaddr
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 观察是否出现新的 mooon 节点，id 和信息为服务器配置的相同
[root@idv-36f9d5 ~]# zerotier-cli listpeers
200 listpeers &amp;lt;ztaddr&amp;gt; &amp;lt;path&amp;gt; &amp;lt;latency&amp;gt; &amp;lt;version&amp;gt; &amp;lt;role&amp;gt;
200 listpeers 0cccb***** 35.236.*.*/64393;110;10726 327 1.6.3 LEAF
200 listpeers 3a46f***** 185.180.*.*/9993;110;757 -1 - PLANET
200 listpeers 3ed7c***** 39.97.*.*/9993;172;79 32 1.6.3 MOON
200 listpeers 4f838***** - -1 - LEAF
200 listpeers 62f86***** 50.7.*.*/9993;110;4796 351 - PLANET
200 listpeers 778cd***** 103.195.*.*/9993;5148;4887 253 - PLANET
200 listpeers 992fc***** 195.181.*.*/9993;10161;4921 226 - PLANET
200 listpeers 9d2b5***** - -1 - LEAF
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Windows プラットフォームでは管理者権限でターミナルを起動し、zerotier-cli.bat コマンドライン操作を行い、Linux プラットフォームでは zerotier-cli 操作を行います。peers サブコマンドで接続状況を確認し、listpeers で全てのノードを表示します。&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; ノードが表示される場合、正常に加入したことを示します。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;どうやってアンインストールしますか&#34;&gt;どうやってアンインストールしますか。
&lt;/h2&gt;&lt;p&gt;&lt;em&gt;斜体&lt;/em&gt;&lt;strong&gt;太字&lt;/strong&gt;&lt;em&gt;斜体&lt;/em&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;dpkgでzerotier-oneサービスを削除します。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo dpkg -P zerotier-one
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;ゼロタイアーワンのフォルダを削除してください。このフォルダにはアドレスが保存されており、削除後に再インストールすると新しいアドレスが割り当てられます。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo rm -rf /var/lib/zerotier-one/
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;追記&#34;&gt;追記
&lt;/h2&gt;&lt;p&gt;元々全てアンインストール済みで、サーバーが到着したものの、適切なプロキシノードとなるサービスがなく、アリババクラウドが業績のために開発限定サーバーを提供してきた。スペックは高くなく、年間99元と手頃な価格だったため、2年ほど利用している。重視したのは、サーバーの提供する帯域幅だ。&lt;/p&gt;
&lt;h2 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.wnark.com/archives/152.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.wnark.com/archives/152.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/Yogile/p/12642423.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cnblogs.com/Yogile/p/12642423.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>VMware仮想マシンディスクスペース最適化</title>
        <link>https://ttf248.life/ja/p/vmware-virtual-disk-space-optimization/</link>
        <pubDate>Wed, 21 Jun 2023 18:35:41 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/vmware-virtual-disk-space-optimization/</guid>
        <description>&lt;p&gt;仮想機をインストールする際、開発システムでは通常、ディスクスペースを多めに確保しますが、使用期間が長くなると、ローカルで占有するディスク容量は仮想ファイルの実際のコンテンツを大幅に上回ることがあります。&lt;/p&gt;
&lt;h2 id=&#34;シーン描写&#34;&gt;シーン描写
&lt;/h2&gt;&lt;p&gt;指示に従い、現在のマシンのディスク情報を確認したところ、実際に使用しているのは60GB。全てのスナップショットとクローンイメージを削除しても、ローカル仮想マシンが占有するディスクスペースは依然として60GBを大幅に超えており、すでに逼迫していたハードディスクの負担をさらに増やしてしまった。&lt;/p&gt;
&lt;h2 id=&#34;前提条件&#34;&gt;前提条件
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;仮想マシンをインストールする際に、プリ割り当てディスクのチェックボックスにチェックが入れられていませんでした。&lt;/li&gt;
&lt;li&gt;仮想マシンの保存に使用するディスクの空き容量が、現在の仮想マシンが使用している容量よりも大きいこと。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;残りのスペースが足りないため、一時的に仮想マシンを外付けHDDに移動し、ディスクを最適化した後に移行に戻すことを検討してください。&lt;/p&gt;
&lt;h2 id=&#34;道具&#34;&gt;道具
&lt;/h2&gt;&lt;p&gt;公式パッケージが提供されており、yumでインストールするか、VMware Toolsイメージパッケージでインストールできます。&lt;/p&gt;
&lt;h2 id=&#34;命令&#34;&gt;命令
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vmware-toolbox-cmd disk shrink /
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;実行後、仮想マシンは自動的にシャットダウンされ、VMwareホストプログラムがディスクの圧縮を実行します。処理時間は、仮想マシンのサイズとディスクアクセス速度に依存します。&lt;/p&gt;
&lt;p&gt;仮想マシンのディスク領域の使用量は、基本的に__INLINE_CODE_0__のディスク情報とほぼ等しいです。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Stable Diffusion - ゼロからのインストールとその顛末</title>
        <link>https://ttf248.life/ja/p/stable-diffusion-zero-install-saga/</link>
        <pubDate>Thu, 13 Apr 2023 00:23:54 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/stable-diffusion-zero-install-saga/</guid>
        <description>&lt;p&gt;国内の資料は、基本的に&lt;strong&gt;秋叶&lt;/strong&gt;氏の一括デプロイパッケージを推奨している。__INLINE_CODE_0__ベースのオープンソースプロジェクトなので、導入もそれほど複雑ではないはずだ。ゼロからやってみるか。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;AI生成画像の作成のために、わざわざグラフィックカードを交換したのに、__INLINE_CODE_0__入门版本；服役七年的__INLINE_CODE_1__してしまった。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主要の暗号化は依然として有効になっていません。&lt;/p&gt;
&lt;h2 id=&#34;未処理&#34;&gt;未処理
&lt;/h2&gt;&lt;p&gt;PyTorchの紹介、バージョン対応関係、バージョン確認方法について、改めて構成を見直します。
ローカル環境で仮想環境を新たに作成し、PyTorch をデプロイする方法は？
翻訳資料、ゼロから始めるStable Diffusion &lt;a class=&#34;link&#34; href=&#34;https://stable-diffusion-art.com/install-windows/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stable-diffusion-art.com/install-windows/&lt;/a&gt;
資料を整理する。&lt;/p&gt;
&lt;h2 id=&#34;手順&#34;&gt;手順
&lt;/h2&gt;&lt;p&gt;中国語で検索しても、ステップバイステップのインストールチュートリアルが見つからないかもしれません。まず、リポジトリをダウンロードし、スクリプトをダブルクリックすれば完了です。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/AUTOMATIC1111/stable-diffusion-webui&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;詳細な使用方法とFAQについては、&lt;strong&gt;&lt;em&gt;このページ&lt;/em&gt;&lt;/strong&gt; を参照してください。&lt;/p&gt;
&lt;p&gt;なぜか誰もこの倉庫が何なのかを説明してくれない。名前からでもわかるように、これはインターフェースコンソールで、使う私たちにとってより便利になるはずだ。実際、インストール時に公式リポジトリの内容をダウンロードし、実際の__INLINE_CODE_0__コードを入手する。&lt;/p&gt;
&lt;p&gt;倉庫でも、インストール起動スクリプトを作成しました。現在のフォルダに__INLINE_CODE_0__虚拟环境。如果有的话默认使用当前路径的的__INLINE_CODE_1__があるかどうかを自動的に識別します。&lt;/p&gt;
&lt;p&gt;もし完全に初心者の方でしたら、こちらをご覧ください：&lt;a class=&#34;link&#34; href=&#34;https://stable-diffusion-art.com/install-windows/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stable-diffusion-art.com/install-windows/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;pytorch&#34;&gt;pytorch
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://pytorch.org/get-started/locally/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pytorch.org/get-started/locally/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ここに私が今日話したいことの肝心な点があります。まず、彼らの手順に従ってスクリプトを直接起動しないでください。Pythonはrequirementファイルで依存ライブラリをインストールするので、これは些細な問題です。重要なのは、GPUドライバのバージョンとPyTorchが対応していることです。これについては多くの情報があり、ネット検索すればすぐに見つかります。&lt;/p&gt;
&lt;p&gt;参考：&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/weixin_40660408/article/details/129896700&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/weixin_40660408/article/details/129896700&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;仮想環境を作成し、そこに公式サイトのスクリプトを実行してPyTorchをインストールします。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python -c &amp;quot;import torch; print(torch.version.cuda)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python -c &amp;quot;import torch; print(torch.__version__, torch.cuda.is_available())&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記の2つのスクリプトで、インストールするCUDAのバージョンを確認したり、インストールが成功したかどうかをチェックできます。&lt;/p&gt;
&lt;p&gt;ここでは、凝った操作は推奨しません。まずは公式ページのロジックに従ってコピーし、そのままインストールしてください。pipでインストールしようとすると、うまくいかないか、CUDAが有効にならない可能性が高いです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;フォルダのパスに余計なものが含まれていると、PyTorchが正常に動作しない可能性があります。&lt;/p&gt;
&lt;p&gt;何度か試行錯誤し、公式のインストールファイルをダウンロードして手動でインストールも試しました。2.0へのアップデートを考えていたのですが、公式ドキュメントには2.0の方が速度が速いと書いてありました。しかし、以前からあまり使っていなかったので、Pythonのバージョンやそれが影響しているのかはわかりません。途中で公式のマニュアルを確認したところ、3.8の使用が推奨されています。そこで少し競合が発生しました。以前はワンクリックインストールパッケージを使用しており、その中には3.10のバージョンが含まれていたためです。最終的には、最初からやり直して、まず新しいフォルダを作成し、仮想環境を作成し、torchが正常にインストールされていることを確認しました。&lt;/p&gt;
&lt;p&gt;インストールした仮想環境を、Web UIのフォルダに移動してください。その後でスクリプトによるインストールを行うと、依存関係の問題はほとんどなくなります。&lt;/p&gt;
&lt;p&gt;移動後に、python -m pip install &amp;ndash;upgrade &amp;ndash;force-reinstall pip を実行して、pipを修正する必要があります。&lt;/p&gt;
&lt;p&gt;見た目はなんだか不可解に見えるかもしれませんが、この場所でかなり色々試しました。原因を特定するため、torchが正しく認識されない問題を解決するために、他の依存関係のインストール前にまずこれをインストールするという手順にしました。&lt;/p&gt;
&lt;h2 id=&#34;xformers&#34;&gt;Xformers
&lt;/h2&gt;&lt;p&gt;推奨します。画像生成を高速化し、既存の占有量を削減できます。副作用は、同じパラメータグループで &lt;strong&gt;生成的图像相对不是那么稳定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Xformers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;stable-diffusion-webui:Xformers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://huggingface.co/docs/diffusers/optimization/xformers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;huggingface optimization&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Optimization Ratio&lt;/th&gt;
&lt;th&gt;Time taken&lt;/th&gt;
&lt;th&gt;Torch active/reserved&lt;/th&gt;
&lt;th&gt;Sys VRAM&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;100.00%&lt;/td&gt;
&lt;td&gt;2m 57.03s&lt;/td&gt;
&lt;td&gt;7440/10058 MiB&lt;/td&gt;
&lt;td&gt;12288/12288 MiB (100.0%)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;51.02%&lt;/td&gt;
&lt;td&gt;1m 29.21s&lt;/td&gt;
&lt;td&gt;4547/7164 MiB&lt;/td&gt;
&lt;td&gt;9298/12288 MiB (75.67%)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;((masterpiece)),((best quality)),((high detial)),((realistic,))
Industrial age city, deep canyons in the middle,chinese architectural streets,bazaars, Bridges, (rainy days:1.2), (steampunk:0.8), chinese architecture
Negative prompt: nsfw,((cowboy)),(((pubic))), ((((pubic_hair))))sketch, duplicate, ugly, huge eyes, text, logo, monochrome, worst face, (bad and mutated hands:1.3), (worst quality:2.0), (low quality:2.0), (blurry:2.0), horror, geometry, bad_prompt, (bad hands), (missing fingers), multiple limbs, bad anatomy, (interlocked fingers:1.2), Ugly Fingers, (extra digit and hands and fingers and legs and arms:1.4), crown braid, ((2girl)), (deformed fingers:1.2), (long fingers:1.2),succubus wings,horn,succubus horn,succubus hairstyle, (bad-artist-anime), bad-artist, bad hand, borrowed character, text focus, watermark, sample watermark, character watermark, lofter username, photo date watermark, movie poster, magazine cover, journal, cover, cover page, doujin cover, album cover, manga cover, brand name imitation, EasyNegative,Tights, silk stockings,shorts
Steps: 35, Sampler: DPM adaptive, CFG scale: 5.5, Seed: 2223996555, Size: 1088x1088, Model hash: 543bcbc212, Model: base_Anything-V3.0-pruned, Clip skip: 2, ENSD: 31337
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;追記&#34;&gt;追記
&lt;/h2&gt;&lt;p&gt;一鍵デプロイパッケージではなく、なぜ推奨されないかというと、そのパッケージには作者が独自にカスタマイズした設定が含まれており、公式のオリジナルとは異なるからです。初心者の方は、なぜパラメータを設定する必要があるのか理解できないかもしれませんが、まずは公式のものを使用するのが最善です。使用時間が長くなるにつれて、公式のマニュアルを参考にすると、どのパラメータを調整すればよいか分かるようになります。&lt;/p&gt;
&lt;h2 id=&#34;グラフィックカードの選択&#34;&gt;グラフィックカードの選択
&lt;/h2&gt;&lt;p&gt;データ通貨マイニング後のこと、グラフィックカードの価格は相対的にそれほど高くないので、普通の初心者であれば、VRAMも十分でしょう。&lt;/p&gt;
&lt;p&gt;まだ一点、&lt;strong&gt;高清放大&lt;/strong&gt;オプションは、細部を具体化し、画面のディテールをより豊かにしますが、より多くのビデオメモリも必要となります。&lt;/p&gt;
&lt;p&gt;以下はNVIDIA GeForce GTX 970、GeForce RTX 3060 Ti、GeForce RTX 3060、GeForce RTX 3080およびGeForce RTX 3080 Tiの単精度（FP32）、半精度（FP16）および倍精度（FP64）浮動小数点演算性能のスペックまとめです。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;グラフィックカードモデル&lt;/th&gt;
&lt;th&gt;リリース年&lt;/th&gt;
&lt;th&gt;単精度浮動小数点演算性能 (TFLOPS)&lt;/th&gt;
&lt;th&gt;複精度浮動小数点演算性能 (TFLOPS)&lt;/th&gt;
&lt;th&gt;倍精度浮動小数点演算性能 (TFLOPS)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GeForce GTX 970&lt;/td&gt;
&lt;td&gt;2014&lt;/td&gt;
&lt;td&gt;3.49&lt;/td&gt;
&lt;td&gt;87.2&lt;/td&gt;
&lt;td&gt;0.109&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3060 Ti&lt;/td&gt;
&lt;td&gt;2020&lt;/td&gt;
&lt;td&gt;16.2&lt;/td&gt;
&lt;td&gt;32.4&lt;/td&gt;
&lt;td&gt;0.51&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3060&lt;/td&gt;
&lt;td&gt;2021&lt;/td&gt;
&lt;td&gt;12.7&lt;/td&gt;
&lt;td&gt;25.4&lt;/td&gt;
&lt;td&gt;0.39&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3080&lt;/td&gt;
&lt;td&gt;2020&lt;/td&gt;
&lt;td&gt;29.8&lt;/td&gt;
&lt;td&gt;58.9&lt;/td&gt;
&lt;td&gt;0.93&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3080 Ti&lt;/td&gt;
&lt;td&gt;2021&lt;/td&gt;
&lt;td&gt;34.8&lt;/td&gt;
&lt;td&gt;68.7&lt;/td&gt;
&lt;td&gt;1.36&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;引用元、&lt;a class=&#34;link&#34; href=&#34;https://docs.google.com/spreadsheets/d/1Zlv4UFiciSgmJZncCujuXKHwc4BcxbjbSBg71-SdeNk/edit#gid=0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;各种显卡性能测试数据&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;アップデート&#34;&gt;アップデート
&lt;/h2&gt;&lt;p&gt;半年の間隔を経て、改めてインストール手順を整理したり、より多くの基礎概念を紹介しようと思いましたが、結局、一般の人々がAIで絵を描くというのは、結局のところ、大佬が提供する画像パラメータに基づいて調整したり、既存の画像を元にフォーマットされたリレンダリングを行うだけだと分かりました。&lt;/p&gt;
&lt;p&gt;途中でAIを使ってミニプログラムのUI素材を描くという試みがあったが、色々手間取った結果、効果は期待ほどではなく、むしろ公式のミニプログラムからリソース画像を直接引き込んだ方が良いだろう。&lt;/p&gt;</description>
        </item>
        <item>
        <title>プログラム最適化は、ハードウェアに逆らうようなことはしないこと。</title>
        <link>https://ttf248.life/ja/p/program-optimization-dont-fight-hardware/</link>
        <pubDate>Fri, 07 Apr 2023 16:30:15 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/program-optimization-dont-fight-hardware/</guid>
        <description>&lt;p&gt;&lt;code&gt;one loop thread&lt;/code&gt;BOLD_1__マイクロ秒**レベルで、サーバー交換により、最大で6万パケットの溜まりから、ほとんど溜まらなくなった。&lt;/p&gt;
&lt;p&gt;シングルスレッドでデータを処理する場合、CPUの性能はクロック周波数、キャッシュサイズ、命令セットアーキテクチャなどの要素に左右されます。一般的に、クロック周波数が高く、キャッシュが大きく、より高度な命令セットアーキテクチャを持つCPUほど、シングルスレッドでのデータ処理性能が高いと言えます。&lt;/p&gt;
&lt;h2 id=&#34;シングルスレッド&#34;&gt;シングルスレッド
&lt;/h2&gt;&lt;p&gt;パフォーマンス向上は、スレッド増強が必須ではない。プロジェクトのフローを見直し、ボトルネックとなっている箇所を特定し、シングルスレッドで要件を満たせるか検討する。シングルスレッドでは考慮すべき点が少なく、問題も起こりにくい。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;いきなりスレッド追加を持ち出してくるなんて、少し変だな。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;事件&#34;&gt;事件
&lt;/h2&gt;&lt;p&gt;扱っているのは&lt;strong&gt;行情数据，延迟敏感&lt;/strong&gt;です。&lt;/p&gt;
&lt;p&gt;ぐったりしながら徹夜で頑張って、新しい最適化バージョンをリリース。ローカルAPIの分離テストもして、速度もまあまあ。TPS: 4.2万&lt;/p&gt;
&lt;p&gt;サーバーにデプロイするとTPSが急落：2.1万。自宅のデスクトップで試すとTPS：7.9万。内部サービス仮想化に問題があるのではないかと疑い始めた。まずCPUクロック周波数を疑う。自宅のデスクトップとサーバーの間で最も大きな違いは、CPUクロック周波数だ。&lt;/p&gt;
&lt;p&gt;テストサーバーA&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;processor	: 7
vendor_id	: GenuineIntel
cpu family	: 6
model		: 47
model name	: Intel(R) Xeon(R) CPU E7- 4807  @ 1.87GHz
stepping	: 2
microcode	: 0x34
cpu MHz		: 1866.733
cache size	: 18432 KB
physical id	: 1
siblings	: 4
core id		: 3
cpu cores	: 4
apicid		: 7
initial apicid	: 7
fpu		: yes
fpu_exception	: yes
cpuid level	: 11
wp		: yes
flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss ht syscall nx rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc cpuid aperfmperf pni pclmulqdq ssse3 cx16 sse4_1 sse4_2 popcnt aes hypervisor lahf_lm pti dtherm arat
bugs		: clflush_monitor cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit
bogomips	: 3733.46
clflush size	: 64
cache_alignment	: 64
address sizes	: 40 bits physical, 48 bits virtual
power management:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;テストサーバーB&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;processor	: 7
vendor_id	: GenuineIntel
cpu family	: 6
model		: 63
model name	: Intel(R) Xeon(R) CPU E5-2640 v3 @ 2.60GHz
stepping	: 2
microcode	: 0x3c
cpu MHz		: 2599.998
cache size	: 20480 KB
physical id	: 14
siblings	: 1
core id		: 0
cpu cores	: 1
apicid		: 14
initial apicid	: 14
fpu		: yes
fpu_exception	: yes
cpuid level	: 15
wp		: yes
flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc cpuid aperfmperf pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand hypervisor lahf_lm cpuid_fault epb pti fsgsbase smep xsaveopt cqm_llc cqm_occup_llc dtherm ida arat pln pts
bugs		: cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit
bogomips	: 5199.99
clflush size	: 64
cache_alignment	: 64
address sizes	: 40 bits physical, 48 bits virtual
power management:
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;openai-へお問い合わせ&#34;&gt;OpenAI へお問い合わせ
&lt;/h2&gt;&lt;p&gt;まず、コア数とクロック周波数についてですが、Intel(R) Xeon(R) CPU E7-4807 @ 1.87GHzは6つの物理コアと12個の論理コアを持ち、クロック周波数は1.87GHzです。一方、Intel(R) Xeon(R) CPU E5-2640 v3 @ 2.60GHzは8つの物理コアと16個の論理コアを持ち、クロック周波数は2.60GHzです。したがって、コア数とクロック周波数から見ると、E5-2640 v3はシングルスレッドでのデータ処理において、E7-4807よりも優位性を持つと考えられます。&lt;/p&gt;
&lt;p&gt;次に、キャッシュサイズに関して、E7-4807は12MB、E5-2640 v3は20MBです。したがって、E5-2640 v3の方がキャッシュ容量が大きく、データのアクセス速度とキャッシュヒット率を向上させることができます。&lt;/p&gt;
&lt;p&gt;最後にアーキテクチャについてですが、E5-2640 v3はより先進的なHaswellアーキテクチャを採用しており、一方、E7-4807は旧世代のNehalemアーキテクチャです。HaswellアーキテクチャはNehalemアーキテクチャと比較して性能が向上しており、これによりE5-2640 v3のシングルスレッドでのデータ処理性能に影響が出ている可能性があります。&lt;/p&gt;
&lt;p&gt;したがって、総合的に考えると、シングルスレッドでデータを処理するシナリオでは、E5-2640 v3の方がE7-4807よりも優れた性能を発揮するはずです。ただし、具体的な性能差は、データ処理のアルゴリズム、メモリ帯域幅、システム負荷など、様々な要因の影響を受けます。個別の問題に対して個別に分析する必要があります。&lt;/p&gt;
&lt;h2 id=&#34;ハードウェア資料&#34;&gt;ハードウェア資料
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cpubenchmark.net/compare/3786.2vs2365.2/%5BDual-CPU%5D-Intel-Xeon-E7%e2%80%934807-vs-%5BDual-CPU%5D-Intel-Xeon-E5-2640-v3&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cpubenchmark.net/compare/3786.2vs2365.2/%5BDual-CPU%5D-Intel-Xeon-E7–4807-vs-%5BDual-CPU%5D-Intel-Xeon-E5-2640-v3&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Specification&lt;/th&gt;
&lt;th&gt;Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Price&lt;/td&gt;
&lt;td&gt;Search Online  $78 - BUY&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Socket Type&lt;/td&gt;
&lt;td&gt;LGA1567&lt;/td&gt;
&lt;td&gt;LGA2011-v3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU Class&lt;/td&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Clockspeed&lt;/td&gt;
&lt;td&gt;1.9 GHz&lt;/td&gt;
&lt;td&gt;2.6 GHz&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Turbo Speed&lt;/td&gt;
&lt;td&gt;Not Supported&lt;/td&gt;
&lt;td&gt;Up to 3.4 GHz&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;# of Physical Cores&lt;/td&gt;
&lt;td&gt;6 (Threads: 12)&lt;/td&gt;
&lt;td&gt;8 (Threads: 16)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Cache&lt;/td&gt;
&lt;td&gt;NA2&lt;/td&gt;
&lt;td&gt;NA2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Max TDP&lt;/td&gt;
&lt;td&gt;95W x 2&lt;/td&gt;
&lt;td&gt;90W x 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Yearly Running Cost&lt;/td&gt;
&lt;td&gt;$34.68&lt;/td&gt;
&lt;td&gt;$32.85&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Other&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;First Seen on Chart&lt;/td&gt;
&lt;td&gt;Q3 2020&lt;/td&gt;
&lt;td&gt;Q3 2014&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;# of Samples&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;46&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU Value&lt;/td&gt;
&lt;td&gt;69.1&lt;/td&gt;
&lt;td&gt;225.6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Single Thread Rating&lt;/td&gt;
&lt;td&gt;721 (-59.2%)&lt;/td&gt;
&lt;td&gt;1767 (0.0%)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU Mark&lt;/td&gt;
&lt;td&gt;6223 (-64.6%)&lt;/td&gt;
&lt;td&gt;17600 (0.0%)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description>
        </item>
        <item>
        <title>プロンプトエンジニア</title>
        <link>https://ttf248.life/ja/p/prompt-engineer/</link>
        <pubDate>Sun, 26 Mar 2023 20:46:53 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/prompt-engineer/</guid>
        <description>&lt;p&gt;まるで昔に検索エンジンのテクニックを学ぶように、私たちも&lt;code&gt;AI&lt;/code&gt;とのコミュニケーションのコツを学び、合理的かつ十分な条件を設定し、必要な答えを効率的に得る必要がある。&lt;/p&gt;
&lt;p&gt;もし別の視点から考えてみたら、現在の強調表示は期待通りの結果を生むでしょう。&lt;/p&gt;
&lt;h2 id=&#34;科学解説&#34;&gt;科学解説
&lt;/h2&gt;&lt;p&gt;火出天际的&lt;code&gt;AI&lt;/code&gt;BOLD_2&lt;code&gt;Generative Pre-Training&lt;/code&gt;とは、直訳すると生成事前学習です。これは、インターネットで利用可能なデータで訓練されたテキスト生成深層学習モデルであり、質問応答、テキスト要約の生成、機械翻訳、分類、コード生成、対話AIなどのタスクに使用されます。現在ではGPT-1、GPT-2、GPT-3、GPT-4など、さまざまなバージョンのモデルが存在し、各バージョンは前のバージョンよりも大きく、強力です。&lt;/p&gt;
&lt;h2 id=&#34;結局知能は存在するのか&#34;&gt;結局、知能は存在するのか。
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;類似度が十分高いほど、精度も上がる。&lt;/li&gt;
&lt;li&gt;基本的な、反復作業は、特定の訓練を経れば、これ以上の人的介入は不要となる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;生成AIとは、既存のテキスト、音声、画像などのデータを利用して新しいコンテンツを生成する技術です。テキスト生成、音声合成、画像生成、対話システムなど、様々なタスクに利用できます。生成AIの論理性は、学習データとモデル構造に依存します。一般的に、生成AIは文法、論理、常識をある程度遵守できますが、誤りや偏見、虚偽の内容を生み出す可能性もあります。そのため、生成AIの出力には人間の判断と検証が必要であり、盲目的に信じたり使用したりすることはできません。&lt;/p&gt;
&lt;h2 id=&#34;プロンプトエンジニア&#34;&gt;プロンプトエンジニア
&lt;/h2&gt;&lt;p&gt;時間が流れ去ることはないから、人は時代の流れに適応する必要がある。あなたはそれを__INLINE_CODE_0__を非論理的だと考えられるかもしれないし、役に立たないコードを生成することがよくある。&lt;/p&gt;
&lt;p&gt;もし別の視点から考えてみたら、現在の強調表示は期待通りの結果を生むでしょう。&lt;/p&gt;
&lt;h2 id=&#34;会話モード&#34;&gt;会話モード
&lt;/h2&gt;&lt;p&gt;2年前に、大胆に登場し、人類は大規模言語モデルの能力を認識した。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于注释的编程&lt;/strong&gt;と&lt;strong&gt;基于对话的编程&lt;/strong&gt;に基づき、インタラクションの論理は完全に異なり、会話のパターンも、初心者ユーザーにとって使いやすい体験を提供します。ここに必ず&lt;code&gt;NewBing&lt;/code&gt;在每个问题之后，给出的追问提示，微软在尝试引导用户，获取&lt;code&gt;AI&lt;/code&gt;知識ベース内の、より多くのコンテンツについて言及する必要があります。&lt;/p&gt;
&lt;h2 id=&#34;例えば&#34;&gt;例えば
&lt;/h2&gt;&lt;p&gt;高速鉄道の移動時間は長く、コーディングは良い選択だ。データ通信量が限られているので、画像を数枚処理し、画像素材を入手したが、ソフトウェアをダウンロードして画像を処理するのは少し贅沢すぎるし、ネットワーク環境もそれを許さない。&lt;/p&gt;
&lt;p&gt;画像素材がいくつかあり、それらは透明な背景の画像で、ミニプログラムのナビゲーションバーに使用されます。選択された状態はカラー、未選択の状態は白黒です。素材自体はカラーなので、前処理が必要です。&lt;/p&gt;
&lt;p&gt;フォルダ内のすべての画像を読み込み、モノクロに変換し、透明な背景を維持した上で、品質を最適化してファイルサイズを縮小した画像を保存するPythonコードを作成してください。また、コンソールには変換前のファイルサイズと変換後のファイルサイズの比較を表示してください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 导入必要的库
import os
import PIL
from PIL import Image

# 定义一个函数，将图片转换成黑白，维持透明背景，保存图片，并返回文件体积
def convert_and_save(image_file):
    # 打开图片
    image = Image.open(image_file)
    # 获取图片的模式，如果是 RGBA 模式，说明有透明背景
    mode = image.mode
    if mode == &amp;quot;RGBA&amp;quot;:
        # 创建一个和图片大小一致的白色背景图片
        background = Image.new(&amp;quot;RGB&amp;quot;, image.size, (255, 255, 255))
        # 将原图片粘贴到白色背景上，忽略透明像素
        background.paste(image, mask=image.split()[3])
        # 将合成的图片转换成灰度模式
        gray_image = background.convert(&amp;quot;L&amp;quot;)
        # 将灰度图片再转换成 RGBA 模式，以便保留透明背景
        final_image = gray_image.convert(&amp;quot;RGBA&amp;quot;)
    else:
        # 如果不是 RGBA 模式，直接将图片转换成灰度模式
        final_image = image.convert(&amp;quot;L&amp;quot;)
    # 获取原图片的文件名和扩展名
    file_name, file_ext = os.path.splitext(image_file)
    # 定义新图片的文件名，添加 _bw 后缀表示黑白
    new_file_name = file_name + &amp;quot;_bw&amp;quot; + file_ext
    # 保存新图片，并优化质量，减少文件体积
    final_image.save(new_file_name, optimize=True)
    # 获取原图片和新图片的文件体积，并返回
    old_size = os.path.getsize(image_file)
    new_size = os.path.getsize(new_file_name)
    return old_size, new_size

# 定义一个文件夹路径，存放所有的图片
folder_path = &amp;quot;images&amp;quot;
# 遍历文件夹中的所有文件
for file in os.listdir(folder_path):
    # 拼接完整的文件路径
    file_path = os.path.join(folder_path, file)
    # 判断是否是图片文件，根据扩展名判断，可以根据需要添加或修改扩展名
    if file_path.endswith((&amp;quot;.png&amp;quot;, &amp;quot;.jpg&amp;quot;, &amp;quot;.jpeg&amp;quot;, &amp;quot;.gif&amp;quot;)):
        # 调用函数，转换并保存图片，并获取文件体积
        old_size, new_size = convert_and_save(file_path)
        # 在控制台展示优化前后的文件体积大小对比
        print(f&amp;quot;{file}: {old_size} bytes -&amp;gt; {new_size} bytes&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;すぐに回答しましたが、見た目は良く、問題なく動作します。経験豊富なプログラマーなら、下記のコードが汎用的ではなく、本番環境には向かないと感じるでしょう。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;パラメータが固定されました。&lt;/li&gt;
&lt;li&gt;ログファイルはなく、情報はコンソールに出力されています。&lt;/li&gt;
&lt;li&gt;画像処理のタスクは、マルチスレッドモデルに適しています。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このコードの改善点はありますか？&lt;/p&gt;
&lt;p&gt;今回提示された回答は、正直言って期待を遥かに上回っています。一般的なプログラマーが思いつくような最適化策についても、それぞれ対応する提案が示されています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;这段代码可能还有一些可以改进的地方，比如：

可以使用 argparse 库，让用户可以通过命令行参数指定文件夹路径和扩展名，而不是写死在代码里。
可以使用 logging 库，记录程序的运行情况，而不是直接打印到控制台。
可以使用 try-except 语句，捕获可能出现的异常，比如文件打开失败，图片转换失败等，并做相应的处理。
可以使用 multiprocessing 库，利用多核处理器，加速图片的转换和保存过程。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非常にフレンドリーな対応で、デプロイ環境の違いを考慮し、マルチプロセス非対応を許可しています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;当然，我很乐意帮你修改一下代码。我尝试添加了 argparse, logging 和 try-except 语句，但没有添加 multiprocessing 库，因为我不确定你的电脑是否支持多核处理。修改后的代码如下：
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 导入必要的库
import argparse
import logging
import multiprocessing
import os

from PIL import Image


# 定义一个函数，将图片转换成黑白，维持透明背景，保存图片，并返回文件体积
def convert_and_save(image_file):
    # 打开图片
    try:
        image = Image.open(image_file)
    except Exception as e:
        logging.error(f&amp;quot;Failed to open {image_file}: {e}&amp;quot;)
        return None, None
    # 获取图片的模式，如果是 RGBA 模式，说明有透明背景
    mode = image.mode
    if mode == &amp;quot;RGBA&amp;quot;:
        # 创建一个和图片大小一致的白色背景图片
        background = Image.new(&amp;quot;RGB&amp;quot;, image.size, (255, 255, 255))
        # 将原图片粘贴到白色背景上，忽略透明像素
        background.paste(image, mask=image.split()[3])
        # 将合成的图片转换成灰度模式
        gray_image = background.convert(&amp;quot;L&amp;quot;)
        # 将灰度图片再转换成 RGBA 模式，以便保留透明背景
        final_image = gray_image.convert(&amp;quot;RGBA&amp;quot;)
    else:
        # 如果不是 RGBA 模式，直接将图片转换成灰度模式
        final_image = image.convert(&amp;quot;L&amp;quot;)
    # 获取原图片的文件名和扩展名
    file_name, file_ext = os.path.splitext(image_file)
    # 定义新图片的文件名，添加 _bw 后缀表示黑白
    new_file_name = file_name + &amp;quot;_bw&amp;quot; + file_ext
    # 保存新图片，并优化质量，减少文件体积
    try:
        final_image.save(new_file_name, optimize=True)
    except Exception as e:
        logging.error(f&amp;quot;Failed to save {new_file_name}: {e}&amp;quot;)
        return None, None
    # 获取原图片和新图片的文件体积，并返回
    old_size = os.path.getsize(image_file)
    new_size = os.path.getsize(new_file_name)
    return file_name, old_size, new_size

# 定义一个函数，解析命令行参数，并返回文件夹路径和扩展名列表
def parse_args():
    # 创建一个解析器对象
    parser = argparse.ArgumentParser(description=&amp;quot;Convert images to black and white and optimize quality.&amp;quot;)
    # 添加一个必选的位置参数，表示文件夹路径
    parser.add_argument(&amp;quot;folder_path&amp;quot;, help=&amp;quot;The path of the folder that contains the images.&amp;quot;)
    # 添加一个可选的参数，表示扩展名列表，默认为 png, jpg, jpeg 和 gif
    parser.add_argument(&amp;quot;-e&amp;quot;, &amp;quot;--extensions&amp;quot;, nargs=&amp;quot;+&amp;quot;, default=[&amp;quot;.png&amp;quot;, &amp;quot;.jpg&amp;quot;, &amp;quot;.jpeg&amp;quot;, &amp;quot;.gif&amp;quot;], help=&amp;quot;The extensions of the image files.&amp;quot;)
    # 解析命令行参数，并返回结果对象
    args = parser.parse_args()
    return args.folder_path, args.extensions

# 定义一个函数，打印优化前后的文件体积大小对比
def print_result(result):
    # 如果结果不为空，说明转换和保存成功
    if result:
        # 解包结果为文件名和文件体积元组
        if len(result) == 3:
            file, old_size, new_size = result
            # 在控制台展示优化前后的文件体积大小对比
            logging.info(f&amp;quot;{file}: {old_size} bytes -&amp;gt; {new_size} bytes&amp;quot;)
        else:
            logging.info(f&amp;quot;{result}&amp;quot;)

# 配置日志记录器，将日志输出到控制台和文件中，设置日志等级为 INFO
logging.basicConfig(level=logging.INFO,
                    format=&amp;quot;%(asctime)s %(levelname)s %(message)s&amp;quot;,
                    handlers=[logging.StreamHandler(),
                              logging.FileHandler(&amp;quot;log.txt&amp;quot;)])

# 调用函数，获取文件夹路径和扩展名列表
folder_path, extensions = parse_args()

if __name__ == &amp;quot;__main__&amp;quot;:
    # Windows 需要这个函数的原因是 Windows 缺乏 fork() 函数（这不完全正确）。
    # 因此，在 Windows 上，fork() 是通过创建一个新的进程来模拟的，这个新的进程中运行的代码，在 Linux 上是在子进程中运行的。
    # 由于这些代码要在技术上无关的进程中运行，所以它必须在运行之前被传递到那里。
    # 传递的方式是先将它们序列化，然后通过管道从原始进程发送到新的进程。
    # 另外，这个新的进程被通知它必须运行通过管道传递的代码，通过向它传递 --multiprocessing-fork 命令行参数。
    # 如果你看一下 freeze_support() 函数的实现，它的任务是检查它运行在哪个进程中，是否应该运行通过管道传递的代码
    multiprocessing.freeze_support()

    # 创建一个进程池，根据电脑的核心数自动分配进程
    pool = multiprocessing.Pool()
    # 创建一个空列表，用于存放异步任务的结果对象
    results = []
    # 遍历文件夹中的所有文件
    for file in os.listdir(folder_path):
        # 拼接完整的文件路径
        file_path = os.path.join(folder_path, file)
        # 判断是否是图片文件，根据扩展名判断，可以根据需要修改扩展名列表
        if any(file_path.endswith(ext) for ext in extensions):
            # 调用函数，转换并保存图片，并获取文件体积，使用异步方式，不阻塞主进程
            result = pool.apply_async(convert_and_save, args=(file_path,), callback=print_result)
            # 将结果对象添加到列表中
            results.append((file, result))
    # 关闭进程池，不再接受新的任务
    pool.close()
    # 等待所有的任务完成
    pool.join()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;追記&#34;&gt;追記
&lt;/h2&gt;&lt;p&gt;ローカル開発で__BOLD_4&lt;code&gt;windows&lt;/code&gt;第一次给出的答案，并没有加上&lt;code&gt;AI&lt;/code&gt;BOLD_6&lt;code&gt;main&lt;/code&gt;第一次给出的答案，并没有加上&lt;code&gt;multiprocessing.freeze_support&lt;/code&gt;が発生し、エラー追跡によりコードを修正しました。&lt;/p&gt;
&lt;p&gt;まるで昔に検索エンジンのテクニックを学ぶように、私たちも__INLINE_CODE_0__とのコミュニケーションのコツを学び、合理的かつ十分な条件を設定し、必要な答えを効率的に得る必要がある。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;</description>
        </item>
        <item>
        <title>微信小程序背景と開発環境</title>
        <link>https://ttf248.life/ja/p/wechat-mini-program-background-and-development-environment/</link>
        <pubDate>Fri, 24 Mar 2023 21:59:11 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/wechat-mini-program-background-and-development-environment/</guid>
        <description>&lt;p&gt;微信ミニプログラムの紹介と開発準備&lt;/p&gt;
&lt;h2 id=&#34;なぜ小程序があるのか&#34;&gt;なぜ小程序があるのか。
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;より良い体験：埋め込みウェブページの読み込みが遅い、白画面。ネイティブアプリの体験は、より高速な読み込みを実現します。&lt;/li&gt;
&lt;li&gt;規範と管理：微信にとって、接続と管理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;小程序的发布之前，微信曾发布过一个__INLINE_CODE_0__BOLD_2&lt;code&gt;JSSDK&lt;/code&gt;，开放了微信原生能力：微信支付、卡券。但开发者基于网页开发语言的逻辑进行开发时，能够绕过微信的部分监管。小程序则有一套自己的描述语言。&lt;/p&gt;
&lt;h2 id=&#34;ミニプログラムとは何か&#34;&gt;ミニプログラムとは何か。
&lt;/h2&gt;&lt;p&gt;ミニプログラムは、ダウンロードやインストールが不要で利用できるアプリケーションであり、アプリケーションの&lt;strong&gt;触手可及&lt;/strong&gt;という夢を実現しています。&lt;/p&gt;
&lt;p&gt;QRコードスキャンまたは検索でアプリを開けること自体が、&lt;strong&gt;用完即走&lt;/strong&gt;のコンセプトを体現している。&lt;/p&gt;
&lt;p&gt;ユーザーは、インストールしすぎたかどうかを気にする必要はありません。アプリはどこにでもあり、いつでも利用可能ですが、同時に&lt;strong&gt;无需安装卸载&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;小プログラムとモバイルアプリの違い&#34;&gt;小プログラムとモバイルアプリの違い
&lt;/h2&gt;&lt;p&gt;インストール不要、メモリ消費なし、共有しやすい：QRコード、ミニプログラムカード、検索&lt;/p&gt;
&lt;h2 id=&#34;微信ミニプログラムで何ができるか&#34;&gt;微信ミニプログラムで何ができるか
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;コンテンツツール：知乎人気ランキング、微博トレンド、モバイクシェア、今日ヘッドライン、テンセントマップ、テンセント翻訳&lt;/li&gt;
&lt;li&gt;小売：拼多多、京東購物、蘑菇街、每日優鮮、小米商城、屈臣氏&lt;/li&gt;
&lt;li&gt;ゲーム：跳び遊び、楽しい牌勝負、楽しいマージャン、ドリームライブ、YYライブ&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;コースの内容は2018年のもので、今や一部のアプリケーションベンダーは既に倒産しています。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;開発準備&#34;&gt;開発準備
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;ミニプログラムのアカウント登録：通常通り情報を入力すれば登録可能です。メールの認証リンクをクリックして有効にしてください。&lt;/li&gt;
&lt;li&gt;情報登録&lt;/li&gt;
&lt;li&gt;ログインミニプログラム管理后台&lt;/li&gt;
&lt;li&gt;小程序情報を完善する&lt;/li&gt;
&lt;li&gt;開発者バインド：個人開発者は、ログインするWeChatアカウントが管理者アカウントであるため、追加のバインド作業は不要です。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;メールアドレスには制限があり、新しいメールアドレスが必要ですが、__INLINE_CODE_0__メールならエイリアスが申請でき、WeChatのバックエンドでは検証されません。試してみた結果、ミニプログラムの名前はやや面倒でしたが、商標に関わるものは審査に落ちやすいです。&lt;/p&gt;
&lt;p&gt;サービスカテゴリは選択可能で、カスタム追加もできます。1つのミニプログラムでは5つのカテゴリを追加可能です。&lt;/p&gt;
&lt;p&gt;設定内で、ミニプログラムの情報を確認できたり、メッセージプッシュを有効にしたりできます。メッセージプッシュを有効にすると、メッセージテンプレート機能が利用可能です。&lt;/p&gt;
&lt;h2 id=&#34;開発者ツール筆者による&#34;&gt;開発者ツール（筆者による）
&lt;/h2&gt;&lt;p&gt;通常通りインストールすれば問題ありません。特に注意点もなく、簡単に游客モードで入ることができます。もし携帯電話のデバッグを有効にしたい場合は（つまり、携帯電話からミニプログラムの開発バージョンを確認したい場合）、ミニプログラムの開発者アカウントにログインし、設定を開いて、プロジェクトの詳細画面で指定されたミニプログラム__INLINE_CODE_0__に切り替えてください。&lt;/p&gt;
&lt;h2 id=&#34;コード構造&#34;&gt;コード構造
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;インタラクションロジック&lt;/li&gt;
&lt;li&gt;データ設定&lt;/li&gt;
&lt;li&gt;インターフェースの要素&lt;/li&gt;
&lt;li&gt;インターフェースのスタイル&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>オフィス移転のため、サーバーにアクセスできません。</title>
        <link>https://ttf248.life/ja/p/office-migration-server-unavailable/</link>
        <pubDate>Sat, 11 Mar 2023 01:42:05 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/office-migration-server-unavailable/</guid>
        <description>&lt;p&gt;事務所の異動について。場所は、元の2階から15階へ変更です。普通の席替えです。&lt;/p&gt;
&lt;h2 id=&#34;デザイン性&#34;&gt;デザイン性
&lt;/h2&gt;&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;20230311014537.png&#34; &gt;办公楼&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;移動&#34;&gt;移動
&lt;/h2&gt;&lt;p&gt;退社して荷物をまとめて、慣れた手つきで新しい席へ。パソコンの配線を整え、楽な姿勢で作業開始。&lt;/p&gt;
&lt;p&gt;（òωóױ）！ネットケーブルを接続しても、チームでよく使うサーバーにアクセスできません。無線ネットワークに切り替えると、またアクセスできるようになりました。&lt;/p&gt;
&lt;p&gt;当初はサーバーのネットワークセグメント設定の問題かと思いましたが、新しい作業場所の有線ネットワークがファイアウォールの設定リストにないだけなので、IT担当者に調整してもらうと解決するだろうと思っていました。しかし、このネットワークセグメントには一台のサーバーだけでなく、他のサーバーにもアクセスしてみると正常でした。次第に疑問が生じました。専門的なことは専門の人に任せることにし、最終的に運用部門の担当者が特定したところ、このサーバーが&lt;code&gt;docker&lt;/code&gt;，服务的默认网络&lt;code&gt;docker0&lt;/code&gt;和办公室有线网络配置的网段冲突了，导致发过去的数据包，都收不到应答，被路由给了&lt;code&gt;docker&lt;/code&gt;サービスをデプロイしていたことが原因でした。&lt;/p&gt;
&lt;p&gt;他のサーバーに展開された__INLINE_CODE_0__服务，也就这台，我比较常用，偶尔用容器部署一些测试服务，没想到还能碰到这个场景。后来细想想，由于整个集团都在一个办公大楼里面，IT部门的同事划分网段，用到了__INLINE_CODE_1__で始まるアドレスは珍しくありません。&lt;/p&gt;
&lt;h2 id=&#34;docker0&#34;&gt;docker0
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# vim /etc/docker/daemon.json
{
    &amp;quot;bip&amp;quot;:&amp;quot;172.200.0.1/24&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;サービスを再起動し、新しいネットワークに切り替えると、サーバーは通常アクセスに戻ります。&lt;/p&gt;
&lt;h2 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h2&gt;&lt;p&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/p&gt;</description>
        </item>
        <item>
        <title>組み込み入門 1 - 専門用語</title>
        <link>https://ttf248.life/ja/p/embedded-introduction-professional-terms/</link>
        <pubDate>Tue, 07 Mar 2023 13:42:36 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/embedded-introduction-professional-terms/</guid>
        <description>&lt;p&gt;組み込みシステムといえば、昔から学校の実験室にあった51マイクロコントローラーとフリースケールが思い浮かぶ。&lt;/p&gt;
&lt;p&gt;LPA3399Proは、ルネテックRK3399Proプラットフォームをベースとしたビジョンホストで、大量の画像処理が必要なポータブルコンピューティングデバイス向けです。NPU計算ユニットを内蔵し、3.0TOPSの演算能力を持ち、様々なアルゴリズムモデルに対応しています。&lt;/p&gt;
&lt;p&gt;RV1109は、ルシンマイクロ（Richwave）のAI・マシンビジョン向けSoCで、内蔵NPUを搭載しています。1TOPSの演算能力を提供します。&lt;/p&gt;
&lt;h2 id=&#34;system-on-chip&#34;&gt;System on Chip
&lt;/h2&gt;&lt;p&gt;SoCは、System on a Chipの略で、「チップ上システム」を意味します。これは、複数の電子システムを1つのチップに統合する技術です。この技術により、電子製品のサイズと重量を大幅に削減しつつ、性能を向上させ、消費電力を抑えることができます。&lt;/p&gt;
&lt;p&gt;SoC（システムオンチップ）とCPU（中央処理装置）は、どちらもコンピューターシステムの重要な構成要素ですが、いくつかの違いがあります。&lt;/p&gt;
&lt;p&gt;CPUはコンピューターシステムの主要なプロセッサであり、プログラム命令の実行を担います。演算ユニット、制御ユニット、レジスタなどの基本的な部品で構成されています。&lt;/p&gt;
&lt;p&gt;SoCは、CPUに加えてメモリ、グラフィックプロセッサ、入出力インターフェースなどの複数の電子システムを1つのチップに統合したものです。これにより、電子製品のサイズと重量を大幅に削減しつつ、性能向上と低消費電力化を実現します。&lt;/p&gt;
&lt;p&gt;要するに、CPUはSoCの一部であり、SoCはより複雑で集積度の高い電子システムです。&lt;/p&gt;
&lt;h2 id=&#34;microcontroller-unit&#34;&gt;Microcontroller Unit
&lt;/h2&gt;&lt;p&gt;SoC（システムオンチップ）とMCU（マイクロコントローラーユニット）は、複数の電子システムを1つのチップに統合する技術ですが、両者にはいくつかの違いがあります。&lt;/p&gt;
&lt;p&gt;MCUは、CPU、メモリ、入出力インターフェースなどの基本的な部品を含むマイクロコントローラーの一種です。家電製品や自動車の電子システムなど、他の電子機器の制御によく使用されます。&lt;/p&gt;
&lt;p&gt;SoCは、MCUの基本的な構成要素に加えて、グラフィックプロセッサや無線通信モジュールなどの他のコンポーネントをチップ上に集積する技術です。これにより、電子製品のサイズと重量を大幅に削減しつつ、性能向上と低消費電力化を実現します。&lt;/p&gt;
&lt;p&gt;要するに、MCUはシンプルなマイクロコントローラーであり、SoCはより複雑で統合度の高い電子システムです。&lt;/p&gt;</description>
        </item>
        <item>
        <title>AI支援によるプログラミング、生産性の進化</title>
        <link>https://ttf248.life/ja/p/ai-assisted-programming-productivity-evolution/</link>
        <pubDate>Tue, 28 Feb 2023 17:05:17 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/ai-assisted-programming-productivity-evolution/</guid>
        <description>&lt;p&gt;&lt;strong&gt;斜体_3&lt;/strong&gt;**太字_2__斜体_4__が登場しました。仕組みはよく分かりませんが、しばらく使っています。両方のツールは生産性を大幅に向上させますが、サポートの面では全く異なります。&lt;/p&gt;
&lt;p&gt;複雑なことについては、効果はせいぜい9割程度だ。&lt;/p&gt;
&lt;h2 id=&#34;github-copilot&#34;&gt;github copilot
&lt;/h2&gt;&lt;p&gt;公開時に公式サイトの説明を拝見しましたが、あまり賢そうではありませんでした。試してみたものの、使い勝手が悪く、諦めました。&lt;/p&gt;
&lt;p&gt;2022年前、暇な時に新バージョンを試してみたら、すでに効果はなかなか良い。ただ、国内の速度が少し遅いのは、大概ネットワークの問題だろう。__INLINE_CODE_0__のような言語で、コメントを参照して書かれたコードはなかなか良く、自分で資料を探して書くよりもずっと速い。&lt;/p&gt;
&lt;h2 id=&#34;chatgpt&#34;&gt;ChatGPT
&lt;/h2&gt;&lt;p&gt;まだプログラマー、つまり開発の視点から製品を設計している段階です。プログラミングの方法を理解し、コメントを通じてAIによる補助的なプログラミングを徐々に誘導する必要があります。&lt;/p&gt;
&lt;p&gt;専門家でなくてもすぐに使い始められる**。対話形式のチャットインターフェースなので、質問や要望を自由に伝えられます。分からないことがあれば、遠慮なく質問してください。&lt;/p&gt;
&lt;p&gt;単純な例で言うと、トークン化の概念は理解しているが、どのようにコーディングするか分からない。文字列の類似度を計算したい。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Python 分词计算 維天運通 LOGORY 和 合肥維天運通信息科技股份有限公司 两个字符串的相似度；
比较前，统一处理字符串，英文转换为小写；
第二个字符中如果能找到第一个字符的首字符，将第二个字符串截位，截位的长度为第一个字符串的长度
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;こんにちは、これはBingです。😊&lt;/p&gt;
&lt;p&gt;オンラインの情報によると123、Pythonの形態素解析には、jiebaライブラリを使用できます。jiebaライブラリは、厳密モード、全文モード、そして検索エンジンモードという3つの分かち込みモードをサポートしています。ニーズに合わせて適切なモードを選択してください。&lt;/p&gt;
&lt;p&gt;文字列の類似度を比較するためには、まず単語分割を行い、次に単語ベクトルや編集距離などの指標を計算する必要があります。numpy や scipy などのライブラリを使用して数学演算を行うことができます。&lt;/p&gt;
&lt;p&gt;文字列を統一的に処理するために、英字を小文字に変換するには、Pythonの組み込み関数lower()を使用できます。&lt;/p&gt;
&lt;p&gt;2番目の文字列を抽出するには、Pythonのスライス演算子[]を使用できます。&lt;/p&gt;
&lt;p&gt;以下はサンプルコードです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import jieba
import numpy as np
from scipy.spatial.distance import cosine

# 定义两个字符串
str1 = &amp;quot;維天運通 LOGORY&amp;quot;
str2 = &amp;quot;合肥維天運通信息科技股份有限公司&amp;quot;

# 统一处理字符串，英文转换为小写
str1 = str1.lower()
str2 = str2.lower()

# 找到第二个字符串中第一个字符的位置
index = str2.find(str1[0])

# 如果找到了，截取第二个字符串
if index != -1:
    str2 = str2[index:index+len(str1)]

# 使用 jieba 库进行分词
words1 = list(jieba.cut(str1))
words2 = list(jieba.cut(str2))

# 计算两个字符串的词向量（以词频作为权重）
vector1 = np.zeros(len(words1))
vector2 = np.zeros(len(words1))

for i, word in enumerate(words1):
    vector1[i] += 1 # 统计第一个字符串中每个词出现的次数
    if word in words2:
        vector2[i] += 1 # 统计第二个字符串中每个词出现的次数

# 计算两个字符串的相似度（以余弦距离作为指标）
similarity = 1 - cosine(vector1, vector2)

print(&amp;quot;两个字符串的相似度是：&amp;quot;, similarity)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/p&gt;
&lt;h3 id=&#34;栗&#34;&gt;栗
&lt;/h3&gt;&lt;p&gt;SQL文で、製品コード表から、製品コードが80000～89999の範囲にあるレコードを抽出してください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;你好，这是 Bing。😊

根据搜索结果12，你可以使用 SQL BETWEEN 运算符来选择给定区间内的值。BETWEEN 运算符包含了开始和结束的值。

你需要先指定要查询的表名和列名，然后在 WHERE 子句中使用 BETWEEN 运算符和区间值。

例如，如果你要查询产品代码表中，产品代码在 80000 到 89999 之间的记录，你可以使用以下语句：

SELECT * FROM product_code
WHERE code BETWEEN 80000 AND 89999;
这里，* 表示选择所有列3。如果你只想选择特定的列，比如产品名称和价格，你可以用逗号分隔它们，如下：

SELECT name, price FROM product_code
WHERE code BETWEEN 80000 AND 89999;
希望这能帮助到你。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;引き続き質問し、否定してください。製品コードは文字列です。あなたのコードが間違っています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;抱歉，我没有注意到产品代码是字符串。如果是这样的话，你需要在区间值两边加上单引号，如下：

SELECT * FROM product_code
WHERE code BETWEEN &#39;80000&#39; AND &#39;89999&#39;;
请原谅我的错误。🙏
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;おめでとうございます、間違えるでしょう。&lt;/p&gt;</description>
        </item>
        <item>
        <title>いくつかのあまり使われないGitコマンドまとめ</title>
        <link>https://ttf248.life/ja/p/git-less-common-commands-summary/</link>
        <pubDate>Fri, 17 Feb 2023 10:08:57 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/git-less-common-commands-summary/</guid>
        <description>&lt;p&gt;あまり使われないけれど役に立つコマンド&lt;/p&gt;
&lt;h3 id=&#34;システム再インストールによりフォルダのオーナー情報が変更されます&#34;&gt;システム再インストールにより、フォルダのオーナー情報が変更されます。
&lt;/h3&gt;&lt;p&gt;新しいバージョンではセキュリティチェックが強化され、警告が表示されるため、操作を続行できません。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global --add safe.directory
git config --global --add safe.directory &amp;quot;*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;新しいコンピューターへのアカウントとパスワードの情報保存&#34;&gt;新しいコンピューターへのアカウントとパスワードの情報保存
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global credential.helper store
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;情報が更新される場合は、まず古い記録を削除してください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --system --unset credential.helper
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>コンパイラ、コールバック関数、パフォーマンステスト</title>
        <link>https://ttf248.life/ja/p/compiler-callback-function-performance-testing/</link>
        <pubDate>Wed, 15 Feb 2023 13:59:25 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/compiler-callback-function-performance-testing/</guid>
        <description>&lt;p&gt;昨年、ある__INLINE_CODE_0__を設計しました。これはイベントの処理を担当し、クラスインターフェースを提供します。サービス初期化時に、呼び出し元が対応するクラスを実装し、オブジェクトポインタをモジュールに渡します。
接触した__，好奇心害死猫，就想着这些接口都用&lt;code&gt;C11&lt;/code&gt;関数オブジェクトコールバックによる実装は、純粋仮想関数のインターフェース定義と比較して、より柔軟である。
疑問が生じた。二つの異なる文法、どちらがパフォーマンス面で速いのか？ 私はコンパイラ理論を理解していないので、コードを書いて試してみよう。&lt;/p&gt;
&lt;h2 id=&#34;まえがき&#34;&gt;まえがき
&lt;/h2&gt;&lt;p&gt;オンラインURLで、異なるコンパイラやコンパイルパラメータを選択し、__INLINE_CODE_0__プラットフォーム上でコードを実行したり、対応するアセンブリコードを確認できます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;技術検証を時々行う際、ウェブページで短いコードを実行するのは便利です。&lt;/li&gt;
&lt;li&gt;色分けすることで、異なるアセンブリに対応するコードを区別でき、ローカルのデバッガーよりも見やすくなります。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;標準委員会が文法の規則を策定し、コンパイルレベルでの実装方法は各コンパイラの自由です。ここで言及せざるを得ないのは、Microsoftのコンパイラは非常に優れているということです。シンタックスシュガーは万能ではなく、コールバックインターフェースも多くありません。__INLINE_CODE_0__の使用の方が便利で、空のコールバック関数インターフェースを定義する必要もありません。コールバックインターフェースの種類が多様な場合は、従来の仮想関数の方がビジネスインターフェースの統一に有利です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;プラットフォーム、両者とも性能はほぼ同等で、大きな違いはありません。&lt;/li&gt;
&lt;li&gt;比較して、一度あたり1.35ns増加。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常の業務システム開発においては、このレベルのパフォーマンス損失は無視できる。&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;，在设计的上，能带来更多的便捷。在设计多信号处理时，尤为明显，底层有事件触发，如果需要落地日志，出入日志对象的的处理函数。当需要更多的业务处理接口时，底层用__INLINE_CODE_1__保存__INLINE_CODE_2__BOLD_6&lt;code&gt;QT&lt;/code&gt;における信号とスロット、ログ、監視、業務1、業務2は、互いに完全に分離されている。&lt;/p&gt;
&lt;h2 id=&#34;コード&#34;&gt;コード
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Counter: 1000000
Time: 3966us
Counter: 1000000
Time: 5316us
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;memory&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;atomic&amp;gt;
#include &amp;lt;string&amp;gt;

std::atomic_int64_t counter = 0;

// 定义回调接口
class UserInterface
{
public:
    virtual void name() = 0;
    virtual void full_name() = 0;
};

class User : public UserInterface
{
public:
    void name() {}
    void full_name() { counter++; }
};

void to_string(UserInterface* user)
{
    user-&amp;gt;name();
    user-&amp;gt;full_name();
}

using name_handler = std::function&amp;lt;void()&amp;gt;;
using full_name_handler = std::function&amp;lt;void()&amp;gt;;

class Test
{
    name_handler name_;
    full_name_handler full_name_;

public:
    void set_name_handler(name_handler name)
    {
        name_ = name;
    }

    void set_full_name_handler(full_name_handler full_name)
    {
        full_name_ = full_name;
    }

    void to_string()
    {
        name_();
        full_name_();
    }
};

int main()
{
    User user;

    auto start = std::chrono::high_resolution_clock::now();

    for (int i = 0; i &amp;lt; 1000000; i++)
    {
        to_string(&amp;amp;user);
    }

    auto end = std::chrono::high_resolution_clock::now();
    std::cout &amp;lt;&amp;lt; &amp;quot;Counter: &amp;quot; &amp;lt;&amp;lt; counter &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;Time: &amp;quot; &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(end - start).count() &amp;lt;&amp;lt; &amp;quot;us&amp;quot; &amp;lt;&amp;lt; std::endl;

    counter = 0;
    auto name = []() {};
    auto full_name = []() { counter++; };

    Test test;
    test.set_name_handler(name);
    test.set_full_name_handler(full_name);

    start = std::chrono::high_resolution_clock::now();

    for (int i = 0; i &amp;lt; 1000000; i++)
    {
        test.to_string();
    }

    end = std::chrono::high_resolution_clock::now();
    std::cout &amp;lt;&amp;lt; &amp;quot;Counter: &amp;quot; &amp;lt;&amp;lt; counter &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;Time: &amp;quot; &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(end - start).count() &amp;lt;&amp;lt; &amp;quot;us&amp;quot; &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;追記&#34;&gt;追記
&lt;/h2&gt;&lt;p&gt;資料を探している時に、類似のコードスニペットにたどり着きました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;memory&amp;gt;
#include &amp;lt;functional&amp;gt;

using namespace std;
using namespace std::chrono;

class Base
{
public:
	Base(){}
	virtual ~Base(){}
	virtual int func(int i) = 0;
};

class Derived : public Base
{
public:
	Derived(int base = 10) : base{base}
	{

	}
	~Derived(){}

	virtual int func(int i)
	{
		return i*base;
	}
private:
	int base;
};

struct Func
{
	int base;
	int operator()(int i)
	{
		return i*base;
	}
	Func(int base) : base {base}
	{

	}
};
const int base = 10;
int calculate(int i)
{
	return base*i;
}

int main()
{
	const int num = 10000;
	Base *p = new Derived{10};
	int total = 0;
	auto start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += p-&amp;gt;func(i);
	}
	auto end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nvirtual call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;

	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += calculate(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\ndirect function call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;

	Func functor{10};
	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += functor(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nfunctor call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;
	int base = 10;
	function&amp;lt;int(int)&amp;gt; lambda = [base](int i)
	{
		return i*base;
	};
	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += lambda(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nlambda call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;
	return 0;
}

/*
test on mac mini i7 2.7GHz
clang++ -std=c++11 chronotest.cpp -O0
output:
result: 499950000
virtual call elapsed: 	43171 nanoseconds.

result: 499950000
direct function call elapsed: 	31379 nanoseconds.

result: 499950000
functor call elapsed: 	41497 nanoseconds.

result: 499950000
lambda call elapsed: 	207416 nanoseconds.
===================================================
clang++ -std=c++11 chronotest.cpp -O1
output:
result: 499950000
virtual call elapsed: 	26144 nanoseconds.

result: 499950000
direct function call elapsed: 	22384 nanoseconds.

result: 499950000
functor call elapsed: 	33477 nanoseconds.

result: 499950000
lambda call elapsed: 	55799 nanoseconds.
===================================================
clang++ -std=c++11 chronotest.cpp -O2
result: 499950000
virtual call elapsed: 	22284 nanoseconds.

result: 499950000
direct function call elapsed: 	36 nanoseconds.

result: 499950000
functor call elapsed: 	30 nanoseconds.

result: 499950000
lambda call elapsed: 	28292 nanoseconds.

===================================================
clang++ -std=c++11 chronotest.cpp -O3
result: 499950000
virtual call elapsed: 	18975 nanoseconds.

result: 499950000
direct function call elapsed: 	29 nanoseconds.

result: 499950000
functor call elapsed: 	30 nanoseconds.

result: 499950000
lambda call elapsed: 	22542 nanoseconds.
===================================================
clang++ -std=c++11 chronotest.cpp -O4

result: 499950000
virtual call elapsed: 	22141 nanoseconds.

result: 499950000
direct function call elapsed: 	30 nanoseconds.

result: 499950000
functor call elapsed: 	30 nanoseconds.

result: 499950000
lambda call elapsed: 	22584 nanoseconds.
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ここでは、通常の関数とラムダ関数の2つのモードが追加され、インターフェースコールバック方式と直接呼び出しの比較を提供します。性能損失は桁違いであり、ラムダ関数の性能は関数に近く、場合によってはラムダ関数の性能の方が優れています。コンパイラ原理に関しては知識の空白ですが、アクセスする変数のアドレスと関数が隣接しているため、__INLINE____処理に有利であると推測しています。&lt;/p&gt;
&lt;p&gt;添付 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; の実行結果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;result: 499950000
virtual call elapsed: 6143 nanoseconds.

result: 499950000
direct function call elapsed: 30 nanoseconds.

result: 499950000
functor call elapsed: 31 nanoseconds.

result: 499950000
lambda call elapsed: 15134 nanoseconds.
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>ホストオーダー、ネットワークオーダー。デバッガで直接観察。</title>
        <link>https://ttf248.life/ja/p/host-order-network-order-debugger-observation/</link>
        <pubDate>Tue, 10 Jan 2023 14:18:12 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/host-order-network-order-debugger-observation/</guid>
        <description>&lt;p&gt;コンピュータの発展史において、データを保存する方法に統一された基準はありませんでした。&lt;/p&gt;
&lt;p&gt;バイトの配置には、主に2つの一般的な規則があります。例えば、多桁数の下位を小さいアドレスに、上位を大きいアドレスに配置する場合をリトルエンディアンと呼び、その逆をビッグエンディアンと呼びます。ネットワークアプリケーションでは、異なるマシンタイプが異なる標準のエンディアンを採用する可能性があるため、バイトオーダーは考慮すべき要素であり、通常はネットワーク標準に変換されます。&lt;/p&gt;
&lt;p&gt;読書習慣では、ビッグエンディアンの方が左から右への読み順に合致しやすい。&lt;/p&gt;
&lt;h2 id=&#34;申し訳ありませんが翻訳する中国語のテキストが提供されていませんテキストを提供していただければ日本語に翻訳します&#34;&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;x86、MOS Technology 6502、Z80、VAX、PDP-11 などのプロセッサはリトルエンディアンです。&lt;/li&gt;
&lt;li&gt;モトローラ6800、モトローラ68000、PowerPC 970などのプロセッサは大Endianです。&lt;/li&gt;
&lt;li&gt;ARM、PowerPC（PowerPC 970を除く）、DEC Alpha、SPARC V9、MIPS、PA-RISCおよびIA64のバイトオーダーは構成可能です。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ネットまえがき&#34;&gt;ネットまえがき
&lt;/h2&gt;&lt;p&gt;ネットワーク転送では通常、ビッグエンディアンが採用され、ネットワークバイトオーダーまたはネットワーク順とも呼ばれます。IPプロトコルでは、ビッグエンディアンをネットワークバイトオーダーとして定義しています。
ソケットは、16ビットおよび32ビット整数のネットワークバイトオーダーとローカルバイトオーダー間の変換を行うための関数群を定義します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;arpa/inet.h&amp;gt;

uint32_t htonl(uint32_t hostlong); //把uint32_t类型从主机序转换到网络序
uint16_t htons(uint16_t hostshort); //把uint16_t类型从主机序转换到网络序
uint32_t ntohl(uint32_t netlong); //把uint32_t类型从网络序转换到主机序
uint16_t ntohs(uint16_t netshort); //把uint16_t类型从网络序转换到主机序
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;もし__INLINE_CODE_0__をネットワークライブラリとして選択した場合、組み込みのネームスペースにはクロスプラットフォーム対応の関数名が存在します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;boost::asio::detail::socket_ops::network_to_host_long&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::network_to_host_short&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::host_to_network_long&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::host_to_network_short&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ビジュアルスタジオ-デバッガー&#34;&gt;ビジュアルスタジオ デバッガー
&lt;/h2&gt;&lt;p&gt;デバッグモードで、デバッグメニューのウィンドウを選択し、メモリウィンドウにチェックを入れます。&lt;/p&gt;
&lt;p&gt;__INLINE_CODE_0__において、デバッガー内でメモリ内のデータを確認できます。図を参照してください。&lt;/p&gt;
&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;Snipaste_2023-01-10_14-44-00.png&#34; &gt;调试器菜单&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;メモリの確認方法&#34;&gt;メモリの確認方法
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;変数名を直接出力し、対応する変数のアドレスにジャンプします。&lt;/li&gt;
&lt;li&gt;変数そのものがポインタであれば、変数をダブルクリックして選択し、メモリウィンドウにドラッグすると、対応するアドレスの内容が表示されます。&lt;/li&gt;
&lt;li&gt;変数がポインタでない場合、計算ウィンドウに追加し、アドレスを取得後、手動でメモリウィンドウにコピーする。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例えば&#34;&gt;例えば
&lt;/h3&gt;&lt;p&gt;データを受信し、&lt;code&gt;buffer&lt;/code&gt;对象中，将网络序转成主机序，得到__INLINE_CODE_1__に保存します。この値は30で、サーバー側ではこのデータを送信するために4バイトが割り当てられています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool NetworkMessage::decode_header()
{
    // 网络序转成主机序
    body_length_ = boost::asio::detail::socket_ops::network_to_host_long(*(int *)buffer_.data());
    return auto_reserve(body_length_);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;メモリウィンドウで、&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; の内容を観察してください。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/host-order-network-order-debugger-observation/buffer_.png&#34;
	width=&#34;603&#34;
	height=&#34;318&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;buffer_&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;189&#34;
		data-flex-basis=&#34;455px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;メモリウィンドウで、&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; の内容を観察してください。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/host-order-network-order-debugger-observation/body_length_.png&#34;
	width=&#34;581&#34;
	height=&#34;333&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;body_length_&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;174&#34;
		data-flex-basis=&#34;418px&#34;
	
&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>C11: sleep for vs yield</title>
        <link>https://ttf248.life/ja/p/c11-sleep-for-vs-yield/</link>
        <pubDate>Tue, 20 Sep 2022 20:54:51 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/c11-sleep-for-vs-yield/</guid>
        <description>&lt;p&gt;コードを見返しているとき、&lt;code&gt;std::this_thread::yield()&lt;/code&gt; 猛的引入眼帘，&lt;code&gt;C11&lt;/code&gt;里面的语法糖，用了不少，__INLINE_CODE_2__里面的语法糖，用了不少，__を初めて見ました。今まで気づいていませんでした。&lt;/p&gt;
&lt;p&gt;マニュアルを確認する前に、最初に考えたのは非同期処理との関連性だった。__INLINE_CODE_0__Boostライブラリのコルーチン実装でこの単語が使われているが、ここではコルーチンとは関係ないだろう。制御ロジックは通常のスレッドに関連している。&lt;/p&gt;
&lt;h2 id=&#34;文書&#34;&gt;文書
&lt;/h2&gt;&lt;h3 id=&#34;yield&#34;&gt;yield
&lt;/h3&gt;&lt;p&gt;この関数の正確性は、実装に依存し、特に使用されているOSスケジューラ機構とシステムの状態に左右されます。例えば、先着順リアルタイムスケジューラ（LinuxのSCHED_FIFO）は、現在のスレッドを中断し、同じ優先度の他のスレッドがなければ、準備完了キューの末尾に配置します（他のスレッドが存在しない場合、yieldの効果はありません）。&lt;/p&gt;
&lt;h3 id=&#34;sleep_for&#34;&gt;sleep_for
&lt;/h3&gt;&lt;p&gt;指定されたsleep_durationの間、現在のスレッドの実行をブロックします。
この関数は、スケジューリングやリソース競合により、sleep_durationよりも長くブロックされる可能性がある。
標準ライブラリでは、安定したクロックで時間を計測することを推奨します。システム時間を用いる実装の場合、待ち時間もクロック調整に影響される可能性があります。&lt;/p&gt;
&lt;h3 id=&#34;分析&#34;&gt;分析
&lt;/h3&gt;&lt;p&gt;二つの関数は、現在のスレッドがスレッドを占有しなくなるようにするもので、効果はプラットフォームによって異なるようですね。ここまでの説明だけではまだよくわからないので、コードを実行して動作を確認してみます。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;シンクパッド ノートPC（Visual Studio Community Edition 2022）、テンセントクラウド S2 スタンダードサーバー（gcc8.5）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;実行プラットフォーム&lt;/th&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;初回/μs&lt;/th&gt;
&lt;th&gt;第2回/μs&lt;/th&gt;
&lt;th&gt;第3回/μs&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;sleep_for&lt;/td&gt;
&lt;td&gt;9872&lt;/td&gt;
&lt;td&gt;1884&lt;/td&gt;
&lt;td&gt;11302&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;yield&lt;/td&gt;
&lt;td&gt;119&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;sleep_for&lt;/td&gt;
&lt;td&gt;171&lt;/td&gt;
&lt;td&gt;168&lt;/td&gt;
&lt;td&gt;167&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;yield&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;td&gt;102&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;動作結果から容易に理解できるように、オペレーティングシステムの実現方法の違いにより、高精度スリープでは、&lt;strong&gt;INLINE_CODE_0__BOLD_2&lt;code&gt;yield&lt;/code&gt;&lt;/strong&gt; の方が適しています。&lt;/p&gt;
&lt;p&gt;時間精度が__INLINE_CODE_0__に向上しても、両者の差はそれほど顕著ではない。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;thread&amp;gt;
 
// 建议其他线程运行一小段时间的“忙睡眠”
void little_sleep(std::chrono::microseconds us)
{
    auto start = std::chrono::high_resolution_clock::now();
    auto end = start + us;
    do {
        std::this_thread::yield();
    } while (std::chrono::high_resolution_clock::now() &amp;lt; end);
}
 
int main()
{
    auto start = std::chrono::high_resolution_clock::now();
 
    little_sleep(std::chrono::microseconds(100));
    std::this_thread::sleep_for(std::chrono::microseconds(100));
 
    auto elapsed = std::chrono::high_resolution_clock::now() - start;
    std::cout &amp;lt;&amp;lt; &amp;quot;waited for &amp;quot;
              &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(elapsed).count()
              &amp;lt;&amp;lt; &amp;quot; microseconds\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/header/thread.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/header/thread.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/thread/sleep_for.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/thread/sleep_for.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Linuxサーバー、MySQLパスワードリセット</title>
        <link>https://ttf248.life/ja/p/linux-server-reset-mysql-password/</link>
        <pubDate>Tue, 20 Sep 2022 14:27:35 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-server-reset-mysql-password/</guid>
        <description>&lt;p&gt;台に余っているテンセントクラウドのサーバーがあり、年末で契約満了になるため、更新は考えていません。開発用のデータベースとしてMySQLをデプロイしました。システムを再インストールする際、手間を省くため、テンセントクラウドが提供しているサードパーティ製のイメージを選択し、MySQLデータベースがすでにインストールされていました。パスワードや配置場所などを説明するReadmeファイルのようなものが標準で付属していると期待していましたが。&lt;/p&gt;
&lt;p&gt;テンスクラウドのシステム再インストールはすぐに完了、約1分で通知が来てログインすると、__INLINE_CODE_0__サービスは起動済み。パスワードを探し回ったが見つからず、徐々に諦めかけている。&lt;/p&gt;
&lt;p&gt;その時思った、すでにサーバーにアクセスできているし、__INLINE_CODE_0__権限を持っているのだから、どうにかしてパスワードをリセットする方法はあるはずだ。資料を調べてみると、アリババクラウドのフォーラムに投稿があり、さらに試してみることにした。&lt;/p&gt;
&lt;h2 id=&#34;パスワード再設定&#34;&gt;パスワード再設定
&lt;/h2&gt;&lt;p&gt;設定ファイルを編集&lt;/p&gt;
&lt;p&gt;再利用__INLINE_CODE_0__直接登录数据，接来下就是正常操作了，重置__INLINE_CODE_1__ユーザーパスワードで、リモートログインを有効にします。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;USE mysql;
UPDATE user SET authentication_string = password (&#39;pass&#39;) WHERE User = &#39;root&#39;;
grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;pass&#39; with grant option;
flush privileges;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;設定ファイルをロールバックし、データベースを再起動すればOK。&lt;/p&gt;
&lt;h2 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://help.aliyun.com/document_detail/42520.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://help.aliyun.com/document_detail/42520.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>自動テストの簡単な考察</title>
        <link>https://ttf248.life/ja/p/shallow-discussion-on-automation-testing/</link>
        <pubDate>Thu, 04 Aug 2022 11:39:18 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/shallow-discussion-on-automation-testing/</guid>
        <description>&lt;p&gt;金融取引システムにおけるテストへの投資は、他のシステムを大きく上回っており、煩雑なテスト手順が繰り返され、&lt;strong&gt;INLIN_ITALIC_1&lt;/strong&gt;__ は極めて低い。プロジェクトや人員の交代に伴い、不可避的に多くの制御不能な要因が導入され、よくあるケースとして、Aインターフェースの出力する特定のフィールドを変更した結果、Bインターフェースの結果に影響が出てしまう。バージョンリリースごとにリスクも蓄積している。&lt;/p&gt;
&lt;h2 id=&#34;理論知識&#34;&gt;理論知識
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自動化テストケースのROI = （手動実行時間）×（実行回数） / （開発コスト + メンテナンスコスト）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ユーザーが頻繁に利用し、変更されない機能。このタイプのインターフェースに対して自動テストコードを記述すると、最も効果的です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;プロジェクトのリリースが目前に迫っており、明らかに不適切です。遠い水を近くの渇きを癒すことはできず、自動化は長期的な収益モデルです。プロジェクトは既に&lt;strong&gt;生产环境&lt;/strong&gt;でオンラインとなり、安定したリリースサイクルに入っています。このタイミングが最適です。&lt;/p&gt;
&lt;h2 id=&#34;フレームの選択&#34;&gt;フレームの選択
&lt;/h2&gt;&lt;p&gt;関連する実践経験がないまま、自動テストというタスクを任されることになった場合、よくある流れ：検索エンジンを開き、現在のシステムで利用できるツールやフレームワークを探し、マニュアルを読んでから着手。すぐに適切なツールが見つかれば、おめでとうございます、&lt;strong&gt;完美开局&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;先に謝罪いたします。関連資料を確認したところ、存在しないというわけではなく、フレームワーク自体が複雑で、デプロイに必要なリソースも過多です。初心者向けには、小さく、簡潔なものが求められます。テストチームの同僚に相談した結果、&lt;code&gt;Python&lt;/code&gt; 自建フレームワークというアイデアが出ました。簡単に言うと、既存の単体テストフレームワークを使い、自動テストフレームワークとしてパッケージ化するというものです。&lt;/p&gt;
&lt;p&gt;このプロジェクトのデザインのコンセプトを参考に：&lt;a class=&#34;link&#34; href=&#34;https://github.com/wintests/pytestDemo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/wintests/pytestDemo&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;フレームが必要な理由は何ですか&#34;&gt;フレームが必要な理由は何ですか？
&lt;/h2&gt;&lt;p&gt;サービスには複数のデプロイ環境があり、開発環境、テスト環境、本番環境があります。フレームワークの役割は、これらの環境を分離し、テストケースとデータを切り離すことです。異なる環境ごとに異なるテストデータが設定可能で、共通データもサポートしています。&lt;/p&gt;
&lt;p&gt;自動化の活用率向上のための根本的なロジックです。シーンが複雑になればなるほど、異なる環境間のデータは互いに関係なく、設定ケースデータ時に &lt;code&gt;label&lt;/code&gt; タグを追加し、対応する環境を指定してください。&lt;/p&gt;
&lt;h2 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h2&gt;&lt;p&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/p&gt;</description>
        </item>
        <item>
        <title>なぜ新しい言語を学ぶ必要があるのか。</title>
        <link>https://ttf248.life/ja/p/why-learn-a-new-language/</link>
        <pubDate>Thu, 04 Aug 2022 11:27:30 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/why-learn-a-new-language/</guid>
        <description>&lt;p&gt;学期から数えても、&lt;code&gt;C++&lt;/code&gt;に触れてから十年以上経っているのに、他のプログラミング言語を学ぶ必要性がなぜあるのだろうか。&lt;/p&gt;
&lt;p&gt;エレガントなモジュール設計の経験は不足しているが、文法は自由で、他の言語の学習も、よりエレガントなデザインを導くのに役立つ。&lt;/p&gt;
&lt;p&gt;ツールを開発するときによく使う。&lt;/p&gt;
&lt;p&gt;設計の原則は、基盤ライブラリであろう、ビジネスモジュール実装であろう、どちらも同じです。&lt;/p&gt;</description>
        </item>
        <item>
        <title>ビジュアルスタジオのコンパイル文字コード[転]</title>
        <link>https://ttf248.life/ja/p/visual-studio-compilation-character-set-translation/</link>
        <pubDate>Thu, 04 Aug 2022 10:51:43 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/visual-studio-compilation-character-set-translation/</guid>
        <description>&lt;p&gt;定数に改行文字が含まれています。&lt;/p&gt;
&lt;h2 id=&#34;visual-studio&#34;&gt;visual studio
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;斜体_5&lt;/strong&gt;&lt;strong&gt;太字_3&lt;/strong&gt;&lt;strong&gt;斜体_6&lt;/strong&gt;&lt;strong&gt;太字_4&lt;/strong&gt;&lt;strong&gt;斜体_7&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;参照資料は、問題の発生原因を詳しく説明している。&lt;/p&gt;
&lt;p&gt;エンコーディングに関しては、&lt;code&gt;MSVC&lt;/code&gt;有专门的编译选项&lt;code&gt;/source-charset&lt;/code&gt;和&lt;code&gt;/execution-charset&lt;/code&gt;の2つで対応します。前者はファイルのエンコードを示し、後者はコンパイル後の文字配列内のバイトがどのようなエンコードであるかを示しており、エンコーディングの問題は基本的にこの2つのオプションで解決できます。&lt;/p&gt;
&lt;p&gt;例えば、太字_11_斜体_21_太字_12_斜体_22_太字_13_斜体_23_太字_14_斜体_24_太字_15_斜体_25_太字_16_斜体_26_太字_17_斜体_27_太字_18_斜体_28_太字_19_斜体_29_太字_20_インラインコード_10_は、コンソール上で正常に漢字を表示する。&lt;/p&gt;
&lt;h2 id=&#34;cmake-ビジュアルスタジオ設定&#34;&gt;CMake ビジュアルスタジオ設定
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;if( WIN32 )
    message( STATUS &amp;quot;Configuring trade on WIN32&amp;quot;)
    set( CMAKE_CXX_FLAGS &amp;quot;${CMAKE_CXX_FLAGS} /source-charset:utf-8 /execution-charset:gbk&amp;quot;)
endif()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/146543940&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/146543940&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Windows プラットフォームでのフォルダサイズ高速統計</title>
        <link>https://ttf248.life/ja/p/windows-platform-quick-folder-size-statistics/</link>
        <pubDate>Mon, 01 Aug 2022 19:54:18 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/windows-platform-quick-folder-size-statistics/</guid>
        <description>&lt;p&gt;どうしようか。ディスクがたくさんあって、整理したいけど、ファイルが多い状態で、標準のリソースマネージャーでフォルダサイズを統計すると、途中で諦めたくなるほど遅い。&lt;/p&gt;
&lt;h2 id=&#34;everything&#34;&gt;Everything
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;斜体_3&lt;/strong&gt;**太字_2__斜体_4__も、友人から聞いたはずです。検索速度は標準のファイルエクスプローラーを大幅に上回ります。システムレベルでファイルの高速インデックスがサポートされているのであれば、同様のツールが見つかるはずです。ファイルのインデックスを作成しつつ、ファイルサイズも統計的に把握できるでしょう。&lt;/p&gt;
&lt;h2 id=&#34;wiztree&#34;&gt;WizTree
&lt;/h2&gt;&lt;p&gt;公式サイト：&lt;a class=&#34;link&#34; href=&#34;https://www.diskanalyzer.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.diskanalyzer.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;標準インストールモードまたはグリーン版の展開実行。&lt;/p&gt;
&lt;p&gt;高速で、多様なデータ表示形式があり、左側はツリー図モード、右側はファイルタイプです。もちろん、グラフィカルな表示もソフトウェアの最下部にあります。&lt;/p&gt;
&lt;h2 id=&#34;spacesnifferアップデート終了サポートなし&#34;&gt;SpaceSniffer（アップデート終了、サポートなし）
&lt;/h2&gt;&lt;p&gt;ソフトウェア公式サイト：&lt;a class=&#34;link&#34; href=&#34;http://www.uderzo.it/main_products/space_sniffer/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.uderzo.it/main_products/space_sniffer/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;操作は簡単です。対応するディスクを選択すると、ソフトウェアがフォルダの容量をグラフィカルに表示します。容量が大きいほど、画像内のマトリックスも大きくなります。その他の操作は、クリックすれば理解できるはずです。ファイルに対して条件フィルタリングにも対応しています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ファイルサイズフィルタ&lt;/li&gt;
&lt;li&gt;書類の日付フィルタ&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;space_sniffer.gif&#34; &gt;基础用法&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;advance.gif&#34; &gt;高级用法&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://moe.best/software/spacesniffer.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://moe.best/software/spacesniffer.html&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>ウェブページのスタイルシート（CSS）のコピー：要素検査</title>
        <link>https://ttf248.life/ja/p/how-to-copy-webpage-css-element-inspection/</link>
        <pubDate>Sun, 31 Jul 2022 23:36:48 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/how-to-copy-webpage-css-element-inspection/</guid>
        <description>&lt;p&gt;海外のテンプレートをベースに修正・調整することが多く、中国語コンテンツのレイアウトについてはあまり考慮されていない。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;半月ほど前にブログのスタイルシートを調整しました。長年バックエンドサービスの開発をしていて、フロントエンドは初心者です。色々試しましたが、デザインがよくわかりません。ふと、いつも参考にしている技術ブログ「infoQ」や「OSChina」のようなレイアウトを取り入れてみたらどうだろうと考えました。ソースコードを見て関連要素を探しましたが、全く見当もつきませんでした。&lt;/p&gt;
&lt;p&gt;フロントエンドの方ならここで笑ってしまうかもしれませんね…指定要素の特定も分からない。分からなくても大丈夫、週末に時間があるので、立ち止まって考えてみましょう。昔、__INLINE_CODE_0__クローラーを書いた時、似たようなものが使われていた気がします。&lt;/p&gt;
&lt;h3 id=&#34;元素チェック&#34;&gt;元素チェック
&lt;/h3&gt;&lt;p&gt;確かに、ブラウザに標準搭載されている要素検査ツールを使えば、スタイルシートのコピーや特定要素の特定もあっという間にできます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要素の複製&lt;/li&gt;
&lt;li&gt;outerHTMLをコピーする&lt;/li&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;li&gt;JS パスをコピーする&lt;/li&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;li&gt;XPathをコピー&lt;/li&gt;
&lt;li&gt;XPathをコピーします。&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Windows プラットフォーム向け、巨大ファイル編集：EmEditor (テキストエディタ)</title>
        <link>https://ttf248.life/ja/p/windows-platform-editing-large-files-emeditor-text-editor/</link>
        <pubDate>Sun, 31 Jul 2022 23:21:24 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/windows-platform-editing-large-files-emeditor-text-editor/</guid>
        <description>&lt;p&gt;上海国安データベース事件は、ハッカー界隈で騒がれており、真偽は定かではない。2年後覚えていれば、また振り返ってみよう。過去の経験から、ローカルのソーシャルエンジニアリングデータベース資料を更新したところ、巨大なSQLファイル：17.9Gを発見。普通のテキストエディタではプレビューですら問題があり、ましてや開くことなどできない。ネットユーザーとの雑談で、EmEditorという名前が出てきた。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;公式サイト：&lt;a class=&#34;link&#34; href=&#34;https://www.emeditor.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.emeditor.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;週末に時間を作って試してみたところ、なかなか便利だった。デザインも大規模ファイルの編集に対応しており、十分なメモリがあればファイル全体を読み込んで、検索や編集の速度も速い。分割機能もある。&lt;/p&gt;</description>
        </item>
        <item>
        <title>思ったより簡単なことだが、コードコピーボタンを追加する。</title>
        <link>https://ttf248.life/ja/p/add-code-copy-button/</link>
        <pubDate>Fri, 25 Feb 2022 01:23:39 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/add-code-copy-button/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;４時間もかけて、この文を見て笑ったけど、まさかこんなに時間がかかるなんて。最後に見たら３時間だった。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;二〇二二年最初の原稿、と言っても大したことのない内容で、タイトル通り（当時の私はまだ若かった）、&lt;a class=&#34;link&#34; href=&#34;https://ouuan.github.io/post/from-hexo-to-hugo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;作业&lt;/a&gt;をそのままコピーして保存し、ずいぶんと待った後、ようやく思い出しました。&lt;/p&gt;
&lt;p&gt;移行時にプラグインが少なくて、コードのコピー＆ペーストができず、多くのノートを印象ノートからブログに移行する際に、その操作が煩雑になり、ブログ更新のモチベーションを著しく損ねていました。&lt;/p&gt;
&lt;h2 id=&#34;前章&#34;&gt;前章
&lt;/h2&gt;&lt;p&gt;まずは原著者の稿を丁寧に見て、一度通読してから紹介を見てみよう。清華大学の学部在学生で、早い段階からコンピュータに触れているとは、すごいな。まずこのブログを見てみるか。何をしていいのか全く思い出せない。ついでに、作者の__INLINE_CODE_0__仓库，这个修改后的__INLINE_CODE_1__テーマの方が今のよりずっと魅力的だし、新機能も多いから、やってみよう。まずは関連コードをマージしよう。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/add-code-copy-button/2022-02-25-02-08-19.png&#34;
	width=&#34;215&#34;
	height=&#34;150&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;143&#34;
		data-flex-basis=&#34;344px&#34;
	
&gt; &lt;img src=&#34;https://ttf248.life/p/add-code-copy-button/2022-02-25-02-08-40.png&#34;
	width=&#34;217&#34;
	height=&#34;167&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;129&#34;
		data-flex-basis=&#34;311px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;新機能記事履歴の確認関連提出記録の閲覧&#34;&gt;新機能：記事履歴の確認、関連提出記録の閲覧
&lt;/h3&gt;&lt;p&gt;なかなか良い効果だ、文の最後に持っていくと体験できる。&lt;/p&gt;
&lt;p&gt;作業前に作者のオリジナルリポジトリの履歴をよく見ていなかった、単純なマージで済むだろうと思っていた。結局、大量のコードをマージしてしまい、途中何度もコンフリクトが発生し、無駄に上書きしてしまった。全てはフロントエンドとレンダリングのテンプレートコードで、自分の希望に合わせて変更した。&lt;/p&gt;
&lt;p&gt;倉庫住所：&lt;a class=&#34;link&#34; href=&#34;https://github.com/TianlongXiang/hugo-theme-even&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/TianlongXiang/hugo-theme-even&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中国の一つの問題点があり、&lt;code&gt;git&lt;/code&gt;不调整这个参数，会导致生成的获取不到当前文章的&lt;code&gt;commit hash&lt;/code&gt;のため、過去のリンクが生成できません。記事の完全な履歴を生成する際も、自動統合スクリプトを修正する必要があります。現在のリポジトリ全体の過去の記録を必ず取得してください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;name: Build Github
run: git config --global core.quotePath false &amp;amp;&amp;amp; hugo -b &amp;quot;https://www.xiangtianlong.com/&amp;quot; -d &amp;quot;github_public&amp;quot; &amp;amp;&amp;amp; ls
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;スタイル調整&#34;&gt;スタイル調整
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;サイトコンテンツの幅を調整しました。以前のデザインはモバイルとPC向けでしたが、実際には誰もスマホで見ていません。私もPCで見ています。&lt;/li&gt;
&lt;li&gt;目次バーは自動伸縮に対応しています。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;参考__INLINE_CODE_0__のコードを半時間以上見ていても、コピーボタンを追加する方法がよく分かりませんでした。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;時が流れ、一月後、またこのことを思い出した。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;この課題が理解できないので、別の課題を写し転がせば、なんとかなるだろう。検索結果は意外だった,&lt;code&gt;hugo&lt;/code&gt;BOLD_2&lt;code&gt;even&lt;/code&gt;レンダリングされたコードブロックのスタイルが資料の説明と異なり、このあたりは少し面倒なので、簡単に記録しておく。&lt;/p&gt;
&lt;p&gt;フロントエンド開発の基礎があまり分からないので、理解できない箇所はブラウザを開いて &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;，对着代码分析、靠着右边的样式器信息，慢慢也分析懂了逻辑；__INLINE_CODE_1__を参考にし、コンソールでログを確認しました。分からないことはたくさんありますが、落ち着いて論理を整理・分解していけば、必ず道は開けます。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ノードが複数ある場合、ここでいうのは単一のコードブロックを指し、テーマ自体が行番号を出力しているため、コピーボタンが2つ表示される。&lt;/li&gt;
&lt;li&gt;コードハイライトの自動レンダリングが欲しいのだが、テーマ設定に詳しくない。&lt;/li&gt;
&lt;li&gt;コードハイライトの制御設定。&lt;/li&gt;
&lt;li&gt;設定ファイルを調整しても、なかなかうまくいかず、レンダリング結果が期待と異なっている。&lt;/li&gt;
&lt;li&gt;これらの設定を見つけたので、資料をさらに調べ、設定を調整します。まずは行番号を削除します。&lt;/li&gt;
&lt;li&gt;カスタムの&lt;code&gt;css&lt;/code&gt;样式表，配置自定义的&lt;code&gt;js&lt;/code&gt;スクリプトの設定&lt;/li&gt;
&lt;li&gt;色々あったので、ふと最近見た配色図が良さそうだなと思い、ボタンのスタイルを修正してみることに。中国風の天青色でやってみる。&lt;/li&gt;
&lt;/ol&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:20%&#34; src=&#34;2022-02-25-02-01-22.png&#34; /&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:20%&#34; src=&#34;2022-02-25-02-01-33.png&#34; /&gt;
&lt;p&gt;四時間かけてやったのに、この文を見て笑ってしまった。まさかこんなに時間がかかるなんて。最後に見たら三時間だった。&lt;/p&gt;
&lt;h2 id=&#34;参照リンク&#34;&gt;参照リンク
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://ouuan.github.io/post/from-hexo-to-hugo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ouuan.github.io/post/from-hexo-to-hugo/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://gohugobrasil.netlify.app/content-management/syntax-highlighting/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://gohugobrasil.netlify.app/content-management/syntax-highlighting/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://gohugo.io/getting-started/configuration-markup#highlight&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://gohugo.io/getting-started/configuration-markup#highlight&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.dannyguo.com/blog/how-to-add-copy-to-clipboard-buttons-to-code-blocks-in-hugo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.dannyguo.com/blog/how-to-add-copy-to-clipboard-buttons-to-code-blocks-in-hugo/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>カオスエンジニアリング</title>
        <link>https://ttf248.life/ja/p/chaos-engineering/</link>
        <pubDate>Wed, 28 Jul 2021 14:35:07 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/chaos-engineering/</guid>
        <description>&lt;p&gt;システムを破壊するパターン、システム安定性テストを実施。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;国内のインターネット業界はいつも新しいものを生み出したがる。時々、名前を聞いてもそれが何なのか全く想像できないことがある。&lt;/p&gt;
&lt;p&gt;記事の一部を読んだのですが、カオスエンジニアリング初期の定義は比較的受け入れやすいです。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;カオスエンジニアリングの初期的な探求は、業界では以前から存在しており、障害テストやディザスタリカバリー訓練といった形で存在していました。しかし、マイクロサービスアーキテクチャの発展と分散システムの拡大に伴い、カオスエンジニアリングはその重要性を増し、注目を集め始めています。Netflixが正式にカオスエンジニアリングの概念を提起したことで、関連理論も急速に拡充され、Netflixの実践は、その安定性における大きな意義を証明しました。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;参照リンク&#34;&gt;参照リンク
&lt;/h2&gt;&lt;p&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Kubernetes pod 一時停止</title>
        <link>https://ttf248.life/ja/p/kubernetes-pause-pod/</link>
        <pubDate>Mon, 12 Jul 2021 11:23:09 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/kubernetes-pause-pod/</guid>
        <description>&lt;p&gt;デプロイメントコントローラーは、Kubernetesクラスタにおける非常に重要な機能、Podの水平的な拡張と縮小を実現します。この機能は、現代クラウドプラットフォームに不可欠なものです。&lt;/p&gt;
&lt;p&gt;ビジネスシーンで、データベース内のデータを修正し、調整後にPodノードを再起動する必要がある。しかし、Podの実行中にテーブルのフィールドを継続的に変更しており、一時的にアプリケーションへのテーブル更新を停止し、データ調整後Podを復旧させる必要がある。&lt;/p&gt;
&lt;p&gt;暴力的な削除Deployment以外に、同様の停止効果を実現する方法はありますか？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl scale --replicas=0 deployment/&amp;lt;your-deployment&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答えを見て初めて、多くの人は思いもよらなかっただろう。答えを見たとき、苦笑いをしてしまう。思考はまだプロセスを直接操作する時代に留まっていて、ビジネスプロセスを直接操作しようとするのだ。&lt;/p&gt;
&lt;h2 id=&#34;参照リンク&#34;&gt;参照リンク
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/54821044/how-to-stop-pause-a-pod-in-kubernetes&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;how to stop/pause a pod in kubernetes&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>Dockerに関するいくつかのこと</title>
        <link>https://ttf248.life/ja/p/docker-two-three-things/</link>
        <pubDate>Thu, 21 Jan 2021 09:26:07 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/docker-two-three-things/</guid>
        <description>&lt;p&gt;長年業務で接したのが、一部内容が適用できない__操作系统，如果是E_CODE_0ユーザーばかりです。&lt;/p&gt;
&lt;p&gt;設置部分は、清華大学の手册を参照してください：&lt;a class=&#34;link&#34; href=&#34;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;設置&#34;&gt;設置
&lt;/h2&gt;&lt;p&gt;不明な力により、国内にDockerをインストールする際は、クラウドプロバイダーが提供するリポジトリを使用することを推奨します。ここでは、&lt;strong&gt;阿里云&lt;/strong&gt; を推奨します。&lt;/p&gt;
&lt;h3 id=&#34;倉庫ソースアドレス設定&#34;&gt;倉庫ソースアドレス設定
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install yum-utils device-mapper-persistent-data lvm2 &amp;amp;&amp;amp; \
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;最新バージョン&#34;&gt;最新バージョン
&lt;/h3&gt;&lt;p&gt;Dockerはよく使用されるバックグラウンドサービスなので、起動時に自動的に開始するように設定することを推奨します。このコマンドはCentOS 7に適用されます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum install -y docker-ce docker-ce-cli containerd.io &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;部署指定バージョン&#34;&gt;部署指定バージョン
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;斜体_9&lt;/strong&gt;&lt;strong&gt;太字_5&lt;/strong&gt;&lt;strong&gt;斜体_10&lt;/strong&gt;&lt;strong&gt;太字_6&lt;/strong&gt;&lt;strong&gt;斜体_11&lt;/strong&gt;&lt;strong&gt;太字_7&lt;/strong&gt;&lt;strong&gt;斜体_12&lt;/strong&gt;&lt;strong&gt;太字_8&lt;/strong&gt;&lt;strong&gt;斜体_13&lt;/strong&gt;**&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum list docker-ce --showduplicates | sort -r
sudo yum install -y docker-ce-18.09.2-3.el7 docker-ce-cli-18.09.2-3.el7 containerd.io-18.09.2-3.el7 &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;通常ユーザーへのdocker権限追加&#34;&gt;通常ユーザーへのDocker権限追加
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo usermod -aG docker ${USER}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;アンインストール&#34;&gt;アンインストール
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum erase -y docker-ce docker-ce-cli containerd.io
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;日常利用&#34;&gt;日常利用
&lt;/h2&gt;&lt;h3 id=&#34;ミラーキャッシュ&#34;&gt;ミラーキャッシュ
&lt;/h3&gt;&lt;p&gt;依然未知な神秘的な力が存在し、イメージのダウンロード速度が遅いという問題がある。この状況下で、国内のクラウドベンダーが多くの加速サービスを提供してきたため、引き続き&lt;strong&gt;阿里云&lt;/strong&gt;をおすすめする。&lt;/p&gt;
&lt;p&gt;加速されたアドレスは、ご自身でアカウントを登録してAliyunから入手してください。このサービスは無料で、Aliyunは無料のイメージ構築サービスも提供しています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt; /etc/docker/daemon.json &amp;lt;&amp;lt;EOF
{
  &amp;quot;registry-mirrors&amp;quot;: [
    &amp;quot;https://docker.nju.edu.cn&amp;quot;,
    &amp;quot;https://mirror.baidubce.com&amp;quot;,
    &amp;quot;https://docker.m.daocloud.io&amp;quot;,
    &amp;quot;https://docker.mirrors.sjtug.sjtu.edu.cn&amp;quot;
  ]
}
EOF
systemctl daemon-reload &amp;amp;&amp;amp; \
systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;強く推奨のコントロールパネル&#34;&gt;強く推奨のコントロールパネル
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker volume create portainer_data &amp;amp;&amp;amp; \
docker run -d --name=portainer --restart=always -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:2.20.3-alpine
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;よく使うイメージプルコレクション&#34;&gt;よく使うイメージプルコレクション
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker pull rancher/rancher:stable &amp;amp;&amp;amp; docker pull  portainer/portainer-ce:2.0.1 &amp;amp;&amp;amp; \
docker pull centos:7 &amp;amp;&amp;amp; docker pull ubuntu:20.04 &amp;amp;&amp;amp; docker pull ubuntu:18.04 &amp;amp;&amp;amp; \
docker pull redis:5 &amp;amp;&amp;amp; docker pull redis:6 &amp;amp;&amp;amp; \
docker pull alpine:3.11 &amp;amp;&amp;amp; docker pull busybox:1.32 &amp;amp;&amp;amp; \
docker pull rabbitmq:3.7-management &amp;amp;&amp;amp; \
docker pull mariadb:10.2 &amp;amp;&amp;amp; \
docker pull nginx:1.18 &amp;amp;&amp;amp; docker pull nginx:1.19 &amp;amp;&amp;amp; \
docker pull mysql:5.6 &amp;amp;&amp;amp; docker pull mysql:8 &amp;amp;&amp;amp; \
docker pull elasticsearch:6.8.11 &amp;amp;&amp;amp; docker pull logstash:6.8.11 &amp;amp;&amp;amp; docker pull kibana:6.8.11 &amp;amp;&amp;amp; \
docker pull zookeeper:3.4 &amp;amp;&amp;amp; \
docker pull influxdb:1.7 &amp;amp;&amp;amp; docker pull grafana/grafana:7.3.1 &amp;amp;&amp;amp; \
docker pull percona:8 &amp;amp;&amp;amp; docker pull percona:5.6 &amp;amp;&amp;amp; \
docker pull cloverzrg/frps-docker:0.34.3 &amp;amp;&amp;amp; docker pull cloverzrg/frpc-docker:0.34.3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;よく使うコマンドの組み合わせ&#34;&gt;よく使うコマンドの組み合わせ
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/engine/reference/commandline/docker/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.docker.com/engine/reference/commandline/docker/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;コンテナの実行状態を確認し、__INLINE_CODE_0__パラメータを追加して詳細なコンテナ情報を確認します。この際、イメージ情報は無視します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker ps --format &amp;quot;{{.Names}}: {{.Ports}}: {{.Size}}&amp;quot;
#portainer: 0.0.0.0:8000-&amp;gt;8000/tcp, 0.0.0.0:9000-&amp;gt;9000/tcp: 0B (virtual 172MB)
#influxdb: 0.0.0.0:8086-&amp;gt;8086/tcp: 183B (virtual 311MB)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;全コンテナを停止&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker stop $(docker ps -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全イメージを一括削除&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dokcer rmi $(docker images -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;イメージエクスポート&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; &amp;gt; -o XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;イメージのエクスポートと圧縮&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; | gzip &amp;gt; XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;イメージのインポート&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker load -i XXX.tar
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Linux上にJMeterテスト環境を構築する</title>
        <link>https://ttf248.life/ja/p/linux-setup-jmeter-testing-environment/</link>
        <pubDate>Tue, 22 Dec 2020 10:12:50 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-setup-jmeter-testing-environment/</guid>
        <description>&lt;p&gt;著者はハードウェアに強い興味を持ち、Jmeterを用いて負荷テストを実施。CentOS 7上にJmeter、InfluxDB、Grafanaをデプロイした過程を記録。Jmeterのインストールとコマンド使用方法、InfluxDBの特徴とDockerインストール方法、そしてGrafanaの簡単なデプロイと設定について解説。高性能プログラムのパターンに関する経験と参考文献もまとめた。&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景
&lt;/h2&gt;&lt;p&gt;データ表示に加えて、Webパネルを別途用意するメリットは何か？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;考えたことが全て思い込みで、試してみないと分からない。
Don&amp;rsquo;t use GUI mode for load testing! only for Test creation and Test debuggin.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;公式的にはコマンドラインでレポートを取得し、GUIで表示する方法にはデータの誤差があるとのことです。JMeterの理解は深くないですが、せめてバージョン__INLINE_CODE_0__のコンソールパネルを試してみる理由が少なくとも見つかりました。&lt;/p&gt;
&lt;p&gt;オープンソース中国の投稿ですが、主要コンポーネントのデプロイは友好的ではありません。必要なファイルも公众号でフォローしないとダウンロードできないため、次世代として当然__INLIN_ITALIC_1____に置き換えました。結局のところ、自分のサーバーが国内にあること、クロスボーダーのソースアドレスへのアクセス速度が遅いことが問題です。少なくともミラーサービスは、アリババクラウドに無料のアクセラレーションがあります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker&lt;/code&gt;のインストールについては、ここでは詳述しません。以前の記事を参照してください。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;今後の内容は大きく分けて、基本的なテスト環境構築と、各コンポーネントの簡単な説明です。&lt;/p&gt;
&lt;h2 id=&#34;jmeter&#34;&gt;Jmeter
&lt;/h2&gt;&lt;p&gt;Apache JMeterは、Apache Software Foundationが開発したJavaベースの負荷テストツールです。ソフトウェアに負荷をかけるために使用され、当初はWebアプリケーションのテスト用に設計されましたが、その後他のテスト分野にも拡張されています。静的なリソースや動的なリソースなど、さまざまなものをテストできます。例えば、静的ファイル、Javaマイクロサービス、CGIスクリプト、Javaオブジェクト、データベース、FTPサーバーなどです。JMeterを使用すると、サーバー、ネットワーク、またはオブジェクトに巨大な負荷をシミュレートし、さまざまなプレッシャーカテゴリー下での強度をテストし、全体的なパフォーマンスを分析できます。また、アサーションを含むスクリプトを作成することで、アプリケーションの機能/回帰テストを行い、プログラムが期待される結果を返すことを検証できます。最大限の柔軟性を実現するため、JMeterは正規表現を使用してアサーションを作成できます。&lt;/p&gt;
&lt;p&gt;Apache JMeterは、静的なリソースと動的なリソース（ファイル、サーブレット、Perlスクリプト、Javaオブジェクト、データベースおよびクエリ、FTPサーバーなど）のパフォーマンスをテストするために使用できます。サーバー、ネットワーク、またはオブジェクトに過剰な負荷をかけて強度をテストしたり、さまざまなプレッシャーの種類下での全体的なパフォーマンスを分析したりすることができます。パフォーマンスのグラフ解析や、高並行負荷テストを行うことも可能です。&lt;/p&gt;
&lt;h3 id=&#34;jmeter-centos7&#34;&gt;JMeter CentOS7
&lt;/h3&gt;&lt;p&gt;インストールパッケージ&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install java-1.8.0-openjdk -y &amp;amp;&amp;amp; \
wget https://mirrors.bfsu.edu.cn/apache//jmeter/binaries/apache-jmeter-5.4.tgz &amp;amp;&amp;amp; tar -xf apache-jmeter-5.4.tgz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;環境変数を設定する&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export JMETER_HOME=$HOME/jmeter/apache-jmeter-5.4
export PATH=$JMETER_HOME/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;jmeter-コマンド&#34;&gt;JMeter コマンド
&lt;/h3&gt;&lt;p&gt;最終、&lt;code&gt;Grafana&lt;/code&gt;控制面板，可以不输入&lt;code&gt;-l&lt;/code&gt;参数，在__INLINE_CODE_2__コントロール台のデータを確認&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;jmeter -n -t /tmp/order-500-10s.jmx -l /tmp/jmeter-order-report-20200109/order-500-10s.jtl
# 一般不用测试结果和测试报告，简化命令
jmeter -n -t /tmp/order-500-10s.jmx
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;influxdb&#34;&gt;InfluxDB
&lt;/h2&gt;&lt;p&gt;InfluxDBは、外部依存なしでGo言語で記述されたオープンソースの分散型時系列データベースです。現在では、主にDevOpsモニタリングデータ、アプリMetrics、IoTセンサーデータ、リアルタイム解析データなど、大量のタイムスタンプデータを保存するために使用されています。&lt;/p&gt;
&lt;h3 id=&#34;influxdbの特徴&#34;&gt;InfluxDBの特徴
&lt;/h3&gt;&lt;p&gt;InfluxDBの特徴は、以下の9点に集約できます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;構造（パターン）なし：任意の数の列が可能です。&lt;/li&gt;
&lt;li&gt;メトリクスの保存期間を設定できます。&lt;/li&gt;
&lt;li&gt;統計を支援するため、時間に関連する関数（最小値、最大値、合計、件数、平均、中央値など）に対応。&lt;/li&gt;
&lt;li&gt;サポートするストレージポリシー：データの削除・変更に利用可能。（InfluxDBはデータ削除・変更の方法を提供していません。）&lt;/li&gt;
&lt;li&gt;継続クエリのサポート：データベース内で自動的にスケジュールされた一連の文であり、ストレージポリシーと組み合わせることでInfluxDBのシステムリソース使用量を削減できます。&lt;/li&gt;
&lt;li&gt;ネイティブなHTTPサポート、内蔵HTTP API。&lt;/li&gt;
&lt;li&gt;SQLに類似した構文をサポート。&lt;/li&gt;
&lt;li&gt;クラスタ内のデータレプリカ数を設定可能。&lt;/li&gt;
&lt;li&gt;定期サンプリングデータをサポートし、別のmeasurementに書き込むことで、細分化されたデータストレージを可能にする。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;influxdb-docker-インストール&#34;&gt;InfluxDB Docker インストール
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir influxdb &amp;amp;&amp;amp; cd influxdb &amp;amp;&amp;amp; \
docker run -p 8086:8086 -d --name influxdb -v $PWD:/var/lib/influxdb influxdb:1.7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;コンテナに入り、コマンドを実行し、手動でデータベースを作成する。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;root@bce0a55bbc72:/# influx
Connected to http://localhost:8086 version 1.7.10
InfluxDB shell version: 1.7.10
&amp;gt; 交互面板执行命令
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;influxdb-データベースとユーザーの作成&#34;&gt;InfluxDB データベースとユーザーの作成
&lt;/h3&gt;&lt;p&gt;データベース作成：create database jmeter_t2
データベース表示：
データベースを切り替えます：use jmeter_t2
ユーザーを作成：パスワード&amp;rsquo;admin&amp;rsquo;でユーザー&amp;quot;admin&amp;quot;を全権限で作成
ユーザー表示&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; show users
user  admin
----  -----
admin true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ユーザー権限が表示されれば、データベースの準備は完了です。&lt;/p&gt;
&lt;h2 id=&#34;grafana&#34;&gt;Grafana
&lt;/h2&gt;&lt;p&gt;テストケース作成中に、グラフ表示はそれほど必須ではないことがわかった。インターフェースの__INLINE_CODE_0__データはコマンドライン実行で確認できるし、主にプログラム内部の処理時間を把握したいだけだ。&lt;/p&gt;
&lt;p&gt;簡単な展開&lt;/p&gt;
&lt;p&gt;コンソールはタグによるテスト結果のフィルタリングをサポートしており、通常は &lt;code&gt;InfluxDB&lt;/code&gt;データベースの設定だけで済みます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アプリケーション名&lt;/li&gt;
&lt;li&gt;テストケース名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/linux-setup-jmeter-testing-environment/Snipaste_2021-03-09_19-44-22.png&#34;
	width=&#34;861&#34;
	height=&#34;357&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;grafana&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;241&#34;
		data-flex-basis=&#34;578px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -d --name=grafana -p 3000:3000 grafana/grafana:7.3.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ウェブ版では、サンプラー間隔により計算の**&lt;em&gt;強調&lt;/em&gt;** &lt;strong&gt;太字&lt;/strong&gt; &lt;em&gt;斜体&lt;/em&gt; &lt;strong&gt;リンク&lt;/strong&gt; が発生します。&lt;/p&gt;
&lt;p&gt;資料には、__INLINE_CODE_0__をカスタマイズする方法も記載されています。&lt;/p&gt;
&lt;h2 id=&#34;追記&#34;&gt;追記
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;高性能なプログラムパターンは必ずしもone loop threadであり、ロック、キューへの入出力は不要なパフォーマンス損失を引き起こす。&lt;/li&gt;
&lt;li&gt;コアビジネスロジックの処理時間が、他のコードの導入にかかる時間よりも長い。効率を効果的に高めるには並行処理が不可欠であり、コア処理時間が十分短い場合にのみ、他のコードの導入は慎重に行うべきである。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@jasonli.studio/to-install-apache-jmeter-in-centos7-294bc72a97ba&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;To install Apache JMeter in CentOS7&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Red Hat と CentOS のライフサイクル</title>
        <link>https://ttf248.life/ja/p/redhat-centos-lifecycle/</link>
        <pubDate>Tue, 21 Jul 2020 20:02:35 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/redhat-centos-lifecycle/</guid>
        <description>&lt;p&gt;オンライン生産環境のオペレーティングシステムとしては、Red HatとCentOSが主流です。両システムのライフサイクルに関する公式ウェブサイトへのリンクを記録し、CentOS 8からCentOS 8 Streamへの移行経験を共有しています。&lt;/p&gt;
&lt;h2 id=&#34;まえがき&#34;&gt;まえがき
&lt;/h2&gt;&lt;p&gt;オンライン生産環境のオペレーティングシステムとして、現在国内ではRed HatとCentOSが主流です。数年前にはRed Hat 6のサポート終了がありましたが、この2つのシステムのライフサイクルに関する公式サイトへのリンクを記録しておきます。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://access.redhat.com/support/policy/updates/errata&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Red Hat Enterprise Linux Life Cycle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Red Hat Enterprise Linux（RHEL）とCentOSは、エンタープライズサーバーオペレーティングシステムの主要な選択肢です。RHELは安定したサポートとアップデートサイクルを提供し、企業向けアプリケーションに適しています。CentOSはRHELのコミュニティ版であり、同様の機能と安定性を提供しますが、公式サポートはありません。&lt;/p&gt;
&lt;h2 id=&#34;追い続き&#34;&gt;追い続き
&lt;/h2&gt;&lt;p&gt;この記事を公開した時、2年後にアップデートすることになるとは思ってもみませんでした。先日、普段使っている仮想マシンをCentOS 8からCentOS 8 Streamにアップグレードしました。本番環境での選択については言及を控えたいのですが、ローカル環境では最新バージョンを追求しています。&lt;/p&gt;
&lt;p&gt;CentOS 8 Streamは、ローリングリリース版であり、従来のCentOSよりも速いアップデートと新機能を提供するため、開発およびテスト環境に適しています。&lt;/p&gt;</description>
        </item>
        <item>
        <title>パソコンの組み立てあれこれ</title>
        <link>https://ttf248.life/ja/p/computer-assembly-tips/</link>
        <pubDate>Sat, 18 Jul 2020 14:33:46 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/computer-assembly-tips/</guid>
        <description>&lt;p&gt;著者は幼い頃からパソコンの組み立てに興味を持ち、大学以降はハードウェアの組み立てに触れるようになった。ハードウェア性能比較サイトや購入のアドバイス（CPU、SSD、HDD、メモリ周波数など）を紹介し、ハードウェア選びの経験と注意点を共有している。&lt;/p&gt;
&lt;h3 id=&#34;ご縁言葉では言い表せない&#34;&gt;ご縁、言葉では言い表せない。
&lt;/h3&gt;&lt;p&gt;幼い頃から自分のパソコンを組み立てることを考えていたのだが、経済的な状況が許さなかった。なんとか大学に進学できたものの、持ち運びの都合上、ノートパソコンを選んだ。具体的にいつからパソコンを組み立てたいと思ったのかという話をするなら、実家近くの図書館に遡ることになるだろう。それは市内の図書館であり、電子閲覧室（実際に利用したことはないが、時間課金制らしい）だけでなく、雑誌閲覧室もあった。そこで《大众软件》、《电脑报》といった雑誌をめくったことがきっかけだ。パソコンにほとんど触れる機会がなかった私にとって、それはまさに神のような科普資料だった。ダンジョン攻略の章を見ると、自分もパソコンを手に入れてモンスを集め、主力アタッカーになりたいと思った。そして、ブラックテクノロジーを見かけると、本の手順を真似すれば、説明されている効果を実現できるのではないかという夢を見た（ハックツールの使用について）。高校の授業は忙しかったが、当時の私の知識では、勉強も遊びも両立したいと思っていた。そのため、「天真爛漫」な日々を送っていた私にとって、図書館に行く口実で、小さなバッグを持ってそちらへ向かうことが多かった。市内の規模は大きくないため、ほとんど歩いて行った。着くとエアコンの効いた空間で、小説や漫画、ゲーム雑誌を見たり、時々真面目な本を読んだりしていた。&lt;/p&gt;
&lt;p&gt;年を取ると忘れっぽくなるのはよくあることですが、図書館での出来事も初めてではありません。中学の頃、親戚の家でパソコンを組み立てたことがありますが、なぜあの時その機械を組み立てたのか思い出せません。OSはWindows 2003で、ゲームはシステム自带のトランプとエイジオブエンパイアがありました。色々な「策略」を考えて、堂弟と一緒にゲームをするために鍵を盗もうとしていました。&lt;/p&gt;
&lt;p&gt;中学に入学するとすぐに、学校でコンピュータの初級トレーニングがあり、転校後も少しコンピュータコンテストの概念に触れた。高校ではNOIPにも参加したことがある。ここで言及せざるを得ないのは、校友会の力だ。高校のコンピュータ棟は校友からの寄付で作られ、コンピュータ教室と図書館を併設している。当時も国内のインターネット黎明期だった。学校のリーダーたちもコンピュータコンテストへの参加を支援しており、実際、前2回の先輩たちがコンピュータを通じて重点大学に特待生として進学している例もあった。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;今までこんな風に自分のこととパソコンを振り返ったことがなかった。卒業後に自動化専攻からコンピュータ業界へ、迷いなく転身したのも無理はない。種はもう植えられていたのだ、ただ周りの人は知らないだけだろう。小さい頃から触れていたせいか、自分はものすごいと思ってたけど、実際は表面しか理解していなかった。最大の強みは、最初の熱意だった。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;ハードウェア組み立て&#34;&gt;ハードウェア組み立て
&lt;/h3&gt;&lt;p&gt;カードラボ、Chiphell、知乎のPC組み立てスレッドを色々見て回ると、初心者でも比較的簡単に必要なパーツリストを作成できます。2019年以降にCPUを選ぶ場合、経済状況があまり良くない場合は、より高いパフォーマンスを求めるならAMDがおすすめです。&lt;/p&gt;
&lt;p&gt;よく使われるハードウェア性能比較サイト：&lt;a class=&#34;link&#34; href=&#34;https://cpu.userbenchmark.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cpu.userbenchmark.com/&lt;/a&gt; 。価格はメルカリの米国版と比較できます。本気の方ならメルカリで中古を探すとかなり安く手に入りますが、あまり詳しくない方は避けた方が良いです。私もメルカリで購入したメモリが偽物でした。現時点では問題なく使用できていますが、型番やスペックが全く合っていないので、あまり確信がありません。&lt;/p&gt;
&lt;h4 id=&#34;sn550-vs-sn750&#34;&gt;SN550 VS SN750
&lt;/h4&gt;&lt;p&gt;SN550 1TBとSN750 1TBの違いは、持続的な読み書き速度が倍違うことくらいで、それぞれ850MBと1.6GBです。しかし日常使いでは違いを感じないでしょう。なぜなら4Kの性能はどちらも同じだからです。ただしこれは1TBモデルのSN550の話で、500Gや250Gだと順次読み書き速度はさらに遅くなります。正直、お金を気にしないのでなければ、日常使いであればSN550で十分だと思います。私が買わなかった最大の理由は、順次読み書き速度ではなく、SN550が最大1TB容量しかなくて、SN750は2TBあるからです。私にとって、追加購入なしに利用できるマザーボードのM.2 Nvmeスロットの方が、これらのSSDの価格差よりも価値があると感じます。&lt;/p&gt;
&lt;p&gt;ネットユーザーの意見を総合すると、変換アダプタを購入すれば、B150マザーボードでもM.2インターフェースに対応したSSDが利用できる。&lt;/p&gt;
&lt;h4 id=&#34;機械式ハードディスクの選び方&#34;&gt;機械式ハードディスクの選び方
&lt;/h4&gt;&lt;p&gt;機械式ハードディスクは現在価格が安定しており、大容量のストレージが必要なユーザーには、適切なものを選ぶ必要があります。頻繁にデータやリソースをダウンロードするユーザーには、エンタープライズ向けのものがおすすめです。よくあるものとしては：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;西数字金庫&lt;/li&gt;
&lt;li&gt;キオクシス&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/p&gt;
&lt;p&gt;キージェシリーズ&lt;/p&gt;
&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;%e5%b8%8c%e6%8d%b7exos1.png&#34; &gt;希捷企业级硬盘概述&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;%e5%b8%8c%e6%8d%b7exos2.png&#34; &gt;希捷企业级硬盘概述&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;メモリクロック&#34;&gt;メモリクロック
&lt;/h4&gt;&lt;p&gt;日常業務の観点からは、頻度はパフォーマンスに大きな影響を与えないでしょう。&lt;/p&gt;
&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;%e5%86%85%e5%ad%98.png&#34; &gt;内存时序&lt;/a&gt;太字_2&lt;a class=&#34;link&#34; href=&#34;%e5%92%b8%e9%b1%bc%e5%86%85%e5%ad%98.png&#34; &gt;咸鱼内存&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;メモリタイミング（英語：Memory timingsまたはRAM timings）は、同期動的メモリアクセスストレージ（SDRAM）のパフォーマンスを記述する4つのパラメータ：CL、TRCD、TRP、TRASです。単位はクロックサイクルで、通常は7-8-8-24のようにハイフンで区切られた4つの数字で表記されます。第4パラメータ（RAS）は省略されることが多く、場合によっては第5パラメータであるコマンドレート（通常は2Tまたは1T、2N、1Nとも表記）が追加されます。これらのパラメータは、ランダムアクセスメモリの速度に影響を与えるレイテンシ（遅延時間）を指定します。数値が小さいほど、一般的にパフォーマンスは向上します。システムパフォーマンスを決定する最終的な要素は、実際のレイテンシであり、通常ナノ秒で表されます。&lt;/p&gt;
&lt;p&gt;メモリタイミングを実際の遅延に変換する際、最も重要なことは、それがクロックサイクル単位で表されていることに注意することです。クロックサイクルの時間を把握していない場合、一連の数値が別の数値よりも高速であるかどうかを判断することはできません。&lt;/p&gt;
&lt;p&gt;例えば、DDR3-2000メモリのクロック周波数は1000MHzで、その周期は1nsです。この1nsの周期に基づき、CL=7の場合、絶対遅延は7nsとなります。一方、より高速なDDR3-2666（クロック1333MHz、サイクルごとに0.75ns）では、CL=9を使用することがありますが、それでも絶対遅延は6.75nsと短くなります。&lt;/p&gt;
&lt;p&gt;現代のDIMMには、シリアルプレゼンス検出（SPD）ROMチップが搭載されており、自動構成に推奨されるメモリタイミング情報が含まれています。PCのBIOSでは、ユーザーがタイミングを調整してパフォーマンスを向上させること（安定性が低下するリスクがある）、または特定の状況下で安定性を高めること（推奨タイミングを使用する場合など）が可能です。&lt;/p&gt;
&lt;p&gt;注意：メモリの帯域幅はメモリのスループットを測定するものですが、通常はレイテンシではなく転送速度によって制限されます。SDRAM の複数の内部バンクに交錯アクセスすることで、ピークレートで連続的なデータ転送が可能になります。帯域幅を増やすために、レイテンシを増加させる場合があります。具体的には、新しい世代の DDR メモリは高い転送速度を実現するものの、絶対遅延は大きく変化せず、特に最初の製品群では、前の世代よりも遅延が長くなる傾向があります。&lt;/p&gt;
&lt;p&gt;メモリのレイテンシーを増やしても、メモリ帯域幅を増やすことで、マルチプロセッサまたは複数の実行スレッドを持つコンピュータシステムのパフォーマンスが向上する。より高い帯域幅は、専用ビデオメモリを持たない統合グラフィックスカードのパフォーマンスも向上させる。&lt;/p&gt;
&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;%e5%86%85%e5%ad%98%e6%97%b6%e5%ba%8f%e5%8f%82%e6%95%b0%e8%af%b4%e6%98%8e.png&#34; &gt;内存时序参数说明&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>ウェブサイトの高速化とドメイン設定</title>
        <link>https://ttf248.life/ja/p/website-acceleration-and-domain-setup/</link>
        <pubDate>Sat, 20 Jun 2020 10:36:27 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/website-acceleration-and-domain-setup/</guid>
        <description>&lt;p&gt;国内でのアクセスが遅いため、著者は個人ドメインを取得し、国内クラウドプロバイダーのCDNアクセラレーションサービスを購入しました。設定中にwwwサブドメインにアクセスできない問題が発生しましたが、汎用ドメイン解析を削除し、セカンダリドメインを個別に設定することで解決しました。また、CDNアクセラレーションの原理と設定経験、Nginxのリバースプロキシ試行とその教訓についても共有しています。&lt;/p&gt;
&lt;h3 id=&#34;背景&#34;&gt;背景
&lt;/h3&gt;&lt;p&gt;GitHub Pagesにサイトをホストしているため、周知の理由により国内からのアクセスが遅いことがあります。そこで、個人ドメインを取得し、国内クラウドプロバイダーのCDN加速サービスを利用しました。加速サービスの設定中に、開発マシンにあるDocker、frp、k8sなどのサービス（それぞれダッシュボードあり）を思い出し、無駄にしない方針でいくつかのリバースプロキシを設定し、すべてセカンダリードメインに紐づけました。&lt;/p&gt;
&lt;p&gt;二級ドメインを使っていると、突然wwwサブドメインにアクセスできなくなりました。アリババクラウドでは、www.xiangtianlong.comとxiangtianlong.comの両方をDNSで同時に解析するように設定しており、CDN加速を有効にする前は両方のドメインが正常に使用できていました。&lt;/p&gt;
&lt;p&gt;CDN設定時、セカンダリドメインが多いため汎用ドメインルールを有効にし、統一的に開発マシンへルーティングした結果、wwwというセカンダリドメインも影響を受けてしまいました。はい、間違いではありません。wwwプレフィックスもセカンダリドメインとして扱われていました。実際のウェブサイトはGitHub Pagesにデプロイされており、開発マシンにはウェブサイトのキャッシュ情報は一切ありません。&lt;/p&gt;
&lt;p&gt;開発環境にサイトをデプロイしないのは、静的ブログで、GitHub Actionsを使えば自動的にリリースできるので便利だからです。&lt;/p&gt;
&lt;h3 id=&#34;ドメイン&#34;&gt;ドメイン
&lt;/h3&gt;&lt;p&gt;専門性のないウェブ開発では、ドメインの理解にSEOやクロスドメインの問題は含まれない。ブログサイトとして、ベアドメインはブログオーナーのサイトを際立たせやすく、現在のモバイルアクセスが多いことも考慮すると、入力できる文字数を減らせるという利点がある。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;パソコンで、wwwとcomの入力を省略できるショートカットキーが利用可能です。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;cdn&#34;&gt;CDN
&lt;/h3&gt;&lt;p&gt;アリババクラウドとテンセントクラウドの両方使ったことがあるので、初心者でも使いやすいです。テンセントクラウドには関連コンセプトを解説する動画もあります。CDNの加速原理は京東（JD）の倉庫と同じで、新商品を発売する際に、全国各地の倉庫に事前に一斉配送し、配送リクエストが発生した際、最寄りの倉庫から発送します。&lt;/p&gt;
&lt;p&gt;元のURL：ウェブサイトリソースが元々保存されていたアドレス&lt;/p&gt;
&lt;p&gt;キャッシュファイル設定、ブラウザF12、管理コンソール、静的リソースと動的リソースの簡単な分析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全件0日有効&lt;/li&gt;
&lt;li&gt;無効期限：0日&lt;/li&gt;
&lt;li&gt;有効期限１日&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;テンセントクラウド設定ルール：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;キャッシュ切れルールは最大で10条まで設定可能です。&lt;/li&gt;
&lt;li&gt;下位優先ルールが適用されます。&lt;/li&gt;
&lt;li&gt;キャッシュの有効期限は最大365日まで設定可能です。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;痛ましい告白&#34;&gt;痛ましい告白
&lt;/h3&gt;&lt;p&gt;以前Nginxを使ったことがなかったので、ウェブサイトを検索すればリバースプロキシの設定がわかると思っていました。しかし、結果は混乱し、半日かけても302リダイレクトを理解できませんでした。結局、効果はありませんでした。そこで、思い切ってDNS解析のワイルドカード設定を削除し、個々のセカンドレベルドメインを独立して設定しました。その時、突然、阿里云DNS解析に「表示URL転送」というモードがあることに気づき、試してみたところ、これがまさに求めていた302リダイレクトでした。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最初の二階建てドメインは問題なくアクセスできたのに、2つ目の設定をしたら動かず、本当にどうしようかと思ったけど、しばらく待ったら使えるようになった。やはり、アリババクラウドのDNS伝播は時々、おっかないことがあるようだ。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>ブログ環境とつぶやき</title>
        <link>https://ttf248.life/ja/p/blog-ide-environment-and-ramblings/</link>
        <pubDate>Tue, 31 Mar 2020 13:54:27 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/blog-ide-environment-and-ramblings/</guid>
        <description>&lt;p&gt;この記事では、Markdown の基本的な概念と様々なソフトウェアでの応用について解説し、VSCode を IDE として推奨しています。また、推奨プラグインの一覧も示しています。著者は Hexo から Hugo への移行経験を共有し、Hugo の柔軟性とカスタマイズ能力を強調しています。最後に、新しい技術の迅速な立ち上げのためのヒントと、Hugo テーマのスタイルが更新されない問題に対する解決策を紹介しています。&lt;/p&gt;
&lt;h2 id=&#34;まえがき&#34;&gt;まえがき
&lt;/h2&gt;&lt;h3 id=&#34;markdown&#34;&gt;Markdown
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;軽量なマークアップ言語で、人々が読みやすく書きやすいプレーンテキスト形式でドキュメントを作成できます。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;詳細なMarkdown文法については、このテキストでは触れません。電子書籍をおすすめします。&lt;a class=&#34;link&#34; href=&#34;https://markdown-zh.readthedocs.io/en/latest/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;点击此处&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;多くのソフトウェアはすでにmdを記述方法としてサポートしています。csdnのブログシステムでは、md文法に対応したオンラインエディタがリリースされ、初めて使用する際にはmd文法の紹介記事が表示されます。筆者はまだ良いと思います。また、印象ノートは2018年にmdノートへの対応を追加し、クイックバーには様々なmdマークアップオプションがあり、普通の文章を編集するのとほぼ同じように使え、全体的に初心者にも使いやすいです。&lt;/p&gt;
&lt;h3 id=&#34;ide推奨&#34;&gt;IDE推奨
&lt;/h3&gt;&lt;p&gt;この記事を書いている時点ですでに2020年ですが、VSCodeなら当然ご存知でしょう。Git Pageでブログシステムを構築する発想を持つのは、やはり業界関係者ですから。以前はSublimeやAtomも良い選択肢でしたが、2年のオープンソースコミュニティの推進により、VSCodeは急速に発展し、初心者にとって最初の選択肢となりつつあります。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;マイクロソフトとオープンソースコミュニティの関係が対立状態から、順調に蜜月期に入った：オープンソースを積極的に活用。筆者が所属する企業もここ2年でJavaエコシステムを積極的に導入しており、言い換えれば、現在の国内におけるJavaの利用は非常に魅力的だ。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;vs-code-拡張機能-おすすめ&#34;&gt;VS Code 拡張機能 おすすめ
&lt;/h3&gt;&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;2020-03-31-14-07-17.png&#34; &gt;插件清单&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;プラグインにはそれぞれReadmeがあり、基本的な使い方や主要機能が紹介されています。一部のプラグイン作者は、動的な効果を示す画像も提供しています。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;、Hugoの画像プラグイン方式と連携すれば、画像を簡単に導入できます。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ショートカットキーを覚えていないので、VSCodeのショートカット管理メニューを開き、「md」を検索して何度か確認。プラグインの説明書をもう一度見直す。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;hugo&#34;&gt;hugo
&lt;/h2&gt;&lt;p&gt;筆者は、元々好奇心旺盛な性格で、じっとして文章を書くのが苦手なのです。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Hugoは、画像とMDファイルを個別のフォルダに配置することをサポートしています。&lt;/li&gt;
&lt;li&gt;学術的なテーマは、デザインにおいて様々な種類の記事スタイルに対応しています。&lt;/li&gt;
&lt;li&gt;様々な便利なカスタマイズ拡張&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;academic&#34;&gt;academic
&lt;/h2&gt;&lt;p&gt;公式サイトデフォルト&lt;strong&gt;太字&lt;/strong&gt;斜体、&lt;strong&gt;太字&lt;/strong&gt;斜体、&lt;strong&gt;太字&lt;/strong&gt;斜体。&lt;/p&gt;
&lt;p&gt;URLのパターンで、ナビゲーションバーをクリックすれば単一ページへのジャンプが可能で、トップページでのスクロールではない。これは完全に個人的な好みによるものだ。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;形式：随筆、講演、電子書籍&lt;/li&gt;
&lt;li&gt;柔軟性：全体スタイルをカスタマイズ、CSSスタイルのカスタマイズ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このテーマは中国語のサポートがまだ完全ではない。主に視覚的な面で、フォントサイズが中国語の読書習慣に合っていない。ただし、Hexoの開発者は中国人の方が多いため、Hugoより優れている点はそこにある。&lt;/p&gt;
&lt;p&gt;しかし、自分で要素を特定して修正するには、ブラウザの開発者ツールで要素の位置を特定し、変更する必要があるCSSスタイルシート名を知りたい場合、サイドバーの&lt;strong&gt;Insert Style Rule Below&lt;/strong&gt;をクリックすれば、ネストされたCSSでも簡単にノード名を取得できます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;li&gt;テーマに組み込まれた文法ハイライト設定、&lt;a class=&#34;link&#34; href=&#34;https://sourcethemes.com/academic/docs/writing-markdown-latex/#highlighting-options.&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;結びに&#34;&gt;結びに
&lt;/h2&gt;&lt;p&gt;また子供が文句言い出すわ。どうして最初から最後まで曖昧なことばかり言って、具体的なことは何も言わないの？&lt;/p&gt;
&lt;p&gt;これがあれば、十分です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公式マニュアル&lt;/li&gt;
&lt;li&gt;プラグインの説明&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新しい技術を早く習得するには、まず公式サイトのドキュメントを読むことをお勧めします。 一度で理解しようとしなくてもいいので、少なくとも概要を把握しておきましょう。 検索エンジンの結果は、最新バージョンと一致しない場合があり、誤解を招く可能性があります。 新しい書籍も同様です。まずは目次を見て、著者が何を説明しようとしているのかを理解しましょう。 時には序章を読むことで、海外の著作が中国語に翻訳された際、翻訳者の序文が書籍の本質的な内容を網羅していることがあります。&lt;/p&gt;
&lt;h2 id=&#34;サプライズ&#34;&gt;サプライズ
&lt;/h2&gt;&lt;p&gt;Hugo Academicのスタイルを変更しても、サイトに公開しても表示が変わりませんね。賢い人はすぐに気づくでしょう。ローカルブラウザのキャッシュをクリアすれば解決します。私も閃きました！F12の開発者モードで、__INLINE_CODE_0__BOLD_2&lt;code&gt;disable cache&lt;/code&gt;に切り替えてリフレッシュすればOKです！&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/blog-ide-environment-and-ramblings/2020-03-31-14-27-15.png&#34;
	width=&#34;399&#34;
	height=&#34;142&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;network&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;280&#34;
		data-flex-basis=&#34;674px&#34;
	
&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>自動統合システム切り替え</title>
        <link>https://ttf248.life/ja/p/auto-integration-system-switch/</link>
        <pubDate>Sun, 29 Mar 2020 02:11:33 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/auto-integration-system-switch/</guid>
        <description>&lt;p&gt;GitHub Actions を使用して、Hugo ブログを GitHub Pages と Gitee に自動デプロイします。&lt;/p&gt;
&lt;h4 id=&#34;背景説明&#34;&gt;背景説明
&lt;/h4&gt;&lt;p&gt;ブログを更新した昨日、Travisのサービスが利用できないことに気づきました。Travisのウェブページを確認すると、ソースコードの取得で処理が止まっており、ふとGitHubが以前発表したActionsサービスのことを思い出しました。&lt;/p&gt;
&lt;p&gt;その頃は色々用事ができそうだし、アクションを使うには申請が必要なので、今は正式にリリースされたばかりです。週末に時間があったら、新しいおもちゃを試してみるか？&lt;/p&gt;
&lt;p&gt;公式資料は各自ウェブサイトでご確認ください。本文ではこれ以上の転載はいたしません。以前Kubernetesをご利用の方は、actionのYAMLファイル設定がKubernetesに似ていると感じるかもしれません。&lt;/p&gt;
&lt;p&gt;中国語の入門チュートリアル、あるいは紹介資料についてですが、&lt;strong&gt;阮一峰的博客&lt;/strong&gt;を検索することをお勧めします。2つの記事があり、1つ目は基本的な文法解説で、2つ目は実際の事例です。&lt;/p&gt;
&lt;h4 id=&#34;正文&#34;&gt;正文
&lt;/h4&gt;&lt;p&gt;必要な知識点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;github secrets&lt;/li&gt;
&lt;li&gt;アクション文法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既存コンポーネントで主要なジョブを完遂し、コマンドによるpushで中国のGiteeに送信。コマンド部分は粗雑で、強制プッシュのみを使用しており、Travisを利用していた際のロジックを引き継いでいる。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;name: github pages and gitee pages

on:
  push:
    branches:
      - hugo

jobs:
  deploy:
    runs-on: ubuntu-18.04
    steps:
      - uses: actions/checkout@v2
        with:
          submodules: true

      - name: Setup Hugo
        uses: peaceiris/actions-hugo@v2
        with:
          hugo-version: &#39;latest&#39;
          extended: true

      - name: Build Github and Gitee ## 单个step只能写一个run命令
        run: hugo -b &amp;quot;https://www.xiangtianlong.com/&amp;quot; -d &amp;quot;github_public&amp;quot; &amp;amp;&amp;amp; hugo -b &amp;quot;https://www.xiangtianlong.com/&amp;quot; -d &amp;quot;gitee_public&amp;quot; &amp;amp;&amp;amp; ls

      - name: Deploy Github
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.BLOG_TOKEN }}
          publish_dir: ./github_public
          publish_branch: master
          cname: xiangtianlong.com

      - name: Deploy Gitee
        run: cd ./gitee_public &amp;amp;&amp;amp; git init &amp;amp;&amp;amp; git config user.name &amp;quot;TianlongXiang&amp;quot; &amp;amp;&amp;amp; git config user.email &amp;quot;tianlongxiang51@gmail.com&amp;quot; &amp;amp;&amp;amp; git add . &amp;amp;&amp;amp; git commit -m &amp;quot;Update TianlongXiang&#39;s Blog&amp;quot; &amp;amp;&amp;amp; git push --force &amp;quot;https://xiangtianlong:${{ secrets.GITEE_PASSWORD }}@gitee.com/xiangtianlong/xiangtianlong.git&amp;quot; master:master   
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;追記&#34;&gt;追記
&lt;/h4&gt;&lt;p&gt;公式ストアで提供されている機能を見ると、現在サポートされているプレイ方法は豊富です。Dockerイメージを構築すれば、Docker Hubのサービスに依存しなくなることもできます。&lt;/p&gt;
&lt;p&gt;Hugoのissueを確認したところ、GitHub ActionsでGit Pagesを自動デプロイする場合、最終的に公開されるウェブページはmasterブランチに必要です。他のブランチにデプロイすると、設定画面でGitHubがウェブページの構文エラーを警告します。&lt;/p&gt;
&lt;p&gt;実際は、Hugoのソースファイルがmasterブランチに置かれていたため、GitHubがjellyブログのソースコードとして検知し、チェックやビルドが通らなかったことが原因です。&lt;/p&gt;
&lt;p&gt;解決策も簡単、Hugoのソースファイルを別のブランチに置き、静的ファイルはmasterブランチで公開する。&lt;/p&gt;</description>
        </item>
        <item>
        <title>標準ライブラリコンテナのメモリ割り当て関数：allocator</title>
        <link>https://ttf248.life/ja/p/standard-library-container-memory-allocator/</link>
        <pubDate>Mon, 30 Dec 2019 13:26:19 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/standard-library-container-memory-allocator/</guid>
        <description>&lt;p&gt;カスタムアロケータは、パフォーマンスの向上、メモリ効率の改善、および頻繁な小規模メモリ割り当ての問題解決に役立ちます。&lt;/p&gt;
&lt;h4 id=&#34;前縁&#34;&gt;前縁
&lt;/h4&gt;&lt;p&gt;最近、ネットワークデータパケットの開発に携わり、頻繁な小さなメモリの割り当てと解放が必要になった。メモリプールを使用しようと考えたが、既存のメモリプールの調査でこれを発見した。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/cacay/MemoryPool&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/cacay/MemoryPool&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;インターフェースを見たときから、少し疑問に思っていた。このメモリプールの実装がなんだか奇妙だ。__INLINE_CODE_0__的实现逻辑，是在申请固定大小的内存空间。看过boost的内存池接口，提供的是一个模板，用的时候进行实例化。正巧这个库已经有文章进行过介绍，提到了__INLINE_CODE_1__という概念。&lt;/p&gt;
&lt;h4 id=&#34;wikihttpszhwikipediaorgwikie58886e9858de599a8_c2b2b&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_%28C%2B%2B%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wiki&lt;/a&gt;
&lt;/h4&gt;&lt;p&gt;C++プログラミングにおいて、アロケータ（allocator）はC++標準ライブラリの重要な構成要素です。コンテナ（container）と呼ばれる様々なデータ構造（例えば、リストや集合など）が定義されており、これらのコンテナには実行時にサイズを変更できるという共通の特徴があります。この実現のために動的なメモリ割り当てが必要となり、アロケータはそのメモリ割り当てと解放のリクエストを処理するために使用されます。つまり、アロケータはSTLコンテナのメモリ管理における低レベルの詳細をカプセル化するものです。デフォルトでは、C++標準ライブラリは独自の汎用アロケータを使用しますが、必要に応じてプログラマはカスタムアロケータを作成して置き換えることも可能です。&lt;/p&gt;
&lt;p&gt;アロケータは当初、アレクサンドル・ステパノフによってC++標準テンプレートライブラリ（STL）の一部として考案され、「ライブラリをより柔軟にし、基盤となるデータモデルに依存しない方法」を提供し、プログラマがカスタムのポインタや参照型を利用できるようにすることを目的としていました。しかし、C++標準に取り込む際、C++標準委員会は完全なデータモデル抽象化による容認できないパフォーマンス損失を認識し、その代替案としてアロケータに対する制限が厳しくなりました。その結果、現在の規格で記述されているアロケータのカスタマイズ性は、ステパノフの当初の構想に比べて大幅に制限されています。&lt;/p&gt;
&lt;p&gt;割り当て方のカスタマイズには制限があるものの、多くの状況でカスタムアロケータが必要となる場合があり、これは主に異なるメモリ空間（共有メモリやリサイクル済みメモリなど）へのアクセス方法をカプセル化するため、あるいはメモリプールを用いたメモリ割り当て時のパフォーマンス向上を目的として行われる。また、頻繁に少量メモリを割り当てるプログラムにおいては、専用のカスタムアロケータを導入することで、メモリ使用量と実行時間の両面で大きな恩恵が得られる場合がある。&lt;/p&gt;
&lt;h4 id=&#34;申し訳ありませんが翻訳する中国語のテキストが提供されていませんテキストを提供していただければ日本語に翻訳します&#34;&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。
&lt;/h4&gt;&lt;p&gt;カスタムアロケータを定義する主な理由の一つは、パフォーマンスの向上です。専用のカスタムアロケータを使用することで、プログラムのパフォーマンスを向上させたり、メモリ使用効率を高めたり、あるいはその両方を実現できます。[4][8] デフォルトのアロケータはnew演算子を使用してメモリ空間を割り当てますが、これはしばしばC言語のヒープ割り当て関数（malloc()）によって実装されます。[9] ヒープ割り当て関数は、大量のメモリを一度に割り当てる場合に最適化されていることが多いため、ベクトルや両端キューなどのメモリを大量に割り当てるコンテナでは、デフォルトのアロケータは一般的に効率的です。[8] しかし、連想コンテナや双方向リストなど、頻繁に少量ずつメモリを割り当てる必要があるコンテナの場合、デフォルトのアロケータを使用すると通常、効率が低下します。[4][9] さらに、malloc()ベースのデフォルトアロケータには、参照局所性の低さ[4]や、メモリ断片化を引き起こす可能性[4][9]などの問題も存在します。&lt;/p&gt;
&lt;p&gt;要するに、この部分（……）は、この規格がディスペンサーに対して行う「私には夢がある」のスピーチのようなものだ。夢が実現するまでは、可搬性を気遣うプログラマーは、ステートレスなカスタムアロケータの使用に縛られることになるだろう。
スコット・メイヤーズ『Effective STL』
この状況を鑑みると、頻繁な少量メモリ割り当ての問題を解決するために、メモリプールベースの割り当て器がよく用いられる[8]。デフォルトの「オンデマンド割り当て」とは異なり、メモリプールベースの割り当て器では、プログラムは事前に大きなメモリブロック（「メモリプール」）を確保し、メモリが必要な際には、カスタム割り当て器は単にプールのメモリへのポインタを要求者に返すだけです。オブジェクトの破棄時には、実際にメモリを解放する代わりに、メモリプールのライフサイクルが終了した時点でまとめて解放されます[注 1][8]。&lt;/p&gt;
&lt;p&gt;「カスタムアロケータ」という話題に関して、すでに多くのC++専門家や関連著者が議論に参加しており、例えばスコット・メイヤーズの『Effective STL』やアンドレイ・アレクサンドレスキューの『Modern C++ Design』にも言及されています。メイヤーズは、ある型Tに対するアロケータのすべてのインスタンスが等しいと要求する場合、可搬性のあるアロケータのインスタンスは状態を含んではならないことに気づきました。C++標準は、ライブラリの実装者がステートフルなアロケータをサポートすることを推奨していますが[文 4]、メイヤーズはこの関連箇所を「（一見）素晴らしい考え」と述べつつも、ほとんどナンセンスであり、アロケータの制限は「あまりにも厳しすぎる」[4]と批判しています。例えば、STLのlistはspliceメソッドを許可しており、これはlistオブジェクトAのノードが直接別のlistオブジェクトBに移動されることを意味します。これにより、Aのアロケータによって割り当てられたメモリが、Bのアロケータによって解放可能である必要があり、それによりAとBのアロケータインスタンスが等しいことが推論されます。メイヤーズの結論は、アロケータを静的方法を使用する型として定義するのが最適であるというものです。例えば、C++標準によると、アロケータはrebindメソッドを実装したotherクラステンプレートを提供する必要があります。&lt;/p&gt;
&lt;p&gt;另外、C++プログラミング言語のビアニ・ストラウスルップは、「各オブジェクトの情報が異なることを防ぐための厳格なアロケータの制限」については「問題ない」（大意）と述べ、ほとんどのアロケータには状態が必要なく、むしろ状態がない方が性能が良い場合もあると指摘しています。彼は、メモリプール型アロケータ、共有メモリ型アロケータ、ガベージコレクション型アロケータという3つのカスタムアロケータの利用例を提示し、内部メモリプールを利用して少量メモリを高速に割り当て/解放するアロケータの実装例を示しました。しかし、彼はそのような最適化は既に彼が提供しているサンプルアロケータで実現されている可能性もあると述べています。[3]&lt;/p&gt;
&lt;p&gt;カスタムアロケータの別の用途は、メモリ関連のエラーをデバッグすることです[10]。そのためには、割り当て時に追加のメモリを割り当ててデバッグ情報を格納するアロケータを作成できます。このようなアロケータは、メモリが同じ種類の割り当て/解放アロケータによって割り当て/解放されることを保証するだけでなく、キャッシュオーバーフローからプログラムをある程度保護することもできます[11]。&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
