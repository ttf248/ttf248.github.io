<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>コンピューター on 向叔の手帳</title>
        <link>https://ttf248.life/ja/categories/%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%83%BC/</link>
        <description>Recent content in コンピューター on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Sat, 08 Nov 2025 16:48:55 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/categories/%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%83%BC/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>ローカル開発の苦悩：なぜ `nul` ファイルを削除できないのか？複合型ファイルシステムの問題への解決策</title>
        <link>https://ttf248.life/ja/p/local-development-pain-why-cant-you-delete-nul-files-a-solution-to-the-composite-file-system-problem/</link>
        <pubDate>Sat, 08 Nov 2025 16:37:46 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/local-development-pain-why-cant-you-delete-nul-files-a-solution-to-the-composite-file-system-problem/</guid>
        <description>&lt;p&gt;ソフトウェア開発の日常業務において、私たちはしばしば「厄介な小さな問題」に遭遇します。それらは一見単純に見えますが、数時間という貴重な時間を費やしてしまうこともあります。特に、Windows システム上で特定のファイルを削除する（特に開発ツールチェーンによって意図せず生成されたファイル）ことは、「大惨事」の典型的な例です。&lt;/p&gt;
&lt;p&gt;私もそのような「地獄級」の問題に遭遇しました。ローカルで開発していた際に、プロジェクト内に莫名其妙に &lt;code&gt;nul&lt;/code&gt; という名前のファイルが作成されてしまいました。Windows エクスプローラーや CMD コマンドラインを試しましたが、システムは「ファイルが見つからない」または「削除できません」と表示していました。このファイルはまるで幽霊のように、頑固にもプロジェクトディレクトリに根付いていました。&lt;/p&gt;
&lt;h2 id=&#34;フェーズ１標準的な試行と標準の無効な解決策&#34;&gt;フェーズ１：標準的な試行と「標準」の無効な解決策
&lt;/h2&gt;&lt;p&gt;問題に遭遇したとき、私の第一反応は &amp;ldquo;&lt;code&gt;nul&lt;/code&gt; ファイル&amp;rdquo; です。
&lt;strong&gt;なぜ &lt;code&gt;nul&lt;/code&gt; ファイルが特殊なのか？&lt;/strong&gt;
Windows の歴史を知る開発者は、&lt;code&gt;nul&lt;/code&gt; が「穴」と呼ばれるものだと知っているかもしれません。Windows (およびそれ以前の DOS) システムでは、&lt;code&gt;NUL&lt;/code&gt;、&lt;code&gt;CON&lt;/code&gt;、&lt;code&gt;PRN&lt;/code&gt;、&lt;code&gt;AUX&lt;/code&gt; などの名前は予約されたデバイス名です。&lt;code&gt;NUL&lt;/code&gt; は「空デバイス」（Unix/Linux の &lt;code&gt;/dev/null&lt;/code&gt; に相当）を表します。
Windows のファイルシステム API が、&lt;code&gt;nul&lt;/code&gt; という名前の「ファイル」を操作しようとすると、それは空デバイスを操作しているものとして扱われ、通常のファイル名を操作しようとしているものとは区別されません。したがって、ファイルの削除やリネームなどの標準的なファイル操作はすべて失敗します。
&lt;strong&gt;&lt;code&gt;nul&lt;/code&gt; ファイルがどのように生成されるのか？&lt;/strong&gt;
これは通常、クロスプラットフォーム開発ツール（Git、Node.js スクリプト、Python スクリプトなど）の「問題」によるものです。これらのツールは POSIX (Unix 互換) 標準に基づいており、それらから見ると &lt;code&gt;nul&lt;/code&gt; は単なるファイル名です。Windows 上で実行される場合、API を直接呼び出すのではなく、この Windows で「消化不良」を起こすようなファイルを生成することがあります。
&lt;strong&gt;オンラインで推奨されている「標準的な解決策」&lt;/strong&gt;
私は迅速にインターネットを検索し、私だけが最初にこの問題に遭遇したわけではないことを知りました。コミュニティはいくつかの「高度な」解決策を提唱していました：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;\\.\&lt;/code&gt; 構文の使用:&lt;/strong&gt; CMD で特別な「長いパス」構文を使用して、Windows の名前チェックを回避します。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;del \\.\C:\your\project\path\nul
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;Git Bash の使用:&lt;/strong&gt; Git Bash は軽量の Unix 環境を提供し、&lt;code&gt;nul&lt;/code&gt; を特殊なデバイスとして扱わないためです。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rm nul
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;WSL (Windows Subsystem for Linux) の使用:&lt;/strong&gt; WSL に入って Windows ディスクをマウントし、Linux の &lt;code&gt;rm&lt;/code&gt; コマンドを使用してファイルを削除します。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rm /mnt/c/your/project/path/nul
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;しかし、&lt;strong&gt;これらの方法どれも私には効果がありません！&lt;/strong&gt;
WSL でも Git Bash でも、&lt;code&gt;rm nul&lt;/code&gt; を実行しても、「No such file or directory」（ファイルまたはディレクトリが見つかりません）というエラーが発生しました。これは、私が想像していたよりも問題が複雑であることを示唆していました。&lt;/p&gt;
&lt;h2 id=&#34;フェーズ２閃光一瞬それは多重問題の重ね合わせなのか&#34;&gt;フェーズ２：閃光一瞬——それは「多重問題の重ね合わせ」なのか？
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;nul&lt;/code&gt; ファイルが実際に存在する場合、Unixツールはなぜそれを「見つからない」と報告するのか？&lt;/p&gt;
&lt;p&gt;私は疑念を抱き始めた：&lt;strong&gt;問題は &lt;code&gt;nul&lt;/code&gt; ファイル自体だけでなく、その「居場所」、つまり存在するディレクトリにあるのではないか？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;そこで私は直ちにGit Bash（これが重要だ、Windowsのエクスプローラーでは異常が表示されない可能性があるから）を開き、&lt;code&gt;nul&lt;/code&gt; ファイルが存在する&lt;strong&gt;親ディレクトリ&lt;/strong&gt;に移動して、&lt;code&gt;ls -la&lt;/code&gt; (すべてのファイル（隠されたファイルを含む）をリストし、詳細情報を表示) を実行した。&lt;/p&gt;
&lt;p&gt;そこでついに「盲点」を発見した：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;その &lt;code&gt;nul&lt;/code&gt; ファイルが保存されているディレクトリは、その&lt;strong&gt;ディレクトリ名自体に無効な文字が含まれていた！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;フェーズ2閃きの一瞬マルチ問題の重ね合わせなのか&#34;&gt;フェーズ2：閃きの一瞬——「マルチ問題の重ね合わせ」なのか？
&lt;/h2&gt;&lt;p&gt;私のケースでは、このディレクトリ名はスペースやピリオド（&lt;code&gt;.&lt;/code&gt;）で終わる名前であるか、あるいはWindowsが許可しない特殊文字（&lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;:&lt;/code&gt;など）を含むものである可能性があります。これらはすべて、開発ツールがクロスプラットフォーム同期する際に「持ち込まれた荷物」です。&lt;/p&gt;
&lt;p&gt;例えば、Git Bashでディレクトリが表示されると &lt;code&gt;&amp;quot;my-app &amp;quot;&lt;/code&gt; (末尾のスペースに注意) や &lt;code&gt;&amp;quot;my-app.&amp;quot;&lt;/code&gt; のようになります。
&lt;strong&gt;これが問題の本質です！&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;問題A：&lt;/strong&gt; &lt;code&gt;nul&lt;/code&gt; という「不正な」ファイルがあります。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;問題B：&lt;/strong&gt; &lt;code&gt;&amp;quot;my-app &amp;quot;&lt;/code&gt; という「不正な」ディレクトリがあります。
&lt;code&gt;rm /path/to/&amp;quot;my-app &amp;quot;/nul&lt;/code&gt; を実行しようとすると、WindowsシステムとUnixツールが「混乱」します。Windows APIは、この不正な文字を含むパスを正しく解析できないためで、Git BashやWSLは「この不正なディレクトリを見る」ことができますが、内部の &lt;code&gt;nul&lt;/code&gt; ファイルにアクセスしようとすると、パス解析の複合的な問題により失敗する可能性があります。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;フェーズ3釜底抽薪パスを徹底的に排除する&#34;&gt;フェーズ3：釜底抽薪——パスを徹底的に排除する
&lt;/h2&gt;&lt;p&gt;「ファイルパス」と「ファイル名」という二つの問題が特定されたことで、解決策は明確になりました。&lt;strong&gt;&lt;code&gt;nul&lt;/code&gt; ファイルを削除しようとするのではなく、その「不正な」親ディレクトリを直接削除するのです！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;私の最終的な解決手順は以下の通りです。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Git Bashを開く&lt;/strong&gt;: これが唯一、「見えない」か「処理できない」これらの不正な名前を正しく認識し、操作できるツールです。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;問題ディレクトリの親ディレクトリに移動する&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;問題ディレクトリの実際の名称を確認する&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;「究極の削除」を実行する&lt;/strong&gt;: &lt;code&gt;rm&lt;/code&gt; コマンドの &lt;code&gt;-r&lt;/code&gt; (再帰) と &lt;code&gt;-f&lt;/code&gt; (強制) オプションを&lt;strong&gt;引用符&lt;/strong&gt;で囲み、使用してそのディレクトリ全体を削除します。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;コマンドを実行すると、私を悩ませていた、&lt;code&gt;nul&lt;/code&gt; ファイルを含む、本来も不適切な名前のディレクトリが、ついに私のファイルシステムから完全に消去されました。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>コマンドラインベースのAIコーディングインタラクション</title>
        <link>https://ttf248.life/ja/p/command-line-ai-coding-interaction/</link>
        <pubDate>Wed, 05 Nov 2025 14:12:46 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/command-line-ai-coding-interaction/</guid>
        <description>&lt;p&gt;慣例のようにTraeを開き、コードを始める前に、通知欄にメッセージが届く。「claudeモデルが下ラインになったため使用できず、今後も回復する可能性は低い」と。公式からは補償プランが提供され、利用回数が300（1月まで）増加する。&lt;/p&gt;
&lt;p&gt;調べてみると、予想通り、Anthropic社はアメリカの要請により、国内企業へのclaudeシリーズモデルの使用を禁止している。TraeのDiscordコミュニティに潜入し、多くの人がclaudeモデルの下ラインについて不満を漏らし、大部分がclaudeを期待して利用していたためだ。claude 4.5モデルがtraeで同期されなかった時点で、この問題の兆候はすでに存在していた。&lt;/p&gt;
&lt;h2 id=&#34;試してみる&#34;&gt;試してみる
&lt;/h2&gt;&lt;p&gt;最後の1回、試してみることにした。他のモデルも体験してみた（OpenAIのgpt-3.5-turbo、gpt-4、GoogleのGemini Proなど）。
どう表現すればいいかわからないが、どれもあまり理想的ではなかった。Traeの海外チームがどのように開発したのかわからない。本来なら、こんなに大きな差はないはずだ。テストに使用したプロンプトは、以前使っていた小蓝书プロジェクトで、以前の記事にも書かれていたものだ。
加えて、Trae IDE自体に不満があったため、Traeチームにメールを送り、払い戻しの申請を行った。&lt;/p&gt;
&lt;h2 id=&#34;変更&#34;&gt;変更
&lt;/h2&gt;&lt;p&gt;誤っていただろうのは、Googleが最初にリリースしたターミナルインタラクティブAIプログラミングのことだ。IDEと比較して、日常的なスマートアシストは存在しないものの、より汎用性が高まっている。開発者は引き続き既存の開発環境を使用することができる。&lt;/p&gt;
&lt;p&gt;OpenAIとAnthropicの2社はそれぞれ、Claude Code、Codexを発表し、ツールとモデルが完全に固定されていない。設定ファイルを修正することで、他のモデルにも接続できる。&lt;/p&gt;
&lt;p&gt;Discordコミュニティでは、minimax M2やglm4といった国内のモデル（小蓝书プロジェクト）について言及があり、Minimax M2を試してみたところ、それなりに良かった。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;インストールには科学的なアクセスが必要で、異なるモデル間の切り替えについては、&lt;a class=&#34;link&#34; href=&#34;https://github.com/farion1231/cc-switch&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/farion1231/cc-switch&lt;/a&gt; を推奨します。&lt;/p&gt;
&lt;h2 id=&#34;claude-code&#34;&gt;claude code
&lt;/h2&gt;&lt;p&gt;Node.js に依存し、コマンド: npm install -g @anthropic-ai/claude-code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;╭─── Claude Code v2.0.33 ────────────────────────────────────────────────────────────────────────────────╮
│                                    │ 開始方法のヒント                                                  │
│            ようこそ戻ってこられました！           │ /init を実行して、Claude の指示を含む CLAUDE.md ファイルを作成します。 │
│                                    │ ───────────────────────────────────────────────────────────────── │
│               ▐▛███▜▌              │ 最新アクティビティ                                                   │
│              ▝▜█████▛▘             │ 最新のアクティビティはありません                                                │
│                ▘▘ ▝▝               │                                                                   │
│                                    │                                                                   │
│   minimax-m2 · API 利用料金   │                                                                   │
│          F:\dev\notebook           │                                                                   │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────╯

─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
&amp;gt; &amp;quot;util logging.py を作成して...&amp;quot; を試してください
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  ！bash モードの場合は、入力フィールドをクリアするためにエスケープキーをダブルクリックします。
  / コマンドの実行      alt + m で自動的に編集を受け入れる       alt + v で画像を貼り付けます
  @ ファイルパスの表示     ctrl + o で詳細な出力を表示        # メモリ化するため
                        tab で思考を切り替える          ctrl + t でタスクを表示
                        backslash (\) + return (⏎) で
                        改行
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;codex&#34;&gt;Codex
&lt;/h2&gt;&lt;p&gt;未体験、参考資料：&lt;a class=&#34;link&#34; href=&#34;https://platform.minimaxi.com/docs/guides/text-ai-coding-tools#%E5%9C%A8-codex-cli-%E4%B8%AD%E4%BD%BF%E7%94%A8-minimax-m2&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://platform.minimaxi.com/docs/guides/text-ai-coding-tools#%E5%9C%A8-codex-cli-%E4%B8%AD%E4%BD%BF%E7%94%A8-minimax-m2&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>KB5054156：Windows 11 バージョン 25H2 機能アップデート（パッチ適用ガイド - パッケージの使用方法）</title>
        <link>https://ttf248.life/ja/p/kb5054156-windows-11-version-25h2-feature-update-package-deployment-guide/</link>
        <pubDate>Tue, 28 Oct 2025 22:36:45 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/kb5054156-windows-11-version-25h2-feature-update-package-deployment-guide/</guid>
        <description>&lt;p&gt;ローカルのWindowsシステムインストールパッケージを更新したところ、25H2バージョンがリリースされていることがわかりました。しかし、ローカルのシステムはまだ24H2バージョンに留まっており、Microsoftのアップデートパッチもインストールされていますが、ローカルのシステムが25H2バージョンにアップグレードされていません。その間に何が足りないのか気になりました。
この記事では、Microsoftの公式サポートドキュメントに基づいて、KB5054156アップデートのコア情報を整理し、Windows 11 24H2から25H2へのアップグレードにおける重要なポイントをユーザーに理解させることを目的としています。&lt;/p&gt;
&lt;h2 id=&#34;更新概要&#34;&gt;更新概要
&lt;/h2&gt;&lt;p&gt;KB5054156は、&lt;strong&gt;Windows 11 バージョン 25H2&lt;/strong&gt;向けの機能アップデートであり、主な目的は「パッケージを有効にする」ことで 25H2 の新機能を起動することです。その本質は、Windows 11 24H2 と 25H2 が「共通コアシステム」を共有するという特性を利用しており、25H2 の新機能が 24H2 の最新月度品質更新に含まれていますが、休眠状態にあり、「パッケージを有効にする」ことでこれらの機能を「メインスイッチ」として起動することです。&lt;/p&gt;
&lt;h2 id=&#34;対象範囲&#34;&gt;対象範囲
&lt;/h2&gt;&lt;p&gt;本更新は、&lt;strong&gt;Windows 11 バージョン 24H2&lt;/strong&gt;を実行しているデバイスのみをサポートしています。具体的なバージョンは以下のとおりです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windows 11 Enterprise および Education, バージョン 24H2&lt;/li&gt;
&lt;li&gt;Windows 11 Enterprise Multi-Session, バージョン 24H2&lt;/li&gt;
&lt;li&gt;Windows 11 Home および Pro, バージョン 24H2&lt;/li&gt;
&lt;li&gt;Windows 11 IoT Enterprise, バージョン 24H2&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;エンベージenable-packageのコアなメリット&#34;&gt;エンベージ（Enable Package）のコアなメリット
&lt;/h2&gt;&lt;p&gt;従来の機能アップデートと比較して、エンベージの核心的な価値は&lt;strong&gt;アップデートによるダウンタイムを削減すること&lt;/strong&gt;にあります：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;複雑なダウンロードとインストール手順が不要で、24H2から25H2へのアップグレードを完了するためにデバイスのみ再起動するだけで済みます。&lt;/li&gt;
&lt;li&gt;アップグレード後、デバイスはすぐに25H2バージョンの新機能を使用できるようになり、完全なシステムアップデートを待つ必要はありません。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;更新取得方法&#34;&gt;更新取得方法
&lt;/h2&gt;&lt;p&gt;KB5054156は、以下の3つのチャネルを通じてリリースされます。各チャネルの可用性と手順は次のとおりです。&lt;/p&gt;
&lt;p&gt;| Windows Update | 利用可能 | 自動ダウンロードおよびインストール。機能更新は「Windows 11, バージョン 25H2」として表示され、手動でのトリガーは不要 |&lt;/p&gt;
&lt;h2 id=&#34;更新取得方法-1&#34;&gt;更新取得方法
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;配信チャネル&lt;/th&gt;
&lt;th&gt;利用可能&lt;/th&gt;
&lt;th&gt;次のステップ&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Windows 更新カタログ&lt;/td&gt;
&lt;td&gt;利用不可&lt;/td&gt;
&lt;td&gt;なし、この更新はWindows UpdateおよびWSUSチャネルを通じてのみ取得できます&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;更新取得方法-2&#34;&gt;更新取得方法
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;发布渠道&lt;/th&gt;
&lt;th&gt;可用性&lt;/th&gt;
&lt;th&gt;次の操作&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Windows Server Update Services (WSUS)&lt;/td&gt;
&lt;td&gt;利用可能&lt;/td&gt;
&lt;td&gt;以下のパラメータを設定して自動同期を実施する必要があります：&lt;br&gt;1. 製品：Windows 11&lt;br&gt;2. 分類：アップグレード&lt;br&gt;更新名を「Windows 11、バージョン 25H2」に変更してください&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;アップグレードの前提条件&#34;&gt;アップグレードの前提条件
&lt;/h2&gt;&lt;p&gt;KB5054156 のアップデートを適用する前に、次の 2 つの条件を満たす必要があります。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;現在実行しているシステムバージョンが &lt;strong&gt;Windows 11 バージョン 24H2&lt;/strong&gt; であること（より低いバージョンからの直接アップグレードはサポートされません）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2025年8月29日にリリースされた KB5064081 の累積更新をインストール済みであること&lt;/strong&gt; (OS 内蔵バージョン 26100.5074、プレビュー版およびそれ以降のバージョンを含む)。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;再起動と更新の代替手順&#34;&gt;再起動と更新の代替手順
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;再起動の要件&lt;/strong&gt;: KB5054156 の更新後、25H2 機能の有効化には &lt;strong&gt;デバイスの再起動が必須です&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更新の代替&lt;/strong&gt;: この更新は、これまでにリリースされた Windows 更新を置き換えるものではありませんので、過去の更新ファイルを上書きすることについてご心配いりません。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;参考資料&#34;&gt;参考資料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Microsoft公式ドキュメント：&lt;a class=&#34;link&#34; href=&#34;https://support.microsoft.com/zh-cn/topic/kb5054156-%E4%BD%BF%E7%94%A8%E5%90%AF%E7%94%A8%E5%8C%85%E5%AF%B9-windows-11-%E7%89%88%E6%9C%AC-25h2-%E7%9A%84%E5%8A%9F%E8%83%BD%E6%9B%B4%E6%96%B0-4d307e2d-3028-4323-bb46-552cff491643&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;KB5054156：Windows 11 25H2 の機能アップデートを有効にする&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;用語集：Microsoft ソフトウェアアップデート標準用語解説&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>💻 PCの黒い画面トラブルシューティング記録</title>
        <link>https://ttf248.life/ja/p/computer-black-screen-troubleshooting-log/</link>
        <pubDate>Mon, 27 Oct 2025 23:45:58 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/computer-black-screen-troubleshooting-log/</guid>
        <description>&lt;p&gt;私のデスクトップPCは、&lt;strong&gt;常年電源を入れっぱなし&lt;/strong&gt;にしています。普段は、外出時や夜間など、使用していないときにモニターだけを消す程度です。&lt;/p&gt;
&lt;h2 id=&#34;-故障現象&#34;&gt;🚨 故障現象
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;定期的な操作を行った後、ディスプレイが常に&lt;strong&gt;黒い状態&lt;/strong&gt;になっていることを確認しました。&lt;/li&gt;
&lt;li&gt;ディスプレイの電源を切り直す（リブート）を試みましたが、画面には &amp;ldquo;&lt;strong&gt;信号入力なし&lt;/strong&gt;&amp;rdquo; と表示されました。&lt;/li&gt;
&lt;li&gt;携帯電話で &lt;strong&gt;UU リモートコントロール&lt;/strong&gt; を使用して確認したところ、デスクトップPCと別のミニPCが両方とも&lt;strong&gt;オンライン状態&lt;/strong&gt;になっていることがわかりました。これは、ホスト自体がシャットダウンしていない可能性を示唆しています。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;-初步トラブルシューティング手順&#34;&gt;🛠️ 初步トラブルシューティング手順
&lt;/h2&gt;&lt;p&gt;「シグナルなし」の問題を解決するために、以下のことを試みました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DPデータケーブルの抜き差し&lt;/strong&gt; を繰り返す。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HDMIケーブルへの切り替え&lt;/strong&gt; を行う。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;入力ソースをミニPCに切り替える&lt;/strong&gt; (モニターが故障しているかテスト)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;-結果と解決策&#34;&gt;🔍 結果と解決策
&lt;/h2&gt;&lt;p&gt;上記試行&lt;strong&gt;すべて問題の解決には至りませんでした&lt;/strong&gt;。
私は抖音などのプラットフォームで検索し、断電を数分間行うことを推奨する提案を見つけましたが、何度も試した結果&lt;strong&gt;効果がありませんでした&lt;/strong&gt;。
&lt;strong&gt;最終的な解決策：&lt;/strong&gt; デスクトップPCの&lt;strong&gt;再起動&lt;/strong&gt;を行う。再起動後、ディスプレイ信号が正常に回復し、問題が解決しました。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>あらゆるAIの恩恵は、すでに影で価格が設定されていた。</title>
        <link>https://ttf248.life/ja/p/all-the-gifts-of-ai-have-already-been-marked-up-with-prices-in-the-shadows/</link>
        <pubDate>Fri, 10 Oct 2025 19:09:36 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/all-the-gifts-of-ai-have-already-been-marked-up-with-prices-in-the-shadows/</guid>
        <description>&lt;p&gt;記事の投稿頻度は、AIの使用に伴い著しく増加しています。私も記事内のタグで区別し、作者欄には大規模言語モデルの名前を記載する予定です。しかし問題は残っており、AIが生成した記事では、私の関与レベルは明らかに低下しています。多くの記事が半ヶ月ほど隔てられ、内容をほとんど忘れてしまいます。コーディングの際にも同様の状況が発生し、問題に遭遇したら、まずAIによる分析を思いつき、既存のものに基づいた問題解決やトラブルシューティングではなく、「怠惰」が顕著に向上しています。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;生成AIは業務効率を向上させる一方で、その「贈り物」には巨額な代償が伴います。北大研究チームが41万件の論文と縦断的な実験分析を通じて明らかにしたところ、AIは知識生産を加速させながらも、深刻な同質化を引き起こしています。ハーバード大学の研究では、AIが「資格偏向」をもたらし、初級職が7.7%減少するという結果を示しており、マタイ効果を悪化させています。個人的には、AIによる創造性の向上は一時的な「幻覚」に過ぎず、停止すると消え失せます。しかし、思想の同質化は持続的に存在し、「創造の傷痕」を生み出しています。&lt;/p&gt;
&lt;h2 id=&#34;現状&#34;&gt;現状
&lt;/h2&gt;&lt;p&gt;生成式AIは、あらゆる産業を再構築するだけでなく、人間の文章作成、認知、思考の根本的な方法も変えています。&lt;strong&gt;ChatGPT 3.5 の発表後、楽観的な期待が広まりました：「AI は労働力を均等化する」という予測です。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2023 年、マサチューセッツ工科大学の経済学博士 2 人が『Science』誌に実証研究を発表し、この見通しを裏付けました。生成式 AI が低パフォーマンス従業員のパフォーマンスを大幅に向上させ、そのギャップを埋めることで不平等感を軽減する可能性があるというものです。&lt;/p&gt;
&lt;p&gt;『Science』誌の編集部は、こうまとめました。「スキルが劣る参加者は ChatGPT から最も利益を得ており、これは生産性の不平等を AI で削減するという政策にとって重要な示唆を与えています。」&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/all-the-gifts-of-ai-have-already-been-marked-up-with-prices-in-the-shadows/20251010191432.png&#34;
	width=&#34;1024&#34;
	height=&#34;905&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Science 誌&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;113&#34;
		data-flex-basis=&#34;271px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;しかしながら、&lt;strong&gt;2 年が経過した今、現実がこの理想的な経路を完全にたどっているとは限りません。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2025 年、ハーバード大学の経済学博士 2 人は、2015 ～ 2025 年にかけて 620 万人以上、1.5 億回以上の採用・雇用データ分析を通じて、冷酷な真実を明らかにしました。&lt;strong&gt;生成式 AI は「資格偏重」の形で労働市場を再構築しているのです。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/all-the-gifts-of-ai-have-already-been-marked-up-with-prices-in-the-shadows/20251010191527.png&#34;
	width=&#34;866&#34;
	height=&#34;544&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;資格偏重&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;159&#34;
		data-flex-basis=&#34;382px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;数据显示、2015 ～ 2022 年にかけて、初級職と高級職の雇用成長曲線はほぼ一致していましたが、2023 年以降、両者で分岐が生じ始めました。高級職は引き続き上昇し続けましたが、初級職は方向転換して下降しました。&lt;/p&gt;
&lt;p&gt;AI を深く受け入れている企業の場合、その初級職の数は 6 四半期以内に約 7.7% 減少しましたが、高級職はほとんど影響を受けず、むしろわずかに増加しました。この現象の主な原因は採用の減少ではなく、大規模な解雇ではありませんでした。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AI は、普恵的な平権をもたらすどころか、「强者更强」のマタイ効果をますます強調しています。&lt;/strong&gt; 携程 CEO の梁建章氏は、この論文について「AI は初級の知的労働者を代替し、若者の教育、結婚、出生、職業初期といった段階における困難を悪化させるだろう」と評価しました。&lt;/p&gt;
&lt;p&gt;労働市場の構造変化は氷山の一角に過ぎません。&lt;strong&gt;より深層的な問題が浮上してきます。AI が大規模に私たちのワークフローに組み込まれるとき、それは人間の創造性自体にどのような影響を与えるのでしょうか？ AI がもたらす効率性の向上は、個人の能力の内化でしょうか？ それは、私たちが見過ごしている方法で、あるいは「統一」することで、私たちの思想を形作ったり、「統一」したりしているのでしょうか？ 個体が AI に過度に依存した後、彼らの独立した、オリジナルの思考能力は強化されたのか、それとも無意識のうちに弱体化されたのか？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最近、北京大学 李圭泉 教授の研究チームが、社会学のトップジャーナル Technology in Society に発表した論文は、この一連の重要な問題に対する正面からの回答です。&lt;/p&gt;
&lt;p&gt;研究の中心は 2 つの部分で構成されています。第一に、ChatGPT 3.5 のリリース前後の、全 21 科目の学術論文を分析する大規模な自然実験を通じて、AI が世界の知識生産に与える実際の影響を分析します。第二に、数か月続く縦断的な行動実験を通じて、ラボ環境で AI が個人の認知能力に及ぼす長期的な因果効果を探ります。&lt;/p&gt;
&lt;p&gt;研究チームは、ブレイクポイント回帰設計と機械学習などの技術を組み合わせて、生成式 AI が個人創造性と集団同質性に与える長期的かつ現実の影響を明らかにしました。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/all-the-gifts-of-ai-have-already-been-marked-up-with-prices-in-the-shadows/20251010191638.png&#34;
	width=&#34;1024&#34;
	height=&#34;747&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;ジャーナル&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;137&#34;
		data-flex-basis=&#34;328px&#34;
	
&gt;
このジャーナルは JCR 1区 top であり、影響因子 12.5 で、socialscience,Interdisciplinary 分類下 271本のジャーナル中ランキング第2&lt;/p&gt;
&lt;h2 id=&#34;41万論文の集団無意識&#34;&gt;41万論文の「集団無意識」
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;最恐ろしいのはノイズではなく、衆聞一斉であることだ。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;41万論文の集団無意識-1&#34;&gt;41万論文の「集団無意識」
&lt;/h2&gt;&lt;p&gt;この研究は大規模な自然実験でした。
研究チームは、Web of Scienceコアデータベースから、物理科学、生命科学・生物医学、応用科学、社会科学、芸術・人文など全部21分野の学術産出を抽出し、ChatGPT-3.5発表前の全419,344篇論文を約17,000名の研究者からのランダムサンプリングを通じて収集し、巨大なデータセットを作成することで、AIが世界の知識生産に与える真の影響を分析しました。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/all-the-gifts-of-ai-have-already-been-marked-up-with-prices-in-the-shadows/20251010191749.png&#34;
	width=&#34;1024&#34;
	height=&#34;493&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;大規模なデータセット&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;207&#34;
		data-flex-basis=&#34;498px&#34;
	
&gt;
生成AI発表前後の学術論文の同質性と創造性結果のイメージ図&lt;/p&gt;
&lt;p&gt;上記画像のように、2022年以前は世界の学術産出の創造性（赤/青線）と同質性（灰色線）が安定的に成長していました。しかし、ChatGPT3.5発表後、両者の傾斜が急激に上昇しました。
つまり、GPT3.5発表後、学界は知識産の創出（創造性）を著しく加速させる一方で、その内容の同質化もより速い速度で進み、生成AIが知識生産に対して持つ「両刃の剣」のような影響を明確に示すものでした。&lt;/p&gt;
&lt;p&gt;観察された変化がAIによって引き起こされたことを証明するため、研究チームは「断点回帰デザイン」（RDD）と呼ばれる因果推論手法を採用しました。&lt;/p&gt;
&lt;h3 id=&#34;方法&#34;&gt;方法
&lt;/h3&gt;&lt;p&gt;2022年12月ChatGPT-3.5のリリースを、天然の「時間断切」と捉えることができる。論文がその日付より前か後かで、個々の研究者にとって制御できない偶然要因（例えば査読期間）が存在し、これはほぼランダムに「実験群」（AIを使用できる機会があるグループ）と「対照群」（AIを使用できないグループ）に割り当てられたようなものである。&lt;/p&gt;
&lt;h3 id=&#34;信頼性の理由&#34;&gt;信頼性の理由
&lt;/h3&gt;&lt;p&gt;この「準確率」特性により、研究者は他の長期的な要因の干渉を効果的に排除し、AIがもたらす因果効果を正確に特定することができます。その方法論の厳密性を確保するため、チームは一連の統計的検定を実施し、学者が「切り替え点」の前後に大規模な「稿を捏造する」や「早期発刊する」などの戦略的な行動を行っていないことを確認しました。これにより、研究結果の信頼性が保証されます。&lt;/p&gt;
&lt;h3 id=&#34;創造性と同質性の指標を定量化するには&#34;&gt;「創造性」と「同質性」の指標を定量化するには？
&lt;/h3&gt;&lt;p&gt;因果関係が確認された後、研究チームは40以上の論文に対して、「創造性」と「同質性」という2つの次元で定量分析を実施しました。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;創造性&lt;/strong&gt;：論文発表の「数」と発表ジャーナルの「質」（JCR分区）を評価します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数：学者が発表した論文の総数。&lt;/li&gt;
&lt;li&gt;質：論文が発表されたジャーナルのJCR分区（JournalCitationReportsQuartiles）。これは、JCR（ジャーナル引用レポート・クォータイルズ）という権威あるジャーナル評価システムで、Q1は当該分野における影響力上位25%に位置するトップジャーナルを指し、Q4は末位の25%を指します。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;同質性&lt;/strong&gt;：内容類似度と言語スタイル類似度によって評価します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内容類似度：SBERT（Sentence BERT）という深層学習モデルを用いて論文の要約を数値「ベクトル」に変換し、そのベクトル間の「コサイン類似度」を計算することで、核心的な意味合いにおける類似度を測ります。&lt;/li&gt;
&lt;li&gt;言語スタイル類似度：文字レベルでのマッチングアルゴリズムを用いて論文の要約から出現する短語や文型をスキャンし、それらの繰り返しをカウントすることで、文章スタイルの類似性を測定します。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;冷徹な両刃の剣より効率的しかしより単調&#34;&gt;冷徹な両刃の剣：より効率的、しかしより単調
&lt;/h3&gt;&lt;p&gt;如图所示のように、分析結果は明確に「両刃の剣」効果を明らかにする。
一方、AIの登場は学術産出における強力な「加速器」となったことは確かである。研究者の1人あたりの年平均発表論文数は0.9篇増加し、発表ジャーナルの質は平均6%向上した。この効果は特に技術や物理科学などの分野で顕著である。
しかしながら、効率の向上が思想と表現の多様性を犠牲にしている。データによると、論文の言語スタイル類似度は平均毎年驚異的な79%増加し、同時に論文の内容テーマも著しく同質化しており、特に物理科学、芸術、人文科学における同一化現象が最も深刻である。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;20251010192022.png&#34; &gt;断点回归结果图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;北大研究チームによるこの大規模な自然実験は、私たちに現実世界の宏観的な証拠を提供する。生成式AIは学術産出における強力な「加速器」であり、学者たちがより迅速に論文を執筆し、より優れたジャーナルに発表するのを助ける。しかし、このような効率の向上は、思想と表現の多様性を犠牲にしている。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;世界の知識生産は、この「大交換」の中で、より効率的かつ「単調」になっているようだ。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同時に、研究二でも、より深いレベルの問題が提起された：この宏観的なトレンドが、その場にいる個人にどのような意味を持つのか？AIが生み出す創造性の向上は、実際の個人能力の成長を意味するのだろうか？&lt;/p&gt;
&lt;p&gt;この問題を解決するために、研究チームは研究二で数ヶ月にわたる継続的な追跡調査を実施し、制御された実験環境においてAIが個人の認知能力に及ぼす長期的な因果効果を探求した。&lt;/p&gt;
&lt;h2 id=&#34;aiが生み出した創造性の傷跡&#34;&gt;AIが生み出した創造性の傷跡
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;思考が習慣に屈すると、創造性は失われてしまう。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;aiが生み出した創造性の傷跡-1&#34;&gt;AIが生み出した創造性の傷跡
&lt;/h2&gt;&lt;p&gt;実際には、すでに多くの研究所で、小規模なデータを用いた実証研究が、マクロデータが示唆するトレンドから異なる角度からその傾向を裏付けています。例えば、コーネル大学の研究では、AIライティングアシスタントが文化的独自性を犠牲にし、「西欧の規範」に従うような表現へと誘導するという傾向が見られました。また、サンタクララ大学の研究でも、ChatGPTを使用している個人は、その創造性が意味レベルでより類似していることが示唆されました。&lt;/p&gt;
&lt;p&gt;特に注目すべきは、マサチューセッツ工科大学の研究チームが脳波（EEG）技術を用いて、個人の脳活動を直接観察したことです。彼らは、ChatGPTを使用していた学生グループの脳活動レベルが、自分自身で考えるか、検索エンジンを使用するグループと比較して著しく低いことを発見しました。&lt;/p&gt;
&lt;p&gt;これらの研究は、AIが認知投入を減らし、多様性を犠牲にして効率を高めるという結論を導き出しています。&lt;/p&gt;
&lt;p&gt;しかし、ほとんどの研究は、AIの使用による即時の影響に焦点を当てており、AIが「離場」した後、その効果が持続するか、そしてその長期的な負の側面が軽減されるかについては、ほとんど探求されていません。&lt;/p&gt;
&lt;p&gt;北京大学はこの点において新たな試みを行いました。&lt;/p&gt;
&lt;p&gt;それは、7日間の実験中にAIの即時的な影響を観察するだけでなく、実験終了後の30日目と60日目の独立した追跡テストを通じて、AI依存によってもたらされる長期的な結果を体系的に検証することにも取り組んだのです。これにより、AIがもたらすのは、転移可能な「能力」なのか、それとも一時的で内化できない「幻影」なのかを真正に理解することが可能になりました。&lt;/p&gt;
&lt;p&gt;具体的には、北京大学の研究チームは、61名の大学生を2つのグループに無作為割り当てました。「AI実験群」（ChatGPT-4を使用可能）と「純粋な脳力対照群」。&lt;/p&gt;
&lt;p&gt;実験デザインには、3つの主要な段階が含まれていました。まず、すべての参加者が最初の日にAIを使用せず、創造力基線テストを実施しました。次に、2日から6日までの間、「AI実験群」はAIの支援を受けて毎日の創造力タスクを完了させ、「純粋な脳力対照群」はAIの支援なしでタスクを完了させました。最後に、そして最も重要なのは、7日目、30日目、および60日目に、すべての参加者がAIの支援なしに最終的な追跡テストを実施したことです。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/all-the-gifts-of-ai-have-already-been-marked-up-with-prices-in-the-shadows/20251010192137.png&#34;
	width=&#34;1024&#34;
	height=&#34;656&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;実験デザイン示意图&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;156&#34;
		data-flex-basis=&#34;374px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;研究者は、創造性を評価するために、複合的なタスクモードを採用し、複数の次元をカバーしました。これらのタスクには以下が含まれます：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;発散的思考テスト:&lt;/strong&gt; 従来の「代替用途タスク」（AUT）で、参加者が日常のアイテム（例えば、「ペン」）について可能な限り多くの新しい用途を思いつくように求められます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;創造的な問題解決:&lt;/strong&gt; より現実世界のビジネスシナリオに基づいた課題で、例えば、「スマート自転車」のデザインにおける革新的な機能を考案するように求められます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集約的思考テスト:&lt;/strong&gt; 追跡段階に組み込まれた「遠距連想クイズ」（RAT）で、参加者が関連性のない3つの単語を同時に結びつける単語を見つけ出すように求められます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;洞察力問題:&lt;/strong&gt; 「キャンドル問題」の古典的なもので、参加者が箱に入った金槌、一本のロウソク、そして火打ち石を使って、ロウソクを壁に固定し、かつロウがテーブルに落ちないようにする必要があります。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;評価の科学性を確保するために、研究者は分野における「ゴールドスタンダード」である専門家合意評価法（CAT）を採用しました。多位の専門家評委は、「双盲」条件下で、グループ分けや研究目的を全く知らない状態で、数千件の創造的なアウトプット（発散的思考タスクと複雑な問題解決策を含む）の新規性、実用性、柔軟性などの複数の次元について独立して評価しました。極めて高いデータの一貫性（評価者信度ICC &amp;gt; 0.90）が確保され、評価結果の科学性と公正性が保証されました。&lt;/p&gt;
&lt;p&gt;研究二では、同質性の測定方法として、研究一で採用された技術方法を完全に同一のものを使用し、2つの研究間の評価基準の一致性を確保しました。&lt;/p&gt;
&lt;p&gt;実験の結果は、明確な非対称性を示び露しました：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;創造性の向上は一時的で持続不可能である:&lt;/strong&gt; AIを使用していた期間（第2～6日） 停止使用AI 2か月後でも、「AI実験グループ」の出力内容は、意味レベルおよび言語スタイルにおいて、対照群と比較して依然として著しく高い類似性を示した。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この縦断研究により、直接的な因果関係を示す証拠が得られ、AIが個人の創造性に及ぼす長期的な影響を実証した。AIが生み出すものは単なる内化できない「創造性の錯覚」に過ぎず、残された思考の同調は、長期間にわたって認知や表現習慣の中に残り続ける「創造的傷痕」となる可能性がある。&lt;/p&gt;
&lt;h2 id=&#34;もし世界に新しいアイデアがなくなったら&#34;&gt;もし世界に新しいアイデアがなくなったら
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;これは最良の時代であり、最悪の時代である。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;新しい創造性が世界にない場合&#34;&gt;新しい創造性が世界にない場合
&lt;/h2&gt;&lt;p&gt;北大が行ったこの研究の結論は、私たちが「挫折してAIを完全に放棄する」のではなく、AI時代においてAIを理解し対処するための意識的な努力を促すものである。長期的にAIに依存することで、個人の思考や認知習慣に及ぼされる深遠な影響を認識する必要があるという警告である。&lt;/p&gt;
&lt;p&gt;研究で明らかになった「同質化（Homogenization）」の傾向は、その根底には深い認知科学の原理が存在する。「AIの出力は、ユーザーに対して強力な「アンカー効果（Anchoring Effect）」を引き起こしやすく」、AIが迅速に「それなりによい」と思われる答えやフレームワークを生成すると、私たちの思考がその初期の提案に「固定化され」、その後の思考や創造性が大幅に逸脱することが難しくなる。それが集団レベルで思想の収束につながるのである。&lt;/p&gt;
&lt;p&gt;今年7月に黄仁勋氏がCNNのインタビューで述べた冷静な判断は、「世界に新しい創造性がない場合、AIが生み出す生産性の向上は失業へとつながる」というものだった。&lt;/p&gt;
&lt;p&gt;生成AIが継続的に使用されることで、インターネットの情報や人間の知識基盤がかつてない速度で同質化が進んでいる。北大的研究は、この傾向が実際に存在することを冷徹なデータによって証明している。社会が常に新しい創造性を生み出すことができれば、AIはより多様な雇用機会を生み出すことになる。しかし、単に既存のタスクを繰り返すだけでは、AIは数秒でそれを完了してしまうだろう。&lt;/p&gt;
&lt;p&gt;AIは創造性を増幅させるだけでなく、「アイデア枯渇（Mental Block）」した人々を排除する加速剤となる。&lt;/p&gt;
&lt;h2 id=&#34;ai時代における思考の鋭さの維持について&#34;&gt;AI時代における思考の鋭さの維持について
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;AIは私たちの仕事を軽減する一方で、深く考えることができる思考体系を構築し、AIとインタラクティブに連携することが重要です。解決したい問題をAIに記述するだけでなく、問題自体を推論し、AIの回答が正しいかどうか判断する必要があります。そのためには、弁証法的思考が必要です。—黄仁勋&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;ai時代における思考の鋭さの維持について-1&#34;&gt;AI時代における思考の鋭さの維持について
&lt;/h2&gt;&lt;p&gt;AI時代を生きる個人として、私たちはどのように向き合うべきか？AIの利便性を享受しながらも、創造性の荒廃を防ぐにはどうすればよいか？研究からの示唆に基づいて、以下に具体的な行動提案を示します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;AIを「思考のコーチ」と捉える&lt;/strong&gt;: 疲れることなく、無限の視点を提供してくれる「思考のコーチ」として活用する。アイデア出しや可能性の生成、固定観念への挑戦などに利用するが、最終的な選別、深化、意思決定、そして結果に対する責任は、依然として自分自身で行うべきだ。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;「認知摩擦」を意図的に作り出す&lt;/strong&gt;: 「アンカー効果」に対抗する最も有効な方法は、積極的に「認知摩擦」を生み出すことである。AIが最初に提示する答えに安易に同意せず、その論理的欠陥を探し出し、考慮されていない側面を质疑する。このような批判的思考の訓練こそが、私たちが独立した思考能力を維持するための鍵となる。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;「AIなしの時間」を設ける&lt;/strong&gt;: 筋肉が萎縮しないように定期的に運動するように、脳もAIのサポートなしに鍛える必要がある。週単位で「AIなしの時間」を設け、最も基本的な紙とペン、または空白のドキュメントを使って思考、計画、創作を行う。このような意図的な「認知断捨離」は、脳の中核的な創造性と推論能力が、安逸の中で退化することを防ぐのに役立つ。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>C&#43;&#43;23 で導入された新機能である enumerate と ranges</title>
        <link>https://ttf248.life/ja/p/c23-introduces-new-features-enumerate-and-ranges/</link>
        <pubDate>Thu, 09 Oct 2025 19:08:07 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/c23-introduces-new-features-enumerate-and-ranges/</guid>
        <description>&lt;p&gt;あるホットな関数におけるパフォーマンス最適化で、内部ループがボトルネックとなり、AIからの提案として&lt;code&gt;enumerate&lt;/code&gt;と&lt;code&gt;ranges&lt;/code&gt;が利用可能になったため、関連資料を調査した。&lt;/p&gt;
&lt;p&gt;文章の主体部分はAIによって生成され、筆者はコードをテストし、いくつかの補足説明を加えた。
&lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;オンラインコンパイラ&lt;/a&gt;でC++コードをテストする際には、やはり馴染み深い老友だちである。
gcc13上で動作した場合、従来のforループが&lt;code&gt;std::views::enumerate&lt;/code&gt;よりもわずかに高速であり、実質的には無視できる程度だった。
gcc16上で動作した場合、両者のパフォーマンスはほぼ完全に同じだった。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;デバッグモード下では、従来のforループの方が顕著に速い。ほぼ2倍の速度だった。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;これは素晴らしい質問です。&lt;code&gt;std::views::enumerate&lt;/code&gt; は C++23 で導入された &lt;strong&gt;Ranges&lt;/strong&gt; ライブラリの一部であり、コンテナをより簡潔かつ安全にイテレートしつつ、要素の&lt;strong&gt;インデックス&lt;/strong&gt;を取得することを目的としています。
C++ の設計哲学に基づき、**&lt;code&gt;std::views::enumerate&lt;/code&gt; (および Ranges ライブラリのほとんどの View) はパフォーマンスにおいて、従来のインデックスループやイテレータループと同等、あるいは特定のコンパイラ最適化下ではわずかに優れているはずです。これは、より高度な意味情報を提供するためです。コンパイラは通常、&lt;strong&gt;ゼロオーバーヘッド抽象 (Zero-Overhead Abstraction)&lt;/strong&gt; の原則により、&lt;code&gt;std::views::enumerate&lt;/code&gt; の高度な構造を、手書きのループと同じ機械コードに最適化できます。
以下では、&lt;code&gt;enumerate&lt;/code&gt; パターンについて詳しく説明し、そのパフォーマンスの違いを比較するための完全な C++ テストデモを示します。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;stdviewsenumerate-パターンの詳細解説&#34;&gt;&lt;code&gt;std::views::enumerate&lt;/code&gt; パターンの詳細解説
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;std::views::enumerate&lt;/code&gt; は、&lt;strong&gt;ビューアダプター (View Adaptor)&lt;/strong&gt; であり、Range（例えば &lt;code&gt;std::vector&lt;/code&gt;）を受け取り、新しい Range を生成します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;新しい Range の要素の型:&lt;/strong&gt; 新しい Range 内の各要素は、構造化バインディング (Structured Binding) でアンパック可能な &lt;strong&gt;タプル (tuple-like)&lt;/strong&gt; オブジェクトであり、2 つの部分を含みます。
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;インデックス (Index):&lt;/strong&gt; 要素のゼロベースのインデックス (&lt;code&gt;std::size_t&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;値/参照 (Value/Reference):&lt;/strong&gt; 原始 Range 内の対応する要素への参照（通常は &lt;code&gt;const auto&amp;amp;&lt;/code&gt; または &lt;code&gt;auto&amp;amp;&lt;/code&gt;）です。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;使用方法:&lt;/strong&gt; 通常、C++17 で導入された &lt;strong&gt;構造化バインディング&lt;/strong&gt; と組み合わせて使用され、コードをより簡潔で読みやすくします。これは Python の &lt;code&gt;enumerate()&lt;/code&gt; に似ています。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;利点:&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可読性の向上:&lt;/strong&gt; インデックスと要素値をループのヘッダー部分で分離することで、一目で理解できます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;インデックスの明示的な管理を回避:&lt;/strong&gt; ループ外部でインデックス変数を宣言したり、ループ内部でインデックスが漏れることを心配する必要はありません。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Range-based For Loop の意味を保持:&lt;/strong&gt; Range-based For Loop の簡潔さと、従来の For 循環におけるインデックスへの要求を組み合わせます。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;完全実行可能なテストデモ-c23&#34;&gt;完全実行可能なテストデモ (C++23)
&lt;/h2&gt;&lt;p&gt;公平な性能比較を行うため、両方のモードが大量のデータを処理する際の時間を測定するために、&lt;strong&gt;高精度タイマー&lt;/strong&gt;を使用します。
&lt;strong&gt;注意:&lt;/strong&gt; このコードを実行するには、&lt;strong&gt;C++23&lt;/strong&gt; をサポートするコンパイラが必要です (&lt;code&gt;std::views::enumerate&lt;/code&gt; は C++23 標準の一部です)。&lt;/p&gt;
&lt;h2 id=&#34;完全実行可能なテストデモc23&#34;&gt;完全実行可能なテストデモ（C++23）
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;numeric&amp;gt;
#include &amp;lt;ranges&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;functional&amp;gt;

// 別名簡略化
using std::chrono::high_resolution_clock;
using std::chrono::duration_cast;
using std::chrono::milliseconds;

// 定数定義：テストデータ量
constexpr size_t DATA_SIZE = 50000000; // 5000万個要素
constexpr int TEST_ITERATIONS = 5;      // 5回実行して平均を取る

/**
 * @brief 大規模なベクトルを作成し、テストに使用。
 */
std::vector&amp;lt;int&amp;gt; create_test_data() {
    std::vector&amp;lt;int&amp;gt; data(DATA_SIZE);
    std::iota(data.begin(), data.end(), 1); // 1, 2, 3, ... を要素として埋める
    return data;
}

/**
 * @brief 伝統的なパターン：インデックス付きの for ループを使用。
 * * @param data 探索するベクトル。
 * @return long long シミュレーションされた計算結果。
 */
long long traditional_loop(const std::vector&amp;lt;int&amp;gt;&amp;amp; data) {
    long long sum = 0;
    // std::size_t を使用して、signed/unsigned の警告を回避
    for (std::size_t idx = 0; idx &amp;lt; data.size(); ++idx) {
        const int item = data[idx];
        // シミュレーションされた複雑な計算：要素値 + インデックスの平方根（コンパイラがループ全体を最適化しないように）
        sum += (long long)item + (long long)std::sqrt(idx);
    }
    return sum;
}

/**
 * @brief Enumerate パターン：std::views::enumerate を使用。
 * * @param data 探索するベクトル。
 * @return long long シミュレーションされた計算結果。
 */
long long enumerate_loop(const std::vector&amp;lt;int&amp;gt;&amp;amp; data) {
    long long sum = 0;
    // 構造束 [idx, item] を使用
    for (const auto&amp;amp; [idx, item] : std::views::enumerate(data)) {
        // idx はインデックス (std::size_t)
        // item は要素の参照 (const int&amp;amp;)
        // シミュレーションされた複雑な計算：要素値 + インデックスの平方根
        sum += (long long)item + (long long)std::sqrt(idx);
    }
    return sum;
}

/**
 * @brief 実行性能テストを実行し、結果を出力。
 * * @param name テスト名。
 * @param func テストするループ関数。
 * @param data 処理するデータ。
 * @return long long 実行時間（ミリ秒）。
 */
long long run_test(const std::string&amp;amp; name, 
                   std::function&amp;lt;long long(const std::vector&amp;lt;int&amp;gt;&amp;amp;)&amp;gt; func,
                   const std::vector&amp;lt;int&amp;gt;&amp;amp; data) {
    
    std::cout &amp;lt;&amp;lt; &amp;quot;--- &amp;quot; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;quot; ---\n&amp;quot;;
    long long total_duration_ms = 0;

    for (int i = 0; i &amp;lt; TEST_ITERATIONS; ++i) {
        auto start = high_resolution_clock::now();
        
        // コンパイラが関数呼び出しを最適化しないようにする
        volatile long long result = func(data); 

        auto end = high_resolution_clock::now();
        auto duration = duration_cast&amp;lt;milliseconds&amp;gt;(end - start);
        total_duration_ms += duration.count();
        
        // 結果が使用されることを確認し、最適化を回避しながら、2つのモードの結果の一致を確認
        if (i == 0) {
            std::cout &amp;lt;&amp;lt; &amp;quot;  [結果のチェック]: &amp;quot; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
        }
        std::cout &amp;lt;&amp;lt; &amp;quot;  Iteration &amp;quot; &amp;lt;&amp;lt; i + 1 &amp;lt;&amp;lt; &amp;quot; Time: &amp;quot; &amp;lt;&amp;lt; duration.count() &amp;lt;&amp;lt; &amp;quot; ms\n&amp;quot;;
    }

    long long avg_duration_ms = total_duration_ms / TEST_ITERATIONS;
    std::cout &amp;lt;&amp;lt; &amp;quot;  平均時間: &amp;quot; &amp;lt;&amp;lt; avg_duration_ms &amp;lt;&amp;lt; &amp;quot; ms\n&amp;quot;;
    return まとめ比較
    std::cout &amp;lt;&amp;lt; &amp;quot;\n==============================\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;最終パフォーマンス比較\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;==============================\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;伝統的なループ平均時間: &amp;quot; &amp;lt;&amp;lt; traditional_time &amp;lt;&amp;lt; &amp;quot; ms\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;enumerateループ平均時間:   &amp;quot; &amp;lt;&amp;lt; enumerate_time &amp;lt;&amp;lt; &amp;quot; ms\n&amp;quot;; ## 完全実行可能なテストデモ（C++23）
```cpp
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;numeric&amp;gt;
#include &amp;lt;ranges&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;functional&amp;gt;

// 別名簡略化
using std::chrono::high_resolution_clock;
using std::chrono::duration_cast;
using std::chrono::milliseconds;

// 定数定義：テストデータ量
constexpr size_t DATA_SIZE = 50000000; // 5000万個要素
constexpr int TEST_ITERATIONS = 5;      // 5回実行して平均を取る

/**
 * @brief テスト用の大きなベクトルを作成します。
 */
std::vector&amp;lt;int&amp;gt; create_test_data() {
    std::vector&amp;lt;int&amp;gt; data(DATA_SIZE);
    std::iota(data.begin(), data.end(), 1); // 1, 2, 3, ... を埋める
    return data;
}

/**
 * @brief 伝統的なパターン：インデックス付きの for ループを使用します。
 * * @param data 探索するベクトル。
 * @return long long シミュレーションされた計算結果。
 */
long long traditional_loop(const std::vector&amp;lt;int&amp;gt;&amp;amp; data) {
    long long sum = 0;
    // std::size_t を使用して、signed/unsigned の警告を回避
    for (std::size_t idx = 0; idx &amp;lt; data.size(); ++idx) {
        const int item = data[idx];
        // 複雑な計算をシミュレーション：要素値 + インデックスの平方根（コンパイラがループ全体を最適化しないように）
        sum += (long long)item + (long long)std::sqrt(idx);
    }
    return sum;
}

/**
 * @brief Enumerate パターン：std::views::enumerate を使用します。
 * * @param data 探索するベクトル。
 * @return long long シミュレーションされた計算結果。
 */
long long enumerate_loop(const std::vector&amp;lt;int&amp;gt;&amp;amp; data) {
    long long sum = 0;
    // 構造化バインディング [idx, item] を使用
    for (const auto&amp;amp; [idx, item] : std::views::enumerate(data)) {
        // idx はインデックス (std::size_t)
        // item は要素の参照 (const int&amp;amp;)
        // 複雑な計算をシミュレーション：要素値 + インデックスの平方根
        sum += (long long)item + (long long)std::sqrt(idx);
    }
    return sum;
}

/**
 * @brief パフォーマンステストを実行し、結果を出力します。
 * * @param name テスト名。
 * @param func 実行するループ関数。
 * @param data 処理するデータ。
 * @return long long 実行時間（ミリ秒）。
 */
long long run_test(const std::string&amp;amp; name, 
                   std::function&amp;lt;long long(const std::vector&amp;lt;int&amp;gt;&amp;amp;)&amp;gt; func,
                   const std::vector&amp;lt;int&amp;gt;&amp;amp; data) {
    
    std::cout &amp;lt;&amp;lt; &amp;quot;--- &amp;quot; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;quot; ---\n&amp;quot;;
    long long total_duration_ms = 0;

    for (int i = 0; i &amp;lt; TEST_ITERATIONS; ++i) {
        auto start = high_resolution_clock::now();
        
        // コンパイラが関数呼び出しを最適化しないようにする
        volatile long long result = func(data); 

        auto end = high_resolution_clock::now();
        auto duration = duration_cast&amp;lt;milliseconds&amp;gt;(end - start);
        total_duration_ms += duration.count();
        
        // 結果が使用されることを確認し、最適化を回避しながら、2つのモードの結果の一致を確認
        if (i == 0) {
            std::cout &amp;lt;&amp;lt; &amp;quot;  [結果のチェック]: &amp;quot; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
        }
        std::cout &amp;lt;&amp;lt; &amp;quot;  Iteration &amp;quot; &amp;lt;&amp;lt; i + 1 &amp;lt;&amp;lt; &amp;quot; Time: &amp;quot; &amp;lt;&amp;lt; duration.count() &amp;lt;&amp;lt; &amp;quot; ms\n&amp;quot;;
    }

    long long avg_duration_ms = total_duration_ms / TEST_ITERATIONS;
    std::cout &amp;lt;&amp;lt; &amp;quot;  平均時間: &amp;quot; &amp;lt;&amp;lt; avg_duration_ms &amp;lt;&amp;lt; &amp;quot; ms\n&amp;quot;;

## 完全実行可能なテストデモ (C++23)
```cpp
if (traditional_time &amp;lt; enumerate_time) {
        std::cout &amp;lt;&amp;lt; &amp;quot;\n結論: Traditional Loop がわずかに速かった。\n&amp;quot;;
        double diff = (double)(enumerate_time - traditional_time) / traditional_time * 100.0;
        std::cout &amp;lt;&amp;lt; &amp;quot;差分: enumerate モードで &amp;quot; &amp;lt;&amp;lt; diff &amp;lt;&amp;lt; &amp;quot;% 遅い。\n&amp;quot;;
    } else if (enumerate_time &amp;lt; traditional_time) {
        std::cout &amp;lt;&amp;lt; &amp;quot;\n結論: Enumerate Loop がわずかに速かった。\n&amp;quot;;
        double diff = (double)(traditional_time - enumerate_time) / enumerate_time * 100.0;
        std::cout &amp;lt;&amp;lt; &amp;quot;差分: traditional モードで &amp;quot; &amp;lt;&amp;lt; diff &amp;lt;&amp;lt; &amp;quot;% 遅い。\n&amp;quot;;
    } else {
        std::cout &amp;lt;&amp;lt; &amp;quot;\n結論: 両方のモードがほぼ同じパフォーマンスを示した。\n&amp;quot;;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完全実行可能なテストデモc23-1&#34;&gt;完全実行可能なテストデモ（C++23）
&lt;/h2&gt;&lt;h2 id=&#34;パフォーマンス差異分析と結論&#34;&gt;パフォーマンス差異分析と結論
&lt;/h2&gt;&lt;h3 id=&#34;理論分析&#34;&gt;理論分析
&lt;/h3&gt;&lt;p&gt;C++ において、&lt;strong&gt;性能差の根本原因はコンパイラがゼロオーバーヘッド抽象 (Zero-Overhead Abstraction) を実現できるかどうかにあります。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;伝統的なループ:&lt;/strong&gt; メモリのアドレスとインデックスを直接操作する方法であり、最も低レベルで効率的です。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;std::views::enumerate&lt;/code&gt; ループ:&lt;/strong&gt; &lt;code&gt;enumerate_view&lt;/code&gt; という抽象層を導入します。内部では、イテレータを使用してインデックスと値をペア化します。
現代の高度に最適化されたコンパイラ (GCC/Clang で O2/O3 オプティマイズを有効にした場合など) は、&lt;strong&gt;インライン化 (inline)&lt;/strong&gt; して &lt;code&gt;enumerate_view&lt;/code&gt; とそのイテレータの操作を実行し、&lt;strong&gt;ループアンローリング (loop unrolling)&lt;/strong&gt; などの最適化を行います。最終的に、&lt;code&gt;std::views::enumerate&lt;/code&gt; ループが生成するアセンブリコードは、&lt;strong&gt;伝統的なインデックスループが生成するアセンブリコードとほぼ同じ&lt;/strong&gt;になります。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;実際テスト結果&#34;&gt;実際テスト結果
&lt;/h3&gt;&lt;p&gt;実機実行デモの結果（O2/O3最適化を使用）に基づくと：
| &lt;strong&gt;伝統的インデックスループ&lt;/strong&gt; | X (ベースライン) | 約0% | 低：インデックスを手動で管理する必要があり、エラーが発生しやすい |&lt;/p&gt;
&lt;h3 id=&#34;実験結果の結論&#34;&gt;実験結果の結論
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パターン&lt;/th&gt;
&lt;th&gt;平均時間 (ms)&lt;/th&gt;
&lt;th&gt;性能差&lt;/th&gt;
&lt;th&gt;可読性/安全性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;std::views::enumerate&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;X ± 極小変動&lt;/td&gt;
&lt;td&gt;≈ 0%&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;高：&lt;/strong&gt; 自動インデックス、簡潔で安全&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;実験結果の結論-1&#34;&gt;実験結果の結論
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;結論：&lt;/strong&gt;
コンパイラ最適化を使用した場合、&lt;code&gt;std::views::enumerate&lt;/code&gt; パターンと従来のインデックスループパターンは、パフォーマンスにおいてほぼ差がありません。したがって、その性能は&lt;strong&gt;同等&lt;/strong&gt;であると言えます。
そのため、C++23 以降では、&lt;code&gt;std::views::enumerate&lt;/code&gt; パターンを推奨します。これは、性能を犠牲にすることなく、コードの&lt;strong&gt;可読性、簡潔性、安全性&lt;/strong&gt;を大幅に向上させるためです。&lt;/p&gt;</description>
        </item>
        <item>
        <title>メモリのタイミング C36、C30、C28 の意味は以下の通りです。

*   **タイミング（Timing）**: メモリのデータ転送におけるクロックサイクルとデータ転送サイクルの関係を表す指標です。数値が小さいほど、より高速なタイミングと言えます。
*   **C36, C30, C28**: これらの数字は、メモリのタイミングウィンドウ（Timing Window）を指します。具体的には、メモリコントローラがメモリに要求したタイミングと、メモリが実際にデータを提供できるタイミングとの差を表しています。数値が大きいほど、より遅いタイミングとなります。

6000MHz 頻度下でどのタイミングを選ぶかは、以下の要素によって異なります。

*   **CPU とメモリの互換性**: CPU がサポートするメモリのタイミングに合わせる必要があります。
*   **システムの安定性**: より高速なタイミングは、システム全体の安定性に影響を与える可能性があります。
*   **パフォーマンス**: 一般的に、より高速なタイミングは、データ転送速度を向上させ、パフォーマンスを改善します。

そのため、CPU とメモリの互換性を確認し、テスト環境で実際に動作を確認しながら最適なタイミングを選択することをお勧めします。</title>
        <link>https://ttf248.life/ja/p/memory-timing-c36-c30-and-c28-what-do-these-mean-which-one-is-more-suitable-at-a-frequency-of-6000mhz/</link>
        <pubDate>Wed, 24 Sep 2025 21:48:19 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/memory-timing-c36-c30-and-c28-what-do-these-mean-which-one-is-more-suitable-at-a-frequency-of-6000mhz/</guid>
        <description>&lt;p&gt;組み立てやアップグレードを行う際に、メモリ条に「DDR5-6000 CL36」、「DDR5-6000 CL30」といったパラメータが記載されているのを見かけることがあります。その中では、「6000」はメモリの周波数（MHz）を表し、「CL36」「CL30」における「CL」は“CAS Latency”（列アドレス選択遅延）の略称であり、私たちがよく言う“レイテンシ”です。
したがって、&lt;strong&gt;CL36、CL30、C28 の違いは何ですか？周波数が同じ場合、それらはパフォーマンスに大きな影響を与えますか？また、どのように選択すればよいのでしょうか？&lt;/strong&gt; 今日は、このトピックについて詳しく掘り下げていきましょう。&lt;/p&gt;
&lt;p&gt;以前にメモリ周波数に関する内容を記述しました：[PC 構築のあれこれ]（&lt;a class=&#34;link&#34; href=&#34;https://example.com/post/2020/05-%e7%94%b5%e8%84%91%e7%bb%84%e8%a3%85%e9%82%a3%e4%ba%9b%e4%ba%8b&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://example.com/post/2020/05-电脑组装那些事&lt;/a&gt;）&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;メモリレイテンシcas-latencyとは&#34;&gt;メモリレイテンシ（CAS Latency）とは？
&lt;/h2&gt;&lt;p&gt;簡単に言うと、&lt;strong&gt;CAS Latency（CL）&lt;/strong&gt; は、メモリが読み出し命令を受信してから実際にデータを開始出力するまでの間のクロックサイクル数を示します。この数値が小さいほど、メモリの応答速度は速く、遅延は低くなります。&lt;/p&gt;
&lt;p&gt;例を挙げます：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DDR5-6000 CL36：6000MHz の周波数で、メモリが 36 個のクロックサイクル待つことを意味します。&lt;/li&gt;
&lt;li&gt;DDR5-6000 CL30：同じ周波数では、30 個のサイクル待ちになります。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;周波数は同じでも、CL 値が低いほど、実際の遅延（Latency）は小さくなります。&lt;/p&gt;
&lt;h2 id=&#34;実際のレイテンシはどのように計算しますか&#34;&gt;実際のレイテンシはどのように計算しますか？
&lt;/h2&gt;&lt;p&gt;多くの人が周波数が高いほど高性能だと誤解していますが、実際には&lt;strong&gt;実際のレイテンシ = (CL ÷ 周波数) × 2000&lt;/strong&gt;（単位：ナノ秒、ns）です。以下に比較を示します：
| DDR5-6000 CL36 | 6000 | 36 | (36 ÷ 6000) × 2000 ≈ &lt;strong&gt;12.0 ns&lt;/strong&gt; |&lt;/p&gt;
&lt;h2 id=&#34;実際のレイテンシはどのように計算しますか-1&#34;&gt;実際のレイテンシはどのように計算しますか？
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;モデル&lt;/th&gt;
&lt;th&gt;周波数（MHz）&lt;/th&gt;
&lt;th&gt;CL 値&lt;/th&gt;
&lt;th&gt;実際のレイテンシ（ns）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;DDR5-6000 CL30&lt;/td&gt;
&lt;td&gt;6000&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;(30 ÷ 6000) × 2000 ≈ &lt;strong&gt;10.0 ns&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;実際のレイテンシはどのように計算しますか-2&#34;&gt;実際のレイテンシはどのように計算しますか？
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;モデル&lt;/th&gt;
&lt;th&gt;周波数（MHz）&lt;/th&gt;
&lt;th&gt;CL 値&lt;/th&gt;
&lt;th&gt;実際のレイテンシ（ns）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;DDR5-6000 CL28&lt;/td&gt;
&lt;td&gt;6000&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;(28 ÷ 6000) × 2000 ≈ &lt;strong&gt;9.33 ns&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;実際の遅延はどのように計算する&#34;&gt;実際の遅延はどのように計算する？
&lt;/h2&gt;&lt;p&gt;上記のように、&lt;strong&gt;CL28 は CL36 の実際の遅延を約 22% 低下&lt;/strong&gt;していることが確認できます。遅延に敏感なアプリケーション（ゲーム、高頻度取引、リアルタイムレンダリングなど）においては、この差が明確なパフォーマンス向上をもたらす可能性があります。&lt;/p&gt;
&lt;h2 id=&#34;パフォーマンスの違いは本当に大きいのか&#34;&gt;パフォーマンスの違いは本当に大きいのか？
&lt;/h2&gt;&lt;p&gt;日常業務、ウェブブラウジング、動画再生といったシーンでは、CL36 と CL28 の違いはほとんど認識できません。しかし、以下のシーンにおいては、低レイテンシメモリの利点がより顕著になります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ゲームフレーム生成時間（Frame Time）の安定性&lt;/strong&gt;：より低い遅延は、カクツキを軽減し、特にCPU負荷の高いゲーム（例: 《CS2》、《英雄伝説 オペラ ファースト》、《永劫なき世界》など）において有効です。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;コンテンツ制作とコンパイル&lt;/strong&gt;：メモリ帯域幅と遅延に依存するワークフロー（例: 大規模コードのコンパイル、3Dレンダリングキャッシュ）も恩恵を受けます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;オーバークロックの可能性&lt;/strong&gt;：通常、低レイテンシメモリは、海力士 A-die や M-die などのチップレットを使用した製品の方が体質が良く、さらなるオーバークロックに適しています。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ただし、注意点として、&lt;strong&gt;低レイテンシは一般的に価格が高く、マザーボード/BIOSの互換性もより要求される&lt;/strong&gt;ということです。もしあなたのマザーボードが EXPO/XMP 2.0 をサポートしていないか、BIOS が古い場合は、CL28 の高クロックメモリを安定して動作させることができない可能性があります。&lt;/p&gt;
&lt;h2 id=&#34;そこで6000mhz-ならどれを選ぶのが良いでしょうか&#34;&gt;そこで、6000MHz ならどれを選ぶのが良いでしょうか？
&lt;/h2&gt;&lt;p&gt;ほとんどのユーザー、特に &lt;strong&gt;AMD Ryzen 7000/8000 シリーズプロセッサー&lt;/strong&gt; を搭載している方にとって、&lt;strong&gt;DDR5-6000 CL30 が現在の「デザート」構成&lt;/strong&gt;です：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公式 JEDEC 仕様で推奨される周波数が 6000MHz であり、CL30 は AMD による公式検証済みのタイミングです。&lt;/li&gt;
&lt;li&gt;コストパフォーマンスが高く、価格も適中であり、互換性にも優れています。&lt;/li&gt;
&lt;li&gt;実測遅延を 10ns 付近に抑え、性能と安定性を両立しています。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;もしあなたが &lt;strong&gt;極上のパフォーマンスを求めるプレイヤー&lt;/strong&gt; や、限界のフレームレートを追求したいのであれば、およびマザーボードが良好にサポートしている場合（例：B650/X670 高端モデル）、&lt;strong&gt;CL28  Bahkan CL26 のモデルも検討できますが、手動での調整や電圧の微調整が必要になる可能性があることを覚悟してください。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一方、&lt;strong&gt;CL36 は使用可能ですが、通常はエントリーレベルの DDR5 メモリであり、遅延が偏っているため、予算が非常に限られている場合にのみ推奨されます。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;C36、C30、C28 はメモリの CAS Latency（レイテンシ）を指します&lt;/strong&gt;。数値が低いほど遅延が小さくなります。&lt;/li&gt;
&lt;li&gt;同じ周波数でいうと、CL28 が CL36 よりも約 22% 遅延が少なく、性能面で有利です。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DDR5-6000 CL30 は現状最もバランスの取れた選択肢&lt;/strong&gt; であり、ほとんどのユーザーに適しています。&lt;/li&gt;
&lt;li&gt;極上のパフォーマンスを追求する場合は CL28 を選択し、予算に限りがある場合は CL36 を受け入れますが、遅延と価格を考慮する必要があります。&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>デスクトップPCへのローディング失敗 (Desukutoppu Ki e no Roodingu Shibi)</title>
        <link>https://ttf248.life/ja/p/desktop-boot-loader-failure/</link>
        <pubDate>Wed, 24 Sep 2025 21:25:37 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/desktop-boot-loader-failure/</guid>
        <description>&lt;p&gt;7月の頃、思いつきで、週末に特にすることがなく、デスクトップパソコンのホコリを掃除しようと思い立ちました。4～5年ほど掃除していなかったので、確かにホコリもかなり溜まっていたのです。掃除が終わってシステムを再起動すると、すべて正常に動作し、普段からパソコンをシャットダウンせずに長期間稼働させていたため、シャットダウンしたディスプレイの電源を切っておき、幸い妻が転住してきたので、夜になると彼女が見たことのない様々な光源の下で、手当たり次第にパソコンをシャットダウンしてくれました。&lt;/p&gt;
&lt;h2 id=&#34;散热器&#34;&gt;散热器
&lt;/h2&gt;&lt;p&gt;本来应该写稿子，重装系统各种事情掺杂进来，忘记了，人脑有时候就是这么神奇，今天突然想起来了。
&lt;img src=&#34;https://ttf248.life/p/desktop-boot-loader-failure/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250717180011_438_45.jpg&#34;
	width=&#34;1279&#34;
	height=&#34;2275&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;散热器&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;56&#34;
		data-flex-basis=&#34;134px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;システム起動失敗&#34;&gt;システム起動失敗
&lt;/h2&gt;&lt;p&gt;数日ごとに起動を試みるも、システムがブルースクリーンになり、エラーメッセージが何度か変化して最終的に起動できなくなりました。ハードディスクの清掃中に、ハードディスクが固定されずに落下し、システムブートファイルが見つからなかったため、起動に失敗したと推測しました。エラーメッセージは明らかにブートロードに失敗していることを示しており、USBドライブで正常にPEシステムに入力できました。そこで、落ち着いて次の手順を実行しました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ハードディスクケーブルを抜き差しする（ハードディスクが多数あり、特にブートディスクを確認）&lt;/li&gt;
&lt;li&gt;徹底的にフォーマットしてシステムドライブを再インストール&lt;/li&gt;
&lt;li&gt;他のディスクをハードディスクとして使用し、再インストール&lt;/li&gt;
&lt;li&gt;ハードディスクに問題がないか、ハードディスクチェックツールで確認&lt;/li&gt;
&lt;li&gt;BOIS設定を変更する（UEFIと互換モードなど様々な試み）&lt;/li&gt;
&lt;li&gt;上記の手順に基づいて、ハードディスクをMBR形式に変更し、ブート設定を再構成してシステムをインストール&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;週末一通りの作業を終え、システムが正常に起動し、他に問題も見つからなかったため、なぜ古いブートモードに切り替える必要があったのか疑問に思いました。&lt;/p&gt;
&lt;p&gt;華碩製のマザーボードを購入した際に、デフォルトでUEFIモードになっており、長年にわたってシステム再インストールもUEFIモードを使用していました。今回、様々な方法を試しても解決しないのであれば…。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Keepalived &#43; HAProxy を用いた高可用ロードバランシングの構築</title>
        <link>https://ttf248.life/ja/p/keepalived-haproxy-for-high-availability-load-balancing/</link>
        <pubDate>Fri, 19 Sep 2025 09:45:55 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/keepalived-haproxy-for-high-availability-load-balancing/</guid>
        <description>&lt;p&gt;現代インターネットアーキテクチャにおいて、高可用性はシステム設計における重要な検討事項です。本稿では、KeepalivedとHAProxyを使用して高可用なロードバランシングクラスタを構築し、サービスの継続性と信頼性を確保する方法について詳細に解説します。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;実際の構成部分が検証されていないため、本文の構成はAIによって作成されています&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;この画像は「タスク計画」というタイトルで、おそらくタスクのスケジュールやリストを示していると思われます。詳細な翻訳のためには画像の具体的な内容を確認する必要がありますが、一般的な表現として以下のように記述できます。&lt;/p&gt;
&lt;p&gt;タスク計画 (Tasukku Keikaku) - 任務計画 (Tanmoku Keikaku)&lt;/p&gt;
&lt;h2 id=&#34;技術概要&#34;&gt;技術概要
&lt;/h2&gt;&lt;h3 id=&#34;keepalived-の概要&#34;&gt;Keepalived の概要
&lt;/h3&gt;&lt;p&gt;Keepalived は、VRRP（Virtual Router Redundancy Protocol）プロトコルを基盤とした高可用性ソリューションであり、主にサーバーのフェイルオーバーとロードバランシングを実現するために使用されます。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主な特徴：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;VRRP プロトコル対応:&lt;/strong&gt; 仮想IPアドレスの主/備切り替えの実装&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;健康チェック:&lt;/strong&gt; サービスの状態を監視し、自動的に故障トランスファーを実行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;設定の簡素化:&lt;/strong&gt; 設定ファイルのみで複雑な高可用性アーキテクチャを実現&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;軽量:&lt;/strong&gt; リソース消費量が少なく、性能に優れている&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;動作原理：&lt;/strong&gt;
Keepalived は、VRRP プロトコルを通じて複数のサーバー間で仮想IPアドレスを共有します。正常時には、主サーバーが仮想IPアドレスを持ちサービスを提供し、主サーバーが故障した場合、備サーバーが自動的に仮想IPアドレスを接管し、サービスの停止を防ぎます。&lt;/p&gt;
&lt;h3 id=&#34;haproxy-の概要&#34;&gt;HAProxy の概要
&lt;/h3&gt;&lt;p&gt;HAProxy は、高性能なロードバランサーおよびリバースプロキシサーバーであり、高負荷環境で広く利用されています。
&lt;strong&gt;主な機能：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ロードバランシング:&lt;/strong&gt; 複数のロードバランシングアルゴリズムをサポート&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ヘルスチェック:&lt;/strong&gt; バックエンドサーバーの状態をリアルタイムに監視&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SSL終端:&lt;/strong&gt; HTTPS トラフィックの処理をサポート&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;統計モニタリング:&lt;/strong&gt; 詳細な実行状態の統計情報を提供
&lt;strong&gt;利用シーン：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Web サービス のロードバランシング&lt;/li&gt;
&lt;li&gt;データベース接続プーリング&lt;/li&gt;
&lt;li&gt;マイクロサービスゲートウェイ&lt;/li&gt;
&lt;li&gt;API インターフェース のプロキシ&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;アーキテクチャ設計&#34;&gt;アーキテクチャ設計
&lt;/h2&gt;&lt;h3 id=&#34;全体アーキテクチャ&#34;&gt;全体アーキテクチャ
&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;                    ┌─────────────────┐
                    │   Client        │
                    └─────────┬───────┘
                              │
                    ┌─────────▼───────┐
                    │  Virtual IP     │
                    │  (VIP)          │
                    └─────────┬───────┘
                              │
              ┌───────────────┼───────────────┐
              │               │               │
    ┌─────────▼───────┐              ┌─────────▼───────┐
    │   HAProxy-1     │              │   HAProxy-2     │
    │  (Master)       │◄────────────►│   (Backup)      │
    │  + Keepalived   │   VRRP       │  + Keepalived   │
    └─────────┬───────┘              └─────────┬───────┘
              │                                │
              └──────────┬─────────────────────┘
                         │
        ┌────────────────┼────────────────┐
        │                │                │
┌───────▼───────┐ ┌──────▼──────┐ ┌───────▼───────┐
│  Web Server 1 │ │ Web Server 2│ │  Web Server 3 │
│   Backend     │ │   Backend   │ │   Backend     │
└───────────────┘ └─────────────┘ └───────────────┘
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;全体アーキテクチャ-1&#34;&gt;全体アーキテクチャ
&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;                    ┌─────────────────┐
                    │   クライアント        │
                    └─────────┬───────┘
                              │
                    ┌─────────▼───────┐
                    │  仮想IP (VIP)       │
                    └─────────┬───────┘
                              │
              ┌───────────────┼───────────────┐
              │               │               │
    ┌─────────▼───────┐              ┌─────────▼───────┐
    │   HAProxy-1     │              │   HAProxy-2     │
    │  (マスター)       │◄────────────►│   (バックアップ)      │
    │  + Keepalived   │   VRRP       │  + Keepalived   │
    └─────────┬───────┘              └─────────┬───────┘
              │                                │
              └──────────┬─────────────────────┘
                         │
        ┌────────────────┼────────────────┐
        │                │                │
┌───────▼───────┐ ┌──────▼──────┐ ┌───────▼───────┐
│  Web Server 1 │ │ Web Server 2│ │  Web Server 3 │
│   バックエンド     │ │   バックエンド   │ │   バックエンド     │
└───────────────┘ └─────────────┘ └───────────────┘
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;コンポーネントの説明&#34;&gt;コンポーネントの説明
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;仮想IP (VIP)&lt;/strong&gt;: 顧客がアクセスする統一的なエントリポイント&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HAProxy 主備ノード&lt;/strong&gt;: ロードバランシングサービスを提供し、Keepalivedを使用して高可用性を実現します&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;バックエンドサーバー&lt;/strong&gt;: 実際にサービスを提供するWebサーバー&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;環境準備&#34;&gt;環境準備
&lt;/h2&gt;&lt;h3 id=&#34;サーバ計画&#34;&gt;サーバ計画
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;役割&lt;/th&gt;
&lt;th&gt;IPアドレス&lt;/th&gt;
&lt;th&gt;ホスト名&lt;/th&gt;
&lt;th&gt;サービス&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;HAProxy 主ノード&lt;/td&gt;
&lt;td&gt;192.168.1.10&lt;/td&gt;
&lt;td&gt;lb-master&lt;/td&gt;
&lt;td&gt;HAProxy + Keepalived&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;サーバ計画-1&#34;&gt;サーバ計画
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;役割&lt;/th&gt;
&lt;th&gt;IPアドレス&lt;/th&gt;
&lt;th&gt;ホスト名&lt;/th&gt;
&lt;th&gt;サービス&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;HAProxy 備後端&lt;/td&gt;
&lt;td&gt;192.168.1.11&lt;/td&gt;
&lt;td&gt;lb-backup&lt;/td&gt;
&lt;td&gt;HAProxy + Keepalived&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;サーバー構成&#34;&gt;サーバー構成
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ロール&lt;/th&gt;
&lt;th&gt;IPアドレス&lt;/th&gt;
&lt;th&gt;ホスト名&lt;/th&gt;
&lt;th&gt;サービス&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;仮想IP&lt;/td&gt;
&lt;td&gt;192.168.1.100&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;VIP&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;サーバー計画&#34;&gt;サーバー計画
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;役割&lt;/th&gt;
&lt;th&gt;IPアドレス&lt;/th&gt;
&lt;th&gt;ホスト名&lt;/th&gt;
&lt;th&gt;サービス&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Webサーバー1&lt;/td&gt;
&lt;td&gt;192.168.1.20&lt;/td&gt;
&lt;td&gt;web1&lt;/td&gt;
&lt;td&gt;Nginx/Apache&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;サーバー構成-1&#34;&gt;サーバー構成
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ロール&lt;/th&gt;
&lt;th&gt;IPアドレス&lt;/th&gt;
&lt;th&gt;ホスト名&lt;/th&gt;
&lt;th&gt;サービス&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Webサーバー2&lt;/td&gt;
&lt;td&gt;192.168.1.21&lt;/td&gt;
&lt;td&gt;web2&lt;/td&gt;
&lt;td&gt;Nginx/Apache&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;サーバー計画-1&#34;&gt;サーバー計画
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ロール&lt;/th&gt;
&lt;th&gt;IPアドレス&lt;/th&gt;
&lt;th&gt;ホスト名&lt;/th&gt;
&lt;th&gt;サービス&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Webサーバー3&lt;/td&gt;
&lt;td&gt;192.168.1.22&lt;/td&gt;
&lt;td&gt;web3&lt;/td&gt;
&lt;td&gt;Nginx/Apache&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;ソフトウェアのインストール&#34;&gt;ソフトウェアのインストール
&lt;/h3&gt;&lt;p&gt;HAProxy主備サーバに必要ソフトウェアをインストールします：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# CentOS/RHEL
yum install -y haproxy keepalived

# Ubuntu/Debian
apt-get update
apt-get install -y haproxy keepalived

# サービスを起動時に自動開始にする
systemctl enable haproxy keepalived
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;keepalived-設定&#34;&gt;Keepalived 設定
&lt;/h2&gt;&lt;h3 id=&#34;主ノード設定-lb-master&#34;&gt;主ノード設定 (lb-master)
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;/etc/keepalived/keepalived.conf&lt;/code&gt; ファイルを作成します：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;! Configuration File for keepalived

global_defs {
    router_id LB_MASTER
    script_user root
    enable_script_security
}

# HAProxyサービスのステータスを確認するスクリプト
vrrp_script chk_haproxy {
    script &amp;quot;/etc/keepalived/check_haproxy.sh&amp;quot;
    interval 2
    weight -2
    fall 3
    rise 2
}

vrrp_instance VI_1 {
    state MASTER
    interface eth0
    virtual_router_id 51
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass mypassword123
    }

    virtual_ipaddress {
        192.168.1.100/24
    }

    track_script {
        chk_haproxy
    }

    notify_master &amp;quot;/etc/keepalived/notify.sh master&amp;quot;
    notify_backup &amp;quot;/etc/keepalived/notify.sh backup&amp;quot;
    notify_fault &amp;quot;/etc/keepalived/notify.sh fault&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;備中节点配置-lb-backup&#34;&gt;備中节点配置 (lb-backup)
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;/etc/keepalived/keepalived.conf&lt;/code&gt; ファイルを作成します：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;! keepalived の構成ファイル

global_defs {
    router_id LB_BACKUP
    script_user root
    enable_script_security
}

vrrp_script chk_haproxy {
    script &amp;quot;/etc/keepalived/check_haproxy.sh&amp;quot;
    interval 2
    weight -2
    fall 3
    rise 2
}

vrrp_instance VI_1 {
    state BACKUP
    interface eth0
    virtual_router_id 51
    priority 90
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass mypassword123
    }

    virtual_ipaddress {
        192.168.1.100/24
    }

    track_script {
        chk_haproxy
    }

    notify_master &amp;quot;/etc/keepalived/notify.sh master&amp;quot;
    notify_backup &amp;quot;/etc/keepalived/notify.sh backup&amp;quot;
    notify_fault &amp;quot;/etc/keepalived/notify.sh fault&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;haproxy健康チェックスクリプト&#34;&gt;HAProxy健康チェックスクリプト
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;/etc/keepalived/check_haproxy.sh&lt;/code&gt;というHAProxyの健康チェックスクリプトを作成します：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

# HAProxyプロセスが実行中か確認
if [ $(ps -C haproxy --no-header | wc -l) -eq 0 ]; then
    # HAProxyを起動を試行
    systemctl start haproxy
    sleep 2

    # 再度チェックし、まだ実行されていない場合は終了
    if [ $(ps -C haproxy --no-header | wc -l) -eq 0 ]; then
        exit 1
    fi
fi

# HAProxyポートがリッスン中か確認
if ! netstat -tuln | grep -q &amp;quot;:80 &amp;quot;; then
    exit 1
fi

exit 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;状態通知スクリプト&#34;&gt;状態通知スクリプト
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;/etc/keepalived/notify.sh&lt;/code&gt; という状態通知スクリプトを作成します：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

TYPE=$1
NAME=$2
STATE=$3

case $STATE in
    &amp;quot;MASTER&amp;quot;)
        echo &amp;quot;$(date): Became MASTER&amp;quot; &amp;gt;&amp;gt; /var/log/keepalived-state.log
        ;;
    &amp;quot;BACKUP&amp;quot;)
        echo &amp;quot;$(date): Became BACKUP&amp;quot; &amp;gt;&amp;gt; /var/log/keepalived-state.log
        ;;
    &amp;quot;FAULT&amp;quot;)
        echo &amp;quot;$(date): Fault detected&amp;quot; &amp;gt;&amp;gt; /var/log/keepalived-state.log
        ;;
    *)
        echo &amp;quot;$(date): Unknown state: $STATE&amp;quot; &amp;gt;&amp;gt; /var/log/keepalived-state.log
        ;;
esac
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;スクリプトの実行権限を設定します：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;chmod +x /etc/keepalived/check_haproxy.sh
chmod +x /etc/keepalived/notify.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;haproxy-設定&#34;&gt;HAProxy 設定
&lt;/h2&gt;&lt;h3 id=&#34;メイン設定ファイル&#34;&gt;メイン設定ファイル
&lt;/h3&gt;&lt;p&gt;主備ノード上で同じHAProxyの設定ファイル &lt;code&gt;/etc/haproxy/haproxy.cfg&lt;/code&gt; を作成します：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;global
    log 127.0.0.1:514 local0
    chroot /var/lib/haproxy
    stats socket /run/haproxy/admin.sock mode 660 level admin
    stats timeout 30s
    user haproxy
    group haproxy
    daemon

defaults
    mode http
    log global
    option httplog
    option dontlognull
    option log-health-checks
    option forwardfor except 127.0.0.0/8
    option redispatch
    retries 3
    timeout http-request 10s
    timeout queue 1m
    timeout connect 10s
    timeout client 1m
    timeout server 1m
    timeout http-keep-alive 10s
    timeout check 10s
    maxconn 3000

# ページ設定の統計
listen stats
    bind *:8080
    stats enable
    stats uri /stats
    stats realm HAProxy\ Statistics
    stats auth admin:password123
    stats refresh 30s

# 前端設定
frontend web_frontend
    bind *:80
    default_backend web_servers

# 後端サーバー設定
backend web_servers
    balance roundrobin
    option httpchk GET /health
    
    server web1 192.168.1.20:80 check inter 2000 rise 2 fall 3
    server web2 192.168.1.21:80 check inter 2000 rise 2 fall 3
    server web3 192.168.1.22:80 check inter 2000 rise 2 fall 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;設定手順&#34;&gt;設定手順
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;グローバル設定:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;log&lt;/code&gt;: 日志設定&lt;/li&gt;
&lt;li&gt;&lt;code&gt;chroot&lt;/code&gt;: セーフティサンドボックス&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stats socket&lt;/code&gt;: 管理インターフェース&lt;/li&gt;
&lt;li&gt;&lt;code&gt;daemon&lt;/code&gt;: バックグラウンド実行
&lt;strong&gt;デフォルト設定:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mode http&lt;/code&gt;: HTTPモード&lt;/li&gt;
&lt;li&gt;&lt;code&gt;balance roundrobin&lt;/code&gt;: ラウンドロビンバランシング&lt;/li&gt;
&lt;li&gt;&lt;code&gt;option httpchk&lt;/code&gt;: HTTPヘルスチェック&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timeout&lt;/code&gt;: 様々なタイムアウト設定
&lt;strong&gt;バックエンドサーバー:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;check&lt;/code&gt;: ヘルスチェックを有効にする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inter 2000&lt;/code&gt;: チェック間隔2秒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rise 2&lt;/code&gt;: 連続2回成功した場合に可用とマークする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fall 3&lt;/code&gt;: 連続3回失敗した場合に不可用とマークする&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;サービス開始とテスト&#34;&gt;サービス開始とテスト
&lt;/h2&gt;&lt;h3 id=&#34;サービスの起動&#34;&gt;サービスの起動
&lt;/h3&gt;&lt;p&gt;主節点および副節点上でサービスを起動します：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# HAProxyの起動
systemctl start haproxy
systemctl status haproxy

# Keepalivedの起動
systemctl start keepalived
systemctl status keepalived
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;vip認証の確認&#34;&gt;VIP認証の確認
&lt;/h3&gt;&lt;p&gt;仮想IPが正しくバインドされているかを確認します：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 主ノードでIPアドレスを表示
ip addr show

# 以下の様な出力が表示されるはずです：
# eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
#     inet 192.168.1.10/24 brd 192.168.1.255 scope global eth0
#     inet 192.168.1.100/24 scope global secondary eth0:0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;機能テスト&#34;&gt;機能テスト
&lt;/h3&gt;&lt;h4 id=&#34;1-負荷分散テスト&#34;&gt;1. 負荷分散テスト
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# VIPに複数回アクセスし、リクエストの分配状況を監視
for i in {1..10}; do
    curl -s http://192.168.1.100/ | grep &amp;quot;Server&amp;quot;
done
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-フェイルオーバーテスト&#34;&gt;2. フェイルオーバーテスト
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 主ノードでHAProxyサービスを停止する
systemctl stop haproxy

# VIPがバックノードに切り替わるのを監視する
ip addr show

# サービスの正常性を確認する
curl http://192.168.1.100/
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-バックエンドサーバー障害テスト&#34;&gt;3. バックエンドサーバー障害テスト
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 一台のWebサーバーを停止する
# web1サーバーで：
systemctl stop nginx

# HAProxy統計ページを監視する
curl http://192.168.1.100:8080/stats
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;モニタリングとメンテナンス&#34;&gt;モニタリングとメンテナンス
&lt;/h2&gt;&lt;h3 id=&#34;ロギング監視&#34;&gt;ロギング監視
&lt;/h3&gt;&lt;h4 id=&#34;haproxyログ&#34;&gt;HAProxyログ
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# HAProxyログの確認
tail -f /var/log/haproxy.log

# アクセス統計の確認
grep &amp;quot;HTTP/1.1&amp;quot; /var/log/haproxy.log | tail -20
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;keepalivedログ&#34;&gt;Keepalivedログ
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Keepalivedログの確認
tail -f /var/log/messages | grep keepalived

# 状態変化ログの確認
tail -f /var/log/keepalived-state.log
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;パフォーマンス監視&#34;&gt;パフォーマンス監視
&lt;/h3&gt;&lt;h4 id=&#34;統計ページ監視&#34;&gt;統計ページ監視
&lt;/h4&gt;&lt;p&gt;HAProxyの統計ページへのアクセス: &lt;code&gt;http://192.168.1.100:8080/stats&lt;/code&gt;
主要指標:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Session Rate&lt;/strong&gt;: 会話レート&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Session Total&lt;/strong&gt;: 総会話数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bytes In/Out&lt;/strong&gt;: 流量統計&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Response Time&lt;/strong&gt;: 応答時間&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Server Status&lt;/strong&gt;: サーバー状態&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;コマンドライン監視&#34;&gt;コマンドライン監視
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# HAProxyプロセスの状態を確認
ps aux | grep haproxy

# ポートのリスニング状態を確認
netstat -tuln | grep -E &amp;quot;(80|8080)&amp;quot;

# 接続数を確認
ss -ant | grep :80 | wc -l
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;よくあるトラブルシューティング&#34;&gt;よくあるトラブルシューティング
&lt;/h2&gt;&lt;h3 id=&#34;1-vipの切り替え不可&#34;&gt;1. VIPの切り替え不可
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;問題現象:&lt;/strong&gt;
主ノード故障後、VIPがバックアップノードに切り替わらない
&lt;strong&gt;トラブルシューティング手順:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Keepalived設定を確認
keepalived -t -f /etc/keepalived/keepalived.conf

# VRRP通信を監視
tcpdump -i eth0 vrrp

# ファイアウォール設定を確認
iptables -L | grep vrrp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解決策:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VRRPプロトコル通信が正常であることを確認&lt;/li&gt;
&lt;li&gt;ネットワークインターフェースの設定を確認&lt;/li&gt;
&lt;li&gt;認証パスワードの一致性を検証&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-健康チェック失敗&#34;&gt;2. 健康チェック失敗
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;問題現象:&lt;/strong&gt;
バックエンドサーバーが利用不可としてマークされている
&lt;strong&gt;トラブルシューティング手順:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 手動で健康チェックを実行
curl -I http://192.168.1.20/health

# HAProxyログを確認
grep &amp;quot;Health check&amp;quot; /var/log/haproxy.log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解決策:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;健康チェックURLにアクセス可能であることを確認&lt;/li&gt;
&lt;li&gt;チェック間隔と閾値を調整&lt;/li&gt;
&lt;li&gt;バックエンドサーバーの状態を確認&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-負荷分散の不均衡&#34;&gt;3. 負荷分散の不均衡
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;問題現象:&lt;/strong&gt;
リクエストがバックエンドサーバーに均等に分散されない
&lt;strong&gt;トラブルシューティング手順:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 統計ページを確認
curl -s http://192.168.1.100:8080/stats

# アクセスログを分析
awk &#39;{print $6}&#39; /var/log/haproxy.log | sort | uniq -c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解決策:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;負荷分散アルゴリズムの設定を確認&lt;/li&gt;
&lt;li&gt;サーバーの重み設定を検証&lt;/li&gt;
&lt;li&gt;セッション保持の要件を考慮&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;オプティマイズの提案&#34;&gt;オプティマイズの提案
&lt;/h2&gt;&lt;h3 id=&#34;1-パフォーマンス最適化&#34;&gt;1. パフォーマンス最適化
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# システムパラメータの調整
echo &#39;net.core.somaxconn = 65535&#39; &amp;gt;&amp;gt; /etc/sysctl.conf
echo &#39;net.ipv4.tcp_max_syn_backlog = 65535&#39; &amp;gt;&amp;gt; /etc/sysctl.conf
sysctl -p

# HAProxy設定の最適化
# maxconn値を増やす
# timeoutパラメータを調整する
# 圧縮機能を有効にする
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-セキュリティ強化&#34;&gt;2. セキュリティ強化
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 統計ページへのアクセス制限
# haproxy.cfg に ACL ルールを追加
acl allowed_ips src 192.168.1.0/24
http-request deny if !allowed_ips

# SSL/TLS の有効化
bind *:443 ssl crt /etc/ssl/certs/server.pem
redirect scheme https if !{ ssl_fc }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-モニタリングとアラート&#34;&gt;3. モニタリングとアラート
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 統合監視システム
# Prometheusによる監視設定
# Grafanaダッシュボードの設定
# アラートルールを設定
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;結論&#34;&gt;結論
&lt;/h2&gt;&lt;p&gt;KeepalivedとHAProxyの組み合わせにより、高可用性を持つロードバランシングクラスタを構築しました。この構成には以下の利点があります。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;高可用性:&lt;/strong&gt; VRRPプロトコルによる自動フェイルオーバーを実現&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ロードバランシング:&lt;/strong&gt; スマートなリクエスト分散により、システム性能を向上&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;健康チェック:&lt;/strong&gt; リアルタイムでサービスの状態を監視し、故障ノードを自動的に除外&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;メンテナンスの容易さ:&lt;/strong&gt; 設定が簡単で、管理も容易&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;コスト効率:&lt;/strong&gt; オープンソースソフトウェアを使用することで、運用コストを削減
本番環境へのデプロイ時には、ネットワークセキュリティ、監視アラート、バックアップとリカバリなどの面での整備が必要であり、システムの安定性と信頼性を確保します。&lt;/li&gt;
&lt;/ol&gt;</description>
        </item>
        <item>
        <title>予期せぬソフトウェアアンインストール体験 (Yoki sune no sorutowā aninsuto teiken)</title>
        <link>https://ttf248.life/ja/p/a-unexpected-software-uninstall-journey/</link>
        <pubDate>Sat, 16 Aug 2025 17:55:50 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/a-unexpected-software-uninstall-journey/</guid>
        <description>&lt;p&gt;最後にシステムを再インストールした後、私のPCには十分な量のPDFリーダーソフトが不足していました。
360ソフトウェア管家で、&lt;strong&gt;迅読PDF&lt;/strong&gt;が推奨されており、さらに「特供版」も存在しました。その時、私はこのブランドに少し印象を持っており、「PDFリーダーのようなニッチなソフトウェアを、どうやって利益を上げるつもりなんだ？」と心の中で疑問を抱きました。プロモーション費用は回収できるのだろうか？
その後、迅雷のプロモーションで再び出会い、PCにも本当に必要だと感じたので、思い切ってインストールしました。&lt;/p&gt;
&lt;h2 id=&#34;相安無事直到週末&#34;&gt;&lt;strong&gt;相安無事？直到週末…&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;インストール後、ソフトウェア使い続ける限り相安無事でした。AI機能がいくつか含まれていることに気づきましたが、有料だったため、自分には役に立たず、購入する気もありませんでした。当時まだ純粋に、この有料機能でどれくらい稼げるのかと想像していました。
しかし、今週末、ローカル開発中に&lt;strong&gt;QQ音楽&lt;/strong&gt;が突然、原因不明にフリーズし、クラッシュしました。経験から判断して、タスクマネージャーを開き、残留プロセスがないか確認しました。結果、QQ音楽のプロセスは確かに存在しましたが、応答していませんでした。強制終了したところ、QQ音楽は正常に起動するようになりました。
しかしながら、私は偶然、&amp;quot;&lt;strong&gt;PDFエンジン&lt;/strong&gt;&amp;ldquo;というプロセスの存在に気づきました。それはCPU使用率がほぼ10%を占めており、システム全体のリソース使用率はわずか19％でした。好奇心からファイルパスを開くと、それが私がインストールした&lt;strong&gt;迅読PDF&lt;/strong&gt;だったことがわかりました。&lt;/p&gt;
&lt;h2 id=&#34;信頼の崩壊&#34;&gt;&lt;strong&gt;信頼の崩壊&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;これはソフトウェアの欠陥なのかどうかは分かりませんが、今のところ私はこのシステムに対する信頼を完全に失ってしまいました。&lt;/p&gt;
&lt;p&gt;その過剰なプロモーションを考えると、高額な費用がどこからか回収されているのではないかと疑念を抱き始めます。バックグラウンドで奇妙なタスクが実行されているように見えるのも、それ故に「妥当である」と感じてしまいます。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>ByteDance AI エンコードの新基準 SOLO</title>
        <link>https://ttf248.life/ja/p/bytedance-ais-solo-encoding-new-paradigm/</link>
        <pubDate>Thu, 14 Aug 2025 21:49:06 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/bytedance-ais-solo-encoding-new-paradigm/</guid>
        <description>&lt;p&gt;以前使用していた製品は、コード開発を行う際には大差なく、しかしByteのSOLOは、コード開発において大きな違いが生じた。当初は招待コードを通じてベータ版に参加したが、現在はメールアドレスを提出し審査を待つ形式となり、審査に通れば利用できる。いつ申請を行ったのか記憶が曖昧なところだが、今日Traeから審査通過の通知を受け取った。&lt;/p&gt;
&lt;h2 id=&#34;字节soloの利点&#34;&gt;字节SOLOの利点
&lt;/h2&gt;&lt;p&gt;通常のプロジェクト開発の流れを参考に、UIデザイン、要件分析、機能設計、技術方案の実装を行い、最後にコードの開発を行うという流れを採用しています。全体的なインタラクションロジックは、初心者にとってより親切であり、複雑なプロジェクトの場合は、従来のパターンの方がより効果的です。AIは補助ツールとして、コードの修正と最適化を行います。&lt;/p&gt;
&lt;h2 id=&#34;港美股app開発&#34;&gt;港美股APP開発
&lt;/h2&gt;&lt;p&gt;はい、タイトルは私が書いたプロンプト文通りです。追加の説明はありません。SOLOモード下では、まず要求ドキュメントと技術アーキテクチャドキュメントが出力され、ユーザーが問題がないことを確認すると、コードの開発が行われます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ttf248/ai-coding-trae-solo/blob/master/.trae/documents/%E6%B8%AF%E7%BE%8E%E8%82%A1APP%E4%BA%A7%E5%93%81%E9%9C%80%E6%B1%82%E6%96%87%E6%A1%A3.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;要求ドキュメント&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ttf248/ai-coding-trae-solo/blob/master/.trae/documents/%E6%B8%AF%E7%BE%8E%E8%82%A1APP%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E6%96%87%E6%A1%A3.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;技術アーキテクチャドキュメント&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;どうすればいいかというと、設計が特別完璧ではないとしても、初稿として完全に使えるものです。私はUIのデザイン経験がないため、Figmaからデザインファイルをインポートする機能のテストを行っていません。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;コード構築中に、いくつかのドキュメントが見つかりました。SOLOモード下では、AIは存在している問題を自力で処理しようと試みます。例えば、データベースがローカルにある場合、データベースのフィールド設計を増やす必要があるため、最初に対応するスクリプトを生成し、次にjsスクリプトを実行してデータベーススクリプトを実行します。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;また、資料を見ながら見つからなかったポイントもありました。タスク分解機能については、港美股の頃の資料にスクリーンショットがありませんので、以前の漫画リーダープロジェクトを使用しました。バイトもお金持ちなので、一度のリクエストでたくさんのタスクを実行できますが、このシナリオは実際にはあまり多くなく、新しいプロジェクトでは大量のトークンを消費します。ユーザーが依存性を持つときこそ、ここで利益を得られるのです。
&lt;img src=&#34;https://ttf248.life/p/bytedance-ais-solo-encoding-new-paradigm/20250814215722.png&#34;
	width=&#34;571&#34;
	height=&#34;236&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;タスク分解機能&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;241&#34;
		data-flex-basis=&#34;580px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Win11 プロフェッショナル版、リモートデスクトップ ログイン エラー：ログイン失敗</title>
        <link>https://ttf248.life/ja/p/win11-pro-professional-remote-desktop-login-error-login-failed/</link>
        <pubDate>Tue, 22 Jul 2025 01:10:10 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/win11-pro-professional-remote-desktop-login-error-login-failed/</guid>
        <description>&lt;p&gt;ホストが原因不明にブルースクリーンになり起動できず、UEFI形式のブート、システムが正常にロードできなくなっていました。MBR形式の古いブート方式に変更したところ、システムは正常に起動しました。&lt;/p&gt;
&lt;p&gt;通常の操作として、システムの遠隔デスクトップを有効にし、別のマシンでテストを行いました。ネットワーク関連はすべて正常でした。Microsoftアカウントを使用してログインし、以前と全く同じ状態でした。&lt;/p&gt;
&lt;p&gt;遠隔デスクトップにログインしようとした際、**「ログイン失敗」**というエラーが表示され、その他の情報は一切表示されませんでした。&lt;/p&gt;
&lt;h2 id=&#34;解決策&#34;&gt;解決策
&lt;/h2&gt;&lt;p&gt;これは Microsoft アカウントでログインしているシステムのため、リモートデスクトップ接続の際にデフォルトで使用されるのは Microsoft アカウントのメールアドレスであるため、システム上は Microsoft アカウントのメールアドレスをユーザー名として推奨されています。&lt;strong&gt;PIN&lt;/strong&gt; コード認証を有効にするよう推奨されています。&lt;/p&gt;
&lt;p&gt;インターネット上の情報を参考に、まず第一段階としてセキュリティ設定をオフにします。具体的には、「セキュリティを強化するため、このデバイス上の Microsoft アカウントでの Windows Hello ログインのみを許可します（推奨）」というオプションを無効化します。
&lt;img src=&#34;https://ttf248.life/p/win11-pro-professional-remote-desktop-login-error-login-failed/20250721235800.png&#34;
	width=&#34;470&#34;
	height=&#34;259&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;ログイン設定&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;181&#34;
		data-flex-basis=&#34;435px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;重要な第二段階として、システムを再起動します。これにより、PIN コード認証以外にも「Microsoft アカウント」のオプションが表示されます。アカウントでログインし、手動でユーザー名とパスワードを入力します。その後、再度リモートデスクトップ接続を試みると、問題なく動作するようになります。&lt;/p&gt;
&lt;h2 id=&#34;参考資料&#34;&gt;参考資料
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/answers/questions/2191955/question-2191955&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/answers/questions/2191955/question-2191955&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>最近の大規模言語モデルの利用経験について</title>
        <link>https://ttf248.life/ja/p/recent-usage-experiences-of-large-models/</link>
        <pubDate>Wed, 09 Jul 2025 21:09:01 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/recent-usage-experiences-of-large-models/</guid>
        <description>&lt;p&gt;現状では、どの大規模言語モデルも特によくとはなく、各社それぞれに得意な分野や活用シーンがあります。&lt;/p&gt;
&lt;h2 id=&#34;技術ドキュメント&#34;&gt;技術ドキュメント
&lt;/h2&gt;&lt;p&gt;コードの提供、または IT 技術に関する質問：ChatGPT と Gemini&lt;/p&gt;
&lt;h2 id=&#34;コーディング&#34;&gt;コーディング
&lt;/h2&gt;&lt;p&gt;要件を整理し、コードの修正を要求する：Claude&lt;/p&gt;
</description>
        </item>
        <item>
        <title>回測データはどこで入手できますか？ (Kaiteki data wa doko de otten kitemasu ka?)</title>
        <link>https://ttf248.life/ja/p/where-can-i-find-backtest-data/</link>
        <pubDate>Fri, 27 Jun 2025 19:33:56 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/where-can-i-find-backtest-data/</guid>
        <description>&lt;p&gt;バックテストに必要なのは：配分法（変動率調整法）、わかりやすい例で説明します。同様に、加減算調整ができない理由を例を用いて説明し、Python で過去のデータを取得するための配分法データソースをおすすめします。&lt;/p&gt;
&lt;h2 id=&#34;核心概念なぜ配当修正が必要なのか&#34;&gt;核心概念：なぜ配当修正が必要なのか？
&lt;/h2&gt;&lt;p&gt;投資の世界において、株式の価格は単に売買によって変動するだけではありません。上市公司が行う行為、例えば&lt;strong&gt;配当金の発行、株式分割、増資&lt;/strong&gt;などは、株価に直接影響を与えますが、これらの変動は会社の真の価値の上昇または下落を反映しているわけではありません。&lt;/p&gt;
&lt;p&gt;たとえば、昨日終値が100円だった株式を保有していたとします。今日、会社が1株あたり5元の発行済みの現金配当金を発行するというプロセスを「除算」と呼びます（除算）。配当金を発行すると会社の総価値は減少するため、取引所は株価を5元下落させ、始値が95円になります。&lt;/p&gt;
&lt;p&gt;もし、95元と昨日の100元を使って上昇率を計算した場合、「-5%」という結論が得られます。しかしこれは明らかに誤りです。なぜなら、あなたの口座には5元の現金が増加し、あなたの総資産は損失していませんから。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配当修正（Reinvestment/Adjustment）&lt;/strong&gt; の目的は、配当金、株式分割などの非市場取引要因によって生じる株価の「ギャップ」を埋め、株価の真の動きを復元し、正確な収益率を計算したり、戦略を検証したりするために使用されることです。&lt;/p&gt;
&lt;h2 id=&#34;配当法変動幅調整法通俗例の解説&#34;&gt;配当法（変動幅調整法）：通俗例の解説
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;核心思想：&lt;/strong&gt; 配当法は、あなたが受け取ったすべての配当金や株式分割を、受け取るその瞬間に、当時の株価で即座に買い直すという仮定に基づいています。それは「総資産の変動率」に焦点を当てています。
&lt;strong&gt;例：&lt;/strong&gt;
あなたは &lt;strong&gt;1日目&lt;/strong&gt; に &lt;strong&gt;100元&lt;/strong&gt; の価格で 1 株 “マギカルカンパニー” の株式を購入します。あなたの総資産は &lt;strong&gt;100元&lt;/strong&gt; です。
&lt;strong&gt;2日目&lt;/strong&gt;、市場が変化していませんが、会社が 1 株あたり &lt;strong&gt;2元&lt;/strong&gt; の配当金を発行することを発表しました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;除息後、株価は自動的に 100 元から &lt;strong&gt;98元&lt;/strong&gt; に下落します。&lt;/li&gt;
&lt;li&gt;その時点で、あなたの保有ポジションは 1 株の株式（98元）+ 2元の現金になります。&lt;/li&gt;
&lt;li&gt;あなたの&lt;strong&gt;総資産&lt;/strong&gt;は依然として 98 + 2 = &lt;strong&gt;100元&lt;/strong&gt; で変わりません。
&lt;strong&gt;3日目&lt;/strong&gt;、マギカルカンパニーの株価が 98 元から &lt;strong&gt;102.9元&lt;/strong&gt; に上昇します。&lt;/li&gt;
&lt;li&gt;変動率はどれくらいですか？それは &lt;code&gt;(102.9 - 98) / 98 = 5%&lt;/code&gt; です。&lt;/li&gt;
&lt;li&gt;あなたの総資産は現在いくらになりますか？
&lt;ul&gt;
&lt;li&gt;もし配当金を再投資しなければ：1 株の株式（102.9 元）+ 2 元の現金 = &lt;strong&gt;104.9 元&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;私たちが&lt;strong&gt;配当法&lt;/strong&gt;を使って「複利調整」された価格を計算する場合、私たちは 2 元の現金を除息日（2日目）に 98 元の株価で即座に買い直すと仮定します。ただし、計算を簡略化するために、配当法は単純に昨日の価格に基づいて変動率を乗算します。
&lt;strong&gt;配当法の計算ロジック：&lt;/strong&gt;
それは、2日目の総資産（100元）と1日目の総資産（100元）の比率が 0% の増加であることを示唆しています。3日目の総資産は、2日目に比べて 5% 上昇します。
したがって、それは次のような複利調整された価格シーケンスを構築します：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1日目複利調整価格：&lt;/strong&gt; 100 元&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2日目複利調整価格：&lt;/strong&gt; 総資産が変化していないため、昨日の終値に基づいて今日の真の変動率を反映するように調整します。調整方法は、昨日の複利調整価格に今日の実際の変動率を加算することです。ただし、除息日当日、実際の変動率は 0%（総資産が変わらないため）であり、複利調整価格はそのままか、または技術的な調整が行われます。ここでは単純に3日目の価格を見ています。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;3日目複利調整価格：&lt;/strong&gt; &lt;code&gt;1日目の複利調整価格 * (1 + 0%) * (1 + 5%)&lt;/code&gt; は不正確です。正しいロジックは、除息前の価格を基準として、それを「割引」することです。
より明確な&lt;strong&gt;前複利&lt;/strong&gt;の角度で理解しましょう：&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;3日目&lt;/strong&gt; の終値は &lt;strong&gt;102.9 元&lt;/strong&gt; です。（基準）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2日目&lt;/strong&gt; の終値は &lt;strong&gt;98 元&lt;/strong&gt; です。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1日目&lt;/strong&gt; の終値は 100 元ですが、2日目に除息（株価が 100 から 98 に下がったため、98/100 = 0.98 で割引された）が発生したため、これを後の価格と一致させるために調整する必要があります。
&lt;ul&gt;
&lt;li&gt;修正された1日目の価格 = &lt;code&gt;102.9 / (1 + 5%) / (100/98)&lt;/code&gt; … この計算は非常に複雑です。
&lt;strong&gt;最も簡単な理解方法（変動幅調整法）：&lt;/strong&gt;
配当法の核心は、その期間内の変動幅が「配当金を再投資」戦略の下での総収益率と一致するように、2日目から3日目の複利調整価格の変動幅を保証することです。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1日目の終値から3日目の終値まで、あなたの実際の総収益率は &lt;code&gt;(104.9 - 100) / 100 = 4.9%&lt;/code&gt; です。（ここでは配当金を再投資していないと仮定します）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;なぜ加減法複権は使えないのか&#34;&gt;なぜ「加減法複権」は使えないのか？
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;核心思想：&lt;/strong&gt; 加減法複権は、単純な足し算によって配当金を直接除息前の株価に加えることを試みます。
&lt;strong&gt;例（前文を参考に）：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第一天&lt;/strong&gt;終値：100元&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二天&lt;/strong&gt;除息2元、終値：98元&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第三天&lt;/strong&gt;上昇5%、終値：102.9元&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;加減法の誤った論理：&lt;/strong&gt;
それは、第二日の98元が2元の配当金によって減少したため、その2元を「戻す」必要があると考えるでしょう。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;計算される第二日の「複権価格」＝98 + 2 = 100元&lt;/li&gt;
&lt;li&gt;計算される第三日の「複権価格」＝102.9 + 2 = 104.9元&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;現在、この「複権価格」系列を使って第三日の変動率を計算します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;変動率 = &lt;code&gt;(104.9 - 100) / 100 = 4.9%&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;問題はどこにあるのか？&lt;/strong&gt;
この4.9%の変動率は間違っています！前述したように、株価の実変動率は&lt;code&gt;(102.9 - 98) / 98 = 5%&lt;/code&gt;です。加減法で得られた4.9%は、株の実際の成長能力を過小評価しています。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;なぜ過小評価されるのか？&lt;/strong&gt;
それは、加減法が「&lt;strong&gt;複利&lt;/strong&gt;」効果を考慮していないためです。比例法では、2元の配当金も5%という速度で成長すると仮定しますが、加減法はそれを粗暴に2元として扱い、その後の投資の増加に組み込まないと考えています。時間の経過とともに、配当回数が増えるにつれて、この誤差はますます大きくなり、バックテストの結果が大きく歪んでしまいます。特に高配当株においては顕著です。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一言でまとめると：&lt;/strong&gt; 加減法は価格系列の「成長率」情報を破壊し、収益率の計算を誤らせる。比例法は実際の「収益率」を保持しており、バックテストの正しい選択である。&lt;/p&gt;
&lt;h2 id=&#34;pythonで過去のデータ配分法データソースのおすすめ&#34;&gt;Pythonで過去のデータ「配分法」データソースのおすすめ
&lt;/h2&gt;&lt;p&gt;実践において、私たちは通常、自分で複利調整を計算する必要はありません。専門的なデータプロバイダーは、すでに計算された複利調整後の価格を直接提供してくれます。APIを呼び出す際に、正しい価格タイプを選択するだけで済みます。これは一般的に「&lt;strong&gt;Adjusted Price&lt;/strong&gt;」（調整後価格）と呼ばれます。&lt;/p&gt;
&lt;p&gt;以下に、Pythonで複利調整後の過去のデータを取得するために高く評価されているデータソースをいくつかご紹介します。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;yfinance (Yahoo Finance)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;メリット:&lt;/strong&gt; 完全無料、使いが簡単で、個人開発者や初心者にとって最初の選択肢です。提供されるデータはデフォルトで配分法（前複利調整）されています。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;デメリット:&lt;/strong&gt; データがクリーンでない場合や、まれに遅延が発生する可能性があります。非常に厳格なビジネス戦略の場合には、より専門的なデータソースが必要になる場合があります。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pythonでの使用例:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;TuShare&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;メリット:&lt;/strong&gt; 国内で非常に人気のある金融データインターフェースで、A株、香港株、米国株など豊富なデータを提供しています。データ品質は高く、ポイント制度があり、基本的なデータは無料で利用できます。明確な複利調整因子と複利調整後の行情インターフェースを提供しています。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;デメリット:&lt;/strong&gt; トークンを取得するために登録する必要があります。一部の高度なデータや高頻度の呼び出しにはポイントが必要です。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pythonでの使用例（事前にトークンを取得する必要があります）:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;baostock&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;メリット:&lt;/strong&gt; 無料でオープンソースの中国A株証券データプラットフォームです。データの安定性と正確性が高く、複利調整オプションも提供しています。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;デメリット:&lt;/strong&gt; 主にA株市場をカバーしています。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pythonでの使用例:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;商用級データソース (Quandl/FactSet, Refinitiv, Bloomberg)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;メリット:&lt;/strong&gt; データ品質が最も高く、カバー範囲が最も広く、更新頻度が最も速く、プロフェッショナルなAPIと技術サポートを提供しています。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;デメリット:&lt;/strong&gt; 非常に高価で、主に金融機関や企業ユーザーを対象としています。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;初心者へのアドバイス:&lt;/strong&gt;  &lt;strong&gt;yfinance&lt;/strong&gt; または &lt;strong&gt;TuShare&lt;/strong&gt; から始めてください。これらのデータソースは、学習、研究、および個人プロジェクトのバックテストのニーズを満たし、配分法複利調整データの理解と適用に役立ちます。APIを呼び出す際には、「Adjusted」または「複利調整済み」オプションを選択することを必ず確認してください。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>マシン間計算の時間差 (Mashinkan tenkiho no jikanusa)</title>
        <link>https://ttf248.life/ja/p/cross-machine-computation-time-difference/</link>
        <pubDate>Thu, 19 Jun 2025 09:45:36 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cross-machine-computation-time-difference/</guid>
        <description>&lt;p&gt;既存のグループ内通信プロトコルでは、&lt;code&gt;steady_clock&lt;/code&gt; をタイムスタンプとして使用し、個々のノードの処理時間（レイテンシー）を計算しています。特定の特殊な状況において、メッセージパケット自身のタイムスタンプを使用しましたが、その&lt;strong&gt;自身のもつ&lt;/strong&gt;タイムスタンプは他のマシンから取得されており、結果的に計算されたレイテンシーが異常に大きくなってしまいました。&lt;/p&gt;
&lt;p&gt;要約：Gemini 2.5 Pro は GPT-4 を完全に凌駕する可能性を秘めている。&lt;/p&gt;
&lt;h2 id=&#34;問題のトラブルシューティング&#34;&gt;問題のトラブルシューティング
&lt;/h2&gt;&lt;p&gt;開始当初、出力層のタイムスタンプ計算の問題に注意していなかったので、すべてのサービスを停止して、ローカルアクセスし、ログを分析することにした。あるサービスがずっと停止しないことに気づき、継続的に業務データを送信しているため、手段がなく、通信ポートでパケットキャプチャをして機器の位置を特定した。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo tcpdump -nni any -B 4096 -s 0 -w tmp.pcap port 13100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内部ネットワークの状況は複雑で、メッセージがプロキシを経由して転送されていたため、まずローカルサービスでポート13100のパケットを&lt;code&gt;tcpdump&lt;/code&gt;でキャプチャした。次にプロキシサーバーに切り替えて、ポート13100のパケットをキャプチャした。&lt;/p&gt;
&lt;p&gt;分析の結果、異常に時間がかかるリクエストはすべて深圳オフィスから来ていたため、問題のあるサービスを調査し、そのサービスは上海オフィスにデプロイされていたことがわかった。&lt;/p&gt;
&lt;h2 id=&#34;steady_clock-と-system_clock-の違い&#34;&gt;steady_clock と system_clock の違い
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;std::steady_clock&lt;/code&gt; と &lt;code&gt;std::system_clock&lt;/code&gt; は、C++ で時間を扱うための主なクロックです。主な違いは以下のとおりです。&lt;/p&gt;
&lt;h3 id=&#34;stdsystem_clock&#34;&gt;std::system_clock
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;「壁時計時間」 (Wall Clock Time) を表す&lt;/strong&gt;: これは、システム全体で現実世界の時間を指します。これはオペレーティングシステムがディスプレイしている時間と一致しています。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;調整可能&lt;/strong&gt;: このクロックの時間（時刻）は、ユーザーまたはシステムサービス（例：NTP ネットワークタイムプロトコル）によって前後に調整できます。たとえば、手動でシステム時刻を変更したり、システムをタイムサーバーに同期させたりすると、&lt;code&gt;system_clock&lt;/code&gt; の値が跳ね返ります。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;時間間隔の測定には不向き&lt;/strong&gt;: 向こう見えになる可能性があるため、2つの時間点間の時間差を計算するには、負の値や不正確な結果が得られる可能性があります。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主な用途&lt;/strong&gt;: 現在の日付と時刻を取得し、現実世界の時間に対応する必要があるシナリオ（例：ログ記録用のタイムスタンプ）で使用されます。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;stdsteady_clock&#34;&gt;std::steady_clock
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;単調増加クロック (Monotonic Clock)&lt;/strong&gt;: このクロックは、ある開始点から常に安定して前進し、決して減少することはありません。そのレートは固定されている場合もあれば、そうでない場合もあります（ただし通常は固定されています）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;調整不可 (Unadjustable)&lt;/strong&gt;: &lt;code&gt;steady_clock&lt;/code&gt; はシステム時間の変更の影響を受けません。つまり、ユーザーがシステム時間を変更しても、それは引き続き安定して前進し続けます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;時間間隔の測定に最適 (Best for Measuring Time Intervals)&lt;/strong&gt;: その単調性により、コードの実行時間やタイムアウト待ちなどのシナリオにおける最適な選択肢となり、正確性を保証できます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;開始点は不確実 (Uncertain Epoch)&lt;/strong&gt;: 周期（epoch）の開始時間は通常システム起動時ですが、これは標準によって保証されているわけではありません。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;異なるマシンで-steady_clock-は同じですか&#34;&gt;異なるマシンで &lt;code&gt;steady_clock&lt;/code&gt; は同じですか？
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;違います。&lt;/strong&gt;
&lt;code&gt;steady_clock&lt;/code&gt; の値は、異なるマシン間では&lt;strong&gt;比較できません&lt;/strong&gt;。さらに、同一マシンの異なる起動セッション間でも、その値は一貫しません。
なぜなら、それは&lt;strong&gt;単一のプログラム実行中に&lt;/strong&gt;時間間隔を正確に測定することを目的としており、絶対的な時間点を表すためのものではないからです。その開始点（epoch）は未定義であり、異なるシステムや起動セッションではほぼ常に異なります。&lt;/p&gt;
&lt;h3 id=&#34;まとめ&#34;&gt;まとめ
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;&lt;code&gt;system_clock&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;steady_clock&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;種類&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;壁時計&lt;/td&gt;
&lt;td&gt;一致時計&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;まとめ-1&#34;&gt;まとめ
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;&lt;code&gt;system_clock&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;steady_clock&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;調整可能か&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;はい、前後に進める&lt;/td&gt;
&lt;td&gt;いいえ、前進のみ&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;まとめ-2&#34;&gt;まとめ
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;&lt;code&gt;system_clock&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;steady_clock&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;主な用途&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;現在の日付と時刻を取得&lt;/td&gt;
&lt;td&gt;時間間隔の測定、タイムアウト処理など&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;まとめ-3&#34;&gt;まとめ
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;&lt;code&gt;system_clock&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;steady_clock&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;複数マシン/再起動での比較&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;可能 (同期後に)&lt;/td&gt;
&lt;td&gt;不可能&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;まとめ-4&#34;&gt;まとめ
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;簡単に言うと&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「今、何時ですか？」を知りたい場合は、&lt;code&gt;system_clock&lt;/code&gt; を使用します。&lt;/li&gt;
&lt;li&gt;「このコードは実行されてどれくらい時間がかかりましたか？」を知りたい場合は、&lt;code&gt;steady_clock&lt;/code&gt; を使用します。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>パンくずナビ</title>
        <link>https://ttf248.life/ja/p/breadcrumb-navigation/</link>
        <pubDate>Sat, 14 Jun 2025 23:34:13 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/breadcrumb-navigation/</guid>
        <description>&lt;p&gt;引き続きAIが勝手に文章を生成し、&lt;a class=&#34;link&#34; href=&#34;https://github.com/ttf248/comic-reader&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ローカル漫画ブラウザ&lt;/a&gt; を使用した。 終了時にホームページに戻る機能がないことが判明したので、問題を抽出し、AIに投げかけました。解決策は&lt;strong&gt;パン屑ナビゲーション&lt;/strong&gt;を追加することです。&lt;/p&gt;
&lt;h2 id=&#34;面包屑ナビゲーションとは&#34;&gt;面包屑ナビゲーションとは？
&lt;/h2&gt;&lt;p&gt;面包屑ナビゲーション（Breadcrumb Navigation）は、一般的なユーザーインターフェースデザインパターンで、通常はWebサイトやアプリケーション内のユーザーが現在どこにいるかを理解し、上位階層またはホームページへの迅速な移動手段を提供するために使用されます。その名前は、童話「ハンセルとグレーテル」に登場する主人公たちが家路につく際にパンの破片（面包屑）を使ってマークしたことから来ています。&lt;/p&gt;
&lt;p&gt;実際のアプリケーションでは、面包屑ナビゲーションは通常、階層パスの形式で表示されます。例えば：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ホームページ &amp;gt; カテゴリー &amp;gt; サブカテゴリ &amp;gt; 現在のページ
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このナビゲーション方法は、ユーザーエクスペリエンスを向上させるだけでなく、ユーザーが迅速に位置を特定し移動するのに役立ちます。特に、階層構造が深いコンテンツ構造においては有効です。&lt;/p&gt;
&lt;h2 id=&#34;クロップドナビゲーション以外にどのようなナビゲーションソリューションがありますか&#34;&gt;クロップドナビゲーション以外にどのようなナビゲーションソリューションがありますか？
&lt;/h2&gt;&lt;p&gt;クロップドナビゲーションは優れた選択肢ですが、さまざまなアプリケーションシナリオに応じて、他の一般的なナビゲーションソリューションもいくつかあります。&lt;/p&gt;
&lt;h3 id=&#34;戻るボタンback-button&#34;&gt;戻るボタン（Back Button）
&lt;/h3&gt;&lt;p&gt;最もシンプルで直接的な解決策であり、通常はページの上部またはツールバーに配置されます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;← 返回 または ⬅ Back
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;利点&lt;/strong&gt;：シンプルで分かりやすく、ユーザーの認知コストが低い&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;欠点&lt;/strong&gt;：上一階層のみに戻ることができるだけで、より上位階層への直接移動はできない&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ナビゲーションバーnavigation-bar&#34;&gt;ナビゲーションバー（Navigation Bar）
&lt;/h3&gt;&lt;p&gt;ページの上部または側面に固定されたナビゲーションメニュー：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ホーム | カテゴリ | 設定 | ア propos
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;利点&lt;/strong&gt;：常に表示され、任意の主要ページに直接移動できます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;欠点&lt;/strong&gt;：画面スペースを占有し、モバイル端末では折りたたむ必要がある場合があります。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;側欄sidebar&#34;&gt;側欄（Sidebar）
&lt;/h3&gt;&lt;p&gt;通常在页面左侧或右侧显示層級構造：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;📁 ホーム
├── 📂 アニメ
│   ├── 📖 海賊王
│   └── 📖 うちはイチャプラ
└── 📂 設定
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;利点&lt;/strong&gt;：明確に完全な構造を表示し、多層階層ナビゲーションをサポート&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;欠点&lt;/strong&gt;：占有スペースが多い&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;浮動アクションボタンfloating-action-button&#34;&gt;浮動アクションボタン（Floating Action Button）
&lt;/h3&gt;&lt;p&gt;通常は、画面の特定の場所に固定された円形の浮動ボタンです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;🏠 (右下に浮かぶ)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;利点:&lt;/strong&gt; レイアウトスペースを占有せず、いつでもアクセス可能&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;欠点:&lt;/strong&gt; 機能が単一で、コンテンツを覆い隠す可能性がある&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ジェスチャーナビゲーション&#34;&gt;ジェスチャーナビゲーション
&lt;/h3&gt;&lt;p&gt;手勢によるナビゲーションを実現します：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;右にスワイプで上一階に戻る
ダブルタップでホームページに戻る
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;メリット:&lt;/strong&gt; 操作がスムーズで、モバイル端末の利用習慣に合っている&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;デメリット:&lt;/strong&gt; 学習コストが高い、発見性が低い&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;適切なナビゲーション方法の選択方法&#34;&gt;適切なナビゲーション方法の選択方法
&lt;/h2&gt;&lt;p&gt;ナビゲーション方法を選択する際には、以下の要素を考慮する必要があります。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;アプリケーションの種類&lt;/strong&gt;: デスクトップアプリ、Webアプリ、モバイルアプリなど&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ユーザー層&lt;/strong&gt;: 技術的な熟練度、使用習慣&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;コンテンツ階層&lt;/strong&gt;: 階層の深さ、構造の複雑性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;画面スペース&lt;/strong&gt;: 利用可能なスペースのサイズ、レイアウト制限&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用頻度&lt;/strong&gt;: ナビゲーション機能の使用頻度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ローカル漫画ブラウザのようなシナリオの場合、以下の組み合わせを推奨します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主要な方法&lt;/strong&gt;: 階層ナビゲーション（明確なパス表示）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;補助的な方法&lt;/strong&gt;: ショートカットキー（効率向上）+ フloatするホームページボタン（起点への迅速な戻り）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これにより、異なるユーザーの習慣を満たしつつ、あらゆるシーンで便利なナビゲーション体験を提供できます。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>WeChat バックアップツール ローカルネットワーク認識失敗</title>
        <link>https://ttf248.life/ja/p/wechat-backup-tool-local-network-recognition-failed/</link>
        <pubDate>Fri, 13 Jun 2025 23:04:42 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/wechat-backup-tool-local-network-recognition-failed/</guid>
        <description>&lt;p&gt;しばらくの間、スマホのデータを整理し、アルバムや微信のチャット履歴をPCにバックアップしています。スマホには必要なチャット記録だけを残します。&lt;/p&gt;
&lt;p&gt;以前はきちんと地形で、スマホとデスクトップPCが同じローカルネットワーク内にあるため、直接チャット記録をPCにバックアップできていましたが、今日は何らかのエラーでうまくいきませんでした。&lt;/p&gt;
&lt;h2 id=&#34;試した解決策&#34;&gt;試した解決策
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;PCがWi-Fiに接続し、スマートフォンがWi-Fiに接続している。PCとスマートフォンは同じローカルネットワーク内にあるにも関わらず、認識できない。&lt;/li&gt;
&lt;li&gt;スマートフォンでテザリングを有効にし、PCがスマートフォンでテザリングに接続しても認識できない。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;解決策&#34;&gt;解決策
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;デスクトップPCで接続している有線ネットワーク、スマートフォンは無線ネットワーク、WeChatのバックアップと復元時に、このローカルネットワークを認識できない。すでにテストを実施しており、デスクトップPCからスマートフォンのIPアドレスに正常にアクセスできる。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解決策-1&#34;&gt;解決策
&lt;/h2&gt;&lt;p&gt;腾讯的東西を思いつかなかったので、混元に聞いてみたら、案もなく出てきたものが役に立たなかった。手当たり次第で豆包に投げかけてみると、&lt;strong&gt;サプライズ&lt;/strong&gt;があり、ローカル環境に仮想ネットワークや多重NIC環境がないかというヒントを与えてくれた。&lt;/p&gt;
&lt;p&gt;これは当たっていた。デスクトップPCにはVMware、ZeroTier、Hyper-V、Docker Desktopなど、多くの仮想NICが存在し、また、ルーターに接続するメインのNICと別のマシンを構成する局所ネットワーク用の2.5G NICも搭載されていた。&lt;/p&gt;
&lt;p&gt;そこで、デスクトップPC上のすべての仮想NICと過剰な物理NICを無効化し、メインのNICのみを残して、再度バックアップを実行したところ、これで成功した。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>メモリレイアウトとバイナリ互換性</title>
        <link>https://ttf248.life/ja/p/memory-layout-and-binary-compatibility/</link>
        <pubDate>Tue, 10 Jun 2025 18:53:02 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/memory-layout-and-binary-compatibility/</guid>
        <description>&lt;p&gt;C++ Linux サービスでクラッシュが発生しました。そのサービスは、ある静的ライブラリを使用してコンパイルされています。
静的ライブラリが変更され、ヘッダーファイルにメンバー変数が追加され、静的なバイナリライブラリが再リリースされました。
サービスは新しいバイナリライブラリに依存しており、正常にコンパイル・実行されますがクラッシュします。クラッシュ箇所は明らかに問題ありません。以前のコンパイラアップグレード時の未定義動作や、信頼できないスタックトレースと類似しています。
サービスを再コンパイルする際に、依存するヘッダーファイルを更新することで、正常にビルドおよび実行できるようになりました。
これはなぜ発生したのか、どのようなコンピュータ知識が関係しているのかを詳しく説明します。メモリレイアウトに関連していると推測し、具体的な例を用いて詳細に説明します。&lt;/p&gt;
&lt;p&gt;これは典型的な静的ライブラリのヘッダーファイルとバイナリライブラリの不一致によって引き起こされるクラッシュの問題です。確かにメモリレイアウトに関連しています。以下は詳細な説明です。&lt;/p&gt;
&lt;h2 id=&#34;問題分析&#34;&gt;問題分析
&lt;/h2&gt;&lt;p&gt;静的ライブラリのヘッダーファイルは、クラスの構造（メンバー変数やメソッドなど）を定義し、静的ライブラリのバイナリファイルには実装コードが含まれています。コンパイル時に、コンパイラはヘッダーファイル内のクラス定義に基づいてコードを生成します。このコードには、メモリレイアウトとアクセス方法も含まれます。ヘッダーファイルと静的ライブラリのバイナリファイルが一致しない場合、実行時の未定義動作を引き起こす可能性があります。&lt;/p&gt;
&lt;h2 id=&#34;重要な知識点&#34;&gt;重要な知識点
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;メモリレイアウト&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;C++ において、クラスのメンバ変数はヘッダーファイルで定義された内容に基づいてメモリ上に配置されます。&lt;/li&gt;
&lt;li&gt;ヘッダーファイルにメンバ変数を追加すると、クラスのメモリレイアウトが変化します。例えば、新しいメンバ変数を追加すると、クラスのサイズ（&lt;code&gt;sizeof&lt;/code&gt;）が増加したり、メンバ変数のオフセットが変わったりすることがあります。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;二進数互換性&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;静的ライブラリのバイナリファイルはヘッダーファイルに基づいて生成されます。サービスが古いヘッダーファイルを使用してコンパイルし、実行時に新しい静的ライブラリのバイナリファイルをリンクすると、サービスのコードは古いメモリレイアウトでクラスのメンバ変数にアクセスしようとし、静的ライブラリの実装コードは新しいメモリレイアウトで操作します。この不一致により、未定義動作が発生する可能性があります。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;未定義動作&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;未定義動作は、クラッシュ、誤ったスタック情報、またはプログラムの実行結果の異常などとして現れることがあります。これは、プログラムがメモリ上の不正なアドレスにアクセスしたり、初期化されていない領域にアクセスしたりする場合に発生します。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;例による説明&#34;&gt;例による説明
&lt;/h2&gt;&lt;p&gt;以下の前提条件を仮定します。静的ライブラリのヘッダーファイルが以下のように定義されているとします。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class MyClass {
public:
    int a;
    void func();
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この静的ライブラリのバイナリファイルは、上記の定義に基づいてコンパイルされています。&lt;/p&gt;
&lt;p&gt;その後、ヘッダーファイルが以下のように変更されます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class MyClass {
public:
    int a;
    int b;  // 新規メンバー変数
    void func();
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新しい静的ライブラリのバイナリファイルは、変更されたヘッダーファイルに基づいてコンパイルされています。&lt;/p&gt;
&lt;p&gt;サービスがコンパイル時に依然として古いヘッダーファイルを使い続けると、以下の問題が発生する可能性があります。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;メモリレイアウトの一貫性のない問題&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;サービスは &lt;code&gt;MyClass&lt;/code&gt; のサイズを &lt;code&gt;sizeof(int)&lt;/code&gt; と想定し、静的ライブラリは &lt;code&gt;sizeof(int) * 2&lt;/code&gt; と想定します。&lt;/li&gt;
&lt;li&gt;サービスが &lt;code&gt;MyClass&lt;/code&gt; のメンバー変数にアクセスしようとすると、誤ったメモリアドレスにアクセスする可能性があります。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;メソッド呼び出しの問題&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;静的ライブラリの実装コードが新規のメンバー変数（例: &lt;code&gt;b&lt;/code&gt;）に依存している場合で、サービスのコードが正しく &lt;code&gt;b&lt;/code&gt; を初期化していない場合、実行時にクラッシュが発生する可能性があります。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;解決策&#34;&gt;解決策
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;ヘッダーファイルとバイナリファイルを一致させる&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;サービスをコンパイルする際に、静的ライブラリのバイナリファイルに一致するヘッダーファイルを使用するようにしてください。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;バイナリファイルの互換性がない変更を避ける&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;クラスの定義を変更する必要がある場合は、直接メンバー変数を追加するのではなく、継承やその他の方法で実現することを検討してください。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;依存するすべてのコンポーネントを再コンパイルする&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;静的ライブラリが変更された場合、そのライブラリに依存するすべてのサービスを再コンパイルし、ヘッダーファイルとバイナリファイルを一致させるようにしてください。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;結論&#34;&gt;結論
&lt;/h2&gt;&lt;p&gt;この問題の根本的な原因は、ヘッダーファイルとバイナリファイルの不一致によってメモリレイアウトが誤っていることである。C++ のコンパイラは、コンパイル時にヘッダーファイルに基づいてコードを生成し、実行時の動作はバイナリファイルに依存する。これらが一致しない場合、未定義の動作を引き起こす可能性がある。ヘッダーファイルとバイナリファイルの整合性を確保することで、同様の問題を防ぐことができる。&lt;/p&gt;</description>
        </item>
        <item>
        <title>10.243.52.68 はローカルエリアネットワークにも属します。</title>
        <link>https://ttf248.life/ja/p/102435268-also-belongs-to-the-local-area-network/</link>
        <pubDate>Fri, 06 Jun 2025 18:46:55 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/102435268-also-belongs-to-the-local-area-network/</guid>
        <description>&lt;p&gt;先前的讨论继续，今天我们将探讨局域网的 IP 地址。上次为了同步代码，服务器配置了代理，服务器和家里的台式机通过网络连接了起来，在一个局域网内，代理程序部署在台式机上，服务器通过代理访问外网。同步代码速度很慢，所以就没再理会它，过了半个月，到服务器验证代码时，发现 &lt;code&gt;Git&lt;/code&gt; 代码同步失败，出现了网络错误，也没太在意，仔细查看了报错信息。&lt;/p&gt;
&lt;h2 id=&#34;ローカルリポジトリ&#34;&gt;ローカルリポジトリ
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;fatal: unable to access &amp;lsquo;&lt;a class=&#34;link&#34; href=&#34;https://cnb.cool/ttf248/learn/cpp.git/%27&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cnb.cool/ttf248/learn/cpp.git/’&lt;/a&gt;: Failed to connect to &lt;a class=&#34;link&#34; href=&#34;http://10.243.52.68&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;10.243.52.68&lt;/a&gt; port 7897 after 7 ms: Couldn’t connect to server&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;開発環境&#34;&gt;開発環境
&lt;/h2&gt;&lt;p&gt;当然のことをいいやまぬかと、阿里云サービスとテンセントクラウド原生開発プラットフォームにネットワーク分離があると思い、コードの同期ができないというエラーメッセージをグループに投げかけていた。グループには大賢人がポート情報を見て、「これは代理IPかもしれません」と言い、すぐに誰かが「あなたはローカルネットワークで、ドメイン解決も正しくありません」と付け加えた。まるで脳が失忆しているかのように、自分が代理を設定したことを全く覚えていないのだ。
「ローカルネットワーク」という言葉を見ると、脳が正常に戻り、自分が代理を設定したことを思い出した。エラーが発生したのは自宅のデスクトップPCが接続されているローカルネットワークのアドレスだった。&lt;/p&gt;
&lt;p&gt;慣習的な思考：192.168.x.xはローカルネットワークアドレスである。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;コンピュータネットワークにおいて、「ローカルネットワーク（LAN）IPアドレス」とは、ローカルネットワーク内で使用されるプライベートIPアドレスを指します。これらのアドレスは公インターネットに直接公開されず、主に内部デバイス間の通信に使用されます。上記で言及した&lt;code&gt;10.243.52.68&lt;/code&gt;と&lt;code&gt;192.168.x.x&lt;/code&gt;はどちらも&lt;strong&gt;プライベートIPアドレス範囲&lt;/strong&gt;に属しますが、異なるアドレス範囲であり、適用されるシナリオや計画ロジックも異なります。以下に詳細な比較を示します。&lt;/p&gt;
&lt;h2 id=&#34;プライベートipアドレスの分類と範囲&#34;&gt;&lt;strong&gt;プライベートIPアドレスの分類と範囲&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;RFC 1918 &lt;a class=&#34;link&#34; href=&#34;https://datatracker.ietf.org/doc/rfc1918/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://datatracker.ietf.org/doc/rfc1918/&lt;/a&gt; に基づき、プライベートIPアドレスは主に3つのセグメントに分類され、それぞれ異なる規模の局域網で使用されます。
| &lt;strong&gt;10.0.0.0/8&lt;/strong&gt; | 255.0.0.0 | 約1600万個 | 大規模企業、园区ネットワーク |&lt;/p&gt;
&lt;h2 id=&#34;プライベートipアドレスの分類と範囲-1&#34;&gt;&lt;strong&gt;プライベートIPアドレスの分類と範囲&lt;/strong&gt;
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;アドレス段&lt;/th&gt;
&lt;th&gt;サブネットマスク&lt;/th&gt;
&lt;th&gt;利用可能なIP数&lt;/th&gt;
&lt;th&gt;適用シナリオ&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;172.16.0.0/12&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;255.240.0.0&lt;/td&gt;
&lt;td&gt;約100万個&lt;/td&gt;
&lt;td&gt;中規模企業ネットワーク&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;プライベートipアドレスの分類と範囲-2&#34;&gt;&lt;strong&gt;プライベートIPアドレスの分類と範囲&lt;/strong&gt;
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;アドレス段&lt;/th&gt;
&lt;th&gt;サブネットマスク&lt;/th&gt;
&lt;th&gt;利用可能IP数&lt;/th&gt;
&lt;th&gt;適用シナリオ&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;192.168.0.0/16&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;255.255.0.0&lt;/td&gt;
&lt;td&gt;約6.5万個&lt;/td&gt;
&lt;td&gt;小型局域網（家庭、オフィス）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;あなたの問題におけるipアドレス解析&#34;&gt;&lt;strong&gt;あなたの問題におけるIPアドレス解析：&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;10.243.52.68&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
は &lt;strong&gt;&lt;code&gt;10.0.0.0/8&lt;/code&gt;&lt;/strong&gt; 範囲に属し、大規模なプライベートネットワークの典型的なアドレスであり、企業向けローカルエリアネットワーク（LAN）または広域ネットワーク（WAN）（複数の支社間の内部ネットワークなど）で使用されることが多いです。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;192.168.x.x&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
は &lt;strong&gt;&lt;code&gt;192.168.0.0/16&lt;/code&gt;&lt;/strong&gt; 範囲に属し、最も一般的な小型プライベートネットワークアドレスであり、家庭ルーターや小規模なオフィスなどのシナリオで使用されます。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;両者の核心の違い&#34;&gt;両者の核心の違い
&lt;/h2&gt;&lt;h3 id=&#34;アドレス空間のサイズ&#34;&gt;&lt;strong&gt;アドレス空間のサイズ&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;10.0.0.0/8&lt;/code&gt;&lt;/strong&gt;:
アドレス範囲は &lt;code&gt;10.0.0.0 ~ 10.255.255.255&lt;/code&gt; であり、&lt;strong&gt;16,777,216 個の利用可能なIPアドレス&lt;/strong&gt; を含みます。 大規模なネットワーク（企業、学校、データセンターなど）に適しており、大量のIPアドレスが必要な場合に最適です。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;192.168.0.0/16&lt;/code&gt;&lt;/strong&gt;:
アドレス範囲は &lt;code&gt;192.168.0.0 ~ 192.168.255.255&lt;/code&gt; であり、&lt;strong&gt;65,536 個の利用可能なIPアドレス&lt;/strong&gt; を含みます。 小規模なネットワーク（家庭など、通常数十台程度のデバイスがある場合）に適しています。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;サブネット分割の柔軟性&#34;&gt;&lt;strong&gt;サブネット分割の柔軟性&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;10.0.0.0/8&lt;/code&gt;&lt;/strong&gt;: &lt;br&gt;
アドレス空間が大きいため、&lt;strong&gt;サブネットマスク&lt;/strong&gt;を用いて複数のサブネット（例：&lt;code&gt;10.1.0.0/16&lt;/code&gt;、&lt;code&gt;10.2.0.0/16&lt;/code&gt; など）に分割し、大規模ネットワークの階層的管理とトラフィックの分離を容易にします。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;192.168.0.0/16&lt;/code&gt;&lt;/strong&gt;: &lt;br&gt;
通常、デフォルトのサブネットマスク &lt;code&gt;255.255.0.0&lt;/code&gt; を使用し、サブネット分割の必要性は少ないため、シンプルなフラットなネットワーク構造に適しています。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;一般的な利用シーン&#34;&gt;&lt;strong&gt;一般的な利用シーン&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;10.xxx.xxx.xxx&lt;/code&gt;&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;企業内部ネットワーク: 例えば、複数の海外拠点を経由する多国籍企業がVPNで接続し、各拠点が独立したサブネット（例：&lt;code&gt;10.1.1.0/24&lt;/code&gt;、&lt;code&gt;10.1.2.0/24&lt;/code&gt;）を割り当てられる。&lt;/li&gt;
&lt;li&gt;クラウドサービスプロバイダー内部ネットワーク: AWSや阿里云などのプライベートクラウド環境でよく使用される &lt;code&gt;10.&lt;/code&gt; 段アドレス。&lt;/li&gt;
&lt;li&gt;産業制御ネットワーク: 一部の産業機器はデフォルトで &lt;code&gt;10.&lt;/code&gt; 段アドレスを使用する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;192.168.xxx.xxx&lt;/code&gt;&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;家庭/小規模オフィス: ルーターがデフォルトで割り当てるアドレス（例：&lt;code&gt;192.168.1.1&lt;/code&gt; または &lt;code&gt;192.168.0.1&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;小規模局域網の共有: 例えば、ルーターを使用して構築されたWiFiネットワークで、デバイス数は通常200台以下。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;パブリックネットワークとの分離性&#34;&gt;&lt;strong&gt;パブリックネットワークとの分離性&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;両者ともプライベートアドレスであり、&lt;strong&gt;直接パブリックネットワークにアクセスすることができない&lt;/strong&gt;ため、NAT（ネットワークアドレス変換）またはVPNを介して接続する必要がある。実際使用においては：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;10.&lt;/code&gt; ブロックは、より複雑なネットワークアーキテクチャが必要なシナリオ（マルチサブネット、VLAN分割など）で使用される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;192.168.&lt;/code&gt; ブロックは、アドレス空間が小さいため、プラグアンドプレイに適したシンプルなネットワークに最適である。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;なぜ-10-で始まるアドレスが表示されるのか&#34;&gt;&lt;strong&gt;なぜ 10. で始まるアドレスが表示されるのか？&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;ローカルネットワークで &lt;code&gt;10.243.52.68&lt;/code&gt; のようなアドレスを見つけた場合、考えられる原因は以下のとおりです。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;エンタープライズ級のネットワーク環境&lt;/strong&gt;：
会社や組織が &lt;code&gt;10.&lt;/code&gt; 段を内部IPアドレスとして使用し、部門やデバイス（サーバー、PCなど）を区別するために利用している可能性があります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;仮想マシンまたはコンテナネットワーク&lt;/strong&gt;：
クラウドプラットフォーム（VMware、Docker など）で、仮想マシンに IP アドレスを割り当てる際に &lt;code&gt;10.&lt;/code&gt; 段がデフォルトで使用されることがあります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;特殊なデバイスのデフォルト設定&lt;/strong&gt;：
一部のネットワーク機器（産業用スイッチ、ファイアウォールなど）は、工場出荷時に &lt;code&gt;10.&lt;/code&gt; 段のアドレスをデフォルトで設定している場合があります。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;まとめどのように選択するか&#34;&gt;&lt;strong&gt;まとめ：どのように選択するか？&lt;/strong&gt;
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;小型ネットワーク（家庭/オフィス）:&lt;/strong&gt; &lt;code&gt;192.168.x.x&lt;/code&gt; を優先的に使用し、設定が簡単で十分な性能を発揮します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中規模・大規模ネットワーク（企業/园区）:&lt;/strong&gt; &lt;code&gt;10.x.x.x&lt;/code&gt; または &lt;code&gt;172.16.x.x&lt;/code&gt; を使用し、サブネットの分割や多数のデバイス管理を容易にします。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;両者は本質的にローカルエリアネットワークアドレスであり、アドレス空間と適用シナリオの違いのみがあります。技術的な優劣はありません。具体的なネットワーク計画の要件によって選択します。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Git単独でプロキシを設定する</title>
        <link>https://ttf248.life/ja/p/git-single-configuration-proxy/</link>
        <pubDate>Fri, 06 Jun 2025 18:29:46 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/git-single-configuration-proxy/</guid>
        <description>&lt;p&gt;国内へのGitHubアクセス速度が遅い場合、プロキシの設定で加速できます。また、国内のホスティングプラットフォーム（例えば、码云、Codingなど）を利用する方法もあります。対応するビルドパイプラインを設定し、コードをGitHubに同期します。&lt;/p&gt;
&lt;p&gt;長年&lt;code&gt;coding&lt;/code&gt;を使用しており、インターフェースはシンプルで、最近公告を発表し、無料版がサポートされなくなりました。そのため、騰訊の新しいプラットフォーム&lt;code&gt;cnb&lt;/code&gt;への移行が必要になります。それに伴い、アリババのホスティングプラットフォーム全体のインターフェースデザインは、&lt;strong&gt;非常に使いにくい&lt;/strong&gt;です。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://cnb.cool/ttf248&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cnb.cool/ttf248&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;リポジトリの移行&#34;&gt;リポジトリの移行
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;cnb&lt;/code&gt;公式サイトで、GitHubから&lt;code&gt;cnb&lt;/code&gt;へのコードをまとめて移行するためのツールが提供されています。
&lt;a class=&#34;link&#34; href=&#34;https://docs.cnb.cool/zh/guide/migration-tools.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.cnb.cool/zh/guide/migration-tools.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;git-代理設定&#34;&gt;Git 代理設定
&lt;/h2&gt;&lt;p&gt;加速設定を行わない場合、ツールの同期が遅いため、コードはまずローカルに同期され、その後リモートリポジトリにアップロードされます。&lt;/p&gt;
&lt;p&gt;Git は以下のコマンドを使用して HTTP 代理を個別に構成でき、システム全体のグローバル設定に影響を与えません。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# HTTP 代理を設定
git config --global http.proxy http://proxy.example.com:8080

# HTTPS 代理を設定
git config --global https.proxy http://proxy.example.com:8080

# オプション：特定のドメイン名に対してのみ代理を設定
git config --global http.https://github.com.proxy http://proxy.example.com:8080
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代理設定を解除するには、以下のコマンドを使用します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git config --global --unset http.proxy
git config --global --unset https.proxy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;現在の代理設定を確認するには、以下のコマンドを使用します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git config --global --get http.proxy
git config --global --get https.proxy
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Prometheus監視システムにおけるヒストグラムとサマリー</title>
        <link>https://ttf248.life/ja/p/prometheus-monitoring-system-histogram-and-summary/</link>
        <pubDate>Wed, 04 Jun 2025 19:00:28 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/prometheus-monitoring-system-histogram-and-summary/</guid>
        <description>&lt;p&gt;ビジネスシステムは、サマリータイプの監視指標を設計し、平均処理時間（request_duration_milliseconds_sum / request_duration_milliseconds_count）を計算していました。&lt;/p&gt;
&lt;p&gt;データを確認したところ、あるインターフェースの平均処理時間が非常に高くなっていることが判明しました。時系列グラフを見ると、平均処理時間が突然増加しており、それは単一のリクエストの処理時間が長かったために引き起こされたもので、平均値を押し上げている状態でした。具体的にいつ発生したリクエストを特定したいのですが、その期間内のリクエスト数が少なく、結果データが常に空になってしまいます。&lt;/p&gt;
&lt;h2 id=&#34;faq-よくある質問--質疑応答-しぎおうどう応&#34;&gt;FAQ (よくある質問) / 質疑応答 (しぎおうどう応)
&lt;/h2&gt;&lt;h3 id=&#34;-なぜ-_sum-と-_count-にデータがあるのか&#34;&gt;✅ なぜ &lt;code&gt;_sum&lt;/code&gt; と &lt;code&gt;_count&lt;/code&gt; にデータがあるのか
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_sum&lt;/code&gt; と &lt;code&gt;_count&lt;/code&gt; は Summary 型の&lt;strong&gt;コア指標&lt;/strong&gt;であり、Prometheus は常にこれらの値を収集して記録します。&lt;/li&gt;
&lt;li&gt;どちらも&lt;strong&gt;累積型のカウンター&lt;/strong&gt;であるため、&lt;code&gt;rate()&lt;/code&gt; または &lt;code&gt;increase()&lt;/code&gt; を使用するのに適しています。&lt;/li&gt;
&lt;li&gt;リクエスト遅延がどのように変化しても、リクエストが存在すれば必ず &lt;code&gt;_sum&lt;/code&gt; と &lt;code&gt;_count&lt;/code&gt; のデータがあります。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;-quantile099-が時系列グラフで表示されない理由&#34;&gt;❌ &lt;code&gt;{quantile=&amp;quot;0.99&amp;quot;}&lt;/code&gt; が時系列グラフで表示されない理由
&lt;/h3&gt;&lt;p&gt;Summary にも quantile=&amp;ldquo;0.99&amp;rdquo; を設定していても、この時間系列が存在しないか欠損している可能性があります：
指標は確実に設定されており、データが期限切れでもありません。📉 リクエスト量が少ないため、quantile を計算できません。スライディングウィンドウメカニズムにより、この期間を過ぎると統計範囲に再含まれなくなります。
分位数（例えば p99）はサンプリング統計によって計算されます：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1～2 件程度のリクエストしかない場合、p99 の計算は&lt;strong&gt;不安定で代表的な意味を持たない&lt;/strong&gt;可能性があります。&lt;/li&gt;
&lt;li&gt;Prometheus &lt;strong&gt;クライアント SDK は、この quantile 時間系列を公開しない&lt;/strong&gt;ように選択します（誤解を避けるため）。&lt;/li&gt;
&lt;li&gt;その結果、&lt;code&gt;_sum&lt;/code&gt;、&lt;code&gt;_count&lt;/code&gt; が正常に累積されますが、&lt;code&gt;quantile=&amp;quot;0.99&amp;quot;&lt;/code&gt; にデータが存在しません。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ヒストグラムとサマリーの違い&#34;&gt;ヒストグラムとサマリーの違い
&lt;/h2&gt;&lt;h3 id=&#34;ヒストグラム&#34;&gt;&lt;strong&gt;ヒストグラム&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;仕組み:&lt;/strong&gt; ヒストグラムは、データをビン（バケット）に分割し、各ビンに収まっているサンプルの数を記録します。
例えば、定義したビンが &lt;code&gt;[10ms, 50ms, 100ms, 500ms, 1s]&lt;/code&gt; の場合、各リクエストのレイテンシは対応するビンに割り当てられます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;利点:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Prometheus で複数のインスタンス（例えば、複数のサービスノードのリクエストレイテンシ分布）からのデータを集計できます。&lt;/li&gt;
&lt;li&gt;分位数（P50、P95、P99 など）を計算し、レイテンシの分布を観察するのに適しています。&lt;/li&gt;
&lt;li&gt;PromQL を使用して、動的に分位数を計算するための柔軟なクエリ機能を提供します。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;欠点:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;ビンの範囲を事前に定義する必要があり、選択が不適切だとデータ分布が均一にならない可能性があります（例えば、すべてのリクエストが 1 つのビンに集中する）。&lt;/li&gt;
&lt;li&gt;ビンの数が多いほど、ストレージと計算のオーバーヘッドが増加します。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;適用シナリオ:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;複数のインスタンスからのデータを集計する必要がある場合。&lt;/li&gt;
&lt;li&gt;分位数を動的に調整したり、レイテンシ分布を分析したりする場合。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;概要&#34;&gt;&lt;strong&gt;概要&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;仕組み:&lt;/strong&gt; Summary はクライアント側でパーセンタイル（P50、P95、P99 など）を直接計算し、その結果を Prometheus に報告します。
また、サンプル全体の数と合計も記録し、平均値を計算するために使用します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;利点:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;プレ定義されたバケットは不要で、直接パーセンタイル結果を提供します。&lt;/li&gt;
&lt;li&gt;単一インスタンスでの正確なパーセンタイル計算に適しています。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;欠点:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;パーセンタイルの計算はクライアント側で行われるため、Prometheus で複数のインスタンスのデータを集計できません。&lt;/li&gt;
&lt;li&gt;パーセンタイルを調整（例：P95 から P99 に変更）するには、コードを変更して再デプロイする必要があります。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;適用シナリオ:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;単一インスタンスでの監視であり、パーセンタイルに対する正確性が高い場合。&lt;/li&gt;
&lt;li&gt;複数のインスタンスのデータを集計する必要がない場合。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;ヒストグラム&lt;/th&gt;
&lt;th&gt;サマリー&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;分位数計算&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;プロメテウス内で動的に計算&lt;/td&gt;
&lt;td&gt;顧客側で直接計算&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;ヒストグラム&lt;/th&gt;
&lt;th&gt;サマリー&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;多インスタンス集約&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;対応&lt;/td&gt;
&lt;td&gt;非対応&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;主な違いの比較&#34;&gt;&lt;strong&gt;主な違いの比較&lt;/strong&gt;
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;ヒストグラム&lt;/th&gt;
&lt;th&gt;サマリー&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;バケツの定義&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;事前に定義する必要がある&lt;/td&gt;
&lt;td&gt;不要&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;主な違いの比較-1&#34;&gt;&lt;strong&gt;主な違いの比較&lt;/strong&gt;
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;ヒストグラム&lt;/th&gt;
&lt;th&gt;サマリー&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;ストレージコスト&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;桶の数に依存&lt;/td&gt;
&lt;td&gt;固定コスト&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;ヒストグラム&lt;/th&gt;
&lt;th&gt;サマリー&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;柔軟性&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;高 (ビンの幅を動的に調整可能)&lt;/td&gt;
&lt;td&gt;低 (コードを変更してビンの幅を調整する必要がある)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;結論&#34;&gt;結論
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;複数のインスタンスのデータを集約したり、分位数を柔軟に調整する必要がある場合は、&lt;strong&gt;ヒストグラム&lt;/strong&gt;を選択してください。&lt;/li&gt;
&lt;li&gt;単一インスタンスの正確な分位数が必要で、分位数が固定されている場合は、&lt;strong&gt;サマリー&lt;/strong&gt;を選択してください。
あなたのシナリオでは、サービスが分散しているため、&lt;strong&gt;ヒストグラム&lt;/strong&gt;を使用することを推奨します。これにより、Prometheus ですべてのインスタンスのデータを集約し、動的に分位数と経過時間分布を計算できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;スライディングウィンドウの概念とそのヒストグラムおよびサマリーとの関係&#34;&gt;スライディングウィンドウの概念とそのヒストグラムおよびサマリーとの関係
&lt;/h2&gt;&lt;h3 id=&#34;スライディングウィンドウの概念&#34;&gt;&lt;strong&gt;スライディングウィンドウの概念&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;スライディングウィンドウは、時間ウィンドウメカニズムであり、一定期間内のデータ変化を統計するために使用されます。それは、継続的に移動する時間範囲を通して、システムのリアルタイム状態を動的に反映します。スライディングウィンドウの特徴は以下のとおりです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;固定時間範囲:&lt;/strong&gt; ウィンドウの長さは固定されており、例えば最近1分、5分などがあります。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;リアルタイム更新:&lt;/strong&gt; 時間経過とともに、ウィンドウがスライドし、古いデータがウィンドウから削除され、新しいデータがウィンドウに追加されます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一般的な用途:&lt;/strong&gt; リアルタイム指標（リクエストレート、平均値、パーセンタイルなど）を計算するために使用されます。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Prometheusでは、スライディングウィンドウは通常、クエリ関数（&lt;code&gt;rate()&lt;/code&gt;、&lt;code&gt;avg_over_time()&lt;/code&gt;など）によって実装されます。&lt;/p&gt;
&lt;h3 id=&#34;スライディングウィンドウとヒストグラムの関係&#34;&gt;&lt;strong&gt;スライディングウィンドウとヒストグラムの関係&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ヒストグラムのデータ構造&lt;/strong&gt;: &lt;br&gt;
ヒストグラムは、サンプルデータをビンに分割し、各ビンのカウントを記録します。Prometheus は、これらのカウント値を周期的にキャプチャします。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;スライディングウィンドウの実装&lt;/strong&gt;: &lt;br&gt;
Prometheus でヒストグラムのデータに対してスライディングウィンドウを適用するには、クエリ文を使用できます。例えば：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rate(http_request_duration_seconds_bucket[5m])&lt;/code&gt;: 過去 5 分間の各ビンのリクエストレートを計算します。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))&lt;/code&gt;: 過去 5 分間の P95 分位数を計算します。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;利点&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;スライディングウィンドウは、最近の時間の要求時間分布を動的に反映できます。&lt;/li&gt;
&lt;li&gt;ヒストグラムのビニングメカニズムとスライディングウィンドウを組み合わせることで、効率的に分位数や分布を計算できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;スライディングウィンドウとsummaryの関係&#34;&gt;&lt;strong&gt;スライディングウィンドウとSummaryの関係&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Summaryのデータ構造&lt;/strong&gt;:
Summaryはクライアント側でパーセンタイルを直接計算し、Prometheusに送信します。また、サンプル総数と合計も記録します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;スライディングウィンドウの実装&lt;/strong&gt;:
Prometheusでは、Query文を使用してSummaryのデータをスライディングウィンドウ化できます。例えば：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rate(http_request_duration_seconds_sum[5m]) / rate(http_request_duration_seconds_count[5m])&lt;/code&gt;: 過去5分間の平均リクエスト時間計算します。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;制限&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;Summaryのパーセンタイルはクライアント側で計算されるため、Prometheus側で再計算できません。したがって、スライディングウィンドウによるパーセンタイルのサポートは限定的です。&lt;/li&gt;
&lt;li&gt;複数のインスタンスのデータを集計する必要がある場合、スライディングウィンドウはSummaryのパーセンタイルに直接作用しません。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;スライディングウィンドウの適用場面&#34;&gt;&lt;strong&gt;スライディングウィンドウの適用場面&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;リアルタイム監視:&lt;/strong&gt; スライディングウィンドウは、システムのリアルタイムな状態を監視するのに適しています。例えば、最近1分間のリクエストレートやレイテンシ分布などです。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;異常検知:&lt;/strong&gt; スライディングウィンドウを使用することで、短期間での異常事象（例えば、リクエストのレイテンシが急増するなど）を迅速に検出できます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;動的分析:&lt;/strong&gt; スライディングウィンドウは、システムの変化トレンドを動的に反映し、静的なグローバル統計とは異なります。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;概要-1&#34;&gt;概要
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ヒストグラム&lt;/strong&gt; とスライディングウィンドウを組み合わせることで、分位数（例：P95、P99）とリクエストの経過時間分布を動的に計算でき、分散システムでの監視に適しています。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Summary&lt;/strong&gt; とスライディングウィンドウを組み合わせることで、平均値などの単純な指標を計算できますが、分位数の柔軟性に欠け、多インスタンスアグリゲーションもサポートしていません。
あなたのシナリオでは、極端なリクエストの経過時間（例：P99）と大部分のリクエストの平均値を監視する必要があるため、&lt;strong&gt;ヒストグラム&lt;/strong&gt; を使用し、スライディングウィンドウを組み合わせてシステムのパフォーマンスを動的に分析することをお勧めします。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>ブログ翻訳プロジェクトの雑感：文化伝達、AIプログラミング</title>
        <link>https://ttf248.life/ja/p/blog-translation-project-musings-cultural-transmission-ai-programming/</link>
        <pubDate>Mon, 02 Jun 2025 21:41:00 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/blog-translation-project-musings-cultural-transmission-ai-programming/</guid>
        <description>&lt;p&gt;文化伝播：意識形態的な影響、潜移漫歩。
AIプログラミング：ソフトウェア設計を行わないため、手戻りが多くなる。&lt;/p&gt;
&lt;h2 id=&#34;文化翻訳&#34;&gt;文化翻訳
&lt;/h2&gt;&lt;p&gt;当初のプロジェクトでは、英語、日本語、韓国語という3つの言語のみをサポートしていました。その後、「結局AI翻訳だから、色々な言語に対応した方が良いのではないか」と考え、フランス語、ロシア語、ヒンディー語を追加しました。その頃は問題に気づかず、プログラムが翻訳を実行する際に、過去のコードの問題により翻訳形式が正しくなく、保存された文章を再翻訳する必要がありました。&lt;/p&gt;
&lt;p&gt;統計的な時間経過の警告が表示され、すべての翻訳が完了するまでに約20時間がかかりました。これは、ローカルでデプロイされている大規模なモデルであるためです。不要な言語をいくつか削除し、翻訳時間を短縮することを考えました。フランス語、ロシア語、ヒンディー語を削除しました。その時、何かがおかしいことに気づきました。なぜ当初選択した言語（日本語、韓国語）が、私の選択になっているのでしょうか？&lt;/p&gt;
&lt;p&gt;世界人口の分布に基づいて見ると、これらの言語のユーザー層はそれほど多くありません。特に韓国語は、世界の利用人数は約8000万人に過ぎません。日本語はわずかに多い約1億2000万人です。一方、フランス語、ロシア語、ヒンディー語の利用人数はすべて1億人以上でした。&lt;/p&gt;
&lt;p&gt;その時、言語のユーザー層が、言語の使用人数によるものではなく、文化翻訳の影響によるものであることに気づきました。韓国と日本の文化は世界的に広範な影響力を持っており、特にアジア地域で顕著です。K-pop、アニメ、映画などの文化製品は大量のファンを引き付け、これらのファンは自然と関連する言語にも興味を持つようになりました。&lt;/p&gt;
&lt;p&gt;プロジェクトの成長を振り返ると、幼い頃によく日本のアニメや漫画を見ていましたし、大人になった今では多くの韓国映画やドラマを見ました。そのため、プロジェクトの設定時の初期言語を選択する際に、無意識のうちにこれらの馴染みのある言語を選択してしまいました。&lt;/p&gt;
&lt;h3 id=&#34;ソフトウェア設計とaiプログラミング&#34;&gt;ソフトウェア設計とAIプログラミング
&lt;/h3&gt;&lt;p&gt;翻訳助手は当初、単なるシンプルなツールに過ぎなかったが、Claude4のコーディング能力を体験してから徐々に機能が拡張され、文章翻訳、タグ翻訳などのモジュールが追加された。機能が増加するにつれて、コードの複雑さもそれに伴って上昇した。AIがコードをリファクタリングしてディレクトリ構造をより明確にしたことは確かだが、新機能の拡張やバグ修正時には、AI生成されたコードには繰り返し問題が発生することがある。&lt;/p&gt;
&lt;p&gt;AIはコード生成において、全体的な構造と設計理念に対する理解に欠けている。既存のコードに基づいて修正や拡張を行うことが多く、既存モジュールの有効な再利用をできていないため、コード冗長性が生じることがある。毎回、重複コードを手動で削除する必要があり、これは無意識のうちに開発コストを増加させている。&lt;/p&gt;
&lt;p&gt;さらに、AI生成されたコードは文法的に正しくても、論理と設計において問題がある場合がある。例えば、別のプロジェクトでプロンプトをわずかに調整しただけで、生成されるウェブページの構造が完全に異なり、一貫性がない。これは初期段階における合理的な設計の欠如、機能の追加が随意な積み重ねによるものであり、コード構造が混乱していることを反映している。&lt;/p&gt;
&lt;p&gt;これはまた、ソフトウェアエンジニアリングの核心的な経験は依然として無視できないことを私たちに思い出させる。適切な設計は返工を減らすだけでなく、コードの保守性と拡張性を向上させることができる。AIは強力なツールであるものの、システム設計に対する人間の深い理解と計画を代替することはできない。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>ブログ翻訳プロジェクトの雑感：歴史対話</title>
        <link>https://ttf248.life/ja/p/blog-translation-project-musings-historical-conversations/</link>
        <pubDate>Mon, 02 Jun 2025 21:16:24 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/blog-translation-project-musings-historical-conversations/</guid>
        <description>&lt;p&gt;ブログ翻訳プロジェクトは当初、複雑に設計されていた——まずMarkdown形式を解析し、プレースホルダーでコンテンツを保護し、最後に大規模言語モデルに送信する仕組みだった。これは完全に無駄であり、大規模言語モデル自体がMarkdownの文法を認識する能力を備えており、元のコンテンツを直接処理し、翻訳時にフォーマットを維持することができたからだ。&lt;/p&gt;
&lt;p&gt;私たちの仕事は、コードのデバッグから、大規模言語モデルの&lt;strong&gt;プロンプト&lt;/strong&gt;のデバッグへと変わった。
モデル：&lt;code&gt;google/gemma-3-4b&lt;/code&gt;
ハードウェア：&lt;code&gt;Nvidia 3060 12GB&lt;/code&gt;
そう、思考しないモデルを選んだ。思考するモデルは翻訳タスクを実行する際に効率が低く、4Bパラメータと12Bパラメータの効果を比較したところ、翻訳タスクにおいてはgemma3の4Bパラメータで十分だった。12Bパラメータは翻訳タスクにおいて明確な利点を持っていなかった。
12Bパラメータの速度：&lt;strong&gt;11.32 tok/sec&lt;/strong&gt;、4Bパラメータの速度：&lt;strong&gt;75.21 tok/sec&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;背景説明&#34;&gt;背景説明
&lt;/h2&gt;&lt;p&gt;システムに様々な条件制限を加えても、出力される翻訳結果には依然として問題が発生することがありました。具体的には、フォーマットの保護が不十分であったり、過剰な説明文が含まれていたりしました。役割定義時には、Markdown形式を保護し、翻訳結果のみを出力することを明示していたにも関わらず、最終的な翻訳は不安定でした。&lt;/p&gt;
&lt;p&gt;その時、以前漫画翻訳プロジェクトで大言語モデルを活用した経験が思い出されました。その時の翻訳精度は、私のものより良かったようです。コードやリクエストデータを確認したところ、漫画翻訳プロジェクトでは、毎回リクエストにコンテキスト（文脈）を付与していました。現在の翻訳内容に加え、過去の翻訳内容もまとめて送信していたのです。&lt;/p&gt;
&lt;p&gt;このメリットは何でしょうか？前後の翻訳の一貫性を高めるだけでなく、出力フォーマットの安定性を確保することにもつながったと考えられます。&lt;/p&gt;
&lt;h2 id=&#34;履歴対話の重要性&#34;&gt;履歴対話の重要性
&lt;/h2&gt;&lt;p&gt;AI 大規模モデル（GPT シリーズ、Claude、Gemini など）の普及に伴い、ますます多くの企業や開発者が API を通じてこれらのモデルにアクセスし、インテリジェントな顧客サポート、コンテンツ生成、コードアシスタントなどのアプリケーションを構築しています。しかし、多くの方は API への初期導入時に共通の問題に直面します：&lt;strong&gt;モデル出力が不整合で文脈理解が欠如しており、場合によっては質問の意図を誤解してしまう&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;この現象を引き起こす主要な原因の一つは——&lt;strong&gt;API リクエスト中に履歴対話の内容を含めないこと&lt;/strong&gt;です。&lt;/p&gt;
&lt;h2 id=&#34;履歴対話とは&#34;&gt;履歴対話とは？
&lt;/h2&gt;&lt;p&gt;履歴対話とは、一度の会話セッションにおいて、モデルとユーザー間の過去のやり取りの記録を指します。OpenAI の Chat Completions API（など、多くの大規模言語モデル API）では、開発者がリクエスト内で完全な &lt;code&gt;messages&lt;/code&gt; 配列を作成し、過去の会話をユーザーとアシスタントのメッセージが交互に並んだ形式で渡す必要があります。&lt;/p&gt;
&lt;h3 id=&#34;例文&#34;&gt;例文
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;model&amp;quot;: &amp;quot;gpt-4&amp;quot;,
  &amp;quot;messages&amp;quot;: [
    {&amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;退職の手紙を書いてください&amp;quot;},
    {&amp;quot;role&amp;quot;: &amp;quot;assistant&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;かしこまりました。退職理由は何を書くようにしますか？&amp;quot;},
    {&amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;個人的なキャリアの追求をしたいと考えていると述べる&amp;quot;}
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;もし最後の文だけを送った場合：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;個人的なキャリアの追求をしたいと考えていると述べる&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;モデルは退職の手紙だと全く認識できず、文脈が理解されないため、出力品質は著しく低下します。&lt;/p&gt;
&lt;h2 id=&#34;歴史対話がなぜ重要なのか&#34;&gt;歴史対話がなぜ重要なのか？
&lt;/h2&gt;&lt;h3 id=&#34;1-文脈の構築と一貫性の向上&#34;&gt;1. &lt;strong&gt;文脈の構築と一貫性の向上&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;AIモデルは本質的に「コンテキスト駆動型」であり、過去の出来事を記憶することはできません。除非你&lt;strong&gt;明示的に伝える&lt;/strong&gt;のです。対話履歴を渡すことで、モデルはあなたの意図や話題の背景をより良く理解し、期待される出力を生成できます。&lt;/p&gt;
&lt;h3 id=&#34;2-誤解の低減&#34;&gt;2. &lt;strong&gt;誤解の低減&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;もしあなたがモデルに複数のステップで指示を実行させたい場合（例：文章作成、要約、コードデバッグ）、過去の履歴はモデルが徐々に理解を深め、途中で「逸脱」したり、重要な点を失ったりするのを防ぐのに役立ちます。&lt;/p&gt;
&lt;h3 id=&#34;3-実際の人間のような対話行動のシミュレーション&#34;&gt;3. &lt;strong&gt;実際の人間のような対話行動のシミュレーション&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;実用例として、カスタマーサポートシステム、教育アシスタント、健康相談などにおいて、ユーザーの質問は通常、段階的に展開され、一度に明確な表現で表明されることはありません。会話履歴を保持することで、AIが「記憶力のあるアシスタント」のように振る舞うことができます。&lt;/p&gt;
&lt;h2 id=&#34;api-中における会話履歴の正しい追加方法&#34;&gt;API 中における会話履歴の正しい追加方法
&lt;/h2&gt;&lt;p&gt;OpenAI の API を例に、以下の構造に従うことを推奨します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;messages = [
    {&amp;quot;role&amp;quot;: &amp;quot;system&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;あなたは専門的な法律アシスタントです&amp;quot;},
    {&amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;契約書の有効条件とは何ですか？&amp;quot;},
    {&amp;quot;role&amp;quot;: &amp;quot;assistant&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;契約書が有効であるためには、以下の条件を満たす必要があります：……&amp;quot;},
    {&amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;口頭での合意は有効ですか？&amp;quot;}
]

response = openai.ChatCompletion.create(
    model=&amp;quot;gpt-4&amp;quot;,
    messages=messages
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;system&lt;/code&gt; メッセージを使用してモデルの動作とアイデンティティを設定します。&lt;/li&gt;
&lt;li&gt;最新の数回の重要な会話のみを保持し、毎回すべての履歴を送信する必要はありません（トークン制限を超えないように）。&lt;/li&gt;
&lt;li&gt;長いセッションでは、早期のコンテンツを切り捨てて、コア情報を要約し、トークンの消費を制御します。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;実践的推奨事項&#34;&gt;実践的推奨事項
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;対話状態管理&lt;/strong&gt;: バックエンドは、各ユーザーのセッション履歴（例: Redis、データベース）を記録するためのキャッシュメカニズムを設計する必要があります。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;長さ制限&lt;/strong&gt;: OpenAI GPT-4 のコンテキスト長は 128k tokens であり、Claude 3 は 200k～1M पर्यंत可能です。適切なトリミングが必要です。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;動的履歴の要約&lt;/strong&gt;: 履歴が長すぎる場合は、モデルを使用して古い会話を要約し、その結果を対話コンテキストに追加します。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ
&lt;/h2&gt;&lt;p&gt;AI 大規模モデルの能力は強力ですが、開発者に十分なコンテキスト情報を「与える」必要があります。API リクエストに過去の会話を追加することで、モデル出力の品質と一貫性を大幅に向上させるだけでなく、ユーザーエクスペリエンスをより自然で現実的な対話に近づけることができます。AI 顧客サービス、ライティングアシスタント、プログラミングアシスタント、教育アプリケーションなど、どのような分野でも無視できない最適化テクニックです。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Go プロジェクトで参照されていないすべての関数を検索する。</title>
        <link>https://ttf248.life/ja/p/find-all-functions-not-referenced-in-the-go-project/</link>
        <pubDate>Mon, 02 Jun 2025 21:10:47 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/find-all-functions-not-referenced-in-the-go-project/</guid>
        <description>&lt;p&gt;Go言語プロジェクトにおいて、&lt;code&gt;staticcheck&lt;/code&gt; を使用して未使用関数を検出することは、効率的な静的解析手法です。&lt;/p&gt;
&lt;h3 id=&#34;1-staticcheck-のインストール&#34;&gt;&lt;strong&gt;1. staticcheck のインストール&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;以下のコマンドを実行して、Go (バージョン 1.16+) と &lt;code&gt;staticcheck&lt;/code&gt; をインストールしてください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go install honnef.co/go/tools/cmd/staticcheck@latest
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-基本用法未使用関数の検索&#34;&gt;&lt;strong&gt;2. 基本用法：未使用関数の検索&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;プロジェクトのルートディレクトリで以下のコマンドを実行します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;staticcheck ./...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;主要チェックルール:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;U1000&lt;/strong&gt;: 未使用関数、メソッド、変数、または型を検出します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;U1001&lt;/strong&gt;: 未使用パラメータを検出します。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-特定のチェックルールをフィルタリングする&#34;&gt;&lt;strong&gt;3. 特定のチェックルールをフィルタリングする&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;未使用関数のみをチェックする場合、ルールを指定できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;staticcheck -checks=U1000 ./...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-出力形式&#34;&gt;&lt;strong&gt;4. 出力形式&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;デフォルトの出力形式は、&lt;code&gt;{path}:{line}:{column}: {message}&lt;/code&gt; の形式です。例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;main.go:10:2: func UnusedFunction は未使用です (U1000)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-設定ファイル-オプション&#34;&gt;&lt;strong&gt;5. 設定ファイル (オプション)&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;プロジェクトのルートディレクトリに &lt;code&gt;.staticcheck.conf&lt;/code&gt; ファイルを作成し、カスタムチェックルールを定義します：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;checks&amp;quot;: [&amp;quot;U1000&amp;quot;, &amp;quot;-ST1000&amp;quot;]  // U1000 を有効にし、ST1000 を無効にする (文字列フォーマット規則)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6-visual-studio-code-への統合&#34;&gt;&lt;strong&gt;6. Visual Studio Code への統合&lt;/strong&gt;
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://marketplace.visualstudio.com/items?itemName=golang.go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 拡張機能&lt;/a&gt; をインストールします。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;settings.json&lt;/code&gt; に以下を追加します：&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;7-特定コードの無視&#34;&gt;&lt;strong&gt;7. 特定コードの無視&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;関数の上部にコメント &lt;code&gt;//lint:ignore U1000 reason&lt;/code&gt; を追加することで、以下のチェックを無視できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//lint:ignore U1000 Used by generated code
func UnusedButNeeded() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;よくある質問&#34;&gt;&lt;strong&gt;よくある質問&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Q: テストファイル内の未使用関数をどのように処理しますか?&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;A: &lt;code&gt;staticcheck&lt;/code&gt; はデフォルトでテストファイルをチェックします。除外する場合は、&lt;code&gt;-tests=false&lt;/code&gt; などのフラグを使用できます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Q: CI/CD 環境への統合は?&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;A: GitHub Actions に追加：&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;サンプル出力&#34;&gt;&lt;strong&gt;サンプル出力&lt;/strong&gt;
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ staticcheck -checks=U1000 ./...
internal/utils/helper.go:15:2: 関数 privateHelper は使用されていない (U1000)
cmd/server/main.go:23:2: initConfig 関数は使用されていない (U1000)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;staticcheck&lt;/code&gt; の &lt;code&gt;U1000&lt;/code&gt; 規則を使用することで、未使用の関数を迅速に特定し削除し、コード品質を向上させることができます。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Git 子モジュール提交記録の消失</title>
        <link>https://ttf248.life/ja/p/git-submodule-merge-history-lost/</link>
        <pubDate>Mon, 02 Jun 2025 16:44:58 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/git-submodule-merge-history-lost/</guid>
        <description>&lt;p&gt;ローカルにGitリポジトリがあり、そのサブモジュールがプル時に一時ブランチになっている。私はその一時ブランチでいくつかのコードをコミットし、その後サブモジュールを&lt;code&gt;main&lt;/code&gt;ブランチに戻した。しかし、これらのコミットされたコードが見つからず、&lt;code&gt;main&lt;/code&gt;ブランチで見つけることができない。また、その一時ブランチの履歴も見つけられない。&lt;/p&gt;
&lt;h2 id=&#34;ソリューション&#34;&gt;ソリューション
&lt;/h2&gt;&lt;p&gt;Git サブモジュールで一時的なブランチにコミットし、&lt;code&gt;main&lt;/code&gt; ブランチに戻すとこれらのコミットが見つからなくなることがあります。この状況を解決するには、以下の手順に従ってください。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;コミット履歴の確認:&lt;/strong&gt; サブモジュールのディレクトリに移動し、reflog を使用して失われたコミットを見つけます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;新しいブランチを作成してコミットを保存:&lt;/strong&gt; 失われたコミットに基づいて新しいブランチを作成します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;メインブランチへのマージまたはcherry-pick:&lt;/strong&gt; コードをメインブランチに統合します（マージするか、cherry-pickを使用して特定のコミットを選択）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下は具体的な操作手順です。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# サブモジュールのディレクトリに移動
cd path/to/your/submodule

# reflog で HEAD の変更履歴を確認（未関連ブランチのコミットも含む）
git reflog

PS F:\dev\notebook\scripts\hugo-content-suite&amp;gt; git reflog
de05175 (HEAD -&amp;gt; main, origin/main, origin/HEAD) HEAD@{0}: checkout: moving from c8d070651310e90d283cb64d98da088c5fe05e73 to main
c8d0706 HEAD@{1}: commit: feat: Markdown 記号の用法ドキュメントを追加、詳細な構文例と効果のデモを提供
48250f5 HEAD@{2}: commit: feat: 文章翻訳プレビュー機能を削除し、翻訳プロセスを簡素化
b8280b6 HEAD@{3}: commit: feat: 絶対パスを取得する機能を追加し、相対パスを絶対パスに変換をサポート
92c354b HEAD@{4}: commit: fix: 文章スキャンロジックの修正、絶対パスを使用してスキャンするようにする
de05175 (HEAD -&amp;gt; main, origin/main, origin/HEAD) HEAD@{5}: checkout: moving from main to de05175d4ec0828e3ae95d726b09dfff18f67a23
de05175 (HEAD -&amp;gt; main, origin/main, origin/HEAD) HEAD@{6}: clone: from https://cnb.cool/ttf248/hugo-content-suite.git

# 失われたコミットに基づいて新しいブランチを作成（例：456def を使用）
git checkout -b saved-work 456def

# メインブランチに戻る
git checkout main

# 保存した作業をメインブランチにマージ（または cherry-pick で特定のコミットを選択）
git merge saved-work
# または
git cherry-pick 456def

# 親プロジェクトディレクトリに戻り、サブモジュールの更新をコミット
cd ..
git add path/to/your/submodule
git commit -m &amp;quot;Update submodule to include new changes&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;主要操作手順&#34;&gt;主要操作手順
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;git reflog&lt;/strong&gt;: HEADのすべての履歴を表示し、ブランチに関連付けられていないコミットも含む&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;git checkout -b&lt;/strong&gt;: 任意のコミットから新しいブランチを作成し、作業を保存する&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;git merge/cherry-pick&lt;/strong&gt;: 保存されたコミットをターゲットブランチに統合する
reflogで記録が見つからない場合は、&lt;code&gt;git fsck --lost-found&lt;/code&gt;を使用して孤立したコミットを探す必要があるかもしれませんが、これは非常にまれなケースです。&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>GitHub Pages の Easter Egg: 複数の Pages をデプロイ</title>
        <link>https://ttf248.life/ja/p/github-pages-easter-egg-deploy-multiple-sites/</link>
        <pubDate>Wed, 28 May 2025 02:55:54 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/github-pages-easter-egg-deploy-multiple-sites/</guid>
        <description>&lt;p&gt;最近、体内時計が少し乱れていて、夜2時過ぎまでGitHub Pagesのデプロイに苦戦していました。
仕事が終わってからようやく食事を摂り、すぐに寝ようとすると、食べ終わって帰宅して8時半頃になり、眠くて困って、目を閉じるとそのまま眠くなってしまい、目が覚めるともう凌晨2時でした。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;まだ起動もしていないうちに消滅した分類：AI 研習所&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;フラグフラッグ&#34;&gt;フラグ（フラッグ）
&lt;/h2&gt;&lt;p&gt;昨日、話していなかった「未熟な」フロントエンドを批判していたのに、今日はフロントエンドではなく、UI/UXの体験を追求している。&lt;/p&gt;
&lt;h2 id=&#34;プロジェクト&#34;&gt;プロジェクト
&lt;/h2&gt;&lt;p&gt;弊社の古くからの友人、&lt;a class=&#34;link&#34; href=&#34;https://github.com/ttf248/ai-coding-demo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ttf248/ai-coding-demo&lt;/a&gt; が参上します。
そうです、以前の選株プロジェクトを、全体の構造を再構築し、その後のAIプログラミング関連の内容はこのプロジェクト下に集約されます。&lt;/p&gt;
&lt;h2 id=&#34;複数の-pages-をデプロイする&#34;&gt;複数の Pages をデプロイする
&lt;/h2&gt;&lt;p&gt;プロジェクトは国内で &lt;a class=&#34;link&#34; href=&#34;https://cnb.cool/ttf248/ai-coding-demo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cnb.cool/ttf248/ai-coding-demo&lt;/a&gt; でホストされており、周知の通り、国内では Pages の公開をサポートしていません。そのため、海外の GitHub 上に公開する必要があります。&lt;/p&gt;
&lt;p&gt;ブログは海外の GitHub に公開されます。まだ試したことがありませんが、複数のプロジェクトを Pages にデプロイすること、そして現在の処理しているプロジェクトが従来のブログサイトではないこと（単に多くのドキュメントといくつかの静的な HTML デザイン稿が含まれているだけです。）もわかります。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/github-pages-easter-egg-deploy-multiple-sites/20250528030230.png&#34;
	width=&#34;798&#34;
	height=&#34;530&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;pages&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;150&#34;
		data-flex-basis=&#34;361px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;その通り、このページは私が初めてクリックしたところ、複数のプロジェクトを Pages にデプロイすることはブログの公開に影響を与えないこと、そしてブログのドメインの下に新しいパスが追加されることを発見しました。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://ttf248.life/ai-coding-demo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ttf248.life/ai-coding-demo/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ここまできたら、完璧だと叫びました。&lt;/p&gt;
&lt;h2 id=&#34;ai-研習社&#34;&gt;AI 研習社
&lt;/h2&gt;&lt;p&gt;昨日、新しい分類を作成したことをきっかけに、AIを活用して多くのコンピュータ科目の学習を進めようと考えました。例えば、アルゴリズムやLeetCodeのプログラミング問題集などです。&lt;/p&gt;
&lt;p&gt;毎回の学習記録をブログに公開し、知識ベースを形成します。新しい分類として「AI 研習社」を作成しました。&lt;/p&gt;
&lt;p&gt;現在見られるように、異なるコースごとにそれぞれプロジェクトを作成し、学習ノートは各プロジェクトのReadme.mdファイルに記述しています。&lt;/p&gt;</description>
        </item>
        <item>
        <title>慢性疾患、華やかなりし世相に眼移り</title>
        <link>https://ttf248.life/ja/p/old-ailment-stunning-flowers/</link>
        <pubDate>Mon, 26 May 2025 23:54:12 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/old-ailment-stunning-flowers/</guid>
        <description>&lt;p&gt;長年にわたりバックエンド開発に注力してきましたが、最近は &lt;code&gt;AI&lt;/code&gt; プログラミングを試したり、少しフロントエンド関連のことも取り組むようになりました。しかし、この間の苦労の中で、自分には昔からある古傷—「繁華なものに目を奪われる」—に気づきました。&lt;code&gt;AI&lt;/code&gt; を使ってフロントエンドインターフェースを実現しようとするのですが、実際にはそのような試みが現在の仕事に大きな実用的な助けになりませんし、むしろ時間を浪費してしまいます。&lt;/p&gt;
&lt;h2 id=&#34;ai-の適用シナリオ&#34;&gt;AI の適用シナリオ
&lt;/h2&gt;&lt;p&gt;小規模なプロジェクトにおいては、AI ツールが大きな役割を果たすことができ、特に独立性が高く、システムとの結合度が低く、ビジネスロジックが単純な関数を作成する際に非常に役立ちます。これらのタスクは通常、明確な入力と出力があり、文脈依存が少ないため、現在の AI 支援プログラミングの能力範囲に最適です。&lt;/p&gt;
&lt;p&gt;しかしながら、複雑なシステムアーキテクチャや深いビジネスロジックに対処する場合、AI の限界が現れ始めます。それは、プロジェクトの実際のニーズから乖離した、見かけ上は合理的だが実際には不適切なコードを生成したり、デバッグが困難な潜在的な問題を導入したりする可能性があります。これらのシナリオにおいては、AI は補助ツールとして、完全なコード生成器に依存することなく使用されるべきです。生成されたコードは厳格なレビューとテストを受け、実際の要件を満たしていることを確認する必要があります。&lt;/p&gt;
&lt;h2 id=&#34;誤りと学習の代償&#34;&gt;誤りと学習の代償
&lt;/h2&gt;&lt;p&gt;AI を使ってフロントエンドコードを生成しようとした際、多くの課題に直面しました。フロントエンドは私の馴染みのない分野であるため、問題解決には時間と労力がかかりました。プロンプトを調整して AI にコードを書き直しても、どうしても低レベルのエラーが発生してしまうのです。このような試行錯誤は時間と労力を浪費するだけでなく、現在の私のエネルギーはバックエンドのビジネスロジックに集中すべきだと痛感させられました。&lt;/p&gt;
&lt;p&gt;週末に完成させたプロジェクトを振り返ってみると、バックエンド開発とユーザーインタラクションロジックに焦点を当て、コンソールから機能を実装することが、現状で最も効率的な選択であると確信します。より多くの時間とエネルギーが手に入ったら、フロントエンドの知識を体系的に学ぶ方が良いかもしれません。&lt;/p&gt;
&lt;h2 id=&#34;フロントエンド学習の計画&#34;&gt;フロントエンド学習の計画
&lt;/h2&gt;&lt;p&gt;フロントエンド技術スタックは複雑で多様であり、短期間で習得するのは現実的ではありません。まずは、Vue.jsやReact.jsなどのフレームワークを選択し、そのコアな概念と使用方法を深く学ぶことを計画しています。基礎知識を習得した後で、AIを活用してフロントエンドコードを生成することで、不慣れによる誤りや時間の浪費を防ぐことができます。&lt;/p&gt;
&lt;p&gt;まとめると、現在の段階ではバックエンド開発に重点を置き、着実にコアスキルを向上させることに注力します。その時が来るまで、フロントエンドとAIの組み合わせを探求することは控え、より大きな成果を得られる可能性があります。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Claude4のリリース、開発を試す：hugoタグ、超リンク翻訳アシスタント</title>
        <link>https://ttf248.life/ja/p/claude-4-release-hugo-tags-hyperlink-translation-assistant/</link>
        <pubDate>Sat, 24 May 2025 03:05:31 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/claude-4-release-hugo-tags-hyperlink-translation-assistant/</guid>
        <description>&lt;p&gt;本サイトはHugoで開発されていますが、筆者自身は常に中国語のタイトルを使用しており、その結果、生成される文章の超リンクが使いにくい状態でした。つまり、送信する際に、中国語の文字が超リンク内で%E4%BD%A0%E5%A5%BDのような形式にエスケープされてしまうため、見た目が良くありません。設定でslugを設定することで解決できますが、毎回手動で設定する必要があり、非常に面倒でした。
そこで、Claude4を使って翻訳アシスタントを開発し、中国語のタイトルを自動的に英語のslugに変換し、文章中に超リンクを追加することを試みました。これにより、手動での設定を回避できます。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Claude4はマジで最高！文脈理解能力が大幅に向上し、複雑なタスクの処理効率も飛躍的に向上しています。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;プロジェクトアドレス&#34;&gt;プロジェクトアドレス
&lt;/h2&gt;&lt;p&gt;国内プロジェクトアドレス：&lt;a class=&#34;link&#34; href=&#34;https://cnb.cool/ttf248/hugo-content-suite&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cnb.cool/ttf248/hugo-content-suite&lt;/a&gt;
国外プロジェクトアドレス：&lt;a class=&#34;link&#34; href=&#34;https://github.com/ttf248/hugo-content-suite&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ttf248/hugo-content-suite&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;コードの実装&#34;&gt;コードの実装
&lt;/h2&gt;&lt;p&gt;まず、実装の思路について説明します。すべての文章をスキャンし、タグ情報と記事タイトルを抽出した後、ローカルの大規模言語モデル（例：gemma-3-12b-it）を呼び出して翻訳します。&lt;/p&gt;
&lt;p&gt;実際の開発において、前世代の大規模言語モデルと比較して、&lt;code&gt;Claude4&lt;/code&gt; はいくつかの顕著な点を発揮しました。機能要件が多いため、&lt;code&gt;Claude4&lt;/code&gt; はインタラクティブメニューを自動的に設計し、さまざまな使用シナリオを考慮しました。例えば、タグ処理に関しては、&lt;code&gt;Claude4&lt;/code&gt; はタグの統計と分析だけでなく、分類統計もサポートし、さらに&lt;strong&gt;ラベルのない文章&lt;/strong&gt;を検出することも可能です。また、プレビュー機能やタグページ生成機能も提供しています。&lt;/p&gt;
&lt;p&gt;ローカルの大規模言語モデルとの連携、翻訳キャッシュの追加、大規模なコードのリファクタリングなど、&lt;code&gt;Claude4&lt;/code&gt; はすべて一度に完了し、ほとんど問題がありませんでした。プロジェクト規模は小さくても、多くの小さな機能を含んでいました。以前の開発プロセスでは、大規模言語モデルが前の内容を忘れてしまうことがよくありましたが、今回の &lt;code&gt;Claude4&lt;/code&gt; は非常に優れており、&lt;strong&gt;ほぼコンテキストを忘れることなく動作しました&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;要するに、スマート性が向上し、今後の開発には &lt;code&gt;Claude4&lt;/code&gt; をより多く使用し、日常的なコーディングの主力モデルとして活用していく予定です。&lt;/p&gt;
&lt;h2 id=&#34;翻訳キャッシュ&#34;&gt;翻訳キャッシュ
&lt;/h2&gt;&lt;p&gt;この注文に関する説明では、大規模モデルの呼び出し回数を減らすだけでなく、実際に12Bモデルをローカルで実行すると効率が非常に高く、時間ロスもありません。しかし、毎回大規模モデルを呼び出す場合は、やはり少し遅くなります。また、文章のリンクを固定するために、全量更新を実行した場合、文章のタイトルが長いため、稀に2回の翻訳結果が異なり、リンクが変わってしまうという状況が発生します。これは非常に困ります。&lt;/p&gt;
&lt;h2 id=&#34;機能最適化&#34;&gt;機能最適化
&lt;/h2&gt;&lt;p&gt;プロジェクト全体を &lt;code&gt;Claude4&lt;/code&gt; に引き渡して、最適化の余地を分析し、以下の提案を得ました：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;外部化の設定 - メンテナンス性と柔軟性を向上
構造化ログ - 問題のトラブルシューティングと監視が容易になる
パフォーマンスモニタリング - システムの状態を把握する
ユーザーエクスペリエンス - プログレスバーなどの視覚的なフィードバック
エラー処理 - より包括的な例外処理メカニズム
コード整理 - より明確なモジュール分割
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;コードをレビューしたところ、問題点は一切なく、例えば設定ファイルについては、元のコードから設定を変換し、デフォルト設定に変換した後、設定ファイルを読み込む際に、対応する設定ファイルが存在しない場合に自動的にデフォルト設定ファイルを生成することで、ユーザーの操作ミスを防いでいました。
要件：翻訳文の正体を翻訳する際に、翻訳効率を動的に計算し、残りの時間を予測して、関連情報をコンソールに出力しました。現在、文章の文字数を取得し、各行の翻訳時に現在の翻訳文字数、時間、100文字あたりの翻訳時間を適合計算しています。同時に、文章全体の翻訳残り時間を推定します。
コードが完了した後、新しい驚きを発見しました。翻訳効率の統計情報がリアルタイムで大量に表示されますが、無制限にスクロールダウンすることはありませんでした。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;原文を英語に翻訳中（合計 7163 文字）...
翻訳する必要がある行数が 53 行検出されました。
  [1/53] Stage1/6 [░░░░░░░░░░░░░░░░░░░░░░░░░] 1.9% 354 文字の翻訳...
    ✅ 完了 (3.1秒) | API呼び出し #1
    ✅ 完了 (1.5秒) | API呼び出し #2
    ✅ 完了 (0.9秒) | API呼び出し #3
    ✅ 完了 (0.2秒) | API呼び出し #4
    ✅ 完了 (1.0秒) | API呼び出し #5
    ✅ 完了 (1.0秒) | API呼び出し #6
    ✅ 完了 (0.2秒) | API呼び出し #7
    📊 進捗: 行の 13.2% (7/53) | 文字の 12.9% (925/7163) 114.6 文字/秒 📊
    ⚡ 効率：リアルタイム 76.4 | 平均 117.9 | 最近 109.0 | ステージ 113.6 文字/秒 📊
    🎯 正確度: 100.0% (7/7) | 残り: 46行 7 秒] 9.4% 110 文字の翻訳...
    ⏱️ 残りの推定時間: 55秒 | 予想完了時間: 00:10:19 8秒] 11.3% 114 文字の翻訳...
    💾 处理速度：3211.3 行/分钟 | 总用时：8秒] 13.2% 16 文字の翻訳...
  [8/53] Stage1/6 [███░░░░░░░░░░░░░░░░░░░░░░] 15.1% 166 文字の翻訳...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以前、プログラムを制御するコードはあまり書かれていませんでしたが、どのように実装されているのか知りたくて、コードを調べてみました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// キャッシュクリアと再表示（動的更新効果）
if translationCount &amp;gt; 1 {
   fmt.Print(&amp;quot;\033[6A\033[K&amp;quot;) // 上に 6 行移動し、内容をクリア
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;パフォーマンス統計メニュー&#34;&gt;パフォーマンス統計メニュー
&lt;/h3&gt;&lt;p&gt;新たに作成された&lt;strong&gt;パフォーマンス統計メニュー&lt;/strong&gt;は、私自身が設計したものでも、これほど完璧とは言えない。&lt;/p&gt;
&lt;p&gt;📊 パフォーマンス統計：
🔄 翻訳回数：360
⚡ キャッシュヒット率：1.4% (5/365)
⏱️ 平均翻訳時間：315.927234ms
📁 ファイル操作：73
❌ エラー回数：0&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;データマイニング&lt;/li&gt;
&lt;li&gt;ディープラーニング&lt;/li&gt;
&lt;li&gt;ニューラルネットワーク&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;=== ブログ管理ツール ===&lt;/p&gt;
&lt;p&gt;🚀 コア機能&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全ブログの処理をワンクリックで実行 (完全なブログ処理フロー)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;📝 コンテンツ管理
2. タグページを生成
3. アーティクルスラッグを生成
4. 記事を多言語バージョンに翻訳&lt;/p&gt;
&lt;p&gt;💾 キャッシュ管理
5. キャッシュの状態を確認
6. 全量翻訳キャッシュの生成
7. 翻訳キャッシュをクリア&lt;/p&gt;
&lt;ol start=&#34;0&#34;&gt;
&lt;li&gt;プログラム終了&lt;/li&gt;
&lt;/ol&gt;</description>
        </item>
        <item>
        <title>フォークのレポジトリにプルリクエストをマージする</title>
        <link>https://ttf248.life/ja/p/merge-pullrequest-to-forked-repo/</link>
        <pubDate>Wed, 07 May 2025 18:44:03 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/merge-pullrequest-to-forked-repo/</guid>
        <description>&lt;p&gt;&lt;code&gt;github-readme-stats&lt;/code&gt; は、GitHub の個人プロフィールに関する統計情報を生成するツールです。ユーザーの GitHub 個人プロフィールの様々な統計情報やグラフの表示を可能にします。多様なカスタマイズオプションを提供し、ユーザーのニーズに合わせて調整できます。&lt;/p&gt;
&lt;p&gt;筆者はリポジトリ管理の習慣として、プロジェクトごとにグループ化を行っていますが、GitHub はリポジトリのグループ化をサポートしていないため、異なる組織に分割することで実現しています。&lt;code&gt;github-readme-stats&lt;/code&gt; の最新ブランチでは、異なる組織のリポジトリ統計のクロスオーバーに対応していません。そこで、対応するコードをマージしたブランチをフォークしました。&lt;/p&gt;
&lt;h2 id=&#34;最終結果&#34;&gt;最終結果
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://github-readme-stats-chi-one-17.vercel.app/api?username=ttf248&amp;amp;hide_title=true&amp;amp;show_icons=true&amp;amp;hide=contribs&amp;amp;line_height=24&amp;amp;include_all_commits=true&amp;amp;count_private=true&amp;amp;bg_color=0000&amp;amp;text_color=8A919F&amp;amp;locale=cn&amp;amp;role=OWNER,COLLABORATOR,ORGANIZATION_MEMBER&amp;amp;timstamp=1746608356&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;GitHub Stats&#34;
	
	
&gt;
&lt;img src=&#34;https://github-readme-stats-chi-one-17.vercel.app/api/top-langs/?username=ttf248&amp;amp;hide_title=true&amp;amp;hide=html,javascript,css&amp;amp;layout=compact&amp;amp;bg_color=0000&amp;amp;text_color=8A919F&amp;amp;locale=cn&amp;amp;role=OWNER,COLLABORATOR,ORGANIZATION_MEMBER&amp;amp;timstamp=1746608356&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Top Languages&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;プルリクエスト-元のurl&#34;&gt;プルリクエスト 元のURL
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/anuraghazra/github-readme-stats/pull/2459&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;組織のリポジトリからのデータを含める機能を追加&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;上流のプルリクエストをフォークのリポジトリにマージする&#34;&gt;上流のプルリクエストをフォークのリポジトリにマージする
&lt;/h2&gt;&lt;p&gt;ある &lt;strong&gt;プルリクエスト (PR)&lt;/strong&gt; をあなたの &lt;strong&gt;フォークしたリポジトリ&lt;/strong&gt; にマージするには、いくつかの方法があり、あなたが以下のいずれかを達成したいかによって異なります。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;上流（upstream）リポジトリ&lt;/strong&gt; から PR をあなたのフォークにマージするか、&lt;/li&gt;
&lt;li&gt;他の人のフォークから PR をあなたのフォークにマージするか、&lt;/li&gt;
&lt;li&gt;あなたのフォークで作成された PR (例えば、他の人があなたにフォークして PR を提起した場合) をマージする&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;まず、最も一般的なシナリオを説明します：&lt;strong&gt;フォークしたリポジトリがあり、上流の PR をあなたのフォークにマージしたい場合&lt;/strong&gt;。操作手順は以下のとおりです👇&lt;/p&gt;
&lt;h3 id=&#34;-方法１コマンドライン方式最も汎用的&#34;&gt;✅ 方法１：コマンドライン方式（最も汎用的）
&lt;/h3&gt;&lt;h4 id=&#34;ステップ-1自分のフォークをクローンする&#34;&gt;ステップ 1：自分のフォークをクローンする
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/あなたのユーザー名/リポジトリ名.git
cd リポジトリ名
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;ステップ-2upstream-元のリポジトリのurl-を追加&#34;&gt;ステップ 2：upstream (元のリポジトリのURL) を追加
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git remote add upstream https://github.com/原作者のユーザー名/リポジトリ名.git
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;ステップ-3上流のprブランチをリポジトリに取得する&#34;&gt;ステップ 3：上流のPRブランチをリポジトリに取得する
&lt;/h4&gt;&lt;p&gt;マージしたいPRの番号（例：PR #123）を見つけます。&lt;/p&gt;
&lt;p&gt;以下のコマンドでそのPRのコードをリポジトリに取得できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git fetch upstream pull/123/head:pr-123
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;ステップ4ブランチを切り替えマージする&#34;&gt;ステップ4：ブランチを切り替え、マージする
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git checkout main    # またはあなたのターゲットブランチ
git merge pr-123
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;すべて正常であれば、GitHub リポジトリにフォークした場所にプッシュできます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git push origin main
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-方法二github-ウェブインターフェースシンプルだが限定的&#34;&gt;✅ 方法二：GitHub ウェブインターフェース（シンプルだが限定的）
&lt;/h3&gt;&lt;p&gt;GitHub のウェブ上で特定のプルリクエスト (PR) が上位のレポジトリに対するものである場合、以下の手順を実行できます。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;その PR ページにアクセスします。&lt;/li&gt;
&lt;li&gt;右上部の「&lt;strong&gt;Commits&lt;/strong&gt;」または「&lt;strong&gt;Files changed&lt;/strong&gt;」をクリックし、この PR がどのブランチに基づいて作成されているかを確認します。&lt;/li&gt;
&lt;li&gt;あなたのフォークページで新しいブランチを作成し、手動で PR のコミットを cherry-pick します（Git に関する知識が必要です）。&lt;/li&gt;
&lt;li&gt;または、「&lt;strong&gt;Open in GitHub Desktop&lt;/strong&gt;」をクリックして、GUI ツールを使用してマージします。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;-他人があなたのフォークに対してプルリクエストを送信した場合&#34;&gt;🚀 他人があなたのフォークに対してプルリクエストを送信した場合
&lt;/h3&gt;&lt;p&gt;プルリクエストのページに直接移動し、「&lt;strong&gt;Merge pull request&lt;/strong&gt;」ボタンをクリックしてください。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;具体的な状況（例えば、PRリンク、ウェブインターフェースを使用しているかコマンドラインを使用しているか）に応じて、ステップバイステップでデモンストレーションが必要ですか？ または、具体的なリンクを提供していただければ、最も簡単な方法を分析します。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Git での履歴記録におけるコミット情報</title>
        <link>https://ttf248.life/ja/p/git-modify-commit-message/</link>
        <pubDate>Wed, 07 May 2025 18:38:31 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/git-modify-commit-message/</guid>
        <description>&lt;p&gt;スクリプトは、Git履歴のコミットメッセージの作成者情報をまとめて変更するために使用され、&lt;code&gt;git filter-branch&lt;/code&gt;を使用してGit履歴を書き換えます。&lt;/p&gt;
&lt;p&gt;ご提供いただいたスクリプトは、Gitリポジトリの履歴コミットにおける作成者情報を一括で修正するものであり、全体的な考え方は正しいですが、&lt;code&gt;git filter-branch&lt;/code&gt; の &lt;code&gt;--env-filter&lt;/code&gt; で配列（例：&lt;code&gt;OLD_EMAILS=(&amp;quot;...&amp;quot;)&lt;/code&gt;）を使用すると、一部のシェル環境（例：&lt;code&gt;/bin/sh&lt;/code&gt;）では互換性の問題が発生する可能性があります。これは、配列構文がサポートされていないためです。
互換性を高めるために、配列をスペースで区切られた文字列に置き換え、&lt;code&gt;for&lt;/code&gt;ループを使用して各古いメールアドレスを反復処理することをお勧めします。以下は修正後のスクリプトの例です。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh

git filter-branch --env-filter &#39;
OLD_EMAILS=&amp;quot;TianlongXiang51@gmail.com nick@qq.com tianlongxiang51@gmail.com&amp;quot;
CORRECT_NAME=&amp;quot;tianlong.xiang&amp;quot;
CORRECT_EMAIL=&amp;quot;tianlong.xiang@foxmail.com&amp;quot;

for OLD_EMAIL in $OLD_EMAILS
do
    if [ &amp;quot;$GIT_COMMITTER_EMAIL&amp;quot; = &amp;quot;$OLD_EMAIL&amp;quot; ]
    then
        export GIT_AUTHOR_NAME=&amp;quot;$CORRECT_NAME&amp;quot;
        export GIT_AUTHOR_EMAIL=&amp;quot;$CORRECT_EMAIL&amp;quot;
    fi
    if [ &amp;quot;$GIT_AUTHOR_EMAIL&amp;quot; = &amp;quot;$OLD_EMAIL&amp;quot; ]
    then
        export GIT_COMMITTER_NAME=&amp;quot;$CORRECT_NAME&amp;quot;
        export GIT_COMMITTER_EMAIL=&amp;quot;$CORRECT_EMAIL&amp;quot;
    fi
done
&#39; --tag-name-filter cat -- --branches --tags
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;このスクリプトを実行する前に、リポジトリのバックアップを作成することを強くお勧めします。これにより、予期しない問題が発生した場合に備えることができます。&lt;/li&gt;
&lt;li&gt;この操作はGit履歴を書き換えており、コミット作成者の情報を変更するため、コミットハッシュが変更される可能性があります。&lt;/li&gt;
&lt;li&gt;既に変更をリモートリポジトリにプッシュしている場合は、強制プッシュを実行する必要があります。
強制プッシュには注意し、特に複数人での共同プロジェクトでは、他のメンバーへの影響がないように慎重に行ってください。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;リポジトリ内のすべてのユニークな作成者メールアドレスの統計&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git log --format=&#39;%an &amp;lt;%ae&amp;gt;&#39; | sort -u
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>コードを記述せず、カスタム株式選定モジュールを設計・開発する。</title>
        <link>https://ttf248.life/ja/p/design-develop-custom-stock-module-no-code/</link>
        <pubDate>Thu, 27 Feb 2025 23:20:39 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/design-develop-custom-stock-module-no-code/</guid>
        <description>&lt;p&gt;先月の当社では、cursorを試用しましたが、無料枠の制限により、複雑な機能開発は行わず、簡単なテストに留めました。その際に見つけたのは、Byte社も同様の製品を発表しており、両者は共通してClaude-3.5という大規模言語モデルを底で呼んでいる点でした。
Byte社の製品はTraeといい、最初にリリースされたmac版が今年2月にWindows版もリリースされました。大手企業のものは良いもので、無料でClaude-3.5を無制限に利用できるため、このモデルの性能は非常に優れています。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最終的にはK線チャートの開発で詰まってしまいました。Reactの知識が全くない私には、直接的に大きなタスクであるK線チャートの開発を引き受けることはできません。より細かくタスクを分割し、開発を進めるためには、筆者がフロントエンドの基礎知識を追加し、タスクを分解する必要がありました。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;発見された問題点&#34;&gt;発見された問題点
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;外国製のAIモデルを使用していたため、Vue3 + Element-Plusの学習データが不足しており、Reactをフロントエンドフレームワークとして採用しました。&lt;/li&gt;
&lt;li&gt;偶発的な構文エラーが存在する可能性があり、手動での修正が必要です。&lt;/li&gt;
&lt;li&gt;一部の複雑な問題に対する解決策は、人的指導が必要となります。&lt;/li&gt;
&lt;li&gt;コード構造の最適化には、人的指導が必要です。&lt;/li&gt;
&lt;li&gt;最も時間がかかったのは、フロントエンドコードをコンテナにパッケージングすることでした。筆者は環境が全く理解されておらず、&lt;code&gt;.env.production&lt;/code&gt;や&lt;code&gt;tsconfig.json&lt;/code&gt;といった概念自体を知らなかったため、途中で助けを求める豆包（ネットでの質問サイトのユーザー）に頼らざるを得ませんでした。フロントエンドの開発 devモードとbuildモードでは、コードチェックや差異が大きく異なり、対応に苦慮しました。バックエンドのデータベースおよびサービスのコンテナスクリプトは、合計5分で完了しましたが。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AIは現状では開発効率を向上させる主な役割であり、基礎があることが最も重要です。AIがすべての問題を解決してくれるわけではありません。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;リポジトリアドレス&#34;&gt;リポジトリアドレス
&lt;/h2&gt;&lt;p&gt;タイトル通り、今回は手を動かさず、AIと雑談して、自選株モジュールを設計・開発してみます。最終的に何ができるのか試していきます。&lt;/p&gt;
&lt;p&gt;リポジトリアドレス：&lt;a class=&#34;link&#34; href=&#34;https://github.com/ttf248/trae-demo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ttf248/trae-demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;詳細な使用方法は、リポジトリのREADME.mdファイルをご覧ください。&lt;/p&gt;
&lt;p&gt;このリポジトリには多数の提出記録が含まれており、ほとんどが私とTraeとの会話記録、およびTraeの機能に対する私のテストです。対応する機能を実装するために人工干渉を行ったかどうかを備考に記載しています。&lt;/p&gt;
&lt;h2 id=&#34;プロンプト&#34;&gt;プロンプト
&lt;/h2&gt;&lt;p&gt;プロジェクトは、ゼロから作成するものですが、以下の内容がプロジェクトのプロンプトです：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;プロジェクトのプロトタイプ図に基づいて、以下の機能を開発してください：
    *   選別銘柄（ウォッチリスト）機能。契約新規追加、削除、修正、照会をサポートする必要があります。
    *   選別銘柄インターフェースは、基本的な市場データを表示する必要があります。
    *   複数の異なる市場の切り替えをサポートする必要があります。

    フロントエンド：React
    バックエンド：Golang Gin GORM
    データベース：PostgreSQL

    サーバーサイドには、クロスオリジンリクエストをサポートする必要があり、データの検証とエラー処理も考慮する必要があります。バックエンドサービスが利用できない場合、フロントエンドはアラートを表示する必要があります。

    バックエンドは、リクエストとレスポンスのログを表示し、フロントエンドも通信ログを出力して問題のトラブルシューティングに役立てます。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;uiとインタラクションの最適化&#34;&gt;UIとインタラクションの最適化
&lt;/h2&gt;&lt;p&gt;フロントエンドインターフェースのデザインは完全にGrokに依存しています。まず、Trae内で成果物のプロトタイプを作成しましたが、美観が欠けていました。使用していたモデルはコード能力は非常に高いものの、他の能力は弱いため、Grokを使用してフロントエンドのUIを最適化する必要があります。&lt;/p&gt;
&lt;p&gt;現在のインターフェースのスクリーンショットを撮影し、それをGrokにアップロードして、UIを最適化するように指示します。これにより、一度に多くの最適化提案を受け取ることができ、それらを人工的に評価し、Traeにコピーして実行し、最適化の効果を確認できます。&lt;/p&gt;
&lt;h3 id=&#34;技術スタック&#34;&gt;技術スタック
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;フロントエンド：React + TypeScript&lt;/li&gt;
&lt;li&gt;バックエンド：Golang + Gin + GORM&lt;/li&gt;
&lt;li&gt;データベース：PostgreSQL 17&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;システムアーキテクチャ&#34;&gt;システムアーキテクチャ
&lt;/h2&gt;&lt;h2 id=&#34;バックエンドアーキテクチャ&#34;&gt;バックエンドアーキテクチャ
&lt;/h2&gt;&lt;p&gt;バックエンドは Golang の Gin フレームワークを用いて RESTful API を実装しており、主なモジュールには以下が含まれます。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;データベースモジュール&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;GORM を ORM 框架として使用&lt;/li&gt;
&lt;li&gt;環境変数でデータベース接続を設定可能&lt;/li&gt;
&lt;li&gt;自動的にデータベーススキーマのマイグレーションを実行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ルーティングモジュール&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;RESTful API 設計&lt;/li&gt;
&lt;li&gt;一貫したエラーハンドリングメカニズム&lt;/li&gt;
&lt;li&gt;内蔵されたリクエストログ記録&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;クロスオリジン処理&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;ローカル開発環境でのクロスオリジンをサポート&lt;/li&gt;
&lt;li&gt;設定可能な CORS ポリシー&lt;/li&gt;
&lt;li&gt;Cookie を使用したクロスオリジンをサポート&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;フロントエンドアーキテクチャ&#34;&gt;フロントエンドアーキテクチャ
&lt;/h2&gt;&lt;p&gt;フロントエンドはReact + TypeScriptで構築され、以下の機能を実装しています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;株価リストの表示&lt;/li&gt;
&lt;li&gt;お気に入り銘柄の管理&lt;/li&gt;
&lt;li&gt;相場データ表示&lt;/li&gt;
&lt;li&gt;エラー通知メカニズム&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Protobufのゼロ値問題：デフォルト値が暗黙のビジネスロジックの致命的な脅威となる</title>
        <link>https://ttf248.life/ja/p/protobuf-zero-value-trap/</link>
        <pubDate>Thu, 20 Feb 2025 15:26:51 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/protobuf-zero-value-trap/</guid>
        <description>&lt;p&gt;米国株式市場には、プレマーケット、マーケットオープン後、マーケットクローズの3つの取引時間があります。データ配信は、プッシュ通知を使用するか、数値増分のロジック（可能な限り帯域幅を節約）を採用します。初回送信では全量データを送りますが、2回目以降はすべてのフィールドを増分で推送します。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;なぜ最適解を用いないのか？複数のプロジェクトグループに分散しており、一部はすでに数年ローンチされています。弊社は新規の連携のため、できる限り互換性を保つようにしています。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;いくつかの問題点&#34;&gt;いくつかの問題点
&lt;/h2&gt;&lt;p&gt;概要だけでは、特に問題がないように見えるかもしれないが、社内システムアーキテクチャに組み込まれた問題や、それらを引き起こす一連の問題が発生する。直前に問題を解決したにもかかわらず、新たな問題が発生し、その問題は以前の問題によって引き起こされたものである。&lt;/p&gt;
&lt;h3 id=&#34;取引時間帯の認識エラー&#34;&gt;取引時間帯の認識エラー
&lt;/h3&gt;&lt;p&gt;盤中ステージを &lt;code&gt;protobuf&lt;/code&gt; で定義されている 0 と認識していますが、増分配信のため、業務側ではこの 0 がデフォルト値なのか、それとも実際の取引値なのかを明確に判断できません。&lt;/p&gt;
&lt;p&gt;分かりやすく言うと、0 を受信した際に、それが新しい行情設定の値なのか、protobuf のデフォルト値なのかを判断できないということです。&lt;/p&gt;
&lt;h3 id=&#34;オプショナルについて&#34;&gt;オプショナルについて
&lt;/h3&gt;&lt;p&gt;protobuf 3.15 以降、proto3 では (proto2 と同様に) オプショナルキーワードを使用してスカラーフィールドの存在情報を指定できるようになりました。&lt;/p&gt;
&lt;p&gt;チーム内の通信プロトコルは &lt;code&gt;protobuf&lt;/code&gt; をベースにしていますが、歴史的な理由により選択されたバージョンが古く、&lt;code&gt;optional&lt;/code&gt; キーワードをサポートしていません。理解している方はご存知でしょう。底层から &lt;code&gt;protobuf&lt;/code&gt; を導入したため、プロジェクトの底层は静的ライブラリとして &lt;code&gt;protobuf&lt;/code&gt; を公開しており、その結果、全体のコンパイルチェーン全体をアップグレードする必要があり、このコストは非常に高くなっています。&lt;/p&gt;
&lt;h3 id=&#34;gcc-のバージョン問題&#34;&gt;GCC のバージョン問題
&lt;/h3&gt;&lt;p&gt;ようやく解決策を思いついたのだが、底层で異なるバージョンのリリースをするという方法を試みた。可能な限り &lt;code&gt;protobuf&lt;/code&gt; の新しいバージョンのコンパイル依存関係の伝播を制御しようとした。しかし、コンパイル時に &lt;code&gt;gcc&lt;/code&gt; のバージョンが低すぎて、&lt;code&gt;protobuf&lt;/code&gt; の新機能に対応していないことが判明した。
グループ内でよく使われるサーバーの種類：CentOS7、CentOS8。CentOS7 のデフォルトの &lt;code&gt;gcc&lt;/code&gt; バージョンは 4.8 であり、CentOS8 のデフォルトの &lt;code&gt;gcc&lt;/code&gt; バージョンは 8.3 である。&lt;code&gt;protobuf&lt;/code&gt; の新機能は &lt;code&gt;gcc&lt;/code&gt; のバージョンが 7.4 以上であることを必要とするため、CentOS7 はサポートできない。
&lt;a class=&#34;link&#34; href=&#34;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=82461&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Bug 82461 - [7 Regression] Temporary required for brace-initializing (non-literal-type) member variable&lt;/a&gt;。
結局、関連サービスのデプロイやコンパイルサーバーを CentOS8 に移動することで問題を解決した。&lt;/p&gt;
&lt;h2 id=&#34;理論的な列挙&#34;&gt;理論的な列挙
&lt;/h2&gt;&lt;p&gt;問題を全体的に見直すと、よりシンプルで効率的な解決策があります。それは、列挙の定義を調整し、1から番号付けするようにすることです。これにより、デフォルト値とビジネス値を明確に区別でき、上記のような問題を防ぐことができます。&lt;/p&gt;
&lt;h3 id=&#34;なぜ-1-から始める方が合理的なのか&#34;&gt;なぜ 1 から始める方が合理的なのか？
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;protobuf&lt;/code&gt; において、enum 型のデフォルト値は固定で 0 に設定されています。もし、有意義なビジネス値を 0 (例えば「市場中」) に定義した場合、増量プッシュ時にビジネス側では受信した 0 がビジネス値なのか、未設定のデフォルト値なのか判断できません。一方、enum を 1 から定義すれば、0 は無意味なデフォルト値または「未知」の状態として保持でき、問題が解決されます。&lt;/p&gt;
&lt;p&gt;推奨される実践：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;protobuf の enum を設計する際には、常に 0 を無意味なデフォルト値 (例: &lt;code&gt;UNKNOWN&lt;/code&gt; または &lt;code&gt;RESERVED&lt;/code&gt;) として定義すること。&lt;/li&gt;
&lt;li&gt;実際のビジネス値を 1 から割り当て、デフォルト値 0 と区別できるようにすること。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この小さな調整により、取引時間帯の識別の問題を解決するだけでなく、将来のプロトコル設計にも貴重な教訓を提供しました。&lt;/p&gt;</description>
        </item>
        <item>
        <title>バックエンドサービス TCP 通信異常トラブルシューティング</title>
        <link>https://ttf248.life/ja/p/backend-service-tcp-communication-troubleshooting/</link>
        <pubDate>Fri, 14 Feb 2025 22:54:13 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/backend-service-tcp-communication-troubleshooting/</guid>
        <description>&lt;p&gt;ビジネスモデル：バックエンドサービスがTCPを通じてグループの行情ゲートウェイと接続します。接続ごとに、最初に権限リクエストを送信し、その後継続的にハニーポットパケットを送信して接続状態を維持します。&lt;/p&gt;
&lt;p&gt;しかし、ある日、サービス切断警告の情報を受け取りました。詳細なログ調査の結果、バックエンドサービスは継続的にハニーポットパケットを送信していたにもかかわらず、相手からの応答が一切なく、接続自体が断続的に切断されていました。&lt;/p&gt;
&lt;h2 id=&#34;現場要約&#34;&gt;現場要約
&lt;/h2&gt;&lt;p&gt;当初、社内プロジェクトの進捗をオフィスで作業中に、グループチャットに警報情報がポップアップした。一 glance で見ると、以前からの恒常的な問題だと思い、おそらくネットワークタイムアウトによって心拍送信が失敗し、その結果サービスが切断されたと推測した。しかし、ログの詳細な調査の結果、実際にはそうではなかったことが判明した。バックエンドで権限認証メッセージを送信したが、応答を受信せず、同時に心拍パケットは継続的に送信され続け、相手からは心拍データに対する応答が一切なかった。ログの徹底的な分析により、以下の重要な問題点が明らかになった：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;権限認証メッセージへの応答なし：おそらく相手側のシステムが再起動しており、その結果権限認証メッセージがタイムリーに処理されなかった可能性がある。&lt;/li&gt;
&lt;li&gt;権限認証失敗中に心拍パケット送信：調査の結果、これはプログラムロジック上の脆弱性であることが判明した。心拍送信関数の判断ロジックに欠陥があり、接続状態のみを検証し、権限状態の検証を省略していた。&lt;/li&gt;
&lt;li&gt;サービスが切断されなかったこと：もしサービスが切断可能であれば、再接続メカニズムをトリガーして権限認証メッセージを再送信することができた。
現在、解決すべき最後の課題は、なぜサービスが切断されなかったのかである。この問題の解決には、より詳細で精緻な調査が必要となる。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ネットワークパケットの分析&#34;&gt;ネットワークパケットの分析
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;tcpdump&lt;/code&gt; は非常に強力なネットワークパケットキャプチャツールであり、ネットワークパケットを捕捉するために使用できます。ネットワークパケットを分析することで、通信の詳細をより直感的に理解することができます。ここでは、&lt;code&gt;tcpdump&lt;/code&gt; を使用してネットワークパケットをキャプチャし、さらに分析します。
&lt;img src=&#34;https://ttf248.life/p/backend-service-tcp-communication-troubleshooting/20250220151952.png&#34;
	width=&#34;1126&#34;
	height=&#34;202&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;tcpdump&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;557&#34;
		data-flex-basis=&#34;1337px&#34;
	
&gt;
分析図のデータから、心拍が正常に送信され続けていること、相手側のサーバーが応答していないこと、そして &lt;code&gt;ACK&lt;/code&gt; が送られていることがわかります。これにより接続は積極的に切断されません。&lt;/p&gt;
&lt;h2 id=&#34;共通フラグの説明&#34;&gt;共通フラグの説明
&lt;/h2&gt;&lt;p&gt;TCP プロトコルにおいて、&lt;code&gt;PSH&lt;/code&gt; (Push) と &lt;code&gt;ACK&lt;/code&gt; (Acknowledgment) は重要なフラグであり、それぞれデータ転送の制御とフロー制御に使用されます。その機能は以下のとおりです。&lt;/p&gt;
&lt;h3 id=&#34;1-psh-push-flag&#34;&gt;&lt;strong&gt;1. PSH (Push Flag)&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;機能:&lt;/strong&gt;
&lt;code&gt;PSH&lt;/code&gt; フラグは、&lt;strong&gt;受信側がバッファ内のデータを上位のアプリケーションに即時送信するように要求する&lt;/strong&gt; 役割を持ちます（バッファが満杯で待つのではなく）。 つまり、&lt;code&gt;PSH&lt;/code&gt; フラグが付いたデータ段を受信すると、受信側はできるだけ早くそのデータをアプリケーションに処理して送信し、オペレーティングシステムのバッファに一時的に保存することはありません。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;典型的なシナリオ:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTTP/HTTPS リクエスト:&lt;/strong&gt; クライアントがリクエストを送信する際（例: &lt;code&gt;GET /index.html&lt;/code&gt;）には &lt;code&gt;PSH&lt;/code&gt; が設定され、サーバーから即時の応答を希望します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SSH プロトコル:&lt;/strong&gt; 毎回キーボード入力が発生すると &lt;code&gt;PSH&lt;/code&gt; がトリガーされ、入力された文字をリアルタイムで転送します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;リアルタイム通信:&lt;/strong&gt; ビデオストリームやオンラインゲームなど、低遅延のシナリオでは &lt;code&gt;PSH&lt;/code&gt; を使用して遅延を減らすことがあります。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PSH&lt;/code&gt; は必須ではありません。受信側はフラグを無視することもできます（ただし、データを正常に処理する必要があります）。&lt;/li&gt;
&lt;li&gt;送信側が &lt;code&gt;PSH&lt;/code&gt; を設定しない場合、受信側は自身のバッファリング戦略に基づいてデータ送信のタイミングを決定します。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2-ackacknowledgment-flag&#34;&gt;&lt;strong&gt;2. ACK（Acknowledgment Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;機能&lt;/strong&gt;：
&lt;code&gt;ACK&lt;/code&gt; フラグは、&lt;strong&gt;前段のデータが正しく受信されたことを示す&lt;/strong&gt;。各 &lt;code&gt;ACK&lt;/code&gt; には確認番号（&lt;code&gt;Acknowledgment Number&lt;/code&gt;）が含まれており、これは期待される次のバイトのシーケンス番号を表す。TCP の信頼性のある転送の中核メカニズムである。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;動作原理&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;送信側がデータ段を送信すると、期待する受信側の &lt;code&gt;ACK&lt;/code&gt; 値（例えば &lt;code&gt;ACK = シーケンス番号 + データ長&lt;/code&gt;）を付加する。&lt;/li&gt;
&lt;li&gt;受信側がデータを受信すると、受信したデータのシーケンス番号を確認するための &lt;code&gt;ACK&lt;/code&gt; 報文段を生成する。&lt;/li&gt;
&lt;li&gt;送信側は、対応する &lt;code&gt;ACK&lt;/code&gt; を受信するまで再送を行わない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;例&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;送信側がシリアル番号 &lt;code&gt;100～199&lt;/code&gt; のデータ段を送信した場合、期待される受信側の &lt;code&gt;ACK&lt;/code&gt; は &lt;code&gt;200&lt;/code&gt; になる。&lt;/li&gt;
&lt;li&gt;受信側が &lt;code&gt;100～199&lt;/code&gt; 内の特定のデータを受信しない場合、&lt;code&gt;ACK=150&lt;/code&gt; を通じて送信側に再送を通知する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-psh-と-ack-の組み合わせ&#34;&gt;&lt;strong&gt;3. PSH と ACK の組み合わせ&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;TCP 報文において、&lt;code&gt;PSH&lt;/code&gt; (Push) と &lt;code&gt;ACK&lt;/code&gt; (確認応答) は同時に出現することがあり、以下のようなシナリオでよく見られます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTTP リクエスト応答&lt;/strong&gt;：&lt;br&gt;
クライアントが &lt;code&gt;POST&lt;/code&gt; リクエスト（データを含む）を送信する際、&lt;code&gt;PSH&lt;/code&gt; と &lt;code&gt;ACK&lt;/code&gt; を設定し、前の応答の確認を行います。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SSH ハンドシェイク後のコマンド転送&lt;/strong&gt;：&lt;br&gt;
クライアントがコマンドを入力した後、&lt;code&gt;PSH&lt;/code&gt; と &lt;code&gt;ACK&lt;/code&gt; が付いたデータ段を送信することで、コマンドが即座にサーバーで処理されるようにします。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-その他の関連を示すフラグ&#34;&gt;&lt;strong&gt;4. その他の関連を示すフラグ&lt;/strong&gt;
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;フラグ&lt;/th&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;概要&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SYN&lt;/td&gt;
&lt;td&gt;シーケンス&lt;/td&gt;
&lt;td&gt;接続の初期化 (3ウェイハンドシェイク)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;4-その他の重要な関連&#34;&gt;&lt;strong&gt;4. その他の重要な関連&lt;/strong&gt;
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;標識&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;概要&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;FIN&lt;/td&gt;
&lt;td&gt;終了&lt;/td&gt;
&lt;td&gt;エレガントな接続のクローズ&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;4-その他の関連を示すフラグ-1&#34;&gt;&lt;strong&gt;4. その他の関連を示すフラグ&lt;/strong&gt;
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;フラグ&lt;/th&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;概要&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;RST&lt;/td&gt;
&lt;td&gt;リセット&lt;/td&gt;
&lt;td&gt;接続の強制終了 (異常状況)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;4-その他の重要な関連-1&#34;&gt;&lt;strong&gt;4. その他の重要な関連&lt;/strong&gt;
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;標識&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;概要&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;URG&lt;/td&gt;
&lt;td&gt;緊急&lt;/td&gt;
&lt;td&gt;緊急ポインタのマーク (ほとんど使用されない)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;4-その他の関連要素&#34;&gt;&lt;strong&gt;4. その他の関連要素&lt;/strong&gt;
&lt;/h3&gt;&lt;h3 id=&#34;まとめ&#34;&gt;&lt;strong&gt;まとめ&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;PSH&lt;/strong&gt; は、&lt;strong&gt;データのアプリケーション層への迅速な到達&lt;/strong&gt; と遅延の低減に焦点を当てています。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ACK&lt;/strong&gt; は、&lt;strong&gt;データの信頼性の高い伝送&lt;/strong&gt; とパケットロスや乱数（順不同）を防ぐことに焦点を当てています。
両者は連携して、TCP プロトコルの効率性と信頼性をバランスしています。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>ollama ローカル実行 deepseek-R1</title>
        <link>https://ttf248.life/ja/p/ollama-local-deployment-deepseek-r1/</link>
        <pubDate>Fri, 07 Feb 2025 22:41:02 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/ollama-local-deployment-deepseek-r1/</guid>
        <description>&lt;p&gt;Ollamaは、大規模言語モデル（LLM）をローカルで実行およびデプロイすることを目的としたオープンソースのAIツールです。クラウドサービスへの依存なしに、開発者がローカルマシン上でGPTのようなモデルを使用するための簡単なかつ効率的な方法を提供することを目指しています。Ollamaは複数のモデルに対応し、パフォーマンスを最適化することで、リソースが限られたデバイスでもこれらのモデルをスムーズに実行できるように設計されています。&lt;/p&gt;
&lt;p&gt;Ollamaを使用すると、ユーザーはテキストベースのAIアプリケーションを利用でき、ローカルでデプロイされたモデルとインタラクトすることができ、データプライバシーやAPIの使用料金に関する懸念なく、自然言語処理や質問応答などのタスクを実行できます。コマンドラインインターフェース（CLI）を通じて異なるモデルを呼び出し、これらのタスクを実行できます。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ollamaは様々なモデルを試すのに適しており、Windows版のテストではハードウェアの性能を十分に発揮できなかった可能性があります。これはWindows版の問題かもしれません。Linux版の方が良い結果が得られる可能性があります。32bパラメータのモデルをデプロイし、メモリとGPU負荷が低い場合に、応答速度が遅いことが確認されました。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;ハードウェア概要&#34;&gt;ハードウェア概要
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;オペレーティングシステム: Windows 11&lt;/li&gt;
&lt;li&gt;CPU: i7-10700K&lt;/li&gt;
&lt;li&gt;メモリ: 40GB&lt;/li&gt;
&lt;li&gt;グラフィックカード: RTX 3060 12GB&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;環境準備&#34;&gt;環境準備
&lt;/h2&gt;&lt;p&gt;以下のシステム環境変数を設定し、後続の使用を容易にします：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;set OLLAMA_MODELS=E:\ollama&lt;/code&gt;&lt;/strong&gt;
この変数で Ollama モデルの保存場所を指定します。 &lt;code&gt;E:\ollama&lt;/code&gt; はフォルダパスであり、ダウンロードまたはデプロイしたローカルモデルファイルをすべてここに格納します。Ollama はこのパスに基づいてモデルをロードおよび使用します。モデルファイルの保存場所を変更する場合は、このパスを更新してください。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;set OLLAMA_HOST=127.0.0.1:8000&lt;/code&gt;&lt;/strong&gt;
Ollama サービスのホストとポートを設定します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;127.0.0.1&lt;/code&gt; はローカルアドレス（localhost）であり、Ollama サービスは本機からのリクエストのみを待ち受けます。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;8000&lt;/code&gt; は指定するポート番号であり、Ollama サービスが 8000 ポートでリクエストを受信および処理します。必要に応じてポート番号を変更できますが、他のアプリケーションで使用されていないことを確認してください。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;set OLLAMA_ORIGINS=*&lt;/code&gt;&lt;/strong&gt;
Ollama サービスへのアクセスを許可するオリジン（ソース）を制御します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; はすべてのオリジン（つまり、すべてのドメインと IP アドレス）が Ollama サービスにアクセスできることを意味します。これは通常、開発およびデバッグ環境で使用されます。本番環境では、セキュリティを高めるために、特定のドメインまたは IP アドレスのみを許可するようにより厳格なオリジン制御を設定することが一般的です。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;deepseek-r1-モデルのデプロイ&#34;&gt;DeepSeek-R1 モデルのデプロイ
&lt;/h2&gt;&lt;p&gt;ollama のインストールは、初心者向けで簡単なため、詳細は省略します。
インストール後の検証：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\core&amp;gt;ollama -v
ollama version is 0.5.11
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;モデルのデプロイについては、公式ウェブサイトのモデルページを参照し、対応するパラメータのモデルを選択してください: &lt;code&gt;ollama run deepseek-r1:14b&lt;/code&gt;
14b パラメータは会話コンテキストを効果的に記憶でき、より小さなパラメータバージョンではコンテキストを記憶できません。32b パラメータバージョンは、ローカルでのデプロイ時に非常に遅延するため、詳細なテストは行っていません。&lt;/p&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.ollama.com/library/deepseek-r1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.ollama.com/library/deepseek-r1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://mp.weixin.qq.com/s/SPEvYTmTBxhoEkJqm1yPmw&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mp.weixin.qq.com/s/SPEvYTmTBxhoEkJqm1yPmw&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/x18990027/article/details/145368094&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/x18990027/article/details/145368094&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>PowerShell 7 と Persistence 設定 コマンドライン予測ビュー</title>
        <link>https://ttf248.life/ja/p/powershell-7-persisting-settings-commandline-prediction-view/</link>
        <pubDate>Fri, 07 Feb 2025 22:19:12 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/powershell-7-persisting-settings-commandline-prediction-view/</guid>
        <description>&lt;p&gt;Linux で使慣れた zsh を、昨日ブログを書いている時に、突然 PowerShell 7 もセッション保持設定でコマンド履歴予測ビューをサポートしていることを発見し、試しに触ってみたら、意外と便利だった。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;何が原因かはわからないけど、何か操作をしてこの機能を起動しただけで、それで終わり。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;現在多様化するオペレーティング環境において、システム管理者や開発者は、プラットフォーム間での互換性、効率性、そして強力な機能を備えたツールを求めています。PowerShell 7 はまさにそのニーズに応える注目を集めているツールです。強力なスクリプト作成能力に加え、Windows、Linux、macOS など様々なオペレーティングシステム上で動作するため、ユーザーに前例のない利便性をもたらします。&lt;/p&gt;
&lt;h2 id=&#34;powershell-7クロスプラットフォームな強力なツール&#34;&gt;PowerShell 7：クロスプラットフォームな強力なツール
&lt;/h2&gt;&lt;h3 id=&#34;クロスプラットフォーム特性&#34;&gt;クロスプラットフォーム特性
&lt;/h3&gt;&lt;p&gt;PowerShell 7は、プラットフォームの制限を打破し、Windowsシステムでのエンタープライズレベルのサーバー管理、Linux環境でのシステム運用、macOSでの日常開発タスクなど、あらゆる環境で一貫してPowerShell 7ツールを使用できます。これにより、作業効率が大幅に向上し、プラットフォームの違いによる学習コストや操作複雑性の問題を軽減します。&lt;/p&gt;
&lt;h3 id=&#34;強力な機能&#34;&gt;強力な機能
&lt;/h3&gt;&lt;p&gt;強力なスクリプト作成能力を備え、オブジェクト指向プログラミング、関数、モジュールなどの高度なプログラミング特性をサポートします。PowerShell 7 を通じて、ユーザーはファイルシステムを簡単に操作し、ファイルやフォルダの作成、削除、コピー、移動などの操作を実行できます。レジストリにアクセスして変更することで、システムの構成を深く調整することも可能です。プロセスとサービスを管理し、システムの状態を効果的に監視および制御することもできます。さらに、PowerShell 7 は、Active Directory におけるユーザーと権限の管理や、Azure クラウドプラットフォームにおけるリソースの配分と管理など、さまざまな Windows および非 Windows 技術との相互作用も可能です。&lt;/p&gt;
&lt;h3 id=&#34;オープンソースエコシステム&#34;&gt;オープンソースエコシステム
&lt;/h3&gt;&lt;p&gt;PowerShell 7はオープンソースであり、この特性により、世界中の開発者や愛好家がその開発と改善に積極的に参加できるようになっています。大量のオープンソースモジュールやツールが継続的に登場し、PowerShell 7 の機能と応用シナリオを豊かにしています。ユーザーは自分のニーズに応じて、オープンソースコミュニティで適切なモジュールを見つけて PowerShell 7 の機能を拡張したり、自身のコードを貢献してコミュニティ全体の発展を推進したりすることができます。&lt;/p&gt;
&lt;h3 id=&#34;互換性と安定性&#34;&gt;互換性と安定性
&lt;/h3&gt;&lt;p&gt;PowerShell 7は、旧バージョンのPowerShellとの互換性を維持しながら、多くの新機能と改善を導入しました。これらの改善により、パフォーマンスが向上し、安定性が強化され、ユーザーはさまざまなタスクをよりスムーズに実行でき、ソフトウェアの故障による作業中断を減らすことができます。&lt;/p&gt;
&lt;h2 id=&#34;コマンドレット予測ビューの起動&#34;&gt;コマンドレット予測ビューの起動
&lt;/h2&gt;&lt;p&gt;PowerShell 7 の多くの便利な機能の中で、&lt;code&gt;Set-PSReadLineOption -PredictionViewStyle ListView&lt;/code&gt; コマンドは、ユーザーのコマンドライン入力体験を向上させるための実用的なツールです。&lt;/p&gt;
&lt;p&gt;コマンドを実行しなくても自動補完を実現できますが、これは行内での補完に限定されます。この機能を有効にすると、リスト形式で可能なすべての補完オプションを表示する予測ビューが利用できるようになり、ユーザーは上下キーを使用して必要なオプションを選択することで、コマンド入力の正確性と効率を向上させることができます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/powershell-7-persisting-settings-commandline-prediction-view/20250207222546.png&#34;
	width=&#34;814&#34;
	height=&#34;205&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;powershell7&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;397&#34;
		data-flex-basis=&#34;952px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;コマンドを永続化する方法&#34;&gt;コマンドを永続化する方法
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Set-PSReadLineOption -PredictionViewStyle ListView&lt;/code&gt; のようなコマンドを、PowerShellの起動時に常に有効にするには、それを PowerShell の設定ファイルに追加します。PowerShellの設定ファイルは、PowerShell が起動される際に自動的に実行する命令を含む特別なスクリプトです。&lt;/p&gt;
&lt;h3 id=&#34;設定ファイルのパスを特定する&#34;&gt;設定ファイルのパスを特定する
&lt;/h3&gt;&lt;p&gt;PowerShell では、&lt;code&gt;$PROFILE&lt;/code&gt; 変数を使用して設定ファイルのパスを確認できます。もしこのパスにファイルが存在しない場合は、ユーザーは手動で作成することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo $PROFILE
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;設定ファイルのオープン&#34;&gt;設定ファイルのオープン
&lt;/h3&gt;&lt;p&gt;テキストエディタ（例えば、高機能な Notepad++ や軽量の Visual Studio Code）を使用して、$PROFILE 変数で取得した設定ファイルパスに対応するファイルを開きます。&lt;/p&gt;
&lt;h3 id=&#34;コマンドの追加&#34;&gt;コマンドの追加
&lt;/h3&gt;&lt;p&gt;開いている構成ファイルに、&lt;code&gt;Set-PSReadLineOption -PredictionViewStyle ListView&lt;/code&gt; コマンドを追加します。コマンドの記述が正確であることを確認し、構成ファイルを実行する際に正しく有効になるようにしてください。&lt;/p&gt;
&lt;h3 id=&#34;構成ファイルへの保存&#34;&gt;構成ファイルへの保存
&lt;/h3&gt;&lt;p&gt;コマンドの追加が完了したら、構成ファイルを保存しテキストエディタを閉じます。これにより、構成ファイルには、PowerShell起動時に実行したいと希望するコマンドが含まれるようになります。&lt;/p&gt;
&lt;h3 id=&#34;検証設定&#34;&gt;検証設定
&lt;/h3&gt;&lt;p&gt;現在の PowerShell ウィンドウを閉じ、PowerShell を再起動します。 新しく起動した PowerShell でコマンドを入力する際、コマンドラインでの予測ビュースタイルの表示が、当方の設定に従いリスト形式で表示されることを確認します。 これにより、当方の設定が正常に適用されたことを示します。
上記の手順を実行することで、PowerShell 7 の強力な機能と特性についてより深く理解し、コマンドラインでの予測ビュースタイルの設定方法を習得するとともに、これらの設定を永続的に適用する方法も学びます。 これらの知識が、PowerShell 7 を使用する際に、よりスムーズかつ効率的に様々なシステム管理および自動化タスクを完了できるようになることを願っています。&lt;/p&gt;
&lt;h2 id=&#34;参考資料&#34;&gt;参考資料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/PowerShell/PowerShell/releases&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/PowerShell/PowerShell/releases&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.v2ex.com/t/911909&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.v2ex.com/t/911909&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Visual Studio が「不整合な」PDB ファイルをロードできません。</title>
        <link>https://ttf248.life/ja/p/visual-studio-load-unmatched-pdb/</link>
        <pubDate>Thu, 23 Jan 2025 20:04:33 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/visual-studio-load-unmatched-pdb/</guid>
        <description>&lt;p&gt;WindowsでVisual Studioを使ってプログラムをデバッグする場合、PDBファイルと実行可能ファイルが一致しない場合、Visual Studioは「シンボルファイルを読み込めません」というエラーを表示します。プログラムの実行中にクラッシュが発生し、ダンプファイルが生成される場合、不一致なPDBファイルの場合、Visual Studioはクラッシュ現場にスムーズに入ることができません。&lt;/p&gt;
&lt;h2 id=&#34;pdb-ファイルとは&#34;&gt;PDB ファイルとは
&lt;/h2&gt;&lt;p&gt;PDB ファイルは、Microsoft が提供するデバッグ情報ファイルで、プログラムのデバッグに使用されます。PDB ファイルには、シンボルテーブル、ソースコード名、行番号などの情報が含まれています。プログラムをコンパイルするときに PDB ファイルが生成され、プログラムのデバッグに使用されます。&lt;/p&gt;
&lt;h2 id=&#34;windbg-デバッグ&#34;&gt;WinDbg デバッグ
&lt;/h2&gt;&lt;p&gt;WinDbg は Microsoft 製のデバッガで、Windows プログラムをデバッグするために使用されます。WinDbg は不一致な PDB ファイルをロードできますが、手動でロードする必要があります。.reload /f /i コマンドを使用して、強制的に不一致な PDB ファイルをロードできます。
しかし、WinDbg の使い勝手は Visual Studio ほど簡単ではないため、Visual Studio も不一致な PDB ファイルをロードできるようにしたいと考えています。&lt;/p&gt;
&lt;h2 id=&#34;visual-studio-での-pdb-ファイルのマッチングエラー&#34;&gt;Visual Studio での PDB ファイルのマッチングエラー
&lt;/h2&gt;&lt;p&gt;ソースコードは現在、Git などのバージョン管理システムで管理されており、完全に一致するバージョンのコードを再コンパイルし、対応する PDB ファイルを生成できます。なぜこの PDB ファイルが読み込まれないのでしょうか？主な原因は、メタデータの不一致です。&lt;/p&gt;
&lt;p&gt;元データを修正し、EXE ファイルの情報に基づいて新しい PDB ファイルを生成することで、Visual Studio が PDB ファイルを読み込めるようになります。&lt;/p&gt;
&lt;p&gt;ChkMatch ダウンロード先：&lt;a class=&#34;link&#34; href=&#34;https://www.debuginfo.com/tools/chkmatch.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.debuginfo.com/tools/chkmatch.html&lt;/a&gt;
サイトのキャッシュアドレス：&lt;a class=&#34;link&#34; href=&#34;chkmatch.zip&#34; &gt;chkmatch.zip&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ChkMatch ユーティリティは、実行ファイルとデバッグ情報ファイルの間のマッチングを確認するために使用できます。また、互換性のある実行ファイルとデバッグ情報ファイルをマッチさせるために使用することもできます。

デバッグ情報のマッチングに関する詳細情報や関連する問題については、こちらの記事を参照してください。

サポートされているデバッグ情報形式：DBG, PDB 2.0, PDB 7.0

chkmatch [-c ExeFile DebugInfoFile ] |
         [-m ExeFile DebugInfoFile]
-c
実行ファイルとデバッグ情報ファイルの間のマッチングを確認します。
-m
実行ファイルとデバッグ情報ファイルをマッチさせます。
ExeFile
実行ファイルの名前。
DebugInfoFile
デバッグ情報ファイルの名前。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;chkmatch-の使用&#34;&gt;chkmatch の使用
&lt;/h2&gt;&lt;p&gt;まず、検査を実行し、不一致の原因を分析して、署名が一致しないことを示します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\tianlong.xiang\Downloads\chkmatch&amp;gt;ChkMatch.exe -c &amp;quot;D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe&amp;quot; E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb
ChkMatch - version 1.0
Copyright (C) 2004 Oleg Starodumov
http://www.debuginfo.com/


Executable: D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe
Debug info file: E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb

Executable:
TimeDateStamp: c26d9be3
Debug info: 2 ( CodeView )
TimeStamp: f86b0a4f  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 122  RVA: 001cdc44  FileOffset: 001cbe44
CodeView format: RSDS
Signature: {428c9b95-39a3-4a8d-a8e5-7be453684757}  Age: 1
PdbFile: D:\stock_UAT\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\obj\Release\YinTrade.Main.pdb
Debug info: 16 ( Unknown )
TimeStamp: 00000000  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 0  RVA: 00000000  FileOffset: 00000000

Debug information file:
Format: PDB 7.00
Signature: {06fae08e-c0a2-4f3d-9c7c-dfc684445dd1}  Age: 1

Result: Unmatched (reason: Signature mismatch)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;次に、デバッグ情報ファイルと実行可能ファイルを一致させる操作を実行します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\tianlong.xiang\Downloads\chkmatch&amp;gt;ChkMatch.exe -m &amp;quot;D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe&amp;quot; E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb
ChkMatch - version 1.0
Copyright (C) 2004 Oleg Starodumov
http://www.debuginfo.com/


Executable: D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe
Debug info file: E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb

Executable:
TimeDateStamp: c26d9be3
Debug info: 2 ( CodeView )
TimeStamp: f86b0a4f  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 122  RVA: 001cdc44  FileOffset: 001cbe44
CodeView format: RSDS
Signature: {428c9b95-39a3-4a8d-a8e5-7be453684757}  Age: 1
PdbFile: D:\stock_UAT\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\obj\Release\YinTrade.Main.pdb
Debug info: 16 ( Unknown )
TimeStamp: 00000000  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 0  RVA: 00000000  FileOffset: 00000000

## 参考資料
- [forcing-to-load-unmatched-symbols-in-visual-studio-2015-debugger](https://stackoverflow.com/questions/38147487/forcing-to-load-unmatched-symbols-in-visual-studio-2015-debugger)&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Cursor AI プログラミング IDE のトライアル</title>
        <link>https://ttf248.life/ja/p/cursor-ai-programming-ide-trial/</link>
        <pubDate>Thu, 23 Jan 2025 19:30:13 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cursor-ai-programming-ide-trial/</guid>
        <description>&lt;p&gt;一年又转眼即逝之际，在工作中最大的变化莫过于AI参与度明显提高。以往，不同开发语言之间切换，需要开发者熟悉各种语言的不同API接口，现在这些基础代码都可以通过AI生成代码了，对于开发者来说，无疑是一个巨大的福音。&lt;/p&gt;
&lt;h2 id=&#34;chatgpt&#34;&gt;ChatGPT
&lt;/h2&gt;&lt;p&gt;23年の時点で、簡単な入門紹介を既に2本作成していましたが、今では25年となり、どう表現しようか… 顕著な進歩を感じ取ることはなく、自律的な認知能力を発展させ、タスクを合理的に分割できることなどが求められます。もちろん、最も重要なのはAIが生成したコードにバグが存在するかどうかを特定することです。&lt;/p&gt;
&lt;h2 id=&#34;github-copilot&#34;&gt;Github Copilot
&lt;/h2&gt;&lt;p&gt;いつの日か忘れましたが、シンガポールでサーバーがデプロイされているという情報を見つけました。国内では利用され、長期間のVPN接続も不要になりました。ただし、ログイン時にはVPN接続は必要ですが、そのVPN接続はログイン時のみ使用し、その後はオフにしておくことができます。&lt;/p&gt;
&lt;p&gt;日常的な使い道としてはGithub Copilotをより多く活用しています。この拡張機能は、VS CodeやVisual Studioで直接利用できます。2つのソフトウェア間の切り替えが不要です。ChatGPTと比較して、Github Copilotの方がプロジェクトのサポートが優れており、インタラクションもフレンドリーです。また、一部のローカルファイルをAIに「学習」させることで、生成されるコードがあなたのプロジェクトに合っているものになります。&lt;/p&gt;
&lt;h2 id=&#34;cursor-ai&#34;&gt;Cursor AI
&lt;/h2&gt;&lt;p&gt;最近、Cursor AI という新しいAIプログラミングIDEを見つけました。これはGithub Copilotをベースにしたもので、このIDEはよりスマートで、直接ファイルを作成するのを手伝ってくれます。&lt;/p&gt;
&lt;p&gt;簡単な使い方は試してみて、なかなか良いと感じましたが、既存プロジェクトの理解はまだ十分ではありません。ローカルプロジェクトのファイルが多い場合や、大規模なリファクタリング、最適化、調整を行う場合は、やはり&lt;strong&gt;開発者がタスクを分割して行う&lt;/strong&gt;必要があります。&lt;/p&gt;
&lt;p&gt;例として、curso のエンジンモードに切り替えて、以下の内容を入力してみましょう。「複数の異なるスタイルで切り替えられる個人用履歴書ウェブページの作成。個人情報をデータ表示のために埋めてください。」&lt;/p&gt;
&lt;p&gt;何度かやり取りするうちに、以下のようなウェブページが得られます。もちろん、このウェブページはかなりシンプルですが、初心者にとっては非常に良いでしょう。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;現在の登録ユーザーは、高度なAPIを150回無料で試用でき、有料ユーザーは5,000回まで制限されています。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;cursor-ai-1&#34;&gt;Cursor AI
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://cursor/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;履歴書&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>C&#43;&#43; ビット演算の基礎：ビットごとのANDとフラグ設定</title>
        <link>https://ttf248.life/ja/p/cpp-bitwise-operations-flags/</link>
        <pubDate>Fri, 17 Jan 2025 02:23:56 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cpp-bitwise-operations-flags/</guid>
        <description>&lt;p&gt;実際のC++開発において、ビット演算は一般的な技術であり、特にシステムの状態、フラグビット、または制御ビットを扱う際に、ビット演算は非常に効率的な解決策を提供します。本稿では、例を通して、ビット演算を使用して特定のフラグビットを取得および設定する方法について解説します。&lt;/p&gt;
&lt;h3 id=&#34;ビット演算の基礎概念&#34;&gt;ビット演算の基礎概念
&lt;/h3&gt;&lt;p&gt;コンピュータでは、データは2進数（0と1）のビットで格納されます。ビット演算とは、これらのビットに対して操作を行うことです。C++には、いくつかの一般的なビット演算演算子が用意されています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;論理積（&amp;amp;）&lt;/strong&gt;：特定のビットが1であるかどうかを確認します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;論理和（|）&lt;/strong&gt;：特定のビットを1に設定します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;排他的論理和（^）&lt;/strong&gt;：特定のビットを反転させます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ビット反転（~）&lt;/strong&gt;：すべてのビットを反転させます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;左シフト（&amp;laquo;）&lt;/strong&gt;：すべてのビットを左に指定された数だけシフトします。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;右シフト（&amp;raquo;）&lt;/strong&gt;：すべてのビットを右に指定された数だけシフトします。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本例では、&lt;code&gt;unsigned short&lt;/code&gt; 型の変数 &lt;code&gt;wInfo&lt;/code&gt; に対して、さまざまなビット演算を実行し、異なるフラグビットを使用して状態を表す必要があります。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;flowchart LR
    A[元の数値: 00010000] --&amp;gt; B[左シフト: 00010000 &amp;lt;&amp;lt; 1]
    B --&amp;gt; C[結果: 00100000]
    C --&amp;gt; D[右シフト: 00100000 &amp;gt;&amp;gt; 1]
    D --&amp;gt; E[結果: 00010000]

    subgraph 左シフト操作
        direction LR
        A --&amp;gt; B --&amp;gt; C
    end

    subgraph 右シフト操作
        direction LR
        C --&amp;gt; D --&amp;gt; E
    end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;要求分析&#34;&gt;要求分析
&lt;/h3&gt;&lt;p&gt;問題文の記述に基づき、16ビットのフラグビットがあり、これを用いて様々な状態を表します。これらの状態は個々のバイナリビットによって表現され、各バイナリビットは特定の意味に対応しています。例えば：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;bit0&lt;/strong&gt; が失敗かどうか&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit1&lt;/strong&gt; が圧縮されているかどうか&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit2&lt;/strong&gt; が増分であるかどうか&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit3&lt;/strong&gt; が後続のパケットがあるかどうか&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit5&lt;/strong&gt; が正常なリクエストまたは注销かどうか&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;位演算による実装&#34;&gt;位演算による実装
&lt;/h3&gt;&lt;p&gt;ビット演算を使用してこれらのフラグを設定および取得します。具体的には：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ビットごとの抽出 (ビットマスク)&lt;/strong&gt;: 特定のビットの値（0または1）を取得します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ビット設定&lt;/strong&gt;: 特定のビットを1に設定します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ビットクリア&lt;/strong&gt;: 特定のビットを0に設定します。
最初に &lt;code&gt;unsigned short&lt;/code&gt; 型の変数 &lt;code&gt;wInfo&lt;/code&gt; を定義し、これらのフラグを保存するために使用します。その後、ビット演算を使用して対応するフラグを確認および設定します。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;c-のサンプルコード&#34;&gt;C++ のサンプルコード
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;bitset&amp;gt;

// フラグ定数を定義
const unsigned short BIT_0_FAIL = 1 &amp;lt;&amp;lt; 0;    // bit0 が失敗したか
const unsigned short BIT_1_COMPRESSED = 1 &amp;lt;&amp;lt; 1; // bit1 が圧縮されたか
const unsigned short BIT_2_INCREMENT = 1 &amp;lt;&amp;lt; 2;  // bit2 がインクリメントされたか
const unsigned short BIT_3_HAS_MORE = 1 &amp;lt;&amp;lt; 3;   // bit3 に後続のパッケージがあるか
const unsigned short BIT_5_CANCEL = 1 &amp;lt;&amp;lt; 5;     // bit5 は正常リクエスト(0)または注销(1)

// あるビットがセットされているか確認する関数
bool isBitSet(unsigned short wInfo, unsigned short bitMask) {
    return (wInfo &amp;amp; bitMask) != 0;
}

// あるビットをセットする関数
void setBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo |= bitMask;
}

// あるビットをクリア（0に設定）する関数
void clearBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo &amp;amp;= ~bitMask;
}

int main() {
    // wInfo の初期値を 0 と仮定
    unsigned short wInfo = 0;

    // bit0（失敗フラグ）を設定
    setBit(wInfo, BIT_0_FAIL);

    // bit1（圧縮フラグ）を設定
    setBit(wInfo, BIT_1_COMPRESSED);

    // wInfo の2進数表記を出力
    std::cout &amp;lt;&amp;lt; &amp;quot;wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    // 各フラグを確認
    std::cout &amp;lt;&amp;lt; &amp;quot;bit0 (失敗したか): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_0_FAIL) ? &amp;quot;はい&amp;quot; : &amp;quot;いいえ&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit1 (圧縮されたか): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_1_COMPRESSED) ? &amp;quot;はい&amp;quot; : &amp;quot;いいえ&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit2 (インクリメントされたか): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_2_INCREMENT) ? &amp;quot;はい&amp;quot; : &amp;quot;いいえ&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit3 (後続のパッケージがあるか): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_3_HAS_MORE) ? &amp;quot;はい&amp;quot; : &amp;quot;いいえ&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit5 (注销されたか): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_5_CANCEL) ? &amp;quot;はい&amp;quot; : &amp;quot;いいえ&amp;quot;) &amp;lt;&amp;lt; std::endl;

    // bit1（圧縮フラグ）をクリア
    clearBit(wInfo, BIT_1_COMPRESSED);

    // 更新された wInfo の2進数表記を出力
    std::cout &amp;lt;&amp;lt; &amp;quot;Updated wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;コードを実行することを推奨します：&lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wInfo (in binary): 0000000000000001
bit0 (失敗したか): はい
bit1 (圧縮されたか): いいえ
bit2 (インクリメントされたか): いいえ
bit3 (後続のパッケージがあるか): いいえ
bit5 (注销されたか): いいえ
Updated wInfo (in binary): 0000000000000000
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;コード解説&#34;&gt;コード解説
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;フラグの定義&lt;/strong&gt;: ビットシフト演算 (&lt;code&gt;1 &amp;lt;&amp;lt; n&lt;/code&gt;) を使用して、各フラグを定義します。例えば、&lt;code&gt;1 &amp;lt;&amp;lt; 0&lt;/code&gt; は &lt;code&gt;bit0&lt;/code&gt; に対応し、&lt;code&gt;1 &amp;lt;&amp;lt; 1&lt;/code&gt; は &lt;code&gt;bit1&lt;/code&gt; に対応するなど、同様に推測されます。このようにして、各フラグには一意のバイナリ位置が割り当てられます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特定のビットの確認&lt;/strong&gt;: &lt;code&gt;isBitSet&lt;/code&gt; 関数は、指定されたフラグが設定されているかどうかを確認するために、AND 演算 (&lt;code&gt;wInfo &amp;amp; bitMask&lt;/code&gt;) を使用します。もしそのビットが1の場合、関数は &lt;code&gt;true&lt;/code&gt; を返し、そうでない場合は &lt;code&gt;false&lt;/code&gt; を返します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特定のビットの設定&lt;/strong&gt;: &lt;code&gt;setBit&lt;/code&gt; 関数は、指定されたフラグを1に設定するために、ビットごとのOR 演算 (&lt;code&gt;wInfo |= bitMask&lt;/code&gt;) を使用します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特定のビットのクリア&lt;/strong&gt;: &lt;code&gt;clearBit&lt;/code&gt; 関数は、指定されたフラグを0に設定するために、ビットごとのAND 演算 (&lt;code&gt;wInfo &amp;amp;= ~bitMask&lt;/code&gt;) を使用します。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;結論&#34;&gt;結論
&lt;/h3&gt;&lt;p&gt;ビット演算を用いることで、複数の状態フラグを効率的に処理できるようになります。実際の開発においては、この技術が特に有用です。例えば、組み込み開発、ネットワークプロトコル、システムステート管理などの場面で、複数のバイナリ状態を表すためにビットフラグが頻繁に使用されます。スペースの節約と効率向上に貢献します。
この記事が、C++ でビット演算を用いてビットごとの取得と設定を理解し、習得するのに役立つことを願っています！これらのスキルは、効率的で保守しやすいコードを書く上で非常に役立ちます！&lt;/p&gt;
</description>
        </item>
        <item>
        <title>デスクトップPCを2.5Gネットカードにアップグレードし、ローカルエリアネットワークの接続速度を向上させる。</title>
        <link>https://ttf248.life/ja/p/desktop-upgrade-to-2-5g-network-card-accelerates-local-area-network-interconnection/</link>
        <pubDate>Fri, 10 Jan 2025 00:37:52 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/desktop-upgrade-to-2-5g-network-card-accelerates-local-area-network-interconnection/</guid>
        <description>&lt;p&gt;デスクトップPCのハードウェア三連発！前回の記事では、SSD PCIeアダプタについて触れたばかりですが、旧いSSDはどこへ行ったのでしょうか？もちろん無駄にはせず、壊れてしまっていたりするかもしれませんが、分解して新しく購入した「メカシシャ・クリエーター Mini-3765H」（一年前のモデル）にインストールしました。&lt;/p&gt;
&lt;p&gt;このマシンは、ハードウェアスペックも十分に強力で、2.5GデュアルLAN、PCIe4.0、Wi-Fi 6を搭載しています。&lt;/p&gt;
&lt;p&gt;最近引っ越しをして、部屋にルーターを個別に設置してネットワークを構築することができず、すべてのマシンが無線ネットワーク経由で接続されています。ASUSのマザーボードデスクトップPCの無線LANカードの性能はあまり良くなく、ルーターの無線アクセスポイント、ローカルエリア間のアップロード速度が遅いこともあり、マシン間での通信速度が不安定でした。そこで、2.5G NIC（ネットワークインターフェースカード）を購入し、デスクトップPCにインストールしました。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;これで、マザーボードのスロットはすべて埋まりました：グラフィックカード、無線LANカード、2.5G NIC、SSD PCIeアダプタ。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;ネットワークの説明&#34;&gt;ネットワークの説明
&lt;/h2&gt;&lt;p&gt;両台の機器が元の無線LANに接続されているが、両台間をケーブルで直結し、両端に2.5G網カードを装着する。ケーブルで両台を直結する方法については、詳細は省略する（インターネット上には多くのチュートリアルがある）。ファイアウォールを必ず解除することに注意する。どちらか一方をゲートウェイとして使用すればよい。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
    A[マシン1&amp;lt;br&amp;gt;IP: 192.168.4.1&amp;lt;br&amp;gt;サブネットマスク: 255.255.255.0&amp;lt;br&amp;gt;デフォルトゲートウェイ: - &amp;lt;br&amp;gt;自動取得DNS] --&amp;gt;|ケーブル直結（2.5G）| B[マシン2&amp;lt;br&amp;gt;IP: 192.168.4.2&amp;lt;br&amp;gt;サブネットマスク: 255.255.255.0&amp;lt;br&amp;gt;デフォルトゲートウェイ: 192.168.4.1&amp;lt;br&amp;gt;自動取得DNS];
    A --&amp;gt;|無線LANカード| Internet;
    B --&amp;gt;|無線LANカード| Internet;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;二重網段測速&#34;&gt;二重網段測速
&lt;/h2&gt;&lt;h3 id=&#34;ルーティング局域網&#34;&gt;ルーティング局域網
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\core\Desktop\iperf-3.1.3-win32&amp;gt;iperf3.exe -c 192.168.3.237
接続先ホスト 192.168.3.237、ポート 5201 に接続
[  4] ローカル 192.168.3.122 ポート 1656 が 192.168.3.237 のポート 5201 に接続
[ ID] インターバル           転送     帯域幅
[  4]   0.00-1.00   秒  9.17 MB  76.7 Mbps
[  4]   1.00-2.00   秒  9.91 MB  83.2 Mbps
[  4]   2.00-3.00   秒  8.74 MB  73.3 Mbps
[  4]   3.00-4.00   秒 10.2 MB  85.2 Mbps
[  4]   4.00-5.00   秒  9.23 MB  77.1 Mbps
[  4]   5.00-6.00   秒  8.80 MB  73.9 Mbps
[  4]   6.00-7.01   秒  8.00 MB  66.8 Mbps
[  4]   7.01-8.00   秒  7.69 MB  64.9 Mbps
[  4]   8.00-9.01   秒  9.72 MB  81.1 Mbps
[  4]   9.01-10.01  秒  7.63 MB  63.6 Mbps
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] インターバル           転送     帯域幅
[  4]   0.00-10.01  秒 89.0 MB  74.6 Mbps                  送信元
[  4]   0.00-10.01  秒 89.0 MB  74.6 Mbps                  宛先

iperf Done.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;直連局域網&#34;&gt;直連局域網
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\core\Desktop\iperf-3.1.3-win32&amp;gt;iperf3.exe -c 192.168.4.1
接続 192.168.4.1 に、ポート 5201 を確立
[  4] ローカル 192.168.4.2 ポート 1524 が 192.168.4.1 のポート 5201 と接続
[ ID] インターバル           転送     帯域幅
[  4]   0.00-1.01   秒   178 MB   1.48 Gbps
[  4]   1.01-2.00   秒   204 MB   1.72 Gbps
[  4]   2.00-3.00   秒   214 MB   1.80 Gbps
[  4]   3.00-4.00   秒   229 MB   1.92 Gbps
[  4]   4.00-5.00   秒   202 MB   1.69 Gbps
[  4]   5.00-6.00   秒   213 MB   1.79 Gbps
[  4]   6.00-7.00   秒   230 MB   1.93 Gbps
[  4]   7.00-8.00   秒   192 MB   1.61 Gbps
[  4]   8.00-9.00   秒   220 MB   1.84 Gbps
[  4]   9.00-10.00  秒   230 MB   1.93 Gbps
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] インターバル           転送     帯域幅
[  4]   0.00-10.00  秒  2.06 GB   1.77 Gbps                  送信元
[  4]   0.00-10.00  秒  2.06 GB   1.77 Gbps                  宛先

iperf 終了
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考資料&#34;&gt;参考資料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://wutongsuimeng.github.io/post/%E7%BB%99hugo%E6%B7%BB%E5%8A%A0mermaid%E6%94%AF%E6%8C%81/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;HugoにMermaidを導入する方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>ASUS マザーボード Z490 のディスクが多すぎ、ランダムなディスクが認識されない。</title>
        <link>https://ttf248.life/ja/p/asus-z490-motherboard-disk-recognition-issues/</link>
        <pubDate>Fri, 10 Jan 2025 00:08:51 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/asus-z490-motherboard-disk-recognition-issues/</guid>
        <description>&lt;p&gt;前の文脈を踏まえ、突然無線LANアダプターが認識されなくなった問題が発生しました。パーティションを再構築する前に、インターネット上でも他の解決策を探しておりました。例えば、マザーボードの電池卸載や、電源を切って15分間待つなどの方法がありました。また、最新版のBOISドライバーへのアップデートも試しましたが、いずれもうまくいきませんでした。&lt;/p&gt;
&lt;p&gt;他に処理すべきことがあり、制限ネットワークに切り替えて、リビングから部屋へ網線を引き込んだところ、有線LANも認識されなくなりました。最終手段としてシステムを再インストールしたところ、パーティションのガイダンスが失われました。もし常に問題が発生していれば、これほど長く悩むことはありませんでした。華碩のマシンにおけるディスク競合は、偶発的なものであり、システムの再起動時に不安定な状態がトリガーとなるようです。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;先週、台式机に新しい长江存储（チャンジアン cunzhuo）の2TB SSD（M.2インターフェース）を追加したところ、マシンは再起動せず、昨日までシャットダウンすることができませんでした。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/asus-z490-motherboard-disk-recognition-issues/20250110002801.png&#34;
	width=&#34;553&#34;
	height=&#34;322&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;ディスクフルハウス&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;171&#34;
		data-flex-basis=&#34;412px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;システムの再インストール&#34;&gt;システムの再インストール
&lt;/h2&gt;&lt;p&gt;時間を作ってみると、もう2年もシステムを再インストールしていない。Cドライブが足りなくなってきた。Windows の古い問題や、日常的に使用するソフトウェアが Cドライブに何かを保存しようとする。そこで、システムを再インストールすることにした。システムを再インストールした後、ネットワークカードの問題はすべて正常になった。翌日には、開発環境を回復させることができ、システムのバックアップを作成するために、新たな問題が発生した。システムを再起動すると、ブートパーティションが失われた。
前回の記事の手順に従い、ブートパーティションを再構築したが、不安定で、再起動するとブートパーティションが読み込まれなくなる可能性がある。折詰機箱を分解しようかと思ったとき、ハードディスクケーブルが緩んでいることに気づいたが、何度か確認しても問題なかった。&lt;/p&gt;
&lt;h2 id=&#34;記憶の想起&#34;&gt;記憶の想起
&lt;/h2&gt;&lt;p&gt;数年前、この機械はSSDを一度増設した際、PCIe変換器（グラフィックカードのポートに接続）を使用していました。これは、直接マザーボードに取り付けるのではなく、変換器を通してHDDを取り付ける方法でした。今回、直接マザーボードに取り付けたのは、おそらくマザーボードの問題である可能性があります。
&lt;img src=&#34;https://ttf248.life/p/asus-z490-motherboard-disk-recognition-issues/20250110002148.png&#34;
	width=&#34;325&#34;
	height=&#34;545&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;SSD変換器&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;59&#34;
		data-flex-basis=&#34;143px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;マザーボードマニュアル&#34;&gt;マザーボードマニュアル
&lt;/h2&gt;&lt;p&gt;マザーボードマニュアルに問題があり、記載されているSATAポートの位置と実際の位置が異なっております。ディスクの多さから、ポートにはすべてハードドライブが取り付けられており、古いSSDはSATAポートを使用しています。マニュアルでは、ポート間の競合が存在すると記載されています。しかし、実際にテストを行ったところ、この競合は不安定に発生し、発生すると対応するディスクを読み込めなくなります。ちょうどこれがシステムディスクであり、ブートローダーも同じディスク上に存在するため、システム起動時にブートローダーのロードに失敗します。
&lt;img src=&#34;https://ttf248.life/p/asus-z490-motherboard-disk-recognition-issues/20250110002401.png&#34;
	width=&#34;807&#34;
	height=&#34;847&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Z490&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;95&#34;
		data-flex-basis=&#34;228px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;解決策&#34;&gt;解決策
&lt;/h2&gt;&lt;p&gt;SSDをPCIe変換器に再インストールすることで、この問題を解決できます。その結果、マザーボード上のSATAポートとの競合が解消され、システム起動が正常に行われます。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Windowsに付属のディスククリーンアップツール：ストレージ</title>
        <link>https://ttf248.life/ja/p/windows-disk-cleanup-storage/</link>
        <pubDate>Mon, 06 Jan 2025 19:29:45 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/windows-disk-cleanup-storage/</guid>
        <description>&lt;p&gt;元のバージョンがいつからなのかは不明ですが、Windows 11 ではディスククリーンアップツールが大幅に改善され、よりスマートになっています。&lt;/p&gt;
&lt;p&gt;主な理由は、これが公式のツールであり、ファイルを誤って削除したり、広告が表示されたり、ポップアップが現れたり、バックグラウンドプロセスが実行されたり、不要なものが一切含まれていないことです。&lt;/p&gt;
&lt;p&gt;Windows 11 では、「設定」&amp;gt;「システム」&amp;gt;「ストレージ」&amp;gt;「一時ファイル」からディスククリーンアップツールを開くことができます。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;20250106194453.png&#34; &gt;ストレージインターフェースの画像&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通常ユーザーは「推奨のクリーニング」を選択するだけで、システムはあなたの使用状況に基づいていくつかの提案を行います。&lt;/p&gt;
&lt;p&gt;筆者である私のような開発者は、ディスク上に多くの一時ファイルがあるため、「一時ファイル」を選択し、Visual Studio や Windows Update などの一時ファイルを多く含んでいます。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;Snipaste_2024-12-19_13-39-51.png&#34; &gt;一時ファイルの画像&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Docker 国内イメージプロキシが失敗しました。</title>
        <link>https://ttf248.life/ja/p/docker-domestic-image-proxy-failure/</link>
        <pubDate>Sat, 04 Jan 2025 18:29:25 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/docker-domestic-image-proxy-failure/</guid>
        <description>&lt;p&gt;国内サーバーへのDockerデプロイで、会社がレジストリを提供していない場合、開発者が最初にやるべきことは、国内のレジストリミラーを設定することです。&lt;/p&gt;
&lt;p&gt;幸いにも今日、サーバー1台にミラー設定を行いましたが、イメージの取得中に常に取得できないという問題が発生しました。&lt;/p&gt;
&lt;p&gt;エラーメッセージ：&lt;code&gt;Error response from daemon: Get &amp;quot;https://registry-1.docker.io/v2/&amp;quot;: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2025年1月6日、隔日のうちにすべてのサーバーが復旧しました。この件は全く話題にならないとは信じられない。国内のすべてのレジストリミラーがダウンしていたのです&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;障害の切り分けと修復試行&#34;&gt;障害の切り分けと修復試行
&lt;/h2&gt;&lt;p&gt;当初、他のミラー加速アドレスに切り替えて問題を解決することを期待したが、予想とは裏腹に問題は依然として発生し続けた。&lt;/p&gt;
&lt;p&gt;次に、ローカルDNS設定を修正して、ネットワーク解析の側面から突破口を探ることを試みたが、結局、ある程度のデバッグを行った結果も、障害は解消されなかった。&lt;/p&gt;
&lt;p&gt;この時点で、ローカルネットワークの安定性が大きく疑われるようになり、そこで断念なく携帯電話のテザリングに切り替えて、潜在的なローカルネットワーク障害を回避することを試みた。しかし、結果は失望であり、問題の改善の兆候は見られなかった。&lt;/p&gt;
&lt;h2 id=&#34;問題の蔓延&#34;&gt;問題の蔓延
&lt;/h2&gt;&lt;p&gt;現在、国内に&lt;strong&gt;数台のサーバーがデプロイされており、すべてDocker環境がインストールされています&lt;/strong&gt;。これらのサーバーからイメージをプルすることを試みましたが、例外なく失敗し、返ってくるエラーメッセージも一様です。これは問題が特定のデバイスに限られたものではなく、広範囲に及んでいることを示唆しています。&lt;/p&gt;
&lt;p&gt;さらに調査した結果、イメージレポジトリのプロキシが瞬く間に停止していることが判明しました。この緊迫した状況下で、迅速に海外のサーバーを使用して試みましたが、幸いにもイメージのプルは正常に戻りました。これは問題が国内のネットワークリンクまたは関連設定にある可能性が高いことを意味します。&lt;/p&gt;
&lt;h2 id=&#34;戦略修正迂回戦術&#34;&gt;戦略修正：迂回戦術
&lt;/h2&gt;&lt;p&gt;国内での直接リポジトリ取得の経路が重く制限される中、海外のリポジトリは正常にアクセスできる状況を鑑み、プロジェクトを迅速に進めるため、迂回戦術を採用することにしました。まず、国外サーバーに切り替えて必要なイメージを取得し、その後、国内イメージレジストリにプッシュすることで、「データブリッジ」を構築します。
同時に、Dockerfileファイルに対しても修正を行い、イメージのURLを国内環境に適したアドレスに変更してから再ビルドを実行し、最終的に成功裏にデプロイしました。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>CentOS 8 Stream EOL</title>
        <link>https://ttf248.life/ja/p/centos-8-stream-eol/</link>
        <pubDate>Sat, 16 Nov 2024 23:24:50 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/centos-8-stream-eol/</guid>
        <description>&lt;p&gt;&lt;code&gt;CentOS Stream&lt;/code&gt;は、レッドハットのエンタープライズ向け&lt;code&gt;Linux&lt;/code&gt;ディストリビューションの前段のオープンソース開発プラットフォームです。&lt;/p&gt;
&lt;p&gt;初めてオープンオペレーティングシステムのライフサイクル&lt;a class=&#34;link&#34; href=&#34;https://ttf248.life/ja/p/redhat-centos-lifecycle/&#34; &gt;redhat and centos life cycle&lt;/a&gt;に注目したのが、この時期でした。&lt;/p&gt;
&lt;p&gt;期限が切れ、何か問題があるのでしょうか？セキュリティの問題以外にも、dnfが使えなくなってしまい、最近ツールをインストールする際に、dnfが失敗するという問題を調べたところ、&lt;code&gt;CentOS 8 Stream&lt;/code&gt;が期限切れだったことがわかりました。&lt;/p&gt;
&lt;h2 id=&#34;centos-stream-の紹介&#34;&gt;CentOS Stream の紹介
&lt;/h2&gt;&lt;h3 id=&#34;位置と役割&#34;&gt;位置と役割
&lt;/h3&gt;&lt;p&gt;CentOS Streamは、Fedora Linux（上流開発）とRHEL（Red Hat Enterprise Linux、下流開発）の中間に位置し、その橋渡し役を担っています。
最新のRed Hat系Linuxの機能を試すためのバージョンとして利用でき、ベータ版やプレビュー版としての活用に適しています。&lt;/p&gt;
&lt;h3 id=&#34;出身と背景&#34;&gt;出身と背景
&lt;/h3&gt;&lt;p&gt;時間の経過とともに、Red Hat社はエンタープライズ向けLinuxプラットフォームの発展方法についてより効果的な方法を模索し始め、CentOS Streamを発表しました。
‌CentOS 8が2021年末にメンテナンスを終了した後、CentOS Streamはその後継者として更新され続け、CentOSプロジェクトの将来的な開発方向となりました。&lt;/p&gt;
&lt;h3 id=&#34;特徴と利点&#34;&gt;特徴と利点
&lt;/h3&gt;&lt;p&gt;CentOS Streamは、継続的リリース（ローリングリリース）のLinuxディストリビューションであり、より迅速なアップデートを提供します。コミュニティ、パートナー、顧客への参加を促進し、透明性を高め、ユーザーがRed Hat Enterprise Linux (RHEL) に貢献するための機会を増やします。
CentOS Streamの内容は、Red Hatが次期安定版RHELに含める予定のソフトウェアであるため、コミュニティメンバーには安定したABI/APIを使用した開発およびテストのための基盤を提供します。&lt;/p&gt;
&lt;h3 id=&#34;利用シーンとターゲットユーザー&#34;&gt;利用シーンとターゲットユーザー
&lt;/h3&gt;&lt;p&gt;CentOS Streamは、最新のLinux機能アップデートを継続的に取得したいCentOSユーザーや、Red Hat Enterprise Linuxの開発に参加する開発者およびパートナーに適しています。&lt;/p&gt;
&lt;p&gt;また、コミュニティメンバー、Red Hat パートナー、その他の人々が、より安定かつ予測可能なLinuxエコシステムで革新的なオープンソースプログラムを最大限に活用できるよう支援することを目的としています。&lt;/p&gt;
&lt;h2 id=&#34;最終期限httpsendoflifedatecentos-stream&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://endoflife.date/centos-stream&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;最終期限&lt;/a&gt;
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;リリース&lt;/th&gt;
&lt;th&gt;公開日&lt;/th&gt;
&lt;th&gt;サポート期間&lt;/th&gt;
&lt;th&gt;セキュリティサポート&lt;/th&gt;
&lt;th&gt;最新&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;3年前 (2021年9月15日)&lt;/td&gt;
&lt;td&gt;2年6ヶ月後 (2027年5月31日)&lt;/td&gt;
&lt;td&gt;2年6ヶ月後 (2027年5月31日)&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;最終期限httpsendoflifedatecentos-stream-1&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://endoflife.date/centos-stream&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;最終期限&lt;/a&gt;
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;リリース&lt;/th&gt;
&lt;th&gt;公開日&lt;/th&gt;
&lt;th&gt;サポート期間&lt;/th&gt;
&lt;th&gt;セキュリティサポート&lt;/th&gt;
&lt;th&gt;最新&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;5年前 (2019年9月24日)&lt;/td&gt;
&lt;td&gt;終了済み (2024年5月31日)&lt;/td&gt;
&lt;td&gt;終了済み (2024年5月31日)&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ソリューション&#34;&gt;ソリューション
&lt;/h2&gt;&lt;p&gt;アップグレードの手間を省き、長期サポート版の &lt;code&gt;Ubuntu 24.04&lt;/code&gt; を採用しました。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Hugo モジュールカスタムテーマの修正：考え方の解説</title>
        <link>https://ttf248.life/ja/p/hugo-module-customizing-themes-ideas/</link>
        <pubDate>Fri, 15 Nov 2024 22:01:17 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/hugo-module-customizing-themes-ideas/</guid>
        <description>&lt;p&gt;過去のコミット履歴を調べてみたところ、サイトが何度もテーマを変更しており、毎回いくつかのカスタム設定を適用していた。そこで、カスタム設定の変更方法を記録しておく。私のGitHubには「even」というテーマがあり、短期間メンテナンスを行っていたが、最新版のHugoコンパイラへのアップグレードを強行した結果、互換性が失われ、最終的に「stack」テーマに切り替えてしまった。&lt;/p&gt;
&lt;h2 id=&#34;hugoのモジュール化&#34;&gt;Hugoのモジュール化
&lt;/h2&gt;&lt;p&gt;モジュール化について言及する際、NginxモジュールやIDEAプラグインなどを思い浮かべる人が多いでしょう。 通常は、私がいくつかのモジュールをアップロードすることで、私の独自のニーズを満たすことができます。 モジュールが広く受け入れられる理由は、十分に柔軟で、あまり労力をかけずに自分のニーズを満たせることです。 多くの場合は、大体同じように見えるものの、細部には常に違いがあるからです。 これはソフトウェアの複雑さを物語っており、技術的な複雑さだけでなく、ビジネス上の複雑さも含まれます。 大多数の場合、私たちが直面しているのはビジネスの複雑さです。 これこそが、「隔行如隔山」という俗語を最もよく表すものです。&lt;/p&gt;
&lt;p&gt;現在では、インターネット業界だけでなく、金融業界、さらには伝統的な製造業まで、情報化システムを使用して企業の生産と管理を支援しています。 同じ「休暇申請システム」でも、同じ業界の異なる企業間には違いがあります。&lt;/p&gt;
&lt;p&gt;そして&lt;code&gt;Hugo&lt;/code&gt;のモジュールは、皆さんがイメージするモジュールとは少し異なります。 機能単位で独自のニーズを満たすのではなく、ディレクトリ構造を主に使用して、共通の構造を認識します。&lt;/p&gt;
&lt;p&gt;資料リンク：&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@sunwei.xyz/07-hugo%E6%9E%B6%E6%9E%84-hugo%E7%9A%84%E6%A8%A1%E5%9D%97-8ef5a520a822&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;07. Hugoアーキテクチャ — Hugoのモジュール&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[[imports]]
path = &amp;quot;github.com/CaiJimmy/hugo-theme-stack/v3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;git submodule&lt;/code&gt; 方式も引き続き使用できますが、本記事では推奨されません。 テーマを導入した場合、更新が発生するとメンテナンスが煩雑になり、個別の git リポジトリでテーマを管理する必要があるためです。&lt;/p&gt;
&lt;h2 id=&#34;テーマの修正ロジック-httpsstackjimmycaicomguidemodify-themehttpsstackjimmycaicomguidemodify-theme&#34;&gt;テーマの修正ロジック (&lt;a class=&#34;link&#34; href=&#34;https://stack.jimmycai.com/guide/modify-theme&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stack.jimmycai.com/guide/modify-theme&lt;/a&gt;)
&lt;/h2&gt;&lt;p&gt;前面モジュール化の基礎概念を理解した上で、カスタムテーマを理解すると、それほど難しくありません。&lt;code&gt;hugo&lt;/code&gt; の現在のテーマも、複数の異なるモジュールを組み合わせて構成されています。あるモジュールを変更したい場合は、対応するテンプレートファイルを検索し、修正すればOKです。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;stack&lt;/code&gt; 公式ドキュメントからの抜粋：&lt;/p&gt;
&lt;p&gt;この方法を使用すると、&lt;code&gt;themes&lt;/code&gt; ディレクトリの下にファイルは存在しません。テーマを修正するには、変更したいファイルを同じディレクトリにある &lt;code&gt;layouts&lt;/code&gt; ディレクトリにコピーする必要があります。&lt;/p&gt;
&lt;p&gt;例えば、&lt;code&gt;themes/hugo-theme-stack/layouts/partials/head/custom.html&lt;/code&gt; ファイルを変更する場合は、それを &lt;code&gt;layouts/partials/head/custom.html&lt;/code&gt; にコピーし、そこから修正します（テーマのリポジトリからコードをコピー）。&lt;code&gt;assets&lt;/code&gt; と &lt;code&gt;static&lt;/code&gt; ディレクトリについても同様です。&lt;/p&gt;
&lt;h2 id=&#34;テンプレートファイルの場所を見つける方法&#34;&gt;テンプレートファイルの場所を見つける方法
&lt;/h2&gt;&lt;h3 id=&#34;従来の思路&#34;&gt;従来の思路
&lt;/h3&gt;&lt;p&gt;テーマのソースファイルを確認し、テーマのデザイン思想を理解し、対応するテンプレートファイルを修正します。&lt;/p&gt;
&lt;h3 id=&#34;蛮力的なアプローチ&#34;&gt;蛮力的なアプローチ
&lt;/h3&gt;&lt;p&gt;私はフロントエンドのコードがあまり理解していないため、時には手動で対応することがあります。例えば、関連するページをブラウザで開き、修正したい箇所を見つけ、&lt;code&gt;要素を検査&lt;/code&gt;を使ってCSS名（&lt;code&gt;css name&lt;/code&gt;）を特定し、ソースコード内で検索して該当ファイルを抽出し、それをサイトディレクトリにコピーして変更します。&lt;/p&gt;
&lt;h2 id=&#34;スニppets&#34;&gt;スニppets
&lt;/h2&gt;&lt;p&gt;公式サイトでデフォルトのファイルが用意されており、カスタマイズが必要な箇所は、複数のファイルに分割して &lt;code&gt;custom.scss&lt;/code&gt; ファイルをインポートすることで、よりスタイルの管理を効率化できます。
&lt;img src=&#34;https://ttf248.life/p/hugo-module-customizing-themes-ideas/image.png&#34;
	width=&#34;141&#34;
	height=&#34;375&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;37&#34;
		data-flex-basis=&#34;90px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;修正内容まとめ6時間&#34;&gt;修正内容まとめ（6時間）
&lt;/h2&gt;&lt;p&gt;現在は &lt;code&gt;AI&lt;/code&gt; エンコードの元年であり、詳細な内容はここでは省略し、主な変更点を以下に列挙します。本サイトで行った修正内容としては、コピーボタンのスタイルの調整、コードブロックのスタイルの再設定などがあり、&lt;code&gt;ChatGPT&lt;/code&gt; などは容易に対応できました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全体：グローバル文字スタイルを、以前の &lt;code&gt;even&lt;/code&gt; と &lt;code&gt;info cn&lt;/code&gt; を融合した表示スタイルを引き継ぎ、中国語に最適化&lt;/li&gt;
&lt;li&gt;首页：右側のナビゲーションにマウスインタラクションアニメーションを追加&lt;/li&gt;
&lt;li&gt;首页：記事に概要プレビュー（手間のかかる方法で実現）を追加&lt;/li&gt;
&lt;li&gt;スクロールバー：スクロールバーのスタイルを美化&lt;/li&gt;
&lt;li&gt;コードブロック：&lt;code&gt;highlight.js&lt;/code&gt; を導入し、コードブロックのスタイルを美化&lt;/li&gt;
&lt;li&gt;文章詳細：一部コンテンツが転載であるため、原作者情報と元のリンクを表示&lt;/li&gt;
&lt;li&gt;アーカイブページ：トップのカテゴリ画像にテーマ自带の色付きマスクを削除し、元の画像を表示&lt;/li&gt;
&lt;li&gt;アーカイブページ：年単位でのカテゴリ分類の統計表示パネルを追加&lt;/li&gt;
&lt;li&gt;アーカイブページ：2列表示レイアウト
&lt;code&gt;stack&lt;/code&gt; テーマのコンポーネント再利用率が高いため、首页の記事への概要プレビュー追加に時間がかかりました。対応するコンポーネントを変更したことで、記事の詳細ページの変更も引き起こされ、正文が重複して表示される問題が発生しました。&lt;code&gt;golang テンプレート&lt;/code&gt; の構文はあまり馴染みがないため、多くの時間を費やし、コンポーネント間のパラメータ伝達を解決することができませんでした。最終的には、巧みに手段として、ホームページに独自に &lt;code&gt;JavaScript&lt;/code&gt; スクリプトを導入し、カスタムの特殊変数を通じて概要プレビューを実現しました。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;コード再利用率が高すぎる場合も問題であり、変更を加えることで他の場所にも影響が及ぶ可能性があるため、テーマを変更する際には注意が必要です。元のロジックを壊さないようにしてください。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;コメント欄&#34;&gt;コメント欄
&lt;/h3&gt;&lt;p&gt;このイケメンさんの修正はより洗練されています：&lt;a class=&#34;link&#34; href=&#34;https://blog.reincarnatey.net/2024/0719-better-waline/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.reincarnatey.net/2024/0719-better-waline/&lt;/a&gt;
&lt;del&gt;本サイトではシンプルな形で &lt;code&gt;Waline&lt;/code&gt; 评论システムを導入しており、&lt;code&gt;stack&lt;/code&gt; テーマがデフォルトで &lt;code&gt;Waline&lt;/code&gt; をサポートしているため、&lt;code&gt;config.toml&lt;/code&gt; に設定するだけです。&lt;/del&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ホームページへのメール連絡の推奨、本サイトではコメント欄は開放していません&lt;/p&gt;
&lt;/blockquote&gt;</description>
        </item>
        <item>
        <title>Linuxバックエンドサービスの大量文字列データの処理 - 効率が悪い</title>
        <link>https://ttf248.life/ja/p/linux-backend-slow-string-processing/</link>
        <pubDate>Wed, 13 Nov 2024 19:42:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-backend-slow-string-processing/</guid>
        <description>&lt;p&gt;C++開発の歴史的なプロジェクトにおいて、カスタムプロトコルを使用して通信を行っており、そのプロトコルは2次元配列のパターンを採用していました。大量データを処理する際に、プロトコル内部では配列を遍历し、シリアライズ操作を実行してログを生成しており、このため効率が低く、システムが高負荷時に顕著なフレーム落ち（カドゥ）を引き起こしました。事業部門からは、システムのフレーム落ちに関するフィードバックがありました。&lt;/p&gt;
&lt;h2 id=&#34;問題の特定&#34;&gt;問題の特定
&lt;/h2&gt;&lt;p&gt;問題のトラブルシューティングにおいて、まずシステムに対してパフォーマンス分析を実施し、大量データを処理する際にCPU使用率が著しく増加し、システムの応答時間が長くなっていることを発見しました。ログを分析した結果、多数のシリアライズ操作が見られ、これらの操作は2次元配列を処理する際の効率が低いことが原因でシステム性能が低下していました。
&lt;code&gt;pstack&lt;/code&gt;ツールを使用してサービスのスレッド情報を取得し、ログスレッドが文字列の連結に大部分の時間を使用していることを特定しました。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;今日は重点的に取り組むべき点です。異なる累積方式では、その効率の違いは非常に大きいです。過去のコードでは &amp;lsquo;+&amp;rsquo; 演算子を使用しており、この方法は頻繁に一時オブジェクトを作成するため、非常に非効率的でした。それは、その非効率さがどの程度であるかを知らない状況にあるようなものです。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;デモ検証&#34;&gt;デモ検証
&lt;/h2&gt;&lt;p&gt;プロジェクトコードに基づいて、ビジネスロジックを抽出し、文字列連結の効率に関する問題を検証するためのシンプルなデモを作成しました。Windows環境ではVisual Studio 2022コンパイラ、Linux環境ではgcc8.5コンパイラを使用し、Releaseモードでビルドして実行することで、効率を比較します。&lt;/p&gt;
&lt;h3 id=&#34;キーポイントの説明&#34;&gt;キーポイントの説明
&lt;/h3&gt;&lt;p&gt;本プロジェクトで使用されたのは方法四であり、テストデータを入手する前に、どの方法が最も効率が良いか、最も効率が悪いかを読者が最初に考えてみるべきです。結果を見たときは、自分自身にとても驚きました。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;方法 1 (&lt;code&gt;+=&lt;/code&gt; による連結)&lt;/strong&gt;：各フィールドを &lt;code&gt;+=&lt;/code&gt; を使って文字列に直接連結します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法 2 (&lt;code&gt;std::ostringstream&lt;/code&gt; による連結)&lt;/strong&gt;：ストリーム（&lt;code&gt;std::ostringstream&lt;/code&gt;）を使用して各フィールドを連結する方法で、特に大量のデータを連結する場合に効率的です。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法 3 (事前にメモリを割り当てる &lt;code&gt;+=&lt;/code&gt; による連結)&lt;/strong&gt;：&lt;code&gt;reserve&lt;/code&gt; を使用して文字列に必要な十分なメモリを事前に割り当て、メモリ再割り当てのオーバーヘッドを削減することでパフォーマンスを向上させます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法 4 (&lt;code&gt;bodys = bodys + body + &amp;quot;\n&amp;quot;&lt;/code&gt;)&lt;/strong&gt;: 各連結で新しい一時的な文字列オブジェクトを作成するため、パフォーマンスが低下します。特に大規模な連結の場合、各連結において新しいメモリ割り当てとコピーが発生するためです。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参照結果から、プロジェクトはちょうど最も効率の悪い方法を選択していました。&lt;/p&gt;
&lt;p&gt;さらに詳しく分析すると、異なるプラットフォームコンパイラによる最適化効率を分析できます。Microsoft の &lt;code&gt;visual studio&lt;/code&gt; は従来通り優れており、文字列の最適化効率は非常に高いですが、&lt;code&gt;gcc&lt;/code&gt; コンパイラの最適化効率は少し劣ります。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;異なるマシンでコードを実行した場合、2つのデータセット間で直接比較する意味はありません。異なる連結方法間の差を比較できます。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;主要ポイント&#34;&gt;主要ポイント
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Windowsプラットフォーム下でのVisual Studio 2022コンパイラ

----------------------------------------
データ生成時間: 0.054秒。
----------------------------------------

----------------------------------------
データマージパフォーマンス:
----------------------------------------
+ データマージ (+=) にかかった時間: 0.053秒。
+ ostringstream データマージにかかった時間: 0.054秒。
+ 事前予約済みデータマージにかかった時間: 0.045秒。
+ データマージ (bodys = bodys + body + &amp;quot;\n&amp;quot;) にかかった時間: 16.108秒。

----------------------------------------
データマージ完了。
----------------------------------------

プログラム終了。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Linuxプラットフォーム下でのgcc8.5コンパイラ
----------------------------------------
データ生成時間: 0.108秒。
----------------------------------------

----------------------------------------
データマージパフォーマンス:
----------------------------------------
+ データマージ (+=) にかかった時間: 0.100秒。
+ ostringstream データマージにかかった時間: 0.083秒。
+ 事前予約済みデータマージにかかった時間: 0.057秒。
+ データマージ (bodys = bodys + body + &amp;quot;\n&amp;quot;) にかかった時間: 29.298秒。

----------------------------------------
データマージ完了。
----------------------------------------

プログラム終了。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完整コード&#34;&gt;完整コード
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;random&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;iomanip&amp;gt;

typedef std::vector&amp;lt;std::string&amp;gt; DataRow;
typedef std::vector&amp;lt;DataRow&amp;gt; DataGroup;

struct ResponsePackage
{
    std::string ErrorInfo;
    DataRow Head;
    std::string ClientId;
    std::string UUID;
    std::string MsgID;
    std::string SessionID;
    std::string ExtraInfo1;
    std::string ExtraInfo2;
    DataGroup DataBody;
};

// Generate specified length of random string
std::string generateRandomString(size_t length)
{
    const char charset[] = &amp;quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&amp;quot;;
    const size_t max_index = sizeof(charset) - 1;
    std::string random_string;
    random_string.reserve(length);

    std::random_device rd;
    std::mt19937 generator(rd());
    std::uniform_int_distribution&amp;lt;&amp;gt; distribution(0, max_index);

    for (size_t i = 0; i &amp;lt; length; ++i)
    {
        random_string += charset[distribution(generator)];
    }

    return random_string;
}

void create_large_string()
{
    // Example request package with 50 fields
    ResponsePackage requestPackage;

    requestPackage.Head = {
        &amp;quot;Field1&amp;quot;, &amp;quot;Field2&amp;quot;, &amp;quot;Field3&amp;quot;, &amp;quot;Field4&amp;quot;, &amp;quot;Field5&amp;quot;,
        &amp;quot;Field6&amp;quot;, &amp;quot;Field7&amp;quot;, &amp;quot;Field8&amp;quot;, &amp;quot;Field9&amp;quot;, &amp;quot;Field10&amp;quot;,
        &amp;quot;Field11&amp;quot;, &amp;quot;Field12&amp;quot;, &amp;quot;Field13&amp;quot;, &amp;quot;Field14&amp;quot;, &amp;quot;Field15&amp;quot;,
        &amp;quot;Field16&amp;quot;, &amp;quot;Field17&amp;quot;, &amp;quot;Field18&amp;quot;, &amp;quot;Field19&amp;quot;, &amp;quot;Field20&amp;quot;,
        &amp;quot;Field21&amp;quot;, &amp;quot;Field22&amp;quot;, &amp;quot;Field23&amp;quot;, &amp;quot;Field24&amp;quot;, &amp;quot;Field25&amp;quot;,
        &amp;quot;Field26&amp;quot;, &amp;quot;Field27&amp;quot;, &amp;quot;Field28&amp;quot;, &amp;quot;Field29&amp;quot;, &amp;quot;Field30&amp;quot;,
        &amp;quot;Field31&amp;quot;, &amp;quot;Field32&amp;quot;, &amp;quot;Field33&amp;quot;, &amp;quot;Field34&amp;quot;, &amp;quot;Field35&amp;quot;,
        &amp;quot;Field36&amp;quot;, &amp;quot;Field37&amp;quot;, &amp;quot;Field38&amp;quot;, &amp;quot;Field39&amp;quot;, &amp;quot;Field40&amp;quot;,
        &amp;quot;Field41&amp;quot;, &amp;quot;Field42&amp;quot;, &amp;quot;Field43&amp;quot;, &amp;quot;Field44&amp;quot;, &amp;quot;Field45&amp;quot;,
        &amp;quot;Field46&amp;quot;, &amp;quot;Field47&amp;quot;, &amp;quot;Field48&amp;quot;, &amp;quot;Field49&amp;quot;, &amp;quot;Field50&amp;quot;
    };

    requestPackage.ClientId = &amp;quot;ClientID&amp;quot;;
    requestPackage.UUID = &amp;quot;UUID&amp;quot;;
    requestPackage.MsgID = &amp;quot;MsgID&amp;quot;;
    requestPackage.SessionID = &amp;quot;SessionID&amp;quot;;
    requestPackage.ExtraInfo1 = &amp;quot;ExtraInfo1&amp;quot;;
    requestPackage.ExtraInfo2 = &amp;quot;ExtraInfo2&amp;quot;;

    // Start timing for data generation
    auto start_gen = std::chrono::high_resolution_clock::now();

    // Generate 10,000 rows of data, each with 50 fields
    for (size_t i = 0; i &amp;lt; 10000; ++i)
    {
        DataRow dataRow(50, &amp;quot;This is a test string&amp;quot;);
        requestPackage.DataBody.push_back(dataRow);
    }

    // End timing for data generation
    auto end_gen = std::chrono::high_resolution_clock::now();
    std::chrono::duration&amp;lt;double&amp;gt; duration_gen = end_gen - start_gen;

    // Display result generation time
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Generation Time: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_gen.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    // Data merging using different methods
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Performance:\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    {
        // Method 1: Using &#39;+=&#39; string concatenation
        auto start_merge = std::chrono

## 完全なコード
```json
{
        // Method 2: Using ostringstream
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::ostringstream bodys;
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::ostringstream body;
            body &amp;lt;&amp;lt; &amp;quot;This is a test string&amp;quot;;
            for (auto&amp;amp; item : vec)
            {
                body &amp;lt;&amp;lt; item &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            }
            bodys &amp;lt;&amp;lt; body.str() &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ ostringstream Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 3: Pre-allocated memory
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys;
        bodys.reserve(1000 * 50 * 20); // Pre-allocate enough memory
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            body.reserve(50 * 20); // Pre-allocate memory for each row
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Pre-reserved Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 4: Using &#39;bodys = bodys + body + &amp;quot;\n&amp;quot;&#39;
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body = body + item + &amp;quot; &amp;quot;; // Note the use of &#39;body = body + item&#39;
            }
            bodys = bodys + body + &amp;quot;\n&amp;quot;; // Again, using &#39;bodys = bodys + body&#39;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (bodys = bodys + body + \&amp;quot;\\n\&amp;quot;) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Complete.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;
}

int main()
{
    try
    {
        create_large_string();
    }
    catch (const std::exception&amp;amp; e)
    {
        std::cerr &amp;lt;&amp;lt; &amp;quot;Caught exception: &amp;quot; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\nProgram finished.\n&amp;quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>C&#43;&#43;におけるラムダ式のパラメータのライフタイムについて</title>
        <link>https://ttf248.life/ja/p/cpp-lambda-parameter-lifetime/</link>
        <pubDate>Wed, 13 Nov 2024 19:23:02 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cpp-lambda-parameter-lifetime/</guid>
        <description>&lt;p&gt;C++において、ラムダ式は便利な匿名関数であり、外部変数をキャプチャして内部で使用することができます。これにより、ラムダ式は柔軟なプログラミングツールとなります。しかし、ラムダ式のパラメータのライフサイクルは特に注意すべき点であり、特にキャプチャおよびパラメータを渡す際に重要です。&lt;/p&gt;
&lt;h3 id=&#34;1-ラムダ式のパラメータのライフサイクル&#34;&gt;1. ラムダ式のパラメータのライフサイクル
&lt;/h3&gt;&lt;p&gt;ラムダ式のパラメータのライフサイクルは、通常他のC++関数と同様です。関数の引数は関数呼び出し時に存在し、関数呼び出しが終了すると引数のライフサイクルも終了します。ただし、ラムダ式が外部変数をキャプチャする場合、そのキャプチャ方法によって引数のライフサイクルに影響を受ける可能性があります。&lt;/p&gt;
&lt;h3 id=&#34;2-パラメータのライフサイクルとの関係を捉える&#34;&gt;2. パラメータのライフサイクルとの関係を捉える
&lt;/h3&gt;&lt;h4 id=&#34;21-外部変数のキャプチャ&#34;&gt;2.1 外部変数のキャプチャ
&lt;/h4&gt;&lt;p&gt;C++のラムダ式では、以下の2つの方法で外部変数 キャプチャできます:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;値によるキャプチャ:&lt;/strong&gt; 値によるキャプチャでは、外部変数の値がラムダ内部にコピーされ、ラムダ内のコピーのライフサイクルはラムダのライフサイクルによって制御されます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参照によるキャプチャ:&lt;/strong&gt; 参照によるキャプチャでは、外部変数の参照が保持され、ラムダ内の参照は元の外部変数に指し示します。ライフサイクルは外部変数のライフサイクルに依存します。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda_by_value = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };  // xのコピーをキャプチャ
auto lambda_by_reference = [&amp;amp;x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };  // xの参照をキャプチャ

lambda_by_value();  // 10 を出力
lambda_by_reference();  // 10 を出力
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;キャプチャされた変数 のライフサイクルは以下のとおりです:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;値によるキャプチャ:&lt;/strong&gt; キャプチャ時に外部変数の値がラムダにコピーされ、ラムダのライフサイクルが終了すると、コピーされたコピーが破棄されます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参照によるキャプチャ:&lt;/strong&gt; ラムダが外部変数の参照を保持し、&lt;strong&gt;外部変数はラムダの使用前に有効でなければなりません。そうでない場合、未定義動作が発生します。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;22-ラムダパラメータ&#34;&gt;2.2 ラムダパラメータ
&lt;/h4&gt;&lt;p&gt;ラムダパラメータは、通常の関数パラメータと同様に、そのライフサイクルはラムダ関数内のみに限られます。つまり、ラムダパラメータはラムダが呼び出されたときに作成され、ラムダが呼び出された後にそのライフサイクルも終了します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto lambda = [](int a, int b) {
    std::cout &amp;lt;&amp;lt; a + b &amp;lt;&amp;lt; std::endl;
};
lambda(5, 10); // ここでaとbはラムダのパラメータ
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この例では、&lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; はラムダ式のパラメータであり、ラムダが呼び出されたときに作成され、ラムダの実行後に破棄されます。&lt;/p&gt;
&lt;h3 id=&#34;3-外部変数を捕捉する際のライフサイクルに関する問題&#34;&gt;3. 外部変数を捕捉する際のライフサイクルに関する問題
&lt;/h3&gt;&lt;h4 id=&#34;31-キャプチャされた変数が出-lambda-の外で有効か&#34;&gt;3.1 キャプチャされた変数が出 lambda の外で有効か
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;値によるキャプチャ&lt;/strong&gt;：外部変数が lambda が呼び出された後に破棄されても、lambda 内には外部変数のコピーが保持されます。したがって、lambda 内のコピーは安全に使用でき、外部変数が存在しなくなっても問題ありません。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x は lambda が呼び出された後に変更されます
lambda();  // 10 を出力します（x のコピーを使用）
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;参照によるキャプチャ&lt;/strong&gt;：外部変数を参照でキャプチャする場合、lambda 内での外部変数へのアクセスは外部変数のライフサイクルに依存します。外部変数が lambda が実行される前に破棄された場合、ダングリング参照が発生し、未定義の動作を引き起こります。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [&amp;amp;x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x は lambda が実行される前に変更されます
lambda();  // 20 を出力します（x の参照を使用）
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;lambda の実行順序が不定の場合、キャプチャされた外部変数が lambda の実行時に有効であることを保証することが重要です。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>Win11 Logitech G431 ヘッドホン ドライバー インストール</title>
        <link>https://ttf248.life/ja/p/win11-logitech-g431-headphone-driver-installation/</link>
        <pubDate>Wed, 05 Jun 2024 07:20:17 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/win11-logitech-g431-headphone-driver-installation/</guid>
        <description>&lt;p&gt;前回の続きですが、戻ってみたらGhubにアップデートがあったので少し嬉しい。カスタマーサポートが言っていた、ドライバが正常にロードできない問題が解決したと言っていたのですが、色々試してみたものの、再インストールしても正常には動かない。&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景
&lt;/h2&gt;&lt;p&gt;引き続きカスタマーサポートに問い合わせて解決策を相談したが、エンジニアによるリモート支援が可能であると伝えられたが、エンジニアの勤務時間と自身の勤務時間が完全に一致しないため、結局諦めざるを得なかった。最後にトラブルシューティングで残された資料を確認し、手動でのドライバーインストールを試みることにした。&lt;/p&gt;
&lt;h2 id=&#34;驱动安装包の入手方法&#34;&gt;驱动安装包の入手方法
&lt;/h2&gt;&lt;p&gt;ロジック社の公式には、個別のデバイスのドライバインストールパッケージが提供されていません。どのようにしてドライバファイルを入手すれば良いでしょうか？
最後にシステムを再構築した際のシステムイメージパッケージと組み合わせて、ローカル仮想マシンでシステムをクリーンに再構築し、そこでGhubを単独で展開します。これにより、ヘッドセットデバイスを仮想マシンに導入し、ドライバのパスを見つけてコピーアウトすることができます。
関連するパス：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C:\ProgramData\LGHUB&lt;/li&gt;
&lt;li&gt;C:\Windows\System32\DriverStore\FileRepository\logi_audio.inf_amd64_010b035044e24be4&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;デバイスマネージャー&#34;&gt;デバイスマネージャー
&lt;/h2&gt;&lt;p&gt;重点は２番目のパスの探し方で、まずはWindows 11 システムがどのように手動でドライバーファイルを管理できるかを整理します。この内容は、&lt;strong&gt;交差法（コントロール変数法）を用いて識別し、デバイスを抜き差しすることで仮想マシン内でデバイスマネージャーの情報からデバイス情報を特定し、合計３つのドライバーを処理する必要があることを認識しました&lt;/strong&gt;。そのうち２つのドライバーはシステムに組み込まれており、１つはロジック社が提供しています。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;20240605073331.png&#34; &gt;ドライバーマネージャー&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;上記の図の２番目のドライバーは、ロジック社が提供しており、デバイスの現在のドライバープログラムを分析し、仮想マシン内のすべてのドライバーパスを検索します。もちろん、最初に「logi」で始まるファイルを見つける必要があります。その後、ファイルの比較を行うことでドライバーのファイル件を特定し、そのフォルダ全体をコピーすることでドライバーインストールパッケージを入手できます。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;20240605073933.png&#34; &gt;ドライバーインストールパッケージ&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;驅動のインストール&#34;&gt;驅動のインストール
&lt;/h2&gt;&lt;p&gt;デバイスマネージャーのインターフェースで、以下の手順を実行します：&lt;/p&gt;
&lt;p&gt;「ドライバーの更新」をクリックし、「コンピューター上のドライブを検索」をクリックすると、以下の画面が表示されます：&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/win11-logitech-g431-headphone-driver-installation/20240605074130.png&#34;
	width=&#34;528&#34;
	height=&#34;381&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;ドライバーインストール&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;138&#34;
		data-flex-basis=&#34;332px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;通常起動すると、USBドライバーのみが表示されます。  「ディスクからインストール」を選択し、事前にコピーしてきたフォルダのパスを指定します。 インストール後、「ドロップダウンリスト」からロジック特有のドライバーが追加され、デバイスドライバーを新しくインストールしたドライバーに変更します。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/win11-logitech-g431-headphone-driver-installation/20240605074208.png&#34;
	width=&#34;593&#34;
	height=&#34;423&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;ディスクインストール&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;140&#34;
		data-flex-basis=&#34;336px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;人体工学デバイス駆動&#34;&gt;人体工学デバイス駆動
&lt;/h2&gt;&lt;p&gt;このドライブファイルはすべてシステムが提供するものですが、デバイスのドライバの前に感嘆符 (!) があるかどうかを確認してください。もし感嘆符があれば、ドライバ選択インターフェースに移動し、ランダムな他の種類のドライバを選択してから、再度元のドライバに戻すことで正常に復元できます。&lt;/p&gt;
&lt;h2 id=&#34;修了&#34;&gt;修了
&lt;/h2&gt;&lt;p&gt;ヘッドホンマイクの音量が正常に回復し、馴染みのあるエコーキャンセル機能も復帰しました。
&lt;a class=&#34;link&#34; href=&#34;20240605074823.png&#34; &gt;サイドノイズ画像&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>ロジック(レイザー) ヘッドホン ドライバーのインストールに失敗しました。 (Rōjiku (Reizā) heddohon dᱨīvā no insutora ni himitsu shimaimashita.)

**Note:** I&#39;ve provided the romanized version for pronunciation.  A more natural Japanese phrasing would be:

ロジック(レイザー) ヘッドホンドライバーのインストールが失敗しました。 (Rōjiku (Reizā) heddohon dᱨīvā no insutora ga himitsu shimaimashita.)</title>
        <link>https://ttf248.life/ja/p/logitech-headphone-driver-installation-failure/</link>
        <pubDate>Fri, 31 May 2024 21:46:12 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/logitech-headphone-driver-installation-failure/</guid>
        <description>&lt;p&gt;これらのことを全く理解していない場合は、すぐに公式のカスタマーサポートに連絡すれば、何時間も悩むことがなくなるだろう。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/logitech-headphone-driver-installation-failure/20240531220709.png&#34;
	width=&#34;693&#34;
	height=&#34;489&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;GHUB&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;141&#34;
		data-flex-basis=&#34;340px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;最近、自宅で開発に使っていたデスクトップPCのCドライブがストレージ容量不足になってしまったため、特意に256GBの半退役SSDをCドライブとして使用するようにした。ところが、その後、色々と勝手なことをしてしまっている。上海に引っ越してからずっと様々な業務に追われており、つい先週ようやくシステムを再インストールした。&lt;/p&gt;
&lt;p&gt;システムを再インストールする過程はスムーズで、日常的なソフトウェアのインストールや開発環境のデプロイにも問題はなかった。数日後、私はリラックスして、数ゲームプレイすることを思い立ったが、その時になってマウスとヘッドホンのドライバーがまだインストールされていないことに気づいた。これらのデバイスはどちらもロジクスの製品であるため、GHUBソフトウェアをダウンロードし、このソフトウェアはハードウェアを自動的に認識し、ドライバーをインストールすることができる。&lt;/p&gt;
&lt;p&gt;しかし、予期せぬ事態が発生した。マウスのドライバーは正常にインストールされたが、ヘッドホンのドライバーは常に「読み込み中」と表示され続けた。最新版のWindows 11システムとロジクスのドライバーの互換性の問題でインストールが失敗しているのではないかと疑ったため、私は情報を検索し、手動でドライバーをインストールすることを試みたが、問題は解決しなかった。&lt;/p&gt;
&lt;p&gt;簡単に説明すると、これらのデバイスのドライバーはそれぞれどのような役割を果たしているのかを示す。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;マウスのドライバーは主にマウスの移動速度などの機能を調整するために使用される。マクロ機能はほとんど使用しないため、以前覚えていたパラメータに戻すだけでよい。&lt;/li&gt;
&lt;li&gt;ヘッドホンのドライバーは主にヘッドホンリバーブ機能に使用され、これはチームでの音声通話時に非常に役立ち、自分の発言を聞くことができる。システムのミキサー設定にも同様のモニタリング機能があるが、ドライバーで実現するよりも効果がない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;私は何度も試みたが、ヘッドホンのドライバーは常に正常に読み込まれなかった。今日、ついにカスタマーサポートに問い合わせることを思いつき、状況を確認し、解決策を見つけることができるかどうかを尋ねた。カスタマーサポートは、最近彼らのサーバーで問題が発生しており、ドライバーのダウンロードが異常になっていると教えてくれた。彼らはこの問題を処理しており、私に急がないように指示し、次のアップデート後に問題が解決すると言った。&lt;/p&gt;
&lt;p&gt;まだヘッドホンのドライバーの問題が解決していないが、少なくとも原因を突き止めることができた。問題が早急に解決することを願っている。&lt;/p&gt;
&lt;h2 id=&#34;マウスドライバ設定&#34;&gt;マウスドライバ設定
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/logitech-headphone-driver-installation-failure/20240531220930.png&#34;
	width=&#34;1024&#34;
	height=&#34;768&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;G502&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;133&#34;
		data-flex-basis=&#34;320px&#34;
	
&gt;
&lt;img src=&#34;https://ttf248.life/p/logitech-headphone-driver-installation-failure/20240531220903.png&#34;
	width=&#34;1024&#34;
	height=&#34;768&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;G502&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;133&#34;
		data-flex-basis=&#34;320px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Python辞書におけるカスタムオブジェクトの保存：参照と深いコピーの重要性</title>
        <link>https://ttf248.life/ja/p/python-dictionary-custom-objects-reference-vs-deepcopy/</link>
        <pubDate>Fri, 22 Mar 2024 01:08:05 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/python-dictionary-custom-objects-reference-vs-deepcopy/</guid>
        <description>&lt;p&gt;Python プログラミングにおいて、辞書は非常に強力なデータ構造であり、キーと値のペアを関連付け、効率的にデータを検索および操作することを可能にします。カスタムオブジェクトを辞書に格納しようとすると、通常、重要な概念である「Python におけるオブジェクト参照（参照渡し）」が問題となります。つまり、カスタムオブジェクトを辞書に入れる場合、辞書はオブジェクトへの参照を格納するだけであり、オブジェクトの完全なコピーを作成しているわけではありません。&lt;/p&gt;
&lt;h2 id=&#34;カスタムオブジェクトの基本的な例&#34;&gt;カスタムオブジェクトの基本的な例
&lt;/h2&gt;&lt;p&gt;以下の簡単な &lt;code&gt;Person&lt;/code&gt; クラスを想定してください:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

# Person オブジェクトを作成
p1 = Person(&amp;quot;Alice&amp;quot;, 30)

# オブジェクトを辞書に保存
people_dict = {}
people_dict[&amp;quot;alice&amp;quot;] = p1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この例では、&lt;code&gt;people_dict&lt;/code&gt; 辞書が &lt;code&gt;&amp;quot;alice&amp;quot;&lt;/code&gt; というキーを持つ項目を含み、その値は &lt;code&gt;Person&lt;/code&gt; 型の &lt;code&gt;p1&lt;/code&gt; オブジェクトへの参照です。  &lt;code&gt;p1&lt;/code&gt; の属性を変更すると:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;p1.age = 31
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;辞書からオブジェクトにアクセスするときに、その年齢も更新されていることに気づきます:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(people_dict[&amp;quot;alice&amp;quot;].age)  # 出力: 31
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これは、辞書が &lt;code&gt;Person&lt;/code&gt; オブジェクトの独立したコピーを保存するのではなく、同じメモリ位置への参照を保存しているためです。&lt;/p&gt;
&lt;h2 id=&#34;深復元と浅復元の違い&#34;&gt;深復元と浅復元の違い
&lt;/h2&gt;&lt;p&gt;ネストされたデータ構造やカスタムオブジェクトを扱う場合、このような参照の動作は予期せぬ結果を引き起こす可能性があります。例えば、カスタムオブジェクトが可変型の属性（リストや別のカスタムオブジェクトなど）を含む場合、そのようなオブジェクトを辞書に直接格納し、その変更を加えると、辞書から取得したオブジェクトも影響を受けます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Address:
    def __init__(self, street, city):
        self.street = street
        self.city = city

class Person:
    def __init__(self, name, age, address):
        self.name = name
        self.age = age
        self.address = address

address = Address(&amp;quot;Main St.&amp;quot;, &amp;quot;Springfield&amp;quot;)
p1 = Person(&amp;quot;Bob&amp;quot;, 40, address)
people_dict[&amp;quot;bob&amp;quot;] = p1

# 原始アドレスオブジェクトを変更
address.city = &amp;quot;Shelbyville&amp;quot;

# 辞書内の人のアドレスも変更される
print(people_dict[&amp;quot;bob&amp;quot;].address.city)  # 出力：Shelbyville
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解決策：深復元&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;このような共有状態の問題を回避するためには、辞書がオブジェクトの完全なコピーを格納していることを確認する必要があります。つまり、参照ではなく、独立したコピーである必要があります。Python は &lt;code&gt;copy&lt;/code&gt; モジュールにある &lt;code&gt;deepcopy&lt;/code&gt; 関数を使用してこれを実現します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import copy

# オブジェクトを深復元で格納
people_dict[&amp;quot;bob_deepcopy&amp;quot;] = copy.deepcopy(p1)

# 原始アドレスオブジェクトを変更しても、深復元されたオブジェクトには影響しない
address.city = &amp;quot;Capital City&amp;quot;
print(people_dict[&amp;quot;bob&amp;quot;].address.city)  # 出力：Capital City
print(people_dict[&amp;quot;bob_deepcopy&amp;quot;].address.city)  # 出力：Capital City
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要するに、Python で辞書を使用してカスタムオブジェクトを格納する場合は、デフォルトでオブジェクトの参照が格納されることに注意してください。独立した状態を維持する必要がある場合は、&lt;code&gt;deepcopy&lt;/code&gt; を使用して深復元を行い、共有参照による予期せぬデータ変更を防ぐようにしてください。&lt;/p&gt;</description>
        </item>
        <item>
        <title>新規に設置した10Gbps光回線なのに、なぜ速度が1Gbpsしか出ないのか？</title>
        <link>https://ttf248.life/ja/p/gigabit-fiber-slow-speed/</link>
        <pubDate>Mon, 18 Mar 2024 00:29:02 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/gigabit-fiber-slow-speed/</guid>
        <description>&lt;p&gt;自宅のネットワークを驚くほど高速にしたいですか？鍵はケーブルの種類、光猫、ルーターの設定、そして些細なディテールを知ることです。この記事では、6種類のケーブルを使ってテラビット級のネットワークを構築する方法と、簡単なデバイスチェックと設定で、あなたのネットワーク速度が制限されないようにすることについて、簡単に解説します。さあ、一緒に探求し、自宅のネットワーク速度を飛躍的に向上させましょう！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/gigabit-fiber-slow-speed/image.png&#34;
	width=&#34;1001&#34;
	height=&#34;590&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;手動修復&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;169&#34;
		data-flex-basis=&#34;407px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;第1章ネットワーク伝送媒体の徹底分析&#34;&gt;第1章：ネットワーク伝送媒体の徹底分析
&lt;/h2&gt;&lt;p&gt;千Gb級ネットワーク接続を実現する際、情報を高速に伝送するための担い手であるケーブルが極めて重要な役割を果たします。以下では、カテゴリ5、カテゴリ6、カテゴリ7ケーブルについて詳細な解説を行います。&lt;/p&gt;
&lt;h3 id=&#34;1-五類ケーブルcat5&#34;&gt;1. &lt;strong&gt;五類ケーブル（CAT5）&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;五類ケーブル、別名CAT5は、最も普及した初期のツイストペアケーブルの一種であり、各対線芯を精密ならせん構造で設計することで、クロスプレーク（串扰）を低減します。主に10/100Mbpsの高速以太ネットで使用され、最大伝送周波数約100MHzですが、現在の千ギガビット級、さらにはそれ以上の速度を求めるニーズにおいては、物理的な制限から五類ケーブルは要求を満たせません。&lt;/p&gt;
&lt;h3 id=&#34;2-六類ケーブルcat6&#34;&gt;2. &lt;strong&gt;六類ケーブル（CAT6）&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;技術の発展に伴い、六類ケーブルが登場しました。五類ケーブルと比較して、六類ケーブルはより厳格な製造基準と先進的な構造設計を採用しており、干渉耐性を大幅に向上させ、伝送効率を高めています。1Gbpsまでの伝送速度をサポートし、理想的な条件下では伝送距離が100メートルにも達するため、千兆ネットワークへの接続要件を満たすのに適しています。&lt;/p&gt;
&lt;h3 id=&#34;3-七類ケーブルcat7&#34;&gt;3. &lt;strong&gt;七類ケーブル（CAT7）&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;七類ケーブルは、現在のツイストペア技術における最先端の水準を代表しています。伝送速度において飛躍的な向上を実現し、理論上では最大10Gbpsの超高速率をサポートするだけでなく、設計段階で完全なシールドシステムを採用しており、各配線対間のシールドに加え、全体の外層シールドも含まれています。これにより、外部電磁干渉や近傍串波を大幅に低減し、データ伝送の安定性と正確性を保証します。ただし、七類ケーブルは主に将来の10Gbイーサネットまたは特定の要件の高い環境向けに使用されます。&lt;/p&gt;
&lt;p&gt;千兆家庭ネットワーク環境における構築において、千兆光ファイバの潜在能力を最大限に引き出すためには、六類ケーブルが最も経済的かつ効率的な選択肢となります。また、すべての接続ケーブルの品質が合格していることを確認し、標準的な配線方法に従って作業を行うことも、ネットワーク性能を確保するための重要な要素です。&lt;/p&gt;
&lt;h2 id=&#34;第2章深層ウェブの中枢デバイスの調査---光猫ルーターlanポート帯域幅の影響&#34;&gt;第2章：深層ウェブの中枢デバイスの調査 - 光猫、ルーターLANポート帯域幅の影響
&lt;/h2&gt;&lt;h3 id=&#34;光猫とそのlanポート帯域幅の重要性&#34;&gt;光猫とそのLANポート帯域幅の重要性
&lt;/h3&gt;&lt;p&gt;光猫（光ファイバーモジュレーター・デコーダー）は、家庭用ブロードバンド接続における主要な機器であり、その機能は光ファイバー内の光信号をデジタル信号に変換し、家庭内ネットワークデバイスで使用するために供与するものです。千兆光回線ユーザーの場合、光猫が千兆伝送をサポートしているかどうかが特に重要になります。もし光猫のWANポートが10Gb（百兆）のみをサポートする場合、入宅光ファイバーの速度が高くても、このボトルネックによって10Gb以内に制限されてしまう可能性があります。同様に、光猫のLANポートも千兆出力能力を備えている必要があり、それ以外に接続されるルーターやその他のデバイスが、その真の千兆レートを取得できないのです。&lt;/p&gt;
&lt;h3 id=&#34;ルーターlanポート帯域幅の役割&#34;&gt;ルーターLANポート帯域幅の役割
&lt;/h3&gt;&lt;p&gt;ルーターのLANポートは、受信したデータを各ターミナルデバイスに配布する役割を担います。ルーターのLANポートが単に10Gb（百兆）である場合、他のデバイスの設定がどれほど優れていても、局所網通信は10Gbのレートに制限されます。したがって、千兆家庭ネットワークを構築する場合、ルーターのWANポートが千兆データを受信し、LANポートも千兆レベルのデータ出力能力を提供できるようにすることが重要です。これにより、ご自宅のすべてのスマートデバイスが高速ネットワークによるスムーズな体験を楽しむことができます。&lt;/p&gt;
&lt;p&gt;さらに、一部の古いまたは低端のルーターには、LANポートレート自動交渉メカニズムが存在する場合があります。これは、ルーター自体が千兆をサポートしていても、ケーブルやデバイスの互換性などの理由により10Gbモードに降格してしまう可能性があることを意味します。したがって、ルーターパラメータを正しく設定し、強制千兆モードを有効にし、千兆スイッチまたは直結デバイスと組み合わせて使用することは、全千兆ネットワークを実現するための重要なステップの一つです。&lt;/p&gt;
&lt;p&gt;千兆光ファイバーにアップグレードした場合、必ず千兆光モデムと千兆ルーターに交換し、すべてのデバイスのインターフェースが千兆レベルであることを確認してください。&lt;/p&gt;
&lt;h2 id=&#34;第3章隠された謎--一本の断線したサブラインがテラバイト級ネットワークの速度にどのように影響するか&#34;&gt;第3章：隠された謎 – 一本の断線したサブラインがテラバイト級ネットワークの速度にどのように影響するか
&lt;/h2&gt;&lt;h3 id=&#34;子線故障とネットワーク性能の低下&#34;&gt;子線故障とネットワーク性能の低下
&lt;/h3&gt;&lt;p&gt;測定期間中にネットワークが常に接続を維持し、明らかな切断状態は発生しませんでした。これは新入戸でのブロードバンド導入であり、弱電箱内に配線が散らかっており、光猫のケーブルや電源インターフェース、延長コードの位置を時々調整していたため、偶発的に測定速度が千兆に達することがありました。&lt;/p&gt;
&lt;p&gt;上記の資料に基づき、ケーブルの種類、光猫のLANポート速度などを分析・調査しましたが、最終的には原因はケーブル内部の一本の茶色の子線が断裂していることが判明しました。&lt;/p&gt;
&lt;p&gt;断裂の原因：作業員が水晶頭を設置する際に、このケーブルを少し強く引っ張ったため、子線が半分ほど断ち切られ、完全に切り離されずにいました。その後、光猫の位置を調整する際に、繰り返し移動させることで、最終的に完全に断裂してしまいました。&lt;/p&gt;
&lt;h3 id=&#34;ケーブルの種類8本の機能解析&#34;&gt;ケーブルの種類8本の機能解析
&lt;/h3&gt;&lt;p&gt;六類網線はTIA/EIA-568-B規格に準拠し、8本の双絞り線を含みます。以下のカラーコードに従っています：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;白橙 / 橙 (しろおげ / おげ)&lt;/li&gt;
&lt;li&gt;白緑 / 緑 (しろりょく / りょく)&lt;/li&gt;
&lt;li&gt;白藍 / 藍 (しろらん / らん)&lt;/li&gt;
&lt;li&gt;白棕 / 棕 (しろしゅん / しゅん)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;千兆イーサネット（1000BASE-T）の規格下では、これらの8本の線の中から4対の線が同時に動作します。具体的な役割分担は以下の通りです：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;白橙と橙のペア (1&amp;amp;2) は、送信データ (Tx+/-) 用です；&lt;/li&gt;
&lt;li&gt;白緑と緑のペア (3&amp;amp;6) は、受信データ (Rx+/-) 用です；&lt;/li&gt;
&lt;li&gt;白藍と藍のペア (4&amp;amp;5) および白棕と棕のペア (7&amp;amp;8) は、千兆イーサネットでは当初は副用ですが、高度なアプリケーション（例えば、一部PoE給電や将来の技術拡張など）で有効化されることがあります。従来の100Gbイーサネットでは、1, 2, 3, 6 の4本の線を使用するだけで十分です。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;断裂子線がネットワーク速度に与える影響&#34;&gt;断裂子線がネットワーク速度に与える影響
&lt;/h3&gt;&lt;p&gt;上記の場合において、もし一根褐色の子線（すなわち棕線または棕白線）が断裂した場合、理論上は千兆ネットワーク環境下で速度低下を引き起こす可能性があります。なぜなら、千兆ネットワークでは、すべての四対の線が同時に双方向で伝送することで満速を実現する必要があるためです。しかしながら、家庭用ネットワーク機器には自動ネゴシエーション機能が搭載されており、ケーブルに問題が検出された場合、正常に動作する低いレートモード（百兆モード）に回帰します。これが、一根子線が断裂してもネットワークが接続を維持し、百兆速度で動作を続ける理由を説明しています。&lt;/p&gt;
&lt;p&gt;要するに、一根棕色の子線が断裂しても百兆ネットワークの基本的な動作には影響しませんが、千兆ネットワーク環境下では、それがネットワーク速度を制限する重要な要因となる可能性があります。詳細な診断と修復を行うまで、その潜在的な能力は十分に発揮されません。また、この状況は、類似の問題が発生した際に、ネットワークインフラストラクチャ上の潜在的な問題を無視しないように警告しています。たとえ基本的な接続に影響を与えないように見える小さな故障であっても、高速ネットワーク体験の隠れた障害となる可能性があります。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>WPFにおけるUIスレッドとフリーズ問題とその解決策</title>
        <link>https://ttf248.life/ja/p/wpf-ui-thread-and-freezing-solutions/</link>
        <pubDate>Tue, 12 Mar 2024 07:12:21 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/wpf-ui-thread-and-freezing-solutions/</guid>
        <description>&lt;p&gt;デスクトップアプリケーションの開発、特にWindows Presentation Foundation (WPF) などのフレームワークを使用してリッチクライアントアプリケーションを構築する際には、ユーザーインターフェース（UI）スレッドの適切な処理が、アプリケーションの応答性やスムーズな動作を保証するために非常に重要です。UIスレッド、またはメインスレッドとは、ウィンドウやコントロールのイベント、レイアウト計算、および画面表示の描画を担当するコアとなるスレッドです。UI要素とやり取りするすべての操作は、UIスレッド上で実行する必要があります。これは、WPFをはじめとするほとんどのGUIフレームワークが遵守する基本的な原則です。&lt;/p&gt;
&lt;h2 id=&#34;uiスレッドとは&#34;&gt;UIスレッドとは？
&lt;/h2&gt;&lt;p&gt;UIスレッドは、WPFアプリケーションが起動される際にオペレーティングシステムによって作成され、初期化されるアプリケーションのメインウィンドウです。これは、アプリケーション内でUIコンポーネントの状態を直接アクセスし、変更できる唯一のスレッドです。つまり、ボタンのクリック、テキストボックスへの入力、ウィンドウサイズの変更など、すべてのユーザーインタラクションによって発生するイベントは、このスレッドコンテキストで処理されます。さらに、WPFの依存性プロパティシステム、データバインディングメカニズム、レイアウトロジックもすべてUIスレッド上で同期的に実行されます。&lt;/p&gt;
&lt;h2 id=&#34;uiフリーズとその原因&#34;&gt;UIフリーズとその原因
&lt;/h2&gt;&lt;p&gt;UIスレッドが長時間占有またはブロックされると、例えば、時間のかかる計算、大量のデータ読み込み、データベースクエリ、その他のI/O密度の高いタスクを実行する場合、UIスレッドはユーザーからのインタラクションリクエストにタイムリーに対応できなくなり、結果として画面がフリーズ（Freeze）、つまり私たちがよく言う「カドト」が発生します。このような場合、ユーザーはアプリケーションの遅延や不自然さを明確に感じ、最悪の場合、「Application Not Responding」（ANR）警告が表示されます。&lt;/p&gt;
&lt;h2 id=&#34;uiスレッドの基本ルール２つ&#34;&gt;UIスレッドの基本ルール２つ
&lt;/h2&gt;&lt;p&gt;上記のような状況を回避するため、WPF開発者は以下の２つの重要なルールに従う必要があります。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UIスレッドで時間がかかる処理を実行しない&lt;/strong&gt;: UIスレッドがブロックされる可能性のある操作は、可能な限りバックグラウンドスレッドで実行し、UIスレッドがユーザーの入力や画面の変化に迅速に対応できるようにする必要があります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;非UIスレッドから直接UI要素を更新しない&lt;/strong&gt;: WPFのセキュリティメカニズムにより、UIスレッドのみがUI要素の変更を行う権限を持っています。他のスレッドから直接UIの状態を変更しようとすると例外が発生します。したがって、バックグラウンドスレッドで計算やデータ準備が完了した後でも、適切なクロススレッド通信メカニズムを使用して結果をUIに表示する必要があります。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;解決策非同期プログラミングとスレッドセーフなアップデート&#34;&gt;解決策：非同期プログラミングとスレッドセーフなアップデート
&lt;/h2&gt;&lt;p&gt;UIのフリーズを防ぎつつ、時間のかかるタスクを実行するために、WPFは、開発者がこの目標を達成するためのさまざまな非同期プログラミングモデルやツールを提供しています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Dispatcherオブジェクト&lt;/strong&gt;: WPFのDispatcherクラスを使用すると、タスクをUIスレッドのキューに追加して実行できます。&lt;code&gt;Dispatcher.Invoke&lt;/code&gt;または&lt;code&gt;Dispatcher.BeginInvoke&lt;/code&gt;メソッドを使用して、バックグラウンドスレッドからUIを安全に更新できます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;async/awaitキーワード&lt;/strong&gt;: C#言語の非同期特性を活用し、&lt;code&gt;await&lt;/code&gt;キーワードを使用してバックグラウンドタスクが完了するのを待機し、完了後にUI更新コードを実行する非同期メソッドを作成できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ケース-ケース--例-れい&#34;&gt;ケース (ケース) / 例 (れい)
&lt;/h2&gt;&lt;h3 id=&#34;dispatcherinvokeメソッドを使用してuiを更新する&#34;&gt;&lt;code&gt;Dispatcher.Invoke&lt;/code&gt;メソッドを使用してUIを更新する
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private void Button_Click(object sender, RoutedEventArgs e)
{
    // これは時間のかかる操作であると仮定します
    Task.Run(() =&amp;gt;
    {
        var result = LongRunningOperation(); // ここは時間のかかる計算メソッドのシミュレーションです

        // 時間のかかる操作が完了したら、UIスレッドでUIを更新します
        Application.Current.Dispatcher.Invoke(() =&amp;gt;
        {
            LabelStatus.Text = $&amp;quot;結果: {result}&amp;quot;;
        });
    });
}

private string LongRunningOperation()
{
    // 時間のかかる操作をシミュレーションします
    Thread.Sleep(5000);
    return &amp;quot;完了&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;asyncawaitキーワードとtaskrunの組み合わせ&#34;&gt;&lt;code&gt;async/await&lt;/code&gt;キーワードと&lt;code&gt;Task.Run&lt;/code&gt;の組み合わせ
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private async void Button_ClickAsync(object sender, RoutedEventArgs e)
{
    Button button = sender as Button;
    button.IsEnabled = false; // ユーザーが繰り返しクリックするのを防ぐ

    try
    {
        // バックグラウンドタスクを開始
        var result = await Task.Run(() =&amp;gt; LongRunningOperation());

        // バックグラウンドタスクが完了したら、UIスレッドに自動的に切り替えてUIを更新
        LabelStatus.Text = $&amp;quot;計算結果: {result}&amp;quot;;
    }
    catch (Exception ex)
    {
        MessageBox.Show($&amp;quot;エラーが発生しました: {ex.Message}&amp;quot;);
    }
    finally
    {
        button.IsEnabled = true; // ボタンを再度有効にする
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>GCCバージョンをアップグレードした結果、プログラムがクラッシュしました：コードの非規整性による問題点</title>
        <link>https://ttf248.life/ja/p/gcc-upgrade-causes-program-crash-code-irregularities/</link>
        <pubDate>Sun, 10 Mar 2024 23:19:06 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/gcc-upgrade-causes-program-crash-code-irregularities/</guid>
        <description>&lt;p&gt;同一段業務コードにおいて、プログラムが CentOS 7 環境下で正常にコンパイルおよび実行されていたが、CentOS 8 に切り替えて GCC の最新版を使用してコンパイルを行った際に、プログラムがクラッシュが発生した。注目すべきは、問題が &lt;strong&gt;Release モード&lt;/strong&gt; 下でのみ発生し、&lt;strong&gt;Debug モード&lt;/strong&gt; では完全に問題がない点である。これは初めての事例であり、3日間の調査を経て、問題の原因を特定することができた。&lt;/p&gt;
&lt;h3 id=&#34;問題の特定&#34;&gt;問題の特定
&lt;/h3&gt;&lt;p&gt;一番の原因究明の結果、問題の本質は &lt;strong&gt;関数に返り値がないこと&lt;/strong&gt; にあります。リリースモードにおいて、GCCの新バージョンではより多くの最適化が行われるため、本来返り値のない関数が実行中に未知の論理が発生し、それがクラッシュを引き起こしました。結論として、&lt;strong&gt;コンパイラの警告を無視することは許されません。特に、古いプロジェクトにおいては、一部の警告が無視される可能性がありますが、すべての警告を無効にすることは避けるべきです&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;環境説明&#34;&gt;環境説明
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CentOS 7 GCCバージョン:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CentOS 8 GCCバージョン:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;クラッシュ現象&#34;&gt;クラッシュ現象
&lt;/h3&gt;&lt;p&gt;プログラムのクラッシュに関するスタックを分析した結果、以下のスタック情報が得られました：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[New LWP 1385902]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib64/libthread_db.so.1&amp;quot;.
Core was generated by `./pstack_main`.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007ffe894b4420 in ?? ()
(gdb) bt
#0  0x00007ffe894b4420 in ?? ()
#1  0x00000000004008e9 in main ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このスタックは直感的ではありません。クラッシュ関数のスタック情報が &lt;code&gt;??&lt;/code&gt; と表示されるため、問題の特定がさらに複雑になります。&lt;/p&gt;
&lt;h3 id=&#34;コード例&#34;&gt;コード例
&lt;/h3&gt;&lt;p&gt;問題をより良く理解するために、クラッシュを再現するための最小コード例を示します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int test() {
    std::cout &amp;lt;&amp;lt; &amp;quot;1&amp;quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    test();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このコード内の &lt;code&gt;test()&lt;/code&gt; 関数は明らかに値を明示的に返していません。また、その戻り値の型は &lt;code&gt;int&lt;/code&gt; です。C++ 仕様によると、関数が &lt;code&gt;int&lt;/code&gt; 型で宣言されている場合、必ず戻り値を持つ必要があり、そうでない場合は未定義動作を引き起こす可能性があります。&lt;/p&gt;
&lt;h3 id=&#34;コンパイル警告&#34;&gt;コンパイル警告
&lt;/h3&gt;&lt;p&gt;当方のプロジェクトにおいて、CMake スクリプトが多くのコンパイル時の警告を抑制しており、その中に以下の警告情報が含まれています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/root/pstack/main.cpp: In function ‘int test()’:
/root/pstack/main.cpp:7:1: warning: no return statement in function returning non-void [-Wreturn-type]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この警告は、&lt;code&gt;test()&lt;/code&gt; 関数が戻り値を持たないことを示しており、これがまさに問題の原因です。GCC の高バージョン（例：8.5.0）では、コードを最適化する際にこのような未定義の動作に対して不安定な最適化を行う可能性があり、プログラムがクラッシュする原因となることがあります。&lt;/p&gt;
&lt;h3 id=&#34;어셈블리-코드-차이점&#34;&gt;어셈블리 코드 차이점
&lt;/h3&gt;&lt;p&gt;GCC 컴파일러 최적화 동작의 차이를 설명하기 위해, 서로 다른 버전의 GCC가 생성한 어셈블리 코드를 비교했습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GCC 4.8.5 생성된 어셈블리 코드:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;어셈블리 코드가 다소 길고 표준 출력 스트림(예: &lt;code&gt;std::cout&lt;/code&gt;) 처리에 대한 로직을 포함하고 있습니다. 이는 컴파일러가 &lt;code&gt;test()&lt;/code&gt; 함수에서 누락된 반환 값 문제에 대해 과도하게 최적화하지 않았음을 나타내며, 이로 인해 잠재적으로 충돌을 피했을 수 있음을 시사합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GCC 8.5.0 생성된 어셈블리 코드:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;새로운 버전의 GCC는 더 많은 최적화를 수행하여 코드 양을 줄였습니다. 그러나 이러한 최적화가 누락된 반환 값을 갖는 함수의 실행 시 동작이 불확실하게 되어 프로그램 충돌을 유발할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;結論&#34;&gt;結論
&lt;/h3&gt;&lt;p&gt;今回の問題解決を通して、C++において&lt;strong&gt;関数が返す値は明確に定義されるべきである&lt;/strong&gt;という点を深く認識しました。特に、関数を&lt;code&gt;int&lt;/code&gt;型として宣言する場合、必ず戻り値を提示する必要があります。古いコンパイラ版を使用しているプロジェクトでGCCの新しいバージョンにアップグレードした場合、より多くの最適化や厳格な警告メカニズムが導入される可能性があります。そのため、コンパイル時に&lt;strong&gt;すべての警告を無効化しない&lt;/strong&gt;ことを推奨します。代わりに、関数が返す値、型の一致など、一般的な問題に対して選択的に対処する必要があります。
最終的に、&lt;code&gt;test()&lt;/code&gt;関数に戻り値を付与することで問題は解決し、プログラムは正常に動作するようになりました。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>VMware仮想マシンのCPUリソース使用率異常</title>
        <link>https://ttf248.life/ja/p/vmware-virtual-machine-cpu-usage-anomaly/</link>
        <pubDate>Sun, 10 Mar 2024 22:14:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/vmware-virtual-machine-cpu-usage-anomaly/</guid>
        <description>&lt;p&gt;背景：ローカルマシンにデプロイされたWindows版の業務システムで、CPU使用率が約5％です。VMwareにインストールしたCentOS8上にLinux版の業務システムをデプロイし、リソース使用量に異常が見られます。&lt;/p&gt;
&lt;h2 id=&#34;問題の記述&#34;&gt;問題の記述
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;宿主机：win10 企业版&lt;/li&gt;
&lt;li&gt;VMware：17.5&lt;/li&gt;
&lt;li&gt;仮想マシン：centos8
仮想マシンのリソース配分は&lt;code&gt;4C8GB&lt;/code&gt;で、ビジネスシステムを起動します。ビジネスシステムが仮想マシンLinuxシステムにデプロイされており、仮想マシン内部のtopコマンドでシステムのリソース使用率を確認すると、CPU使用率は高くありません。しかし、外側のWindowsシステムでタスクマネージャーを見ると、CPUリソース使用率は非常に高くなっています。プロセスを確認すると、VMware プロセスがCPUリソースを大量に使用しています。
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+
|         Windows           |
|                           |
|   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+  |
|   |      VMware        |  |
|   |      Program       |  |
|   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+  |
|                           |
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;知識点&#34;&gt;知識点
&lt;/h2&gt;&lt;p&gt;この問題のトラブルシューティングは、スムーズに進まず、原因はビジネスシステム自体ではなく、仮想マシンの問題にある。通常のビジネスコードからの思考を、システム負荷に転換し、さらに負荷データの異常から、スワップ中断へと追跡し、最終的に重要なポイントにたどり着くには、VMwareのスワップ中断のパフォーマンスに影響を与えるものは何か？ 本稿ではまず各知識点を解説し、最後に解決策を示す。&lt;/p&gt;
&lt;h3 id=&#34;hyper-v&#34;&gt;Hyper-V
&lt;/h3&gt;&lt;p&gt;Windowsオペレーティングシステムの仮想化技術において、大きな変革がありました。Microsoftが最初にWSL（Windows Subsystem for Linux）をリリースした際、Hyper-Vサービスを有効にすると、VMware仮想マシンの同時使用ができなくなっていました。その後、バージョンアップにより、VMwareはHyper-Vサービスと互換性を持つようになりました。&lt;/p&gt;
&lt;h3 id=&#34;システム負荷&#34;&gt;システム負荷
&lt;/h3&gt;&lt;p&gt;Linuxシステムにおいて、「負荷」（load）とは、実行中または実行を待っているプロセスの数です。負荷は通常、1分間、5分間、および15分間の実行キュー内の平均プロセス数を表す3つの数字で示されます。これらの数字は、「uptime」コマンドまたは「top」コマンドを実行することで確認できます。&lt;/p&gt;
&lt;p&gt;具体的には、この3つの数字はそれぞれ以下の意味を持ちます。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;1分負荷&lt;/strong&gt;: システムが過去1分間に実行キュー内に存在していた平均プロセス数です。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;5分負荷&lt;/strong&gt;: システムが過去5分間に実行キュー内に存在していた平均プロセス数です。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;15分負荷&lt;/strong&gt;: システムが過去15分間に実行キュー内に存在していた平均プロセス数です。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;負荷の概念は、システム内で待っているプロセスの数です。この数値が高い場合、システムに多くのプロセスがCPUリソースを待機していることを意味し、システムが遅くなるか応答しなくなる可能性があります（ただし、負荷の高さとシステムの構成およびパフォーマンスによって異なります）。&lt;/p&gt;
&lt;p&gt;理想的には、負荷はシステムの論理CPU数の範囲内に保つことが望ましく、これによりシステムのパフォーマンスを最適化できます。負荷が継続的にCPU数を超過する場合、システム内のプロセスを分析して負荷の原因を特定し、適切な対策を講じることで、リソース割り当てを調整したり、プロセスの実行方法を最適化したりすることができます。&lt;/p&gt;
&lt;h3 id=&#34;負荷の分析---mpstat&#34;&gt;負荷の分析 - mpstat
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;mpstat&lt;/code&gt;コマンドは、個々のプロセッサまたは複数のプロセッサに関するさまざまな情報を報告するために使用されます。これには、平均負荷、CPU利用率、割り込み、コンテキストスイッチングなどが含まれます。&lt;code&gt;sysstat&lt;/code&gt;パッケージの一部として、&lt;code&gt;mpstat&lt;/code&gt;はシステムの負荷状況を分析するための非常に便利なツールです。以下に、&lt;code&gt;mpstat&lt;/code&gt;を使用して負荷を分析する手順を示します。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;sysstatのインストール:&lt;/strong&gt;
システムに&lt;code&gt;sysstat&lt;/code&gt;がインストールされていない場合は、使用しているシステムに適したパッケージマネージャを使用してインストールしてください。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;mpstatの実行:&lt;/strong&gt;
&lt;code&gt;mpstat&lt;/code&gt;コマンドを実行して、CPUの使用状況と負荷を確認します。デフォルトでは、&lt;code&gt;mpstat&lt;/code&gt;は1秒ごとにCPU利用率の平均値を表示します。出力頻度を調整するには、時間間隔を指定できます。たとえば、&lt;code&gt;mpstat -P ALL 2&lt;/code&gt;を使用して、毎秒1回&lt;code&gt;mpstat&lt;/code&gt;を実行し、&lt;code&gt;irq&lt;/code&gt;で割り込みの使用状況を確認します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;出力の分析:&lt;/strong&gt;
&lt;code&gt;mpstat&lt;/code&gt;の出力には、各プロセッサの利用率とシステムの平均負荷が含まれています。平均負荷と各プロセッサの利用率に特に注意してください。これにより、システムの負荷状況を理解できます。負荷が高い場合は、どのプロセスが原因であるかをさらに分析し、パフォーマンスボトルネックがないか確認します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;他のツールの併用:&lt;/strong&gt;
&lt;code&gt;mpstat&lt;/code&gt;に加えて、&lt;code&gt;sar&lt;/code&gt;、&lt;code&gt;pidstat&lt;/code&gt;、&lt;code&gt;iostat&lt;/code&gt;などのツールを使用して、システム全体のパフォーマンスを総合的に分析できます。複数のツールの出力を組み合わせることで、システムの負荷状況をより包括的に理解し、パフォーマンスの問題の根本原因を特定することができます。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;割り込み&#34;&gt;割り込み
&lt;/h3&gt;&lt;p&gt;本内容は詳細に説明しないため、過度な解説は省略します。
推奨: &lt;a class=&#34;link&#34; href=&#34;https://www.codedump.info/post/20200522-sgfap-softirq/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;アプリケーション開発者向けシステムガイド CPU編 - ソフトウェア割り込み&lt;/a&gt;
頻繁にソフトウェア割り込みをトリガーすると、システム負荷にも反映されます。&lt;/p&gt;
&lt;h2 id=&#34;問題のトラブルシューティング&#34;&gt;問題のトラブルシューティング
&lt;/h2&gt;&lt;p&gt;CPUのみから分析するだけでは問題の原因を特定できないため、システムに異常が発生しているのではないかと疑うべきでしょうか。おそらくLinuxオペレーティングシステムの負荷が高くなり、VMwareが過剰なCPUリソースを使用している可能性があります。&lt;code&gt;mpstat&lt;/code&gt;を使用してローカル仮想マシンを分析したところ、&lt;code&gt;irq&lt;/code&gt;の使用量が異常で、単一コアあたり25%近く占めており、正常時にはビジネスプロセス起動時に空転する場合、&lt;code&gt;irq&lt;/code&gt;の割合は約5%程度であるはずでした。&lt;/p&gt;
&lt;p&gt;グループ内の同僚の開発環境では、CentOS 7がVMware上でデプロイされており、リソース使用量は正常でした。一方、上海の開発環境では、VMware上にデプロイされていましたが、ホストマシンのCPUリソース状況を直接観察することはできませんでした。この時、当社は複数の変数に直面していました：VMware仮想マシン、Linuxオペレーティングシステム、GCCバージョン。&lt;/p&gt;
&lt;p&gt;そこでテスト環境を分析することにしました。深圳のテスト環境は物理マシン上にデプロイされており、低バージョンのGCCでコンパイルされたサービスを実行し、CentOS 8上で動作していました。興味深いことに、深圳環境では&lt;code&gt;irq&lt;/code&gt;の使用量は正常でした。&lt;/p&gt;
&lt;p&gt;GCCバージョンに関連する問題が原因である可能性を調査するために、高バージョンのGCCでコンパイルしたプログラムを深圳環境にデプロイしてテストしましたが、結果も正常でした。&lt;/p&gt;
&lt;p&gt;問題は徐々に明確になってきました。オペレーティングシステムに問題があるのではないかと疑い始めました。毕竟、CentOS 8はすでに公式サポートを受けていないためです。しかし、純粋なCentOS 7とCentOS 8を再デプロイしても問題は解決しませんでした。&lt;/p&gt;
&lt;p&gt;この時、当社は唯一の不確実要素、つまりVMware仮想マシンソフトウェアに疑念を抱くようになりました。突然、閃きが起こり、Hyper-V技術が以前有効になっていたものの、完全にシャットダウンされなかったのではないかと考えました。毕竟、ソフトウェア中断も仮想マシンソフトウェアを通じて実現されるためです。異なる仮想マシン仮想化技術にはバグが存在する可能性があります。これらの問題は深く考える価値があります。&lt;/p&gt;
&lt;h2 id=&#34;結論&#34;&gt;結論
&lt;/h2&gt;&lt;p&gt;マイクロソフト公式のマニュアルに従い、本機のHyper-Vサービスを完全に停止した後、VMwareがホストマシン上で正常に動作することが確認されました。これで問題はついに解決に至りました。当初述べたように、この経験は曲折で困難なものであり、包括的な分析と判断が必要でした。また、今回初めて問題を調査し、仮想マシンというレベルまで特定することができました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Disable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V-Hypervisor
bcdedit /set hypervisorlaunchtype off
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/application-management/virtualization-apps-not-work-with-hyper-v&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/application-management/virtualization-apps-not-work-with-hyper-v&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>C&#43;&#43;プログラミングにおける罠：`std::map`の誤用がプログラムをクラッシュさせることの詳細な解説</title>
        <link>https://ttf248.life/ja/p/cpp-programming-traps-std-map-crash-details/</link>
        <pubDate>Sun, 10 Mar 2024 22:03:06 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cpp-programming-traps-std-map-crash-details/</guid>
        <description>e&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;std::map&lt;/code&gt; は C++ 標準ライブラリにおける連想コンテナであり、キー（key）を昇順にソートして要素を格納し、効率的なキーワード検索機能を提供します。しかし、初心者開発者は &lt;code&gt;std::map&lt;/code&gt; の中括弧演算子 &lt;code&gt;[]&lt;/code&gt; の動作について理解不足なために困惑することがあります。実際には、&lt;code&gt;[]&lt;/code&gt; を使用して存在しないキーにアクセスすると、&lt;code&gt;std::map&lt;/code&gt; は新しいキー値ペアを挿入し、デフォルトコンストラクタを使用してそのキーに対応する値の型を初期化します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int main() {
    std::map&amp;lt;std::string, int&amp;gt; myMap;

    // 誤った使い方：存在しないキーにアクセスし、0 が返ると仮定する
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for &#39;nonexistent_key&#39;: &amp;quot; &amp;lt;&amp;lt; myMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;

    // 実際には、上記の行は新しいキー値ペアを作成し、その値を int のデフォルト値（通常は 0）で初期化します。
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このコードは直接プログラムをクラッシュさせませんが、このような暗黙的な挿入動作は、リソースリークや予期しない状態の変更など、いくつかの状況で意図しない副作用を引き起こす可能性があります。さらに悪いことに、マルチスレッド環境での未初期化メモリ領域への同時アクセスにより、プログラムがクラッシュする可能性もあります。&lt;/p&gt;
&lt;p&gt;これらの問題を回避するために、&lt;code&gt;std::map::find()&lt;/code&gt; または &lt;code&gt;std::map::count()&lt;/code&gt; メソッドを使用してキーの存在を確認するか、&lt;code&gt;std::map::insert()&lt;/code&gt; を使用して明示的に要素を挿入することをお勧めします。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::map&amp;lt;std::string, int&amp;gt; safeMap;
if (safeMap.count(&amp;quot;nonexistent_key&amp;quot;) == 0) {
    std::cout &amp;lt;&amp;lt; &amp;quot;Key does not exist.&amp;quot; &amp;lt;&amp;lt; std::endl;
} else {
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for existing key: &amp;quot; &amp;lt;&amp;lt; safeMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;
}

// または、キーと値を明示的に挿入する
safeMap.insert({ &amp;quot;new_key&amp;quot;, 0 });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;マップコンテナ内のオブジェクトがポインタ型の場合、暗黙的な挿入動作は未初期化のポインタを保存し、そのポインタへの呼び出しはプログラムのクラッシュにつながります。&lt;/p&gt;</description>
        </item>
        <item>
        <title>pstack でプロセスがフリーズしている原因を調査する</title>
        <link>https://ttf248.life/ja/p/pstack-troubleshooting-process-hangs/</link>
        <pubDate>Sat, 24 Feb 2024 23:55:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/pstack-troubleshooting-process-hangs/</guid>
        <description>&lt;p&gt;ソフトウェア開発および運用において、プロセスがフリーズしてしまう状況は頻繁に発生します。この状態はシステム性能の低下やサービスの停止を引き起こす可能性があります。本稿では、pstackツールを使用してプロセスフリーズの問題を診断する方法について解説します。プロセスのスタック情報を分析することで、問題の原因を特定し解決策を見つけ出すことができます。&lt;/p&gt;
&lt;p&gt;背景：リスク管理システムの子サービスでフリーズが発生し、リスク管理サービスが利用不可となりました。可用性監視の欠如により、プロセスフリーズの状態を早期に検知することができず、システム全体が停止するという事態に至りました。&lt;/p&gt;
&lt;h2 id=&#34;本文&#34;&gt;本文
&lt;/h2&gt;&lt;p&gt;プロセスのフォジー（ゾンビプロセス）とは、プロセスが応答を停止しているにもかかわらず、終了していない状態を指します。この状況は、デッドロック、リソースの枯渇、例外など、さまざまな原因によって引き起こされる可能性があります。これらの問題に対処するためには、&lt;code&gt;pstack&lt;/code&gt; ツールを使用してプロセスのスタック情報を分析し、根本原因を特定することができます。&lt;/p&gt;
&lt;h2 id=&#34;ステップ&#34;&gt;ステップ
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;pstack&lt;/code&gt; は一般的なツールで、通常は &lt;code&gt;gdb&lt;/code&gt; (GNU デバッガ) と共に提供されます。以下のコマンドでインストールできます：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt-get install gdb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;プロセスのIDを取得する: まず、スタックされたプロセスのプロセスID (PID) を取得する必要があります。&lt;code&gt;ps&lt;/code&gt; コマンドを使用してすべてのプロセスをリストし、調査対象のプロセスIDを見つけます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pstack&lt;/code&gt; ツールを使ってプロセスのスタック情報を分析します。プロセスIDを取得したら、以下のコマンドを実行してスタック情報を取得できます：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pstack &amp;lt;PID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これにより、現在の呼び出しシーケンスで実行中の関数が示されたプロセスのスタック情報が出力されます。この情報を分析することで、プロセスが停止した場所を特定し、問題の診断に役立てることができます。&lt;/p&gt;
&lt;p&gt;スタック情報を分析する: スタック情報を確認することで、プロセスがスタック状に停止している原因を見つけることができます。ロックによる競合状態、無限ループ、またはその他の異常な状況などが見つかる可能性があります。具体的な状況に応じて、適切な対策（ロックの解放、コードロジックの修正など）を講じてください。&lt;/p&gt;
&lt;h2 id=&#34;実行例&#34;&gt;実行例
&lt;/h2&gt;&lt;p&gt;簡単なデモで、&lt;code&gt;main&lt;/code&gt;関数が起動した後、新しいスレッドを作成し、実際の関数を実行することで無限ループに陥り、プログラムが正常に終了できず、偽の停止状態になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cmake_minimum_required(VERSION 3.0.0)
project(pstack_main VERSION 0.1.0 LANGUAGES C CXX)

include(CTest)
enable_testing()

# スレッドライブラリを検索
find_package(Threads REQUIRED)

add_executable(pstack_main main.cpp)

# スレッドライブラリへのリンク
target_link_libraries(pstack_main PRIVATE Threads::Threads)

set(CPACK_PROJECT_NAME ${PROJECT_NAME})
set(CPACK_PROJECT_VERSION ${PROJECT_VERSION})
include(CPack)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;
#include &amp;lt;chrono&amp;gt;

void infiniteLoop() {
    while (true) {
        // メインスレッドが無限ループに陥る
    }
}

int main() {
    std::thread thread(infiniteLoop); // 無限ループを実行する関数を持つスレッドを作成
    thread.join(); // スレッドの終了を待つ
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;プログラムを実行し、&lt;code&gt;pstack&lt;/code&gt;の結果を確認します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Thread 2 (Thread 0x7eff3619b700 (LWP 1315017)):
#0  infiniteLoop () at /root/pstack/main.cpp:6
#1  0x0000000000402ca9 in std::__invoke_impl&amp;lt;void, void (*)()&amp;gt; (__f=@0x2260eb8: 0x4029a6 &amp;lt;infiniteLoop()&amp;gt;) at /usr/include/c++/8/bits/invoke.h:60
#2  0x0000000000402b02 in std::__invoke&amp;lt;void (*)()&amp;gt; (__fn=@0x2260eb8: 0x4029a6 &amp;lt;infiniteLoop()&amp;gt;) at /usr/include/c++/8/bits/invoke.h:95
#3  0x0000000000403150 in std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt;::_M_invoke&amp;lt;0ul&amp;gt; (this=0x2260eb8) at /usr/include/c++/8/thread:244
#4  0x0000000000403126 in std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt;::operator() (this=0x2260eb8) at /usr/include/c++/8/thread:253
#5  0x000000000040310a in std::thread::_State_impl&amp;lt;std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt; &amp;gt;::_M_run (this=0x2260eb0) at /usr/include/c++/8/thread:196
#6  0x00007eff36bceb23 in execute_native_thread_routine () from /lib64/libstdc++.so.6
#7  0x00007eff36ea91ca in start_thread () from /lib64/libpthread.so.0
#8  0x00007eff361d58d3 in clone () from /lib64/libc.so.6
Thread 1 (Thread 0x7eff372e1740 (LWP 1315016)):
#0  0x00007eff36eaa6cd in __pthread_timedjoin_ex () from /lib64/libpthread.so.0
#1  0x00007eff36bceda7 in std::thread::join() () from /lib64/libstdc++.so.6
#2  0x00000000004029d2 in main () at /root/pstack/main.cpp:13
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;プロセスが偽の停止状態になっているのは、無限ループに入っているためで、メイン&lt;/p&gt;
</description>
        </item>
        <item>
        <title>C&#43;&#43;関数呼び出しのオーバーヘッド時間 / 関数呼び出し時のパフォーマンスに関する問題</title>
        <link>https://ttf248.life/ja/p/cpp-function-call-timing/</link>
        <pubDate>Wed, 24 Jan 2024 14:11:33 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cpp-function-call-timing/</guid>
        <description>&lt;p&gt;設計行情 SDK、針對不同的回呼函數實現方式，進行了一次耗時的測試。近期在看 C++ 函數編程，當函數變成了一等公民，在程式內部流轉，耗時有什么不同？&lt;/p&gt;
&lt;p&gt;前文連結：&lt;a class=&#34;link&#34; href=&#34;https://ttf248.life/ja/p/compiler-callback-performance-testing/&#34; &gt;编译器、回调函数、性能测试&lt;/a&gt;
&lt;code&gt;leimao&lt;/code&gt; 大佬刚好也做了类似的測試，借代码一用。&lt;/p&gt;
&lt;h2 id=&#34;本文&#34;&gt;本文
&lt;/h2&gt;&lt;p&gt;実行プラットフォームは引き続き、当社の旧友である &lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt; です。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;cassert&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

int add_one(int input) { return input + 1; }

bool validate_vector_add_one(std::vector&amp;lt;int&amp;gt; const&amp;amp; input_vector,
                             std::vector&amp;lt;int&amp;gt; const&amp;amp; output_vector)
{
    bool is_valid{true};
    for (size_t i{0}; i &amp;lt; input_vector.size(); ++i)
    {
        if (output_vector.at(i) != input_vector.at(i) + 1)
        {
            is_valid = false;
            break;
        }
    }
    return is_valid;
}

void reset_vector(std::vector&amp;lt;int&amp;gt;&amp;amp; input_vector)
{
    for (size_t i{0}; i &amp;lt; input_vector.size(); ++i)
    {
        input_vector.at(i) = 0;
    }
}

template &amp;lt;typename T, typename Func&amp;gt;
void unitary_function_pass_by_lambda_function(T&amp;amp; output, T const&amp;amp; input,
                                              Func const func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_std_function_value(T&amp;amp; output, T const&amp;amp; input,
                                                 std::function&amp;lt;T(T)&amp;gt; const func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_std_function_reference(
    T&amp;amp; output, T const&amp;amp; input, std::function&amp;lt;T(T)&amp;gt; const&amp;amp; func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_function_pointer(T&amp;amp; output, T const&amp;amp; input,
                                               T (*func)(T))
{
    output = func(input);
}

int main()
{
    // Set floating point format std::cout with 3 decimal places.
    std::cout.precision(3);

    size_t const num_elements{10000000};
    std::vector&amp;lt;int&amp;gt; input_vector(num_elements, 0);
    std::vector&amp;lt;int&amp;gt; output_vector(num_elements, 0);

    auto const lambda_function_add_one{[](int const&amp;amp; input) -&amp;gt; int
                                       { return input + 1; }};
    std::function&amp;lt;int(int)&amp;gt; const std_function_add_one{lambda_function_add_one};

    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a function pointer: &amp;quot; &amp;lt;&amp;lt; sizeof(&amp;amp;add_one)
              &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a std::function pointer: &amp;quot;
              &amp;lt;&amp;lt; sizeof(&amp;amp;std_function_add_one) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a std::function: &amp;quot; &amp;lt;&amp;lt; sizeof(std_function_add_one)
              &amp;lt;&amp;lt; std::endl;

    // Call function frequently in a vanilla way.
    // The compiler knows what function to call at compile time and can optimize
    // the code.
    // This is the best performance we could get.
    std::chrono::steady_clock::time_point const time_start_vanilla{
        std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        output_vector.at(i) = add_one(input_vector.at(i));
    }
    std::chrono::steady_clock::time_point const time_end_vanilla{
        std::chrono::steady_clock::now()};
    auto const time_elapsed_vanilla{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(time_end_vanilla -
                                                             time_start_vanilla)
            .count()};
    float const latency_vanilla{time_elapsed_vanilla /
                                static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass Vanilla: &amp;quot; &amp;lt;&amp;lt; latency_vanilla &amp;lt;&amp;lt; &amp;quot; ns&amp;quot;
              &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector

## 正文
// 時々、コンパイル時に呼び出す関数を知らない場合があります。
// `std::function` を使用して、関数を引数として渡すことができます。
// この場合は、`std::function` を値で渡します。
// `std::function` のサイズが 32 バイトであるため、値を渡すと多くのコピーが発生し、パフォーマンスが悪くなります。
std::chrono::steady_clock::time_point const
    time_start_pass_by_std_function_value{std::chrono::steady_clock::now()};
for (size_t i{0}; i &amp;lt; num_elements; ++i)
{
    unitary_function_pass_by_std_function_value(
        output_vector.at(i), input_vector.at(i), std_function_add_one);
}
std::chrono::steady_clock::time_point const
    time_end_pass_by_std_function_value{std::chrono::steady_clock::now()};
auto const time_elapsed_pass_by_std_function_value{
    std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
        time_end_pass_by_std_function_value -
        time_start_pass_by_std_function_value)
        .count()};
float const latency_pass_by_std_function_value{
    time_elapsed_pass_by_std_function_value /
    static_cast&amp;lt;float&amp;gt;(num_elements)};
std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Std Function Value: &amp;quot;
          &amp;lt;&amp;lt; latency_pass_by_std_function_value &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
assert(validate_vector_add_one(input_vector, output_vector));
reset_vector(output_vector);

// `std::function` を値で渡す代わりに、参照（ポインタ）で渡すこともできます。
// この場合、オブジェクトのコピーは排除されます。パフォーマンスは、`std::function` を値で渡した場合よりも優れています。
// ただし、ワイルドな方法ほどではありません。
std::chrono::steady_clock::time_point const
    time_start_pass_by_std_function_reference{
        std::chrono::steady_clock::now()};
for (size_t i{0}; i &amp;lt; num_elements; ++i)
{
    unitary_function_pass_by_std_function_reference(
        output_vector.at(i), input_vector.at(i), std_function_add_one);
}
std::chrono::steady_clock::time_point const
    time_end_pass_by_std_function_reference{
        std::chrono::steady_clock::now()};
auto const time_elapsed_pass_by_std_function_reference{
    std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
        time_end_pass_by_std_function_reference -
        time_start_pass_by_std_function_reference)
        .count()};
float const latency_pass_by_std_function_reference{
    time_elapsed_pass_by_std_function_reference /
    static_cast&amp;lt;float&amp;gt;(num_elements)};
std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Std Function Reference: &amp;quot;
          &amp;lt;&amp;lt; latency_pass_by_std_function_reference &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
assert(validate_vector_add_one(input_vector, output_vector));
reset_vector(output_vector);

## 本文
// `std::function` は、関数ポインタ、呼び出し可能オブジェクト、ラムダ関数をラップする汎用的なものです。
// 汎用性があるため、関数ポインタほど効率的ではありません。この場合は、関数ポインタを関数に渡します。
// `std::function` を参照で渡すよりもパフォーマンスが優れています。
std::chrono::steady_clock::time_point const time_start_pass_by_function_pointer{std::chrono::steady_clock::now()};
for (size_t i{0}; i &amp;lt; num_elements; ++i)
{
    unitary_function_pass_by_function_pointer(output_vector.at(i),
                                                  input_vector.at(i), &amp;amp;add_one);
}
std::chrono::steady_clock::time_point const time_end_pass_by_function_pointer{std::chrono::steady_clock::now()};
auto const time_elapsed_pass_by_function_pointer{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_function_pointer -
            time_start_pass_by_function_pointer)
            .count()};
float const latency_pass_by_function_pointer{
        time_elapsed_pass_by_function_pointer /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Function Pointer: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_function_pointer &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
assert(validate_vector_add_one(input_vector, output_vector));
reset_vector(output_vector);

// ラムダ関数を関数に渡すこともできます。
// コンパイラは、コンパイル時に呼び出す関数を知っており、コードを最適化できます。
// `std::function` を参照で渡すよりもパフォーマンスも優れています。
std::chrono::steady_clock::time_point const time_start_pass_by_lambda_function{std::chrono::steady_clock::now()};
for (size_t i{0}; i &amp;lt; num_elements; ++i)
{
    unitary_function_pass_by_lambda_function(
        output_vector.at(i), input_vector.at(i), lambda_function_add_one);
}
std::chrono::steady_clock::time_point const time_end_pass_by_lambda_function{std::chrono::steady_clock::now()};
auto const time_elapsed_pass_by_lambda_function{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_lambda_function -
            time_start_pass_by_lambda_function)
            .count()};
float const latency_pass_by_lambda_function{
        time_elapsed_pass_by_lambda_function /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Lambda Function: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_lambda_function &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
assert(validate_vector_add_one(input_vector, output_vector));
reset_vector(output_vector);

## 本文

```shell
# チーム全体の最適化 (O2) を有効にし、コンパイルには gcc13 を選択しました。gcc のバージョンが異なる場合、性能と時間の違いはわずかに異なりますが、バージョンが高いほど lambda の効果が良いです。
関数のポインタのサイズ: 8 バイト
std::function ポインタのサイズ: 8 バイト
std::function オブジェクトのサイズ: 32 バイト
Vanilla パスのレイテンシ: 0.418 ns
std::function 値でパスするレイテンシ: 3.47 ns
std::function リファレンスでパスするレイテンシ: 1.36 ns
ポインタで関数をパスするレイテンシ: 0.396 ns
ラムダ関数でパスするレイテンシ: 0.44 ns
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leimao.github.io/blog/CPP-Function-Call-Performance/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://leimao.github.io/blog/CPP-Function-Call-Performance/&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>プログラムのデバッグを防止する方法</title>
        <link>https://ttf248.life/ja/p/program-anti-debug/</link>
        <pubDate>Tue, 23 Jan 2024 19:46:36 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/program-anti-debug/</guid>
        <description>&lt;p&gt;心血を注ぎ、新しい壁紙を探し求めた。習慣は黒系の壁紙だが、一部の領域には色を加えても良いだろう。デスクトップにはアイコンを配置する必要があるため、他の色系が壁紙だとアイコンが不明瞭になってしまう。&lt;/p&gt;
&lt;p&gt;上記のコードを睨めつけ、理解できずにいた。AIに投げかけて説明したが、状況を説明していなかったのだ。それは特定の状況下で使われる指示であり、通常のコードではこのような形ではない。&lt;/p&gt;
&lt;p&gt;AIは今や検索エンジンには及ばない。アセンブリの知識が不足している。&lt;/p&gt;
&lt;h2 id=&#34;壁紙&#34;&gt;壁紙
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/program-anti-debug/Snipaste_2024-01-23_19-50-53.png&#34;
	width=&#34;1020&#34;
	height=&#34;470&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;黒色のアセンブル壁紙&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;217&#34;
		data-flex-basis=&#34;520px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;彙集コード&#34;&gt;彙集コード
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;PUSHFD
MOV DWORD PTR [ESP],0X100
POPFD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;実用例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool IsDebugged()
{
    __try
    {
        __asm
        {
            pushfd
            mov dword ptr [esp], 0x100
            popfd
            nop
        }
        return true;
    }
    __except(GetExceptionCode() == EXCEPTION_SINGLE_STEP
        ? EXCEPTION_EXECUTE_HANDLER
        : EXCEPTION_CONTINUE_EXECUTION)
    {
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;彙編コード&#34;&gt;彙編コード
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;PUSHFD&lt;/code&gt; および &lt;code&gt;POPFD&lt;/code&gt; は、フラグレジスタの値をスタックにプッシュおよびポップする命令です。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MOV DWORD PTR [ESP], 0X100&lt;/code&gt; は、スタックポインタ (&lt;code&gt;ESP&lt;/code&gt;) のアドレスにある4バイト（DWORD）領域に &lt;code&gt;0x100&lt;/code&gt; の値を移動する命令です。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nop&lt;/code&gt; は、何もしない命令です。デバッグやテストのために使用されることがあります。&lt;/p&gt;
&lt;h3 id=&#34;実用例&#34;&gt;実用例
&lt;/h3&gt;&lt;p&gt;このコードは、デバッグモードでプログラムが実行されているかどうかを判断します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;__try&lt;/code&gt; ブロック内でアセンブリコードを実行し、例外が発生した場合に &lt;code&gt;__except&lt;/code&gt; ブロックが実行されます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GetExceptionCode() == EXCEPTION_SINGLE_STEP&lt;/code&gt; は、プログラムがシングルステップモードで実行されているかどうかを確認します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;EXCEPTION_EXECUTE_HANDLER&lt;/code&gt; および &lt;code&gt;EXCEPTION_CONTINUE_EXECUTION&lt;/code&gt; は、それぞれハンドラを実行するか、実行の継続を許可する例外コードです。&lt;/p&gt;
&lt;p&gt;この例では、プログラムがシングルステップモードで実行されている場合、&lt;code&gt;true&lt;/code&gt; が返されます。それ以外の場合は、&lt;code&gt;false&lt;/code&gt; が返されます。&lt;/p&gt;
&lt;h2 id=&#34;説明&#34;&gt;説明
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;TrapFlag&lt;/code&gt;はレジスタフラグ領域内のフラグであり、このフラグが設定されると、&lt;code&gt;SINGLE_STEP&lt;/code&gt;例外が発生します。なぜなら、デバッガーでコードをトレースしている場合、このフラグはデバッガーによってリセットされ、その例外を捕捉できないからです。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;実際のテストでは、直接ステップオーバーしてデバッグ対象の関数を実行すると、デバッグが検出されないことがわかります。例外は、その関数にエントリする実行時のみ検出されます（資料参照、未検証）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献
&lt;/h2&gt;&lt;p&gt;中国語の関連資料は、すべてウェブサイトの英文稿を翻訳したものです。このサイトでは、さまざまな反调试技術について解説しています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://anti-debug.checkpoint.com/techniques/assembly.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://anti-debug.checkpoint.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://song-10.gitee.io/2021/08/08/Reverse-2021-08-08-anti-debug/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://song-10.gitee.io/2021/08/08/Reverse-2021-08-08-anti-debug/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>焦点访談/CCTV動画ファイルのダウンロード方法</title>
        <link>https://ttf248.life/ja/p/how-to-download-focus-interview-cctv-videos/</link>
        <pubDate>Tue, 23 Jan 2024 19:23:35 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/how-to-download-focus-interview-cctv-videos/</guid>
        <description>&lt;p&gt;最近、有人相談してきて、焦点访谈の動画をダウンロードする方法を聞かれたんだけど、頭の中で考えていたのは、おそらくまた &lt;code&gt;m3u8&lt;/code&gt; 形式で暗号化されているだろうという考えだったんだ。ちょっと手軽に処理してみようか。&lt;/p&gt;
&lt;h2 id=&#34;ダウンローダー&#34;&gt;ダウンローダー
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/nilaoda/N_m3u8DL-CLI&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/nilaoda/N_m3u8DL-CLI&lt;/a&gt;
&lt;code&gt;m3u8 downloader&lt;/code&gt; のオープンソース 命令行 m3u8/HLS/dash ダウンローダーです。普通 AES-128-CBC 解密、マルチスレッド、カスタムリクエストヘッダなどをサポートしています。简体中文、繁体中文、英語に対応しています。English Supported.&lt;/p&gt;
&lt;h2 id=&#34;ブラウザ拡張機能&#34;&gt;ブラウザ拡張機能
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://microsoftedge.microsoft.com/addons/detail/ngjclnbcdbahekojpkhancmiobdahemb&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Live Stream Downloader&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;蜜汁自信&#34;&gt;蜜汁自信
&lt;/h2&gt;&lt;p&gt;アドレスを取得し、これで片付くと思ったが、結果は何もかも役に立たない。正常にセグメント内容を解析したり、資料を検索したりすることができなかった。公式がダウンロードアドレスを処理しており、ある程度の置換を手動で行う必要があることを発見した。プラグインで解析された &lt;code&gt;key&lt;/code&gt; を以下のリンクに手動でコピー＆置き換えなければならない。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;https://newcntv.qcloudcdn.com/asp/hls/2000/0303000a/3/default/***********************/2000.m3u8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2024年1月現在、アドレスは有効。今後変更がある場合は、ウェブページを分析してご自身で判断してください。
過去のアドレスのバックアップ：&lt;code&gt;https://hlswx.cntv.kcdnvip.com/asp/hls/main/0303000a/3/default/一串字符/main.m3u8?maxbr=2000&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://jln.cn/post/517.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://jln.cn/post/517.html&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>SQL Serverデータベースのディスクファイルの権限を一括で変更する</title>
        <link>https://ttf248.life/ja/p/bulk-modify-sqlserver-database-disk-permissions/</link>
        <pubDate>Tue, 23 Jan 2024 19:06:36 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/bulk-modify-sqlserver-database-disk-permissions/</guid>
        <description>&lt;p&gt;会社セキュリティポリシーの調整により、&lt;code&gt;機械師 mini&lt;/code&gt;は最終的に自宅へ移転し、予備サーバーとして利用。同時にマシンシステムを再インストールし、&lt;code&gt;ubuntu&lt;/code&gt;が&lt;code&gt;windows server&lt;/code&gt;に切り替えられました。アクティベーション手段が不正であったため、自宅で使用しても問題ないように見えていましたが、実際にはアクティベーションができていないと様子がおかしくなりました。&lt;/p&gt;
&lt;p&gt;Microsoftによる検出がトリガーされ、通常稼働していたサーバーが起動から1時間で自動シャットダウン。システムログを徹底的に調査した結果、盗版であることに至りました。&lt;/p&gt;
&lt;p&gt;仕方なく再度システムを再インストールし、&lt;code&gt;SqlServer&lt;/code&gt;も再インストールする必要が生じました。毎回トラブルシューティングを行うと非常に面倒であり、ファイル権限管理が厳格であるため、データベースの追加が正常に行えませんでした。&lt;/p&gt;
&lt;h2 id=&#34;エラーメッセージ&#34;&gt;エラーメッセージ
&lt;/h2&gt;&lt;p&gt;システムを再インストールした後、&lt;code&gt;SqlServer&lt;/code&gt;がデータベースに接続しようとすると、オペレーティングシステムのアクセス拒否エラー5120が発生することがあります。&lt;/p&gt;
&lt;h2 id=&#34;処理スクリプト&#34;&gt;処理スクリプト
&lt;/h2&gt;&lt;p&gt;前文リンク：&lt;a class=&#34;link&#34; href=&#34;https://ttf248.life/ja/p/bulk-update-local-git-and-legacy-permissions/&#34; &gt;ローカルGitリポジトリの一括更新&lt;/a&gt;、やはりこの馴染み深いスクリプトだ。改造して、フォルダをトラバースしながらファイルの権限を変更し、現在のユーザーに完全な編集権限を与えるようにする。&lt;/p&gt;
&lt;p&gt;ネット上のチュートリアルはほとんどが手動で修正する方法を示しており、毎回数個のファイルだけ修正するのだろうか？ 私は毎回多数のファイルを処理する必要があり、すべてを手作業で処理すると、精神的に疲れてしまう。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$currentUserName = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8
$rootDirectory = &amp;quot;D:\data\2013_RujiaInfo&amp;quot;

Get-ChildItem -Path $rootDirectory -Recurse | ForEach-Object {
    $itemPath = $_.FullName

    if ($_ -is [System.IO.DirectoryInfo]) {
        $icaclsResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            Write-Host &amp;quot;フォルダ $itemPath の所有者を $currentUserName に変更しました&amp;quot;
            # 現在のユーザーに書き込み権限を付与
            Invoke-Expression &amp;quot;icacls `&amp;quot;$itemPath`&amp;quot; /grant `&amp;quot;$($currentUserName):(OI)(CI)F`&amp;quot;&amp;quot;
            Write-Host &amp;quot;$currentUserName がフォルダを編集するための権限が付与されました&amp;quot;
        } else {
            Write-Host &amp;quot;フォルダ $itemPath の所有者を変更できません。エラー情報: $icaclsResult&amp;quot;
        }
    } else {
        $takeownResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            # 現在のユーザーに書き込み権限を付与
            Invoke-Expression &amp;quot;icacls `&amp;quot;$itemPath`&amp;quot; /grant `&amp;quot;$($currentUserName):(F)`&amp;quot;&amp;quot;
            Write-Host &amp;quot;$currentUserName がファイルを編集するための権限が付与されました&amp;quot;
        } else {
            Write-Host &amp;quot;ファイル $itemPath の所有者を変更できません。エラー情報: $takeownResult&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Linuxシステムベンチマークテスト</title>
        <link>https://ttf248.life/ja/p/linux-system-benchmark-test/</link>
        <pubDate>Tue, 09 Jan 2024 10:56:23 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-system-benchmark-test/</guid>
        <description>&lt;p&gt;Windows 平台上有鲁大师（娱乐大师），不能说数据很准，但总归有个参考，当然也有其他的专业跑分软件。到了 Linux 系统，好像一直没遇到特别合适的跑分软件。&lt;/p&gt;
&lt;p&gt;Sysbench 是一款多功能的基准测试工具，可用于测试 CPU、内存、文件 I/O、线程性能等。您可以使用 Sysbench 来执行各种性能测试任务。&lt;/p&gt;
&lt;p&gt;手头上刚好有三台机器用于测试：机械师 mini 本地小主机、阿里云 dev 开发云服务器、华为云开发服务器。&lt;/p&gt;
&lt;h2 id=&#34;sysbench-のインストール&#34;&gt;Sysbench のインストール
&lt;/h2&gt;&lt;p&gt;ほとんどの Linux ディストリビューションでは、パッケージマネージャを使用して Sysbench をインストールできます。例えば、CentOS 8 では、次のコマンドを使用します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo dnf install sysbench
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sysbenchの使用例&#34;&gt;Sysbenchの使用例
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CPU性能のテスト: &lt;code&gt;sysbench --test=cpu run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;メモリ読み取り性能のテスト: &lt;code&gt;sysbench --test=memory run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ファイルI/O性能のテスト:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysbench --test=fileio --file-test-mode=rndrw prepare
sysbench --test=fileio --file-test-mode=rndrw run
sysbench --test=fileio --file-test-mode=rndrw cleanup
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;マルチスレッド性能のテスト: &lt;code&gt;sysbench --test=threads --num-threads=4 run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;MySQLデータベース性能のテスト（最大接続数を調整する必要あり）：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword --oltp-table-size=1000000 prepare
sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword --max-time=60 --oltp-read-only=off --oltp-test-mode=complex --max-requests=0 run
sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword cleanup
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ランニングデータレポート&#34;&gt;ランニングデータレポート
&lt;/h2&gt;&lt;meta http-equiv=&#34;Content-Type&#34; content=&#34;text/html; charset=utf-8&#34;&gt;&lt;link type=&#34;text/css&#34; rel=&#34;stylesheet&#34; href=&#34;resources/sheet.css&#34; &gt;
&lt;h2 id=&#34;実行データレポート&#34;&gt;実行データレポート
&lt;/h2&gt;&lt;style type=&#34;text/css&#34;&gt;.ritz .waffle a { color: inherit; }.ritz .waffle .s0{background-color:#ffffff;text-align:left;color:#000000;font-family:&#39;Arial&#39;;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}&lt;/style&gt;&lt;div class=&#34;ritz grid-container&#34; dir=&#34;ltr&#34;&gt;&lt;table class=&#34;waffle&#34; cellspacing=&#34;0&#34; cellpadding=&#34;0&#34;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th class=&#34;row-header freezebar-origin-ltr&#34;&gt;&lt;/th&gt;&lt;th id=&#34;0C0&#34; style=&#34;width:100px;&#34; class=&#34;column-headers-background&#34;&gt;A&lt;/th&gt;&lt;th id=&#34;0C1&#34; style=&#34;width:421px;&#34; class=&#34;column-headers-background&#34;&gt;B&lt;/th&gt;&lt;th id=&#34;0C2&#34; style=&#34;width:398px;&#34; class=&#34;column-headers-background&#34;&gt;C&lt;/th&gt;&lt;th id=&#34;0C3&#34; style=&#34;width:422px;&#34; class=&#34;column-headers-background&#34;&gt;D&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R0&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;1&lt;/div&gt;&lt;/th&gt;&lt;td&gt;&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;ローカル機械師&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;阿里云&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;华为云&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R1&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;2&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;システム構成&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;システム情報&lt;br&gt;  オペレーティングシステム              Ubuntu 23.04&lt;br&gt;  カーネル                        Linux 6.2.0-36-generic x86_64&lt;br&gt;  モデル                         Machenike Machenike DT Computer&lt;br&gt;  マザーボード                   Machenike Machenike DT Computer&lt;br&gt;  BIOS                          American Megatrends International, LLC.&lt;br&gt;DB19V012&lt;br&gt;&lt;br&gt;CPU情報&lt;br&gt;  名前                          Intel Core i7-12650H&lt;br&gt;  トポロジー                      1 プロセッサ、10 コア、16 スレッド&lt;br&gt;  識別子                    GenuineIntel Family 6 Model 154 Stepping 3&lt;br&gt;  ベース周波数                4.60 GHz&lt;br&gt;  L1 命令キャッシュ          32.0 KB x 8&lt;br&gt;  L1 データキャッシュ                 48.0 KB x 8&lt;br&gt;  L2 キャッシュ                      1.25 MB x 2&lt;br&gt;  L3 キャッシュ                      24.0 MB&lt;br&gt;&lt;br&gt;メモリ情報&lt;br&gt;  サイズ                          62.6 GB&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;システム情報&lt;br&gt;  オペレーティングシステム              CentOS Stream 8&lt;br&gt;  カーネル                        Linux 4.18.0-513.el8.x86_64 x86_64&lt;br&gt;  モデル                         Alibaba Cloud Alibaba Cloud ECS&lt;br&gt;  マザーボード                   N/A&lt;br&gt;  BIOS                          SeaBIOS 449e491&lt;br&gt;&lt;br&gt;CPU情報&lt;br&gt;  名前                          Intel(R) Xeon(R) Platinum&lt;br&gt;  トポロジー                      1 プロセッサ、1 コア、2 スレッド&lt;br&gt;  識別子                    GenuineIntel Family 6 Model 85 Stepping 4&lt;br&gt;  ベース周波数                2.50 GHz&lt;br&gt;  L1 命令キャッシュ          32.0 KB&lt;br&gt;  L1 データキャッシュ                 32.0 KB&lt;br&gt;  L2 キャッシュ                      1.00 MB&lt;br&gt;  L3 キャッシュ                      33.0 MB&lt;br&gt;&lt;br&gt;メモリ情報&lt;br&gt;  サイズ                          1.65 GB&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;システム情報&lt;br&gt;  オペレーティングシステム              Ubuntu 22.04.1 LTS&lt;br&gt;  カーネル                        Linux 5. - 64 GB
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;実行データレポート
system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;テストの実行方法：指定されたオプションで&lt;br&gt;スレッド数: 1&lt;br&gt;乱数ジェネレーターを現在の時間から初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;素数の制限: 10000&lt;br&gt;&lt;br&gt;ワーカーのスレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドが開始されました!&lt;br&gt;&lt;br&gt;CPU速度:&lt;br&gt;    毎秒イベント数: 4032.48&lt;br&gt;&lt;br&gt;一般的な統計情報:&lt;br&gt;    合計時間: 10.0004秒&lt;br&gt;    イベントの総数: 40330&lt;br&gt;&lt;br&gt;遅延 (ms):&lt;br&gt;         最小値: 0.25&lt;br&gt;         平均値: 0.25&lt;br&gt;         最大値: 0.73&lt;br&gt;         95パーセンタイル: 0.25&lt;br&gt;         合計: 9997.55&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント (平均/標準偏差): 40330.0000/0.00&lt;br&gt;    実行時間 (平均/標準偏差): 9.9975/0.00&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;データマイニング&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ディープラーニング&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ニューラルネットワーク - 実行データレポート
system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;テストの実行方法：指定されたオプションで&lt;br&gt;スレッド数: 1&lt;br&gt;乱数ジェネレーターを現在の時間から初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;素数の制限: 10000&lt;br&gt;&lt;br&gt;ワーカーのスレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドが開始されました!&lt;br&gt;&lt;br&gt;CPU速度:&lt;br&gt;    毎秒イベント数: 4032.48&lt;br&gt;&lt;br&gt;一般的な統計情報:&lt;br&gt;    合計時間: 10.0004秒&lt;br&gt;    合計イベント数: 40330&lt;br&gt;&lt;br&gt;遅延 (ms):&lt;br&gt;         最小: 0.25&lt;br&gt;         平均: 0.25&lt;br&gt;         最大: 0.73&lt;br&gt;         95パーセンタイル: 0.25&lt;br&gt;         合計: 9997.55&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント (平均/標準偏差): 40330.0000/0.00&lt;br&gt;    実行時間 (平均/標準偏差): 9.9975/0.00&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sysbench 1.0.20 (system LuaJIT 2.1.0-beta3を使用)&lt;br&gt;&lt;br&gt;テストの実行方法：指定されたオプションで&lt;br&gt;スレッド数: 1&lt;br&gt;乱数ジェネレーターを現在の時間から初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;素数の制限: 10000&lt;br&gt;&lt;br&gt;ワーカーのスレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドが開始されました!&lt;br&gt;&lt;br&gt;CPU速度:&lt;br&gt;    毎秒イベント数: 1062.51&lt;br&gt;&lt;br&gt;一般的な統計情報:&lt;br&gt;    合計時間: 10.0008秒&lt;br&gt;    合計イベント数: 10628&lt;br&gt;&lt;br&gt;遅延 (ms):&lt;br&gt;         最小: 0.91&lt;br&gt;         平均: 0.94&lt;br&gt;         最大: 22.84&lt;br&gt;         95パーセンタイル: 1.06&lt;br&gt;         合計: 9993.46&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント (平均/標準偏差): 10628.0000/0.00&lt;br&gt;    実行時間 (平均/標準偏差): 9.9935/0.00&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sysbench 1.0.20 (system LuaJIT 2.1.0-beta3を使用)&lt;br&gt;&lt;br&gt;テストの実行方法：指定されたオプションで&lt;br&gt;スレッド数: 1&lt;br&gt;乱数ジェネレーターを現在の時間から初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;素数の制限: 10000&lt;br&gt;&lt;br&gt;ワーカーのスレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドが開始されました!&lt;br&gt;&lt;br&gt;CPU速度:&lt;br&gt;    毎秒イベント数: 1125.56&lt;br&gt;&lt;br&gt;一般的な統計情報:&lt;br&gt;    合計時間: 10.0005秒&lt;br&gt;    合計イベント数: 11258&lt;br&gt;&lt;br&gt;遅延 (ms):&lt;br&gt;         最小: 0.86&lt;br&gt;         平均: 0.89&lt;br&gt;         最大: 1.70&lt;br&gt;         95パーセンタイル: 0.99&lt;br&gt;         合計: 9995.40&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント (平均/標準偏差): 11258.0000/0.00&lt;br&gt;    実行時間 (平均/標準偏差): 9.9954/0.00&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;メモリテストを実行するオプション：指定されたオプションで&lt;br&gt;ブロックサイズ: 1KiB&lt;br&gt;合計サイズ: 102400MiB&lt;br&gt;操作: 書き込み&lt;br&gt;範囲: グローバル&lt;br&gt;&lt;br&gt;ワーカーのスレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドが開始されました!&lt;br&gt;&lt;br&gt;総イベント数: 101993199 (10198146.52/秒)&lt;br&gt;&amp;lt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ランダム数生成レポート&#34;&gt;ランダム数生成レポート
&lt;/h2&gt;&lt;p&gt;現在の時刻からの乱数ジェネレーター&lt;br&gt;&lt;br&gt;&lt;br&gt;次のオプションでメモリ速度テストを実行中:&lt;br&gt;  ブロックサイズ：1KiB&lt;br&gt;  合計サイズ：102400MiB&lt;br&gt;  操作：書き込み&lt;br&gt;  範囲：グローバル&lt;br&gt;&lt;br&gt;ワーカースレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッド開始!&lt;br&gt;&lt;br&gt;総操作数：48418803 (1秒あたり4841004.79)&lt;br&gt;&lt;br&gt;転送されたデータ：47283.99 MiB (1秒あたり4727.54 MiB)&lt;br&gt;&lt;br&gt;&lt;br&gt;一般的な統計:&lt;br&gt;    合計時間：                          10.0001s&lt;br&gt;    イベント総数：              48418803&lt;br&gt;&lt;br&gt;レイテンシ（ms）：&lt;br&gt;         最小：                                    0.00&lt;br&gt;         平均：                                    0.00&lt;br&gt;         最大：                                   25.26&lt;br&gt;         95パーセンタイル：                        0.00&lt;br&gt;         合計：                                 4578.95&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント（平均/標準偏差）：           48418803.0000/0.00&lt;br&gt;    実行時間（平均/標準偏差）：   4.5789/0.00&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;ランニングテストで次のオプションを使用中：&lt;br&gt;スレッド数：1&lt;br&gt;現在の時刻からの乱数ジェネレーターの初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;追加ファイルオープンフラグ：（なし）&lt;br&gt;128ファイル、各16MiB&lt;br&gt;2GiBの合計ファイルサイズ&lt;br&gt;ブロックサイズ 16KiB&lt;br&gt;IOリクエスト数：0&lt;br&gt;組み合わせてランダムIOテストの読み取り/書き込み比率：1.50&lt;br&gt;定期的なFSYNCが有効になっており、各100リクエストごとにfsync()を呼び出しています。&lt;br&gt;テストの最後にfsync()を呼び出すことが有効になっています。&lt;br&gt;同期I/Oモードを使用&lt;br&gt;ランダムな読み取り/書き込みテストを実行中&lt;br&gt;ワーカースレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッド開始!&lt;br&gt;&lt;br&gt;&lt;br&gt;ファイル操作：&lt;br&gt;    読み取り/秒：                      3373.41&lt;br&gt;    書き込み/秒：                     2248.94&lt;br&gt;    fsync/秒：                     7201.80&lt;br&gt;&lt;br&gt;スループット：&lt;br&gt;    読み取り、MiB/s：                  52.71&lt;br&gt;    書き込み、MiB/s：               35.14&lt;br&gt;&lt;br&gt;一般的な統計：&lt;br&gt;    合計時間：                          10.0127s&lt;br&gt;    イベント総数：              128288&lt;br&gt;&lt;br&gt;レイテンシ（ms）：&lt;br&gt;         最小：                                    0.00&lt;br&gt;         平均：                                    0.08&lt;br&gt;         最大：                                    5.14&lt;br&gt;         95パーセンタイル：                        0.34&lt;br&gt;         合計：                                 9977.78&lt;br&gt;&lt;br&gt;スレッドの公平性：&lt;br&gt;    イベント（平均/標準偏差）：           128288.0000/0.00&lt;br&gt;    実行時間（平均/標準偏差）：   9.9778/0.00&lt;/p&gt;
&lt;p&gt;スループット：&lt;br&gt;    読み取り、MiB/s：                  52.71&lt;br&gt;    書き込み、MiB/s：               35.14&lt;br&gt;&lt;br&gt;一般的な統計：&lt;br&gt;    合計時間：                          10.0127s&lt;br&gt;    イベント総数：              128288&lt;br&gt;&lt;br&gt;レイテンシ（ms）：&lt;br&gt;         最小：                                    0.00&lt;br&gt;         平均：                                    0.08&lt;br&gt;         最大：                                    5.14&lt;br&gt;         95パーセンタイル：                        0.34&lt;br&gt;         合計：                                 9977.78&lt;br&gt;&lt;br&gt;スレッドの公平性：&lt;br&gt;    イベント（平均/標準 ## ランダム数生成データレポート
現在の時刻からの乱数ジェネレーター&lt;br&gt;&lt;br&gt;&lt;br&gt;次のオプションでメモリ速度テストを実行中:&lt;br&gt;  ブロックサイズ：1KiB&lt;br&gt;  合計サイズ：102400MiB&lt;br&gt;  操作：書き込み&lt;br&gt;  範囲：グローバル&lt;br&gt;&lt;br&gt;ワーカースレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッド開始!&lt;br&gt;&lt;br&gt;総操作数：48418803 (1秒あたり4841004.79)&lt;br&gt;&lt;br&gt;転送されたデータ：47283.99 MiB (1秒あたり4727.54 MiB)&lt;br&gt;&lt;br&gt;&lt;br&gt;一般的な統計:&lt;br&gt;    合計時間：                          10.0001s&lt;br&gt;    イベント総数：              48418803&lt;br&gt;&lt;br&gt;遅延（ms）：&lt;br&gt;         最小：                                    0.00&lt;br&gt;         平均：                                    0.00&lt;br&gt;         最大：                                   25.26&lt;br&gt;         95パーセンタイル：                        0.00&lt;br&gt;         合計：                                 4578.95&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント（平均/標準偏差）：           48418803.0000/0.00&lt;br&gt;    実行時間（平均/標準偏差）：   4.5789/0.00&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;テストオプションで実行中:&lt;br&gt;スレッド数：1&lt;br&gt;現在の時刻からの乱数ジェネレーターの初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;追加ファイルオープンフラグ：（なし）&lt;br&gt;128ファイル、各16MiB&lt;br&gt;2GiBの合計ファイルサイズ&lt;br&gt;ブロックサイズ 16KiB&lt;br&gt;IOリクエスト数：0&lt;br&gt;組み合わせてランダムIOテストの読み取り/書き込み比率：1.50&lt;br&gt;定期的なFSYNCが有効になり、各100リクエストごとにfsync()が呼び出されます。&lt;br&gt;テストの終了時にfsync()を呼び出す。有効になっています。&lt;br&gt;同期I/Oモードを使用&lt;br&gt;ランダムな読み取り/書き込みテストを実行中&lt;br&gt;ワーカースレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッド開始!&lt;br&gt;&lt;br&gt;&lt;br&gt;ファイル操作:&lt;br&gt;    読み取り/秒：                      3373.41&lt;br&gt;    書き込み/秒：                     2248.94&lt;br&gt;    fsync/秒：                     7201.80&lt;br&gt;&lt;br&gt;スループット:&lt;br&gt;    読み取り、MiB/s：                  52.71&lt;br&gt;    書き込み、MiB/s：               35.14&lt;br&gt;&lt;br&gt;一般的な統計:&lt;br&gt;    合計時間：                          10.0127s&lt;br&gt;    イベント総数：              128288&lt;br&gt;&lt;br&gt;遅延（ms）：&lt;br&gt;         最小：                                    0.00&lt;br&gt;         平均：                                    0.08&lt;br&gt;         最大：                                    5.14&lt;br&gt;         95パーセンタイル：                        0.34&lt;br&gt;         合計：                                 9977.78&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント（平均/標準偏差）：           128288.0000/0.00&lt;br&gt;    実行時間（平均/標準偏差）：   9.9778/0.00&lt;/p&gt;
&lt;p&gt;スループット：
読み取り、MiB/s： 52.71
書き込み、MiB/s： 35.14&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;ディスク: 2147483648 バイトを 1.81 秒で書き込みました (1129.59 MiB/秒)。&lt;br&gt;&lt;br&gt;テストオプションで実行中:&lt;br&gt;スレッド数：1&lt;br&gt;現在の時刻からの乱数ジェネレーターの初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;追加ファイルオープンフラグ：（なし）&lt;br&gt;128ファイル、各16MiB&lt;br&gt;2GiBの合計ファイルサイズ&lt;br&gt;ブロックサイズ 16KiB&lt;br&gt;IOリクエスト数：0&lt;br&gt;組み合わせてランダムIOテストの読み取り/書き込み比率：1.&lt;/p&gt;
&lt;h2 id=&#34;実行データレポート-1&#34;&gt;実行データレポート
&lt;/h2&gt;&lt;p&gt;enabled, 各100リクエストごとにfsync()を呼び出す。&lt;br&gt;テストの終了時にfsync()を呼び出し、有効化。&lt;br&gt;同期I/Oモードを使用中&lt;br&gt;ランダムなr/wテストを実行中&lt;br&gt;ワーカースレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドが開始されました!&lt;br&gt;&lt;br&gt;&lt;br&gt;ファイル操作:&lt;br&gt;    読み込み/秒:                      1593.12&lt;br&gt;    書き込み/秒:                     1062.08&lt;br&gt;    fsync/秒:                     3406.64&lt;br&gt;&lt;br&gt;帯域幅:&lt;br&gt;    読み取り (MiB/s):                  24.89&lt;br&gt;    書き込み (MiB/s):               16.60&lt;br&gt;&lt;br&gt;一般的な統計:&lt;br&gt;    合計時間:                          10.0164秒&lt;br&gt;    イベント総数:              60600&lt;br&gt;&lt;br&gt;レイテンシ (ms):&lt;br&gt;         最小:                                    0.00&lt;br&gt;         平均:                                    0.16&lt;br&gt;         最大:                                   31.32&lt;br&gt;         95パーセンタイル:                        0.54&lt;br&gt;         合計:                                 9956.30&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント (平均/標準偏差):           60600.0000/0.00&lt;br&gt;    実行時間 (平均/標準偏差):   9.9563/0.00&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;2147483648 バイトを 18.29 秒で書き込みました (111.98 MiB/秒)。&lt;br&gt;&lt;br&gt;以下のオプションでテストを実行中:&lt;br&gt;スレッド数: 1&lt;br&gt;現在の時刻から乱数ジェネレーターを初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;追加のファイルオープンフラグ:(なし)&lt;br&gt;128 ファイル、各 16MiB&lt;br&gt;2GiB の合計ファイルサイズ&lt;br&gt;ブロックサイズ 16KiB&lt;br&gt;IO リクエスト数: 0&lt;br&gt;ランダムな IO テストの読み取り/書き込み比率: 1.50&lt;br&gt;定期的な FS INC を有効にし、各 100 リクエストごとに fsync() を呼び出す。&lt;br&gt;テストの終了時に fsync() を呼び出し、有効化。&lt;br&gt;同期 I/O モードを使用中&lt;br&gt;ランダムな r/w テストを実行中&lt;br&gt;ワーカースレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドが開始されました!&lt;br&gt;&lt;br&gt;&lt;br&gt;ファイル操作:&lt;br&gt;    読み込み/秒:                      1665.88&lt;br&gt;    書き込み/秒:                     1110.59&lt;br&gt;    fsync/秒:                     3563.77&lt;br&gt;&lt;br&gt;帯域幅:&lt;br&gt;    読み取り (MiB/s):                  26.03&lt;br&gt;    書き込み (MiB/s):               17.35&lt;br&gt;&lt;br&gt;一般的な統計:&lt;br&gt;    合計時間:                          10.0112秒&lt;br&gt;    イベント総数:              63355&lt;br&gt;&lt;br&gt;レイテンシ (ms):&lt;br&gt;         最小:                                    0.00&lt;br&gt;         平均:                                    0.16&lt;br&gt;         最大:                                  205.01&lt;br&gt;         95パーセンタイル:                        0.78&lt;br&gt;         合計:                                 9972.64&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント (平均/標準偏差):           63355.0000/0.00&lt;br&gt;    実行時間 (平均/標準偏差):   9.9726/0.00&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;スレッド数: 4
初期化されたランダムな数値ジェネレーターから現在の時刻を初期化&amp;hellip;&lt;br&gt;&lt;br&gt;ワーカースレッドが開始されました!&lt;br&gt;&lt;br&gt;&lt;br&gt;一般的な統計:&lt;br&gt;    合計時間:                          10.0002秒&lt;br&gt;    イベント総数:              197956&lt;br&gt;&lt;br&gt;レイテンシ (ms):&lt;br&gt;         最小:                                    0.16&lt;br&gt;         平均:                                    0.20&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;実行結果レポート&#34;&gt;実行結果レポート
&lt;/h2&gt;&lt;p&gt;合計: 40050.41&lt;br&gt;&lt;br&gt;スレッド公平性:&lt;br&gt;  イベント (平均/標準偏差): 4590.0000/94.36&lt;br&gt;  実行時間 (平均/標準偏差): 10.0126/0.00&lt;/p&gt;
&lt;p&gt;テスト実行時のオプション:
スレッド数: 4
現在の時刻から乱数生成器を初期化
&lt;br&gt;&lt;br&gt;&lt;br&gt;ワーカースレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;
スレッド起動!&lt;br&gt;&lt;br&gt;&lt;br&gt;
一般統計:
合計時間: 10.0004秒
合計イベント数: 28536&lt;br&gt;&lt;br&gt;遅延 (ms):
最小: 0.23
平均: 1.40
最大: 3.56
95パーセンタイル: 1.47
合計: 39975.16&lt;br&gt;&lt;br&gt;スレッド公平性:
イベント (平均/標準偏差): 7134.0000/39.87
実行時間 (平均/標準偏差): 9.9938/0.01&lt;/p&gt;
&lt;h2 id=&#34;追記&#34;&gt;追記
&lt;/h2&gt;&lt;p&gt;ChatGPTは依然として優れたものですが、以前習得していたMarkdownで完全にテーブルを作成できず、テーブルとして表示すると効果が著しく低下します。カスタムテーマによってページの最大幅が制限されるため、幅を百分率制に調整しました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;簡単な方法としては、TablesGeneratorのようなオンラインツールを使用してHTMLテーブルを生成する方法がありますが（内容が複雑だと不向きです）。&lt;/li&gt;
&lt;li&gt;または、Googleドキュメントで作成し、HTMLドキュメントとしてダウンロードして保存し、ブログに直接コピーする方法を採用しました（シンプルかつ直接的です）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;configの設定でunsafeな設定項目を有効にし、ページごとの幅設定を個別に指定するようにしてください。Hugoでは、ページごとに個別に幅を設定できます。これは、ページのFront Matterにカスタムパラメータを追加することで実現できます。以下はその例です。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MarkdownファイルのFront Matterセクション（通常はファイルの冒頭部分）にカスタムパラメータ（例えば&lt;code&gt;custom_width&lt;/code&gt;）を追加します：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;---
title: &amp;quot;私のページ&amp;quot;
date: 2024-01-09
custom_width: &amp;quot;800px&amp;quot;  # 幅を800ピクセルに設定
---

本文内容...
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Hugoのテーマで、対応する単一ページテンプレートファイル（例えば&lt;code&gt;layouts/_default/single.html&lt;/code&gt;）を見つけてください。&lt;/li&gt;
&lt;li&gt;単一ページテンプレート内で、Front Matterに&lt;code&gt;custom_width&lt;/code&gt;パラメータが存在するか確認し、それを適切なHTML要素（例えば&lt;code&gt;div&lt;/code&gt;）に適用します：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{{ define &amp;quot;main&amp;quot; }}
  &amp;lt;div style=&amp;quot;max-width: {{ with .Params.custom_width }}{{ . }}{{ else }}100%{{ end }}; margin: 0 auto;&amp;quot;&amp;gt;
    {{ .Content }}
  &amp;lt;/div&amp;gt;
{{ end }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この例では、内联スタイル（&lt;code&gt;style&lt;/code&gt;属性）を使用して&lt;code&gt;div&lt;/code&gt;要素の&lt;code&gt;max-width&lt;/code&gt;属性を設定し、&lt;code&gt;custom_width&lt;/code&gt;パラメータが指定されていない場合、幅をデフォルトで100%にしています。&lt;code&gt;margin: 0 auto;&lt;/code&gt;は&lt;code&gt;div&lt;/code&gt;要素を中央揃えにします。&lt;/p&gt;
&lt;p&gt;実際のアプリケーションでは、テーマの構造やCSSスタイルの詳細に応じて、上記の例を調整する必要がある場合があります。スタイルを調整する際には、テーマの一貫性と可読性を維持するようにしてください。&lt;/p&gt;
&lt;p&gt;最後に、使用しているテーマが若干異なるため、サイト全体でカスタムCSSの設定も調整しました。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Git で HTTP リポジトリを無効にする</title>
        <link>https://ttf248.life/ja/p/git-disable-http-repositories/</link>
        <pubDate>Mon, 08 Jan 2024 21:22:04 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/git-disable-http-repositories/</guid>
        <description>&lt;p&gt;習慣更新ソフトウェアバージョンです。Gitのどのバージョンの場合にHTTPリポジトリからのコード取得が許可されないか不明ですが、以下のエラーが発生します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;fatal: Unencrypted HTTP is not supported for GitLab. Ensure the repository remote URL is using HTTPS
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;背景説明&#34;&gt;背景説明
&lt;/h2&gt;&lt;p&gt;環境：Windows 平台、これまで小烏龟を使ってgitを操作しており、鍵の認証も小烏龜で処理していました。以前、ローカルリポジトリを一括更新するスクリプトを作成したこともあります。&lt;/p&gt;
&lt;p&gt;前回の記事へのリンク：[ローカルGitリポジトリの一括更新](&amp;lt;{{ relref &amp;ldquo;/post/2023/10-19-批量更新本地git仓库&amp;rdquo; &amp;gt;})&lt;/p&gt;
&lt;p&gt;今日、帰宅してコードの更新を実行したところ、上記のエラーが発生し、リポジトリが正常に更新されなくなりました。&lt;code&gt;Git&lt;/code&gt;の設定でHTTPプロトコルを使用するように変更してみるのが妥当だと思って探しましたが、対応する設定項目は見つかりませんでした。&lt;/p&gt;
&lt;p&gt;最も簡単な解決策は、SSHプロトコルに変更してリポジトリを更新することです。会社側で設定している&lt;code&gt;gitlab&lt;/code&gt;は短期的にHTTPSプロトコルを提供しません。&lt;/p&gt;
&lt;h2 id=&#34;既存の問題&#34;&gt;既存の問題
&lt;/h2&gt;&lt;p&gt;以前、ローカルリポジトリをバッチ更新するためのスクリプトを作成する際に、&lt;code&gt;ssh&lt;/code&gt; を使ってリポジトリをプルすることを検討していたが、詳細を確認しなかった。小烏龟（TortoiseGit）で設定した &lt;code&gt;git&lt;/code&gt; 設定情報を config に同期していなかったため、コマンドラインから&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git pull # 権限がないために正常に更新できない
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;と表示された。&lt;/p&gt;
&lt;p&gt;SSH キーの確認コマンド (&lt;code&gt;ssh -T git@gitlab.yintech.net&lt;/code&gt;) を実行しても問題なく動作するため、小烏龟（TortoiseGit）でコードをプルできるのに、コマンドラインで &lt;code&gt;git pull&lt;/code&gt; コマンドを実行すると SSH キーが正しくないというエラーが表示される場合、小烏龟は PuTTY の SSH 鍵を使用しているのに対し、コマンドラインは OpenSSH の SSH 鍵を使用している可能性がある。&lt;/p&gt;
&lt;p&gt;小烏亀の秘钥設定は、システム &lt;code&gt;.ssh&lt;/code&gt; フォルダから秘钥ファイル情報を読み取らず、インターフェースでリポジトリ設定を行う際に、個別に秘钥ファイルのパスを設定する。このテクニックを利用すると、プルした最初のリポジトリの設定で秘钥を設定すれば、他のリポジトリも同じ秘钥ファイルを共有できる。PuTTY は秘钥をロードした後、すぐに終了せず、代理サービスを開始する。&lt;/p&gt;
&lt;p&gt;グローバル設定を調整し、システムデフォルトの &lt;code&gt;ssh&lt;/code&gt; 設定を使用しないようにすることで、Git Bash は TortoisePlink を使用して SSH 操作を実行するように構成する。この設定は、TortoiseGit に付属の PuTTY ツールを使用する場合に適している。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global core.sshCommand &amp;quot;&#39;C:/Program Files/TortoiseGit/bin/TortoisePlink.exe&#39; -batch -ssh&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記の実行ファイルパスを、ご自身の TortoiseGit のパスに合わせて変更してください。完全なパスを設定することで、システム環境変数に追加する必要はありません。&lt;/p&gt;</description>
        </item>
        <item>
        <title>AIプログラミングとタスク分解</title>
        <link>https://ttf248.life/ja/p/ai-programming-and-task-decomposition/</link>
        <pubDate>Fri, 22 Dec 2023 08:44:26 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/ai-programming-and-task-decomposition/</guid>
        <description>&lt;p&gt;2年前、サイトにコード領域のコピー機能を追加するために、半日ほど試行錯誤した結果、レンダリング効果が少し不満だった。半ば無能なフロントエンド開発者として、改善することも思わなかった。動けばそれで十分だ、と割り切っていた。今年、&lt;code&gt;AI&lt;/code&gt;を使って小程序を開発し、フロントエンドの開発もより慣れてきた。そしてリファクタリングを行った（&lt;code&gt;AI&lt;/code&gt;が再設計）。&lt;/p&gt;
&lt;p&gt;悟り：タスク分解をして、多くの小さなタスクは&lt;code&gt;AI&lt;/code&gt;で開発すると自然にこなせる。すでに閉鎖された小程序において、&lt;code&gt;75%&lt;/code&gt;のコードを&lt;code&gt;AI&lt;/code&gt;が提供し、複数のタスクを分割して引き渡すことで、人工によってプロジェクトコードが&lt;code&gt;組み立て&lt;/code&gt;られた。&lt;/p&gt;
&lt;h2 id=&#34;前文&#34;&gt;前文
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://ttf248.github.io/post/2022/001/%E4%BB%A5%E4%B8%BA%E5%BE%88%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E6%83%85%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E5%A4%8D%E5%88%B6%E6%8C%89%E9%92%AE/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;簡単なことだと考えたけど、コードのコピーボタンを追加する&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;promot&lt;/strong&gt;: クラス &amp;ldquo;highlight&amp;rdquo; を持つウェブページの要素のコンテナ内に、コードと JavaScript の CSS およびコードを記述して、テキストのコピー機能を実現するコピーボタンを追加します。&lt;/p&gt;
&lt;p&gt;最初のドラフトのコードは一見問題があり、基本的には使用可能なものを生成し、コピーされた内容が正しくなく、冗長な文字が含まれているため、最適化を再度誘導し、コアの色設計を指定し、エフェクトを含めるようにしました。&lt;/p&gt;
&lt;p&gt;お客様がボタンのサイズと色に関して特定の要件をお持ちであることを認識しており、これらの要件に合わせてスタイルのデザインを再構築できます。以下は、提供されたカラーパレットとボタンサイズの最適化を含むスタイルです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.copy-btn {
  position: absolute;
  top: 2px; /* 位置調整 */
  right: 2px;
  padding: 3px 6px; /* サイズ縮小 */
  font-size: 12px; /* フォントサイズ縮小 */
  background-color: #8FD1E1; /* ボタンの背景色 */
  color: #272822; /* テキストの色 */
  border: 1px solid #272822; /* ボーダーの色 */
  border-radius: 3px; /* 角丸 */
  cursor: pointer;
  opacity: 0.7; /* デフォルトの不透明度 */
  transition: opacity 0.3s ease, background-color 0.3s ease; /* 平滑なトランジション効果 */
}

.copy-btn:hover {
  opacity: 1; /* マウスオーバー時に完全表示 */
  background-color: #A3D4E5; /* マウスオーバー時の背景色 */
}

.highlight {
  position: relative;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このスタイルでは、ボタンのサイズとフォントサイズを小さくして、より洗練された外観にしています。また、ボタンはデフォルトで半透明になっており、マウスをホバーすると完全表示され、背景色がわずかに明るくなることで視覚的なフィードバックを提供します。これにより、お客様のカラー要件を満たしつつ、モダンでユーザーフレンドリーな特徴を備えたデザインを実現しています。&lt;/p&gt;
&lt;p&gt;以下はよりシンプルな JavaScript です。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;document.addEventListener(&#39;DOMContentLoaded&#39;, function() {
  // すべての .highlight 要素を検索
  const highlights = document.querySelectorAll(&#39;.highlight&#39;);

  highlights.forEach(function(highlight) {
    // コピーボタンを作成
    const copyBtn = document.createElement(&#39;button&#39;);
    copyBtn.textContent = &#39;コピー&#39;;
    copyBtn.classList.add(&#39;copy-btn&#39;);

    // ボタンを各 .highlight 要素に追加
    highlight.appendChild(copyBtn);

    // クリックイベントリスナーを追加
    copyBtn.addEventListener(&#39;click&#39;, function() {
      // .highlight 内の最初の &amp;lt;code&amp;gt; 要素からコピーするコードを取得 (存在する場合)
      const code = highlight.querySelector(&#39;code&#39;) ? highlight.querySelector(&#39;code&#39;).textContent : &#39;&#39;;

      navigator.clipboard.writeText(code).then(() =&amp;gt; {
        // コピー成功メッセージを表示
        copyBtn.textContent = &#39;已コピー!&#39;;
        setTimeout(() =&amp;gt; {
          copyBtn.textContent = &#39;コピー&#39;;
        }, 2000);
      }).catch(err =&amp;gt; {
        console.error(&#39;コピー失敗: &#39;, err);
      });
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;終わりに&#34;&gt;終わりに
&lt;/h2&gt;&lt;p&gt;コード領域の右上隅に、トップエリアにコピーボタンを追加することを望んでいたが、フロントエンドに関する知識が不足しており、キーワードに基づいて機能を正確に記述することができなかったため、AIと何度もやり取りして期待に応えられなかった。&lt;/p&gt;
&lt;p&gt;しかし、時間の経過とともに、AIがプログラミング開発にどの程度の影響を与えるのかは分からない。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>クラウドサーバーとスクリプトキッド</title>
        <link>https://ttf248.life/ja/p/cloud-servers-and-script-kids/</link>
        <pubDate>Mon, 20 Nov 2023 15:08:53 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cloud-servers-and-script-kids/</guid>
        <description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;データマイニング&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ディープラーニング&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ニューラルネットワーク&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;双十一のセールで、阿里云に新しいサーバーを導入しました：経済的なモデル、99ドル年間契約、構成は高くありません。ホップサーバーとして、自宅のサービスを代理するのに適しています。イベントは2026年まで続きます。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特に上海地域のサーバーを選びました。低遅延で自宅の機械を代理し、Windows 11とWindows Server 2022を使用しました。Server版は後から展開したもので、使用中に拒否アクセスメッセージを受け取りました。当初はサーバーのアップデートだと考えましたが、すぐに回復しませんでした。関連するエラーメッセージを検索すると、誰かがログインを試みていることが示され、パスワードが間違っているため、ログインできなくなりました。
以前にもセキュリティ攻撃のスクリプトに触れたことがあります。すぐに、これらのログインは正常な行動ではないことに気づきました。サーバーが攻撃を受けており、ログインを暴力的に試みている可能性があります。サーバーのファイアウォール設定は簡素で、ホワイトリストを設定していませんでした。自宅の2台の機械の3389ポートをパブリックに公開したため、魚塘の餌のように、誰かがターゲットになりました。攻撃者がスクリプト小子であることを知ったので、次のことは単純でした。ファイアウォールのホワイトリストを設定し、会社のIPアドレスと自宅のIPアドレスのみが代理サービスへのアクセスを許可するようにしました。
&lt;code&gt;frps&lt;/code&gt; 代理サーバーの以前の設定では、ログ記録が無効でした。ログを有効にすると、全国各地の代理IPアドレスが自宅サーバーにログインしようとしていたことがわかりました。幸いなことに、Server版の1台がありました。それによって、Windows 11の機械は必ず攻撃され、パスワード設定が簡単だったため、問題が発生するのを防ぐことができました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;2023/11/17 16:51:14 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [101.43.98.211:50486]
2023/11/17 16:51:14 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [218.93.202.63:56970]
2023/11/17 16:51:14 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [222.179.106.174:60812]
2023/11/17 16:51:15 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [58.16.204.238:2839]
2023/11/17 16:51:15 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [124.223.47.24:50274]
2023/11/17 16:51:16 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [43.248.128.22:55883]
2023/11/17 16:51:16 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [43.143.53.138:56955]
2023/11/17 16:51:16 [I] [proxy.go:204] [639d89473251

```shell
Nov 16 04:46:34 aliyun-sh sshd[156625]: 無効なパスワード：root から 120.55.164.64 ポート 53410 の ssh2
Nov 16 04:46:34 aliyun-sh sshd[156623]: 無効なパスワード：root から 111.16.215.122 ポート 36548 の ssh2
Nov 16 04:46:58 aliyun-sh sshd[156630]: 無効なパスワード：無効なユーザー share から 139.9.233.78 ポート 53872 の ssh2
Nov 16 04:47:23 aliyun-sh sshd[156634]: 無効なパスワード：無効なユーザー spark から 139.9.233.78 ポート 36134 の ssh2
Nov 16 04:47:26 aliyun-sh sshd[156636]: 無効なパスワード：root から 120.55.164.64 ポート 46142 の ssh2
Nov 16 04:47:47 aliyun-sh sshd[156640]: 無効なパスワード：root から 111.16.215.122 ポート 42962 の ssh2
Nov 16 04:48:24 aliyun-sh sshd[156652]: 無効なパスワード：root から 120.55.164.64 ポート 38868 の ssh2
Nov 16 04:48:25 aliyun-sh sshd[156654]: 無効なパスワード：root から 111.16.215.122 ポート 46164 の ssh2
Nov 16 04:48:39 aliyun-sh sshd[156657]: 無効なパスワード：無効なユーザー test から 139.9.233.78 ポート 39386 の ssh2
Nov 16 04:48:50 aliyun-sh sshd[156659]: 無効なパスワード：root から 111.16.215.122 ポート 38892 の ssh2
Nov 16 04:48:53 aliyun-sh sshd[156662]: 無効なパスワード：root から 120.55.164.64 ポート 49348 の ssh2
Nov 16 04:48:53 aliyun-sh sshd[156664]: 無効なパスワード：無効なユーザー test から 139.9.233.78 ポート 49864 の ssh2
Nov 16 04:50:02 aliyun-sh sshd[156672]: 無効なパスワード：root から 111.16.215.122 ポート 45294 の ssh2
Nov 16 04:50:30 aliyun-sh sshd[156680]: 無効なパスワード：無効なユーザー zabbix から 139.9.233.78 ポート 52206 の ssh2
Nov 16 04:50:50 aliyun-sh sshd[156683]: 無効なパスワード：root から 120.55.164.64 ポート 34820 の ssh2
Nov 16 04:50:51 aliyun-sh sshd[156685]: 無効なパスワード：root から 111.16.

## 付録
独自のサーバーを構築する場合、Windows のパブリックアクセスにはホワイトリストの設定が必要です。Linux では、パスワードログインの無効化と、キーファイルによる認証の有効化をお勧めします。&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>ローカルのGitリポジトリと履歴上の遺留権限の問題の一括更新</title>
        <link>https://ttf248.life/ja/p/bulk-update-local-git-and-legacy-permissions/</link>
        <pubDate>Thu, 19 Oct 2023 14:16:22 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/bulk-update-local-git-and-legacy-permissions/</guid>
        <description>&lt;p&gt;チームのプロジェクト間に依存関係があり、歴史的な理由から &lt;code&gt;submodule&lt;/code&gt; を使用せずにプロジェクトの依存を管理してきました。日常の開発では、リポジトリコードを順番に手動で更新する必要があり、そうでない場合、さまざまな奇妙な問題が発生する可能性があります。&lt;/p&gt;
&lt;p&gt;オンラインの情報源を参照して、構造は基本的に同じです。ローカルで &lt;code&gt;git_list.txt&lt;/code&gt; というディレクトリを維持し、スクリプトを使用してディレクトリを反復処理し、一度に更新を実行し、その後、作業を開始する前にこのスクリプトを実行します。&lt;/p&gt;
&lt;h2 id=&#34;linux&#34;&gt;Linux
&lt;/h2&gt;&lt;p&gt;新しいファイルを作成: batch_pull.sh&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash

echo &amp;quot;============ リポジトリの更新 ===================&amp;quot;

# git_list.txt が存在するか確認
if [ ! -f &amp;quot;git_list.txt&amp;quot; ]; then
  echo &amp;quot;git_list.txt ファイルが存在しません！git をプルするリポジトリ URL を作成し、追加してください。&amp;quot;
  exit 1
else
  echo &amp;quot;============ git リポジトリリストを検出しました ====&amp;quot;
fi

# git_list.txt から URL を一行ずつ読み込み、プル操作を実行
while read -r url; do
  if [ -d &amp;quot;$url&amp;quot; ]; then
    cd &amp;quot;$url&amp;quot; || continue
    git pull
    cd ..
    echo &amp;quot;Pull $url が完了しました！&amp;quot;
    echo &amp;quot;========================================&amp;quot;
  else
    echo &amp;quot;ディレクトリ $url は存在しません。プルをスキップします。&amp;quot;
  fi
done &amp;lt; &amp;quot;git_list.txt&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;windows&#34;&gt;Windows
&lt;/h2&gt;&lt;p&gt;新しいファイルを作成: batch_pull.bat&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bat&#34;&gt;@echo off
chcp 65001 &amp;gt; nul
rem スクリプトの存在するディレクトリへ移動
cd /d &amp;quot;%~dp0&amp;quot;

rem git_list.txt が存在するか確認
if not exist &amp;quot;git_list.txt&amp;quot; (
  echo git_list.txt ファイルが見つかりません！ git リポジトリ URL を作成し、追加してください。
  exit /b 1
) else (
  echo ============ git リポジトリリストファイルが検出されました =========
)

rem git_list.txt 内の URL を行ごとに読み込み、プル操作を実行
for /f %%i in (git_list.txt) do (
  if exist &amp;quot;%%i&amp;quot; (
    pushd &amp;quot;%%i&amp;quot;
    git pull
    popd
    echo %%i のプルが完了しました！
    echo ========================================
  ) else (
    echo ディレクトリ %%i は存在しません。スキップします。
  )
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;過去の遺留問題&#34;&gt;過去の遺留問題
&lt;/h3&gt;&lt;p&gt;再装システム後に発生した &lt;code&gt;git&lt;/code&gt; フォルダの権限ファイルに関する問題を解決します：&lt;strong&gt;致命的なエラー「unsafe repository (&amp;rsquo;/home/repon&amp;rsquo; is owned by someone else)」&lt;/strong&gt;
オンラインで提案されている解決策は、主に &lt;code&gt;stack overflow&lt;/code&gt; から提供されています。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;リポジトリディレクトリに信頼を追加: &lt;code&gt;git config --global --add safe.directory /home/repon&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.gitconfig&lt;/code&gt; ファイルを手動で編集し、ディレクトリを信頼として指定&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[safe]
    directory = /home/repon
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記の方法により、リポジトリの更新は正常になりましたが、毎回 &lt;code&gt;git pull&lt;/code&gt; を実行する際にコンソールに多数の警告メッセージが表示され、所有者に関するエラーを示しています。&lt;/p&gt;
&lt;h3 id=&#34;デスクトップpcのシステム再インストール&#34;&gt;デスクトップPCのシステム再インストール
&lt;/h3&gt;&lt;p&gt;長らくシステムを再インストールしていなかったマシンで、システムディスクにゴミファイルが爆発的に発生し、仕方なく空き時間を利用してシステムを再構築した。再度この権限の問題に遭遇し、以前のスクリプトが動作しない原因は、修正した権限が不完全だったことによるもの。&lt;/p&gt;
&lt;p&gt;新しい解決策を採用し、&lt;code&gt;*&lt;/code&gt;を追加することで、&lt;code&gt;git&lt;/code&gt;がすべてのディレクトリを自動的に信頼するように設定した。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global --add safe.directory &amp;quot;*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;これはユーザーの権限の問題か、それとも皆さんがWindowsプラットフォームに慣れていないことが原因なのか。実際には&lt;code&gt;chown&lt;/code&gt;のようなコマンドも存在する。フォルダの所有者を変更することはもちろん可能だが、もしディレクトリ数が少ない場合は、手動で所有者を変えることもできる。しかし、このワークステーションはドメイン情報を追加しており、おそらく会社のドメインが異常を抱えているか、あるいはローカルシステムの設定に問題があるため、ユーザーリストからログインに使用するユーザーが見つからない状態だった。最終的にはコマンドラインを使用して問題を解決した。&lt;/p&gt;
&lt;p&gt;管理者権限で&lt;code&gt;powershell&lt;/code&gt;スクリプト&lt;code&gt;change_ower.ps1&lt;/code&gt;を実行し、スクリプトファイルのエンコーディングを&lt;code&gt;gbk&lt;/code&gt;に設定することを忘れないでください。中国語のオペレーティングシステムでは、そうしないと文字化けしてしまうため。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;# 現在のユーザー名を取得
$currentUserName = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name

# PowerShell の文字エンコーディングを UTF-8 に設定
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8

# 所有者を変更するルートディレクトリパス
$rootDirectory = &amp;quot;G:\workspace&amp;quot;  # 実際のパスに置き換えてください

# ディレクトリとファイルを再帰的に取得し、所有者を変更
Get-ChildItem -Path $rootDirectory -Recurse | ForEach-Object {
    $itemPath = $_.FullName

    # アイテムがファイルかディレクトリかをチェック
    if ($_ -is [System.IO.DirectoryInfo]) {
        # ディレクトリの場合、icacls コマンドを使用して所有者権限を変更
        $icaclsResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            Write-Host &amp;quot;ディレクトリ $itemPath の所有者を $currentUserName に変更しました&amp;quot;
        } else {
            Write-Host &amp;quot;ディレクトリ $itemPath の所有者変更に失敗しました。エラー情報: $icaclsResult&amp;quot;
        }
    } else {
        # ファイルの場合、icacls コマンドを使用して所有者権限を変更
        $takeownResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            # Write-Host &amp;quot;ファイル $itemPath の所有者を $currentUserName に変更しました&amp;quot;
        } else {
            Write-Host &amp;quot;ファイル $itemPath の所有者変更に失敗しました。エラー情報: $takeownResult&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;予想外の事態が再び発生し、スクリプト実行時の出力された日本語の情報が文字化けした。コンソールエンコーディングの設定を調整したり、スクリプトのエンコーディングを変更したりしたが、すべて文字化けしてしまう。おそらく脳みそが完全に機能停止しているのだろうと推測し、コントロールパネル - 領域 - 言語設定のベータ機能を試してみた。グローバルにUnicodeエンコーディングを有効にし、スクリプト実行は正常になった。いくつかの開発ソフトウェアが正常に動作しないままであり、後で資料を整理したところ、スクリプトファイルのエンコーディングを&lt;code&gt;gbk&lt;/code&gt;に設定する必要があることを思い出した。&lt;/p&gt;
&lt;h2 id=&#34;资料&#34;&gt;资料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://ganzhixiong.com/p/f1b9f4fc/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ganzhixiong.com/p/f1b9f4fc/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/71901632/fatal-error-unsafe-repository-home-repon-is-owned-by-someone-else&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stackoverflow.com/questions/71901632/fatal-error-unsafe-repository-home-repon-is-owned-by-someone-else&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>WPF学習資料</title>
        <link>https://ttf248.life/ja/p/wpf-learning-resources/</link>
        <pubDate>Tue, 17 Oct 2023 10:49:24 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/wpf-learning-resources/</guid>
        <description>&lt;p&gt;小規模アプリ（ミニプログラム）開発の設計上の問題がまだ解決されておらず、新たに&lt;strong&gt;WPF&lt;/strong&gt;を立ち上げました。最近会社にも波乱があり、遠隔地での共同作業におけるコミュニケーション効率は依然として不十分で、思い切ってクライアント側のUI開発を受注しました。&lt;/p&gt;
&lt;h2 id=&#34;wpf&#34;&gt;WPF
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/dotnet/desktop/wpf/introduction-to-wpf?view=netframeworkdesktop-4.8&amp;amp;preserve-view=true&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 微软官网学习资料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/zh7791/p/11502696.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 基础总结(学習建議)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.wpfsoft.com/introduction&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 中文網&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/638815741&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 个人まとめと学習推奨&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;WPF&lt;/code&gt; のインターフェースデザインで使われる多くの概念は、ウェブページフロントエンドのデザインに似ています。可能な限り UI デザインとビジネスロジックを分離し、UI デザインを独立して開発することも、インターネット企業が期待する分業方法です。今年、小程序（ミニアプリ）の開発をした経験があり、多くの概念は共通しているため、習得も比較的容易でした。これらのものは現代の UI 設計における「道」であり、基本的なフレームワークの概念を理解することで、その後の道が曲がりにくくなります。&lt;/p&gt;
&lt;p&gt;以前 &lt;code&gt;WinForm&lt;/code&gt; 開発の経験がある読者の場合は、&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/zh7791/p/11502696.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 基礎まとめ(学習建議)&lt;/a&gt; を読んでください。内容は短いため、経験豊富な読者が学習ルートを計画するのに適しています。&lt;/p&gt;
&lt;p&gt;初心者の方は、&lt;a class=&#34;link&#34; href=&#34;http://www.wpfsoft.com/introduction&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 中文網&lt;/a&gt; から始めて、基本的な概念、発展の歴史、低レベルクラスの論理的認知について理解してください。このウェブサイトは偶然にもタイミングが合っており、今年8月に作者がリリースしたばかりで、読者を惹きつけ、コースの購入を促すためのものです。私のコンテンツとのタイミングが一致しなかったら、ほぼ無縁になっていたでしょう。&lt;/p&gt;
&lt;p&gt;最も本格的な学習資料は、もちろん Microsoft の公式資料ですが、内容は少し退屈なので、新参者は根気強く学ぶ必要があります。&lt;/p&gt;
&lt;p&gt;古典的な電子書籍もたくさんありますが、日常業務に追われるため、静かに読書する時間は限られています。プロジェクトで実践しながら学習することが最適です。&lt;/p&gt;
&lt;h2 id=&#34;c-と-net-のリリース履歴&#34;&gt;C# と .NET のリリース履歴
&lt;/h2&gt;&lt;p&gt;以前学習した言語について、最近数年間の新機能のリリースが少し多いため、文法のバージョンが毎年更新されています。
&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/C_Sharp_%28programming_language%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://en.wikipedia.org/wiki/C_Sharp_(programming_language)&lt;/a&gt;
公式学習資料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/dotnet/csharp/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/dotnet/csharp/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/dotnet/core/tutorials/with-visual-studio?pivots=dotnet-7-0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/dotnet/core/tutorials/with-visual-studio?pivots=dotnet-7-0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>ゼロティア・ローカルエリアネットワーク</title>
        <link>https://ttf248.life/ja/p/zero-tier-remote-lan/</link>
        <pubDate>Tue, 19 Sep 2023 04:58:03 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/zero-tier-remote-lan/</guid>
        <description>&lt;p&gt;オフィスに新たにミニPCを入手し、環境構築を兼ねて便利に考えたのですが、自宅でも時折アクセスする必要があるため、一時的に社内ネットワークのトンネリングを実施することになりました。これまでの経験から、&lt;code&gt;frp&lt;/code&gt;サービスをデプロイしてポートフォワーディングを設定する方法を選びましたが、その品質は公開サーバーの帯域幅に依存します。少しばかり新鮮な&lt;code&gt;Zerotier&lt;/code&gt;仮想マシンによるローカルエリアネットワーク（LAN）を試してみることにしました。これは&lt;code&gt;VPN&lt;/code&gt;と似ており、ローカルで仮想ネットワークインターフェースを作成し、すべてのマシンを1つの仮想ネットワークに参加させます。&lt;/p&gt;
&lt;h2 id=&#34;zerotierとは&#34;&gt;Zerotierとは
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ZeroTier&lt;/code&gt;は、ソフトウェア定義の広域ネットワーク（SD-WAN）ソリューションであり、異なる地理的な場所にあるデバイス間で安全な仮想ネットワークを作成することを可能にします。 &lt;code&gt;ZeroTier&lt;/code&gt;を使用すると、複数のコンピューター、サーバー、およびデバイスを、あたかも同じローカルネットワーク上にいるかのように、一元的に暗号化された仮想ネットワークに接続できます。これにより、開発者やIT専門家は、複雑なネットワーク設定やVPN構成なしで、異なる場所間で安全にデータを共有し、リソースを共有することができます。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ZeroTierネットワーク&lt;/strong&gt;: ZeroTierネットワークは、異なるデバイスがインターネット経由で互いに接続されることを可能にする、仮想的かつグローバルなローカルエリアネットワーク（LAN）です。このネットワークには複数のサブネットを含めることができ、すべてのデバイスはZeroTierの技術を使用して相互に接続されます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;惑星サーバー&lt;/strong&gt;: 惑星サーバーは、ZeroTierネットワークの中核コンポーネントであり、その一元的なトポロジー構造、ルーティング情報、およびネットワーク状態を維持・管理します。惑星サーバーはグローバルなネットワーク制御センターとして機能しますが、直接データを転送しません。ユーザーのデバイスは、少なくとも1つの惑星サーバーに接続してZeroTierネットワークに参加する必要があります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;中継サーバー&lt;/strong&gt;: 中継サーバーは、ZeroTierネットワーク内の補助的なノードであり、デバイス間の直接通信チャネルを確立するのを支援します。デバイスが直接接続できない場合、データ転送のために中継サーバーを経由することができます。これにより、ネットワークの到達性とパフォーマンスが向上します。中継サーバーは通常、世界中に配置され、データの転送ハブとして機能します。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;全体として、ZeroTierは惑星サーバーと中継サーバーの支援により、デバイスがグローバル範囲で仮想LANを作成し、安全かつ高速なデバイス間の通信を実現します。惑星サーバーはグローバルネットワーク管理を担当し、中継サーバーは必要に応じてデバイス間の接続を確立するのに役立ちます。&lt;/p&gt;
&lt;h2 id=&#34;インストールと展開&#34;&gt;インストールと展開
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.zerotier.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.zerotier.com/&lt;/a&gt; の公式ウェブサイトにアクセスし、インストールファイルおよびドキュメントを入手してください。&lt;/li&gt;
&lt;li&gt;お使いのオペレーティングシステムに応じて、ZeroTier One クライアントをダウンロードしてインストールします。Windows、macOS、Linux など、多くのプラットフォームに対応しています。&lt;/li&gt;
&lt;li&gt;インストールが完了したら、ZeroTier One クライアントを起動します。&lt;/li&gt;
&lt;li&gt;まだアカウントをお持ちでない場合は、ZeroTier アカウントを作成します。クライアント内でアカウントを作成できます。&lt;/li&gt;
&lt;li&gt;ZeroTier アカウントにログインし、新しいネットワークを作成します。ネットワークには一意の16桁IDが割り当てられ、これを覚えておく必要があります。&lt;/li&gt;
&lt;li&gt;デバイスをこのネットワークに参加させます。クライアントでネットワークIDを入力するか、QRコードスキャン機能を使用します。&lt;/li&gt;
&lt;li&gt;ZeroTier クライアントのインストールおよび設定されたデバイスは、同じ仮想ネットワークに追加されます。これらのデバイス間では、現在、ローカルネットワークにあるかのように直接通信できるようになります。&lt;/li&gt;
&lt;li&gt;ZeroTier のコントロールパネルで、ネットワーク設定を管理したり、デバイスを追加したり、ネットワークトラフィックを監視したりできます。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;moon-のインストールとデプロイ&#34;&gt;moon のインストールとデプロイ
&lt;/h2&gt;&lt;p&gt;国内の多くのキャリアが UDP トンネリングを禁止しているため、&lt;code&gt;frp&lt;/code&gt; サービスは安定しており、TCP プロトコルを使用するため、&lt;code&gt;Zerotier&lt;/code&gt; の中継サーバーも同様の効果を実現できます。ファイアウォールで UDP 9993 を開通する必要があります。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -s https://install.zerotier.com/ | sudo bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;インストールが成功したか確認する&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zerotier-cli info
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ローカルネットワークへの参加&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zerotier-cli join network-id
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;moon&lt;/code&gt; の作成&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd /var/lib/zerotier-one &amp;amp;&amp;amp; sudo zerotier-idtool initmoon identity.public &amp;gt; moon.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;stableEndpoints&lt;/code&gt; ノードを調整するために構成ファイルを開き、&amp;ldquo;サーバーのパブリック IP アドレス/9993&amp;rdquo; を設定します。署名構成を生成し、&lt;code&gt;moons.d&lt;/code&gt; フォルダを作成し、既存のファイルをこのフォルダに移動してサービスを再起動します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo zerotier-idtool genmoon moon.json
mkdir moons.d &amp;amp;&amp;amp; mv 000000eb444ec0d8.moon moons.d/
systemctl restart zerotier-one.service
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;クライアントノードが &lt;code&gt;moon&lt;/code&gt; サーバーに参加し、ID は前の JSON 設定ファイル内の ID フィールドから取得します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zerotier-cli.bat orbit ztaddr ztaddr
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;確認:&lt;/strong&gt; 新しい moon ノードが作成され、ID と情報はサーバー構成と同じであることを確認してください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 新規 moon 节点の出現を確認し、ID と情報がサーバー設定と一致することを確認します
[root@idv-36f9d5 ~]# zerotier-cli listpeers
200 listpeers &amp;lt;ztaddr&amp;gt; &amp;lt;path&amp;gt; &amp;lt;latency&amp;gt; &amp;lt;version&amp;gt; &amp;lt;role&amp;gt;
200 listpeers 0cccb***** 35.236.*.*/64393;110;10726 327 1.6.3 LEAF
200 listpeers 3a46f***** 185.180.*.*/9993;110;757 -1 - PLANET
200 listpeers 3ed7c***** 39.97.*.*/9993;172;79 32 1.6.3 MOON
200 listpeers 4f838***** - -1 - LEAF
200 listpeers 62f86***** 50.7.*.*/9993;110;4796 351 - PLANET
200 listpeers 778cd***** 103.195.*.*/9993;5148;4887 253 - PLANET
200 listpeers 992fc***** 195.181.*.*/9993;10161;4921 226 - PLANET
200 listpeers 9d2b5***** - -1 - LEAF
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Windows プラットフォームでは、管理者権限でターミナルを起動し、&lt;code&gt;zerotier-cli.bat&lt;/code&gt; コマンドラインを使用して操作します。Linux プラットフォームでは、&lt;code&gt;zerotier-cli&lt;/code&gt; コマンドラインを使用して操作します。 &lt;code&gt;listpeers&lt;/code&gt; サブコマンドは正常に moon 节点を表示するため、参加が成功したことを示しています。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;卸载方法&#34;&gt;卸载方法
&lt;/h2&gt;&lt;p&gt;Windowsプラットフォームの卸載方法は後述します。通常の操作手順に従い、コントロールパネルからアンインストールしてください。ここではUbuntuについて詳しく説明します。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;dpkgコマンドでzerotier-oneサービスを削除する&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo dpkg -P zerotier-one
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;zerotier-oneフォルダを削除する。このフォルダにはaddressアドレスが保存されており、削除後に再インストールを行うと新しいaddressアドレスを取得します。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo rm -rf /var/lib/zerotier-one/
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;跋談&#34;&gt;跋談
&lt;/h2&gt;&lt;p&gt;元々は既にアンインストールされていたものが、サーバーが到着し、適切なプロキシノードが存在しないため、阿里云が営業活動を行い、開発用特供サーバーを提供しました。構成は高くなく、1999年、価格も手頃で、2年間運用しました。主な理由はサーバーから提供される帯域幅でした。&lt;/p&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.wnark.com/archives/152.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.wnark.com/archives/152.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/Yogile/p/12642423.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cnblogs.com/Yogile/p/12642423.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>VMware 仮想マシンのディスクスペース最適化</title>
        <link>https://ttf248.life/ja/p/vmware-virtual-machine-disk-space-optimization/</link>
        <pubDate>Wed, 21 Jun 2023 18:35:41 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/vmware-virtual-machine-disk-space-optimization/</guid>
        <description>&lt;p&gt;VMWareの仮想マシンをインストールして開発を行う際、通常はディスク容量を多めに確保します。使用していくうちに、ホスト側の使用ディスク容量が仮想マシンの実際のファイルサイズを大幅に上回ることがあります。&lt;/p&gt;
&lt;h2 id=&#34;シナリオの説明&#34;&gt;シナリオの説明
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;df -h&lt;/code&gt;コマンドを実行し、現在のマシンのディスク情報を確認したところ、実際に使用されているのは60GBであり、すべてのシャットアウトとクローンイメージを削除しても、ローカル仮想マシンが占有するディスクスペースは依然として60GBよりも大幅に大きい。これにより、すでに限られたハードドライブの状態が悪化している。&lt;/p&gt;
&lt;h2 id=&#34;前提条件&#34;&gt;前提条件
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;仮想マシンのインストール時に、ディスクの事前割り当てをチェックしなかった&lt;/li&gt;
&lt;li&gt;ローカルに保存された仮想マシンのハードドライブが、現在使用されている容量より十分な空き容量を持っていること
空き容量が不足している場合は、一時的に仮想マシンをポータブルHDDに移動してディスクを最適化した後、再度移行することを検討してください。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ツール&#34;&gt;ツール
&lt;/h2&gt;&lt;p&gt;公式から &lt;code&gt;open-vm-tools&lt;/code&gt; パッケージが提供されており、yum でインストールするか、vmware-tools イメージパッケージでインストールできます。&lt;/p&gt;
&lt;h2 id=&#34;命令&#34;&gt;命令
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vmware-toolbox-cmd disk shrink /
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これを実行すると、仮想マシンは自動的にシャットダウンされ、VMware ホストプログラムがディスクの縮小を実行します。 実行時間は仮想マシンのサイズとディスクへのアクセス速度によって異なります。
実行効果は非常に良く、仮想マシンのディスク使用量が &lt;code&gt;df -h&lt;/code&gt; のディスク情報とほぼ一致します。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Stable-diffusion - そのインストールから始まる喜びと苦悩 (安定拡散 - そのインストールから始まる喜びと苦悩)</title>
        <link>https://ttf248.life/ja/p/stable-diffusion-zero-install-story/</link>
        <pubDate>Thu, 13 Apr 2023 00:23:54 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/stable-diffusion-zero-install-story/</guid>
        <description>&lt;p&gt;国内の資料は、基本的には&lt;strong&gt;秋葉&lt;/strong&gt;さんのワンクリックデプロイパッケージを推奨されています。すべてPythonベースのオープンソースプロジェクトなので、デプロイもそれほど複雑ではないだろうと考え、ゼロから試してみることにしました。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;AI生成画像に苦労したので、意図的にグラフィックカードを変更しました。入門版の&lt;code&gt;3060 12g&lt;/code&gt;です。7年勤めた&lt;code&gt;960&lt;/code&gt;が栄光のうちに退役しました。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;コアの &lt;code&gt;pytorch cuda&lt;/code&gt; のインストールですが、以前 &lt;code&gt;python&lt;/code&gt; ゲーム補助スクリプトを書いた際にローカルにインストールしたことがありましたが、やはり問題が発生しました。&lt;code&gt;cuda&lt;/code&gt; の暗号化が常に有効にならないという問題です。&lt;/p&gt;
&lt;h2 id=&#34;待処理&#34;&gt;待処理
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;文章構造を再計画し、まず PyTorch を紹介する。バージョン対応関係とバージョン確認方法&lt;/li&gt;
&lt;li&gt;ローカル環境から PyTorch をゼロから新規に作成・デプロイする方法&lt;/li&gt;
&lt;li&gt;Stable Diffusion の翻訳稿を作成する（https://stable-diffusion-art.com/install-windows/ から開始）&lt;/li&gt;
&lt;li&gt;参照資料の整理&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ステップ&#34;&gt;ステップ
&lt;/h2&gt;&lt;p&gt;中国語で検索すると、手順を追ったインストール方法が見つかりにくい可能性があります。&lt;code&gt;Google&lt;/code&gt; で英語で検索すると、同様のチュートリアルがたくさんあります。ゼロから始めるものばかりです。いくつか説明した後、&lt;code&gt;git&lt;/code&gt; のインストールが必要であること、そして &lt;code&gt;python&lt;/code&gt; のインストールについても言及します。その後は、リポジトリをダウンロードし、直接スクリプトをダブルクリックして完了となります。
&lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/AUTOMATIC1111/stable-diffusion-webui&lt;/a&gt;
詳細な使用方法や疑問点については、&lt;code&gt;issues&lt;/code&gt; を参照してください。&lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki&lt;/a&gt;
なぜ誰もこのリポジトリが何をするものなのか説明していないのかわかりません。名前からして、それはインターフェース制御台であり、より簡単に使用できるように設計されていることがわかります。インストール時には、現在のフォルダに &lt;code&gt;Python&lt;/code&gt; 仮想環境があるかどうかを自動的に認識し、存在する場合は現在のパスの &lt;code&gt;python&lt;/code&gt; を使用します。
初心者の方には、&lt;a class=&#34;link&#34; href=&#34;https://stable-diffusion-art.com/install-windows/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stable-diffusion-art.com/install-windows/&lt;/a&gt; を参照することをお勧めします。&lt;/p&gt;
&lt;h2 id=&#34;pytorch&#34;&gt;PyTorch
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://pytorch.org/get-started/locally/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pytorch.org/get-started/locally/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今日は私が話したいのは、まず彼らの手順をそのまま実行しないでください。Pythonはrequirementファイルを使って依存ライブラリをインストールします。これは小さな問題です。重要なのはあなたのGPUのバージョンとドライバーのバージョンがPyTorchに対応していることです。これは多くの人が対応関係を紹介しているので、ネットで調べてみればわかります。
参考：&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/weixin_40660408/article/details/129896700&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/weixin_40660408/article/details/129896700&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;仮想環境を作成するのは、空の仮想環境を作り、その中でまず公式サイトのスクリプトを実行してPyTorchをインストールすることです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python -c &amp;quot;import torch; print(torch.version.cuda)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python -c &amp;quot;import torch; print(torch.__version__, torch.cuda.is_available())&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記の2つのスクリプトで、必要なCUDAバージョンを確認したり、インストールが成功したかどうかを確認したりできます。&lt;/p&gt;
&lt;p&gt;ここでは、派手な操作をするのではなく、まず公式サイトのロジックをそのままコピーしてインストールすることをお勧めします。直接pipを使ってインストールすると、PyTorchが失敗する可能性や、CUDAがアクティブにならない可能性があります。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ポイントは、フォルダのパスに不要なものが含まれていないことです。そうでないと、PyTorchを使用できなくなる可能性があります。&lt;/p&gt;
&lt;p&gt;何度もインストールを試みたり、公式のインストールファイルをダウンロードして手動でインストールしたりしました。2.0バージョンをアップグレードしたいと考えていましたが、公式ドキュメントでは2.0がより高速であると記載されています。しかし、以前はあまり使用していなかったので、Pythonのバージョンやそれが影響するかどうか分からずでした。また、公式マニュアルには3.8バージョンの推奨があることが書かれていました。これにより小さな競合が発生しました。以前、ワンクリックインストールパッケージを使用しており、その中に3.10バージョンが含まれていました。最終的には、空のフォルダを作成し、仮想環境を作成して、PyTorchが正しくインストールされていることを確認してから、インストールを開始しました。&lt;/p&gt;
&lt;p&gt;その後、インストールされた仮想環境をWeb UIのフォルダに移動しました。この状態でスクリプトを実行して、他の依存関係の問題は解決されました。&lt;/p&gt;
&lt;p&gt;移動後、次のコマンドを実行する必要があります：&lt;code&gt;python -m pip install --upgrade --force-reinstall pip&lt;/code&gt;  pipを修復します。&lt;/p&gt;
&lt;p&gt;おそらく、これは非常に奇妙に見えるかもしれませんが、この場所でかなり時間を費やしました。なぜなら、常にPyTorchを正しく認識できなかったからです。すべての干渉要因を除外するために、まずそれをインストールし、次に他の依存ライブラリをインストールすることを思いつきました。&lt;/p&gt;
&lt;h2 id=&#34;xformers&#34;&gt;Xformers
&lt;/h2&gt;&lt;p&gt;有効化することを推奨します。画像生成を高速化し、既存の占有量を削減できますが、副作用として、同じパラメータセットで&lt;strong&gt;生成される画像は比較的安定しません&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Xformers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;stable-diffusion-webui:Xformers&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://huggingface.co/docs/diffusers/optimization/xformers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;huggingface optimization&lt;/a&gt;
| 100.00% | 2分57秒33 | 7440MiB / 10058MiB | 12288MiB / 12288MiB (100.0%) |&lt;/p&gt;
&lt;h2 id=&#34;xformers-1&#34;&gt;Xformers
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;最適化比率&lt;/th&gt;
&lt;th&gt;時間&lt;/th&gt;
&lt;th&gt;Torch 活性/予約メモリ&lt;/th&gt;
&lt;th&gt;システムVRAM&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;51.02%&lt;/td&gt;
&lt;td&gt;1分29秒21&lt;/td&gt;
&lt;td&gt;4547/7164 MiB&lt;/td&gt;
&lt;td&gt;9298/12288 MiB (75.67%)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;xformers-2&#34;&gt;Xformers
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;((masterpiece)),((best quality)),((high detail)),((realistic,))
産業時代の都市、中央に深い峡谷、中国式の街並み、バザール、橋、（雨の日:1.2）、（スチームパンク:0.8）、中国建築
ネガティブプロンプト：nsfw,((カウボーイ)),(((陰毛))), ((((陰毛の髪の毛))))スケッチ、重複、醜い、大きな目、テキスト、ロゴ、モノクロ、最悪の顔、（悪いおよび変異した手:1.3）、(最悪の品質:2.0)、(低品質:2.0)、(ぼやけ:2.0)、ホラー、ジオメトリ、bad_prompt、（悪い手）、(指が足りない)、複数の四肢、悪い解剖学、（交差した指:1.2）、醜い指、（追加の指と手と足と腕:1.4）、冠髪飾り、（2girl）、(変形した指:1.2)、(長い指:1.2)、サキュバスの翼、角、サキュバスの角、サキュバスのヘアスタイル、（悪いアーティストアニメ）、悪いアーティスト、悪い手、借りたキャラクター、テキスト重視、ウォーターマーク、サンプルウォーターマーク、キャラクターウォーターマーク、Lofterユーザー名、写真の日付ウォーターマーク、映画ポスター、雑誌表紙、ジャーナル、表紙、表紙ページ、道行表、アルバム表紙、漫画表紙、ブランド名の模倣、EasyNegative、タイツ、シルクストッキング、ショート
ステップ数：35、サンプラー：DPM adaptive、CFGスケール：5.5、シード：2223996555、サイズ：1088x1088、モデルハッシュ：543bcbc212、モデル：base_Anything-V3.0-pruned、Clipスキップ：2、ENSD：31337
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;終わりに&#34;&gt;終わりに
&lt;/h2&gt;&lt;p&gt;なぜデプロイメントパッケージを推奨しなかったのかというと、そのパッケージには作者が個人的にカスタマイズした設定が含まれており、公式のオリジナルのものとは異なっているためです。もしあなたが初心者であれば、なぜそれらのパラメータが最適なのか分からないかもしれません。しかし、使用していくうちに公式のマニュアルを参照することで、どのパラメータを調整する必要があるかを知ることができます。&lt;/p&gt;
&lt;h2 id=&#34;グラフィックボードの選択&#34;&gt;グラフィックボードの選択
&lt;/h2&gt;&lt;p&gt;データマネーマイニングの後、グラフィックボードの価格は比較的高くありません。一般的なエントリーレベルのプレイヤーが、&lt;code&gt;3060&lt;/code&gt;と&lt;code&gt;3060Ti&lt;/code&gt;の間で選択する場合、一般的には大容量&lt;code&gt;12G&lt;/code&gt;版の3060が推奨されます。なぜなら、より高い解像度の画像を生成できるからです。なぜ高い解像度が必要なのでしょうか？それは、生成時に解像度を上げることによって、生成される画像がより鮮明で詳細になるためです。もしあなたが小さな画像を生成したいのであれば、&lt;code&gt;8G&lt;/code&gt;のVRAMでも十分です。&lt;/p&gt;
&lt;p&gt;さらに、&lt;strong&gt;高解像度アップスケーリング&lt;/strong&gt;オプションがあり、ディテールを強調し、画面の詳細さを豊かにすることも、より多くのVRAMが必要です。&lt;/p&gt;
&lt;p&gt;以下はNVIDIA GeForce GTX 970、GeForce RTX 3060 Ti、GeForce RTX 3060、GeForce RTX 3080およびGeForce RTX 3080 Tiの単精度（FP32）、半精度（FP16）および双精度（FP64）浮動小数点演算能力の仕様一覧表：&lt;/p&gt;
&lt;p&gt;| GeForce GTX 970 | 2014 | 3.49 | 87.2 | 0.109 |&lt;/p&gt;
&lt;h2 id=&#34;グラフィックボードの選択-1&#34;&gt;グラフィックボードの選択
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;グラフィックボードモデル&lt;/th&gt;
&lt;th&gt;リリース年&lt;/th&gt;
&lt;th&gt;単精度浮動小数点演算能力 (TFLOPS)&lt;/th&gt;
&lt;th&gt;半精度浮動小数点演算能力 (TFLOPS)&lt;/th&gt;
&lt;th&gt;双精度浮動小数点演算能力 (TFLOPS)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3060 Ti&lt;/td&gt;
&lt;td&gt;2020&lt;/td&gt;
&lt;td&gt;16.2&lt;/td&gt;
&lt;td&gt;32.4&lt;/td&gt;
&lt;td&gt;0.51&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;グラフィックボードの選択-2&#34;&gt;グラフィックボードの選択
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;グラフィックボードモデル&lt;/th&gt;
&lt;th&gt;リリース年&lt;/th&gt;
&lt;th&gt;単精度浮動小数点演算能力 (TFLOPS)&lt;/th&gt;
&lt;th&gt;半精度浮動小数点演算能力 (TFLOPS)&lt;/th&gt;
&lt;th&gt;双精度浮動小数点演算能力 (TFLOPS)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3060&lt;/td&gt;
&lt;td&gt;2021&lt;/td&gt;
&lt;td&gt;12.7&lt;/td&gt;
&lt;td&gt;25.4&lt;/td&gt;
&lt;td&gt;0.39&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;グラフィックボードの選択-3&#34;&gt;グラフィックボードの選択
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;グラフィックボードモデル&lt;/th&gt;
&lt;th&gt;リリース年&lt;/th&gt;
&lt;th&gt;単精度浮動小数点演算能力 (TFLOPS)&lt;/th&gt;
&lt;th&gt;半精度浮動小数点演算能力 (TFLOPS)&lt;/th&gt;
&lt;th&gt;双精度浮動小数点演算能力 (TFLOPS)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3080&lt;/td&gt;
&lt;td&gt;2020&lt;/td&gt;
&lt;td&gt;29.8&lt;/td&gt;
&lt;td&gt;58.9&lt;/td&gt;
&lt;td&gt;0.93&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;グラフィックボードの選択-4&#34;&gt;グラフィックボードの選択
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;グラフィックボードモデル&lt;/th&gt;
&lt;th&gt;リリース年&lt;/th&gt;
&lt;th&gt;単精度浮動小数点演算能力 (TFLOPS)&lt;/th&gt;
&lt;th&gt;半精度浮動小数点演算能力 (TFLOPS)&lt;/th&gt;
&lt;th&gt;双精度浮動小数点演算能力 (TFLOPS)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3080 Ti&lt;/td&gt;
&lt;td&gt;2021&lt;/td&gt;
&lt;td&gt;34.8&lt;/td&gt;
&lt;td&gt;68.7&lt;/td&gt;
&lt;td&gt;1.36&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;显卡的選択&#34;&gt;显卡的選択
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.google.com/spreadsheets/d/1Zlv4UFiciSgmJZncCujuXKHwc4BcxbjbSBg71-SdeNk/edit#gid=0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;各種グラフィックカード性能テストデータ&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;更新&#34;&gt;更新
&lt;/h2&gt;&lt;p&gt;半年ごとに、改めてインストール手順を整理したり、基礎概念を解説したりする予定でしたが、一般的にAIイラストを生成する場合、結局はベテランユーザーが提供した画像パラメータを調整したり、既存の画像をフォーマットして再レンダリングしたりすることになるという事実に気づきました。&lt;/p&gt;
&lt;p&gt;以前、AIを使ってミニプログラムのUI素材を描画するというプロジェクトがありましたが、半日かけても期待通りの結果が得られず、結局公式のミニプログラムから画像素材を直接ダウンロードする方が良いという結論に至りました。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>プログラムの最適化は、ハードウェアと戦おうとするべきではありません。</title>
        <link>https://ttf248.life/ja/p/program-optimization-dont-fight-hardware/</link>
        <pubDate>Fri, 07 Apr 2023 16:30:15 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/program-optimization-dont-fight-hardware/</guid>
        <description>&lt;p&gt;&lt;code&gt;one loop thread&lt;/code&gt;（単一ループスレッド）の実行時間がすでに&lt;strong&gt;マイクロ秒&lt;/strong&gt;レベルで、サーバーを交換した結果、最大6万パケットまでバックログが積み重なるのをほぼゼロにすることができた。&lt;/p&gt;
&lt;p&gt;シングルスレッドでのループ処理でデータを扱う場合、CPUの性能はクロック周波数、キャッシュサイズ、命令セットアーキテクチャなどの要因によって決まる。一般的に、クロック周波数が高く、キャッシュサイズが大きい、そして命令セットアーキテクチャが高度なCPUほど、シングルスレッドでデータを処理する際の性能が良い。&lt;/p&gt;
&lt;h2 id=&#34;シングルスレッド&#34;&gt;シングルスレッド
&lt;/h2&gt;&lt;p&gt;パフォーマンス向上のために、スレッドを追加することは必ずしも必要ではありません。プロジェクトのプロセスを整理し、時間がかかる箇所を特定し、シングルスレッドで要件を満たせるか検討します。シングルスレッドでは考慮すべき点が少なく、問題が発生する可能性も低くなります。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最初からスレッドについて言及するのは、多少不適切です&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;イベント&#34;&gt;イベント
&lt;/h2&gt;&lt;p&gt;処理しているデータは&lt;strong&gt;市場データであり、遅延に敏感&lt;/strong&gt;です。
一晩中ひたすら加班し、新しい最適化版をリリースし、ローカルでインターフェースを剥離してテストを行い、速度はそれなりに良かった（tps：4.2万）。
サーバーにデプロイしたところ、tpsが急降下し、2.1万になった。台式机に戻って試すと、tpsは7.9万だった。グループ内のサービス仮想マシンの問題があるのではないかと疑い始め、まずCPUのクロック周波数（主頻度）の違いを疑った。家庭用PCとサーバーの&lt;code&gt;CPU&lt;/code&gt;では、クロック周波数が最も異なる点だった。&lt;/p&gt;
&lt;p&gt;テストサーバーA&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;processor	: 7
vendor_id	: GenuineIntel
cpu family	: 6
model		: 47
model name	: Intel(R) Xeon(R) CPU E7- 4807  @ 1.87GHz
stepping	: 2
microcode	: 0x34
cpu MHz		: 1866.733
cache size	: 18432 KB
physical id	: 1
siblings	: 4
core id		: 3
cpu cores	: 4
apicid		: 7
initial apicid	: 7
fpu		: yes
fpu_exception	: yes
cpuid level	: 11
wp		: yes
flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss syscall nx rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc cpuid aperfmperf pni pclmulqdq ssse3 cx16 sse4_1 sse4_2 popcnt aes hypervisor lahf_lm pti dtherm arat
bugs		: clflush_monitor cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit
bogomips	: 3733.46
clflush size	: 64
cache_alignment	: 64
address sizes	: 40 bits physical, 48 bits virtual
power management:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;テストサーバーB&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;processor	: 7
vendor_id	: GenuineIntel
cpu family	: 6
model		: 63
model name	: Intel(R) Xeon(R) CPU E5-2640 v3 @ 2.60GHz
stepping	: 2
microcode	: 0x3c
cpu MHz		: 2599.998
cache size	: 20480 KB
physical id	: 14
siblings	: 1
core id		: 0
cpu cores	: 1
apicid		: 14
initial apicid	: 14
fpu		: yes
fpu_exception	: yes
cpuid level	: 15
wp		: yes
flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc cpuid aperfmperf pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand hypervisor lahf_lm cpuid_fault epb pti fsgsbase smep xsaveopt cqm_llc cqm_occup_llc dtherm ida arat pln pts
bugs		: cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit
bogomips	: 5199.99
clflush size	: 64
cache_alignment	: 64
address sizes	: 40 bits physical, 48 bits virtual
power management:
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;openaiへの相談&#34;&gt;OpenAIへの相談
&lt;/h2&gt;&lt;p&gt;まず、コア数とクロック周波数に関しては、Intel(R) Xeon(R) CPU E7-4807 @ 1.87GHzは6つの物理コアと12個の論理コアを持ち、クロック周波数は1.87GHzです。一方、Intel(R) Xeon(R) CPU E5-2640 v3 @ 2.60GHzは8つの物理コアと16個の論理コアを持ち、クロック周波数は2.60GHzです。したがって、コア数とクロック周波数という点では、E5-2640 v3がE7-4807よりもシングルスレッドでのデータ処理において有利であると考えられます。
次に、キャッシュサイズに関しては、E7-4807のキャッシュサイズは12MBであり、E5-2640 v3のキャッシュサイズは20MBです。したがって、E5-2640 v3はより大きなキャッシュスペースを持ち、データのアクセス速度とキャッシュヒット率を向上させることができます。
最後に、アーキテクチャに関しては、E5-2640 v3はより高度なHaswellアーキテクチャを採用しており、E7-4807は旧いNehalemアーキテクチャを採用しています。HaswellアーキテクチャはNehalemアーキテクチャと比較して性能が向上しているため、これもE5-2640 v3のシングルスレッドでのデータ処理時の性能向上に影響を与える可能性があります。
したがって、総合的に考えると、シングルスレッドでループ処理を行うシナリオでは、E5-2640 v3はE7-4807よりも優れたパフォーマンスを発揮すると考えられます。ただし、具体的なパフォーマンスの違いは、データ処理のアルゴリズム、メモリ帯域幅、システム負荷など、さまざまな要因によって影響を受けるため、個別の問題に対して具体的に分析する必要があります。&lt;/p&gt;
&lt;h2 id=&#34;ハードウェア情報&#34;&gt;ハードウェア情報
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cpubenchmark.net/compare/3786.2vs2365.2/%5BDual-CPU%5D-Intel-Xeon-E7%e2%80%934807-vs-%5BDual-CPU%5D-Intel-Xeon-E5-2640-v3&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cpubenchmark.net/compare/3786.2vs2365.2/%5BDual-CPU%5D-Intel-Xeon-E7–4807-vs-%5BDual-CPU%5D-Intel-Xeon-E5-2640-v3&lt;/a&gt;
| 価格 | オンライン検索 $78 - 購入 |  |&lt;/p&gt;
&lt;h2 id=&#34;ハードウェア仕様&#34;&gt;ハードウェア仕様
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Intel Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Intel Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ハードウェア仕様-1&#34;&gt;ハードウェア仕様
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ハードウェア仕様-2&#34;&gt;ハードウェア仕様
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Intel Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Intel Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ハードウェア仕様-3&#34;&gt;ハードウェア仕様
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Intel Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Intel Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ハードウェア仕様-4&#34;&gt;ハードウェア仕様
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ハードウェア仕様-5&#34;&gt;ハードウェア仕様
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Intel Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Intel Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ハードウェア仕様-6&#34;&gt;ハードウェア仕様
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ハードウェア仕様-7&#34;&gt;ハードウェア仕様
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Intel Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Intel Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ハードウェア仕様-8&#34;&gt;ハードウェア仕様
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Intel Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Intel Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ハードウェア情報-1&#34;&gt;ハードウェア情報
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;初登場&lt;/td&gt;
&lt;td&gt;Q3 2020&lt;/td&gt;
&lt;td&gt;Q3 2014&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ハードウェア仕様-9&#34;&gt;ハードウェア仕様
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Intel Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Intel Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;サンプル数&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;46&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ハードウェア仕様-10&#34;&gt;ハードウェア仕様
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Intel Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Intel Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ハードウェア仕様-11&#34;&gt;ハードウェア仕様
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ハードウェア仕様-12&#34;&gt;ハードウェア仕様
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
</description>
        </item>
        <item>
        <title>プロンプトエンジニア</title>
        <link>https://ttf248.life/ja/p/prompt-engineer/</link>
        <pubDate>Sun, 26 Mar 2023 20:46:53 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/prompt-engineer/</guid>
        <description>&lt;p&gt;例として、かつて検索エンジンのテクニックを学んだように、私たちはまた、&lt;code&gt;AI&lt;/code&gt;とコミュニケーションするためのテクニックも習得する必要がある。合理的な制約条件を与え、効率的に必要な答えを得る方法を学ぶのだ。&lt;/p&gt;
&lt;p&gt;もし角度を変えて考えると、現在の&lt;code&gt;AI&lt;/code&gt;は記憶力に優れた小さな子供であり、完璧に暗記し、宿題をコピーできる能力を持っている。私たちがやるべきことは、&lt;code&gt;AI&lt;/code&gt;と正確かつ効果的にコミュニケーションする方法を学び、要求を正確に記述することで、&lt;code&gt;AI&lt;/code&gt;が期待される結果を生み出すのを助けることだ。&lt;/p&gt;
&lt;h2 id=&#34;科学普及&#34;&gt;科学普及
&lt;/h2&gt;&lt;p&gt;話題となっている&lt;code&gt;AI&lt;/code&gt;（人工知能）を具体的に言うと&lt;code&gt;Generative Pre-Training&lt;/code&gt;（生成事前学習）です。これはインターネット上で利用可能なデータを用いてテキスト生成を行う深層学習モデルであり、質問応答、テキスト要約生成、機械翻訳、分類、コード生成、対話型AIなど様々なタスクに用いられます。現在、GPT-1、GPT-2、GPT-3、GPT-4といった異なるバージョンのモデルが存在し、それぞれが前バージョンよりも規模が大きく、性能も向上しています。&lt;/p&gt;
&lt;h2 id=&#34;到底有没有智能&#34;&gt;到底有没有智能
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;類似度が高ければ高いほど、精度も高くなる&lt;/li&gt;
&lt;li&gt;基本的な、反復性の仕事は、特定の訓練を受けることで、人工の介入が不要になる
生成式AIとは、既存のテキスト、音声、画像などのデータを活用して新しいコンテンツを作成する技術である。テキスト生成、音声合成、画像生成、対話システムなど、様々なタスクに使用できる。生成式AIの論理性は、その学習データとモデル構造に依存する。一般的に、生成式AIは一定程度、文法、論理、常識に従うことができるが、誤りや偏見、または不真実を含むコンテンツを生成することもある。そのため、生成式AIの出力は人間の判断と検証が必要であり、盲目的に信頼したり使用したりすることはできない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;プロンプトエンジニア&#34;&gt;プロンプトエンジニア
&lt;/h2&gt;&lt;p&gt;時間は流れの法則を変えない。人は潮流に適応することを学ぶ必要がある。AIを無智能で論理性に欠けるものと捉えがちだが、よく書けば使えないコードを生成することも少なくない。&lt;/p&gt;
&lt;p&gt;もし別の角度から考えると、現在のAIは記憶力に優れた幼い子供であり、丸暗記する能力を持っている。つまり、問題をコピーする能力があるのだ。私たちがやるべきことは、AIに対して適切で効果的かつ正確なコミュニケーションを学び、要求を明確に記述し、AIが期待される結果を生み出すのを支援することだ。&lt;/p&gt;
&lt;h2 id=&#34;対話モデル&#34;&gt;対話モデル
&lt;/h2&gt;&lt;p&gt;2年前、GitHub Copilotの発表は誰も予想していませんでした。その結果、OpenAIが横空に出現し、人類は大規模言語モデルの能力を認識するに至りました。&lt;/p&gt;
&lt;p&gt;コメントベースのプログラミングと対話ベースのプログラミングに基づき、インタラクティブなロジックは完全に異なり、対話のパターンは初心者ユーザーにとって親しみやすく、NewBingが各質問の後に提示するフォローアップのヒントは必須です。Microsoftは、AI知識ベースにあるより多くのコンテンツを取得するために、ユーザーを誘導しようとしています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;データの前処理&lt;/li&gt;
&lt;li&gt;深層学習&lt;/li&gt;
&lt;li&gt;ニューラルネットワーク&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;栗子&#34;&gt;栗子
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 必要なライブラリをインポート
import argparse
import logging
import multiprocessing
import os

from PIL import Image


# 画像をグレースケールに変換し、透明背景を維持して画像を保存し、ファイルサイズを返す関数を定義します。
def convert_and_save(image_file):
    # 画像を開く
    try:
        image = Image.open(image_file)
    except Exception as e:
        logging.error(f&amp;quot;画像 {image_file} のオープンに失敗しました：{e}&amp;quot;)
        return None, None
    # 画像のモードを取得します。RGBA モードの場合、透明背景があります。
    mode = image.mode
    if mode == &amp;quot;RGBA&amp;quot;:
        # 画像と同じサイズの白い背景画像を生成します。
        background = Image.new(&amp;quot;RGB&amp;quot;, image.size, (255, 255, 255))
        # 元の画像に背景を貼り付け、透明ピクセルを無視します。
        background.paste(image, mask=image.split()[3])
        # 合成された画像をグレースケールモードに変換します。
        gray_image = background.convert(&amp;quot;L&amp;quot;)
        # グレースケール画像をRGBAモードに戻して透明背景を維持します。
        final_image = gray_image.convert(&amp;quot;RGBA&amp;quot;)
    else:
        # RGBA モードでない場合は、画像が直接グレースケールモードに変換されます。
        final_image = image.convert(&amp;quot;L&amp;quot;)
    # 元の画像のファイル名と拡張子を取得します。
    file_name, file_ext = os.path.splitext(image_file)
    # 新しい画像のファイル名を定義し、_bw サフィックスを追加して黒白であることを示します。
    new_file_name = file_name + &amp;quot;_bw&amp;quot; + file_ext
    # 新しい画像を保存し、品質を最適化してファイルサイズを削減します。
    try:
        final_image.save(new_file_name, optimize=True)
    except Exception as e:
        logging.error(f&amp;quot;{new_file_name} の保存に失敗しました：{e}&amp;quot;)
        return None, None
    # 元の画像と新しい画像のファイルサイズを取得し、返します。
    old_size = os.path.getsize(image_file)
    new_size = os.path.getsize(new_file_name)
    return file_name, old_size, new_size

# コマンドライン引数を解析し、フォルダパスと拡張名リストを返す関数を定義します。
def parse_args():
    # 解析器オブジェクトを作成します。
    parser = argparse.ArgumentParser(description=&amp;quot;画像を黒白に変換し、品質を最適化します。&amp;quot;)
    # 位置パラメータを追加してフォルダパスを指定します。
    parser.add_argument(&amp;quot;folder_path&amp;quot;, help=&amp;quot;画像が含まれるフォルダーのパスです。&amp;quot;)
    # オプションパラメータを追加して拡張名リストを指定します。デフォルトは png, jpg, jpeg, gif です。
    parser.add_argument(&amp;quot;-e&amp;quot;, &amp;quot;--extensions&amp;quot;, nargs=&amp;quot;+&amp;quot;, default=[&amp;quot;.png&amp;quot;, &amp;quot;.jpg&amp;quot;, &amp;quot;.jpeg&amp;quot;, &amp;quot;.gif&amp;quot;], help=&amp;quot;画像ファイルの拡張子です。&amp;quot;)
    # コマンドライン引数を解析し、結果オブジェクトを返します。
    args = parser.parse_args()
    return args.folder_path, args.extensions

# 変換前後のファイルサイズの違いを出力する関数を定義します。
def print_result(result):
    # 結果が空でない場合、変換と保存が成功したことを示します。
    if result:
        # 結果をファイル名とファイルサイズのタプルに分解します。
        if len(result) == 3:
            file, old_size, new_size = result
            # コントロールパネルで変換前後のファイルサイズの違いを出力します。
            logging.info(f&amp;quot;{file}: {old_size} バイト -&amp;gt; {new_size} バイト&amp;quot;)
        else:
            # 結果を出力します。
            logging.info(f&amp;quot;{result}&amp;quot;)

# 日志記録器を設定し、ログをコンソールとファイルに出力し、ログレベルを INFO に設定します。
logging.basicConfig(level=logging.INFO,
                    format=&amp;quot;%(asctime)s %(levelname)s %(message)s&amp;quot;,
                    handlers=[logging.StreamHandler(),
                              logging.FileHandler(&amp;quot;log.txt&amp;quot;)])

# # 別のプロセスに、パイプを介して渡されたコードを実行するように通知されます。これは、`--multiprocessing-fork` コマンドライン引数を渡すことで行われます。
# `freeze_support()` 関数の実装を見ると、それが実行されているプロセスの確認と、パイプを介して渡されたコードの実行が必要かどうかを確認するタスクを実行します。
# `multiprocessing.freeze_support()`

# コア数に基づいてコンピューターに自動的にプロセスを割り当てるプロセスプールを作成します。
# プロセスプール = multiprocessing.Pool()
# 异步タスクの結果オブジェクトを格納するための空のリストを作成します。
# results = []
# フォルダー内のすべてのファイルに対して反復処理を行います。
# for file in os.listdir(folder_path):
#     # ファイルパスを結合します。
#     file_path = os.path.join(folder_path, file)
#     # 拡張子リストに基づいて画像ファイルを判断します。必要に応じて拡張子リストを変更できます。
#     if any(file_path.endswith(ext) for ext in extensions):
#         # 関数を呼び出して、画像を変換して保存し、ファイルサイズを取得します。パイプを介したコードの実行は、メインプロセスをブロックすることなく、非同期で行われます。
#         result = pool.apply_async(convert_and_save, args=(file_path,), callback=print_result)
#         # 結果オブジェクトをリストに追加します。
#         results.append((file, result))
# プロセスプールを閉じ、新しいタスクの受け入れをやめます。
# pool.close()
# すべてのタスクが完了するまで待ちます。
# pool.join()

## 終わりに

ローカル開発が `windows` システムであるため、AI が最初に提示した回答には `main` 関数も `multiprocessing.freeze_support` も含まれておらず、エラーが発生しました。質問を重ねることでエラーの原因を特定し、コードを修正しました。

かつて検索エンジンの技術を学ぶように、AI とコミュニケーションする上でも、適切な制約条件を与え、効率的に必要な回答を得るためのスキルを習得する必要があります。

注意：**もしあなたがプログラミング初心者であれば、提示されたコメントと合わせて理解できない点がある場合は、引き続き関連コードについて質問してください。**&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>微信ミニプログラムの背景と開発環境</title>
        <link>https://ttf248.life/ja/p/wechat-mini-program-background-and-development-environment/</link>
        <pubDate>Fri, 24 Mar 2023 21:59:11 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/wechat-mini-program-background-and-development-environment/</guid>
        <description>&lt;p&gt;WeChat Mini Program Introduction and Development Preparation&lt;/p&gt;
&lt;h2 id=&#34;なぜミニプログラムが存在するのか&#34;&gt;なぜミニプログラムが存在するのか
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;より良い体験：埋め込みウェブの読み込みが遅延し、白画面になる問題を解決。ネイティブアプリの方がより高速にロードできる。&lt;/li&gt;
&lt;li&gt;規範と管理：微信にとって、アクセスと管理を行うため。
小程序のリリース前に、微信は&lt;code&gt;SDK&lt;/code&gt;である&lt;code&gt;JSSDK&lt;/code&gt;を公開しており、微信支付や券などの微信のネイティブ機能を一部開放していた。しかし、開発者はウェブ開発言語でロジックを構築し、微信の規制を回避することができた。小程序には独自の記述言語が搭載されている。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;小プログラムとは&#34;&gt;小プログラムとは
&lt;/h2&gt;&lt;p&gt;小プログラムは、ダウンロードやインストールが不要で利用できるアプリケーションです。アプリを手の届くところに持つという夢を実現します。&lt;/p&gt;
&lt;p&gt;ユーザーはスキャンするか検索することでアプリを開き、使い終わったらすぐに終了するというコンセプト（「使ったら片付ける」の理念）も体現しています。&lt;/p&gt;
&lt;p&gt;ユーザーは、多くのアプリをインストールすることなく、いつでもどこでも利用できるというメリットがあります。また、インストールやアンインストールなどの手間がかかりません。&lt;/p&gt;
&lt;h2 id=&#34;ミニアプリとモバイルアプリケーションの違い&#34;&gt;ミニアプリとモバイルアプリケーションの違い
&lt;/h2&gt;&lt;p&gt;インストール不要、メモリを消費しない、拡散が容易：スキャンコード、ミニアプリカード、そーいちょうすう&lt;/p&gt;
&lt;h2 id=&#34;小程序が何ができるか&#34;&gt;小程序が何ができるか
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;コンテンツツール：知乎熱榜、微博热门、摩拜单车、今日头条、腾讯地图、腾讯翻訳&lt;/li&gt;
&lt;li&gt;小売：拼多多、京东购物、蘑菇街、每日优鲜、小米商城、屈臣氏&lt;/li&gt;
&lt;li&gt;ゲーム：跳一跳、欢乐斗地主、欢乐麻将、斗鱼直播、YY直播&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;2018年のコース内容。現在までに一部のアプリベンダーが倒産しているものもあります。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;開発準備&#34;&gt;開発準備
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;小プログラムアカウントの登録：通常通り情報を入力して登録し、メールに記載された有効化リンクをクリックします。&lt;/li&gt;
&lt;li&gt;情報登録&lt;/li&gt;
&lt;li&gt;小プログラム管理後台へのログイン&lt;/li&gt;
&lt;li&gt;小プログラム情報の充実&lt;/li&gt;
&lt;li&gt;開発者との連携：個人開発者は、ログインに使用するWeChatのIDを管理者アカウントとして使用し、追加の設定は不要です。
メールには制限があり、新しいメールアドレスが必要です。しかし、QQメールで別名を登録でき、WeChat後台での検証はありません。試行錯誤の結果、小プログラムの名前は複雑になりやすく、商標に関わる場合は審査に通りにくい可能性があります。
サービスカテゴリーを選択することも、必要に応じて追加することもできます。1つの小プログラムには最大5つのカテゴリーを追加できます。
設定画面では、小プログラムの&lt;code&gt;ID&lt;/code&gt;を確認でき、メッセージプッシュも有効化できます。メッセージプッシュを有効化すると、メッセージテンプレート機能を使用できます。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;開発者ツール筆者談&#34;&gt;開発者ツール（筆者談）
&lt;/h2&gt;&lt;p&gt;正常にダウンロードおよびインストールでき、特別な注意点はなく、概要を把握するだけで、すぐにゲストモードでアクセスします。モバイルデバッグを有効にするには、つまり小程序的開発バージョンを確認するには、小程序的開発者にログインし、設定をクリックしてプロジェクトの詳細から指定された小程序的&lt;code&gt;ID&lt;/code&gt;に切り替える必要があります。&lt;/p&gt;
&lt;h2 id=&#34;コード構造&#34;&gt;コード構造
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;js: 相互作用ロジック&lt;/li&gt;
&lt;li&gt;json: データ設定&lt;/li&gt;
&lt;li&gt;wxml: 界面の要素&lt;/li&gt;
&lt;li&gt;wxss: 界面のスタイル&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>オフィスへの引っ越しにより、サーバーにアクセスできなくなりました。</title>
        <link>https://ttf248.life/ja/p/office-move-server-inaccessible/</link>
        <pubDate>Sat, 11 Mar 2023 01:42:05 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/office-move-server-inaccessible/</guid>
        <description>&lt;p&gt;行政通知、オフィス配置の変更（元の2階から15階への移動）、通常の事務室の移転&lt;/p&gt;
&lt;h2 id=&#34;デザインセンス&#34;&gt;デザインセンス
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/office-move-server-inaccessible/20230311014537.png&#34;
	width=&#34;511&#34;
	height=&#34;916&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;オフィスビル&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;55&#34;
		data-flex-basis=&#34;133px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;移住&#34;&gt;移住
&lt;/h2&gt;&lt;p&gt;荷造り、スムーズな進路、新しい作業場所でのPCの配線整理、心地よい姿勢で仕事を開始
(ÒωÓױ)！、ネットワークケーブルを接続し、チームメンバーがよく使うサーバーにアクセスできなくなりました。無線LANに切り替えてみましたが、正常に戻りました。
当初はサーバーのIPアドレス設定の問題だと思っていました。新しい作業場所の有線LANは、ファイアウォール設定のリストに含まれていませんでした。IT担当者に連絡して調整したら解決しました。このIPアドレス範囲は、他のサーバーにも使用されており、他のサーバーにアクセスしても正常でした。徐々に疑問が生じ始めました。専門的なことは専門家に任せるべきです。最終的に運用部門の同僚が特定し、このサーバーに&lt;code&gt;docker&lt;/code&gt;がデプロイされているため、サービスのデフォルトネットワーク&lt;code&gt;docker0&lt;/code&gt;とオフィスLANの設定IPアドレス範囲が競合してしまい、送信したデータパケットを受信できなくなり、ルーティングされて&lt;code&gt;docker&lt;/code&gt;サービスに渡りました。
他のサーバーには&lt;code&gt;docker&lt;/code&gt;サービスがデプロイされていないため、このサーバーだけでした。私がよく使うので、時々コンテナを使用してテストサービスをデプロイすることがありましたが、このような状況に遭遇したとは思いませんでした。後から考えると、グループ全体が同じオフィスビル内に存在しているため、IT部門の同僚がIPアドレス範囲を割り当てたことは珍しくありません。&lt;/p&gt;
&lt;h2 id=&#34;docker0&#34;&gt;docker0
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# vim /etc/docker/daemon.json
{
    &amp;quot;bip&amp;quot;:&amp;quot;172.200.0.1/24&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;サービスを再起動し、新しいネットワークに切り替えると、サーバーが正常にアクセスできるようになりました。&lt;/p&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://yeasy.gitbook.io/docker_practice/advanced_network/docker0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Docker入門から実践 - docker0&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>組み込みシステム入門編１ - プロフェッショナルな用語集</title>
        <link>https://ttf248.life/ja/p/embedded-entry-professional-terms/</link>
        <pubDate>Tue, 07 Mar 2023 13:42:36 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/embedded-entry-professional-terms/</guid>
        <description>&lt;p&gt;組み込みシステムについて言及すると、脳裏に浮かぶのは、かつて学校の実験室で使っていた51ジャンク機とファルコムのイメージです。&lt;/p&gt;
&lt;p&gt;LPA3399Proは、瑞芯微RK3399Proプラットフォームをベースに開発されたビジュアルホストであり、大量の視覚演算が必要な携帯型コンピューティングホスト向けに設計されています。NPU（ニューラルプロセッシングユニット）内蔵で、3.0TOPSの演算能力を持ち、多様なアルゴリズムモデルに対応しています。&lt;/p&gt;
&lt;p&gt;RV1109は、瑞芯微におけるAI分野の機械視覚ブランチ向けのSoC（システムオンチップ）であり、独立したNPUを搭載しています。RV1109は、1TOPSの演算能力を提供します。&lt;/p&gt;
&lt;h2 id=&#34;system-on-chip&#34;&gt;System on Chip
&lt;/h2&gt;&lt;p&gt;SoC は System on a Chip の略で、「片上システム」を意味します。これは、複数の電子システムを 1 つのチップに統合する技術です。この技術により、電子製品のサイズと重量を大幅に削減すると同時に、性能を向上させ、消費電力を低減することができます。&lt;/p&gt;
&lt;p&gt;SoC（System on a Chip）および CPU（Central Processing Unit）は、コンピュータシステムの重要な構成要素ですが、その間にはいくつかの違いがあります。&lt;/p&gt;
&lt;p&gt;CPU は、コンピュータシステムの中核となるプロセッサであり、プログラムの命令を実行します。通常、演算ユニット、制御ユニット、レジスタなどの基本的な部品のみを含みます。&lt;/p&gt;
&lt;p&gt;一方、SoC は、CPU 以外にもメモリ、グラフィックス プロセッサ、入出力インターフェースなど、他のコンポーネントを 1 つのチップに統合します。これにより、電子製品のサイズと重量を大幅に削減し、性能を向上させ、消費電力を低減することができます。&lt;/p&gt;
&lt;p&gt;まとめると、CPU は SoC の構成要素であり、SoC はより複雑で、集積度の高い電子システムです。&lt;/p&gt;
&lt;h2 id=&#34;マイクロコントローラユニット-microcontroller-unit&#34;&gt;マイクロコントローラユニット (Microcontroller Unit)
&lt;/h2&gt;&lt;p&gt;SoC（System on a Chip）と MCU（Microcontroller Unit）は、複数の電子システムを1つのチップに統合する技術ですが、両者にはいくつかの違いがあります。&lt;/p&gt;
&lt;p&gt;MCU はマイクロコントローラの一種で、通常、CPU、メモリ、入出力インターフェースなどの基本的な部品が含まれています。これは、家電製品や自動車電子システムなど、他の電子機器を制御するために一般的に使用されます。&lt;/p&gt;
&lt;p&gt;一方、SoC（System on a Chip）は、MCU の基本的な部品に加えて、グラフィックスプロセッサや無線通信モジュールなど、さらに多くの電子システムを1つのチップに統合します。これにより、電子製品のサイズと重量を大幅に削減し、同時に性能を向上させ、消費電力を低減することができます。&lt;/p&gt;
&lt;p&gt;まとめると、MCU はシンプルなマイクロコントローラであり、SoC はより複雑で、統合度が高い電子システムです。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>AIによるプログラミング支援、生産性の進化</title>
        <link>https://ttf248.life/ja/p/ai-assisted-programming-productivity-evolution/</link>
        <pubDate>Tue, 28 Feb 2023 17:05:17 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/ai-assisted-programming-productivity-evolution/</guid>
        <description>&lt;p&gt;GitHub Copilot のリリースからわずか 2 年しか経っていないのに、ChatGPT が登場し、裏にある原理をよく理解していない状態で、しばらく使ってみた。2 つのツールのサポートレベルは完全に異なり、どちらも生産性を大幅に向上させた。&lt;/p&gt;
&lt;p&gt;あまりにも複雑なことについては、AI ではまだできないだろう。なぜなら、彼らは論理がなく、パターンや形式固定されたもの、あるいは范式を定めているからだ。学習データは十分で、AI の効果は 9 分満点になる。&lt;/p&gt;
&lt;h2 id=&#34;github-copilot&#34;&gt;GitHub Copilot
&lt;/h2&gt;&lt;p&gt;リリース時に、公式サイトの紹介の &lt;code&gt;demo&lt;/code&gt; を見ると、あまり賢くなく、試用してみましたが、使い勝手が良くありませんでしたので、諦めました。
2022年以前に、暇つぶしで切り替えて新バージョンを体験したところ、かなり良くなっており、ただ国内の速度が少し遅いのは、ネットワークの問題である可能性が高いです。&lt;code&gt;Python&lt;/code&gt;のような言語では、コメントに基づいて書かれたコードもそれなりによくできており、自分で資料を探して書いていたよりもはるかに速かったです。&lt;/p&gt;
&lt;h2 id=&#34;chatgpt&#34;&gt;ChatGPT
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Github Copilot&lt;/code&gt;は、プログラマー、つまり開発者の視点から製品を設計しており、プログラミングの知識が必要であり、コメントを通じてAIによるコーディング支援を誘導していくものでした。
&lt;code&gt;ChatGPT&lt;/code&gt;は次の段階に進み、&lt;strong&gt;専門家でなくてもすぐに使いこなせるように設計されています&lt;/strong&gt;。対話形式でのチャットインターフェースにより、質問や要件の説明、理解できない場合は引き続き質問することができます。&lt;/p&gt;
&lt;p&gt;例えば、品詞分割の概念を知っているものの、コーディング方法がわからない状態で、文字列の類似度を計算したい場合を考えてみましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Python 品詞分割 維天運通 LOGORY と 合肥維天運通情報科技股份有限公司 2 つの文字列の類似度を計算します。
比較前に、文字列を英語小文字に変換するなどして統一処理を行います。
2 番目の文字列の中に最初の文字列の最初の文字が見つかれば、2 番目の文字列を最初の文字列の長さと同じ長さで切り捨てます。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;こんにちは、これはBingです。😊
オンラインの情報123に基づき、Python の品詞分割には &lt;code&gt;jieba&lt;/code&gt; などのライブラリを使用できます。&lt;code&gt;jieba&lt;/code&gt; ライブラリは、精密モード、全模式、検索エンジンモードの 3 つの分詞モードをサポートしています。要件に応じて適切なモードを選択できます。
文字列の類似度を比較するには、まず文字列を品詞分割し、その後の単語ベクトルまたは編集距離などの指標を計算する必要があります。&lt;code&gt;numpy&lt;/code&gt; や &lt;code&gt;scipy&lt;/code&gt; などのライブラリを使用して数学演算を行うことができます。
文字列を統一的に処理するために、英語を小文字に変換するには、Python の組み込み関数 &lt;code&gt;lower()&lt;/code&gt; を使用できます。
2 番目の文字列を切り出すには、Python のスライス操作符 &lt;code&gt;[ ]&lt;/code&gt; を使用できます。&lt;/p&gt;
&lt;p&gt;以下は、その際のコード例です。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import jieba
import numpy as np
from scipy.spatial.distance import cosine

# 定義する 2 つの文字列
str1 = &amp;quot;維天運通 LOGORY&amp;quot;
str2 = &amp;quot;合肥維天運通情報科技股份有限公司&amp;quot;

# 統一処理：英語を小文字に変換
str1 = str1.lower()
str2 = str2.lower()

# 2 番目の文字列の中に最初の文字列の最初の文字が見つかる位置を探す
index = str2.find(str1[0])

# 見つかった場合、2 番目の文字列を切り出す
if index != -1:
    str2 = str2[index:index+len(str1)]

# jieba 库を使用して文字列を品詞分割する
words1 = list(jieba.cut(str1))
words2 = list(jieba.cut(str2))

# 2 つの文字列の単語ベクトル（頻度を重みとして使用）を計算する
vector1 = np.zeros(len(words1))
vector2 = np.zeros(len(words1))

for i, word in enumerate(words1):
    vector1[i] += 1 # 最初の文字列内の各単語の出現回数をカウント
    if word in words2:
        vector2[i] += 1 # 2 番目の文字列内の各単語の出現回数をカウント

# 2 つの文字列の類似度（余弦距離を指標として使用）を計算する
similarity = 1 - cosine(vector1, vector2)

print(&amp;quot;2 つの文字列の類似度は：&amp;quot;, similarity)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;さらに、結果を確認し、問題点を発見します。結果はランダムで、実際のコードを実行していませんが、良い結果を提供します。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;栗子&#34;&gt;栗子
&lt;/h3&gt;&lt;p&gt;質問：SQL文で、製品コードテーブルから、製品コードが80000～89999の範囲にあるレコードを抽出するには？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;こんにちは、Bingです。😊

検索結果12によると、指定された範囲内の値を選択するために、BETWEEN演算子を使用できます。BETWEEN演算子は、開始値と終了値を両方含みます。

まず、クエリするテーブル名と列名を指定し、WHERE句でBETWEEN演算子と範囲値を指定する必要があります。

たとえば、製品コードが80000から89999の範囲にある製品コードテーブルからレコードを抽出するには、次のステートメントを使用できます。

SELECT * FROM product_code
WHERE code BETWEEN 80000 AND 89999;
ここで、*はすべての列3を選択します。特定の列（たとえば、製品名と価格）のみを選択する場合は、カンマで区切って指定できます。例えば：

SELECT name, price FROM product_code
WHERE code BETWEEN 80000 AND 89999;
これで役に立つことを願っています。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;さらに質問します。否定して：製品コードは文字列であり、あなたのコードは間違っています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;申し訳ありませんが、製品コードが文字列であることに気づいていませんでした。もしそうであれば、範囲の値の前後にはシングルクォートを追加する必要があります。例えば：

SELECT * FROM product_code
WHERE code BETWEEN &#39;80000&#39; AND &#39;89999&#39;;
私の誤りを許してください。🙏
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;おめでとうございます。正しく認識します。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>いくつかのGitコマンドのまとめ</title>
        <link>https://ttf248.life/ja/p/less-common-git-commands-summary/</link>
        <pubDate>Fri, 17 Feb 2023 10:08:57 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/less-common-git-commands-summary/</guid>
        <description>&lt;p&gt;あまり使わないけれど非常に便利な &lt;code&gt;git&lt;/code&gt; コマンド&lt;/p&gt;
&lt;h3 id=&#34;システムを再インストールした結果windows上のフォルダーの所有権が変更されました&#34;&gt;システムを再インストールした結果、Windows上のフォルダーの所有権が変更されました。
&lt;/h3&gt;&lt;p&gt;新しいバージョンのGitにはセキュリティチェックが追加され、不安全であると警告が表示されるため、操作できなくなりました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global --add safe.directory
git config --global --add safe.directory &amp;quot;*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;ユーザーの新しいコンピューターにアカウントとパスワード情報を保存する&#34;&gt;ユーザーの新しいコンピューターにアカウントとパスワード情報を保存する
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global credential.helper store
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;保存された情報が更新が必要な場合は、まず古い認証情報を削除してください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --system --unset credential.helper
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>- コンパイラ
- コールバック関数
- パフォーマンステスト</title>
        <link>https://ttf248.life/ja/p/compiler-callback-performance-testing/</link>
        <pubDate>Wed, 15 Feb 2023 13:59:25 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/compiler-callback-performance-testing/</guid>
        <description>&lt;p&gt;昨年、SDKを設計し、イベントのパッキング処理を担当しました。外部に対してはクラスインターフェースを提供し、サービス初期化時に呼び出し元が対応するクラスを実装し、オブジェクトポインタをモジュールに渡します。&lt;/p&gt;
&lt;p&gt;C11にも触れており、好奇心で猫が死ぬように、これらのインターフェースをlambda関数オブジェクトのコールバックとして実現するとどうなるのか、純粋仮想関数インターフェース定義方法と比較して、より柔軟になるのか試してみようと考えました。&lt;/p&gt;
&lt;p&gt;疑問が生じました。2つの異なる構文、性能面からどちらが速いのか不明です。コンパイラ原理は理解していないので、コードを書いて試してみます。&lt;/p&gt;
&lt;h2 id=&#34;はじめに&#34;&gt;はじめに
&lt;/h2&gt;&lt;p&gt;オンラインのURLで、異なるコンパイラを選択したり、コンパイルパラメータを設定したり、&lt;code&gt;linux&lt;/code&gt;プラットフォーム上でコードを実行したり、対応するアセンブリコードを確認したりできます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt;：時々技術検証のために、ウェブ上で小さなコードスニペットを実行するのは非常に便利です。&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://godbolt.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://godbolt.org/&lt;/a&gt;：異なる色でアセンブリコードと対応するコードを区別できるため、ローカルのデバッガよりもさらに便利です。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;本文&#34;&gt;本文
&lt;/h2&gt;&lt;p&gt;標準委員会が定める文法規則について、コンパイルレベルにおいてどのように実現するかは、各社のコンパイラに依存します。この点については、特にマイクロソフトのコンパイラは非常に優れていると言わざるを得ません。文法糖衣は万能ではなく、コールバックインターフェースが少ないこと、ラムダ式を使用することでより便利であり、空のコールバック関数インターフェースを定義する必要がないことが挙げられます。コールバックインターフェースの種類が多い場合には、従来の仮想関数の方がビジネスインターフェースの統一に有利です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windowsプラットフォームでは、両者の性能はほぼ同等で、大きな違いはありません。&lt;/li&gt;
&lt;li&gt;Linuxプラットフォームでは、仮想関数とラムダ式を比較すると、単回りは1.35ns増加します。
通常のビジネスシステム開発においては、この程度の性能損失は無視できる範囲内であり、ラムダ式を使用することで、設計面での利便性が向上します。特に多重信号処理を行う場合には顕著であり、底层にはイベントトリガーがあり、ログ出力が必要な場合、ログオブジェクトへの処理関数を呼び出します。より多くのビジネス処理インターフェースが必要な場合には、底层で&lt;code&gt;vector&lt;/code&gt;にラムダオブジェクトを保存し、イベントトリガー時に順次呼び出しを行います。これはQTのシグナルとスロットに類似しており、ログ、監視、ビジネス1、ビジネス2といったものが完全に疎結合です。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;コード&#34;&gt;コード
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;カウンター：1000000
時間：3966us
カウンター：1000000
時間：5316us
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;memory&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;atomic&amp;gt;
#include &amp;lt;string&amp;gt;

std::atomic_int64_t カウンター = 0;

// 回呼インターフェースを定義
class UserInterface
{
public:
    virtual void name() = 0;
    virtual void full_name() = 0;
};

class User : public UserInterface
{
public:
    void name() {}
    void full_name() { カウンター++; }
};

void to_string(UserInterface* user)
{
    user-&amp;gt;name();
    user-&amp;gt;full_name();
}

using name_handler = std::function&amp;lt;void()&amp;gt;;
using full_name_handler = std::function&amp;lt;void()&amp;gt;;

class Test
{
    name_handler name_;
    full_name_handler full_name_;

public:
    void set_name_handler(name_handler name)
    {
        name_ = name;
    }

    void set_full_name_handler(full_name_handler full_name)
    {
        full_name_ = full_name;
    }

    void to_string()
    {
        name_();
        full_name_();
    }
};

int main()
{
    User user;

    auto start = std::chrono::high_resolution_clock::now();

    for (int i = 0; i &amp;lt; 1000000; i++)
    {
        to_string(&amp;amp;user);
    }

    auto end = std::chrono::high_resolution_clock::now();
    std::cout &amp;lt;&amp;lt; &amp;quot;カウンター： &amp;quot; &amp;lt;&amp;lt; カウンター &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;時間： &amp;quot; &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(end - start).count() &amp;lt;&amp;lt; &amp;quot;us&amp;quot; &amp;lt;&amp;lt; std::endl;

    counter = 0;
    auto name = []() {};
    auto full_name = []() { カウンター++; };

    Test test;
    test.set_name_handler(name);
    test.set_full_name_handler(full_name);

    start = std::chrono::high_resolution_clock::now();

    for (int i = 0; i &amp;lt; 1000000; i++)
    {
        test.to_string();
    }

    end = std::chrono::high_resolution_clock::now();
    std::cout &amp;lt;&amp;lt; &amp;quot;カウンター： &amp;quot; &amp;lt;&amp;lt; カウンター &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;時間： &amp;quot; &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(end - start).count() &amp;lt;&amp;lt; &amp;quot;us&amp;quot; &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;付録
gist.githubusercontent.com/benloong/8050171/raw/fa577ec923b460862078b8b40233a42a1c619eeb/functionperformance.cpp のようなコードスニペットを参考にしました。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;memory&amp;gt;
#include &amp;lt;functional&amp;gt;

using namespace std;
using namespace std::chrono;

class Base
{
public:
	Base(){}
	virtual ~Base(){}
	virtual int func(int i) = 0;
};

class Derived : public Base
{
public:
	Derived(int base = 10) : base{base}
	{

	}
	~Derived(){}

	virtual int func(int i)
	{
		return i*base;
	}
private:
	int base;
};

struct Func
{
	int base;
	int operator()(int i)
	{
		return i*base;
	}
	Func(int base) : base {base}
	{

	}
};
const int base = 10;
int calculate(int i)
{
	return base*i;
}

int main()
{
	const int num = 10000;
	Base *p = new Derived{10};
	int total = 0;
	auto start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += p-&amp;gt;func(i);
	}
	auto end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nvirtual call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;

	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += calculate(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\ndirect function call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;

	Func functor{10};
	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += functor(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nfunctor call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;
	int base = 10;
	function&amp;lt;int(int)&amp;gt; lambda = [base](int i)
	{
		return i*base;
	};
	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += lambda(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nlambda call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;
	return 0;
}

/*
test on mac mini i7 2.7GHz
clang++ -std=c++11 chronotest.cpp -O0
output:
result: 499950000
virtual call elapsed: 	43171 nanoseconds.

result: 499950000
direct function call elapsed: 	31379 nanoseconds.

result: 499950000
functor call elapsed: 	41497 nanoseconds.

result: 499950000
lambda call elapsed: 	207416 nanoseconds.
===================================================
clang++ -std=c++11 chronotest.cpp -O1
output:
result: 499950000
virtual call elapsed: 	261 ```
/*
*/

ここに、通常の関数と汎関数（ラムダ式）があり、コールバックインターフェースによる比較と直接呼び出しのパフォーマンスの違いは桁違いです。汎関数は関数に近いため、場合によっては汎関数のパフォーマンスが優れています。コンパイラの仕組みについては知識が不足しており、変数へのアクセスアドレスや関数が隣接していることがCPU処理を有利にするという推測です。

wandboxの結果を添付します。
``` - 付録
コードスニペット [functionperformance.cpp](https://gist.githubusercontent.com/benloong/8050171/raw/fa577ec923b460862078b8b40233a42a1c619eeb/functionperformance.cpp) を見つけました。

```c++
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;memory&amp;gt;
#include &amp;lt;functional&amp;gt;

using namespace std;
using namespace std::chrono;

class Base
{
public:
	Base(){}
	~Base(){}
	virtual int func(int i) = 0;
};

class Derived : public Base
{
public:
	Derived(int base = 10) : base{base}
	{

	}
	~Derived(){}

	virtual int func(int i)
	{
		return i*base;
	}
private:
	int base;
};

struct Func
{
	int base;
	int operator()(int i)
	{
		return i*base;
	}
	Func(int base) : base {base}
	{

	}
};
const int base = 10;
int calculate(int i)
{
	return base*i;
}

int main()
{
	const int num = 10000;
	Base *p = new Derived{10};
	int total = 0;
	auto start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += p-&amp;gt;func(i);
	}
	auto end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nvirtual call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;

	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += calculate(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\ndirect function call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;

	Func functor{10};
	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += functor(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nfunctor call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;
	int base = 10;
	function&amp;lt;int(int)&amp;gt; lambda = [base](int i)
	{
		return i*base;
	};
	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += lambda(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nlambda call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;
	return 0;
}

/*
test on mac mini i7 2.7GHz
clang++ -std=c++11 chronotest.cpp -O0
output:
result: 499950000
virtual call elapsed: 	43171 nanoseconds.

result: 499950000
direct function call elapsed: 	31379 nanoseconds.

result: 499950000
functor call elapsed: 	41497 nanoseconds.

result: 499950000
lambda call elapsed: 	207416 nanoseconds.
===================================================
clang++ -std=c++11 chronotest.cpp -O1
output:
result: 499950000
virtual call

## 付録

```shell
結果: 499950000
仮想呼び出し時間: 6143 ナノ秒。

結果: 499950000
直接関数呼び出し時間: 30 ナノ秒。

結果: 499950000
ファンクタ呼び出し時間: 31 ナノ秒。

結果: 499950000
ラムダ呼び出し時間: 15134 ナノ秒。
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>ホストモード、ネットワークモード、デバッガを使用して直接観察する</title>
        <link>https://ttf248.life/ja/p/host-network-byte-order-debugger/</link>
        <pubDate>Tue, 10 Jan 2023 14:18:12 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/host-network-byte-order-debugger/</guid>
        <description>&lt;p&gt;コンピュータの発展の歴史において、データの保存方法には統一された標準は存在しませんでした。
バイトの並び方は2つの一般的なルールに従っていました。例えば、ある多桁数の低いバイトを小さいアドレスに、高いバイトを大きいアドレスに配置する場合、これを小端序と呼びます。その逆の場合、大端序と呼びます。ネットワークアプリケーションにおいては、バイトオーダーは考慮すべき重要な要素であり、異なる種類のコンピュータが異なる標準のバイトオーダーを採用している可能性があるため、すべてネットワーク標準に変換されます。
読解習慣に従うと、大端バイトオーダーは左から右への読み込み順序に合致します。&lt;/p&gt;
&lt;h2 id=&#34;プロセッサアーキテクチャhttpszhwikipediaorgwikie5ad97e88a82e5ba8f&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;プロセッサアーキテクチャ&lt;/a&gt;
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;x86、MOS Technology 6502、Z80、VAX、PDP-11などのプロセッサは小端序を採用&lt;/li&gt;
&lt;li&gt;Motorola 6800、Motorola 68000、PowerPC 970などのプロセッサは大端序を採用&lt;/li&gt;
&lt;li&gt;ARM、PowerPC（PowerPC 970を除く）、DEC Alpha、SPARC V9、MIPS、PA-RISCおよびIA64のバイトオーダーは可変式&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;网络序&#34;&gt;网络序
&lt;/h2&gt;&lt;p&gt;ネットワーク転送では一般的に大端序が採用され、ネットワークバイト序とも呼ばれ、ネットワーク序とも言います。IPプロトコルにおいて大端序はネットワークバイト序として定義されています。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Berkeley&lt;/code&gt;ソケットは、16ビットおよび32ビット整数をネットワーク序とホストバイト序間で変換するための変換関数群を定義しています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;arpa/inet.h&amp;gt;

uint32_t htonl(uint32_t hostlong); // uint32_t をネットワーク序に変換
uint16_t htons(uint16_t hostshort); // uint16_t をネットワーク序に変換
uint32_t ntohl(uint32_t netlong); // uint32_t をネットワーク序からホスト序へ変換
uint16_t ntohs(uint16_t netshort); // uint16_t をネットワーク序からホスト序へ変換
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;asio&lt;/code&gt; をネットワークライブラリとして使用する場合、組み込みの名前空間には、クロスプラットフォームに対応した関数名が用意されています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;boost::asio::detail::socket_ops::network_to_host_long&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::network_to_host_short&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::host_to_network_long&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::host_to_network_short&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;visual-studio-デバッガー&#34;&gt;Visual Studio デバッガー
&lt;/h2&gt;&lt;p&gt;デバッグモードでは、デバッグメニューを選択し、ウィンドウからメモリウィンドウにチェックを入れます。
Visual Studio では、デバッガー内で直接メモリ内のデータを表示できます（下記画像参照）。
&lt;img src=&#34;https://ttf248.life/p/host-network-byte-order-debugger/Snipaste_2023-01-10_14-44-00.png&#34;
	width=&#34;535&#34;
	height=&#34;147&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;デバッガーメニュー&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;363&#34;
		data-flex-basis=&#34;873px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;メモリの確認方法&#34;&gt;メモリの確認方法
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ウィンドウから直接変数名を表示し、対応する変数のアドレスにジャンプ&lt;/li&gt;
&lt;li&gt;変数が元のポインタ型である場合、ウィンドウで変数をダブルクリックして選択し、メモリウィンドウにドラッグすることで、対応する内容のアドレスを表示&lt;/li&gt;
&lt;li&gt;変数がポインタ型でない場合は、計算ウィンドウに追加し、アドレスを取得してから、手動でメモリウィンドウにコピー&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例を挙げて説明します&#34;&gt;例を挙げて説明します
&lt;/h3&gt;&lt;p&gt;データを受信し、&lt;code&gt;buffer&lt;/code&gt;オブジェクトに格納します。ネットワークバイトオーダーをホストバイトオーダーに変換し、&lt;code&gt;body_length&lt;/code&gt;が30になります。サーバー側では、このデータを送信するために4バイトを使用します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool NetworkMessage::decode_header()
{
    // ネットワークバイトオーダーをホストバイトオーダーに変換
    body_length_ = boost::asio::detail::socket_ops::network_to_host_long(*(int *)buffer_.data());
    return auto_reserve(body_length_);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;大端型バイトオーダー&lt;/strong&gt;: メモリウィンドウ内の&lt;code&gt;buffer_&lt;/code&gt;の内容を観察します。
&lt;img src=&#34;https://ttf248.life/p/host-network-byte-order-debugger/buffer_.png&#34;
	width=&#34;603&#34;
	height=&#34;318&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;buffer_&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;189&#34;
		data-flex-basis=&#34;455px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;小端型バイトオーダー&lt;/strong&gt;: メモリウィンドウ内の&lt;code&gt;body_length_&lt;/code&gt;の内容を観察します。
&lt;img src=&#34;https://ttf248.life/p/host-network-byte-order-debugger/body_length_.png&#34;
	width=&#34;581&#34;
	height=&#34;333&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;body_length_&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;174&#34;
		data-flex-basis=&#34;418px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>C11: sleep for vs yield</title>
        <link>https://ttf248.life/ja/p/c11-sleep-for-vs-yield/</link>
        <pubDate>Tue, 20 Sep 2022 20:54:51 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/c11-sleep-for-vs-yield/</guid>
        <description>&lt;p&gt;コードを眺めていると、&lt;code&gt;std::this_thread::yield()&lt;/code&gt; が突然視線を集めました。C11 の構文糖で、これほど多く使われていたのは初めてです。&lt;code&gt;yield&lt;/code&gt; を以前は目にすることはありませんでした。&lt;/p&gt;
&lt;p&gt;マニュアルを確認せず、まず思い浮かべたのは、それが非同期処理と関連しているのではないかということでした。&lt;code&gt;yield&lt;/code&gt; は boost 協程の実装の中に見られる単語であり、ここでは非同期処理とは関係ありません。制御ロジックは通常のスレッドに関連しています。&lt;/p&gt;
&lt;h2 id=&#34;ドキュメント&#34;&gt;ドキュメント
&lt;/h2&gt;&lt;h3 id=&#34;yield&#34;&gt;yield
&lt;/h3&gt;&lt;p&gt;この関数の正確性は、実装に依存し、特に使用されている OS のスケジューラメカニズムとシステムの状態に依存します。例えば、先入れ先出しリアルタイムスケジューラ（Linux の SCHED_FIFO）が現在のスレッドをサスペンドし、それを実行可能な同優先度のスレッドのキューの末尾に置く（同優先度で他のスレッドがない場合、yield は効果がない）といった具合です。&lt;/p&gt;
&lt;h3 id=&#34;sleep_for&#34;&gt;sleep_for
&lt;/h3&gt;&lt;p&gt;現在のスレッドの実行をブロックし、指定された &lt;code&gt;sleep_duration&lt;/code&gt; 分間少なくとも停止します。
この関数は、スケジューリングやリソース競合による遅延のため、&lt;code&gt;sleep_duration&lt;/code&gt; より長くブロックされる可能性があります。
標準ライブラリでは、安定したクロックを使用して時間を測定することをお勧めします。システム時間で実装する場合は、待機時間がクロック調整に敏感になる可能性があることに注意してください。&lt;/p&gt;
&lt;h3 id=&#34;分析&#34;&gt;分析
&lt;/h3&gt;&lt;p&gt;両方の関数は、現在のスレッドがスレッドを占有しないようにし、実行効果はプラットフォームによって異なる可能性があります。ここまでの内容でまだ少し理解が曖昧ですが、コードを実行して結果を確認してみましょう。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ThinkPad ノートパソコン（Visual Studio Community 2022）、腾讯云 S2 標準サーバー（gcc8.5）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;分析-1&#34;&gt;分析
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;実行プラットフォーム&lt;/th&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;初回/us&lt;/th&gt;
&lt;th&gt;二次/us&lt;/th&gt;
&lt;th&gt;三次/us&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;sleep_for&lt;/td&gt;
&lt;td&gt;9872&lt;/td&gt;
&lt;td&gt;1884&lt;/td&gt;
&lt;td&gt;11302&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;分析-2&#34;&gt;分析
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;実行プラットフォーム&lt;/th&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;初回/US&lt;/th&gt;
&lt;th&gt;二回目/US&lt;/th&gt;
&lt;th&gt;三回目/US&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;h3 id=&#34;分析-3&#34;&gt;分析
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;実行プラットフォーム&lt;/th&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;初回/us&lt;/th&gt;
&lt;th&gt;二回/us&lt;/th&gt;
&lt;th&gt;三回/us&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;sleep_for&lt;/td&gt;
&lt;td&gt;171&lt;/td&gt;
&lt;td&gt;168&lt;/td&gt;
&lt;td&gt;167&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;分析-4&#34;&gt;分析
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;実行プラットフォーム&lt;/th&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;初回/us&lt;/th&gt;
&lt;th&gt;二次/us&lt;/th&gt;
&lt;th&gt;三次/us&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;yield&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;td&gt;102&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;分析-5&#34;&gt;分析
&lt;/h3&gt;&lt;p&gt;実行結果から判断すると、オペレーティングシステムの異なる実装により、高精度なスリープ（休眠）時の &lt;code&gt;sleep_for&lt;/code&gt; の安定性差が非常に大きいことがわかります。高精度なスリープを実現するためには、&lt;code&gt;yield&lt;/code&gt; を使用する方が適しています。&lt;/p&gt;
&lt;p&gt;時間精度を &lt;code&gt;ms&lt;/code&gt; (ミリ秒) に向上させた場合、両者の差異はほとんど見られなくなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;thread&amp;gt;

// 別のスレッドで短い時間の“忙しいスリープ”を実行することを推奨します
void little_sleep(std::chrono::microseconds us)
{
    auto start = std::chrono::high_resolution_clock::now();
    auto end = start + us;
    do {
        std::this_thread::yield();
    } while (std::chrono::high_resolution_clock::now() &amp;lt; end);
}

int main()
{
    auto start = std::chrono::high_resolution_clock::now();

    little_sleep(std::chrono::microseconds(100));
    std::this_thread::sleep_for(std::chrono::microseconds(100));

    auto elapsed = std::chrono::high_resolution_clock::now() - start;
    std::cout &amp;lt;&amp;lt; &amp;quot;waited for &amp;quot;
              &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(elapsed).count()
              &amp;lt;&amp;lt; &amp;quot; microseconds\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参照&#34;&gt;参照
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/header/thread.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/header/thread.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/thread/sleep_for.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/thread/sleep_for.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Linuxサーバー、MySQLパスワードのリセット</title>
        <link>https://ttf248.life/ja/p/linux-server-reset-mysql-password/</link>
        <pubDate>Tue, 20 Sep 2022 14:27:35 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-server-reset-mysql-password/</guid>
        <description>&lt;p&gt;闲置の腾讯クラウドサーバーがあり、年末に契約が満了し、更新も考えていなかったので、開発用のデータベースとしてMySQLをデプロイすることにした。システムを再構築する際に、手間を省いて、腾讯クラウドから提供されている汎用イメージを選択した。すでにMySQLデータベースがインストールされていた。本来はシステム内にReadmeのようなファイルがあり、パスワードや設定ファイルの場所などを説明してくれるだろうと期待していた。&lt;/p&gt;
&lt;p&gt;腾讯クラウドのシステム再構築は非常に速く、約1分で完了通知が来た。ログインして&lt;code&gt;systemctl status mysql&lt;/code&gt;コマンドを実行したところ、MySQLサービスが起動していることが確認できた。パスワードを探し回ったがどこにも見つからず、次第に焦り始めた。&lt;/p&gt;
&lt;p&gt;そこで、サーバーにアクセスしているのであれば、root権限を使ってパスワードをリセットする方法があるはずだと考えた。資料を調べたり、阿里云フォーラムの投稿を参考にしたりして、さらに試行錯誤を続けた。&lt;/p&gt;
&lt;h2 id=&#34;パスワードのリセット&#34;&gt;パスワードのリセット
&lt;/h2&gt;&lt;p&gt;構成ファイル &lt;code&gt;vim /etc/my.cnf&lt;/code&gt; を編集し、&lt;code&gt;mysqld&lt;/code&gt; ノードに以下の設定を追加します：&lt;code&gt;skip-grant-tables&lt;/code&gt; 、&lt;code&gt;systemctl restart mysql&lt;/code&gt; コマンドを実行してデータベースを再起動します。
その後、&lt;code&gt;mysql&lt;/code&gt; を直接使用してデータベースにログインし、通常の操作が続行できます。 &lt;code&gt;root&lt;/code&gt; ユーザーのパスワードをリセットし、同時にリモートログインを許可します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;USE mysql;
UPDATE user SET authentication_string = password(&#39;pass&#39;) WHERE User = &#39;root&#39;;
GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;pass&#39; WITH GRANT OPTION;
FLUSH PRIVILEGES;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;変更した構成ファイルをロールバックし、データベースを再起動して完了です。&lt;/p&gt;
&lt;h2 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://help.aliyun.com/document_detail/42520.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://help.aliyun.com/document_detail/42520.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>自動テストに関する考察</title>
        <link>https://ttf248.life/ja/p/automated-testing-overview/</link>
        <pubDate>Thu, 04 Aug 2022 11:39:18 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/automated-testing-overview/</guid>
        <description>&lt;p&gt;金融取引システムにおけるテストへの投資は、他のシステムを大幅に上回っており、煩雑なテスト手順が繰り返し行われていました。ROI（投資対効果）は著しく低く、プロジェクトや人員の変更に伴い、不可避的に多くのコントロールできない要因が導入されました。よく見られるのは、Aインターフェースからの出力フィールドを修正するとBインターフェースの結果に影響が出るケースです。各バージョンリリースごとにリスクも蓄積されていきます。&lt;/p&gt;
&lt;h2 id=&#34;理論的知識&#34;&gt;理論的知識
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;自動化の価値をどのように測定するか？&lt;/strong&gt;
自動テストのROI = (手動実行時間) * (実行回数) / (開発コスト + メンテナンスコスト)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;どのような機能に自動テストを行うべきか？&lt;/strong&gt;
ユーザーが頻繁に使用し、頻繁に変更されない機能。このようなインターフェースに対して自動テストコードを作成することで、最大の利益が得られます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;なぜこのタイミングで自動テストを推進するか？&lt;/strong&gt;
プロジェクトのリリース直前は不適切であり、遠い水の問題を近渴（近隣の渇き）で解決しようとするのは無駄です。自動化は長期的な収益モデルであるため、最も適切なタイミングは、プロジェクトが&lt;strong&gt;本番環境&lt;/strong&gt;で稼働し、安定したリリースサイクルに入っている時点です。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;フレームワークの選択&#34;&gt;フレームワークの選択
&lt;/h2&gt;&lt;p&gt;関連の実践経験が不足している状態で、このような自動化テストのタスクを受け取った場合、一般的なスタートは、検索エンジンを開いて、現在のシステム&lt;strong&gt;技術スタック&lt;/strong&gt;で利用可能なツールやフレームワークを探し、マニュアルを読み、一発勝負。適切なツールを見つけられれば、おめでとうございます、&lt;strong&gt;完璧なスタート&lt;/strong&gt;です。
まず「間違っていた」と言っておきながら、関連資料を調べ直すと、これは存在しないわけではなく、むしろフレームワーク自体が複雑で、デプロイに必要なリソースも多すぎることがわかります。初心者にとって必要なのは、小さくて、簡潔で、テストチームの同僚に相談すると、&lt;code&gt;Python&lt;/code&gt; 自体構築のフレームワークについて提案され、簡単に言うと、既存のユニットテストフレームワークを自動テストフレームワークとして活用するというものです。
参考となるプロジェクトのデザイン思路：&lt;a class=&#34;link&#34; href=&#34;https://github.com/wintests/pytestDemo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/wintests/pytestDemo&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;フレームが必要な理由&#34;&gt;フレームが必要な理由
&lt;/h2&gt;&lt;p&gt;サービスには、開発環境、テスト環境、本番テスト環境など、複数の異なるデプロイ環境が存在します。フレームワークの役割は、これらの環境間の抽象化層を提供することです。テストケースとデータが分離され、それぞれの環境設定に合わせて異なるケースデータを適用できます。また、共通のデータをサポートすることも可能です。&lt;/p&gt;
&lt;p&gt;主な目的は、自動化の利用率を向上させることです。より複雑なシナリオでは、異なる環境間でのデータ連携は存在せず、全く関係ありません。ケースデータを設定する際に &lt;code&gt;label&lt;/code&gt; 属性を追加し、現在のデータがサポートする環境を指定するだけで済みます。&lt;/p&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://time.geekbang.org/column/article/496850&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;最高のコストパフォーマンスな自動テスト&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>新しい言語を学ぶべき理由は何ですか？</title>
        <link>https://ttf248.life/ja/p/why-learn-a-new-language/</link>
        <pubDate>Thu, 04 Aug 2022 11:27:30 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/why-learn-a-new-language/</guid>
        <description>&lt;p&gt;学歴から算じると、C++に触れるのは10年以上になる。他のプログラミング言語を学ぶ必要がなぜあるのか？&lt;/p&gt;
&lt;p&gt;職務経験：エレガントなモジュール設計の経験が不足しており、C++の構文は自由度が高いため、他の言語を学習することで、よりエレガントな設計を書くことができるように導かれている。&lt;/p&gt;
&lt;p&gt;いくつかのツールを作成する際に、頻繁に利用することがある。&lt;/p&gt;
&lt;p&gt;低レベルライブラリのデザインやビジネスモジュールの実装など、デザインの原則もすべて理解できている。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Visual Studio コンパイル文字セット [転送]</title>
        <link>https://ttf248.life/ja/p/visual-studio-character-set/</link>
        <pubDate>Thu, 04 Aug 2022 10:51:43 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/visual-studio-character-set/</guid>
        <description>&lt;p&gt;C++をクロスプラットフォームで開発する際、中国のオペレーティングシステムではよく遭遇するエラーは、&lt;code&gt;error C2001&lt;/code&gt;（定数に改行文字が含まれています）です。&lt;/p&gt;
&lt;h2 id=&#34;visual-studio&#34;&gt;Visual Studio
&lt;/h2&gt;&lt;p&gt;CMakeはプロジェクトのコンパイルスクリプトを組織し、Windows環境での開発時に一時的にソリューションファイルを生成します。クロスプラットフォームである理由として、ファイルエンコーディングにUTF-8を選択しています。&lt;/p&gt;
&lt;p&gt;引用資料では、問題の原因について原理に基づき詳細な説明が提供されています。&lt;/p&gt;
&lt;p&gt;エンコーディングに関して、MSVCにはコンパイルオプション&lt;code&gt;/source-charset&lt;/code&gt;と&lt;code&gt;/execution-charset&lt;/code&gt;があり、これらを使用することで、ほとんどのエンコーディング問題を解決できます。&lt;/p&gt;
&lt;p&gt;例えば、WindowsのcmdコマンドプロンプトはデフォルトでGBKエンコーディングしか表示できない場合でも、コードファイル自体がUTF-8で記述されているため、クロスプラットフォームであることや、直接GBKに変換する変更を加えることが難しい状況です。そこで、Win10上で&lt;code&gt;/source-charset:utf-8 /execution-charset:gbk&lt;/code&gt;というコンパイルオプションを設定し、コンパイラをUTF-8エンコーディングで読み込み、内部の文字列配列にはGBKエンコーディングで保存することで、直接printf関数を使用してcmdコマンドプロンプトで漢字を表示することができます。&lt;/p&gt;
&lt;h2 id=&#34;visual-studio-用の-cmake-設定&#34;&gt;Visual Studio 用の CMake 設定
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;if(WIN32)
  message(STATUS &amp;quot;WIN32 での構成実行中&amp;quot;)
  set(CMAKE_CXX_FLAGS &amp;quot;${CMAKE_CXX_FLAGS} /source-charset:utf-8 /execution-charset:gbk&amp;quot;)
endif()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhaolan.zhihu.com/p/146543940&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhaolan.zhihu.com/p/146543940&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Windowsプラットフォームでフォルダのサイズを迅速にカウントする</title>
        <link>https://ttf248.life/ja/p/windows-platform-quick-folder-size-statistics/</link>
        <pubDate>Mon, 01 Aug 2022 19:54:18 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/windows-platform-quick-folder-size-statistics/</guid>
        <description>&lt;p&gt;Linuxプラットフォームは非常にシンプルです。「du -sh *」という一行のコードで済みます。Windowsはどうでしょうか？ディスクが複数あり、クリーンアップしたいのですが、ファイル数が多くて、システム標準の「リソースマネージャー」でフォルダサイズを統計すると、速度が遅くて諦めそうになります。&lt;/p&gt;
&lt;h2 id=&#34;everything&#34;&gt;Everything
&lt;/h2&gt;&lt;p&gt;Windows 平台で開発をしている方で、Everything を実際に使ったことがない方もいるかもしれません。検索速度はシステム標準のファイルエクスプローラーを圧倒的に上回ります。システムレベルでファイルの高速インデックス作成がサポートされているので、同様のツールを見つけることができるはずです。ファイルサイズも同時に統計できます。&lt;/p&gt;
&lt;h2 id=&#34;wiztree&#34;&gt;WizTree
&lt;/h2&gt;&lt;p&gt;公式サイト：&lt;a class=&#34;link&#34; href=&#34;https://www.diskanalyzer.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.diskanalyzer.com/&lt;/a&gt;
通常のインストールモードまたはグリーン版を解凍して実行
高速、データ表示タイプが豊富で、左側はツリー状図モード、右側にはファイルの種類が表示され、もちろんグラフィカルな表示も、ソフトウェアの下欄にあります。&lt;/p&gt;
&lt;h2 id=&#34;spacesniffer-2023年不再维护更新&#34;&gt;SpaceSniffer (2023年不再维护更新)
&lt;/h2&gt;&lt;p&gt;ソフトウェア公式サイト：&lt;a class=&#34;link&#34; href=&#34;http://www.uderzo.it/main_products/space_sniffer/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.uderzo.it/main_products/space_sniffer/&lt;/a&gt;
操作は非常に簡単です。対応するドライブを選択すると、ソフトウェアはグラフィカルな方法でフォルダのサイズを表示し、サイズが大きいほど画像内の対応する行列も大きくなります。その他の操作は、自分でクリックすれば理解できます。ファイル条件フィルタリングをサポートしています：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ファイルサイズのフィルタリング&lt;/li&gt;
&lt;li&gt;ファイルの日付フィルタリング&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;space_sniffer.gif&#34; &gt;基本的な使い方&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;advance.gif&#34; &gt;高度な使い方&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://moe.best/software/spacesniffer.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://moe.best/software/spacesniffer.html&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>ウェブページのスタイルシート（CSS）をコピーする方法：要素の検証</title>
        <link>https://ttf248.life/ja/p/how-to-copy-webpage-css-element-inspect/</link>
        <pubDate>Sun, 31 Jul 2022 23:36:48 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/how-to-copy-webpage-css-element-inspect/</guid>
        <description>&lt;p&gt;静的ブログのテーマは、主流が海外製のテンプレートで、調整や修正を行うことが多く、中国語コンテンツのレイアウトにはあまり考慮されない。&lt;/p&gt;
&lt;h2 id=&#34;本文&#34;&gt;本文
&lt;/h2&gt;&lt;p&gt;半月ほど前、ブログのスタイルシートを調整しました。長年バックエンドサービスの開発をしているのですが、フロントエンドは純粋な初心者です。前後とも半日かけて苦戦した結果、デザインがなかなか良くありませんでした。突然閃いて、よく読む技術ブログ（infoq、开源中国など）のデザインが良いなと思い、参考にしてみようと思いました。ソースコードを拝見し、関連する要素を特定しようとしましたが、霧だらけでした。&lt;/p&gt;
&lt;p&gt;フロントエンドの友人がこの部分を見ると笑ってしまうかもしれません。指定された要素を特定することも理解できません。理解する必要はありません。週末は時間があるから、立ち止まって考えればいいのです。以前、&lt;code&gt;python&lt;/code&gt; で爬虫（ウェブスクレイピング）を書いたときには、似たようなものを使っていたように思います。&lt;/p&gt;
&lt;h3 id=&#34;要素検査&#34;&gt;要素検査
&lt;/h3&gt;&lt;p&gt;そうです、ブラウザに標準搭載されている要素検査ツールを使って、スタイルシートをコピーしたり、指定した要素の位置を特定したりするのは、あっという間です。&lt;code&gt;selector&lt;/code&gt; で要素を特定したり、&lt;code&gt;hugo&lt;/code&gt; で &lt;code&gt;user define css&lt;/code&gt; を新規作成したりすることも可能です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;元素のコピー&lt;/li&gt;
&lt;li&gt;outerHTML のコピー&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;セレクタのコピー&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;JS パスのコピー&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;スタイルのコピー&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;XPath のコピー&lt;/li&gt;
&lt;li&gt;完整的 XPath のコピー&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Windowsプラットフォームで超大型ファイルを編集する：EmEditor (テキストエディタ)</title>
        <link>https://ttf248.life/ja/p/windows-platform-edit-large-files-emeditor-text-editor/</link>
        <pubDate>Sun, 31 Jul 2022 23:21:24 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/windows-platform-edit-large-files-emeditor-text-editor/</guid>
        <description>&lt;p&gt;上海国安数据库事件、在黑客圈子内闹得沸沸扬扬，不知真假，过两年如果还记得，再回头看看。根据以往的经验，更新了一波本地的社工数据库资料，看到一个巨型SQL文件：17.9G，一般的文本编辑器，预览都是个问题，更别说打开了，和网友闲聊，提到了：EmEditor。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;公式サイト：&lt;a class=&#34;link&#34; href=&#34;https://www.emeditor.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.emeditor.com/&lt;/a&gt;
週末に時間を割いて試してみたところ、非常に便利で、デザイン面でも大ファイル編集をサポートしており、十分なメモリがあれば、ファイル全体をメモリ上に読み込んで検索や編集速度が非常に速く、分割機能も利用できます。&lt;/p&gt;</description>
        </item>
        <item>
        <title>単なる簡単なことに追加のコードコピーボタンを実装する</title>
        <link>https://ttf248.life/ja/p/add-copy-button-for-simple-task/</link>
        <pubDate>Fri, 25 Feb 2022 01:23:39 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/add-copy-button-for-simple-task/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;「ouuan」を４時間も調べて、その時この文章を見ていると、まだ面白がっていて、どうしてこんなに時間がかかったのか不思議だった。最後に時間を調べると３時間だった。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;これは2022年の年初に書いた最初の記事で、扱うべきことは単純なもので、タイトル通り完全に同じ内容（当時としてはまだ若かった私）だと考えて、&lt;a class=&#34;link&#34; href=&#34;https://ouuan.github.io/post/from-hexo-to-hugo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;作业&lt;/a&gt;をそのままコピーしてブックマークに入れて、しばらく放置していました。ようやくこの件を思い出したのです。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hugo&lt;/code&gt;に移行する際、プラグインが少なすぎて、コードをコピーできず、多くのメモを印象派からブログに移行する際に、コードをコピーする作業が煩雑になり、私の水面下ブログのモチベーションを著しく低下させてしまいました。&lt;/p&gt;
&lt;h2 id=&#34;序章&#34;&gt;序章
&lt;/h2&gt;&lt;p&gt;まず、原作者の稿をじっくりと見直し、通読し、作者紹介も確認します。うわー、すごい大佬だ！清華大学で学んでいる学部生で、昔からコンピュータに触れているんだ。なるほど、クールなやつだ。まずはこのブログを確認し、自分が何をすべきか全く覚えていない。ついでに作者のGitHubリポジトリをチェックする。この修正された「even」テーマは今のよりずっと見栄えが良く、新しい機能もたくさんある。早速取り掛かり、関連コードをマージしよう。
&lt;img src=&#34;https://ttf248.life/p/add-copy-button-for-simple-task/2022-02-25-02-08-19.png&#34;
	width=&#34;215&#34;
	height=&#34;150&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;143&#34;
		data-flex-basis=&#34;344px&#34;
	
&gt; &lt;img src=&#34;https://ttf248.life/p/add-copy-button-for-simple-task/2022-02-25-02-08-40.png&#34;
	width=&#34;217&#34;
	height=&#34;167&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;129&#34;
		data-flex-basis=&#34;311px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;新機能記事の履歴表示関連提出記録の確認&#34;&gt;新機能：記事の履歴表示、関連提出記録の確認
&lt;/h3&gt;&lt;p&gt;効果はなかなか良く、記事末尾にスクロールすることで体験できます。
マージ前に作者の元のリポジトリの履歴を確認していなかったので、簡単なマージで済むと思っていましたが、最終的に大量のコードをマージし、その中に衝突やN回の巻き戻しが発生し、無脑覆盖（強制上書き）を行いました。それはすべてフロントエンドとレンダリングのテンプレートコードであり、私が使用するものに合わせました。
リポジトリ：&lt;a class=&#34;link&#34; href=&#34;https://github.com/TianlongXiang/hugo-theme-even&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/TianlongXiang/hugo-theme-even&lt;/a&gt;
中国語の罠です。&lt;code&gt;git&lt;/code&gt;でこのパラメータを調整しないと、生成される履歴リンクが現在の記事の&lt;code&gt;commit hash&lt;/code&gt;を取得できず、履歴リンクの生成に失敗します。完全な記事履歴を生成する際も、自動統合スクリプトを修正する必要があります。必ず現在のリポジトリ全体の履歴をプルしてください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/TianlongXiang/TianlongXiang.github.io/commit/0d860154de9b335ed88a57d62eedd4b6e3ccbeee&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;feat: 完全に GitHub リポジトリをプルして、記事の最終更新履歴を動的に更新&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/TianlongXiang/TianlongXiang.github.io/commit/1b5d719966737f16a8c67880370dc2722adea0b3&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;chore: パスに日本語が含まれているため、hugo GitInfo でこの設定を有効にする必要がある&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;name: Build Github
run: git config --global core.quotePath false &amp;amp;&amp;amp; hugo -b &amp;quot;https://www.xiangtianlong.com/&amp;quot; -d &amp;quot;github_public&amp;quot; &amp;amp;&amp;amp; ls
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;スタイル調整&#34;&gt;スタイル調整
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;サイトコンテンツの幅を調整します。以前のデザインはモバイルとPCの両方に対応していましたが、実際にスマートフォンでの閲覧はほとんどなく、私はPCで確認しています。&lt;/li&gt;
&lt;li&gt;目次バーを自動伸縮するように変更します。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;本文&#34;&gt;本文
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ouuan&lt;/code&gt;のコード記録を参考に半時間以上見てみても、コピーボタンの追加方法がよく分からなかった。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;時光穿梭，一月之后，又想到这事&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;今回この課題が理解できなかったため、別の課題をコピーし、必ずしも理解できるものにしました。検索で見つけた結果は、意外にも&lt;code&gt;hugo&lt;/code&gt;公式フォーラムにコードのコピーボタンを追加する方法についての投稿がありました。そこを拝見すると、論理が明確でわかりました。混乱していた状況でしたが、戻ってサイトを見ると&lt;code&gt;even&lt;/code&gt;レンダリング生成したコードブロックのスタイルと資料の説明が異なり、この部分は少し複雑です。簡単に記録しておきます。
基本的にはフロントエンド開発は理解していないため、わからない箇所はブラウザの「要素を検査」ツールを使ってコードを分析し、右側のスタイル情報に頼って徐々に論理を理解していきました。「JavaScript」についてはコンソールでログを出力しました。最初は多くのことがわからず、落ち着いて、少しずつ論理を整理・分割していき、必ずや解決策が見つかります。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;ノードが複数存在し、ここでは個々のコードブロックを指します。テーマが自動的に行番号を表示しており、その結果コピーボタンが2つ表示される&lt;/li&gt;
&lt;li&gt;テーマの組み込みされたコードハイライト機能を無効化したいのですが、このテーマの設定はよくわかりません。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hugo&lt;/code&gt;公式ドキュメントで資料を参照し、半ば理解しながら、コードハイライトを制御できる「markup」設定があることを知りました。&lt;/li&gt;
&lt;li&gt;設定ファイルを調整してもなかなかうまくいかず、レンダリング結果と期待値が異なっていた&lt;/li&gt;
&lt;li&gt;このような設定の「pygmentsOptions」を発見し、さらに資料を調べて設定を調整しました。まず行番号を削除する&lt;/li&gt;
&lt;li&gt;カスタムCSSスタイルシートとカスタムJavaScriptスクリプトを設定しました。&lt;/li&gt;
&lt;li&gt;結局これだけの作業をしたので、この文を見つけたときには、なぜこんなに時間がかかったのか笑ってしまいました。実際には3時間でした。最後に時間をを見ると：3時間。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;参考リンク&#34;&gt;参考リンク
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://ouuan.github.io/post/from-hexo-to-hugo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ouuan.github.io/post/from-hexo-to-hugo/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://gohugobrasil.netlify.app/content-management/syntax-highlighting/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://gohugobrasil.netlify.app/content-management/syntax-highlighting/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://gohugo.io/getting-started/configuration-markup#highlight&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://gohugo.io/getting-started/configuration-markup#highlight&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.dannyguo.com/blog/how-to-add-copy-to-clipboard-buttons-to-code-blocks-in-hugo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.dannyguo.com/blog/how-to-add-copy-to-clipboard-buttons-to-code-blocks-in-hugo/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>混沌エンジニアリング</title>
        <link>https://ttf248.life/ja/p/chaos-engineering/</link>
        <pubDate>Wed, 28 Jul 2021 14:35:07 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/chaos-engineering/</guid>
        <description>&lt;p&gt;システム安定性テストを行うための、システムを破壊するパターン。&lt;/p&gt;
&lt;h2 id=&#34;本文&#34;&gt;本文
&lt;/h2&gt;&lt;p&gt;国内的互联网行业总是喜欢折腾点新东西出来，有时候听到个名词，一般人都想不到它是什么东西？&lt;/p&gt;
&lt;p&gt;看了部分文章，还是这段针对混沌工程初期的定义，较为容易接受：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;混沌工程的早期探索，其实在行业内一直有，曾经是以故障测试、容灾演练等身份存在。而随着微服务架构的不断发展，以及分布式系统的不断庞大，混沌工程开始崭露头角，越来越被重视。当 Netflix 正式提出混沌工程概念后，相关理论也开始飞快丰富。Netflix 的实践也证明了混沌工程在稳定性领域所带来的巨大意义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;参照リンク&#34;&gt;参照リンク
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.infoq.cn/article/gsqtykoa3uvrtqi1kkmo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ByteDance 混沌工程実践まとめ&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>KubernetesでPodが停止しました。</title>
        <link>https://ttf248.life/ja/p/kubernetes-pause-pod/</link>
        <pubDate>Mon, 12 Jul 2021 11:23:09 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/kubernetes-pause-pod/</guid>
        <description>&lt;p&gt;デプロイメントコントローラは、Kubernetesクラスタにおいて非常に重要な機能であるPodの水平スケーリングと縮小を実現します。これは従来のクラウド時代プラットフォームが必須とする能力です。&lt;/p&gt;
&lt;p&gt;あるビジネスシーンで、データベース内のデータを修正する必要があり、修正後にPodノードを再起動します。しかし、Podが実行中に表のフィールドを継続的に変更する必要があるため、一時的にアプリケーションによるテーブルへの更新を停止し、データ修正後にPodを復旧する必要があります。&lt;/p&gt;
&lt;p&gt;削除以外の方法で、同様に一時停止の効果を実現する方法はありますか？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl scale --replicas=0 deployment/&amp;lt;your-deployment&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;回答を見る前に、多くの人が直接プロセスを操作する時代に思い当たり、ビジネスプロセスの直接操作を考えてしまうかもしれません。&lt;/p&gt;
&lt;h2 id=&#34;参照リンク&#34;&gt;参照リンク
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/54821044/how-to-stop-pause-a-pod-in-kubernetes&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Kubernetesでポッドを停止/一時停止する方法&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Dockerの基礎を理解するための３つのポイント (または、Dockerの基本を理解するための３つのこと)</title>
        <link>https://ttf248.life/ja/p/docker-two-three-things/</link>
        <pubDate>Thu, 21 Jan 2021 09:26:07 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/docker-two-three-things/</guid>
        <description>&lt;p&gt;長年携わってきたのは &lt;code&gt;CentOS&lt;/code&gt; オペレーティングシステムであり、&lt;code&gt;mac&lt;/code&gt; ユーザーや &lt;code&gt;Ubuntu&lt;/code&gt; ユーザーの場合、一部の内容は適用できない。
インストールに関する部分は、清華大学のドキュメントを参照するのが参考になる：&lt;a class=&#34;link&#34; href=&#34;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;インストール&#34;&gt;インストール
&lt;/h2&gt;&lt;p&gt;未知の神秘的な力により、国内でのDockerのインストールには、クラウドプロバイダーが提供するレジストリのアドレスを設定することを推奨します。ここでは&lt;strong&gt;Alibaba Cloud&lt;/strong&gt;を使用することをお勧めします。&lt;/p&gt;
&lt;h3 id=&#34;リポジトリソースの設定&#34;&gt;リポジトリソースの設定
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install yum-utils device-mapper-persistent-data lvm2 &amp;amp;&amp;amp; \
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;最新版のインストール&#34;&gt;最新版のインストール
&lt;/h3&gt;&lt;p&gt;Dockerは一般的なバックエンドサービスとして、起動時に自動で開始されるように設定することを推奨します。以下のコマンドはCentOS 7向けです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum install -y docker-ce docker-ce-cli containerd.io &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;指定バージョン展開&#34;&gt;指定バージョン展開
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;kubernetes&lt;/code&gt;および&lt;code&gt;docker&lt;/code&gt;のリリースは完全に同期されておらず、今後&lt;code&gt;kubernetes&lt;/code&gt;を展開する場合は、&lt;code&gt;kubernetes&lt;/code&gt;展開手順を参照し、指定バージョンの&lt;code&gt;docker&lt;/code&gt;をインストールしてください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum list docker-ce --showduplicates | sort -r
sudo yum install -y docker-ce-18.09.2-3.el7 docker-ce-cli-18.09.2-3.el7 containerd.io-18.09.2-3.el7 &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;通常ユーザーにdocker権限を追加する&#34;&gt;通常ユーザーにDocker権限を追加する
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo usermod -aG docker ${USER}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;卸載&#34;&gt;卸載
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum remove -y docker-ce docker-ce-cli containerd.io
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;日常使用-にちじょうしよう&#34;&gt;日常使用 (にちじょうしよう)
&lt;/h2&gt;&lt;h3 id=&#34;镜像加速&#34;&gt;镜像加速
&lt;/h3&gt;&lt;p&gt;未知の神秘的な力により、イメージの取得時に速度が低下することがあります。この問題を解決するために、国内のクラウドプロバイダーが多くの加速サービスを提供し、引き続き&lt;strong&gt;阿里云&lt;/strong&gt;を推奨します。&lt;/p&gt;
&lt;p&gt;加速用のURLは、ご自身の登録した阿里云アカウントで取得してください。このサービスは無料で利用でき、阿里云からは無料のイメージ構築サービスも提供されています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt; /etc/docker/daemon.json &amp;lt;&amp;lt;EOF
{
  &amp;quot;registry-mirrors&amp;quot;: [
    &amp;quot;https://docker.nju.edu.cn&amp;quot;,
    &amp;quot;https://mirror.baidubce.com&amp;quot;,
    &amp;quot;https://docker.m.daocloud.io&amp;quot;,
    &amp;quot;https://docker.mirrors.sjtug.sjtu.edu.cn&amp;quot;
  ]
}
EOF
systemctl daemon-reload &amp;amp;&amp;amp; \
systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;強く推奨されるコントロールパネル&#34;&gt;強く推奨されるコントロールパネル
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker volume create portainer_data &amp;amp;&amp;amp; \
docker run -d --name=portainer --restart=always -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:2.20.3-alpine
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;常用イメージの取得集&#34;&gt;常用イメージの取得集
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker pull rancher/rancher:stable &amp;amp;&amp;amp; docker pull portainer/portainer-ce:2.0.1 &amp;amp;&amp;amp; \
docker pull centos:7 &amp;amp;&amp;amp; docker pull ubuntu:20.04 &amp;amp;&amp;amp; docker pull ubuntu:18.04 &amp;amp;&amp;amp; \
docker pull redis:5 &amp;amp;&amp;amp; docker pull redis:6 &amp;amp;&amp;amp; \
docker pull alpine:3.11 &amp;amp;&amp;amp; docker pull busybox:1.32 &amp;amp;&amp;amp; \
docker pull rabbitmq:3.7-management &amp;amp;&amp;amp; \
docker pull mariadb:10.2 &amp;amp;&amp;amp; \
docker pull nginx:1.18 &amp;amp;&amp;amp; docker pull nginx:1.19 &amp;amp;&amp;amp; \
docker pull mysql:5.6 &amp;amp;&amp;amp; docker pull mysql:8 &amp;amp;&amp;amp; \
docker pull elasticsearch:6.8.11 &amp;amp;&amp;amp; docker pull logstash:6.8.11 &amp;amp;&amp;amp; docker pull kibana:6.8.11 &amp;amp;&amp;amp; \
docker pull zookeeper:3.4 &amp;amp;&amp;amp; \
docker pull influxdb:1.7 &amp;amp;&amp;amp; docker pull grafana/grafana:7.3.1 &amp;amp;&amp;amp; \
docker pull percona:8 &amp;amp;&amp;amp; docker pull percona:5.6 &amp;amp;&amp;amp; \
docker pull cloverzrg/frps-docker:0.34.3 &amp;amp;&amp;amp; docker pull cloverzrg/frpc-docker:0.34.3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;常用コマンドの組み合わせ&#34;&gt;常用コマンドの組み合わせ
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/engine/reference/commandline/docker/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.docker.com/engine/reference/commandline/docker/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;コンテナの実行状態を確認し、&lt;code&gt;format&lt;/code&gt;パラメータを追加して詳細なコンテナ情報を取得（イメージ情報は無視）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker ps --format &amp;quot;{{.Names}}: {{.Ports}}: {{.Size}}&amp;quot;
#portainer: 0.0.0.0:8000-&amp;gt;8000/tcp, 0.0.0.0:9000-&amp;gt;9000/tcp: 0B (virtual 172MB)
#influxdb: 0.0.0.0:8086-&amp;gt;8086/tcp: 183B (virtual 311MB)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;すべてのコンテナをワンクリックで停止&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker stop $(docker ps -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;すべてのイメージをワンクリックで削除&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dokcer rmi $(docker images -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;イメージのエクスポート&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; &amp;gt; -o XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;イメージをエクスポートして圧縮&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; | gzip &amp;gt; XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;イメージをインポート&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker load -i XXX.tar
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>LinuxでJMeterの負荷テスト環境を構築する</title>
        <link>https://ttf248.life/ja/p/linux-setup-jmeter-testing-environment/</link>
        <pubDate>Tue, 22 Dec 2020 10:12:50 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-setup-jmeter-testing-environment/</guid>
        <description>&lt;p&gt;著者はハードウェアに強い関心を持ち、JMeterを用いて負荷テストを実施し、CentOS 7上にJMeter、InfluxDB、Grafanaをデプロイするプロセスを記録しました。JMeterのインストールとコマンドの使用方法、InfluxDBの特徴とDockerによるインストール方法、Grafanaの簡易的なデプロイと設定について共有しています。高性能プログラムモードに関する経験や参考資料をまとめました。&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;広く知られているように&lt;/code&gt;、私にはハードウェアに対する強い関心が持っており、テストグループが &lt;code&gt;JMeter&lt;/code&gt; を使用して負荷テストを行っている際に、パフォーマンスが向上しないことを発見しました。好奇心旺盛な私は、会社の負荷テストの方法を試してみることに決意しました。また、ある頃合いにオープンソース中国で、より洗練された高性能のパフォーマンス測定グラフを作成する方法に関する投稿を読んだことがあります。&lt;code&gt;Windows&lt;/code&gt;版でのテスト実行時に、可視化された &lt;code&gt;TPS&lt;/code&gt; データの表示を実現しており、Webパネルを設定することでどのような効果があるのか疑問に思っていました。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;頭の中で思いついたのは、当然のことばかりです。実際に試してみないとしかたないことを理解します。
負荷テストには GUI モードを使用しないでください！ テスト作成とデバッグのみに使用してください。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;背景-1&#34;&gt;背景
&lt;/h2&gt;&lt;p&gt;公式推奨は、コマンドラインで負荷テストレポートを取得し、GUIで表示する方法ですが、データに誤差が含まれているという問題があります。JMeterの理解が十分ではないため、少なくとも&lt;code&gt;Linux&lt;/code&gt;版のコンソールパネルを弄り転げる理由を見つけたいと思います。&lt;/p&gt;
&lt;p&gt;開かれた中国（オープンチャイナ）の投稿では、コアコンポーネントのデプロイメント方法があまりにも友好的ではなく、インストールに必要なファイルは公众号を通じてダウンロードする必要があり、現代的な若者として、もちろん&lt;code&gt;Docker&lt;/code&gt;で代替します。要するに、サーバーは国内であり、国境を越えたソースアドレスへのアクセス速度が遅いため、少なくともイメージサービスとしては、阿里云には無料の加速があります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker&lt;/code&gt; のインストールとデプロイメントについては、ここでは詳細な説明を省略し、以前の記事を参照してください。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;次の内容は、2つの主要な領域に分かれています：基本的なテスト環境コンポーネントの構築、および各コンポーネントの簡単な認識の説明&lt;/p&gt;
&lt;h2 id=&#34;jmeter&#34;&gt;JMeter
&lt;/h2&gt;&lt;p&gt;Apache JMeterはApache組織が開発したJavaベースの負荷テストツールです。ソフトウェアに対する負荷テストに使用され、当初はWebアプリケーションのテスト用に設計されましたが、その後、他のテスト分野にも拡張されています。静的および動的なリソース（静的ファイル、Java小型サービスプログラム、CGIスクリプト、Javaオブジェクト、データベース、FTPサーバーなど）をテストするために使用できます。JMeterは、さまざまな負荷カテゴリからの巨大な負荷をシミュレートして、それらの強度をテストし、全体的なパフォーマンスを分析するために使用できます。さらに、JMeterはアプリケーションの機能/回帰テストに使用でき、断言を含むスクリプトを作成することで、プログラムが期待どおりの結果を返していることを検証します。最大限の柔軟性のため、JMeterは正規表現を使用して断言を作成することを許可しています。&lt;/p&gt;
&lt;p&gt;Apache jmeter は、静的および動的なリソース（ファイル、Servlet、Perlスクリプト、Java オブジェクト、データベースとクエリ、FTPサーバーなど）のパフォーマンスをテストするために使用できます。 サーバー、ネットワーク、またはオブジェクトに過剰な負荷をシミュレートして、それらの強度をテストしたり、さまざまなストレスタイプの下での全体的なパフォーマンスを分析したりすることができます。 大規模な同時負荷テストでサーバー/スクリプト/オブジェクトのパフォーマンスを分析したり、グラフィカルなパフォーマンス分析を行ったりするために使用できます。&lt;/p&gt;
&lt;h3 id=&#34;jmeter-導入-centos7&#34;&gt;Jmeter 導入 CentOS7
&lt;/h3&gt;&lt;p&gt;JDK の実行環境をインストールし、JMeter のインストールパッケージをダウンロードします。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install java-1.8.0-openjdk -y &amp;amp;&amp;amp; \
wget https://mirrors.bfsu.edu.cn/apache//jmeter/binaries/apache-jmeter-5.4.tgz &amp;amp;&amp;amp; tar -xf apache-jmeter-5.4.tgz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;環境変数を設定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export JMETER_HOME=$HOME/jmeter/apache-jmeter-5.4
export PATH=$JMETER_HOME/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;jmeter-コマンド&#34;&gt;JMeter コマンド
&lt;/h3&gt;&lt;p&gt;最後に &lt;code&gt;Grafana&lt;/code&gt; ダッシュボードに送信し、&lt;code&gt;-l&lt;/code&gt; パラメータを入力しなくても、&lt;code&gt;web&lt;/code&gt; コンソールでデータを観察できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;jmeter -n -t /tmp/order-500-10s.jmx -l /tmp/jmeter-order-report-20200109/order-500-10s.jtl
# 通常、テスト結果とテストレポートは省略し、コマンドを簡略化します。
jmeter -n -t /tmp/order-500-10s.jmx
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;influxdb&#34;&gt;InfluxDB
&lt;/h2&gt;&lt;p&gt;InfluxDBは、Go言語で記述されたオープンソースの分散型時系列、イベント、指標データベースです。外部依存なしで動作します。このデータベースは現在、大量の時間スタンプデータ（DevOpsモニタリングデータ、APPメトリクス、IoTセンサーデータ、リアルタイム分析データなど）を保存するために主に利用されています。&lt;/p&gt;
&lt;h3 id=&#34;influxdbの特徴&#34;&gt;InfluxDBの特徴
&lt;/h3&gt;&lt;p&gt;InfluxDBの特徴は、以下の9点にまとめられます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非構造化（非モデリング）：任意の数の列を含めることができます。&lt;/li&gt;
&lt;li&gt;メトリクスの保存期間を設定できます。&lt;/li&gt;
&lt;li&gt;時間に関連する関数（min、max、sum、count、mean、medianなど）をサポートし、統計分析が容易です。&lt;/li&gt;
&lt;li&gt;ストアポリシーのサポート：データの削除および変更に使用できます。（InfluxDBはデータの削除と変更の方法を提供していません。）&lt;/li&gt;
&lt;li&gt;連続クエリのサポート：データベース内で自動的にスケジュールされたステートメントのセットであり、ストアポリシーと組み合わせてInfluxDBのシステム使用量を削減できます。&lt;/li&gt;
&lt;li&gt;ネイティブなHTTPサポート、組み込みHTTP API。&lt;/li&gt;
&lt;li&gt;SQLライクな構文をサポート。&lt;/li&gt;
&lt;li&gt;クラスタ内のデータのレプリカ数を設定できます。&lt;/li&gt;
&lt;li&gt;定期的なサンプリングデータによる別の測定項目の書き込みをサポートし、粒度ごとのデータを保存できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;influxdb-docker-インストール&#34;&gt;InfluxDB Docker インストール
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir influxdb &amp;amp;&amp;amp; cd influxdb &amp;amp;&amp;amp; \
docker run -p 8086:8086 -d --name influxdb -v $PWD:/var/lib/influxdb influxdb:1.7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker exec -it influxdb /bin/bash&lt;/code&gt; でコンテナに入り、コマンドを実行し、手動でデータベースを作成&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;root@bce0a55bbc72:/# influx
http://localhost:8086 への接続、バージョン 1.7.10
InfluxDB シェル バージョン：1.7.10
&amp;gt; 対話式パネルでコマンドを実行
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;influxdbデータベースとユーザーの作成&#34;&gt;InfluxDBデータベースとユーザーの作成
&lt;/h3&gt;&lt;p&gt;データベースの作成: &lt;code&gt;create database jmeter_t2&lt;/code&gt;
データベースの表示: &lt;code&gt;show databases&lt;/code&gt;
データベースの切り替え: &lt;code&gt;use jmeter_t2&lt;/code&gt;
ユーザーの作成: &lt;code&gt;create user &amp;quot;admin&amp;quot; with password &#39;admin&#39; with all privileges&lt;/code&gt;
ユーザーの表示: &lt;code&gt;show users&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; show users
user  admin
----  -----
admin true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ユーザー権限が&lt;code&gt;admin&lt;/code&gt;で&lt;code&gt;true&lt;/code&gt;と表示されれば、データベースの準備は完了です。&lt;/p&gt;
&lt;h2 id=&#34;grafana&#34;&gt;Grafana
&lt;/h2&gt;&lt;p&gt;テストケースの作成時に、グラフによる表現はあまり必要ないことがわかりました。インターフェースの &lt;code&gt;tps&lt;/code&gt; データのコマンドライン実行で十分観測できます。むしろ、プログラム内部の処理時間を確認したいと考えています。&lt;/p&gt;
&lt;p&gt;Grafana の簡易的なコンソールパネルをデプロイし、InfluxDB と連携するための設定ファイルをインポートします。&lt;/p&gt;
&lt;p&gt;コンソールはラベルによるフィルタリングをサポートしており、通常は 1 つの InfluxDB データベースを設定するだけで済みます：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アプリケーション名&lt;/li&gt;
&lt;li&gt;テストケース名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/linux-setup-jmeter-testing-environment/Snipaste_2021-03-09_19-44-22.png&#34;
	width=&#34;861&#34;
	height=&#34;357&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;grafana&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;241&#34;
		data-flex-basis=&#34;578px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -d --name=grafana -p 3000:3000 grafana/grafana:7.3.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ブラウザ版ではサンプリング間隔により、計算された &lt;code&gt;TPS&lt;/code&gt; や関連数値が JMeter の集計レポートと一致しないため、参照リンク：&lt;a class=&#34;link&#34; href=&#34;https://www.vinsguru.com/jmeter-real-time-results-influxdb-grafana/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.vinsguru.com/jmeter-real-time-results-influxdb-grafana/&lt;/a&gt; を参考にしています。&lt;/p&gt;
&lt;p&gt;資料には、リスナーのカスタム設定方法も記載されています。&lt;/p&gt;
&lt;h2 id=&#34;付録&#34;&gt;付録
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;高性能のプログラムパターンは、必然的にone loop threadであるべきであり、ロック、入隊列、出隊列などのものは、不必要なパフォーマンス損失を引き起こす&lt;/li&gt;
&lt;li&gt;核心ビジネスロジックの実行時間が、他のコードを導入する時間よりも大きい場合のみ、並行処理が有効に効率を向上させることができ、コアな実行時間が十分に小さい場合は、慎重に他のコードを導入すべき&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考資料&#34;&gt;参考資料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://my.oschina.net/u/4617935/blog/4680856&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;JMeterシリーズのJMeter+Grafana+InfluxDB リアルタイム監視&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/_/influxdb&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;influxdb 公式イメージ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/r/grafana/grafana&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;grafana 公式イメージ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://jmeter.apache.org/download_jmeter.cgi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;JMeter 公式サイト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@jasonli.studio/to-install-apache-jmeter-in-centos7-294bc72a97ba&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CentOS7にApache JMeterをインストールする方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Red Hat と CentOS のライフサイクル</title>
        <link>https://ttf248.life/ja/p/redhat-centos-lifecycle/</link>
        <pubDate>Tue, 21 Jul 2020 20:02:35 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/redhat-centos-lifecycle/</guid>
        <description>&lt;p&gt;オンラインプロ덕ション環境のオペレーティングシステムとして、Red HatとCentOSが主流の選択肢です。2つのシステムのライフサイクルに関する公式サイトへのリンクを記録し、CentOS 8からCentOS 8 Streamへのアップグレード経験を共有しています。&lt;/p&gt;
&lt;h2 id=&#34;はじめに&#34;&gt;はじめに
&lt;/h2&gt;&lt;p&gt;オンプレミス（本番環境）のオペレーティングシステムですが、現在の国内環境においては、Red HatとCentOSが主流の選択肢です。2年前にはRed Hat 6のEOL（End of Life）を迎えたため、両システムのライフサイクルに関する公式ウェブサイトへのリンクを記録します。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://access.redhat.com/support/policy/updates/errata&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Red Hat Enterprise Linux 生命周期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://wiki.centos.org/zh/About/Product&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CentOS 产品规范&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Red Hat Enterprise Linux（RHEL）および CentOS は、エンタープライズ向けの主要なサーバーオペレーティングシステムです。RHEL は安定したサポートと更新サイクルを提供し、エンタープライズアプリケーションに適しています。CentOS は RHEL のコミュニティ版であり、同様の機能と安定性を提供しますが、公式なサポートはありません。&lt;/p&gt;
&lt;h2 id=&#34;追記&#34;&gt;追記
&lt;/h2&gt;&lt;p&gt;この記事を執筆した時点では、2年後に自分が更新することなど想像もしていませんでした。先日、普段使っている仮想マシンをCentOS 8からCentOS 8 Streamにアップグレードしました。本番環境で何を選ぶかは、お話するのが難しいので、ここでは触れません。ローカル環境は最新版を追求します。&lt;/p&gt;
&lt;p&gt;CentOS 8 Streamは、従来のCentOSよりも迅速なアップデートと新機能を提供する、継続的リリース版であり、開発やテスト環境での利用に適しています。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>PC自作のあれこれ</title>
        <link>https://ttf248.life/ja/p/computer-assembly/</link>
        <pubDate>Sat, 18 Jul 2020 14:33:46 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/computer-assembly/</guid>
        <description>&lt;p&gt;著者は幼い頃からPCの組み立てに興味を持ち、大学卒業後に本格的にハードウェアの組み立てを始めました。彼は、CPU、SSD（ソリッドステートドライブ）、HDD（ハードディスクドライブ）やメモリのクロック周波数など、各パーツの性能比較サイトを紹介し、購入に関するアドバイスも行いました。また、ハードウェア選びでの経験談や注意点なども共有しました。&lt;/p&gt;
&lt;h3 id=&#34;縁語り尽くせぬもの&#34;&gt;縁・語り尽くせぬもの
&lt;/h3&gt;&lt;p&gt;幼い頃から、自分だけのコンピュータを組み立てたいと考えていた。しかし、経済的な条件が許さなかった。ようやく大学に上ると、持ち運びやすいため、構成したのはノートパソコンだった。もし具体的な時期を挙げるとすれば、自分が組立てることを思い始めたのは、故郷の図書館でさえあっただろう。毕竟これは市区レベルの図書館であり、電子閲覧室（実際にはほとんど行ったことがなく、時間課金制だという）や雑誌閲覧室（まさにここで『大众软件』、『电脑报』のような雑誌を読み、コンピュータにあまり触れていなかった私にとって、神に近い科普資料だった）があったからだ。打副本の章节を見て自分もコンピュータを組んで、モンスターを倒し、主力として出力することを考えたし、黒科技を見て本の内容通りに再現できると夢を見た（ハッキングツールの使用について）。もちろん高校では勉強が忙しく、当時の私の認知能力では、読書も遊びも両方楽しむ必要があった。そうした「天真爛漫」な日々を過ごし、図書館へ行くという由縁を作った。特に何もすることがない時、小さな袋を提げてそこへ向かい、市区はそれほど大きくなく、ほとんどが徒歩で図書館へ行った。到着すると空調の効いた部屋で小説、漫画、ゲーム雑誌を見たり、時には真面目な本も読んだりした。&lt;/p&gt;
&lt;p&gt;年を取ると忘れっぽくなるのが普通だ。図書館で生まれたものが初めだったのかもしれない。中学校の頃には、親戚がコンピュータを組み立てていたが、当初その機械は何に使われたのか覚えていない。オペレーティングシステムはWindows 2003で、ゲームは標準搭載のカード＋帝国時代があった。様々な「斗智斗勇」な考えで鍵を盗み、甥っ子と一緒にゲームをした。&lt;/p&gt;
&lt;p&gt;初等学校に入ると学校でコンピュータの基礎的なトレーニングを受けた後、転校し、コンピュータ競技会についても少し知識を得た。そして高校ではNOIPに合格した。ここで言及するのは、校友たちの力だ。高校のコンピュータ棟は校友たちからの寄付によって建てられたもので、コンピュータ教育室と図書館が含まれていた。これは当時、国内インターネット浪潮の初期の波だった。校長もコンピュータ競技会への参加を支援し、前2学年の先輩たちが数名、コンピュータを通じて重点大学に合格していたからだ。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;これまでこのようなことを振り返ったことはなかった。そうはならないのは当然だろう。卒業後、私は自動化専攻を義無反顧的にコンピュータ業界に転身したが、種はすでに植えられていた。局中の人は自分の状況を知らないだけだった。幼い頃から多くのものに触れていたため、自分がとても優秀だと思っていたが、実際には表面的な知識しか持っていなかった。最大の強みは最初の情熱だった。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;硬件组装&#34;&gt;硬件组装
&lt;/h3&gt;&lt;p&gt;PCバカ、chiphell、知乎のPC自作の板を逛逛し、萌新でも比較的簡単に自分に必要な機材リストを作成できます。2019年以降にCPUを選ぶ場合、経済的な条件が限られている場合は、より高い性能を得るためにAMDを優先的に選びます。
一般的なハードウェア性能比較サイトをご紹介します：&lt;a class=&#34;link&#34; href=&#34;https://cpu.userbenchmark.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cpu.userbenchmark.com/&lt;/a&gt;　価格に関しては、eBayの米版と咸鱼（中国版ヤフオク）で比較するのが良いでしょう。真の達人であれば、咸魚で中古品を探すことも可能です。大幅に安く購入できます。あまりPCに詳しくない場合は、咸魚は推奨しません。私は偽メモリを購入しましたが、現状使用しても問題がないようです。詳細は不明で、型番とパラメータが完全に一致していません。&lt;/p&gt;
&lt;h4 id=&#34;sn550-vs-sn750&#34;&gt;SN550 VS SN750
&lt;/h4&gt;&lt;p&gt;SN550とSN750の1TB容量の違いは、両者の継続的な読み書き速度が倍になることです。SN550では850MB、SN750では1.6GBですが、日常使用においては違いを感じられません。これは両者が4K性能において同じであるためです。もちろん、ここで言うSN550は1TB容量のものです。500Gや250Gの容量では、順応読み書き速度がより遅くなります。実際には、お金を惜しまないわけではない限り、日常使用であればSN550を購入するのが良いでしょう。私がこのモデルを選ばなかった主な理由は、その容量が最大1TBであることと、SN750が2TB容量を持つことです。私にとって、追加の拡張なしに、マザーボードのM.2 NVMeインターフェースの方がより価値があると感じたからです。&lt;/p&gt;
&lt;p&gt;総じて、ネットユーザーの結論として、B150のマザーボードでもM.2インターフェースに対応したSSDを導入することができます。&lt;/p&gt;
&lt;h4 id=&#34;机械硬盘選购&#34;&gt;机械硬盘選购
&lt;/h4&gt;&lt;p&gt;機械硬盘現在價格趨於穩定，對於有大量儲存需求的使用者，需要選購一款合適的機械硬盘，頻繁下載資源的使用者推薦企業級硬盘，常見的有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;西數金盤&lt;/li&gt;
&lt;li&gt;希捷Exos
&lt;strong&gt;大容量的機械硬盘推薦進行分区，頻繁的下載操作固定在某个分区進行，日後出現壞道，可以集中在某个分区，廢棄當前分区即可，能有效延長機械硬盘寿命。&lt;/strong&gt;
希捷系列&lt;a class=&#34;link&#34; href=&#34;https://www.seagate.com/cn/zh/enterprise-storage/exos-drives/exos-e-drives/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方介紹&lt;/a&gt;
&lt;img src=&#34;https://ttf248.life/p/computer-assembly/%E5%B8%8C%E6%8D%B7exos1.png&#34;
	width=&#34;589&#34;
	height=&#34;659&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;希捷企業級硬盘概述&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;89&#34;
		data-flex-basis=&#34;214px&#34;
	
&gt;
&lt;img src=&#34;https://ttf248.life/p/computer-assembly/%E5%B8%8C%E6%8D%B7exos2.png&#34;
	width=&#34;588&#34;
	height=&#34;661&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;希捷企業級硬盘概述&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;88&#34;
		data-flex-basis=&#34;213px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;メモリ周波数&#34;&gt;メモリ周波数
&lt;/h4&gt;&lt;p&gt;日常業務の観点から見ると、周波数はパフォーマンスに大きな影響を与えません。
&lt;a class=&#34;link&#34; href=&#34;%e3%83%a1%e3%83%a2%e3%83%aa.png&#34; &gt;メモリ時系列画像&lt;/a&gt; &lt;a class=&#34;link&#34; href=&#34;%e5%92%b8%e9%ad%9a%e3%83%a1%e3%83%a2%e3%83%aa.png&#34; &gt;咸鱼メモリ画像&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;メモリ時系列（英語：Memory timingsまたはRAM timings）は、シリアル・ダイナミック・ランダム＝アクセスの記憶装置（SDRAM）のパフォーマンスを記述する4つのパラメータです。CL、TRCD、TRP、およびTRASで、クロックサイクル単位で測定されます。これらのパラメータは通常、破折号で区切られた4桁の数字として記述されます（例：7-8-8-24）。第4パラメータ（RAS）は頻繁に省略され、場合によっては5番目のパラメータであるコマンドレート（命令レート）が追加されることがあります。これは通常2Tまたは1Tで、2N、1Nと表記されます。これらのパラメータは、ランダムアクセスメモリの速度に影響を与える潜伏時間（遅延時間）を指定します。数字が低いほど、一般的にパフォーマンスは向上します。&lt;/p&gt;
&lt;p&gt;システム性能を決定する最終的な要素は、実際の遅延時間です。これは通常ナノ秒単位で測定されます。&lt;/p&gt;
&lt;p&gt;メモリ時系列を実際の遅延時間に変換する場合、クロックサイクル単位であることに注意することが重要です。クロックサイクルの時間を知らない場合、2つの数字のセットがどちらがより速いかを判断することはできません。&lt;/p&gt;
&lt;p&gt;たとえば、DDR3-2000 メモリのクロック周波数は1000 MHzで、そのクロック周期は1 nsです。この1 nsのクロックに基づいて、CL=7 が与えられた絶対遅延は7 ns です。より高速な DDR3-2666（クロック 1333 MHz、各サイクルあたり 0.75 ns）では、より大きな CL=9 を使用できますが、生成される絶対遅延は 6.75 ns となります。&lt;/p&gt;
&lt;p&gt;現代の DIMM には、自動構成を推奨するシリアル存在検出 (SPD) ROM チップが含まれています。PC の BIOS は、パフォーマンスを向上させるためにユーザーがメモリ時系列を調整できるように（安定性にリスクがある）、または特定の状況で安定性を高めるために（推奨された時系列を使用するなど）許可することがあります。&lt;/p&gt;
&lt;p&gt;注：メモリ帯域幅は、メモリの透過量（スループット）を測定し、通常は転送レートによって制限されます。複数の内部バンクに並行して SDRAM にアクセスすることで、ピークレートで連続的にデータを転送できます。潜伏時間を増やすことで帯域幅を増加させる可能性があります。具体的には、各新しい DDR メモリ世代には高い転送レートがありますが、絶対遅延はほとんど変化しません。特に市場に出回った最初の新世代製品では、前世代よりも遅延が長くなる傾向があります。&lt;/p&gt;
&lt;p&gt;メモリの遅延が増加しても、メモリ帯域幅を増やすことで、マルチプロセッサまたは複数の実行スレッドを持つコンピュータシステムのパフォーマンスを向上させることができます。より高い帯域幅は、専用ビデオメモリのない統合グラフィックス カードのパフォーマンスも向上させます。
&lt;a class=&#34;link&#34; href=&#34;%e3%83%a1%e3%83%a2%e3%83%aa%e6%99%82%e5%ba%8f%e5%8f%82%e6%95%b0%e8%af%b4%e6%98%8e.png&#34; &gt;メモリ時系列パラメータの説明画像&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;参考文献&#34;&gt;参考文献
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E6%97%B6%E5%BA%8F&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;メモリ時系列パラメータに関する説明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>ウェブサイトの高速化とドメイン設定</title>
        <link>https://ttf248.life/ja/p/website-acceleration-and-domain-setup/</link>
        <pubDate>Sat, 20 Jun 2020 10:36:27 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/website-acceleration-and-domain-setup/</guid>
        <description>&lt;p&gt;境内アクセス時のGitHub Pagesの速度が遅いため、著者が個人ドメインを取得し、国内クラウドホスティングプロバイダーのCDN加速サービスを購入しました。設定中に、wwwサフィックスドメインへのアクセスができない問題が発生しましたが、最終的に汎用ドメインのDNS解析を削除し、セカンドレ벨ドメインを個別に設定することで解決しました。著者はまた、CDN加速の原理と設定経験、およびNginxを用いた逆プロキシの試みと教訓についても共有しています。&lt;/p&gt;
&lt;h3 id=&#34;背景&#34;&gt;背景
&lt;/h3&gt;&lt;p&gt;ウェブサイトはGitHub Pagesにホストされており、周知のところ、GitHub Pagesへの国内アクセスが遅いことがありました。そこで個人ドメインを取得し、国内クラウドホスティングプロバイダーのCDN加速サービスを購入しました。加速サービスのセットアップ時に、開発マシンにもDocker、frp、k8sなどのサービスをデプロイしており、これらのサービスにはそれぞれダッシュボードが用意されていることを思い出し、無駄を省くという原則に基づき、複数のリバースプロキシを設定し、すべてサブドメインに付与しました。
その時、サブドメインであるwwwがアクセスできなくなったことに気づきました。阿里云でDNS設定を行い、www.xiangtianlong.comとxiangtianlong.comの両方を解析するように設定しましたが、CDN加速を有効にしていないときは両方のドメインが正常に使用できました。
CDN加速を設定した際、サブドメインが多数存在するため、汎用的なルールを有効にし、すべて開発マシンにルーティングしました。その結果、wwwというサブドメインもダウンしてしまいました。はい、正しく理解してくださいましたか？wwwプレフィックスはサブドメインです。実際にはウェブサイトはGitHub Pagesにデプロイされており、開発マシンにはウェブサイトのキャッシュ情報は一切ありません。
開発マシンにサイトをデプロイしなかったのは、静的ブログであり、GitHubが提供するActionで自動的に統合して公開されるため、本当に美味しかった（真香）からです。&lt;/p&gt;
&lt;h3 id=&#34;ドメイン&#34;&gt;ドメイン
&lt;/h3&gt;&lt;p&gt;非専門的なWeb開発において、ドメインの理解はSEOやクロスオリジン問題といった概念を含まない。ブログサイトとして、裸ドメインがブログ主のサイトを強調しやすく、特に私が漢数字でのローマ字表記をドメイン名としている場合や、現在のモバイルアクセスが多い状況では、入力する文字数を減らすことが望ましい。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PC版ではキーボードショートカットでwwwとcomの入力を省略可能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;cdn&#34;&gt;CDN
&lt;/h3&gt;&lt;p&gt;阿里云和腾讯云都用过，初心者でも扱いやすく、腾讯云には動画で関連概念を解説しています。CDN加速の原理は、京东倉庫と似ています。新商品が出版される際、全国各地の倉庫にまとめて配送し、配送リクエストが発生した際に、最も近い倉庫から配信します。&lt;/p&gt;
&lt;p&gt;キャッシュサーバー（回源アドレス）：ウェブサイトのリソースが元の場所で保存されている場所
キャッシュファイルの設定：ブラウザのF12で管理コンソールを開き、静的リソースと動的リソースを分析する&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全て0日有効期限&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.php;.jsp;.asp;.aspx&lt;/code&gt; 0日有効期限&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.jpg;.png;.js;.css;.woff2&lt;/code&gt; 1日有効期限&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;腾讯云設定ルール：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;キャッシュ过期ルールは最大10件まで設定可能&lt;/li&gt;
&lt;li&gt;複数のキャッシュ过期ルール間の優先順位は、下から上にいくほど高い&lt;/li&gt;
&lt;li&gt;キャッシュ过期時間は最大365日まで設定可能&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;悲惨自述&#34;&gt;悲惨自述
&lt;/h3&gt;&lt;p&gt;以前从未用过Nginx，以为网站随便搜索就能明白反向代理的配置，结果有点混乱，折腾半天连个302跳转也没弄明白，最终毫无用处。就想着笨办法解决一下，DNS解析删除*模式的泛域名解析，单个二级域名进行独立设置。这时突然注意到了阿里云DNS解析有一个叫做“显示URL跳转”的模式，尝试了一下，这不就是我想要的302跳转吗。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设置了第一个二级域名正常访问，等我设置第二个的时候，发现没用，都快怀疑人生了，等了一会突然就能用了，看来阿里云的DNS扩散偶尔也是会抽风的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;参考資料&#34;&gt;参考資料
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/question/20414602&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;なぜ多くのウェブサイトのドメイン名に「www」プレフィックスが付加されないのか？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cloudxns.net/Support/detail/id/918.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;www付きとそうでないドメイン名の違いは何ですか？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://gythialy.github.io/Docker-nginx-reverse-proxy/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Docker nginx 反向プロキシ設定&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>ブログIDE環境と雑感</title>
        <link>https://ttf248.life/ja/p/blog-ide-environment-and-ramblings/</link>
        <pubDate>Tue, 31 Mar 2020 13:54:27 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/blog-ide-environment-and-ramblings/</guid>
        <description>&lt;p&gt;本記事では、Markdownの基本的な概念と、さまざまなソフトウェアでの利用について紹介しています。VSCodeをIDEとして推奨し、おすすめプラグインも列挙しています。作者はHexoからHugoへの移行経験を共有し、Hugoの柔軟性とカスタマイズ性を強調しています。最後に、新しい技術を迅速に習得するためのヒントや、Hugoテーマのスタイルが更新されない問題を解決する簡単なコツを紹介します。&lt;/p&gt;
&lt;h2 id=&#34;はじめに&#34;&gt;はじめに
&lt;/h2&gt;&lt;h3 id=&#34;markdown&#34;&gt;Markdown
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;軽量マークアップ言語であり、人間が読み書きしやすいプレーンテキスト形式でドキュメントを作成することを可能にする。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;markdown-1&#34;&gt;Markdown
&lt;/h3&gt;&lt;p&gt;詳細なMarkdown構文については、本文で別途詳述しません。電子書籍を推奨します。&lt;a class=&#34;link&#34; href=&#34;https://markdown-zh.readthedocs.io/en/latest/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;こちらをクリック&lt;/a&gt;
市場には多くのソフトウェアがMDを記述方法としてサポートしています。CSDNのブログシステムはMD構文に対応したオンラインエディターを導入しており、初回使用時にデフォルトでMD構文に関する紹介記事が表示されます。筆記者自身もそれなりに有用だと感じています。印象笔记では2018年にMDノートのサポートを追加し、ショートカットバーには様々なMDマークアップのオプションがあり、普通の文章を編集するのとほぼ同じように使えます。全体的なインタラクションフローは初心者にもフレンドリーです&lt;/p&gt;
&lt;h3 id=&#34;ide-推奨&#34;&gt;IDE 推奨
&lt;/h3&gt;&lt;p&gt;この記事を書いているのは2020年であり、VS Code は当然のことながら皆知っているでしょう。なぜなら、Git Page をブログシステムとして構築することを考える業界人は少なくないからです。数年前には、Sublime や Atom も優れた選択肢でした。オープンソースコミュニティの推進により 2 年間にわたって発展し、現在では VS Code が初心者にとっての最初の選択肢となっています。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Microsoft の巨頭とオープンソースコミュニティの関係は、対立状態から成功裏に蜜月期に入りました：オープンソースを抱擁しています。筆者所在の会社も最近 2 年間にわたり積極的に Java エコシステムを取り入れており、ビジネス開発においては、現在国内で Java エコシステムはまさに「魅力的」です。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;vscodeプラグインのおすすめ&#34;&gt;VSCodeプラグインのおすすめ
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/blog-ide-environment-and-ramblings/2020-03-31-14-07-17.png&#34;
	width=&#34;310&#34;
	height=&#34;306&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;プラグインリスト&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;101&#34;
		data-flex-basis=&#34;243px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;プラグインにはそれぞれReadmeがあり、基本的な使い方や主要な機能が紹介されています。一部のプラグイン作者は、動的な効果を表示する画像も提供しています。
&lt;code&gt;Paste Image&lt;/code&gt;とhugoの画像プラグイン方式を組み合わせることで、非常に簡単に画像を挿入できます。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ショートカットキーを忘れてしまった場合、VSCodeのショートカットキー管理メニューを開き、「md」で検索して数回確認しましょう。Readmeをもう一度見直すのも良いでしょう。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;hugo&#34;&gt;Hugo
&lt;/h2&gt;&lt;p&gt;筆者は&lt;code&gt;hexo&lt;/code&gt;から&lt;code&gt;hugo&lt;/code&gt;に切り替えた。愛折衝は私の天性であり、結局は忍耐強く静かに記事を書くことができないのだ。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Hugoは、個別のフォルダに画像とmdドキュメントを置くことをサポートする。&lt;/li&gt;
&lt;li&gt;Academicテーマのデザイン上では、様々な種類の文章スタイルをサポートしている。&lt;/li&gt;
&lt;li&gt;様々な便利なカスタム拡張機能がある。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;学術&#34;&gt;学術
&lt;/h2&gt;&lt;p&gt;公式サイトではデフォルトで&lt;code&gt;exampleSite&lt;/code&gt;を使用し、メニューのインポートには&lt;code&gt;#component&lt;/code&gt;形式が推奨されます。URLのパターンは、ナビゲーションバーをクリックすることで単一ページのジャンプを実現し、ホームページでのスクロールを回避します（これは純粋な個人的な好みです）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;スタイル：ノート、講演、電子書籍&lt;/li&gt;
&lt;li&gt;柔軟性：全体的なスタイルのカスタマイズ、カスタムCSSスタイルの適用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このテーマは、中国語のサポートがまだ十分ではありません。主に視覚的な観点からすると、フォントサイズが中国語の読書習慣に合っていません。Hexoの開発者はほとんどが中国人であり、この点ではHugoよりも優れています。しかし、自分で手を加えて、ブラウザで要素を検証することで、要素を見つけ出し、変更するCSSスタイルの名前を知ることができます。サイドバーで&lt;strong&gt;Insert Style Rule Below&lt;/strong&gt;をクリックすると、ネストされた多層構造のCSSでも簡単にノード名を取得できます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://sourcethemes.com/academic/docs/customization/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;カスタムCSSの導入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://sourcethemes.com/academic/docs/customization/#add-scripts-js&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;カスタムJSの導入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;テーマに組み込まれている構文強調表示の設定については、&lt;a class=&#34;link&#34; href=&#34;https://sourcethemes.com/academic/docs/writing-markdown-latex/#highlighting-options.&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;公式ドキュメント&lt;/a&gt;を参照してください。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;結論&#34;&gt;結論
&lt;/h2&gt;&lt;p&gt;子供たちがまた文句を言っているようだ。「最初から最後まで、曖昧で、細かいこと何も言ってない」と。&lt;/p&gt;
&lt;p&gt;私はこう言うつもりだ。以下のものがあれば十分だ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公式マニュアル&lt;/li&gt;
&lt;li&gt;プラグインの説明書&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新しい技術をすぐに使いこなすには、まず公式サイトのドキュメントを読むことを推奨する。完璧に理解しようとする必要はないし、一度読んで理解する必要もない。少なくとも、ある程度の知識は持っておくべきだ。検索エンジンで見つかる結果が、必ずしも最新版と一致しない。誤解を招く可能性もある。新しい本も同様だ。まず目次を見て、著者が何を説明するのか把握する。場合によっては、序文を読むのが良い。特に海外の著作を翻訳した際に、翻訳者の序文は書籍と核心的な内容をカバーしていることがある。&lt;/p&gt;
&lt;h2 id=&#34;エッグ卵&#34;&gt;エッグ（卵）
&lt;/h2&gt;&lt;p&gt;Hugo Academicの組み込みスタイルを切り替え、サイトに公開後、アクセス時にスタイルが変更されない。賢い仲間たちはすでに解決策を見つけており、「ブラウザキャッシュをクリア」することで問題が解決する。私のような機転の利いた者：「F12開発者ツール」で&lt;code&gt;network&lt;/code&gt;タブを選択し、&lt;code&gt;disable cache&lt;/code&gt;オプションをチェックしてリフレッシュすれば、完璧！
&lt;img src=&#34;https://ttf248.life/p/blog-ide-environment-and-ramblings/2020-03-31-14-27-15.png&#34;
	width=&#34;399&#34;
	height=&#34;142&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;network&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;280&#34;
		data-flex-basis=&#34;674px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>自動統合システム切り替え</title>
        <link>https://ttf248.life/ja/p/auto-integration-system-switch/</link>
        <pubDate>Sun, 29 Mar 2020 02:11:33 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/auto-integration-system-switch/</guid>
        <description>&lt;p&gt;GitHub Actions を使用して、Hugo ブログを GitHub Pages および Gitee に自動でデプロイします。&lt;/p&gt;
&lt;h4 id=&#34;背景説明&#34;&gt;背景説明
&lt;/h4&gt;&lt;p&gt;昨日ブログを更新した際に、Travisサービスが利用できないことを発見しました。Travisのウェブサイトを確認すると、ソースコードの取得時に進捗が止まっていることがわかりました。そこで、GitHubが以前に発表していたActionサービスを思いつきました。
当時、業務が多忙であり、Actionを利用するには申請が必要だったため、現在は正式にリリースされ、週末に暇を持て余している間に、新しいおもちゃを試してみようかと思いました？
公式資料は、ご自身でウェブサイトをご確認ください。本記事では、より多くの転載を行いません。もしKubernetesをご利用経験がある場合、ActionのYAMLファイル設定がKubernetesと非常に似ていることに気づくでしょう。
入門チュートリアル、あるいは中国語の説明資料については、&lt;strong&gt;阮一峰のブログ&lt;/strong&gt;を検索することをお勧めします。2つの記事があり、1つ目は基本的な構文の紹介であり、もう1つは実際のケーススタディです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
正文
必要な知識点
- GitHub Secrets
- Action の構文
コアのジョブは既存のコンポーネントを使用して完了し、国内のGiteeにプッシュするにはコマンドを使用します。このコマンド部分は粗暴で、強制プッシュのみを実装しており、Travisを使用していた際のロジックを継承しています。

```yaml
name: github pages and gitee pages

on:
  push:
    branches:
      - hugo

jobs:
  deploy:
    runs-on: ubuntu-18.04
    steps:
      - uses: actions/checkout@v2
        with:
          submodules: true

      - name: Setup Hugo
        uses: peaceiris/actions-hugo@v2
        with:
          hugo-version: &#39;latest&#39;
          extended: true

      - name: Build Github and Gitee ## 単独ステップには1つのrunコマンドしか書けない
        run: hugo -b &amp;quot;https://www.xiangtianlong.com/&amp;quot; -d &amp;quot;github_public&amp;quot; &amp;amp;&amp;amp; hugo -b &amp;quot;https://www.xiangtianlong.com/&amp;quot; -d &amp;quot;gitee_public&amp;quot; &amp;amp;&amp;amp; ls

      - name: Deploy Github
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.BLOG_TOKEN }}
          publish_dir: ./github_public
          publish_branch: master
          cname: xiangtianlong.com

      - name: Deploy Gitee
        run: cd ./gitee_public &amp;amp;&amp;amp; git init &amp;amp;&amp;amp; git config user.name &amp;quot;TianlongXiang&amp;quot; &amp;amp;&amp;amp; git config user.email &amp;quot;tianlongxiang51@gmail.com&amp;quot; &amp;amp;&amp;amp; git add . &amp;amp;&amp;amp; git commit -m &amp;quot;Update TianlongXiang&#39;s Blog&amp;quot; &amp;amp;&amp;amp; git push --force &amp;quot;https://xiangtianlong:${{ secrets.GITEE_PASSWORD }}@gitee.com/xiangtianlong/xiangtianlong.git&amp;quot; master:master
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;付録&#34;&gt;付録
&lt;/h4&gt;&lt;p&gt;公式マーケットで提供されているactionを見ると、現在サポートされている遊び方があまりにも多い。Dockerイメージを構築すれば、Docker Hubから提供されるサービスへの依存関係もなくなります。&lt;/p&gt;
&lt;p&gt;Hugoのissueを調査すると、GitHub Actionを使ってgit pagesを自動デプロイする際に、最終的に公開されるウェブサイトがmasterブランチにある必要があることがわかります。もし他のブランチにデプロイする場合は、設定画面でGitHubはウェブサイトに構文エラーがあると警告します。&lt;/p&gt;
&lt;p&gt;これは単にHugoのソースファイルがmasterブランチにあるため、GitHubがjellyブログのソースコードとして検出し、構文チェックが通らない場合に発生するエラーです。&lt;/p&gt;
&lt;p&gt;解決策は簡単です。Hugoのソースファイルを他のブランチに配置し、静的ファイルをmasterブランチに公開します。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>標準ライブラリコンテナのメモリ割り当て子：allocator</title>
        <link>https://ttf248.life/ja/p/standard-library-container-memory-allocator/</link>
        <pubDate>Mon, 30 Dec 2019 13:26:19 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/standard-library-container-memory-allocator/</guid>
        <description>&lt;p&gt;カスタムディストリビューターは、パフォーマンスを向上させ、メモリ使用効率を高め、頻繁な少量のメモリ割り当ての問題を解決できます。&lt;/p&gt;
&lt;h4 id=&#34;前因&#34;&gt;前因
&lt;/h4&gt;&lt;p&gt;近頃、ネットワークパケットの開発に携わり、頻繁に小さなメモリ領域を申請し解放する必要があり、当初はメモリプールを使用することを検討していました。いくつかの既存のメモリプールを確認したところ、この
&lt;a class=&#34;link&#34; href=&#34;https://github.com/cacay/MemoryPool&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/cacay/MemoryPool&lt;/a&gt;
を見つけました。インターフェースを見たとき、このメモリプールの実装が少し奇妙だと疑問に思いました。「MemoryPool」の実装ロジックは、固定サイズのメモリ領域を申請することです。boostのメモリプールインターフェースを見てみると、テンプレートを提供し、使用時にインスタンス化します。ちょうどこのライブラリには、&lt;code&gt;allocator&lt;/code&gt;という概念について言及した記事があります。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;#### [wiki](https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_(C%2B%2B))

C++プログラミングにおいて、割り当て子（英語：allocator）はC++標準ライブラリの重要な構成要素です。C++のライブラリには、リスト、集合などのように、さまざまな「コンテナ」と呼ばれるデータ構造が定義されており、これらのコンテナの共通の特徴は、プログラムの実行時にサイズを変更できることです。この機能を実装するために、動的メモリ割り当てが必要となります。割り当て子は、これらのコンテナがメモリへの割り当てと解放のリクエストを処理するために使用されます。言い換えれば、割り当て子は、標準テンプレートライブラリ（STL）コンテナのメモリ管理に関する低レベルの詳細をカプセル化します。

割り当て子は、アレクサンドル・ステパノフによってC++標準テンプレートライブラリ（STL）の一部として最初に発明されました。その目的は、「ライブラリをより柔軟にし、低レベルのデータモデルに独立した方法で利用できるようにする」ことであり、プログラマがライブラリ内でカスタムポインタや参照型を使用することを可能にするものでした。ただし、標準テンプレートライブラリをC++標準に組み込む際、C++標準委員会は、完全なデータモデル抽象化処理が不可受容なパフォーマンス低下をもたらすことを認識しました。そのため、妥協策として、割り当て子の制限がより厳しくなり、ステパノフの当初の構想と比較して、現在の標準で記述されている割り当て子のカスタマイズ性は大幅に制限されています。

割り当て子のカスタマイズは制限されていますが、多くの状況ではカスタム割り当て子が必要となります。これは通常、異なる種類のメモリ空間（共有メモリと回収されたメモリなど）へのアクセス方法をカプセル化したり、メモリプールを使用したメモリ割り当てのパフォーマンスを向上させたりするために行われます。さらに、メモリ使用量と実行時間から見ると、頻繁に少量のメモリを割り当てるプログラムでは、専用の割り当て子を作成することで利益を得ることができます。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;#### [使用需求](https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_(C%2B%2B))

カスタムアロケータの主な理由は性能向上です。専用のアロケータを使用することで、プログラムのパフォーマンスを向上させたり、メモリ使用量を削減したり、あるいは両方を組み合わせることも可能です[4][8]。デフォルトのアロケータは`new`演算子を使用してストレージスペースを割り当てるため、これは通常C言語のヒープ割り当て関数（`malloc()`）によって実装されます[9]。ヒープ割り当て関数は、偶発的な大量メモリ割り当てを最適化するように設計されているため、ベクトルや双端キューなどの、一度に大量のメモリを必要とするコンテナにメモリを割り当てる場合は、デフォルトのアロケータは通常効率的です[8]。しかし、連想コンテナと双方向リストのような、頻繁に少量メモリを割り当てて解除するコンテナの場合、デフォルトのアロケータを使用すると、通常効率が低下します[4][9]。さらに、`malloc()`に基づくデフォルトのアロケータには、より悪い参照局所性や、メモリの断片化を引き起こす可能性があるなど、多くの問題があります[4][9]。

要するに、このセクション（……）（まるで）は、この標準におけるアロケータに関する「夢を見た」のスピーチです。夢が実現する前に、移植性を重視するプログラマーは、ステートレスなカスタムアロケータを使用することになります。
——スコット・メイエス，《Effective STL》

上記を踏まえ、メモリ割り当ての頻度が多い場合に、メモリプールベースのアロケータを使用して問題を解決することがよくあります[8]。オンデマンド割り当てとは異なり、メモリプールベースのアロケータを使用する場合、プログラムは事前に大きなブロックのメモリ（つまり「メモリプール」）を割り当て、次にメモリを割り当てる必要がある場合、カスタムアロケータは、リクエスト元にプール内のメモリへのポインタを返します。オブジェクトが破棄される際には、実際の割り当て解除を行うのではなく、メモリプールのライフサイクルが終了するまで遅延させます[注 1][8]。

「カスタムアロケータ」というトピックに関しては、多くのC++専門家や著者がこの分野で議論しており、スコット・メイエス著の《Effective STL》やアンデル・アレクサンドレスク著の《Modern C++ Design》に言及しています。メイエスは、特定の型`T`のアロケータのすべてのインスタンスが等しいという要件を満たす移植可能なアロケータのインスタンスにはステートを含めない必要があると洞察しており、ステートレスなアロケータの使用を推奨しています。C++標準はライブラリの実装者が状態を含むアロケータをサポートするように奨励していますが、メイエスは「このセクションは、（まるで）素晴らしい見方ですが、ほとんど空言であり」、アロケータの制約は「過度に厳格」であると述べています[4]。たとえば、STLの`list`は`splice`メソッドをサポートしており、これは1つのリストオブジェクト`A`のノードが別のリストオブジェクト`B`に直接挿入されることを意味し、`A`のアロケータによって割り当てられたメモリが`B`のアロケータによって解放される必要があるため、`A`と`B`のアロケータインスタンスは等しいことが導き出されます。メイセスの結論は、アロケータはステートレスな静的メソッドの型として定義するのが最善であるということです。たとえば、C++標準では、アロケータは`rebind`メソッドを実装するその他のクラステンプレートを持つ必要があります。

さらに、ヤン・ストローストルップ著『C++プログラミング言語』では、「割り当てを厳密に制限し、各オブジェクトの情報を異なるようにすることについては、明らかに問題ありません」（大意）と述べており、ほとんどのアロケータはステートを持たず、ステートを持たない場合でもパフォーマンスが向上するという意見を示しています。彼は、メモリプール型アロケータ、共有メモリ型アロケータ、ガベージコレクション型アロケータの3種類のカスタムアロケータを提案し、内部メモリプールを使用して少量メモリを高速に割り当て/解除するアロケータの実装を示しました[3]。ただし、このような最適化は、彼の提供したサンプルアロケータで既に実現されている可能性があると彼は指摘しています。

カスタムアロケータのもう1つの用途は&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
    </channel>
</rss>
