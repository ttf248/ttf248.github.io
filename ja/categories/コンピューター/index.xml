<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>コンピューター on 向叔の手帳</title>
        <link>https://ttf248.life/ja/categories/%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%83%BC/</link>
        <description>Recent content in コンピューター on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Mon, 02 Jun 2025 21:59:58 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/categories/%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%83%BC/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>ブログ翻訳プロジェクトの雑感：文化伝達、AIプログラミング</title>
        <link>https://ttf248.life/ja/p/blog-translation-project-musings-cultural-transmission-ai-programming/</link>
        <pubDate>Mon, 02 Jun 2025 21:41:00 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/blog-translation-project-musings-cultural-transmission-ai-programming/</guid>
        <description>&lt;p&gt;文化伝播：意識形態的な影響、潜移漫歩。
AIプログラミング：ソフトウェア設計を行わないため、手戻りが多くなる。&lt;/p&gt;
&lt;h2 id=&#34;文化翻訳&#34;&gt;文化翻訳
&lt;/h2&gt;&lt;p&gt;当初のプロジェクトでは、英語、日本語、韓国語という3つの言語のみをサポートしていました。その後、「結局AI翻訳だから、色々な言語に対応した方が良いのではないか」と考え、フランス語、ロシア語、ヒンディー語を追加しました。その頃は問題に気づかず、プログラムが翻訳を実行する際に、過去のコードの問題により翻訳形式が正しくなく、保存された文章を再翻訳する必要がありました。&lt;/p&gt;
&lt;p&gt;統計的な時間経過の警告が表示され、すべての翻訳が完了するまでに約20時間がかかりました。これは、ローカルでデプロイされている大規模なモデルであるためです。不要な言語をいくつか削除し、翻訳時間を短縮することを考えました。フランス語、ロシア語、ヒンディー語を削除しました。その時、何かがおかしいことに気づきました。なぜ当初選択した言語（日本語、韓国語）が、私の選択になっているのでしょうか？&lt;/p&gt;
&lt;p&gt;世界人口の分布に基づいて見ると、これらの言語のユーザー層はそれほど多くありません。特に韓国語は、世界の利用人数は約8000万人に過ぎません。日本語はわずかに多い約1億2000万人です。一方、フランス語、ロシア語、ヒンディー語の利用人数はすべて1億人以上でした。&lt;/p&gt;
&lt;p&gt;その時、言語のユーザー層が、言語の使用人数によるものではなく、文化翻訳の影響によるものであることに気づきました。韓国と日本の文化は世界的に広範な影響力を持っており、特にアジア地域で顕著です。K-pop、アニメ、映画などの文化製品は大量のファンを引き付け、これらのファンは自然と関連する言語にも興味を持つようになりました。&lt;/p&gt;
&lt;p&gt;プロジェクトの成長を振り返ると、幼い頃によく日本のアニメや漫画を見ていましたし、大人になった今では多くの韓国映画やドラマを見ました。そのため、プロジェクトの設定時の初期言語を選択する際に、無意識のうちにこれらの馴染みのある言語を選択してしまいました。&lt;/p&gt;
&lt;h3 id=&#34;ソフトウェア設計とaiプログラミング&#34;&gt;ソフトウェア設計とAIプログラミング
&lt;/h3&gt;&lt;p&gt;翻訳助手は当初、単なるシンプルなツールに過ぎなかったが、Claude4のコーディング能力を体験してから徐々に機能が拡張され、文章翻訳、タグ翻訳などのモジュールが追加された。機能が増加するにつれて、コードの複雑さもそれに伴って上昇した。AIがコードをリファクタリングしてディレクトリ構造をより明確にしたことは確かだが、新機能の拡張やバグ修正時には、AI生成されたコードには繰り返し問題が発生することがある。&lt;/p&gt;
&lt;p&gt;AIはコード生成において、全体的な構造と設計理念に対する理解に欠けている。既存のコードに基づいて修正や拡張を行うことが多く、既存モジュールの有効な再利用をできていないため、コード冗長性が生じることがある。毎回、重複コードを手動で削除する必要があり、これは無意識のうちに開発コストを増加させている。&lt;/p&gt;
&lt;p&gt;さらに、AI生成されたコードは文法的に正しくても、論理と設計において問題がある場合がある。例えば、別のプロジェクトでプロンプトをわずかに調整しただけで、生成されるウェブページの構造が完全に異なり、一貫性がない。これは初期段階における合理的な設計の欠如、機能の追加が随意な積み重ねによるものであり、コード構造が混乱していることを反映している。&lt;/p&gt;
&lt;p&gt;これはまた、ソフトウェアエンジニアリングの核心的な経験は依然として無視できないことを私たちに思い出させる。適切な設計は返工を減らすだけでなく、コードの保守性と拡張性を向上させることができる。AIは強力なツールであるものの、システム設計に対する人間の深い理解と計画を代替することはできない。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>ブログ翻訳プロジェクトの雑感：歴史対話</title>
        <link>https://ttf248.life/ja/p/blog-translation-project-musings-historical-conversations/</link>
        <pubDate>Mon, 02 Jun 2025 21:16:24 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/blog-translation-project-musings-historical-conversations/</guid>
        <description>&lt;p&gt;ブログ翻訳プロジェクトは当初、複雑に設計されていた——まずMarkdown形式を解析し、プレースホルダーでコンテンツを保護し、最後に大規模言語モデルに送信する仕組みだった。これは完全に無駄であり、大規模言語モデル自体がMarkdownの文法を認識する能力を備えており、元のコンテンツを直接処理し、翻訳時にフォーマットを維持することができたからだ。&lt;/p&gt;
&lt;p&gt;私たちの仕事は、コードのデバッグから、大規模言語モデルの&lt;strong&gt;プロンプト&lt;/strong&gt;のデバッグへと変わった。
モデル：&lt;code&gt;google/gemma-3-4b&lt;/code&gt;
ハードウェア：&lt;code&gt;Nvidia 3060 12GB&lt;/code&gt;
そう、思考しないモデルを選んだ。思考するモデルは翻訳タスクを実行する際に効率が低く、4Bパラメータと12Bパラメータの効果を比較したところ、翻訳タスクにおいてはgemma3の4Bパラメータで十分だった。12Bパラメータは翻訳タスクにおいて明確な利点を持っていなかった。
12Bパラメータの速度：&lt;strong&gt;11.32 tok/sec&lt;/strong&gt;、4Bパラメータの速度：&lt;strong&gt;75.21 tok/sec&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;背景説明&#34;&gt;背景説明
&lt;/h2&gt;&lt;p&gt;システムに様々な条件制限を加えても、出力される翻訳結果には依然として問題が発生することがありました。具体的には、フォーマットの保護が不十分であったり、過剰な説明文が含まれていたりしました。役割定義時には、Markdown形式を保護し、翻訳結果のみを出力することを明示していたにも関わらず、最終的な翻訳は不安定でした。&lt;/p&gt;
&lt;p&gt;その時、以前漫画翻訳プロジェクトで大言語モデルを活用した経験が思い出されました。その時の翻訳精度は、私のものより良かったようです。コードやリクエストデータを確認したところ、漫画翻訳プロジェクトでは、毎回リクエストにコンテキスト（文脈）を付与していました。現在の翻訳内容に加え、過去の翻訳内容もまとめて送信していたのです。&lt;/p&gt;
&lt;p&gt;このメリットは何でしょうか？前後の翻訳の一貫性を高めるだけでなく、出力フォーマットの安定性を確保することにもつながったと考えられます。&lt;/p&gt;
&lt;h2 id=&#34;履歴対話の重要性&#34;&gt;履歴対話の重要性
&lt;/h2&gt;&lt;p&gt;AI 大規模モデル（GPT シリーズ、Claude、Gemini など）の普及に伴い、ますます多くの企業や開発者が API を通じてこれらのモデルにアクセスし、インテリジェントな顧客サポート、コンテンツ生成、コードアシスタントなどのアプリケーションを構築しています。しかし、多くの方は API への初期導入時に共通の問題に直面します：&lt;strong&gt;モデル出力が不整合で文脈理解が欠如しており、場合によっては質問の意図を誤解してしまう&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;この現象を引き起こす主要な原因の一つは——&lt;strong&gt;API リクエスト中に履歴対話の内容を含めないこと&lt;/strong&gt;です。&lt;/p&gt;
&lt;h2 id=&#34;履歴対話とは&#34;&gt;履歴対話とは？
&lt;/h2&gt;&lt;p&gt;履歴対話とは、一度の会話セッションにおいて、モデルとユーザー間の過去のやり取りの記録を指します。OpenAI の Chat Completions API（など、多くの大規模言語モデル API）では、開発者がリクエスト内で完全な &lt;code&gt;messages&lt;/code&gt; 配列を作成し、過去の会話をユーザーとアシスタントのメッセージが交互に並んだ形式で渡す必要があります。&lt;/p&gt;
&lt;h3 id=&#34;例文&#34;&gt;例文
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;model&amp;quot;: &amp;quot;gpt-4&amp;quot;,
  &amp;quot;messages&amp;quot;: [
    {&amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;退職の手紙を書いてください&amp;quot;},
    {&amp;quot;role&amp;quot;: &amp;quot;assistant&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;かしこまりました。退職理由は何を書くようにしますか？&amp;quot;},
    {&amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;個人的なキャリアの追求をしたいと考えていると述べる&amp;quot;}
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;もし最後の文だけを送った場合：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;個人的なキャリアの追求をしたいと考えていると述べる&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;モデルは退職の手紙だと全く認識できず、文脈が理解されないため、出力品質は著しく低下します。&lt;/p&gt;
&lt;h2 id=&#34;歴史対話がなぜ重要なのか&#34;&gt;歴史対話がなぜ重要なのか？
&lt;/h2&gt;&lt;h3 id=&#34;1-文脈の構築と一貫性の向上&#34;&gt;1. &lt;strong&gt;文脈の構築と一貫性の向上&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;AIモデルは本質的に「コンテキスト駆動型」であり、過去の出来事を記憶することはできません。除非你&lt;strong&gt;明示的に伝える&lt;/strong&gt;のです。対話履歴を渡すことで、モデルはあなたの意図や話題の背景をより良く理解し、期待される出力を生成できます。&lt;/p&gt;
&lt;h3 id=&#34;2-誤解の低減&#34;&gt;2. &lt;strong&gt;誤解の低減&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;もしあなたがモデルに複数のステップで指示を実行させたい場合（例：文章作成、要約、コードデバッグ）、過去の履歴はモデルが徐々に理解を深め、途中で「逸脱」したり、重要な点を失ったりするのを防ぐのに役立ちます。&lt;/p&gt;
&lt;h3 id=&#34;3-実際の人間のような対話行動のシミュレーション&#34;&gt;3. &lt;strong&gt;実際の人間のような対話行動のシミュレーション&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;実用例として、カスタマーサポートシステム、教育アシスタント、健康相談などにおいて、ユーザーの質問は通常、段階的に展開され、一度に明確な表現で表明されることはありません。会話履歴を保持することで、AIが「記憶力のあるアシスタント」のように振る舞うことができます。&lt;/p&gt;
&lt;h2 id=&#34;api-中における会話履歴の正しい追加方法&#34;&gt;API 中における会話履歴の正しい追加方法
&lt;/h2&gt;&lt;p&gt;OpenAI の API を例に、以下の構造に従うことを推奨します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;messages = [
    {&amp;quot;role&amp;quot;: &amp;quot;system&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;あなたは専門的な法律アシスタントです&amp;quot;},
    {&amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;契約書の有効条件とは何ですか？&amp;quot;},
    {&amp;quot;role&amp;quot;: &amp;quot;assistant&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;契約書が有効であるためには、以下の条件を満たす必要があります：……&amp;quot;},
    {&amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;口頭での合意は有効ですか？&amp;quot;}
]

response = openai.ChatCompletion.create(
    model=&amp;quot;gpt-4&amp;quot;,
    messages=messages
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;system&lt;/code&gt; メッセージを使用してモデルの動作とアイデンティティを設定します。&lt;/li&gt;
&lt;li&gt;最新の数回の重要な会話のみを保持し、毎回すべての履歴を送信する必要はありません（トークン制限を超えないように）。&lt;/li&gt;
&lt;li&gt;長いセッションでは、早期のコンテンツを切り捨てて、コア情報を要約し、トークンの消費を制御します。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;実践的推奨事項&#34;&gt;実践的推奨事項
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;対話状態管理&lt;/strong&gt;: バックエンドは、各ユーザーのセッション履歴（例: Redis、データベース）を記録するためのキャッシュメカニズムを設計する必要があります。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;長さ制限&lt;/strong&gt;: OpenAI GPT-4 のコンテキスト長は 128k tokens であり、Claude 3 は 200k～1M पर्यंत可能です。適切なトリミングが必要です。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;動的履歴の要約&lt;/strong&gt;: 履歴が長すぎる場合は、モデルを使用して古い会話を要約し、その結果を対話コンテキストに追加します。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ
&lt;/h2&gt;&lt;p&gt;AI 大規模モデルの能力は強力ですが、開発者に十分なコンテキスト情報を「与える」必要があります。API リクエストに過去の会話を追加することで、モデル出力の品質と一貫性を大幅に向上させるだけでなく、ユーザーエクスペリエンスをより自然で現実的な対話に近づけることができます。AI 顧客サービス、ライティングアシスタント、プログラミングアシスタント、教育アプリケーションなど、どのような分野でも無視できない最適化テクニックです。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Go プロジェクトで参照されていないすべての関数を検索する。</title>
        <link>https://ttf248.life/ja/p/find-all-functions-not-referenced-in-the-go-project/</link>
        <pubDate>Mon, 02 Jun 2025 21:10:47 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/find-all-functions-not-referenced-in-the-go-project/</guid>
        <description>&lt;p&gt;Go言語プロジェクトにおいて、&lt;code&gt;staticcheck&lt;/code&gt; を使用して未使用関数を検出することは、効率的な静的解析手法です。&lt;/p&gt;
&lt;h3 id=&#34;1-staticcheck-のインストール&#34;&gt;&lt;strong&gt;1. staticcheck のインストール&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;以下のコマンドを実行して、Go (バージョン 1.16+) と &lt;code&gt;staticcheck&lt;/code&gt; をインストールしてください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go install honnef.co/go/tools/cmd/staticcheck@latest
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-基本用法未使用関数の検索&#34;&gt;&lt;strong&gt;2. 基本用法：未使用関数の検索&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;プロジェクトのルートディレクトリで以下のコマンドを実行します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;staticcheck ./...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;主要チェックルール:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;U1000&lt;/strong&gt;: 未使用関数、メソッド、変数、または型を検出します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;U1001&lt;/strong&gt;: 未使用パラメータを検出します。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-特定のチェックルールをフィルタリングする&#34;&gt;&lt;strong&gt;3. 特定のチェックルールをフィルタリングする&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;未使用関数のみをチェックする場合、ルールを指定できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;staticcheck -checks=U1000 ./...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-出力形式&#34;&gt;&lt;strong&gt;4. 出力形式&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;デフォルトの出力形式は、&lt;code&gt;{path}:{line}:{column}: {message}&lt;/code&gt; の形式です。例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;main.go:10:2: func UnusedFunction は未使用です (U1000)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-設定ファイル-オプション&#34;&gt;&lt;strong&gt;5. 設定ファイル (オプション)&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;プロジェクトのルートディレクトリに &lt;code&gt;.staticcheck.conf&lt;/code&gt; ファイルを作成し、カスタムチェックルールを定義します：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;checks&amp;quot;: [&amp;quot;U1000&amp;quot;, &amp;quot;-ST1000&amp;quot;]  // U1000 を有効にし、ST1000 を無効にする (文字列フォーマット規則)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6-visual-studio-code-への統合&#34;&gt;&lt;strong&gt;6. Visual Studio Code への統合&lt;/strong&gt;
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://marketplace.visualstudio.com/items?itemName=golang.go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 拡張機能&lt;/a&gt; をインストールします。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;settings.json&lt;/code&gt; に以下を追加します：&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;7-特定コードの無視&#34;&gt;&lt;strong&gt;7. 特定コードの無視&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;関数の上部にコメント &lt;code&gt;//lint:ignore U1000 reason&lt;/code&gt; を追加することで、以下のチェックを無視できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//lint:ignore U1000 Used by generated code
func UnusedButNeeded() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;よくある質問&#34;&gt;&lt;strong&gt;よくある質問&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Q: テストファイル内の未使用関数をどのように処理しますか?&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;A: &lt;code&gt;staticcheck&lt;/code&gt; はデフォルトでテストファイルをチェックします。除外する場合は、&lt;code&gt;-tests=false&lt;/code&gt; などのフラグを使用できます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Q: CI/CD 環境への統合は?&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;A: GitHub Actions に追加：&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;サンプル出力&#34;&gt;&lt;strong&gt;サンプル出力&lt;/strong&gt;
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ staticcheck -checks=U1000 ./...
internal/utils/helper.go:15:2: 関数 privateHelper は使用されていない (U1000)
cmd/server/main.go:23:2: initConfig 関数は使用されていない (U1000)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;staticcheck&lt;/code&gt; の &lt;code&gt;U1000&lt;/code&gt; 規則を使用することで、未使用の関数を迅速に特定し削除し、コード品質を向上させることができます。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Git 子モジュール提交記録の消失</title>
        <link>https://ttf248.life/ja/p/git-submodule-merge-history-lost/</link>
        <pubDate>Mon, 02 Jun 2025 16:44:58 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/git-submodule-merge-history-lost/</guid>
        <description>&lt;p&gt;ローカルにGitリポジトリがあり、そのサブモジュールがプル時に一時ブランチになっている。私はその一時ブランチでいくつかのコードをコミットし、その後サブモジュールを&lt;code&gt;main&lt;/code&gt;ブランチに戻した。しかし、これらのコミットされたコードが見つからず、&lt;code&gt;main&lt;/code&gt;ブランチで見つけることができない。また、その一時ブランチの履歴も見つけられない。&lt;/p&gt;
&lt;h2 id=&#34;ソリューション&#34;&gt;ソリューション
&lt;/h2&gt;&lt;p&gt;Git サブモジュールで一時的なブランチにコミットし、&lt;code&gt;main&lt;/code&gt; ブランチに戻すとこれらのコミットが見つからなくなることがあります。この状況を解決するには、以下の手順に従ってください。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;コミット履歴の確認:&lt;/strong&gt; サブモジュールのディレクトリに移動し、reflog を使用して失われたコミットを見つけます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;新しいブランチを作成してコミットを保存:&lt;/strong&gt; 失われたコミットに基づいて新しいブランチを作成します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;メインブランチへのマージまたはcherry-pick:&lt;/strong&gt; コードをメインブランチに統合します（マージするか、cherry-pickを使用して特定のコミットを選択）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下は具体的な操作手順です。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# サブモジュールのディレクトリに移動
cd path/to/your/submodule

# reflog で HEAD の変更履歴を確認（未関連ブランチのコミットも含む）
git reflog

PS F:\dev\notebook\scripts\hugo-content-suite&amp;gt; git reflog
de05175 (HEAD -&amp;gt; main, origin/main, origin/HEAD) HEAD@{0}: checkout: moving from c8d070651310e90d283cb64d98da088c5fe05e73 to main
c8d0706 HEAD@{1}: commit: feat: Markdown 記号の用法ドキュメントを追加、詳細な構文例と効果のデモを提供
48250f5 HEAD@{2}: commit: feat: 文章翻訳プレビュー機能を削除し、翻訳プロセスを簡素化
b8280b6 HEAD@{3}: commit: feat: 絶対パスを取得する機能を追加し、相対パスを絶対パスに変換をサポート
92c354b HEAD@{4}: commit: fix: 文章スキャンロジックの修正、絶対パスを使用してスキャンするようにする
de05175 (HEAD -&amp;gt; main, origin/main, origin/HEAD) HEAD@{5}: checkout: moving from main to de05175d4ec0828e3ae95d726b09dfff18f67a23
de05175 (HEAD -&amp;gt; main, origin/main, origin/HEAD) HEAD@{6}: clone: from https://cnb.cool/ttf248/hugo-content-suite.git

# 失われたコミットに基づいて新しいブランチを作成（例：456def を使用）
git checkout -b saved-work 456def

# メインブランチに戻る
git checkout main

# 保存した作業をメインブランチにマージ（または cherry-pick で特定のコミットを選択）
git merge saved-work
# または
git cherry-pick 456def

# 親プロジェクトディレクトリに戻り、サブモジュールの更新をコミット
cd ..
git add path/to/your/submodule
git commit -m &amp;quot;Update submodule to include new changes&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;主要操作手順&#34;&gt;主要操作手順
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;git reflog&lt;/strong&gt;: HEADのすべての履歴を表示し、ブランチに関連付けられていないコミットも含む&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;git checkout -b&lt;/strong&gt;: 任意のコミットから新しいブランチを作成し、作業を保存する&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;git merge/cherry-pick&lt;/strong&gt;: 保存されたコミットをターゲットブランチに統合する
reflogで記録が見つからない場合は、&lt;code&gt;git fsck --lost-found&lt;/code&gt;を使用して孤立したコミットを探す必要があるかもしれませんが、これは非常にまれなケースです。&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>GitHub Pages の Easter Egg: 複数の Pages をデプロイ</title>
        <link>https://ttf248.life/ja/p/github-pages-easter-egg-deploy-multiple-sites/</link>
        <pubDate>Wed, 28 May 2025 02:55:54 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/github-pages-easter-egg-deploy-multiple-sites/</guid>
        <description>&lt;p&gt;最近、体内時計が少し乱れていて、夜2時過ぎまでGitHub Pagesのデプロイに苦戦していました。
仕事が終わってからようやく食事を摂り、すぐに寝ようとすると、食べ終わって帰宅して8時半頃になり、眠くて困って、目を閉じるとそのまま眠くなってしまい、目が覚めるともう凌晨2時でした。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;まだ起動もしていないうちに消滅した分類：AI 研習所&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;フラグフラッグ&#34;&gt;フラグ（フラッグ）
&lt;/h2&gt;&lt;p&gt;昨日、話していなかった「未熟な」フロントエンドを批判していたのに、今日はフロントエンドではなく、UI/UXの体験を追求している。&lt;/p&gt;
&lt;h2 id=&#34;プロジェクト&#34;&gt;プロジェクト
&lt;/h2&gt;&lt;p&gt;弊社の古くからの友人、&lt;a class=&#34;link&#34; href=&#34;https://github.com/ttf248/ai-coding-demo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ttf248/ai-coding-demo&lt;/a&gt; が参上します。
そうです、以前の選株プロジェクトを、全体の構造を再構築し、その後のAIプログラミング関連の内容はこのプロジェクト下に集約されます。&lt;/p&gt;
&lt;h2 id=&#34;複数の-pages-をデプロイする&#34;&gt;複数の Pages をデプロイする
&lt;/h2&gt;&lt;p&gt;プロジェクトは国内で &lt;a class=&#34;link&#34; href=&#34;https://cnb.cool/ttf248/ai-coding-demo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cnb.cool/ttf248/ai-coding-demo&lt;/a&gt; でホストされており、周知の通り、国内では Pages の公開をサポートしていません。そのため、海外の GitHub 上に公開する必要があります。&lt;/p&gt;
&lt;p&gt;ブログは海外の GitHub に公開されます。まだ試したことがありませんが、複数のプロジェクトを Pages にデプロイすること、そして現在の処理しているプロジェクトが従来のブログサイトではないこと（単に多くのドキュメントといくつかの静的な HTML デザイン稿が含まれているだけです。）もわかります。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/github-pages-easter-egg-deploy-multiple-sites/20250528030230.png&#34;
	width=&#34;798&#34;
	height=&#34;530&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;pages&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;150&#34;
		data-flex-basis=&#34;361px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;その通り、このページは私が初めてクリックしたところ、複数のプロジェクトを Pages にデプロイすることはブログの公開に影響を与えないこと、そしてブログのドメインの下に新しいパスが追加されることを発見しました。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://ttf248.life/ai-coding-demo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ttf248.life/ai-coding-demo/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ここまできたら、完璧だと叫びました。&lt;/p&gt;
&lt;h2 id=&#34;ai-研習社&#34;&gt;AI 研習社
&lt;/h2&gt;&lt;p&gt;昨日、新しい分類を作成したことをきっかけに、AIを活用して多くのコンピュータ科目の学習を進めようと考えました。例えば、アルゴリズムやLeetCodeのプログラミング問題集などです。&lt;/p&gt;
&lt;p&gt;毎回の学習記録をブログに公開し、知識ベースを形成します。新しい分類として「AI 研習社」を作成しました。&lt;/p&gt;
&lt;p&gt;現在見られるように、異なるコースごとにそれぞれプロジェクトを作成し、学習ノートは各プロジェクトのReadme.mdファイルに記述しています。&lt;/p&gt;</description>
        </item>
        <item>
        <title>慢性疾患、華やかなりし世相に眼移り</title>
        <link>https://ttf248.life/ja/p/old-ailment-stunning-flowers/</link>
        <pubDate>Mon, 26 May 2025 23:54:12 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/old-ailment-stunning-flowers/</guid>
        <description>&lt;p&gt;長年にわたりバックエンド開発に注力してきましたが、最近は &lt;code&gt;AI&lt;/code&gt; プログラミングを試したり、少しフロントエンド関連のことも取り組むようになりました。しかし、この間の苦労の中で、自分には昔からある古傷—「繁華なものに目を奪われる」—に気づきました。&lt;code&gt;AI&lt;/code&gt; を使ってフロントエンドインターフェースを実現しようとするのですが、実際にはそのような試みが現在の仕事に大きな実用的な助けになりませんし、むしろ時間を浪費してしまいます。&lt;/p&gt;
&lt;h2 id=&#34;ai-の適用シナリオ&#34;&gt;AI の適用シナリオ
&lt;/h2&gt;&lt;p&gt;小規模なプロジェクトにおいては、AI ツールが大きな役割を果たすことができ、特に独立性が高く、システムとの結合度が低く、ビジネスロジックが単純な関数を作成する際に非常に役立ちます。これらのタスクは通常、明確な入力と出力があり、文脈依存が少ないため、現在の AI 支援プログラミングの能力範囲に最適です。&lt;/p&gt;
&lt;p&gt;しかしながら、複雑なシステムアーキテクチャや深いビジネスロジックに対処する場合、AI の限界が現れ始めます。それは、プロジェクトの実際のニーズから乖離した、見かけ上は合理的だが実際には不適切なコードを生成したり、デバッグが困難な潜在的な問題を導入したりする可能性があります。これらのシナリオにおいては、AI は補助ツールとして、完全なコード生成器に依存することなく使用されるべきです。生成されたコードは厳格なレビューとテストを受け、実際の要件を満たしていることを確認する必要があります。&lt;/p&gt;
&lt;h2 id=&#34;誤りと学習の代償&#34;&gt;誤りと学習の代償
&lt;/h2&gt;&lt;p&gt;AI を使ってフロントエンドコードを生成しようとした際、多くの課題に直面しました。フロントエンドは私の馴染みのない分野であるため、問題解決には時間と労力がかかりました。プロンプトを調整して AI にコードを書き直しても、どうしても低レベルのエラーが発生してしまうのです。このような試行錯誤は時間と労力を浪費するだけでなく、現在の私のエネルギーはバックエンドのビジネスロジックに集中すべきだと痛感させられました。&lt;/p&gt;
&lt;p&gt;週末に完成させたプロジェクトを振り返ってみると、バックエンド開発とユーザーインタラクションロジックに焦点を当て、コンソールから機能を実装することが、現状で最も効率的な選択であると確信します。より多くの時間とエネルギーが手に入ったら、フロントエンドの知識を体系的に学ぶ方が良いかもしれません。&lt;/p&gt;
&lt;h2 id=&#34;フロントエンド学習の計画&#34;&gt;フロントエンド学習の計画
&lt;/h2&gt;&lt;p&gt;フロントエンド技術スタックは複雑で多様であり、短期間で習得するのは現実的ではありません。まずは、Vue.jsやReact.jsなどのフレームワークを選択し、そのコアな概念と使用方法を深く学ぶことを計画しています。基礎知識を習得した後で、AIを活用してフロントエンドコードを生成することで、不慣れによる誤りや時間の浪費を防ぐことができます。&lt;/p&gt;
&lt;p&gt;まとめると、現在の段階ではバックエンド開発に重点を置き、着実にコアスキルを向上させることに注力します。その時が来るまで、フロントエンドとAIの組み合わせを探求することは控え、より大きな成果を得られる可能性があります。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Claude4のリリース、開発を試す：hugoタグ、超リンク翻訳アシスタント</title>
        <link>https://ttf248.life/ja/p/claude-4-release-hugo-tags-hyperlink-translation-assistant/</link>
        <pubDate>Sat, 24 May 2025 03:05:31 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/claude-4-release-hugo-tags-hyperlink-translation-assistant/</guid>
        <description>&lt;p&gt;本サイトはHugoで開発されていますが、筆者自身は常に中国語のタイトルを使用しており、その結果、生成される文章の超リンクが使いにくい状態でした。つまり、送信する際に、中国語の文字が超リンク内で%E4%BD%A0%E5%A5%BDのような形式にエスケープされてしまうため、見た目が良くありません。設定でslugを設定することで解決できますが、毎回手動で設定する必要があり、非常に面倒でした。
そこで、Claude4を使って翻訳アシスタントを開発し、中国語のタイトルを自動的に英語のslugに変換し、文章中に超リンクを追加することを試みました。これにより、手動での設定を回避できます。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Claude4はマジで最高！文脈理解能力が大幅に向上し、複雑なタスクの処理効率も飛躍的に向上しています。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;プロジェクトアドレス&#34;&gt;プロジェクトアドレス
&lt;/h2&gt;&lt;p&gt;国内プロジェクトアドレス：&lt;a class=&#34;link&#34; href=&#34;https://cnb.cool/ttf248/hugo-content-suite&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cnb.cool/ttf248/hugo-content-suite&lt;/a&gt;
国外プロジェクトアドレス：&lt;a class=&#34;link&#34; href=&#34;https://github.com/ttf248/hugo-content-suite&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ttf248/hugo-content-suite&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;コードの実装&#34;&gt;コードの実装
&lt;/h2&gt;&lt;p&gt;まず、実装の思路について説明します。すべての文章をスキャンし、タグ情報と記事タイトルを抽出した後、ローカルの大規模言語モデル（例：gemma-3-12b-it）を呼び出して翻訳します。&lt;/p&gt;
&lt;p&gt;実際の開発において、前世代の大規模言語モデルと比較して、&lt;code&gt;Claude4&lt;/code&gt; はいくつかの顕著な点を発揮しました。機能要件が多いため、&lt;code&gt;Claude4&lt;/code&gt; はインタラクティブメニューを自動的に設計し、さまざまな使用シナリオを考慮しました。例えば、タグ処理に関しては、&lt;code&gt;Claude4&lt;/code&gt; はタグの統計と分析だけでなく、分類統計もサポートし、さらに&lt;strong&gt;ラベルのない文章&lt;/strong&gt;を検出することも可能です。また、プレビュー機能やタグページ生成機能も提供しています。&lt;/p&gt;
&lt;p&gt;ローカルの大規模言語モデルとの連携、翻訳キャッシュの追加、大規模なコードのリファクタリングなど、&lt;code&gt;Claude4&lt;/code&gt; はすべて一度に完了し、ほとんど問題がありませんでした。プロジェクト規模は小さくても、多くの小さな機能を含んでいました。以前の開発プロセスでは、大規模言語モデルが前の内容を忘れてしまうことがよくありましたが、今回の &lt;code&gt;Claude4&lt;/code&gt; は非常に優れており、&lt;strong&gt;ほぼコンテキストを忘れることなく動作しました&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;要するに、スマート性が向上し、今後の開発には &lt;code&gt;Claude4&lt;/code&gt; をより多く使用し、日常的なコーディングの主力モデルとして活用していく予定です。&lt;/p&gt;
&lt;h2 id=&#34;翻訳キャッシュ&#34;&gt;翻訳キャッシュ
&lt;/h2&gt;&lt;p&gt;この注文に関する説明では、大規模モデルの呼び出し回数を減らすだけでなく、実際に12Bモデルをローカルで実行すると効率が非常に高く、時間ロスもありません。しかし、毎回大規模モデルを呼び出す場合は、やはり少し遅くなります。また、文章のリンクを固定するために、全量更新を実行した場合、文章のタイトルが長いため、稀に2回の翻訳結果が異なり、リンクが変わってしまうという状況が発生します。これは非常に困ります。&lt;/p&gt;
&lt;h2 id=&#34;機能最適化&#34;&gt;機能最適化
&lt;/h2&gt;&lt;p&gt;プロジェクト全体を &lt;code&gt;Claude4&lt;/code&gt; に引き渡して、最適化の余地を分析し、以下の提案を得ました：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;外部化の設定 - メンテナンス性と柔軟性を向上
構造化ログ - 問題のトラブルシューティングと監視が容易になる
パフォーマンスモニタリング - システムの状態を把握する
ユーザーエクスペリエンス - プログレスバーなどの視覚的なフィードバック
エラー処理 - より包括的な例外処理メカニズム
コード整理 - より明確なモジュール分割
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;コードをレビューしたところ、問題点は一切なく、例えば設定ファイルについては、元のコードから設定を変換し、デフォルト設定に変換した後、設定ファイルを読み込む際に、対応する設定ファイルが存在しない場合に自動的にデフォルト設定ファイルを生成することで、ユーザーの操作ミスを防いでいました。
要件：翻訳文の正体を翻訳する際に、翻訳効率を動的に計算し、残りの時間を予測して、関連情報をコンソールに出力しました。現在、文章の文字数を取得し、各行の翻訳時に現在の翻訳文字数、時間、100文字あたりの翻訳時間を適合計算しています。同時に、文章全体の翻訳残り時間を推定します。
コードが完了した後、新しい驚きを発見しました。翻訳効率の統計情報がリアルタイムで大量に表示されますが、無制限にスクロールダウンすることはありませんでした。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;原文を英語に翻訳中（合計 7163 文字）...
翻訳する必要がある行数が 53 行検出されました。
  [1/53] Stage1/6 [░░░░░░░░░░░░░░░░░░░░░░░░░] 1.9% 354 文字の翻訳...
    ✅ 完了 (3.1秒) | API呼び出し #1
    ✅ 完了 (1.5秒) | API呼び出し #2
    ✅ 完了 (0.9秒) | API呼び出し #3
    ✅ 完了 (0.2秒) | API呼び出し #4
    ✅ 完了 (1.0秒) | API呼び出し #5
    ✅ 完了 (1.0秒) | API呼び出し #6
    ✅ 完了 (0.2秒) | API呼び出し #7
    📊 進捗: 行の 13.2% (7/53) | 文字の 12.9% (925/7163) 114.6 文字/秒 📊
    ⚡ 効率：リアルタイム 76.4 | 平均 117.9 | 最近 109.0 | ステージ 113.6 文字/秒 📊
    🎯 正確度: 100.0% (7/7) | 残り: 46行 7 秒] 9.4% 110 文字の翻訳...
    ⏱️ 残りの推定時間: 55秒 | 予想完了時間: 00:10:19 8秒] 11.3% 114 文字の翻訳...
    💾 处理速度：3211.3 行/分钟 | 总用时：8秒] 13.2% 16 文字の翻訳...
  [8/53] Stage1/6 [███░░░░░░░░░░░░░░░░░░░░░░] 15.1% 166 文字の翻訳...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以前、プログラムを制御するコードはあまり書かれていませんでしたが、どのように実装されているのか知りたくて、コードを調べてみました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// キャッシュクリアと再表示（動的更新効果）
if translationCount &amp;gt; 1 {
   fmt.Print(&amp;quot;\033[6A\033[K&amp;quot;) // 上に 6 行移動し、内容をクリア
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;パフォーマンス統計メニュー&#34;&gt;パフォーマンス統計メニュー
&lt;/h3&gt;&lt;p&gt;新たに作成された&lt;strong&gt;パフォーマンス統計メニュー&lt;/strong&gt;は、私自身が設計したものでも、これほど完璧とは言えない。&lt;/p&gt;
&lt;p&gt;📊 パフォーマンス統計：
🔄 翻訳回数：360
⚡ キャッシュヒット率：1.4% (5/365)
⏱️ 平均翻訳時間：315.927234ms
📁 ファイル操作：73
❌ エラー回数：0&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;データマイニング&lt;/li&gt;
&lt;li&gt;ディープラーニング&lt;/li&gt;
&lt;li&gt;ニューラルネットワーク&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;=== ブログ管理ツール ===&lt;/p&gt;
&lt;p&gt;🚀 コア機能&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全ブログの処理をワンクリックで実行 (完全なブログ処理フロー)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;📝 コンテンツ管理
2. タグページを生成
3. アーティクルスラッグを生成
4. 記事を多言語バージョンに翻訳&lt;/p&gt;
&lt;p&gt;💾 キャッシュ管理
5. キャッシュの状態を確認
6. 全量翻訳キャッシュの生成
7. 翻訳キャッシュをクリア&lt;/p&gt;
&lt;ol start=&#34;0&#34;&gt;
&lt;li&gt;プログラム終了&lt;/li&gt;
&lt;/ol&gt;</description>
        </item>
        <item>
        <title>フォークのレポジトリにプルリクエストをマージする</title>
        <link>https://ttf248.life/ja/p/merge-pullrequest-to-forked-repo/</link>
        <pubDate>Wed, 07 May 2025 18:44:03 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/merge-pullrequest-to-forked-repo/</guid>
        <description>&lt;p&gt;&lt;code&gt;github-readme-stats&lt;/code&gt; は、GitHub の個人プロフィールに関する統計情報を生成するツールです。ユーザーの GitHub 個人プロフィールの様々な統計情報やグラフの表示を可能にします。多様なカスタマイズオプションを提供し、ユーザーのニーズに合わせて調整できます。&lt;/p&gt;
&lt;p&gt;筆者はリポジトリ管理の習慣として、プロジェクトごとにグループ化を行っていますが、GitHub はリポジトリのグループ化をサポートしていないため、異なる組織に分割することで実現しています。&lt;code&gt;github-readme-stats&lt;/code&gt; の最新ブランチでは、異なる組織のリポジトリ統計のクロスオーバーに対応していません。そこで、対応するコードをマージしたブランチをフォークしました。&lt;/p&gt;
&lt;h2 id=&#34;最終結果&#34;&gt;最終結果
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://github-readme-stats-chi-one-17.vercel.app/api?username=ttf248&amp;amp;hide_title=true&amp;amp;show_icons=true&amp;amp;hide=contribs&amp;amp;line_height=24&amp;amp;include_all_commits=true&amp;amp;count_private=true&amp;amp;bg_color=0000&amp;amp;text_color=8A919F&amp;amp;locale=cn&amp;amp;role=OWNER,COLLABORATOR,ORGANIZATION_MEMBER&amp;amp;timstamp=1746608356&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;GitHub Stats&#34;
	
	
&gt;
&lt;img src=&#34;https://github-readme-stats-chi-one-17.vercel.app/api/top-langs/?username=ttf248&amp;amp;hide_title=true&amp;amp;hide=html,javascript,css&amp;amp;layout=compact&amp;amp;bg_color=0000&amp;amp;text_color=8A919F&amp;amp;locale=cn&amp;amp;role=OWNER,COLLABORATOR,ORGANIZATION_MEMBER&amp;amp;timstamp=1746608356&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Top Languages&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;プルリクエスト-元のurl&#34;&gt;プルリクエスト 元のURL
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/anuraghazra/github-readme-stats/pull/2459&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;組織のリポジトリからのデータを含める機能を追加&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;上流のプルリクエストをフォークのリポジトリにマージする&#34;&gt;上流のプルリクエストをフォークのリポジトリにマージする
&lt;/h2&gt;&lt;p&gt;ある &lt;strong&gt;プルリクエスト (PR)&lt;/strong&gt; をあなたの &lt;strong&gt;フォークしたリポジトリ&lt;/strong&gt; にマージするには、いくつかの方法があり、あなたが以下のいずれかを達成したいかによって異なります。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;上流（upstream）リポジトリ&lt;/strong&gt; から PR をあなたのフォークにマージするか、&lt;/li&gt;
&lt;li&gt;他の人のフォークから PR をあなたのフォークにマージするか、&lt;/li&gt;
&lt;li&gt;あなたのフォークで作成された PR (例えば、他の人があなたにフォークして PR を提起した場合) をマージする&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;まず、最も一般的なシナリオを説明します：&lt;strong&gt;フォークしたリポジトリがあり、上流の PR をあなたのフォークにマージしたい場合&lt;/strong&gt;。操作手順は以下のとおりです👇&lt;/p&gt;
&lt;h3 id=&#34;-方法１コマンドライン方式最も汎用的&#34;&gt;✅ 方法１：コマンドライン方式（最も汎用的）
&lt;/h3&gt;&lt;h4 id=&#34;ステップ-1自分のフォークをクローンする&#34;&gt;ステップ 1：自分のフォークをクローンする
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/あなたのユーザー名/リポジトリ名.git
cd リポジトリ名
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;ステップ-2upstream-元のリポジトリのurl-を追加&#34;&gt;ステップ 2：upstream (元のリポジトリのURL) を追加
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git remote add upstream https://github.com/原作者のユーザー名/リポジトリ名.git
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;ステップ-3上流のprブランチをリポジトリに取得する&#34;&gt;ステップ 3：上流のPRブランチをリポジトリに取得する
&lt;/h4&gt;&lt;p&gt;マージしたいPRの番号（例：PR #123）を見つけます。&lt;/p&gt;
&lt;p&gt;以下のコマンドでそのPRのコードをリポジトリに取得できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git fetch upstream pull/123/head:pr-123
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;ステップ4ブランチを切り替えマージする&#34;&gt;ステップ4：ブランチを切り替え、マージする
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git checkout main    # またはあなたのターゲットブランチ
git merge pr-123
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;すべて正常であれば、GitHub リポジトリにフォークした場所にプッシュできます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git push origin main
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-方法二github-ウェブインターフェースシンプルだが限定的&#34;&gt;✅ 方法二：GitHub ウェブインターフェース（シンプルだが限定的）
&lt;/h3&gt;&lt;p&gt;GitHub のウェブ上で特定のプルリクエスト (PR) が上位のレポジトリに対するものである場合、以下の手順を実行できます。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;その PR ページにアクセスします。&lt;/li&gt;
&lt;li&gt;右上部の「&lt;strong&gt;Commits&lt;/strong&gt;」または「&lt;strong&gt;Files changed&lt;/strong&gt;」をクリックし、この PR がどのブランチに基づいて作成されているかを確認します。&lt;/li&gt;
&lt;li&gt;あなたのフォークページで新しいブランチを作成し、手動で PR のコミットを cherry-pick します（Git に関する知識が必要です）。&lt;/li&gt;
&lt;li&gt;または、「&lt;strong&gt;Open in GitHub Desktop&lt;/strong&gt;」をクリックして、GUI ツールを使用してマージします。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;-他人があなたのフォークに対してプルリクエストを送信した場合&#34;&gt;🚀 他人があなたのフォークに対してプルリクエストを送信した場合
&lt;/h3&gt;&lt;p&gt;プルリクエストのページに直接移動し、「&lt;strong&gt;Merge pull request&lt;/strong&gt;」ボタンをクリックしてください。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;具体的な状況（例えば、PRリンク、ウェブインターフェースを使用しているかコマンドラインを使用しているか）に応じて、ステップバイステップでデモンストレーションが必要ですか？ または、具体的なリンクを提供していただければ、最も簡単な方法を分析します。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Git での履歴記録におけるコミット情報</title>
        <link>https://ttf248.life/ja/p/git-modify-commit-message/</link>
        <pubDate>Wed, 07 May 2025 18:38:31 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/git-modify-commit-message/</guid>
        <description>&lt;p&gt;スクリプトは、Git履歴のコミットメッセージの作成者情報をまとめて変更するために使用され、&lt;code&gt;git filter-branch&lt;/code&gt;を使用してGit履歴を書き換えます。&lt;/p&gt;
&lt;p&gt;ご提供いただいたスクリプトは、Gitリポジトリの履歴コミットにおける作成者情報を一括で修正するものであり、全体的な考え方は正しいですが、&lt;code&gt;git filter-branch&lt;/code&gt; の &lt;code&gt;--env-filter&lt;/code&gt; で配列（例：&lt;code&gt;OLD_EMAILS=(&amp;quot;...&amp;quot;)&lt;/code&gt;）を使用すると、一部のシェル環境（例：&lt;code&gt;/bin/sh&lt;/code&gt;）では互換性の問題が発生する可能性があります。これは、配列構文がサポートされていないためです。
互換性を高めるために、配列をスペースで区切られた文字列に置き換え、&lt;code&gt;for&lt;/code&gt;ループを使用して各古いメールアドレスを反復処理することをお勧めします。以下は修正後のスクリプトの例です。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh

git filter-branch --env-filter &#39;
OLD_EMAILS=&amp;quot;TianlongXiang51@gmail.com nick@qq.com tianlongxiang51@gmail.com&amp;quot;
CORRECT_NAME=&amp;quot;tianlong.xiang&amp;quot;
CORRECT_EMAIL=&amp;quot;tianlong.xiang@foxmail.com&amp;quot;

for OLD_EMAIL in $OLD_EMAILS
do
    if [ &amp;quot;$GIT_COMMITTER_EMAIL&amp;quot; = &amp;quot;$OLD_EMAIL&amp;quot; ]
    then
        export GIT_AUTHOR_NAME=&amp;quot;$CORRECT_NAME&amp;quot;
        export GIT_AUTHOR_EMAIL=&amp;quot;$CORRECT_EMAIL&amp;quot;
    fi
    if [ &amp;quot;$GIT_AUTHOR_EMAIL&amp;quot; = &amp;quot;$OLD_EMAIL&amp;quot; ]
    then
        export GIT_COMMITTER_NAME=&amp;quot;$CORRECT_NAME&amp;quot;
        export GIT_COMMITTER_EMAIL=&amp;quot;$CORRECT_EMAIL&amp;quot;
    fi
done
&#39; --tag-name-filter cat -- --branches --tags
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;このスクリプトを実行する前に、リポジトリのバックアップを作成することを強くお勧めします。これにより、予期しない問題が発生した場合に備えることができます。&lt;/li&gt;
&lt;li&gt;この操作はGit履歴を書き換えており、コミット作成者の情報を変更するため、コミットハッシュが変更される可能性があります。&lt;/li&gt;
&lt;li&gt;既に変更をリモートリポジトリにプッシュしている場合は、強制プッシュを実行する必要があります。
強制プッシュには注意し、特に複数人での共同プロジェクトでは、他のメンバーへの影響がないように慎重に行ってください。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;リポジトリ内のすべてのユニークな作成者メールアドレスの統計&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git log --format=&#39;%an &amp;lt;%ae&amp;gt;&#39; | sort -u
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>暇を持て余し、中国の水墨画風のテーマでデザインをしたい。</title>
        <link>https://ttf248.life/ja/p/designing-a-chinese-ink-style-theme/</link>
        <pubDate>Tue, 08 Apr 2025 03:42:47 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/designing-a-chinese-ink-style-theme/</guid>
        <description>&lt;p&gt;鮮やかな色彩のホームページに飽きてしまい、急に極簡なスタイルで中国水墨画風のテーマをデザインしたいと思いました。&lt;/p&gt;
&lt;p&gt;現在のスタイルシートは、様々な要素に対して特定のスタイルを設定し、テーマのデフォルトスタイルを上書きしているため、カスタマイズされています。&lt;/p&gt;
&lt;p&gt;リファクタリングを行わずにAIを使って新しいテーマを生成してみましたが、結果は不安定でした。
さらに、trae claudeの大規模言語モデルがキューに並んでおり、vscode agentモードに切り替えた場合、その差は顕著で、修正したものが全くデザイン感のあるものとは言えませんでした。&lt;/p&gt;
&lt;p&gt;結局のところ、自分自身のフロントエンドに関する理解が不足しており、AIに効果的にタスクを分解して委託することができないことが原因です。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>コードを記述せず、カスタム株式選定モジュールを設計・開発する。</title>
        <link>https://ttf248.life/ja/p/design-develop-custom-stock-module-no-code/</link>
        <pubDate>Thu, 27 Feb 2025 23:20:39 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/design-develop-custom-stock-module-no-code/</guid>
        <description>&lt;p&gt;先月の当社では、cursorを試用しましたが、無料枠の制限により、複雑な機能開発は行わず、簡単なテストに留めました。その際に見つけたのは、Byte社も同様の製品を発表しており、両者は共通してClaude-3.5という大規模言語モデルを底で呼んでいる点でした。
Byte社の製品はTraeといい、最初にリリースされたmac版が今年2月にWindows版もリリースされました。大手企業のものは良いもので、無料でClaude-3.5を無制限に利用できるため、このモデルの性能は非常に優れています。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最終的にはK線チャートの開発で詰まってしまいました。Reactの知識が全くない私には、直接的に大きなタスクであるK線チャートの開発を引き受けることはできません。より細かくタスクを分割し、開発を進めるためには、筆者がフロントエンドの基礎知識を追加し、タスクを分解する必要がありました。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;発見された問題点&#34;&gt;発見された問題点
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;外国製のAIモデルを使用していたため、Vue3 + Element-Plusの学習データが不足しており、Reactをフロントエンドフレームワークとして採用しました。&lt;/li&gt;
&lt;li&gt;偶発的な構文エラーが存在する可能性があり、手動での修正が必要です。&lt;/li&gt;
&lt;li&gt;一部の複雑な問題に対する解決策は、人的指導が必要となります。&lt;/li&gt;
&lt;li&gt;コード構造の最適化には、人的指導が必要です。&lt;/li&gt;
&lt;li&gt;最も時間がかかったのは、フロントエンドコードをコンテナにパッケージングすることでした。筆者は環境が全く理解されておらず、&lt;code&gt;.env.production&lt;/code&gt;や&lt;code&gt;tsconfig.json&lt;/code&gt;といった概念自体を知らなかったため、途中で助けを求める豆包（ネットでの質問サイトのユーザー）に頼らざるを得ませんでした。フロントエンドの開発 devモードとbuildモードでは、コードチェックや差異が大きく異なり、対応に苦慮しました。バックエンドのデータベースおよびサービスのコンテナスクリプトは、合計5分で完了しましたが。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AIは現状では開発効率を向上させる主な役割であり、基礎があることが最も重要です。AIがすべての問題を解決してくれるわけではありません。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;リポジトリアドレス&#34;&gt;リポジトリアドレス
&lt;/h2&gt;&lt;p&gt;タイトル通り、今回は手を動かさず、AIと雑談して、自選株モジュールを設計・開発してみます。最終的に何ができるのか試していきます。&lt;/p&gt;
&lt;p&gt;リポジトリアドレス：&lt;a class=&#34;link&#34; href=&#34;https://github.com/ttf248/trae-demo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ttf248/trae-demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;詳細な使用方法は、リポジトリのREADME.mdファイルをご覧ください。&lt;/p&gt;
&lt;p&gt;このリポジトリには多数の提出記録が含まれており、ほとんどが私とTraeとの会話記録、およびTraeの機能に対する私のテストです。対応する機能を実装するために人工干渉を行ったかどうかを備考に記載しています。&lt;/p&gt;
&lt;h2 id=&#34;プロンプト&#34;&gt;プロンプト
&lt;/h2&gt;&lt;p&gt;プロジェクトは、ゼロから作成するものですが、以下の内容がプロジェクトのプロンプトです：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;プロジェクトのプロトタイプ図に基づいて、以下の機能を開発してください：
    *   選別銘柄（ウォッチリスト）機能。契約新規追加、削除、修正、照会をサポートする必要があります。
    *   選別銘柄インターフェースは、基本的な市場データを表示する必要があります。
    *   複数の異なる市場の切り替えをサポートする必要があります。

    フロントエンド：React
    バックエンド：Golang Gin GORM
    データベース：PostgreSQL

    サーバーサイドには、クロスオリジンリクエストをサポートする必要があり、データの検証とエラー処理も考慮する必要があります。バックエンドサービスが利用できない場合、フロントエンドはアラートを表示する必要があります。

    バックエンドは、リクエストとレスポンスのログを表示し、フロントエンドも通信ログを出力して問題のトラブルシューティングに役立てます。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;uiとインタラクションの最適化&#34;&gt;UIとインタラクションの最適化
&lt;/h2&gt;&lt;p&gt;フロントエンドインターフェースのデザインは完全にGrokに依存しています。まず、Trae内で成果物のプロトタイプを作成しましたが、美観が欠けていました。使用していたモデルはコード能力は非常に高いものの、他の能力は弱いため、Grokを使用してフロントエンドのUIを最適化する必要があります。&lt;/p&gt;
&lt;p&gt;現在のインターフェースのスクリーンショットを撮影し、それをGrokにアップロードして、UIを最適化するように指示します。これにより、一度に多くの最適化提案を受け取ることができ、それらを人工的に評価し、Traeにコピーして実行し、最適化の効果を確認できます。&lt;/p&gt;
&lt;h3 id=&#34;技術スタック&#34;&gt;技術スタック
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;フロントエンド：React + TypeScript&lt;/li&gt;
&lt;li&gt;バックエンド：Golang + Gin + GORM&lt;/li&gt;
&lt;li&gt;データベース：PostgreSQL 17&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;システムアーキテクチャ&#34;&gt;システムアーキテクチャ
&lt;/h2&gt;&lt;h2 id=&#34;バックエンドアーキテクチャ&#34;&gt;バックエンドアーキテクチャ
&lt;/h2&gt;&lt;p&gt;バックエンドは Golang の Gin フレームワークを用いて RESTful API を実装しており、主なモジュールには以下が含まれます。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;データベースモジュール&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;GORM を ORM 框架として使用&lt;/li&gt;
&lt;li&gt;環境変数でデータベース接続を設定可能&lt;/li&gt;
&lt;li&gt;自動的にデータベーススキーマのマイグレーションを実行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ルーティングモジュール&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;RESTful API 設計&lt;/li&gt;
&lt;li&gt;一貫したエラーハンドリングメカニズム&lt;/li&gt;
&lt;li&gt;内蔵されたリクエストログ記録&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;クロスオリジン処理&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;ローカル開発環境でのクロスオリジンをサポート&lt;/li&gt;
&lt;li&gt;設定可能な CORS ポリシー&lt;/li&gt;
&lt;li&gt;Cookie を使用したクロスオリジンをサポート&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;フロントエンドアーキテクチャ&#34;&gt;フロントエンドアーキテクチャ
&lt;/h2&gt;&lt;p&gt;フロントエンドはReact + TypeScriptで構築され、以下の機能を実装しています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;株価リストの表示&lt;/li&gt;
&lt;li&gt;お気に入り銘柄の管理&lt;/li&gt;
&lt;li&gt;相場データ表示&lt;/li&gt;
&lt;li&gt;エラー通知メカニズム&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Protobufのゼロ値問題：デフォルト値が暗黙のビジネスロジックの致命的な脅威となる</title>
        <link>https://ttf248.life/ja/p/protobuf-zero-value-trap/</link>
        <pubDate>Thu, 20 Feb 2025 15:26:51 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/protobuf-zero-value-trap/</guid>
        <description>&lt;p&gt;米国株式市場には、プレマーケット、マーケットオープン後、マーケットクローズの3つの取引時間があります。データ配信は、プッシュ通知を使用するか、数値増分のロジック（可能な限り帯域幅を節約）を採用します。初回送信では全量データを送りますが、2回目以降はすべてのフィールドを増分で推送します。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;なぜ最適解を用いないのか？複数のプロジェクトグループに分散しており、一部はすでに数年ローンチされています。弊社は新規の連携のため、できる限り互換性を保つようにしています。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;いくつかの問題点&#34;&gt;いくつかの問題点
&lt;/h2&gt;&lt;p&gt;概要だけでは、特に問題がないように見えるかもしれないが、社内システムアーキテクチャに組み込まれた問題や、それらを引き起こす一連の問題が発生する。直前に問題を解決したにもかかわらず、新たな問題が発生し、その問題は以前の問題によって引き起こされたものである。&lt;/p&gt;
&lt;h3 id=&#34;取引時間帯の認識エラー&#34;&gt;取引時間帯の認識エラー
&lt;/h3&gt;&lt;p&gt;盤中ステージを &lt;code&gt;protobuf&lt;/code&gt; で定義されている 0 と認識していますが、増分配信のため、業務側ではこの 0 がデフォルト値なのか、それとも実際の取引値なのかを明確に判断できません。&lt;/p&gt;
&lt;p&gt;分かりやすく言うと、0 を受信した際に、それが新しい行情設定の値なのか、protobuf のデフォルト値なのかを判断できないということです。&lt;/p&gt;
&lt;h3 id=&#34;オプショナルについて&#34;&gt;オプショナルについて
&lt;/h3&gt;&lt;p&gt;protobuf 3.15 以降、proto3 では (proto2 と同様に) オプショナルキーワードを使用してスカラーフィールドの存在情報を指定できるようになりました。&lt;/p&gt;
&lt;p&gt;チーム内の通信プロトコルは &lt;code&gt;protobuf&lt;/code&gt; をベースにしていますが、歴史的な理由により選択されたバージョンが古く、&lt;code&gt;optional&lt;/code&gt; キーワードをサポートしていません。理解している方はご存知でしょう。底层から &lt;code&gt;protobuf&lt;/code&gt; を導入したため、プロジェクトの底层は静的ライブラリとして &lt;code&gt;protobuf&lt;/code&gt; を公開しており、その結果、全体のコンパイルチェーン全体をアップグレードする必要があり、このコストは非常に高くなっています。&lt;/p&gt;
&lt;h3 id=&#34;gcc-のバージョン問題&#34;&gt;GCC のバージョン問題
&lt;/h3&gt;&lt;p&gt;ようやく解決策を思いついたのだが、底层で異なるバージョンのリリースをするという方法を試みた。可能な限り &lt;code&gt;protobuf&lt;/code&gt; の新しいバージョンのコンパイル依存関係の伝播を制御しようとした。しかし、コンパイル時に &lt;code&gt;gcc&lt;/code&gt; のバージョンが低すぎて、&lt;code&gt;protobuf&lt;/code&gt; の新機能に対応していないことが判明した。
グループ内でよく使われるサーバーの種類：CentOS7、CentOS8。CentOS7 のデフォルトの &lt;code&gt;gcc&lt;/code&gt; バージョンは 4.8 であり、CentOS8 のデフォルトの &lt;code&gt;gcc&lt;/code&gt; バージョンは 8.3 である。&lt;code&gt;protobuf&lt;/code&gt; の新機能は &lt;code&gt;gcc&lt;/code&gt; のバージョンが 7.4 以上であることを必要とするため、CentOS7 はサポートできない。
&lt;a class=&#34;link&#34; href=&#34;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=82461&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Bug 82461 - [7 Regression] Temporary required for brace-initializing (non-literal-type) member variable&lt;/a&gt;。
結局、関連サービスのデプロイやコンパイルサーバーを CentOS8 に移動することで問題を解決した。&lt;/p&gt;
&lt;h2 id=&#34;理論的な列挙&#34;&gt;理論的な列挙
&lt;/h2&gt;&lt;p&gt;問題を全体的に見直すと、よりシンプルで効率的な解決策があります。それは、列挙の定義を調整し、1から番号付けするようにすることです。これにより、デフォルト値とビジネス値を明確に区別でき、上記のような問題を防ぐことができます。&lt;/p&gt;
&lt;h3 id=&#34;なぜ-1-から始める方が合理的なのか&#34;&gt;なぜ 1 から始める方が合理的なのか？
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;protobuf&lt;/code&gt; において、enum 型のデフォルト値は固定で 0 に設定されています。もし、有意義なビジネス値を 0 (例えば「市場中」) に定義した場合、増量プッシュ時にビジネス側では受信した 0 がビジネス値なのか、未設定のデフォルト値なのか判断できません。一方、enum を 1 から定義すれば、0 は無意味なデフォルト値または「未知」の状態として保持でき、問題が解決されます。&lt;/p&gt;
&lt;p&gt;推奨される実践：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;protobuf の enum を設計する際には、常に 0 を無意味なデフォルト値 (例: &lt;code&gt;UNKNOWN&lt;/code&gt; または &lt;code&gt;RESERVED&lt;/code&gt;) として定義すること。&lt;/li&gt;
&lt;li&gt;実際のビジネス値を 1 から割り当て、デフォルト値 0 と区別できるようにすること。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この小さな調整により、取引時間帯の識別の問題を解決するだけでなく、将来のプロトコル設計にも貴重な教訓を提供しました。&lt;/p&gt;</description>
        </item>
        <item>
        <title>バックエンドサービス TCP 通信異常トラブルシューティング</title>
        <link>https://ttf248.life/ja/p/backend-service-tcp-communication-troubleshooting/</link>
        <pubDate>Fri, 14 Feb 2025 22:54:13 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/backend-service-tcp-communication-troubleshooting/</guid>
        <description>&lt;p&gt;ビジネスモデル：バックエンドサービスがTCPを通じてグループの行情ゲートウェイと接続します。接続ごとに、最初に権限リクエストを送信し、その後継続的にハニーポットパケットを送信して接続状態を維持します。&lt;/p&gt;
&lt;p&gt;しかし、ある日、サービス切断警告の情報を受け取りました。詳細なログ調査の結果、バックエンドサービスは継続的にハニーポットパケットを送信していたにもかかわらず、相手からの応答が一切なく、接続自体が断続的に切断されていました。&lt;/p&gt;
&lt;h2 id=&#34;現場要約&#34;&gt;現場要約
&lt;/h2&gt;&lt;p&gt;当初、社内プロジェクトの進捗をオフィスで作業中に、グループチャットに警報情報がポップアップした。一 glance で見ると、以前からの恒常的な問題だと思い、おそらくネットワークタイムアウトによって心拍送信が失敗し、その結果サービスが切断されたと推測した。しかし、ログの詳細な調査の結果、実際にはそうではなかったことが判明した。バックエンドで権限認証メッセージを送信したが、応答を受信せず、同時に心拍パケットは継続的に送信され続け、相手からは心拍データに対する応答が一切なかった。ログの徹底的な分析により、以下の重要な問題点が明らかになった：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;権限認証メッセージへの応答なし：おそらく相手側のシステムが再起動しており、その結果権限認証メッセージがタイムリーに処理されなかった可能性がある。&lt;/li&gt;
&lt;li&gt;権限認証失敗中に心拍パケット送信：調査の結果、これはプログラムロジック上の脆弱性であることが判明した。心拍送信関数の判断ロジックに欠陥があり、接続状態のみを検証し、権限状態の検証を省略していた。&lt;/li&gt;
&lt;li&gt;サービスが切断されなかったこと：もしサービスが切断可能であれば、再接続メカニズムをトリガーして権限認証メッセージを再送信することができた。
現在、解決すべき最後の課題は、なぜサービスが切断されなかったのかである。この問題の解決には、より詳細で精緻な調査が必要となる。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ネットワークパケットの分析&#34;&gt;ネットワークパケットの分析
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;tcpdump&lt;/code&gt; は非常に強力なネットワークパケットキャプチャツールであり、ネットワークパケットを捕捉するために使用できます。ネットワークパケットを分析することで、通信の詳細をより直感的に理解することができます。ここでは、&lt;code&gt;tcpdump&lt;/code&gt; を使用してネットワークパケットをキャプチャし、さらに分析します。
&lt;img src=&#34;https://ttf248.life/p/backend-service-tcp-communication-troubleshooting/20250220151952.png&#34;
	width=&#34;1126&#34;
	height=&#34;202&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;tcpdump&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;557&#34;
		data-flex-basis=&#34;1337px&#34;
	
&gt;
分析図のデータから、心拍が正常に送信され続けていること、相手側のサーバーが応答していないこと、そして &lt;code&gt;ACK&lt;/code&gt; が送られていることがわかります。これにより接続は積極的に切断されません。&lt;/p&gt;
&lt;h2 id=&#34;共通フラグの説明&#34;&gt;共通フラグの説明
&lt;/h2&gt;&lt;p&gt;TCP プロトコルにおいて、&lt;code&gt;PSH&lt;/code&gt; (Push) と &lt;code&gt;ACK&lt;/code&gt; (Acknowledgment) は重要なフラグであり、それぞれデータ転送の制御とフロー制御に使用されます。その機能は以下のとおりです。&lt;/p&gt;
&lt;h3 id=&#34;1-psh-push-flag&#34;&gt;&lt;strong&gt;1. PSH (Push Flag)&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;機能:&lt;/strong&gt;
&lt;code&gt;PSH&lt;/code&gt; フラグは、&lt;strong&gt;受信側がバッファ内のデータを上位のアプリケーションに即時送信するように要求する&lt;/strong&gt; 役割を持ちます（バッファが満杯で待つのではなく）。 つまり、&lt;code&gt;PSH&lt;/code&gt; フラグが付いたデータ段を受信すると、受信側はできるだけ早くそのデータをアプリケーションに処理して送信し、オペレーティングシステムのバッファに一時的に保存することはありません。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;典型的なシナリオ:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTTP/HTTPS リクエスト:&lt;/strong&gt; クライアントがリクエストを送信する際（例: &lt;code&gt;GET /index.html&lt;/code&gt;）には &lt;code&gt;PSH&lt;/code&gt; が設定され、サーバーから即時の応答を希望します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SSH プロトコル:&lt;/strong&gt; 毎回キーボード入力が発生すると &lt;code&gt;PSH&lt;/code&gt; がトリガーされ、入力された文字をリアルタイムで転送します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;リアルタイム通信:&lt;/strong&gt; ビデオストリームやオンラインゲームなど、低遅延のシナリオでは &lt;code&gt;PSH&lt;/code&gt; を使用して遅延を減らすことがあります。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PSH&lt;/code&gt; は必須ではありません。受信側はフラグを無視することもできます（ただし、データを正常に処理する必要があります）。&lt;/li&gt;
&lt;li&gt;送信側が &lt;code&gt;PSH&lt;/code&gt; を設定しない場合、受信側は自身のバッファリング戦略に基づいてデータ送信のタイミングを決定します。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2-ackacknowledgment-flag&#34;&gt;&lt;strong&gt;2. ACK（Acknowledgment Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;機能&lt;/strong&gt;：
&lt;code&gt;ACK&lt;/code&gt; フラグは、&lt;strong&gt;前段のデータが正しく受信されたことを示す&lt;/strong&gt;。各 &lt;code&gt;ACK&lt;/code&gt; には確認番号（&lt;code&gt;Acknowledgment Number&lt;/code&gt;）が含まれており、これは期待される次のバイトのシーケンス番号を表す。TCP の信頼性のある転送の中核メカニズムである。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;動作原理&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;送信側がデータ段を送信すると、期待する受信側の &lt;code&gt;ACK&lt;/code&gt; 値（例えば &lt;code&gt;ACK = シーケンス番号 + データ長&lt;/code&gt;）を付加する。&lt;/li&gt;
&lt;li&gt;受信側がデータを受信すると、受信したデータのシーケンス番号を確認するための &lt;code&gt;ACK&lt;/code&gt; 報文段を生成する。&lt;/li&gt;
&lt;li&gt;送信側は、対応する &lt;code&gt;ACK&lt;/code&gt; を受信するまで再送を行わない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;例&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;送信側がシリアル番号 &lt;code&gt;100～199&lt;/code&gt; のデータ段を送信した場合、期待される受信側の &lt;code&gt;ACK&lt;/code&gt; は &lt;code&gt;200&lt;/code&gt; になる。&lt;/li&gt;
&lt;li&gt;受信側が &lt;code&gt;100～199&lt;/code&gt; 内の特定のデータを受信しない場合、&lt;code&gt;ACK=150&lt;/code&gt; を通じて送信側に再送を通知する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-psh-と-ack-の組み合わせ&#34;&gt;&lt;strong&gt;3. PSH と ACK の組み合わせ&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;TCP 報文において、&lt;code&gt;PSH&lt;/code&gt; (Push) と &lt;code&gt;ACK&lt;/code&gt; (確認応答) は同時に出現することがあり、以下のようなシナリオでよく見られます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTTP リクエスト応答&lt;/strong&gt;：&lt;br&gt;
クライアントが &lt;code&gt;POST&lt;/code&gt; リクエスト（データを含む）を送信する際、&lt;code&gt;PSH&lt;/code&gt; と &lt;code&gt;ACK&lt;/code&gt; を設定し、前の応答の確認を行います。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SSH ハンドシェイク後のコマンド転送&lt;/strong&gt;：&lt;br&gt;
クライアントがコマンドを入力した後、&lt;code&gt;PSH&lt;/code&gt; と &lt;code&gt;ACK&lt;/code&gt; が付いたデータ段を送信することで、コマンドが即座にサーバーで処理されるようにします。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-その他の関連を示すフラグ&#34;&gt;&lt;strong&gt;4. その他の関連を示すフラグ&lt;/strong&gt;
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;フラグ&lt;/th&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;概要&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SYN&lt;/td&gt;
&lt;td&gt;シーケンス&lt;/td&gt;
&lt;td&gt;接続の初期化 (3ウェイハンドシェイク)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;4-その他の重要な関連&#34;&gt;&lt;strong&gt;4. その他の重要な関連&lt;/strong&gt;
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;標識&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;概要&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;FIN&lt;/td&gt;
&lt;td&gt;終了&lt;/td&gt;
&lt;td&gt;エレガントな接続のクローズ&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;4-その他の関連を示すフラグ-1&#34;&gt;&lt;strong&gt;4. その他の関連を示すフラグ&lt;/strong&gt;
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;フラグ&lt;/th&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;概要&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;RST&lt;/td&gt;
&lt;td&gt;リセット&lt;/td&gt;
&lt;td&gt;接続の強制終了 (異常状況)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;4-その他の重要な関連-1&#34;&gt;&lt;strong&gt;4. その他の重要な関連&lt;/strong&gt;
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;標識&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;概要&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;URG&lt;/td&gt;
&lt;td&gt;緊急&lt;/td&gt;
&lt;td&gt;緊急ポインタのマーク (ほとんど使用されない)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;4-その他の関連要素&#34;&gt;&lt;strong&gt;4. その他の関連要素&lt;/strong&gt;
&lt;/h3&gt;&lt;h3 id=&#34;まとめ&#34;&gt;&lt;strong&gt;まとめ&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;PSH&lt;/strong&gt; は、&lt;strong&gt;データのアプリケーション層への迅速な到達&lt;/strong&gt; と遅延の低減に焦点を当てています。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ACK&lt;/strong&gt; は、&lt;strong&gt;データの信頼性の高い伝送&lt;/strong&gt; とパケットロスや乱数（順不同）を防ぐことに焦点を当てています。
両者は連携して、TCP プロトコルの効率性と信頼性をバランスしています。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>ollama ローカル実行 deepseek-R1</title>
        <link>https://ttf248.life/ja/p/ollama-local-deployment-deepseek-r1/</link>
        <pubDate>Fri, 07 Feb 2025 22:41:02 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/ollama-local-deployment-deepseek-r1/</guid>
        <description>&lt;p&gt;Ollamaは、大規模言語モデル（LLM）をローカルで実行およびデプロイすることを目的としたオープンソースのAIツールです。クラウドサービスへの依存なしに、開発者がローカルマシン上でGPTのようなモデルを使用するための簡単なかつ効率的な方法を提供することを目指しています。Ollamaは複数のモデルに対応し、パフォーマンスを最適化することで、リソースが限られたデバイスでもこれらのモデルをスムーズに実行できるように設計されています。&lt;/p&gt;
&lt;p&gt;Ollamaを使用すると、ユーザーはテキストベースのAIアプリケーションを利用でき、ローカルでデプロイされたモデルとインタラクトすることができ、データプライバシーやAPIの使用料金に関する懸念なく、自然言語処理や質問応答などのタスクを実行できます。コマンドラインインターフェース（CLI）を通じて異なるモデルを呼び出し、これらのタスクを実行できます。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ollamaは様々なモデルを試すのに適しており、Windows版のテストではハードウェアの性能を十分に発揮できなかった可能性があります。これはWindows版の問題かもしれません。Linux版の方が良い結果が得られる可能性があります。32bパラメータのモデルをデプロイし、メモリとGPU負荷が低い場合に、応答速度が遅いことが確認されました。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;ハードウェア概要&#34;&gt;ハードウェア概要
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;オペレーティングシステム: Windows 11&lt;/li&gt;
&lt;li&gt;CPU: i7-10700K&lt;/li&gt;
&lt;li&gt;メモリ: 40GB&lt;/li&gt;
&lt;li&gt;グラフィックカード: RTX 3060 12GB&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;環境準備&#34;&gt;環境準備
&lt;/h2&gt;&lt;p&gt;以下のシステム環境変数を設定し、後続の使用を容易にします：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;set OLLAMA_MODELS=E:\ollama&lt;/code&gt;&lt;/strong&gt;
この変数で Ollama モデルの保存場所を指定します。 &lt;code&gt;E:\ollama&lt;/code&gt; はフォルダパスであり、ダウンロードまたはデプロイしたローカルモデルファイルをすべてここに格納します。Ollama はこのパスに基づいてモデルをロードおよび使用します。モデルファイルの保存場所を変更する場合は、このパスを更新してください。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;set OLLAMA_HOST=127.0.0.1:8000&lt;/code&gt;&lt;/strong&gt;
Ollama サービスのホストとポートを設定します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;127.0.0.1&lt;/code&gt; はローカルアドレス（localhost）であり、Ollama サービスは本機からのリクエストのみを待ち受けます。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;8000&lt;/code&gt; は指定するポート番号であり、Ollama サービスが 8000 ポートでリクエストを受信および処理します。必要に応じてポート番号を変更できますが、他のアプリケーションで使用されていないことを確認してください。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;set OLLAMA_ORIGINS=*&lt;/code&gt;&lt;/strong&gt;
Ollama サービスへのアクセスを許可するオリジン（ソース）を制御します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; はすべてのオリジン（つまり、すべてのドメインと IP アドレス）が Ollama サービスにアクセスできることを意味します。これは通常、開発およびデバッグ環境で使用されます。本番環境では、セキュリティを高めるために、特定のドメインまたは IP アドレスのみを許可するようにより厳格なオリジン制御を設定することが一般的です。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;deepseek-r1-モデルのデプロイ&#34;&gt;DeepSeek-R1 モデルのデプロイ
&lt;/h2&gt;&lt;p&gt;ollama のインストールは、初心者向けで簡単なため、詳細は省略します。
インストール後の検証：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\core&amp;gt;ollama -v
ollama version is 0.5.11
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;モデルのデプロイについては、公式ウェブサイトのモデルページを参照し、対応するパラメータのモデルを選択してください: &lt;code&gt;ollama run deepseek-r1:14b&lt;/code&gt;
14b パラメータは会話コンテキストを効果的に記憶でき、より小さなパラメータバージョンではコンテキストを記憶できません。32b パラメータバージョンは、ローカルでのデプロイ時に非常に遅延するため、詳細なテストは行っていません。&lt;/p&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.ollama.com/library/deepseek-r1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.ollama.com/library/deepseek-r1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://mp.weixin.qq.com/s/SPEvYTmTBxhoEkJqm1yPmw&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mp.weixin.qq.com/s/SPEvYTmTBxhoEkJqm1yPmw&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/x18990027/article/details/145368094&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/x18990027/article/details/145368094&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>PowerShell 7 と Persistence 設定 コマンドライン予測ビュー</title>
        <link>https://ttf248.life/ja/p/powershell-7-persisting-settings-commandline-prediction-view/</link>
        <pubDate>Fri, 07 Feb 2025 22:19:12 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/powershell-7-persisting-settings-commandline-prediction-view/</guid>
        <description>&lt;p&gt;Linux で使慣れた zsh を、昨日ブログを書いている時に、突然 PowerShell 7 もセッション保持設定でコマンド履歴予測ビューをサポートしていることを発見し、試しに触ってみたら、意外と便利だった。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;何が原因かはわからないけど、何か操作をしてこの機能を起動しただけで、それで終わり。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;現在多様化するオペレーティング環境において、システム管理者や開発者は、プラットフォーム間での互換性、効率性、そして強力な機能を備えたツールを求めています。PowerShell 7 はまさにそのニーズに応える注目を集めているツールです。強力なスクリプト作成能力に加え、Windows、Linux、macOS など様々なオペレーティングシステム上で動作するため、ユーザーに前例のない利便性をもたらします。&lt;/p&gt;
&lt;h2 id=&#34;powershell-7クロスプラットフォームな強力なツール&#34;&gt;PowerShell 7：クロスプラットフォームな強力なツール
&lt;/h2&gt;&lt;h3 id=&#34;クロスプラットフォーム特性&#34;&gt;クロスプラットフォーム特性
&lt;/h3&gt;&lt;p&gt;PowerShell 7は、プラットフォームの制限を打破し、Windowsシステムでのエンタープライズレベルのサーバー管理、Linux環境でのシステム運用、macOSでの日常開発タスクなど、あらゆる環境で一貫してPowerShell 7ツールを使用できます。これにより、作業効率が大幅に向上し、プラットフォームの違いによる学習コストや操作複雑性の問題を軽減します。&lt;/p&gt;
&lt;h3 id=&#34;強力な機能&#34;&gt;強力な機能
&lt;/h3&gt;&lt;p&gt;強力なスクリプト作成能力を備え、オブジェクト指向プログラミング、関数、モジュールなどの高度なプログラミング特性をサポートします。PowerShell 7 を通じて、ユーザーはファイルシステムを簡単に操作し、ファイルやフォルダの作成、削除、コピー、移動などの操作を実行できます。レジストリにアクセスして変更することで、システムの構成を深く調整することも可能です。プロセスとサービスを管理し、システムの状態を効果的に監視および制御することもできます。さらに、PowerShell 7 は、Active Directory におけるユーザーと権限の管理や、Azure クラウドプラットフォームにおけるリソースの配分と管理など、さまざまな Windows および非 Windows 技術との相互作用も可能です。&lt;/p&gt;
&lt;h3 id=&#34;オープンソースエコシステム&#34;&gt;オープンソースエコシステム
&lt;/h3&gt;&lt;p&gt;PowerShell 7はオープンソースであり、この特性により、世界中の開発者や愛好家がその開発と改善に積極的に参加できるようになっています。大量のオープンソースモジュールやツールが継続的に登場し、PowerShell 7 の機能と応用シナリオを豊かにしています。ユーザーは自分のニーズに応じて、オープンソースコミュニティで適切なモジュールを見つけて PowerShell 7 の機能を拡張したり、自身のコードを貢献してコミュニティ全体の発展を推進したりすることができます。&lt;/p&gt;
&lt;h3 id=&#34;互換性と安定性&#34;&gt;互換性と安定性
&lt;/h3&gt;&lt;p&gt;PowerShell 7は、旧バージョンのPowerShellとの互換性を維持しながら、多くの新機能と改善を導入しました。これらの改善により、パフォーマンスが向上し、安定性が強化され、ユーザーはさまざまなタスクをよりスムーズに実行でき、ソフトウェアの故障による作業中断を減らすことができます。&lt;/p&gt;
&lt;h2 id=&#34;コマンドレット予測ビューの起動&#34;&gt;コマンドレット予測ビューの起動
&lt;/h2&gt;&lt;p&gt;PowerShell 7 の多くの便利な機能の中で、&lt;code&gt;Set-PSReadLineOption -PredictionViewStyle ListView&lt;/code&gt; コマンドは、ユーザーのコマンドライン入力体験を向上させるための実用的なツールです。&lt;/p&gt;
&lt;p&gt;コマンドを実行しなくても自動補完を実現できますが、これは行内での補完に限定されます。この機能を有効にすると、リスト形式で可能なすべての補完オプションを表示する予測ビューが利用できるようになり、ユーザーは上下キーを使用して必要なオプションを選択することで、コマンド入力の正確性と効率を向上させることができます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/powershell-7-persisting-settings-commandline-prediction-view/20250207222546.png&#34;
	width=&#34;814&#34;
	height=&#34;205&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;powershell7&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;397&#34;
		data-flex-basis=&#34;952px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;コマンドを永続化する方法&#34;&gt;コマンドを永続化する方法
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Set-PSReadLineOption -PredictionViewStyle ListView&lt;/code&gt; のようなコマンドを、PowerShellの起動時に常に有効にするには、それを PowerShell の設定ファイルに追加します。PowerShellの設定ファイルは、PowerShell が起動される際に自動的に実行する命令を含む特別なスクリプトです。&lt;/p&gt;
&lt;h3 id=&#34;設定ファイルのパスを特定する&#34;&gt;設定ファイルのパスを特定する
&lt;/h3&gt;&lt;p&gt;PowerShell では、&lt;code&gt;$PROFILE&lt;/code&gt; 変数を使用して設定ファイルのパスを確認できます。もしこのパスにファイルが存在しない場合は、ユーザーは手動で作成することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo $PROFILE
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;設定ファイルのオープン&#34;&gt;設定ファイルのオープン
&lt;/h3&gt;&lt;p&gt;テキストエディタ（例えば、高機能な Notepad++ や軽量の Visual Studio Code）を使用して、$PROFILE 変数で取得した設定ファイルパスに対応するファイルを開きます。&lt;/p&gt;
&lt;h3 id=&#34;コマンドの追加&#34;&gt;コマンドの追加
&lt;/h3&gt;&lt;p&gt;開いている構成ファイルに、&lt;code&gt;Set-PSReadLineOption -PredictionViewStyle ListView&lt;/code&gt; コマンドを追加します。コマンドの記述が正確であることを確認し、構成ファイルを実行する際に正しく有効になるようにしてください。&lt;/p&gt;
&lt;h3 id=&#34;構成ファイルへの保存&#34;&gt;構成ファイルへの保存
&lt;/h3&gt;&lt;p&gt;コマンドの追加が完了したら、構成ファイルを保存しテキストエディタを閉じます。これにより、構成ファイルには、PowerShell起動時に実行したいと希望するコマンドが含まれるようになります。&lt;/p&gt;
&lt;h3 id=&#34;検証設定&#34;&gt;検証設定
&lt;/h3&gt;&lt;p&gt;現在の PowerShell ウィンドウを閉じ、PowerShell を再起動します。 新しく起動した PowerShell でコマンドを入力する際、コマンドラインでの予測ビュースタイルの表示が、当方の設定に従いリスト形式で表示されることを確認します。 これにより、当方の設定が正常に適用されたことを示します。
上記の手順を実行することで、PowerShell 7 の強力な機能と特性についてより深く理解し、コマンドラインでの予測ビュースタイルの設定方法を習得するとともに、これらの設定を永続的に適用する方法も学びます。 これらの知識が、PowerShell 7 を使用する際に、よりスムーズかつ効率的に様々なシステム管理および自動化タスクを完了できるようになることを願っています。&lt;/p&gt;
&lt;h2 id=&#34;参考資料&#34;&gt;参考資料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/PowerShell/PowerShell/releases&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/PowerShell/PowerShell/releases&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.v2ex.com/t/911909&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.v2ex.com/t/911909&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>atopツールでLinuxシステム指標を監視する：インストール、設定と使い方完全ガイド</title>
        <link>https://ttf248.life/ja/p/atop-linux-system-monitoring-guide/</link>
        <pubDate>Thu, 06 Feb 2025 22:48:55 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/atop-linux-system-monitoring-guide/</guid>
        <description>&lt;p&gt;Linuxシステム運用において、リアルタイムかつ包括的にシステムリソースとプロセス状態を監視することは非常に重要です。atopは強力なモニタリングツールとして、この目標を簡単に達成するのに役立ちます。本稿では、Linuxインスタンスにatopモニタリングツールをインストール、設定、使用する方法について詳細に説明します。&lt;/p&gt;
&lt;h2 id=&#34;一atopツールの紹介&#34;&gt;一、atopツールの紹介
&lt;/h2&gt;&lt;p&gt;atopは、Linuxシステムの資源とプロセスを監視するために専門的に設計されたツールです。システムおよびプロセスの活動を記録し、すべてのプロセスの実行状況を報告します。このツールが収集するデータには、CPU、メモリ、ディスク、ネットワークなどのリソース使用量、およびプロセス状態が含まれます。さらに、データをログファイル形式でディスクに保存することも可能です。各プロセスについて、CPU使用率、メモリ増加量、ディスク使用量、優先度、ユーザー名、ステータス、および終了コードなど、重要な情報を取得できます。また、atopの設定ファイルを通じて、ログ収集頻度、ログファイル保存パス、ローテーションポリシーなどのパラメータをカスタマイズすることも可能です。&lt;/p&gt;
&lt;h2 id=&#34;二atopツールのインストール&#34;&gt;二、atopツールのインストール
&lt;/h2&gt;&lt;p&gt;異なるLinuxディストリビューションでのatopのインストール方法は若干異なります。以下に一般的なオペレーティングシステムを例として説明します。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Alibaba Cloud Linux 3/2、CentOS 7/8、Fedora、Rocky Linux 9&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;インストールコマンドの実行: &lt;code&gt;sudo yum install -y atop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;atopサービスの起動: &lt;code&gt;sudo systemctl start atop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ubuntu / Debian&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;パッケージリストの更新: &lt;code&gt;sudo apt update&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;インストールコマンドの実行: &lt;code&gt;sudo apt install -y atop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;atopサービスの起動: &lt;code&gt;sudo systemctl start atop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CentOS Stream 9&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;ダウンロードとインストール: &lt;code&gt;sudo wget https://www.atoptool.nl/download/atop-2.11.0-1.el9.x86_64.rpm &amp;amp;&amp;amp; sudo rpm -i atop-2.11.0-1.el9.x86_64.rpm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;atopサービスの起動: &lt;code&gt;sudo systemctl start atop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;openSUSE&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;インストールコマンドの実行: &lt;code&gt;sudo zypper install -y atop atop-daemon&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;atopサービスの起動: &lt;code&gt;sudo systemctl start atop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上記で列挙されたオペレーティングシステムが含まれていない場合は、atop公式ウェブサイトからインストール情報を参照してください。&lt;/p&gt;
&lt;h2 id=&#34;iii-モニタリング周期とログ保持期間の設定&#34;&gt;III. モニタリング周期とログ保持期間の設定
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;設定ファイル位置:&lt;/strong&gt; Alibaba Cloud Linux 3/2、CentOS 7/8およびFedoraシステムでは、atopの設定ファイルは&lt;code&gt;/etc/sysconfig/atop&lt;/code&gt;です。Ubuntu、DebianおよびopenSUSEシステムでは、設定ファイルは&lt;code&gt;/etc/default/atop&lt;/code&gt;です。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;デフォルト設定パラメータの説明&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LOGOPTS&lt;/code&gt;: 日志ファイル記録オプションを制御するために使用され、デフォルトでは空です。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LOGINTERVAL&lt;/code&gt;: モニタリング周期で、デフォルトは600秒です。問題追跡のために過去のログを収集する場合は、実際の要件に応じてこの頻度を調整することをお勧めします。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LOGGENERATIONS&lt;/code&gt;: ログ保持期間で、デフォルトは28日間です。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LOGPATH&lt;/code&gt;: 日志ファイルの保存パスで、デフォルトは&lt;code&gt;/var/log/atop&lt;/code&gt;です。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;設定手順&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;設定ファイルを開くためのコマンドの実行:
&lt;ul&gt;
&lt;li&gt;Alibaba Cloud Linux 3/2、CentOS 7/8およびFedoraシステムでは: &lt;code&gt;sudo vim /etc/sysconfig/atop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Ubuntu、Debian、openSUSE、CentOS Stream 9、Rocky Linux 9システムでは: &lt;code&gt;sudo vim /etc/default/atop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;キーを押して編集モードに入り、必要な設定パラメータを調整します。例えば、モニタリング周期を30秒に、ログ保持期間を7日間に設定し、ログパスはデフォルトのままにする場合：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Esc&lt;/code&gt;キーを押してコマンドモードに戻り、&lt;code&gt;:wq&lt;/code&gt;と入力して保存および終了します。&lt;/li&gt;
&lt;li&gt;設定を有効にするためにatopサービスを再起動します: &lt;code&gt;sudo systemctl restart atop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;LOGOPTS=&amp;quot;&amp;quot;
LOGINTERVAL=30
LOGGENERATIONS=7
LOGPATH=/var/log/atop
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;四atopツールを使用&#34;&gt;四、atopツールを使用
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;一般的なコマンドの説明:&lt;/strong&gt; インタラクティブコマンドモード下では、以下の一般的なコマンドが使用できます。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g&lt;/code&gt;: デフォルトの総合出力ビューに戻ります。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c&lt;/code&gt;: プロセスの完全なコマンドラインを表示します。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m&lt;/code&gt;: プロセスのメモリ使用率で降順にソートします。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d&lt;/code&gt;: プロセスのディスク使用率で降順にソートします。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt;: プロセスの総合的なリソース使用率で降順にソートします。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt;: プロセスのネットワーク使用率で降順にソートします。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt;: 次のモニタ収集ポイントにジャンプします。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt;: 前のモニタ収集ポイントにジャンプします。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt;: 形式が&lt;code&gt;YYYYMMDDhhmm&lt;/code&gt;である時間点を指定します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;リソース監視フィールドの意味の説明:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ATOP&lt;/strong&gt;: ホスト名、情報サンプリングの日付と時刻。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PRC&lt;/strong&gt;: プロセスの全体的な実行状況（カーネルモードとユーザーモードの実行時間、プロセス総数、異なる状態のプロセスの数など）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPU&lt;/strong&gt;: CPU全体の利用状況。各フィールドの数字を合計した結果が&lt;code&gt;N*100%&lt;/code&gt;（NはCPUコア数）で、カーネルモード、ユーザーモード、割り込み、アイドル、ディスクI/O待ちなどの時間割合を含みます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPL&lt;/strong&gt;: CPU負荷状況（過去1分、5分、および15分間のキュー内の平均プロセス数、コンテキストスイッチの回数、割り込みの発生回数）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MEM&lt;/strong&gt;: メモリの使用状況（物理メモリ総量、空きメモリ、ページキャッシュメモリ、ファイルキャッシュメモリ、カーネル占有メモリなど）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SWP&lt;/strong&gt;: スワップ領域の使用状況（スワップ区画総量と空きスワップ領域のサイズ）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PAG&lt;/strong&gt;: 仮想メモリページの状況（入ったページ数と出たページ数）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DSK&lt;/strong&gt;: ディスクの使用状況。各ディスクデバイスに対応する列があり、デバイス識別子、繁忙状態時間割合、読み書きリクエスト数を表示します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NET&lt;/strong&gt;: ネットワークの状態。TCPおよびUDPのトランスポート層、IP層、および各アクティブなポートの受信および送信パケットサイズを表示します。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;リアルタイムシステム指標を確認する:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;5秒ごとにシステム指標をチェックします: &lt;code&gt;atop 5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;現在時刻以降5分間（合計30回、10秒間隔）システム指標をチェックします: &lt;code&gt;atop -M 10 30&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;現在時刻以降10分間（10回、60秒間隔）システム指標をチェックし、結果をファイルに書き込みます: &lt;code&gt;atop -M 60 10 &amp;gt; /log/atop.mem&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;履歴指標ログを確認する:&lt;/strong&gt; atopが起動されると、収集記録はデフォルトで&lt;code&gt;/var/log/atop&lt;/code&gt;ディレクトリに保存されます。確認時には、指定された日付のログファイルが存在している必要があり、存在しない場合、エラーが発生します。
&lt;ul&gt;
&lt;li&gt;その日の履歴指標ログを確認します: &lt;code&gt;atop -r&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;昨日の履歴指標ログを確認します: &lt;code&gt;atop -r y&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指定された日付の履歴指標ログを確認します（例：2024年11月6日）：&lt;code&gt;atop -r 20241106&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指定された日付内の指定時間以降の履歴指標ログを確認します（例：2024年11月6日14:00以降）：&lt;code&gt;atop -r 20241106 -b 14:00&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指定された日付内、指定された時間間隔の履歴指標ログを確認します（例：2024年11月5日00:04～00:08）：&lt;code&gt;atop -r 20241105 -b 00:04 -e 00:08&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;システムアクティビティレポートを確認する:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;現在のシステムを1分間（12回、5秒間隔）のCPU使用率レポートを確認します: &lt;code&gt;atopsar -c 5 12&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;その日の指定された時間間隔のメモリ指標レポートを確認します（例：18:00～18:01）：`at&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;五その他の操作&#34;&gt;五、その他の操作
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;天级别ログローテーション戦略の設定&lt;/strong&gt;：毎日atop指標ログファイルを生成したい場合は、以下の手順を実行してください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;（オプション）要件に応じて監視周期、ログ保持時間、およびログストレージパスを調整します。&lt;/li&gt;
&lt;li&gt;以下のコマンドで、毎日ログローテーションに関連するサービスが起動時に自動的に起動し、サービスを開始します：&lt;code&gt;sudo systemctl enable --now atop atopacct atop-rotate.timer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ビジネス要件によっては、logrotateやカスタムスクリプトを使用してログ管理をより複雑に実装することも可能です。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;オプションのnetatopカーネルモジュールのロード&lt;/strong&gt;：ネットワーク使用率を監視する必要がある場合は、atopにはデフォルトでnetatopモジュールがインストールされていないため、netatopモジュールをインストールします（Alibaba Cloud Linux 3システムの場合）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;カーネル開発パッケージおよびコンパイルに必要なソフトウェア環境をインストールします：&lt;code&gt;sudo yum install -y kernel-devel dkms elfutils-libelf-devel&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最新バージョンのnetatopソースコードを指定ディレクトリにダウンロードします：&lt;code&gt;cd /usr/src/ &amp;amp;&amp;amp; sudo wget https://www.atoptool.nl/download/netatop-3.2.2.tar.gz --no-check-certificate&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ソースコードを解凍し、ソースコードディレクトリに入ります：&lt;code&gt;sudo tar -zxvf netatop-3.2.2.tar.gz &amp;amp;&amp;amp; cd netatop-3.2.2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ソースコードに基づいてモジュールとデーモンをビルドおよびインストールします：&lt;code&gt;sudo make &amp;amp;&amp;amp; sudo make install&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;netatopサービスを開始します：&lt;code&gt;sudo systemctl start netatop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;atopツールは強力で柔軟性があり、適切にインストール、設定、および使用することで、Linuxシステムの実行状況をより良く理解し、潜在的な問題をタイムリーに特定して解決することができます。この記事が皆様のLinuxシステム監視能力向上の一助となれば幸いです。&lt;/p&gt;
&lt;h2 id=&#34;6参考链接&#34;&gt;6．参考链接
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.atoptool.nl/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;atop公式サイト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://help.aliyun.com/zh/ecs/use-cases/use-the-atop-tool-to-monitor-linux-system-metrics#99e53d0198euu&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;atopモニタリングツールのインストール、設定、および使用方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Visual Studio が「不整合な」PDB ファイルをロードできません。</title>
        <link>https://ttf248.life/ja/p/visual-studio-load-unmatched-pdb/</link>
        <pubDate>Thu, 23 Jan 2025 20:04:33 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/visual-studio-load-unmatched-pdb/</guid>
        <description>&lt;p&gt;WindowsでVisual Studioを使ってプログラムをデバッグする場合、PDBファイルと実行可能ファイルが一致しない場合、Visual Studioは「シンボルファイルを読み込めません」というエラーを表示します。プログラムの実行中にクラッシュが発生し、ダンプファイルが生成される場合、不一致なPDBファイルの場合、Visual Studioはクラッシュ現場にスムーズに入ることができません。&lt;/p&gt;
&lt;h2 id=&#34;pdb-ファイルとは&#34;&gt;PDB ファイルとは
&lt;/h2&gt;&lt;p&gt;PDB ファイルは、Microsoft が提供するデバッグ情報ファイルで、プログラムのデバッグに使用されます。PDB ファイルには、シンボルテーブル、ソースコード名、行番号などの情報が含まれています。プログラムをコンパイルするときに PDB ファイルが生成され、プログラムのデバッグに使用されます。&lt;/p&gt;
&lt;h2 id=&#34;windbg-デバッグ&#34;&gt;WinDbg デバッグ
&lt;/h2&gt;&lt;p&gt;WinDbg は Microsoft 製のデバッガで、Windows プログラムをデバッグするために使用されます。WinDbg は不一致な PDB ファイルをロードできますが、手動でロードする必要があります。.reload /f /i コマンドを使用して、強制的に不一致な PDB ファイルをロードできます。
しかし、WinDbg の使い勝手は Visual Studio ほど簡単ではないため、Visual Studio も不一致な PDB ファイルをロードできるようにしたいと考えています。&lt;/p&gt;
&lt;h2 id=&#34;visual-studio-での-pdb-ファイルのマッチングエラー&#34;&gt;Visual Studio での PDB ファイルのマッチングエラー
&lt;/h2&gt;&lt;p&gt;ソースコードは現在、Git などのバージョン管理システムで管理されており、完全に一致するバージョンのコードを再コンパイルし、対応する PDB ファイルを生成できます。なぜこの PDB ファイルが読み込まれないのでしょうか？主な原因は、メタデータの不一致です。&lt;/p&gt;
&lt;p&gt;元データを修正し、EXE ファイルの情報に基づいて新しい PDB ファイルを生成することで、Visual Studio が PDB ファイルを読み込めるようになります。&lt;/p&gt;
&lt;p&gt;ChkMatch ダウンロード先：&lt;a class=&#34;link&#34; href=&#34;https://www.debuginfo.com/tools/chkmatch.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.debuginfo.com/tools/chkmatch.html&lt;/a&gt;
サイトのキャッシュアドレス：&lt;a class=&#34;link&#34; href=&#34;chkmatch.zip&#34; &gt;chkmatch.zip&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ChkMatch ユーティリティは、実行ファイルとデバッグ情報ファイルの間のマッチングを確認するために使用できます。また、互換性のある実行ファイルとデバッグ情報ファイルをマッチさせるために使用することもできます。

デバッグ情報のマッチングに関する詳細情報や関連する問題については、こちらの記事を参照してください。

サポートされているデバッグ情報形式：DBG, PDB 2.0, PDB 7.0

chkmatch [-c ExeFile DebugInfoFile ] |
         [-m ExeFile DebugInfoFile]
-c
実行ファイルとデバッグ情報ファイルの間のマッチングを確認します。
-m
実行ファイルとデバッグ情報ファイルをマッチさせます。
ExeFile
実行ファイルの名前。
DebugInfoFile
デバッグ情報ファイルの名前。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;chkmatch-の使用&#34;&gt;chkmatch の使用
&lt;/h2&gt;&lt;p&gt;まず、検査を実行し、不一致の原因を分析して、署名が一致しないことを示します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\tianlong.xiang\Downloads\chkmatch&amp;gt;ChkMatch.exe -c &amp;quot;D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe&amp;quot; E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb
ChkMatch - version 1.0
Copyright (C) 2004 Oleg Starodumov
http://www.debuginfo.com/


Executable: D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe
Debug info file: E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb

Executable:
TimeDateStamp: c26d9be3
Debug info: 2 ( CodeView )
TimeStamp: f86b0a4f  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 122  RVA: 001cdc44  FileOffset: 001cbe44
CodeView format: RSDS
Signature: {428c9b95-39a3-4a8d-a8e5-7be453684757}  Age: 1
PdbFile: D:\stock_UAT\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\obj\Release\YinTrade.Main.pdb
Debug info: 16 ( Unknown )
TimeStamp: 00000000  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 0  RVA: 00000000  FileOffset: 00000000

Debug information file:
Format: PDB 7.00
Signature: {06fae08e-c0a2-4f3d-9c7c-dfc684445dd1}  Age: 1

Result: Unmatched (reason: Signature mismatch)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;次に、デバッグ情報ファイルと実行可能ファイルを一致させる操作を実行します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\tianlong.xiang\Downloads\chkmatch&amp;gt;ChkMatch.exe -m &amp;quot;D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe&amp;quot; E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb
ChkMatch - version 1.0
Copyright (C) 2004 Oleg Starodumov
http://www.debuginfo.com/


Executable: D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe
Debug info file: E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb

Executable:
TimeDateStamp: c26d9be3
Debug info: 2 ( CodeView )
TimeStamp: f86b0a4f  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 122  RVA: 001cdc44  FileOffset: 001cbe44
CodeView format: RSDS
Signature: {428c9b95-39a3-4a8d-a8e5-7be453684757}  Age: 1
PdbFile: D:\stock_UAT\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\obj\Release\YinTrade.Main.pdb
Debug info: 16 ( Unknown )
TimeStamp: 00000000  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 0  RVA: 00000000  FileOffset: 00000000

## 参考資料
- [forcing-to-load-unmatched-symbols-in-visual-studio-2015-debugger](https://stackoverflow.com/questions/38147487/forcing-to-load-unmatched-symbols-in-visual-studio-2015-debugger)&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>Cursor AI プログラミング IDE のトライアル</title>
        <link>https://ttf248.life/ja/p/cursor-ai-programming-ide-trial/</link>
        <pubDate>Thu, 23 Jan 2025 19:30:13 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cursor-ai-programming-ide-trial/</guid>
        <description>&lt;p&gt;一年又转眼即逝之际，在工作中最大的变化莫过于AI参与度明显提高。以往，不同开发语言之间切换，需要开发者熟悉各种语言的不同API接口，现在这些基础代码都可以通过AI生成代码了，对于开发者来说，无疑是一个巨大的福音。&lt;/p&gt;
&lt;h2 id=&#34;chatgpt&#34;&gt;ChatGPT
&lt;/h2&gt;&lt;p&gt;23年の時点で、簡単な入門紹介を既に2本作成していましたが、今では25年となり、どう表現しようか… 顕著な進歩を感じ取ることはなく、自律的な認知能力を発展させ、タスクを合理的に分割できることなどが求められます。もちろん、最も重要なのはAIが生成したコードにバグが存在するかどうかを特定することです。&lt;/p&gt;
&lt;h2 id=&#34;github-copilot&#34;&gt;Github Copilot
&lt;/h2&gt;&lt;p&gt;いつの日か忘れましたが、シンガポールでサーバーがデプロイされているという情報を見つけました。国内では利用され、長期間のVPN接続も不要になりました。ただし、ログイン時にはVPN接続は必要ですが、そのVPN接続はログイン時のみ使用し、その後はオフにしておくことができます。&lt;/p&gt;
&lt;p&gt;日常的な使い道としてはGithub Copilotをより多く活用しています。この拡張機能は、VS CodeやVisual Studioで直接利用できます。2つのソフトウェア間の切り替えが不要です。ChatGPTと比較して、Github Copilotの方がプロジェクトのサポートが優れており、インタラクションもフレンドリーです。また、一部のローカルファイルをAIに「学習」させることで、生成されるコードがあなたのプロジェクトに合っているものになります。&lt;/p&gt;
&lt;h2 id=&#34;cursor-ai&#34;&gt;Cursor AI
&lt;/h2&gt;&lt;p&gt;最近、Cursor AI という新しいAIプログラミングIDEを見つけました。これはGithub Copilotをベースにしたもので、このIDEはよりスマートで、直接ファイルを作成するのを手伝ってくれます。&lt;/p&gt;
&lt;p&gt;簡単な使い方は試してみて、なかなか良いと感じましたが、既存プロジェクトの理解はまだ十分ではありません。ローカルプロジェクトのファイルが多い場合や、大規模なリファクタリング、最適化、調整を行う場合は、やはり&lt;strong&gt;開発者がタスクを分割して行う&lt;/strong&gt;必要があります。&lt;/p&gt;
&lt;p&gt;例として、curso のエンジンモードに切り替えて、以下の内容を入力してみましょう。「複数の異なるスタイルで切り替えられる個人用履歴書ウェブページの作成。個人情報をデータ表示のために埋めてください。」&lt;/p&gt;
&lt;p&gt;何度かやり取りするうちに、以下のようなウェブページが得られます。もちろん、このウェブページはかなりシンプルですが、初心者にとっては非常に良いでしょう。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;現在の登録ユーザーは、高度なAPIを150回無料で試用でき、有料ユーザーは5,000回まで制限されています。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;cursor-ai-1&#34;&gt;Cursor AI
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://cursor/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;履歴書&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>C&#43;&#43; ビット演算の基礎：ビットごとのANDとフラグ設定</title>
        <link>https://ttf248.life/ja/p/cpp-bitwise-operations-flags/</link>
        <pubDate>Fri, 17 Jan 2025 02:23:56 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cpp-bitwise-operations-flags/</guid>
        <description>&lt;p&gt;実際のC++開発において、ビット演算は一般的な技術であり、特にシステムの状態、フラグビット、または制御ビットを扱う際に、ビット演算は非常に効率的な解決策を提供します。本稿では、例を通して、ビット演算を使用して特定のフラグビットを取得および設定する方法について解説します。&lt;/p&gt;
&lt;h3 id=&#34;ビット演算の基礎概念&#34;&gt;ビット演算の基礎概念
&lt;/h3&gt;&lt;p&gt;コンピュータでは、データは2進数（0と1）のビットで格納されます。ビット演算とは、これらのビットに対して操作を行うことです。C++には、いくつかの一般的なビット演算演算子が用意されています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;論理積（&amp;amp;）&lt;/strong&gt;：特定のビットが1であるかどうかを確認します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;論理和（|）&lt;/strong&gt;：特定のビットを1に設定します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;排他的論理和（^）&lt;/strong&gt;：特定のビットを反転させます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ビット反転（~）&lt;/strong&gt;：すべてのビットを反転させます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;左シフト（&amp;laquo;）&lt;/strong&gt;：すべてのビットを左に指定された数だけシフトします。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;右シフト（&amp;raquo;）&lt;/strong&gt;：すべてのビットを右に指定された数だけシフトします。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本例では、&lt;code&gt;unsigned short&lt;/code&gt; 型の変数 &lt;code&gt;wInfo&lt;/code&gt; に対して、さまざまなビット演算を実行し、異なるフラグビットを使用して状態を表す必要があります。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;flowchart LR
    A[元の数値: 00010000] --&amp;gt; B[左シフト: 00010000 &amp;lt;&amp;lt; 1]
    B --&amp;gt; C[結果: 00100000]
    C --&amp;gt; D[右シフト: 00100000 &amp;gt;&amp;gt; 1]
    D --&amp;gt; E[結果: 00010000]

    subgraph 左シフト操作
        direction LR
        A --&amp;gt; B --&amp;gt; C
    end

    subgraph 右シフト操作
        direction LR
        C --&amp;gt; D --&amp;gt; E
    end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;要求分析&#34;&gt;要求分析
&lt;/h3&gt;&lt;p&gt;問題文の記述に基づき、16ビットのフラグビットがあり、これを用いて様々な状態を表します。これらの状態は個々のバイナリビットによって表現され、各バイナリビットは特定の意味に対応しています。例えば：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;bit0&lt;/strong&gt; が失敗かどうか&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit1&lt;/strong&gt; が圧縮されているかどうか&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit2&lt;/strong&gt; が増分であるかどうか&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit3&lt;/strong&gt; が後続のパケットがあるかどうか&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit5&lt;/strong&gt; が正常なリクエストまたは注销かどうか&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;位演算による実装&#34;&gt;位演算による実装
&lt;/h3&gt;&lt;p&gt;ビット演算を使用してこれらのフラグを設定および取得します。具体的には：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ビットごとの抽出 (ビットマスク)&lt;/strong&gt;: 特定のビットの値（0または1）を取得します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ビット設定&lt;/strong&gt;: 特定のビットを1に設定します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ビットクリア&lt;/strong&gt;: 特定のビットを0に設定します。
最初に &lt;code&gt;unsigned short&lt;/code&gt; 型の変数 &lt;code&gt;wInfo&lt;/code&gt; を定義し、これらのフラグを保存するために使用します。その後、ビット演算を使用して対応するフラグを確認および設定します。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;c-のサンプルコード&#34;&gt;C++ のサンプルコード
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;bitset&amp;gt;

// フラグ定数を定義
const unsigned short BIT_0_FAIL = 1 &amp;lt;&amp;lt; 0;    // bit0 が失敗したか
const unsigned short BIT_1_COMPRESSED = 1 &amp;lt;&amp;lt; 1; // bit1 が圧縮されたか
const unsigned short BIT_2_INCREMENT = 1 &amp;lt;&amp;lt; 2;  // bit2 がインクリメントされたか
const unsigned short BIT_3_HAS_MORE = 1 &amp;lt;&amp;lt; 3;   // bit3 に後続のパッケージがあるか
const unsigned short BIT_5_CANCEL = 1 &amp;lt;&amp;lt; 5;     // bit5 は正常リクエスト(0)または注销(1)

// あるビットがセットされているか確認する関数
bool isBitSet(unsigned short wInfo, unsigned short bitMask) {
    return (wInfo &amp;amp; bitMask) != 0;
}

// あるビットをセットする関数
void setBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo |= bitMask;
}

// あるビットをクリア（0に設定）する関数
void clearBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo &amp;amp;= ~bitMask;
}

int main() {
    // wInfo の初期値を 0 と仮定
    unsigned short wInfo = 0;

    // bit0（失敗フラグ）を設定
    setBit(wInfo, BIT_0_FAIL);

    // bit1（圧縮フラグ）を設定
    setBit(wInfo, BIT_1_COMPRESSED);

    // wInfo の2進数表記を出力
    std::cout &amp;lt;&amp;lt; &amp;quot;wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    // 各フラグを確認
    std::cout &amp;lt;&amp;lt; &amp;quot;bit0 (失敗したか): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_0_FAIL) ? &amp;quot;はい&amp;quot; : &amp;quot;いいえ&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit1 (圧縮されたか): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_1_COMPRESSED) ? &amp;quot;はい&amp;quot; : &amp;quot;いいえ&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit2 (インクリメントされたか): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_2_INCREMENT) ? &amp;quot;はい&amp;quot; : &amp;quot;いいえ&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit3 (後続のパッケージがあるか): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_3_HAS_MORE) ? &amp;quot;はい&amp;quot; : &amp;quot;いいえ&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit5 (注销されたか): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_5_CANCEL) ? &amp;quot;はい&amp;quot; : &amp;quot;いいえ&amp;quot;) &amp;lt;&amp;lt; std::endl;

    // bit1（圧縮フラグ）をクリア
    clearBit(wInfo, BIT_1_COMPRESSED);

    // 更新された wInfo の2進数表記を出力
    std::cout &amp;lt;&amp;lt; &amp;quot;Updated wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;コードを実行することを推奨します：&lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wInfo (in binary): 0000000000000001
bit0 (失敗したか): はい
bit1 (圧縮されたか): いいえ
bit2 (インクリメントされたか): いいえ
bit3 (後続のパッケージがあるか): いいえ
bit5 (注销されたか): いいえ
Updated wInfo (in binary): 0000000000000000
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;コード解説&#34;&gt;コード解説
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;フラグの定義&lt;/strong&gt;: ビットシフト演算 (&lt;code&gt;1 &amp;lt;&amp;lt; n&lt;/code&gt;) を使用して、各フラグを定義します。例えば、&lt;code&gt;1 &amp;lt;&amp;lt; 0&lt;/code&gt; は &lt;code&gt;bit0&lt;/code&gt; に対応し、&lt;code&gt;1 &amp;lt;&amp;lt; 1&lt;/code&gt; は &lt;code&gt;bit1&lt;/code&gt; に対応するなど、同様に推測されます。このようにして、各フラグには一意のバイナリ位置が割り当てられます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特定のビットの確認&lt;/strong&gt;: &lt;code&gt;isBitSet&lt;/code&gt; 関数は、指定されたフラグが設定されているかどうかを確認するために、AND 演算 (&lt;code&gt;wInfo &amp;amp; bitMask&lt;/code&gt;) を使用します。もしそのビットが1の場合、関数は &lt;code&gt;true&lt;/code&gt; を返し、そうでない場合は &lt;code&gt;false&lt;/code&gt; を返します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特定のビットの設定&lt;/strong&gt;: &lt;code&gt;setBit&lt;/code&gt; 関数は、指定されたフラグを1に設定するために、ビットごとのOR 演算 (&lt;code&gt;wInfo |= bitMask&lt;/code&gt;) を使用します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特定のビットのクリア&lt;/strong&gt;: &lt;code&gt;clearBit&lt;/code&gt; 関数は、指定されたフラグを0に設定するために、ビットごとのAND 演算 (&lt;code&gt;wInfo &amp;amp;= ~bitMask&lt;/code&gt;) を使用します。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;結論&#34;&gt;結論
&lt;/h3&gt;&lt;p&gt;ビット演算を用いることで、複数の状態フラグを効率的に処理できるようになります。実際の開発においては、この技術が特に有用です。例えば、組み込み開発、ネットワークプロトコル、システムステート管理などの場面で、複数のバイナリ状態を表すためにビットフラグが頻繁に使用されます。スペースの節約と効率向上に貢献します。
この記事が、C++ でビット演算を用いてビットごとの取得と設定を理解し、習得するのに役立つことを願っています！これらのスキルは、効率的で保守しやすいコードを書く上で非常に役立ちます！&lt;/p&gt;
</description>
        </item>
        <item>
        <title>デスクトップPCを2.5Gネットカードにアップグレードし、ローカルエリアネットワークの接続速度を向上させる。</title>
        <link>https://ttf248.life/ja/p/desktop-upgrade-to-2-5g-network-card-accelerates-local-area-network-interconnection/</link>
        <pubDate>Fri, 10 Jan 2025 00:37:52 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/desktop-upgrade-to-2-5g-network-card-accelerates-local-area-network-interconnection/</guid>
        <description>&lt;p&gt;デスクトップPCのハードウェア三連発！前回の記事では、SSD PCIeアダプタについて触れたばかりですが、旧いSSDはどこへ行ったのでしょうか？もちろん無駄にはせず、壊れてしまっていたりするかもしれませんが、分解して新しく購入した「メカシシャ・クリエーター Mini-3765H」（一年前のモデル）にインストールしました。&lt;/p&gt;
&lt;p&gt;このマシンは、ハードウェアスペックも十分に強力で、2.5GデュアルLAN、PCIe4.0、Wi-Fi 6を搭載しています。&lt;/p&gt;
&lt;p&gt;最近引っ越しをして、部屋にルーターを個別に設置してネットワークを構築することができず、すべてのマシンが無線ネットワーク経由で接続されています。ASUSのマザーボードデスクトップPCの無線LANカードの性能はあまり良くなく、ルーターの無線アクセスポイント、ローカルエリア間のアップロード速度が遅いこともあり、マシン間での通信速度が不安定でした。そこで、2.5G NIC（ネットワークインターフェースカード）を購入し、デスクトップPCにインストールしました。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;これで、マザーボードのスロットはすべて埋まりました：グラフィックカード、無線LANカード、2.5G NIC、SSD PCIeアダプタ。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;ネットワークの説明&#34;&gt;ネットワークの説明
&lt;/h2&gt;&lt;p&gt;両台の機器が元の無線LANに接続されているが、両台間をケーブルで直結し、両端に2.5G網カードを装着する。ケーブルで両台を直結する方法については、詳細は省略する（インターネット上には多くのチュートリアルがある）。ファイアウォールを必ず解除することに注意する。どちらか一方をゲートウェイとして使用すればよい。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
    A[マシン1&amp;lt;br&amp;gt;IP: 192.168.4.1&amp;lt;br&amp;gt;サブネットマスク: 255.255.255.0&amp;lt;br&amp;gt;デフォルトゲートウェイ: - &amp;lt;br&amp;gt;自動取得DNS] --&amp;gt;|ケーブル直結（2.5G）| B[マシン2&amp;lt;br&amp;gt;IP: 192.168.4.2&amp;lt;br&amp;gt;サブネットマスク: 255.255.255.0&amp;lt;br&amp;gt;デフォルトゲートウェイ: 192.168.4.1&amp;lt;br&amp;gt;自動取得DNS];
    A --&amp;gt;|無線LANカード| Internet;
    B --&amp;gt;|無線LANカード| Internet;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;二重網段測速&#34;&gt;二重網段測速
&lt;/h2&gt;&lt;h3 id=&#34;ルーティング局域網&#34;&gt;ルーティング局域網
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\core\Desktop\iperf-3.1.3-win32&amp;gt;iperf3.exe -c 192.168.3.237
接続先ホスト 192.168.3.237、ポート 5201 に接続
[  4] ローカル 192.168.3.122 ポート 1656 が 192.168.3.237 のポート 5201 に接続
[ ID] インターバル           転送     帯域幅
[  4]   0.00-1.00   秒  9.17 MB  76.7 Mbps
[  4]   1.00-2.00   秒  9.91 MB  83.2 Mbps
[  4]   2.00-3.00   秒  8.74 MB  73.3 Mbps
[  4]   3.00-4.00   秒 10.2 MB  85.2 Mbps
[  4]   4.00-5.00   秒  9.23 MB  77.1 Mbps
[  4]   5.00-6.00   秒  8.80 MB  73.9 Mbps
[  4]   6.00-7.01   秒  8.00 MB  66.8 Mbps
[  4]   7.01-8.00   秒  7.69 MB  64.9 Mbps
[  4]   8.00-9.01   秒  9.72 MB  81.1 Mbps
[  4]   9.01-10.01  秒  7.63 MB  63.6 Mbps
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] インターバル           転送     帯域幅
[  4]   0.00-10.01  秒 89.0 MB  74.6 Mbps                  送信元
[  4]   0.00-10.01  秒 89.0 MB  74.6 Mbps                  宛先

iperf Done.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;直連局域網&#34;&gt;直連局域網
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\core\Desktop\iperf-3.1.3-win32&amp;gt;iperf3.exe -c 192.168.4.1
接続 192.168.4.1 に、ポート 5201 を確立
[  4] ローカル 192.168.4.2 ポート 1524 が 192.168.4.1 のポート 5201 と接続
[ ID] インターバル           転送     帯域幅
[  4]   0.00-1.01   秒   178 MB   1.48 Gbps
[  4]   1.01-2.00   秒   204 MB   1.72 Gbps
[  4]   2.00-3.00   秒   214 MB   1.80 Gbps
[  4]   3.00-4.00   秒   229 MB   1.92 Gbps
[  4]   4.00-5.00   秒   202 MB   1.69 Gbps
[  4]   5.00-6.00   秒   213 MB   1.79 Gbps
[  4]   6.00-7.00   秒   230 MB   1.93 Gbps
[  4]   7.00-8.00   秒   192 MB   1.61 Gbps
[  4]   8.00-9.00   秒   220 MB   1.84 Gbps
[  4]   9.00-10.00  秒   230 MB   1.93 Gbps
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] インターバル           転送     帯域幅
[  4]   0.00-10.00  秒  2.06 GB   1.77 Gbps                  送信元
[  4]   0.00-10.00  秒  2.06 GB   1.77 Gbps                  宛先

iperf 終了
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考資料&#34;&gt;参考資料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://wutongsuimeng.github.io/post/%E7%BB%99hugo%E6%B7%BB%E5%8A%A0mermaid%E6%94%AF%E6%8C%81/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;HugoにMermaidを導入する方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>ASUS マザーボード Z490 のディスクが多すぎ、ランダムなディスクが認識されない。</title>
        <link>https://ttf248.life/ja/p/asus-z490-motherboard-disk-recognition-issues/</link>
        <pubDate>Fri, 10 Jan 2025 00:08:51 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/asus-z490-motherboard-disk-recognition-issues/</guid>
        <description>&lt;p&gt;前の文脈を踏まえ、突然無線LANアダプターが認識されなくなった問題が発生しました。パーティションを再構築する前に、インターネット上でも他の解決策を探しておりました。例えば、マザーボードの電池卸載や、電源を切って15分間待つなどの方法がありました。また、最新版のBOISドライバーへのアップデートも試しましたが、いずれもうまくいきませんでした。&lt;/p&gt;
&lt;p&gt;他に処理すべきことがあり、制限ネットワークに切り替えて、リビングから部屋へ網線を引き込んだところ、有線LANも認識されなくなりました。最終手段としてシステムを再インストールしたところ、パーティションのガイダンスが失われました。もし常に問題が発生していれば、これほど長く悩むことはありませんでした。華碩のマシンにおけるディスク競合は、偶発的なものであり、システムの再起動時に不安定な状態がトリガーとなるようです。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;先週、台式机に新しい长江存储（チャンジアン cunzhuo）の2TB SSD（M.2インターフェース）を追加したところ、マシンは再起動せず、昨日までシャットダウンすることができませんでした。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/asus-z490-motherboard-disk-recognition-issues/20250110002801.png&#34;
	width=&#34;553&#34;
	height=&#34;322&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;ディスクフルハウス&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;171&#34;
		data-flex-basis=&#34;412px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;システムの再インストール&#34;&gt;システムの再インストール
&lt;/h2&gt;&lt;p&gt;時間を作ってみると、もう2年もシステムを再インストールしていない。Cドライブが足りなくなってきた。Windows の古い問題や、日常的に使用するソフトウェアが Cドライブに何かを保存しようとする。そこで、システムを再インストールすることにした。システムを再インストールした後、ネットワークカードの問題はすべて正常になった。翌日には、開発環境を回復させることができ、システムのバックアップを作成するために、新たな問題が発生した。システムを再起動すると、ブートパーティションが失われた。
前回の記事の手順に従い、ブートパーティションを再構築したが、不安定で、再起動するとブートパーティションが読み込まれなくなる可能性がある。折詰機箱を分解しようかと思ったとき、ハードディスクケーブルが緩んでいることに気づいたが、何度か確認しても問題なかった。&lt;/p&gt;
&lt;h2 id=&#34;記憶の想起&#34;&gt;記憶の想起
&lt;/h2&gt;&lt;p&gt;数年前、この機械はSSDを一度増設した際、PCIe変換器（グラフィックカードのポートに接続）を使用していました。これは、直接マザーボードに取り付けるのではなく、変換器を通してHDDを取り付ける方法でした。今回、直接マザーボードに取り付けたのは、おそらくマザーボードの問題である可能性があります。
&lt;img src=&#34;https://ttf248.life/p/asus-z490-motherboard-disk-recognition-issues/20250110002148.png&#34;
	width=&#34;325&#34;
	height=&#34;545&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;SSD変換器&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;59&#34;
		data-flex-basis=&#34;143px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;マザーボードマニュアル&#34;&gt;マザーボードマニュアル
&lt;/h2&gt;&lt;p&gt;マザーボードマニュアルに問題があり、記載されているSATAポートの位置と実際の位置が異なっております。ディスクの多さから、ポートにはすべてハードドライブが取り付けられており、古いSSDはSATAポートを使用しています。マニュアルでは、ポート間の競合が存在すると記載されています。しかし、実際にテストを行ったところ、この競合は不安定に発生し、発生すると対応するディスクを読み込めなくなります。ちょうどこれがシステムディスクであり、ブートローダーも同じディスク上に存在するため、システム起動時にブートローダーのロードに失敗します。
&lt;img src=&#34;https://ttf248.life/p/asus-z490-motherboard-disk-recognition-issues/20250110002401.png&#34;
	width=&#34;807&#34;
	height=&#34;847&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Z490&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;95&#34;
		data-flex-basis=&#34;228px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;解決策&#34;&gt;解決策
&lt;/h2&gt;&lt;p&gt;SSDをPCIe変換器に再インストールすることで、この問題を解決できます。その結果、マザーボード上のSATAポートとの競合が解消され、システム起動が正常に行われます。&lt;/p&gt;</description>
        </item>
        <item>
        <title>ESPセグメントの探求、GPTセグメントテーブルとWindowsオペレーティングシステムの協調性に関する深掘り</title>
        <link>https://ttf248.life/ja/p/esp-partitioning-gpt-windows-cooperation/</link>
        <pubDate>Thu, 09 Jan 2025 23:58:20 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/esp-partitioning-gpt-windows-cooperation/</guid>
        <description>&lt;p&gt;昨から退勤して帰宅し、慣例に従いデスクトップPCを起動。システムが正常に起動したが、無線LANアダプターを読み込めない。カードが緩んでいるのではないかと推測し、分解して無線LANアダプターを再インストールしたところ、問題が拡大した。システムが直接起動できなくなり、ブートローダーのロードに失敗した。&lt;/p&gt;
&lt;p&gt;長らくPCをメンテナンスしていなかったため、パーティションの構成やブートローダーの構築が少し戸惑う。DisGeniusで空きパーティションを再作成（通常はディスクの前部へ分割）し、ESPパーティション（デフォルト300MB）として割り当て、PEシステムでブートローダーを再構築した。関連情報はネット上で見つけることができた。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/esp-partitioning-gpt-windows-cooperation/20250110000433.png&#34;
	width=&#34;330&#34;
	height=&#34;269&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;新規ESPパーティション&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;122&#34;
		data-flex-basis=&#34;294px&#34;
	
&gt;
&lt;img src=&#34;https://ttf248.life/p/esp-partitioning-gpt-windows-cooperation/20250110000509.png&#34;
	width=&#34;433&#34;
	height=&#34;355&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;MSRパーティションを削除しても良い&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;121&#34;
		data-flex-basis=&#34;292px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;コンピュータのストレージ世界において、ESPパーティション、GPTパーティション表、そしてWindowsオペレーティングシステムは密接に関連し、それぞれが独自の役割を果たし、システムの安定した動作と効率的な管理を支えている。しかし、これらの仕組みを理解する前に、コンピュータのパーティション歴史における「先駆者」であるMBRパーティション表形式について言及せざるを得ない。それは後続の技術と相互に照らし合い、テクノロジーの進化の軌跡をより際立たせる。今日では、これらの内部の関係性と精妙な点について深く掘り下げてみよう。&lt;/p&gt;
&lt;h2 id=&#34;1-mbrパーティションテーブル---伝統的なハードディスクのパーティショニングにおける基礎&#34;&gt;1. MBRパーティションテーブル - 伝統的なハードディスクのパーティショニングにおける「基礎」
&lt;/h2&gt;&lt;p&gt;MBR (Master Boot Record) は、個人コンピュータが誕生当初から存在し、数十年にもわたってハードディスクのパーティショニング領域を支配してきた。&lt;/p&gt;
&lt;h3 id=&#34;1-基本構造&#34;&gt;1. 基本構造
&lt;/h3&gt;&lt;p&gt;これはハードディスクの最初のセクタ、つまり0号セクタに位置し、512バイトの領域を占有しています。この512バイトは主に3つの部分に分けられています。第一にブートプログラムコードで、コンピュータ起動時にオペレーティングシステムのブートローダーをロードする役割を担い、通常446バイトを占めます。第二にディスクパーティション表で、64バイトを占め、最大4つのメインパーティションに関する情報を記述します。各パーティションは16バイトを占め、セクタ、トラック、パーティションの開始位置などの重要なパラメータを記録し、パーティションの種類とサイズなどを記録します。最後に2バイトがMBR終端マーク“55 AA”で、このセクタが有効なMBRであることを示します。&lt;/p&gt;
&lt;h3 id=&#34;2-功績と限界&#34;&gt;2. 功績と限界
&lt;/h3&gt;&lt;p&gt;初期においては、MBRパーティション表は個人向けコンピュータの比較的単純なストレージニーズを完全に満たしていました。これにより、オペレーティングシステムはハードディスクのパーティションをスムーズに認識し、データの整理された保存と読み取りを実現しました。しかし、時代とともにその限界がより顕著になっていきました。第一に、64バイトのパーティション表領域に限定されるため、最大で4つのプライマリパーティションしか作成できず、さらに多くのパーティションを作成するには、拡張パーティションや論理パーティションといったやや複雑な方法を用いる必要があり、ディスク管理を煩雑にしました。第二に、最大容量が2TBに制限されており、現代では数TB、場合によっては数十TBの大型ハードディスクに対しては力不足であり、これはストレージ技術のさらなる発展を阻害するボトルネックとなりました。&lt;/p&gt;
&lt;h2 id=&#34;2-espパーティション系統的な隠れ起動の鍵&#34;&gt;2. ESPパーティション—系統的な「隠れ起動の鍵」
&lt;/h2&gt;&lt;p&gt;ESP (EFI System Partition) は、EFI システムパーティションの略称です。これは、UEFI (Unified Extensible Firmware Interface) 標準に基づくコンピュータに必要な特別なパーティションです。&lt;/p&gt;
&lt;h3 id=&#34;1-機能特性&#34;&gt;1. 機能特性
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;起動ブート&lt;/strong&gt;：コンピュータが通電して起動する際、UEFIファームウェアはまずハードディスク上のESPパーティションを検索し、そこに保存されている起動ロードプログラム（例：Windows Boot Manager）を読み込み、オペレーティングシステムを開始します。これは精密な鍵であり、システムの起動の扉を開けるものであり、これがないと、コンピュータが起動時に迷茫状態に陥り、どこへ向かうべきか分からなくなります。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ストレージドライバ&lt;/strong&gt;：ESPパーティションには、システムの起動中に必要なドライバも保存されており、早期起動段階でハードウェアデバイス（例：ハードディスクコントローラ、グラフィックカードなど）が正常に動作し、オペレーティングシステムがスムーズに接管するための基盤を築きます。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-空間要請とフォーマット&#34;&gt;2. 空間要請とフォーマット
&lt;/h3&gt;&lt;p&gt;通常、ESP 分割領域の推奨サイズは 100MB ～ 500MB であり、一般的には 200MB 程度を割り当てれば基本的な要件を満たします。ファイルシステム形式は FAT32 である必要があり、これは UEFI ファームウェアが FAT32 形式で起動ファイルを読み取れるためであり、互換性とクロスプラットフォーム性を保証するためです。&lt;/p&gt;
&lt;h2 id=&#34;3-gptパーティションテーブルハードディスクのスマートマネージャー&#34;&gt;3. GPTパーティションテーブル—ハードディスクの「スマートマネージャー」
&lt;/h2&gt;&lt;p&gt;GPT（GUID Partition Table）は、グローバルユニーク識別パーティションテーブルの略で、従来のMBRパーティションテーブルを代替する新しいパーティション方式です。&lt;/p&gt;
&lt;h3 id=&#34;1-メリットの顕著化&#34;&gt;1. メリットの顕著化
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;大容量対応&lt;/strong&gt;：現在のようなデータ爆発の時代において、大容量ハードディスクが続々と登場しています。GPTパーティションテーブルはMBRの2TBの容量制限を突破し、理論上では9.4ZB（ゼタバイト、1ZB=1024EB、1EB=1024PB、1PB=1024TB）という超大容量のストレージスペースに対応可能となり、大量データの保存を可能にします。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;パーティション数が多い&lt;/strong&gt;：MBRでは最大で4つのパーティションしか区別できないのに対し、GPTは最大で128個のパーティションを作成できます。これにより、ユーザーとシステム管理者には極めて柔軟性があり、複数のシステムパーティション、データパーティションの分割や、特殊な用途のためのパーティションの割り当てなど、あらゆる状況に対応できます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;信頼性が高い&lt;/strong&gt;：GPTパーティションテーブルは冗長バックアップメカニズムを採用しており、ハードディスクの頭と尾にそれぞれパーティションテーブルの情報が保存されています。一方のパーティションテーブルが破損した場合、システムは自動的にもう一方からのバックアップから復元し、パーティションテーブルの故障によるデータ損失のリスクを大幅に低減し、データセキュリティをサポートします。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-構造解析&#34;&gt;2. 構造解析
&lt;/h3&gt;&lt;p&gt;GPT 分区表は、保護 MBR (これは従来の BIOS との互換性を保つために保持されている小さな MBR 構造であり、実際のパーティション管理には使用されません)、GPT ヘッダー (GPT パーティション表の基本的な情報（パーティションテーブルのバージョン、パーティション数、パーティションテーブルサイズなど）を格納します) およびパーティション項目配列 (各パーティション項目は、開始セクタ、終了セクタ、パーティションタイプ GUID、パーティションの一意な識別子などの重要な情報を詳細に記録します) など、複数の部分で構成されています。これらの構造が相互に連携し、ハードディスクのスペースを正確に計画および管理します。&lt;/p&gt;
&lt;h2 id=&#34;4-windows-オペレーティングシステム---ユーザーのデジタル相互天地&#34;&gt;4. Windows オペレーティングシステム - ユーザーの「デジタル相互天地」
&lt;/h2&gt;&lt;p&gt;Windows は世界的に広く使用されているオペレーティングシステムであり、人々とコンピューターハードウェア間の親しみやすい橋を築いています。&lt;/p&gt;
&lt;h3 id=&#34;1-espパーティションとgptパーティションテーブルの統合&#34;&gt;1. ESPパーティションとGPTパーティションテーブルの統合
&lt;/h3&gt;&lt;p&gt;UEFIブートを前提としたWindowsシステムのインストールプロセスにおいて、インストーラは自動的にESP（EFIシステムパーティション）を作成し、起動ファイルをその中に展開します。同時に、ハードディスクをGPTパーティションテーブル形式で初期化し、システム保留領域（システムキーファイルなどを格納する、従来のBIOS下でのシステムブートファイル領域に類似したもの）、Windowsシステムパーティション（Windowsのコアファイルを格納する場所）、およびその他のユーザーが作成したデータパーティションなど、複数のパーティションを分割します。WindowsはGPTパーティションテーブルを使用して各パーティションを正確に識別し、ESPパーティションとのスムーズな連携により起動を円滑に進めるため、快適な起動と使用体験を提供します。&lt;/p&gt;
&lt;h3 id=&#34;2-システム管理と最適化の活用&#34;&gt;2. システム管理と最適化の活用
&lt;/h3&gt;&lt;p&gt;Windows は実行中に、GPT パーティション表の利点を十分に活用し、ディスク管理を行います。例えば、ディスク管理ツールで GPT パーティションを簡単に認識でき、ユーザーはパーティションの作成、削除、フォーマット、サイズ調整などの操作を実行して、さまざまな段階のデータストレージニーズに対応できます。また、システムアップデートやソフトウェアインストールといったプロセスもパーティション構成と密接に関連しており、適切なパーティション計画はシステムのパフォーマンスと安定性を向上させ、ディスク容量不足やパーティションの混乱によって引き起こされる問題を軽減するのに役立ちます。&lt;/p&gt;
&lt;h2 id=&#34;5-実戦小貼示維持と故障診断&#34;&gt;5. 実戦小貼示：維持と故障診断
&lt;/h2&gt;&lt;p&gt;それらの密接な関係を理解した上で、日々の維持管理と故障診断は、手順に沿って進めることができます。&lt;/p&gt;
&lt;h3 id=&#34;1-ディスクスペース管理&#34;&gt;1. ディスクスペース管理
&lt;/h3&gt;&lt;p&gt;ESPパーティションの空き容量を定期的に確認し、起動項目のソフトウェアを過剰にインストールすることで空き容量が不足するのを防ぎ、システムの起動に影響を与えないようにします。GPTパーティション下のデータパーティションについては、適切なストレージ計画を立て、不要なファイルを適宜削除し、単一パーティションが満杯になることでシステム動作に影響がないようにします。&lt;/p&gt;
&lt;h3 id=&#34;2-起動時のトラブルシューティング&#34;&gt;2. 起動時のトラブルシューティング
&lt;/h3&gt;&lt;p&gt;システムが起動しない場合、まずESPパーティションが破損またはファイルが失われているか確認してください。UEFIファームウェアに搭載されているブートエントリ修復ツールを使用するか、Windowsインストールメディアから修復環境に入り、ESPパーティションのブートファイルを再構築します。GPTパーティションテーブルの故障を疑う場合は、DiskGeniusなどの専門ディスクユーティリティを使用してパーティションテーブルの整合性をチェックし、バックアップされたパーティションテーブル情報を復元して失われたパーティションを回復してください。&lt;/p&gt;
&lt;p&gt;ESPパーティション、GPTパーティションテーブル、およびWindowsオペレーティングシステムは、それぞれが専門分野を持ち、精密な連携により、安定した効率的なコンピューター環境を実現します。これらを深く理解することで、システムインストールやメンテナンスにおいて的確に対応でき、コンピュータの低レベル動作ロジックを把握し、デジタル世界を自由に探索することができます。一方、MBRパーティションテーブルの興亡を振り返ると、技術進歩の力に感銘を受けます。これは、ストレージ技術がデータ保存ニーズの高まりに合わせて継続的に進化を促してきたことを示しています。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>GCC、GLIBC および C&#43;&#43; プログラムの互換性に関する深い理解</title>
        <link>https://ttf248.life/ja/p/gcc-glibc-cpp-compatibility/</link>
        <pubDate>Mon, 06 Jan 2025 19:51:16 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/gcc-glibc-cpp-compatibility/</guid>
        <description>&lt;p&gt;C++の開発分野において、GCCとGLIBCは避けて通れない重要な要素であり、プログラムのリリース後の互換性問題も開発者を悩ませる常 occurrenceである。本稿では、その本質を深く分析し、互換性問題の原因と対策を探求する。&lt;/p&gt;
&lt;h2 id=&#34;i-gcc強力なコンパイラ基盤&#34;&gt;I. GCC：強力なコンパイラ基盤
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;定義と機能&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;GCC（GNU Compiler Collection）は、GNUプロジェクトが開発したオープンソースのコンパイラセットです。単なるコンパイラではなく、C、C++、Objective - C、Fortran、Ada、Goなど、主要な言語を幅広くサポートしており、複数の言語を使った開発において、一元的なソリューションを提供します。&lt;/li&gt;
&lt;li&gt;例えばC++の場合、クラス、テンプレート、関数オーバーロードなどの複雑な特性を持つソースファイルを記述する際、GCCはC++の厳格な構文と意味規則に従い、高度なC++コードを、低レベルの機械が理解し実行できる命令列に変換します。このプロセスには、トークン解析、構文解析、意味解析、最適化、コード生成など、複数の詳細な段階が含まれます。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;コンパイルプロセスの詳細&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;前処理フェーズ&lt;/strong&gt;: GCCはまずソースファイルを前処理操作を行います。この過程で、&lt;code&gt;#&lt;/code&gt;で始まるすべてのプリプロセス指示子を処理します。例えば、&lt;code&gt;#include&lt;/code&gt;指示子は、指定されたヘッダーファイル（例：C++の標準入出力ストリーム操作のための&lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt;）の内容をソースファイルの対応する位置に埋め込みます。これにより、プログラムはヘッダーファイルで宣言されている関数、クラスなどのリソースを使用できるようになります。&lt;code&gt;#define&lt;/code&gt;指示子によるマクロ展開もこの段階で行われ、例として&lt;code&gt;#define PI 3.14159&lt;/code&gt;の場合、ソースファイル内のすべての&lt;code&gt;PI&lt;/code&gt;の箇所が&lt;code&gt;3.14159&lt;/code&gt;に置き換えられます。前処理後、ソースファイルは初期的に「拡張」されます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;コンパイルフェーズ&lt;/strong&gt;: 前処理されたファイルをコンパイル段階に入力し、GCCはC++言語標準に従い、ソースコードをアセンブリ言語コードに変換します。この過程で、クラスの継承、ポリモーフィズムの実装が正しく行われているか、関数呼び出しパラメータが一致しているかなどを厳密にチェックし、構文や意味規則に合致しないエラーが見つかった場合は、即座にエラーを報告してコンパイルプロセスを停止します。例えば、関数宣言と定義の引数リストが一致しない場合、GCCは正確に問題箇所を示します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;アセンブルフェーズ&lt;/strong&gt;: アセンブラは、前工程で生成されたアセンブリコードを機械語に変換し、&lt;code&gt;.o&lt;/code&gt;拡張子のターゲットファイルを作成します。これらのターゲットファイルには、機械が直接実行できるバイナリ命令が含まれていますが、通常、完全なプログラムは複数のモジュールで構成されており、各モジュール間の関数や変数への参照が解決されていないため、独立して実行できません。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;リンクフェーズ&lt;/strong&gt;: これは、実行可能ファイルを生成するための最終的な段階です。リンカは、複数のターゲットファイルと必要なライブラリ（静的ライブラリまたは動的ライブラリ）を統合します。例えば、C++の標準テンプレートライブラリにあるコンテナクラス（&lt;code&gt;vector&lt;/code&gt;、&lt;code&gt;list&lt;/code&gt;など）を使用する場合、対応するライブラリの実装コードを見つけてリンクし、プログラム実行時にこれらのコンテナ機能が正しく呼び出せるようにすることで、完全な実行可能ファイルを生成します。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二glibccプログラム実行の幕後ろ支柱&#34;&gt;二、GLIBC：C++プログラム実行の幕後ろ支柱
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;本質と作用&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;GLIBC（GNU C Library）は、C標準ライブラリの GNU エコシステム下における具体的な実装です。名前が C を強調していますが、C++ プログラムも高度に依存しており、C++ は C の基礎部分を受け継いでいるためです。大量の基本的な関数を提供し、例えばメモリ管理に使用される &lt;code&gt;malloc&lt;/code&gt;（動的メモリ割り当て）、&lt;code&gt;free&lt;/code&gt;（メモリ解放）関数は、C++ で動的な配列やオブジェクトを作成する際に不可欠です。また、文字列処理関数である &lt;code&gt;strcpy&lt;/code&gt;（文字列コピー）、&lt;code&gt;strcat&lt;/code&gt;（文字列連結）も、C++ に高度な &lt;code&gt;string&lt;/code&gt; クラスが存在しても、低レベルでの C コードとのインタフェースや、最大限のパフォーマンスを追求する場合に頻繁に使用されます。さらに、標準入出力関数 &lt;code&gt;printf&lt;/code&gt;、&lt;code&gt;scanf&lt;/code&gt; などは、C++ の初期開発や、性能に敏感で簡潔さを重視するシナリオにおいて頻繁に見られます。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;オペレーティングシステムとの協調&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;GLIBC は、オペレーティングシステムとアプリケーション間の重要な橋渡し役です。Linux システムでは、C++ プログラムがシステム呼び出し（例えば、ファイルを開く &lt;code&gt;open&lt;/code&gt; 関数を使用し、その裏側は GLIBC で実装されている）、オペレーティングシステムカーネルにリクエストを送信する際、GLIBC はプログラムの要求をカーネルが規定する方法でパッケージ化し、カーネルに渡します。カーネルが処理を完了すると、GLIBC が結果をアプリケーションに戻します。これにより、アプリケーションはオペレーティングシステムの低レベルの複雑なシステム呼び出しインターフェースの詳細を理解する必要がなく、ファイルシステム、ネットワーク、プロセス管理などのさまざまなシステムリソースを簡単に利用できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;iii-c-プログラム公開後の互換性問題の分析&#34;&gt;III. C++ プログラム公開後の互換性問題の分析
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;GLIBC バージョン差異が引き起こす互換性の困窮&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;異なる Linux ディストリビューションは、それぞれ異なるバージョンの GLIBC を搭載している場合がある。C++ プログラムが高バージョン GLIBC 環境下でコンパイルされた場合、意図せずそのバージョンに新しく追加された関数特性を利用したり、より最適化された関数実装に依存したりすることがある。例えば、新 GLIBC バージョンがメモリ割り当てアルゴリズムを改善した場合、プログラムは実行時にこの新しいアルゴリズムを活用して性能を向上させる。しかし、このようなプログラムを低バージョン GLIBC システムに移植すると、対応する関数が見つからなくなる（低バージョンではその関数が導入されていないため）か、関数の動作が異常になる（旧バージョンの関数実装と新版の間に論理的なずれがあるため）、といった問題が発生し、プログラムがクラッシュしたり、結果が誤ったりすることがある。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;コンパイラ差異がもたらす互換性のリスク&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同じ GCC コンパイラを使用しても、異なるバージョンの GCC はコード生成、標準ライブラリのサポート、C++ 特性への実装の詳細において違いがある。より新しい GCC バージョンは、C++ 最新規格（例えば C++20 の新モジュール、コルーチンなど）を完全にサポートしている場合があり、プログラムがこれらの先進的な特性を使用し、古いバージョンの GCC 下でコンパイルすると、コンパイラはこれらの新しい構文構造を認識できずエラーが発生する。エラーがない場合でも、異なる GCC バージョンの最適化戦略の違いにより、生成される機械コードの実行効率やメモリ使用量において大きな差が生じることがあり、性能が要求される環境下ではプログラムの動作が大きく異なってしまう可能性がある。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;システムアーキテクチャ差異がもたらす課題&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C++ プログラムは、異なるハードウェアシステムアーキテクチャ上で実行する必要がある場合がある（x86, ARM, PowerPC など）。異なるアーキテクチャはそれぞれ独自の命令セット、メモリレイアウト、データアライメント要件を持っている。データアライメントの例を挙げると、x86 アーキテクチャで正常に動作する構造体データのストレージレイアウトが、ARM アーキテクチャではアライメント規則の違いによりメモリアクセス例外を引き起こし、プログラムエラーにつながる可能性がある。さらに、GCC が異なるアーキテクチャ向けにコンパイルすると生成される機械コードの差は非常に大きく、プログラム中にハードコーディングされたアーキテクチャ固有の指示や仮定がある場合、異なるアーキテクチャで実行すると頻繁に故障が発生する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;四互換性問題への対処戦略&#34;&gt;四、互換性問題への対処戦略
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;静的リンクライブラリの活用&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GLIBCなどのプログラムが依存するライブラリコードを、実行ファイルに直接組み込む静的リンクライブラリの使用を検討してください。これにより、プログラムは実行時に特定のターゲットシステムのGLIBCバージョンに依存しなくなり、GLIBCバージョンの不一致によって引き起こされる問題を効果的に回避できます。ただし、静的リンクは実行ファイルのサイズを大幅に増加させるため、ストレージリソースが限られた環境では利点と欠点を比較検討する必要があります。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;コンテナ化デプロイメント&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dockerなどのコンテナ技術を利用して、C++プログラムとその必要な実行環境（特定のバージョンのGCC、GLIBCなど）を独立したコンテナ内にカプセル化します。どのようなベースOSにデプロイする場合でも、コンテナ内の環境は開発時の環境と一貫性を保ち、プログラムが期待どおりに動作することを保証し、クロス環境デプロイの複雑さを大幅に軽減します。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;互換性テストおよび継続的インテグレーション&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GLIBC、GCC、一般的なシステムアーキテクチャなど、さまざまなバージョンを網羅した包括的な互換性テスト体系を確立します。プログラム開発プロセス中に、継続的インテグレーションツールを使用して、定期的に複数の環境で自動化されたテストを実行し、互換性問題が検出された場合は迅速に修正します。これにより、潜在的な問題をその発生初期段階で排除し、プログラムのリリース後の安定性を保証します。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上記をまとめると、GCCおよびGLIBCの動作原理を深く理解し、C++プログラムの互換性問題の根本原因を正確に把握し、柔軟に対応戦略を活用することは、堅牢かつクロスプラットフォームなアプリケーションを作成するすべてのC++開発者の必須スキルです。そうすることで、私たちのC++作品は多様な技術生態系の中で無障害に航行できます。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Windowsに付属のディスククリーンアップツール：ストレージ</title>
        <link>https://ttf248.life/ja/p/windows-disk-cleanup-storage/</link>
        <pubDate>Mon, 06 Jan 2025 19:29:45 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/windows-disk-cleanup-storage/</guid>
        <description>&lt;p&gt;元のバージョンがいつからなのかは不明ですが、Windows 11 ではディスククリーンアップツールが大幅に改善され、よりスマートになっています。&lt;/p&gt;
&lt;p&gt;主な理由は、これが公式のツールであり、ファイルを誤って削除したり、広告が表示されたり、ポップアップが現れたり、バックグラウンドプロセスが実行されたり、不要なものが一切含まれていないことです。&lt;/p&gt;
&lt;p&gt;Windows 11 では、「設定」&amp;gt;「システム」&amp;gt;「ストレージ」&amp;gt;「一時ファイル」からディスククリーンアップツールを開くことができます。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;20250106194453.png&#34; &gt;ストレージインターフェースの画像&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通常ユーザーは「推奨のクリーニング」を選択するだけで、システムはあなたの使用状況に基づいていくつかの提案を行います。&lt;/p&gt;
&lt;p&gt;筆者である私のような開発者は、ディスク上に多くの一時ファイルがあるため、「一時ファイル」を選択し、Visual Studio や Windows Update などの一時ファイルを多く含んでいます。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;Snipaste_2024-12-19_13-39-51.png&#34; &gt;一時ファイルの画像&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Docker 国内イメージプロキシが失敗しました。</title>
        <link>https://ttf248.life/ja/p/docker-domestic-image-proxy-failure/</link>
        <pubDate>Sat, 04 Jan 2025 18:29:25 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/docker-domestic-image-proxy-failure/</guid>
        <description>&lt;p&gt;国内サーバーへのDockerデプロイで、会社がレジストリを提供していない場合、開発者が最初にやるべきことは、国内のレジストリミラーを設定することです。&lt;/p&gt;
&lt;p&gt;幸いにも今日、サーバー1台にミラー設定を行いましたが、イメージの取得中に常に取得できないという問題が発生しました。&lt;/p&gt;
&lt;p&gt;エラーメッセージ：&lt;code&gt;Error response from daemon: Get &amp;quot;https://registry-1.docker.io/v2/&amp;quot;: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2025年1月6日、隔日のうちにすべてのサーバーが復旧しました。この件は全く話題にならないとは信じられない。国内のすべてのレジストリミラーがダウンしていたのです&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;障害の切り分けと修復試行&#34;&gt;障害の切り分けと修復試行
&lt;/h2&gt;&lt;p&gt;当初、他のミラー加速アドレスに切り替えて問題を解決することを期待したが、予想とは裏腹に問題は依然として発生し続けた。&lt;/p&gt;
&lt;p&gt;次に、ローカルDNS設定を修正して、ネットワーク解析の側面から突破口を探ることを試みたが、結局、ある程度のデバッグを行った結果も、障害は解消されなかった。&lt;/p&gt;
&lt;p&gt;この時点で、ローカルネットワークの安定性が大きく疑われるようになり、そこで断念なく携帯電話のテザリングに切り替えて、潜在的なローカルネットワーク障害を回避することを試みた。しかし、結果は失望であり、問題の改善の兆候は見られなかった。&lt;/p&gt;
&lt;h2 id=&#34;問題の蔓延&#34;&gt;問題の蔓延
&lt;/h2&gt;&lt;p&gt;現在、国内に&lt;strong&gt;数台のサーバーがデプロイされており、すべてDocker環境がインストールされています&lt;/strong&gt;。これらのサーバーからイメージをプルすることを試みましたが、例外なく失敗し、返ってくるエラーメッセージも一様です。これは問題が特定のデバイスに限られたものではなく、広範囲に及んでいることを示唆しています。&lt;/p&gt;
&lt;p&gt;さらに調査した結果、イメージレポジトリのプロキシが瞬く間に停止していることが判明しました。この緊迫した状況下で、迅速に海外のサーバーを使用して試みましたが、幸いにもイメージのプルは正常に戻りました。これは問題が国内のネットワークリンクまたは関連設定にある可能性が高いことを意味します。&lt;/p&gt;
&lt;h2 id=&#34;戦略修正迂回戦術&#34;&gt;戦略修正：迂回戦術
&lt;/h2&gt;&lt;p&gt;国内での直接リポジトリ取得の経路が重く制限される中、海外のリポジトリは正常にアクセスできる状況を鑑み、プロジェクトを迅速に進めるため、迂回戦術を採用することにしました。まず、国外サーバーに切り替えて必要なイメージを取得し、その後、国内イメージレジストリにプッシュすることで、「データブリッジ」を構築します。
同時に、Dockerfileファイルに対しても修正を行い、イメージのURLを国内環境に適したアドレスに変更してから再ビルドを実行し、最終的に成功裏にデプロイしました。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>CentOS 8 Stream EOL</title>
        <link>https://ttf248.life/ja/p/centos-8-stream-eol/</link>
        <pubDate>Sat, 16 Nov 2024 23:24:50 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/centos-8-stream-eol/</guid>
        <description>&lt;p&gt;&lt;code&gt;CentOS Stream&lt;/code&gt;は、レッドハットのエンタープライズ向け&lt;code&gt;Linux&lt;/code&gt;ディストリビューションの前段のオープンソース開発プラットフォームです。&lt;/p&gt;
&lt;p&gt;初めてオープンオペレーティングシステムのライフサイクル&lt;a class=&#34;link&#34; href=&#34;https://ttf248.life/ja/p/redhat-centos-lifecycle/&#34; &gt;redhat and centos life cycle&lt;/a&gt;に注目したのが、この時期でした。&lt;/p&gt;
&lt;p&gt;期限が切れ、何か問題があるのでしょうか？セキュリティの問題以外にも、dnfが使えなくなってしまい、最近ツールをインストールする際に、dnfが失敗するという問題を調べたところ、&lt;code&gt;CentOS 8 Stream&lt;/code&gt;が期限切れだったことがわかりました。&lt;/p&gt;
&lt;h2 id=&#34;centos-stream-の紹介&#34;&gt;CentOS Stream の紹介
&lt;/h2&gt;&lt;h3 id=&#34;位置と役割&#34;&gt;位置と役割
&lt;/h3&gt;&lt;p&gt;CentOS Streamは、Fedora Linux（上流開発）とRHEL（Red Hat Enterprise Linux、下流開発）の中間に位置し、その橋渡し役を担っています。
最新のRed Hat系Linuxの機能を試すためのバージョンとして利用でき、ベータ版やプレビュー版としての活用に適しています。&lt;/p&gt;
&lt;h3 id=&#34;出身と背景&#34;&gt;出身と背景
&lt;/h3&gt;&lt;p&gt;時間の経過とともに、Red Hat社はエンタープライズ向けLinuxプラットフォームの発展方法についてより効果的な方法を模索し始め、CentOS Streamを発表しました。
‌CentOS 8が2021年末にメンテナンスを終了した後、CentOS Streamはその後継者として更新され続け、CentOSプロジェクトの将来的な開発方向となりました。&lt;/p&gt;
&lt;h3 id=&#34;特徴と利点&#34;&gt;特徴と利点
&lt;/h3&gt;&lt;p&gt;CentOS Streamは、継続的リリース（ローリングリリース）のLinuxディストリビューションであり、より迅速なアップデートを提供します。コミュニティ、パートナー、顧客への参加を促進し、透明性を高め、ユーザーがRed Hat Enterprise Linux (RHEL) に貢献するための機会を増やします。
CentOS Streamの内容は、Red Hatが次期安定版RHELに含める予定のソフトウェアであるため、コミュニティメンバーには安定したABI/APIを使用した開発およびテストのための基盤を提供します。&lt;/p&gt;
&lt;h3 id=&#34;利用シーンとターゲットユーザー&#34;&gt;利用シーンとターゲットユーザー
&lt;/h3&gt;&lt;p&gt;CentOS Streamは、最新のLinux機能アップデートを継続的に取得したいCentOSユーザーや、Red Hat Enterprise Linuxの開発に参加する開発者およびパートナーに適しています。&lt;/p&gt;
&lt;p&gt;また、コミュニティメンバー、Red Hat パートナー、その他の人々が、より安定かつ予測可能なLinuxエコシステムで革新的なオープンソースプログラムを最大限に活用できるよう支援することを目的としています。&lt;/p&gt;
&lt;h2 id=&#34;最終期限httpsendoflifedatecentos-stream&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://endoflife.date/centos-stream&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;最終期限&lt;/a&gt;
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;リリース&lt;/th&gt;
&lt;th&gt;公開日&lt;/th&gt;
&lt;th&gt;サポート期間&lt;/th&gt;
&lt;th&gt;セキュリティサポート&lt;/th&gt;
&lt;th&gt;最新&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;3年前 (2021年9月15日)&lt;/td&gt;
&lt;td&gt;2年6ヶ月後 (2027年5月31日)&lt;/td&gt;
&lt;td&gt;2年6ヶ月後 (2027年5月31日)&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;最終期限httpsendoflifedatecentos-stream-1&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://endoflife.date/centos-stream&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;最終期限&lt;/a&gt;
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;リリース&lt;/th&gt;
&lt;th&gt;公開日&lt;/th&gt;
&lt;th&gt;サポート期間&lt;/th&gt;
&lt;th&gt;セキュリティサポート&lt;/th&gt;
&lt;th&gt;最新&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;5年前 (2019年9月24日)&lt;/td&gt;
&lt;td&gt;終了済み (2024年5月31日)&lt;/td&gt;
&lt;td&gt;終了済み (2024年5月31日)&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ソリューション&#34;&gt;ソリューション
&lt;/h2&gt;&lt;p&gt;アップグレードの手間を省き、長期サポート版の &lt;code&gt;Ubuntu 24.04&lt;/code&gt; を採用しました。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Hugo モジュールカスタムテーマの修正：考え方の解説</title>
        <link>https://ttf248.life/ja/p/hugo-module-customizing-themes-ideas/</link>
        <pubDate>Fri, 15 Nov 2024 22:01:17 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/hugo-module-customizing-themes-ideas/</guid>
        <description>&lt;p&gt;過去のコミット履歴を調べてみたところ、サイトが何度もテーマを変更しており、毎回いくつかのカスタム設定を適用していた。そこで、カスタム設定の変更方法を記録しておく。私のGitHubには「even」というテーマがあり、短期間メンテナンスを行っていたが、最新版のHugoコンパイラへのアップグレードを強行した結果、互換性が失われ、最終的に「stack」テーマに切り替えてしまった。&lt;/p&gt;
&lt;h2 id=&#34;hugoのモジュール化&#34;&gt;Hugoのモジュール化
&lt;/h2&gt;&lt;p&gt;モジュール化について言及する際、NginxモジュールやIDEAプラグインなどを思い浮かべる人が多いでしょう。 通常は、私がいくつかのモジュールをアップロードすることで、私の独自のニーズを満たすことができます。 モジュールが広く受け入れられる理由は、十分に柔軟で、あまり労力をかけずに自分のニーズを満たせることです。 多くの場合は、大体同じように見えるものの、細部には常に違いがあるからです。 これはソフトウェアの複雑さを物語っており、技術的な複雑さだけでなく、ビジネス上の複雑さも含まれます。 大多数の場合、私たちが直面しているのはビジネスの複雑さです。 これこそが、「隔行如隔山」という俗語を最もよく表すものです。&lt;/p&gt;
&lt;p&gt;現在では、インターネット業界だけでなく、金融業界、さらには伝統的な製造業まで、情報化システムを使用して企業の生産と管理を支援しています。 同じ「休暇申請システム」でも、同じ業界の異なる企業間には違いがあります。&lt;/p&gt;
&lt;p&gt;そして&lt;code&gt;Hugo&lt;/code&gt;のモジュールは、皆さんがイメージするモジュールとは少し異なります。 機能単位で独自のニーズを満たすのではなく、ディレクトリ構造を主に使用して、共通の構造を認識します。&lt;/p&gt;
&lt;p&gt;資料リンク：&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@sunwei.xyz/07-hugo%E6%9E%B6%E6%9E%84-hugo%E7%9A%84%E6%A8%A1%E5%9D%97-8ef5a520a822&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;07. Hugoアーキテクチャ — Hugoのモジュール&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[[imports]]
path = &amp;quot;github.com/CaiJimmy/hugo-theme-stack/v3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;git submodule&lt;/code&gt; 方式も引き続き使用できますが、本記事では推奨されません。 テーマを導入した場合、更新が発生するとメンテナンスが煩雑になり、個別の git リポジトリでテーマを管理する必要があるためです。&lt;/p&gt;
&lt;h2 id=&#34;テーマの修正ロジック-httpsstackjimmycaicomguidemodify-themehttpsstackjimmycaicomguidemodify-theme&#34;&gt;テーマの修正ロジック (&lt;a class=&#34;link&#34; href=&#34;https://stack.jimmycai.com/guide/modify-theme&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stack.jimmycai.com/guide/modify-theme&lt;/a&gt;)
&lt;/h2&gt;&lt;p&gt;前面モジュール化の基礎概念を理解した上で、カスタムテーマを理解すると、それほど難しくありません。&lt;code&gt;hugo&lt;/code&gt; の現在のテーマも、複数の異なるモジュールを組み合わせて構成されています。あるモジュールを変更したい場合は、対応するテンプレートファイルを検索し、修正すればOKです。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;stack&lt;/code&gt; 公式ドキュメントからの抜粋：&lt;/p&gt;
&lt;p&gt;この方法を使用すると、&lt;code&gt;themes&lt;/code&gt; ディレクトリの下にファイルは存在しません。テーマを修正するには、変更したいファイルを同じディレクトリにある &lt;code&gt;layouts&lt;/code&gt; ディレクトリにコピーする必要があります。&lt;/p&gt;
&lt;p&gt;例えば、&lt;code&gt;themes/hugo-theme-stack/layouts/partials/head/custom.html&lt;/code&gt; ファイルを変更する場合は、それを &lt;code&gt;layouts/partials/head/custom.html&lt;/code&gt; にコピーし、そこから修正します（テーマのリポジトリからコードをコピー）。&lt;code&gt;assets&lt;/code&gt; と &lt;code&gt;static&lt;/code&gt; ディレクトリについても同様です。&lt;/p&gt;
&lt;h2 id=&#34;テンプレートファイルの場所を見つける方法&#34;&gt;テンプレートファイルの場所を見つける方法
&lt;/h2&gt;&lt;h3 id=&#34;従来の思路&#34;&gt;従来の思路
&lt;/h3&gt;&lt;p&gt;テーマのソースファイルを確認し、テーマのデザイン思想を理解し、対応するテンプレートファイルを修正します。&lt;/p&gt;
&lt;h3 id=&#34;蛮力的なアプローチ&#34;&gt;蛮力的なアプローチ
&lt;/h3&gt;&lt;p&gt;私はフロントエンドのコードがあまり理解していないため、時には手動で対応することがあります。例えば、関連するページをブラウザで開き、修正したい箇所を見つけ、&lt;code&gt;要素を検査&lt;/code&gt;を使ってCSS名（&lt;code&gt;css name&lt;/code&gt;）を特定し、ソースコード内で検索して該当ファイルを抽出し、それをサイトディレクトリにコピーして変更します。&lt;/p&gt;
&lt;h2 id=&#34;スニppets&#34;&gt;スニppets
&lt;/h2&gt;&lt;p&gt;公式サイトでデフォルトのファイルが用意されており、カスタマイズが必要な箇所は、複数のファイルに分割して &lt;code&gt;custom.scss&lt;/code&gt; ファイルをインポートすることで、よりスタイルの管理を効率化できます。
&lt;img src=&#34;https://ttf248.life/p/hugo-module-customizing-themes-ideas/image.png&#34;
	width=&#34;141&#34;
	height=&#34;375&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;37&#34;
		data-flex-basis=&#34;90px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;修正内容まとめ6時間&#34;&gt;修正内容まとめ（6時間）
&lt;/h2&gt;&lt;p&gt;現在は &lt;code&gt;AI&lt;/code&gt; エンコードの元年であり、詳細な内容はここでは省略し、主な変更点を以下に列挙します。本サイトで行った修正内容としては、コピーボタンのスタイルの調整、コードブロックのスタイルの再設定などがあり、&lt;code&gt;ChatGPT&lt;/code&gt; などは容易に対応できました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全体：グローバル文字スタイルを、以前の &lt;code&gt;even&lt;/code&gt; と &lt;code&gt;info cn&lt;/code&gt; を融合した表示スタイルを引き継ぎ、中国語に最適化&lt;/li&gt;
&lt;li&gt;首页：右側のナビゲーションにマウスインタラクションアニメーションを追加&lt;/li&gt;
&lt;li&gt;首页：記事に概要プレビュー（手間のかかる方法で実現）を追加&lt;/li&gt;
&lt;li&gt;スクロールバー：スクロールバーのスタイルを美化&lt;/li&gt;
&lt;li&gt;コードブロック：&lt;code&gt;highlight.js&lt;/code&gt; を導入し、コードブロックのスタイルを美化&lt;/li&gt;
&lt;li&gt;文章詳細：一部コンテンツが転載であるため、原作者情報と元のリンクを表示&lt;/li&gt;
&lt;li&gt;アーカイブページ：トップのカテゴリ画像にテーマ自带の色付きマスクを削除し、元の画像を表示&lt;/li&gt;
&lt;li&gt;アーカイブページ：年単位でのカテゴリ分類の統計表示パネルを追加&lt;/li&gt;
&lt;li&gt;アーカイブページ：2列表示レイアウト
&lt;code&gt;stack&lt;/code&gt; テーマのコンポーネント再利用率が高いため、首页の記事への概要プレビュー追加に時間がかかりました。対応するコンポーネントを変更したことで、記事の詳細ページの変更も引き起こされ、正文が重複して表示される問題が発生しました。&lt;code&gt;golang テンプレート&lt;/code&gt; の構文はあまり馴染みがないため、多くの時間を費やし、コンポーネント間のパラメータ伝達を解決することができませんでした。最終的には、巧みに手段として、ホームページに独自に &lt;code&gt;JavaScript&lt;/code&gt; スクリプトを導入し、カスタムの特殊変数を通じて概要プレビューを実現しました。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;コード再利用率が高すぎる場合も問題であり、変更を加えることで他の場所にも影響が及ぶ可能性があるため、テーマを変更する際には注意が必要です。元のロジックを壊さないようにしてください。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;コメント欄&#34;&gt;コメント欄
&lt;/h3&gt;&lt;p&gt;このイケメンさんの修正はより洗練されています：&lt;a class=&#34;link&#34; href=&#34;https://blog.reincarnatey.net/2024/0719-better-waline/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.reincarnatey.net/2024/0719-better-waline/&lt;/a&gt;
&lt;del&gt;本サイトではシンプルな形で &lt;code&gt;Waline&lt;/code&gt; 评论システムを導入しており、&lt;code&gt;stack&lt;/code&gt; テーマがデフォルトで &lt;code&gt;Waline&lt;/code&gt; をサポートしているため、&lt;code&gt;config.toml&lt;/code&gt; に設定するだけです。&lt;/del&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ホームページへのメール連絡の推奨、本サイトではコメント欄は開放していません&lt;/p&gt;
&lt;/blockquote&gt;</description>
        </item>
        <item>
        <title>Linuxバックエンドサービスの大量文字列データの処理 - 効率が悪い</title>
        <link>https://ttf248.life/ja/p/linux-backend-slow-string-processing/</link>
        <pubDate>Wed, 13 Nov 2024 19:42:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-backend-slow-string-processing/</guid>
        <description>&lt;p&gt;C++開発の歴史的なプロジェクトにおいて、カスタムプロトコルを使用して通信を行っており、そのプロトコルは2次元配列のパターンを採用していました。大量データを処理する際に、プロトコル内部では配列を遍历し、シリアライズ操作を実行してログを生成しており、このため効率が低く、システムが高負荷時に顕著なフレーム落ち（カドゥ）を引き起こしました。事業部門からは、システムのフレーム落ちに関するフィードバックがありました。&lt;/p&gt;
&lt;h2 id=&#34;問題の特定&#34;&gt;問題の特定
&lt;/h2&gt;&lt;p&gt;問題のトラブルシューティングにおいて、まずシステムに対してパフォーマンス分析を実施し、大量データを処理する際にCPU使用率が著しく増加し、システムの応答時間が長くなっていることを発見しました。ログを分析した結果、多数のシリアライズ操作が見られ、これらの操作は2次元配列を処理する際の効率が低いことが原因でシステム性能が低下していました。
&lt;code&gt;pstack&lt;/code&gt;ツールを使用してサービスのスレッド情報を取得し、ログスレッドが文字列の連結に大部分の時間を使用していることを特定しました。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;今日は重点的に取り組むべき点です。異なる累積方式では、その効率の違いは非常に大きいです。過去のコードでは &amp;lsquo;+&amp;rsquo; 演算子を使用しており、この方法は頻繁に一時オブジェクトを作成するため、非常に非効率的でした。それは、その非効率さがどの程度であるかを知らない状況にあるようなものです。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;デモ検証&#34;&gt;デモ検証
&lt;/h2&gt;&lt;p&gt;プロジェクトコードに基づいて、ビジネスロジックを抽出し、文字列連結の効率に関する問題を検証するためのシンプルなデモを作成しました。Windows環境ではVisual Studio 2022コンパイラ、Linux環境ではgcc8.5コンパイラを使用し、Releaseモードでビルドして実行することで、効率を比較します。&lt;/p&gt;
&lt;h3 id=&#34;キーポイントの説明&#34;&gt;キーポイントの説明
&lt;/h3&gt;&lt;p&gt;本プロジェクトで使用されたのは方法四であり、テストデータを入手する前に、どの方法が最も効率が良いか、最も効率が悪いかを読者が最初に考えてみるべきです。結果を見たときは、自分自身にとても驚きました。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;方法 1 (&lt;code&gt;+=&lt;/code&gt; による連結)&lt;/strong&gt;：各フィールドを &lt;code&gt;+=&lt;/code&gt; を使って文字列に直接連結します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法 2 (&lt;code&gt;std::ostringstream&lt;/code&gt; による連結)&lt;/strong&gt;：ストリーム（&lt;code&gt;std::ostringstream&lt;/code&gt;）を使用して各フィールドを連結する方法で、特に大量のデータを連結する場合に効率的です。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法 3 (事前にメモリを割り当てる &lt;code&gt;+=&lt;/code&gt; による連結)&lt;/strong&gt;：&lt;code&gt;reserve&lt;/code&gt; を使用して文字列に必要な十分なメモリを事前に割り当て、メモリ再割り当てのオーバーヘッドを削減することでパフォーマンスを向上させます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法 4 (&lt;code&gt;bodys = bodys + body + &amp;quot;\n&amp;quot;&lt;/code&gt;)&lt;/strong&gt;: 各連結で新しい一時的な文字列オブジェクトを作成するため、パフォーマンスが低下します。特に大規模な連結の場合、各連結において新しいメモリ割り当てとコピーが発生するためです。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参照結果から、プロジェクトはちょうど最も効率の悪い方法を選択していました。&lt;/p&gt;
&lt;p&gt;さらに詳しく分析すると、異なるプラットフォームコンパイラによる最適化効率を分析できます。Microsoft の &lt;code&gt;visual studio&lt;/code&gt; は従来通り優れており、文字列の最適化効率は非常に高いですが、&lt;code&gt;gcc&lt;/code&gt; コンパイラの最適化効率は少し劣ります。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;異なるマシンでコードを実行した場合、2つのデータセット間で直接比較する意味はありません。異なる連結方法間の差を比較できます。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;主要ポイント&#34;&gt;主要ポイント
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Windowsプラットフォーム下でのVisual Studio 2022コンパイラ

----------------------------------------
データ生成時間: 0.054秒。
----------------------------------------

----------------------------------------
データマージパフォーマンス:
----------------------------------------
+ データマージ (+=) にかかった時間: 0.053秒。
+ ostringstream データマージにかかった時間: 0.054秒。
+ 事前予約済みデータマージにかかった時間: 0.045秒。
+ データマージ (bodys = bodys + body + &amp;quot;\n&amp;quot;) にかかった時間: 16.108秒。

----------------------------------------
データマージ完了。
----------------------------------------

プログラム終了。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Linuxプラットフォーム下でのgcc8.5コンパイラ
----------------------------------------
データ生成時間: 0.108秒。
----------------------------------------

----------------------------------------
データマージパフォーマンス:
----------------------------------------
+ データマージ (+=) にかかった時間: 0.100秒。
+ ostringstream データマージにかかった時間: 0.083秒。
+ 事前予約済みデータマージにかかった時間: 0.057秒。
+ データマージ (bodys = bodys + body + &amp;quot;\n&amp;quot;) にかかった時間: 29.298秒。

----------------------------------------
データマージ完了。
----------------------------------------

プログラム終了。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完整コード&#34;&gt;完整コード
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;random&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;iomanip&amp;gt;

typedef std::vector&amp;lt;std::string&amp;gt; DataRow;
typedef std::vector&amp;lt;DataRow&amp;gt; DataGroup;

struct ResponsePackage
{
    std::string ErrorInfo;
    DataRow Head;
    std::string ClientId;
    std::string UUID;
    std::string MsgID;
    std::string SessionID;
    std::string ExtraInfo1;
    std::string ExtraInfo2;
    DataGroup DataBody;
};

// Generate specified length of random string
std::string generateRandomString(size_t length)
{
    const char charset[] = &amp;quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&amp;quot;;
    const size_t max_index = sizeof(charset) - 1;
    std::string random_string;
    random_string.reserve(length);

    std::random_device rd;
    std::mt19937 generator(rd());
    std::uniform_int_distribution&amp;lt;&amp;gt; distribution(0, max_index);

    for (size_t i = 0; i &amp;lt; length; ++i)
    {
        random_string += charset[distribution(generator)];
    }

    return random_string;
}

void create_large_string()
{
    // Example request package with 50 fields
    ResponsePackage requestPackage;

    requestPackage.Head = {
        &amp;quot;Field1&amp;quot;, &amp;quot;Field2&amp;quot;, &amp;quot;Field3&amp;quot;, &amp;quot;Field4&amp;quot;, &amp;quot;Field5&amp;quot;,
        &amp;quot;Field6&amp;quot;, &amp;quot;Field7&amp;quot;, &amp;quot;Field8&amp;quot;, &amp;quot;Field9&amp;quot;, &amp;quot;Field10&amp;quot;,
        &amp;quot;Field11&amp;quot;, &amp;quot;Field12&amp;quot;, &amp;quot;Field13&amp;quot;, &amp;quot;Field14&amp;quot;, &amp;quot;Field15&amp;quot;,
        &amp;quot;Field16&amp;quot;, &amp;quot;Field17&amp;quot;, &amp;quot;Field18&amp;quot;, &amp;quot;Field19&amp;quot;, &amp;quot;Field20&amp;quot;,
        &amp;quot;Field21&amp;quot;, &amp;quot;Field22&amp;quot;, &amp;quot;Field23&amp;quot;, &amp;quot;Field24&amp;quot;, &amp;quot;Field25&amp;quot;,
        &amp;quot;Field26&amp;quot;, &amp;quot;Field27&amp;quot;, &amp;quot;Field28&amp;quot;, &amp;quot;Field29&amp;quot;, &amp;quot;Field30&amp;quot;,
        &amp;quot;Field31&amp;quot;, &amp;quot;Field32&amp;quot;, &amp;quot;Field33&amp;quot;, &amp;quot;Field34&amp;quot;, &amp;quot;Field35&amp;quot;,
        &amp;quot;Field36&amp;quot;, &amp;quot;Field37&amp;quot;, &amp;quot;Field38&amp;quot;, &amp;quot;Field39&amp;quot;, &amp;quot;Field40&amp;quot;,
        &amp;quot;Field41&amp;quot;, &amp;quot;Field42&amp;quot;, &amp;quot;Field43&amp;quot;, &amp;quot;Field44&amp;quot;, &amp;quot;Field45&amp;quot;,
        &amp;quot;Field46&amp;quot;, &amp;quot;Field47&amp;quot;, &amp;quot;Field48&amp;quot;, &amp;quot;Field49&amp;quot;, &amp;quot;Field50&amp;quot;
    };

    requestPackage.ClientId = &amp;quot;ClientID&amp;quot;;
    requestPackage.UUID = &amp;quot;UUID&amp;quot;;
    requestPackage.MsgID = &amp;quot;MsgID&amp;quot;;
    requestPackage.SessionID = &amp;quot;SessionID&amp;quot;;
    requestPackage.ExtraInfo1 = &amp;quot;ExtraInfo1&amp;quot;;
    requestPackage.ExtraInfo2 = &amp;quot;ExtraInfo2&amp;quot;;

    // Start timing for data generation
    auto start_gen = std::chrono::high_resolution_clock::now();

    // Generate 10,000 rows of data, each with 50 fields
    for (size_t i = 0; i &amp;lt; 10000; ++i)
    {
        DataRow dataRow(50, &amp;quot;This is a test string&amp;quot;);
        requestPackage.DataBody.push_back(dataRow);
    }

    // End timing for data generation
    auto end_gen = std::chrono::high_resolution_clock::now();
    std::chrono::duration&amp;lt;double&amp;gt; duration_gen = end_gen - start_gen;

    // Display result generation time
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Generation Time: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_gen.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    // Data merging using different methods
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Performance:\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    {
        // Method 1: Using &#39;+=&#39; string concatenation
        auto start_merge = std::chrono

## 完全なコード
```json
{
        // Method 2: Using ostringstream
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::ostringstream bodys;
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::ostringstream body;
            body &amp;lt;&amp;lt; &amp;quot;This is a test string&amp;quot;;
            for (auto&amp;amp; item : vec)
            {
                body &amp;lt;&amp;lt; item &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            }
            bodys &amp;lt;&amp;lt; body.str() &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ ostringstream Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 3: Pre-allocated memory
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys;
        bodys.reserve(1000 * 50 * 20); // Pre-allocate enough memory
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            body.reserve(50 * 20); // Pre-allocate memory for each row
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Pre-reserved Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 4: Using &#39;bodys = bodys + body + &amp;quot;\n&amp;quot;&#39;
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body = body + item + &amp;quot; &amp;quot;; // Note the use of &#39;body = body + item&#39;
            }
            bodys = bodys + body + &amp;quot;\n&amp;quot;; // Again, using &#39;bodys = bodys + body&#39;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (bodys = bodys + body + \&amp;quot;\\n\&amp;quot;) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Complete.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;
}

int main()
{
    try
    {
        create_large_string();
    }
    catch (const std::exception&amp;amp; e)
    {
        std::cerr &amp;lt;&amp;lt; &amp;quot;Caught exception: &amp;quot; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\nProgram finished.\n&amp;quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>C&#43;&#43;におけるラムダ式のパラメータのライフタイムについて</title>
        <link>https://ttf248.life/ja/p/cpp-lambda-parameter-lifetime/</link>
        <pubDate>Wed, 13 Nov 2024 19:23:02 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cpp-lambda-parameter-lifetime/</guid>
        <description>&lt;p&gt;C++において、ラムダ式は便利な匿名関数であり、外部変数をキャプチャして内部で使用することができます。これにより、ラムダ式は柔軟なプログラミングツールとなります。しかし、ラムダ式のパラメータのライフサイクルは特に注意すべき点であり、特にキャプチャおよびパラメータを渡す際に重要です。&lt;/p&gt;
&lt;h3 id=&#34;1-ラムダ式のパラメータのライフサイクル&#34;&gt;1. ラムダ式のパラメータのライフサイクル
&lt;/h3&gt;&lt;p&gt;ラムダ式のパラメータのライフサイクルは、通常他のC++関数と同様です。関数の引数は関数呼び出し時に存在し、関数呼び出しが終了すると引数のライフサイクルも終了します。ただし、ラムダ式が外部変数をキャプチャする場合、そのキャプチャ方法によって引数のライフサイクルに影響を受ける可能性があります。&lt;/p&gt;
&lt;h3 id=&#34;2-パラメータのライフサイクルとの関係を捉える&#34;&gt;2. パラメータのライフサイクルとの関係を捉える
&lt;/h3&gt;&lt;h4 id=&#34;21-外部変数のキャプチャ&#34;&gt;2.1 外部変数のキャプチャ
&lt;/h4&gt;&lt;p&gt;C++のラムダ式では、以下の2つの方法で外部変数 キャプチャできます:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;値によるキャプチャ:&lt;/strong&gt; 値によるキャプチャでは、外部変数の値がラムダ内部にコピーされ、ラムダ内のコピーのライフサイクルはラムダのライフサイクルによって制御されます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参照によるキャプチャ:&lt;/strong&gt; 参照によるキャプチャでは、外部変数の参照が保持され、ラムダ内の参照は元の外部変数に指し示します。ライフサイクルは外部変数のライフサイクルに依存します。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda_by_value = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };  // xのコピーをキャプチャ
auto lambda_by_reference = [&amp;amp;x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };  // xの参照をキャプチャ

lambda_by_value();  // 10 を出力
lambda_by_reference();  // 10 を出力
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;キャプチャされた変数 のライフサイクルは以下のとおりです:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;値によるキャプチャ:&lt;/strong&gt; キャプチャ時に外部変数の値がラムダにコピーされ、ラムダのライフサイクルが終了すると、コピーされたコピーが破棄されます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参照によるキャプチャ:&lt;/strong&gt; ラムダが外部変数の参照を保持し、&lt;strong&gt;外部変数はラムダの使用前に有効でなければなりません。そうでない場合、未定義動作が発生します。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;22-ラムダパラメータ&#34;&gt;2.2 ラムダパラメータ
&lt;/h4&gt;&lt;p&gt;ラムダパラメータは、通常の関数パラメータと同様に、そのライフサイクルはラムダ関数内のみに限られます。つまり、ラムダパラメータはラムダが呼び出されたときに作成され、ラムダが呼び出された後にそのライフサイクルも終了します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto lambda = [](int a, int b) {
    std::cout &amp;lt;&amp;lt; a + b &amp;lt;&amp;lt; std::endl;
};
lambda(5, 10); // ここでaとbはラムダのパラメータ
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この例では、&lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; はラムダ式のパラメータであり、ラムダが呼び出されたときに作成され、ラムダの実行後に破棄されます。&lt;/p&gt;
&lt;h3 id=&#34;3-外部変数を捕捉する際のライフサイクルに関する問題&#34;&gt;3. 外部変数を捕捉する際のライフサイクルに関する問題
&lt;/h3&gt;&lt;h4 id=&#34;31-キャプチャされた変数が出-lambda-の外で有効か&#34;&gt;3.1 キャプチャされた変数が出 lambda の外で有効か
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;値によるキャプチャ&lt;/strong&gt;：外部変数が lambda が呼び出された後に破棄されても、lambda 内には外部変数のコピーが保持されます。したがって、lambda 内のコピーは安全に使用でき、外部変数が存在しなくなっても問題ありません。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x は lambda が呼び出された後に変更されます
lambda();  // 10 を出力します（x のコピーを使用）
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;参照によるキャプチャ&lt;/strong&gt;：外部変数を参照でキャプチャする場合、lambda 内での外部変数へのアクセスは外部変数のライフサイクルに依存します。外部変数が lambda が実行される前に破棄された場合、ダングリング参照が発生し、未定義の動作を引き起こります。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [&amp;amp;x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x は lambda が実行される前に変更されます
lambda();  // 20 を出力します（x の参照を使用）
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;lambda の実行順序が不定の場合、キャプチャされた外部変数が lambda の実行時に有効であることを保証することが重要です。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>Win11 Logitech G431 ヘッドホン ドライバー インストール</title>
        <link>https://ttf248.life/ja/p/win11-logitech-g431-headphone-driver-installation/</link>
        <pubDate>Wed, 05 Jun 2024 07:20:17 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/win11-logitech-g431-headphone-driver-installation/</guid>
        <description>&lt;p&gt;前回の続きですが、戻ってみたらGhubにアップデートがあったので少し嬉しい。カスタマーサポートが言っていた、ドライバが正常にロードできない問題が解決したと言っていたのですが、色々試してみたものの、再インストールしても正常には動かない。&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景
&lt;/h2&gt;&lt;p&gt;引き続きカスタマーサポートに問い合わせて解決策を相談したが、エンジニアによるリモート支援が可能であると伝えられたが、エンジニアの勤務時間と自身の勤務時間が完全に一致しないため、結局諦めざるを得なかった。最後にトラブルシューティングで残された資料を確認し、手動でのドライバーインストールを試みることにした。&lt;/p&gt;
&lt;h2 id=&#34;驱动安装包の入手方法&#34;&gt;驱动安装包の入手方法
&lt;/h2&gt;&lt;p&gt;ロジック社の公式には、個別のデバイスのドライバインストールパッケージが提供されていません。どのようにしてドライバファイルを入手すれば良いでしょうか？
最後にシステムを再構築した際のシステムイメージパッケージと組み合わせて、ローカル仮想マシンでシステムをクリーンに再構築し、そこでGhubを単独で展開します。これにより、ヘッドセットデバイスを仮想マシンに導入し、ドライバのパスを見つけてコピーアウトすることができます。
関連するパス：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C:\ProgramData\LGHUB&lt;/li&gt;
&lt;li&gt;C:\Windows\System32\DriverStore\FileRepository\logi_audio.inf_amd64_010b035044e24be4&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;デバイスマネージャー&#34;&gt;デバイスマネージャー
&lt;/h2&gt;&lt;p&gt;重点は２番目のパスの探し方で、まずはWindows 11 システムがどのように手動でドライバーファイルを管理できるかを整理します。この内容は、&lt;strong&gt;交差法（コントロール変数法）を用いて識別し、デバイスを抜き差しすることで仮想マシン内でデバイスマネージャーの情報からデバイス情報を特定し、合計３つのドライバーを処理する必要があることを認識しました&lt;/strong&gt;。そのうち２つのドライバーはシステムに組み込まれており、１つはロジック社が提供しています。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;20240605073331.png&#34; &gt;ドライバーマネージャー&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;上記の図の２番目のドライバーは、ロジック社が提供しており、デバイスの現在のドライバープログラムを分析し、仮想マシン内のすべてのドライバーパスを検索します。もちろん、最初に「logi」で始まるファイルを見つける必要があります。その後、ファイルの比較を行うことでドライバーのファイル件を特定し、そのフォルダ全体をコピーすることでドライバーインストールパッケージを入手できます。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;20240605073933.png&#34; &gt;ドライバーインストールパッケージ&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;驅動のインストール&#34;&gt;驅動のインストール
&lt;/h2&gt;&lt;p&gt;デバイスマネージャーのインターフェースで、以下の手順を実行します：&lt;/p&gt;
&lt;p&gt;「ドライバーの更新」をクリックし、「コンピューター上のドライブを検索」をクリックすると、以下の画面が表示されます：&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/win11-logitech-g431-headphone-driver-installation/20240605074130.png&#34;
	width=&#34;528&#34;
	height=&#34;381&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;ドライバーインストール&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;138&#34;
		data-flex-basis=&#34;332px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;通常起動すると、USBドライバーのみが表示されます。  「ディスクからインストール」を選択し、事前にコピーしてきたフォルダのパスを指定します。 インストール後、「ドロップダウンリスト」からロジック特有のドライバーが追加され、デバイスドライバーを新しくインストールしたドライバーに変更します。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/win11-logitech-g431-headphone-driver-installation/20240605074208.png&#34;
	width=&#34;593&#34;
	height=&#34;423&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;ディスクインストール&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;140&#34;
		data-flex-basis=&#34;336px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;人体工学デバイス駆動&#34;&gt;人体工学デバイス駆動
&lt;/h2&gt;&lt;p&gt;このドライブファイルはすべてシステムが提供するものですが、デバイスのドライバの前に感嘆符 (!) があるかどうかを確認してください。もし感嘆符があれば、ドライバ選択インターフェースに移動し、ランダムな他の種類のドライバを選択してから、再度元のドライバに戻すことで正常に復元できます。&lt;/p&gt;
&lt;h2 id=&#34;修了&#34;&gt;修了
&lt;/h2&gt;&lt;p&gt;ヘッドホンマイクの音量が正常に回復し、馴染みのあるエコーキャンセル機能も復帰しました。
&lt;a class=&#34;link&#34; href=&#34;20240605074823.png&#34; &gt;サイドノイズ画像&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>ロジック(レイザー) ヘッドホン ドライバーのインストールに失敗しました。 (Rōjiku (Reizā) heddohon dᱨīvā no insutora ni himitsu shimaimashita.)

**Note:** I&#39;ve provided the romanized version for pronunciation.  A more natural Japanese phrasing would be:

ロジック(レイザー) ヘッドホンドライバーのインストールが失敗しました。 (Rōjiku (Reizā) heddohon dᱨīvā no insutora ga himitsu shimaimashita.)</title>
        <link>https://ttf248.life/ja/p/logitech-headphone-driver-installation-failure/</link>
        <pubDate>Fri, 31 May 2024 21:46:12 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/logitech-headphone-driver-installation-failure/</guid>
        <description>&lt;p&gt;これらのことを全く理解していない場合は、すぐに公式のカスタマーサポートに連絡すれば、何時間も悩むことがなくなるだろう。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/logitech-headphone-driver-installation-failure/20240531220709.png&#34;
	width=&#34;693&#34;
	height=&#34;489&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;GHUB&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;141&#34;
		data-flex-basis=&#34;340px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;最近、自宅で開発に使っていたデスクトップPCのCドライブがストレージ容量不足になってしまったため、特意に256GBの半退役SSDをCドライブとして使用するようにした。ところが、その後、色々と勝手なことをしてしまっている。上海に引っ越してからずっと様々な業務に追われており、つい先週ようやくシステムを再インストールした。&lt;/p&gt;
&lt;p&gt;システムを再インストールする過程はスムーズで、日常的なソフトウェアのインストールや開発環境のデプロイにも問題はなかった。数日後、私はリラックスして、数ゲームプレイすることを思い立ったが、その時になってマウスとヘッドホンのドライバーがまだインストールされていないことに気づいた。これらのデバイスはどちらもロジクスの製品であるため、GHUBソフトウェアをダウンロードし、このソフトウェアはハードウェアを自動的に認識し、ドライバーをインストールすることができる。&lt;/p&gt;
&lt;p&gt;しかし、予期せぬ事態が発生した。マウスのドライバーは正常にインストールされたが、ヘッドホンのドライバーは常に「読み込み中」と表示され続けた。最新版のWindows 11システムとロジクスのドライバーの互換性の問題でインストールが失敗しているのではないかと疑ったため、私は情報を検索し、手動でドライバーをインストールすることを試みたが、問題は解決しなかった。&lt;/p&gt;
&lt;p&gt;簡単に説明すると、これらのデバイスのドライバーはそれぞれどのような役割を果たしているのかを示す。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;マウスのドライバーは主にマウスの移動速度などの機能を調整するために使用される。マクロ機能はほとんど使用しないため、以前覚えていたパラメータに戻すだけでよい。&lt;/li&gt;
&lt;li&gt;ヘッドホンのドライバーは主にヘッドホンリバーブ機能に使用され、これはチームでの音声通話時に非常に役立ち、自分の発言を聞くことができる。システムのミキサー設定にも同様のモニタリング機能があるが、ドライバーで実現するよりも効果がない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;私は何度も試みたが、ヘッドホンのドライバーは常に正常に読み込まれなかった。今日、ついにカスタマーサポートに問い合わせることを思いつき、状況を確認し、解決策を見つけることができるかどうかを尋ねた。カスタマーサポートは、最近彼らのサーバーで問題が発生しており、ドライバーのダウンロードが異常になっていると教えてくれた。彼らはこの問題を処理しており、私に急がないように指示し、次のアップデート後に問題が解決すると言った。&lt;/p&gt;
&lt;p&gt;まだヘッドホンのドライバーの問題が解決していないが、少なくとも原因を突き止めることができた。問題が早急に解決することを願っている。&lt;/p&gt;
&lt;h2 id=&#34;マウスドライバ設定&#34;&gt;マウスドライバ設定
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/logitech-headphone-driver-installation-failure/20240531220930.png&#34;
	width=&#34;1024&#34;
	height=&#34;768&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;G502&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;133&#34;
		data-flex-basis=&#34;320px&#34;
	
&gt;
&lt;img src=&#34;https://ttf248.life/p/logitech-headphone-driver-installation-failure/20240531220903.png&#34;
	width=&#34;1024&#34;
	height=&#34;768&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;G502&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;133&#34;
		data-flex-basis=&#34;320px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Python辞書におけるカスタムオブジェクトの保存：参照と深いコピーの重要性</title>
        <link>https://ttf248.life/ja/p/python-dictionary-custom-objects-reference-vs-deepcopy/</link>
        <pubDate>Fri, 22 Mar 2024 01:08:05 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/python-dictionary-custom-objects-reference-vs-deepcopy/</guid>
        <description>&lt;p&gt;Python プログラミングにおいて、辞書は非常に強力なデータ構造であり、キーと値のペアを関連付け、効率的にデータを検索および操作することを可能にします。カスタムオブジェクトを辞書に格納しようとすると、通常、重要な概念である「Python におけるオブジェクト参照（参照渡し）」が問題となります。つまり、カスタムオブジェクトを辞書に入れる場合、辞書はオブジェクトへの参照を格納するだけであり、オブジェクトの完全なコピーを作成しているわけではありません。&lt;/p&gt;
&lt;h2 id=&#34;カスタムオブジェクトの基本的な例&#34;&gt;カスタムオブジェクトの基本的な例
&lt;/h2&gt;&lt;p&gt;以下の簡単な &lt;code&gt;Person&lt;/code&gt; クラスを想定してください:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

# Person オブジェクトを作成
p1 = Person(&amp;quot;Alice&amp;quot;, 30)

# オブジェクトを辞書に保存
people_dict = {}
people_dict[&amp;quot;alice&amp;quot;] = p1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この例では、&lt;code&gt;people_dict&lt;/code&gt; 辞書が &lt;code&gt;&amp;quot;alice&amp;quot;&lt;/code&gt; というキーを持つ項目を含み、その値は &lt;code&gt;Person&lt;/code&gt; 型の &lt;code&gt;p1&lt;/code&gt; オブジェクトへの参照です。  &lt;code&gt;p1&lt;/code&gt; の属性を変更すると:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;p1.age = 31
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;辞書からオブジェクトにアクセスするときに、その年齢も更新されていることに気づきます:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(people_dict[&amp;quot;alice&amp;quot;].age)  # 出力: 31
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これは、辞書が &lt;code&gt;Person&lt;/code&gt; オブジェクトの独立したコピーを保存するのではなく、同じメモリ位置への参照を保存しているためです。&lt;/p&gt;
&lt;h2 id=&#34;深復元と浅復元の違い&#34;&gt;深復元と浅復元の違い
&lt;/h2&gt;&lt;p&gt;ネストされたデータ構造やカスタムオブジェクトを扱う場合、このような参照の動作は予期せぬ結果を引き起こす可能性があります。例えば、カスタムオブジェクトが可変型の属性（リストや別のカスタムオブジェクトなど）を含む場合、そのようなオブジェクトを辞書に直接格納し、その変更を加えると、辞書から取得したオブジェクトも影響を受けます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Address:
    def __init__(self, street, city):
        self.street = street
        self.city = city

class Person:
    def __init__(self, name, age, address):
        self.name = name
        self.age = age
        self.address = address

address = Address(&amp;quot;Main St.&amp;quot;, &amp;quot;Springfield&amp;quot;)
p1 = Person(&amp;quot;Bob&amp;quot;, 40, address)
people_dict[&amp;quot;bob&amp;quot;] = p1

# 原始アドレスオブジェクトを変更
address.city = &amp;quot;Shelbyville&amp;quot;

# 辞書内の人のアドレスも変更される
print(people_dict[&amp;quot;bob&amp;quot;].address.city)  # 出力：Shelbyville
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解決策：深復元&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;このような共有状態の問題を回避するためには、辞書がオブジェクトの完全なコピーを格納していることを確認する必要があります。つまり、参照ではなく、独立したコピーである必要があります。Python は &lt;code&gt;copy&lt;/code&gt; モジュールにある &lt;code&gt;deepcopy&lt;/code&gt; 関数を使用してこれを実現します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import copy

# オブジェクトを深復元で格納
people_dict[&amp;quot;bob_deepcopy&amp;quot;] = copy.deepcopy(p1)

# 原始アドレスオブジェクトを変更しても、深復元されたオブジェクトには影響しない
address.city = &amp;quot;Capital City&amp;quot;
print(people_dict[&amp;quot;bob&amp;quot;].address.city)  # 出力：Capital City
print(people_dict[&amp;quot;bob_deepcopy&amp;quot;].address.city)  # 出力：Capital City
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要するに、Python で辞書を使用してカスタムオブジェクトを格納する場合は、デフォルトでオブジェクトの参照が格納されることに注意してください。独立した状態を維持する必要がある場合は、&lt;code&gt;deepcopy&lt;/code&gt; を使用して深復元を行い、共有参照による予期せぬデータ変更を防ぐようにしてください。&lt;/p&gt;</description>
        </item>
        <item>
        <title>新規に設置した10Gbps光回線なのに、なぜ速度が1Gbpsしか出ないのか？</title>
        <link>https://ttf248.life/ja/p/gigabit-fiber-slow-speed/</link>
        <pubDate>Mon, 18 Mar 2024 00:29:02 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/gigabit-fiber-slow-speed/</guid>
        <description>&lt;p&gt;自宅のネットワークを驚くほど高速にしたいですか？鍵はケーブルの種類、光猫、ルーターの設定、そして些細なディテールを知ることです。この記事では、6種類のケーブルを使ってテラビット級のネットワークを構築する方法と、簡単なデバイスチェックと設定で、あなたのネットワーク速度が制限されないようにすることについて、簡単に解説します。さあ、一緒に探求し、自宅のネットワーク速度を飛躍的に向上させましょう！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/gigabit-fiber-slow-speed/image.png&#34;
	width=&#34;1001&#34;
	height=&#34;590&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;手動修復&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;169&#34;
		data-flex-basis=&#34;407px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;第1章ネットワーク伝送媒体の徹底分析&#34;&gt;第1章：ネットワーク伝送媒体の徹底分析
&lt;/h2&gt;&lt;p&gt;千Gb級ネットワーク接続を実現する際、情報を高速に伝送するための担い手であるケーブルが極めて重要な役割を果たします。以下では、カテゴリ5、カテゴリ6、カテゴリ7ケーブルについて詳細な解説を行います。&lt;/p&gt;
&lt;h3 id=&#34;1-五類ケーブルcat5&#34;&gt;1. &lt;strong&gt;五類ケーブル（CAT5）&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;五類ケーブル、別名CAT5は、最も普及した初期のツイストペアケーブルの一種であり、各対線芯を精密ならせん構造で設計することで、クロスプレーク（串扰）を低減します。主に10/100Mbpsの高速以太ネットで使用され、最大伝送周波数約100MHzですが、現在の千ギガビット級、さらにはそれ以上の速度を求めるニーズにおいては、物理的な制限から五類ケーブルは要求を満たせません。&lt;/p&gt;
&lt;h3 id=&#34;2-六類ケーブルcat6&#34;&gt;2. &lt;strong&gt;六類ケーブル（CAT6）&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;技術の発展に伴い、六類ケーブルが登場しました。五類ケーブルと比較して、六類ケーブルはより厳格な製造基準と先進的な構造設計を採用しており、干渉耐性を大幅に向上させ、伝送効率を高めています。1Gbpsまでの伝送速度をサポートし、理想的な条件下では伝送距離が100メートルにも達するため、千兆ネットワークへの接続要件を満たすのに適しています。&lt;/p&gt;
&lt;h3 id=&#34;3-七類ケーブルcat7&#34;&gt;3. &lt;strong&gt;七類ケーブル（CAT7）&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;七類ケーブルは、現在のツイストペア技術における最先端の水準を代表しています。伝送速度において飛躍的な向上を実現し、理論上では最大10Gbpsの超高速率をサポートするだけでなく、設計段階で完全なシールドシステムを採用しており、各配線対間のシールドに加え、全体の外層シールドも含まれています。これにより、外部電磁干渉や近傍串波を大幅に低減し、データ伝送の安定性と正確性を保証します。ただし、七類ケーブルは主に将来の10Gbイーサネットまたは特定の要件の高い環境向けに使用されます。&lt;/p&gt;
&lt;p&gt;千兆家庭ネットワーク環境における構築において、千兆光ファイバの潜在能力を最大限に引き出すためには、六類ケーブルが最も経済的かつ効率的な選択肢となります。また、すべての接続ケーブルの品質が合格していることを確認し、標準的な配線方法に従って作業を行うことも、ネットワーク性能を確保するための重要な要素です。&lt;/p&gt;
&lt;h2 id=&#34;第2章深層ウェブの中枢デバイスの調査---光猫ルーターlanポート帯域幅の影響&#34;&gt;第2章：深層ウェブの中枢デバイスの調査 - 光猫、ルーターLANポート帯域幅の影響
&lt;/h2&gt;&lt;h3 id=&#34;光猫とそのlanポート帯域幅の重要性&#34;&gt;光猫とそのLANポート帯域幅の重要性
&lt;/h3&gt;&lt;p&gt;光猫（光ファイバーモジュレーター・デコーダー）は、家庭用ブロードバンド接続における主要な機器であり、その機能は光ファイバー内の光信号をデジタル信号に変換し、家庭内ネットワークデバイスで使用するために供与するものです。千兆光回線ユーザーの場合、光猫が千兆伝送をサポートしているかどうかが特に重要になります。もし光猫のWANポートが10Gb（百兆）のみをサポートする場合、入宅光ファイバーの速度が高くても、このボトルネックによって10Gb以内に制限されてしまう可能性があります。同様に、光猫のLANポートも千兆出力能力を備えている必要があり、それ以外に接続されるルーターやその他のデバイスが、その真の千兆レートを取得できないのです。&lt;/p&gt;
&lt;h3 id=&#34;ルーターlanポート帯域幅の役割&#34;&gt;ルーターLANポート帯域幅の役割
&lt;/h3&gt;&lt;p&gt;ルーターのLANポートは、受信したデータを各ターミナルデバイスに配布する役割を担います。ルーターのLANポートが単に10Gb（百兆）である場合、他のデバイスの設定がどれほど優れていても、局所網通信は10Gbのレートに制限されます。したがって、千兆家庭ネットワークを構築する場合、ルーターのWANポートが千兆データを受信し、LANポートも千兆レベルのデータ出力能力を提供できるようにすることが重要です。これにより、ご自宅のすべてのスマートデバイスが高速ネットワークによるスムーズな体験を楽しむことができます。&lt;/p&gt;
&lt;p&gt;さらに、一部の古いまたは低端のルーターには、LANポートレート自動交渉メカニズムが存在する場合があります。これは、ルーター自体が千兆をサポートしていても、ケーブルやデバイスの互換性などの理由により10Gbモードに降格してしまう可能性があることを意味します。したがって、ルーターパラメータを正しく設定し、強制千兆モードを有効にし、千兆スイッチまたは直結デバイスと組み合わせて使用することは、全千兆ネットワークを実現するための重要なステップの一つです。&lt;/p&gt;
&lt;p&gt;千兆光ファイバーにアップグレードした場合、必ず千兆光モデムと千兆ルーターに交換し、すべてのデバイスのインターフェースが千兆レベルであることを確認してください。&lt;/p&gt;
&lt;h2 id=&#34;第3章隠された謎--一本の断線したサブラインがテラバイト級ネットワークの速度にどのように影響するか&#34;&gt;第3章：隠された謎 – 一本の断線したサブラインがテラバイト級ネットワークの速度にどのように影響するか
&lt;/h2&gt;&lt;h3 id=&#34;子線故障とネットワーク性能の低下&#34;&gt;子線故障とネットワーク性能の低下
&lt;/h3&gt;&lt;p&gt;測定期間中にネットワークが常に接続を維持し、明らかな切断状態は発生しませんでした。これは新入戸でのブロードバンド導入であり、弱電箱内に配線が散らかっており、光猫のケーブルや電源インターフェース、延長コードの位置を時々調整していたため、偶発的に測定速度が千兆に達することがありました。&lt;/p&gt;
&lt;p&gt;上記の資料に基づき、ケーブルの種類、光猫のLANポート速度などを分析・調査しましたが、最終的には原因はケーブル内部の一本の茶色の子線が断裂していることが判明しました。&lt;/p&gt;
&lt;p&gt;断裂の原因：作業員が水晶頭を設置する際に、このケーブルを少し強く引っ張ったため、子線が半分ほど断ち切られ、完全に切り離されずにいました。その後、光猫の位置を調整する際に、繰り返し移動させることで、最終的に完全に断裂してしまいました。&lt;/p&gt;
&lt;h3 id=&#34;ケーブルの種類8本の機能解析&#34;&gt;ケーブルの種類8本の機能解析
&lt;/h3&gt;&lt;p&gt;六類網線はTIA/EIA-568-B規格に準拠し、8本の双絞り線を含みます。以下のカラーコードに従っています：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;白橙 / 橙 (しろおげ / おげ)&lt;/li&gt;
&lt;li&gt;白緑 / 緑 (しろりょく / りょく)&lt;/li&gt;
&lt;li&gt;白藍 / 藍 (しろらん / らん)&lt;/li&gt;
&lt;li&gt;白棕 / 棕 (しろしゅん / しゅん)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;千兆イーサネット（1000BASE-T）の規格下では、これらの8本の線の中から4対の線が同時に動作します。具体的な役割分担は以下の通りです：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;白橙と橙のペア (1&amp;amp;2) は、送信データ (Tx+/-) 用です；&lt;/li&gt;
&lt;li&gt;白緑と緑のペア (3&amp;amp;6) は、受信データ (Rx+/-) 用です；&lt;/li&gt;
&lt;li&gt;白藍と藍のペア (4&amp;amp;5) および白棕と棕のペア (7&amp;amp;8) は、千兆イーサネットでは当初は副用ですが、高度なアプリケーション（例えば、一部PoE給電や将来の技術拡張など）で有効化されることがあります。従来の100Gbイーサネットでは、1, 2, 3, 6 の4本の線を使用するだけで十分です。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;断裂子線がネットワーク速度に与える影響&#34;&gt;断裂子線がネットワーク速度に与える影響
&lt;/h3&gt;&lt;p&gt;上記の場合において、もし一根褐色の子線（すなわち棕線または棕白線）が断裂した場合、理論上は千兆ネットワーク環境下で速度低下を引き起こす可能性があります。なぜなら、千兆ネットワークでは、すべての四対の線が同時に双方向で伝送することで満速を実現する必要があるためです。しかしながら、家庭用ネットワーク機器には自動ネゴシエーション機能が搭載されており、ケーブルに問題が検出された場合、正常に動作する低いレートモード（百兆モード）に回帰します。これが、一根子線が断裂してもネットワークが接続を維持し、百兆速度で動作を続ける理由を説明しています。&lt;/p&gt;
&lt;p&gt;要するに、一根棕色の子線が断裂しても百兆ネットワークの基本的な動作には影響しませんが、千兆ネットワーク環境下では、それがネットワーク速度を制限する重要な要因となる可能性があります。詳細な診断と修復を行うまで、その潜在的な能力は十分に発揮されません。また、この状況は、類似の問題が発生した際に、ネットワークインフラストラクチャ上の潜在的な問題を無視しないように警告しています。たとえ基本的な接続に影響を与えないように見える小さな故障であっても、高速ネットワーク体験の隠れた障害となる可能性があります。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>WPFにおけるUIスレッドとフリーズ問題とその解決策</title>
        <link>https://ttf248.life/ja/p/wpf-ui-thread-and-freezing-solutions/</link>
        <pubDate>Tue, 12 Mar 2024 07:12:21 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/wpf-ui-thread-and-freezing-solutions/</guid>
        <description>&lt;p&gt;デスクトップアプリケーションの開発、特にWindows Presentation Foundation (WPF) などのフレームワークを使用してリッチクライアントアプリケーションを構築する際には、ユーザーインターフェース（UI）スレッドの適切な処理が、アプリケーションの応答性やスムーズな動作を保証するために非常に重要です。UIスレッド、またはメインスレッドとは、ウィンドウやコントロールのイベント、レイアウト計算、および画面表示の描画を担当するコアとなるスレッドです。UI要素とやり取りするすべての操作は、UIスレッド上で実行する必要があります。これは、WPFをはじめとするほとんどのGUIフレームワークが遵守する基本的な原則です。&lt;/p&gt;
&lt;h2 id=&#34;uiスレッドとは&#34;&gt;UIスレッドとは？
&lt;/h2&gt;&lt;p&gt;UIスレッドは、WPFアプリケーションが起動される際にオペレーティングシステムによって作成され、初期化されるアプリケーションのメインウィンドウです。これは、アプリケーション内でUIコンポーネントの状態を直接アクセスし、変更できる唯一のスレッドです。つまり、ボタンのクリック、テキストボックスへの入力、ウィンドウサイズの変更など、すべてのユーザーインタラクションによって発生するイベントは、このスレッドコンテキストで処理されます。さらに、WPFの依存性プロパティシステム、データバインディングメカニズム、レイアウトロジックもすべてUIスレッド上で同期的に実行されます。&lt;/p&gt;
&lt;h2 id=&#34;uiフリーズとその原因&#34;&gt;UIフリーズとその原因
&lt;/h2&gt;&lt;p&gt;UIスレッドが長時間占有またはブロックされると、例えば、時間のかかる計算、大量のデータ読み込み、データベースクエリ、その他のI/O密度の高いタスクを実行する場合、UIスレッドはユーザーからのインタラクションリクエストにタイムリーに対応できなくなり、結果として画面がフリーズ（Freeze）、つまり私たちがよく言う「カドト」が発生します。このような場合、ユーザーはアプリケーションの遅延や不自然さを明確に感じ、最悪の場合、「Application Not Responding」（ANR）警告が表示されます。&lt;/p&gt;
&lt;h2 id=&#34;uiスレッドの基本ルール２つ&#34;&gt;UIスレッドの基本ルール２つ
&lt;/h2&gt;&lt;p&gt;上記のような状況を回避するため、WPF開発者は以下の２つの重要なルールに従う必要があります。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UIスレッドで時間がかかる処理を実行しない&lt;/strong&gt;: UIスレッドがブロックされる可能性のある操作は、可能な限りバックグラウンドスレッドで実行し、UIスレッドがユーザーの入力や画面の変化に迅速に対応できるようにする必要があります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;非UIスレッドから直接UI要素を更新しない&lt;/strong&gt;: WPFのセキュリティメカニズムにより、UIスレッドのみがUI要素の変更を行う権限を持っています。他のスレッドから直接UIの状態を変更しようとすると例外が発生します。したがって、バックグラウンドスレッドで計算やデータ準備が完了した後でも、適切なクロススレッド通信メカニズムを使用して結果をUIに表示する必要があります。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;解決策非同期プログラミングとスレッドセーフなアップデート&#34;&gt;解決策：非同期プログラミングとスレッドセーフなアップデート
&lt;/h2&gt;&lt;p&gt;UIのフリーズを防ぎつつ、時間のかかるタスクを実行するために、WPFは、開発者がこの目標を達成するためのさまざまな非同期プログラミングモデルやツールを提供しています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Dispatcherオブジェクト&lt;/strong&gt;: WPFのDispatcherクラスを使用すると、タスクをUIスレッドのキューに追加して実行できます。&lt;code&gt;Dispatcher.Invoke&lt;/code&gt;または&lt;code&gt;Dispatcher.BeginInvoke&lt;/code&gt;メソッドを使用して、バックグラウンドスレッドからUIを安全に更新できます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;async/awaitキーワード&lt;/strong&gt;: C#言語の非同期特性を活用し、&lt;code&gt;await&lt;/code&gt;キーワードを使用してバックグラウンドタスクが完了するのを待機し、完了後にUI更新コードを実行する非同期メソッドを作成できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ケース-ケース--例-れい&#34;&gt;ケース (ケース) / 例 (れい)
&lt;/h2&gt;&lt;h3 id=&#34;dispatcherinvokeメソッドを使用してuiを更新する&#34;&gt;&lt;code&gt;Dispatcher.Invoke&lt;/code&gt;メソッドを使用してUIを更新する
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private void Button_Click(object sender, RoutedEventArgs e)
{
    // これは時間のかかる操作であると仮定します
    Task.Run(() =&amp;gt;
    {
        var result = LongRunningOperation(); // ここは時間のかかる計算メソッドのシミュレーションです

        // 時間のかかる操作が完了したら、UIスレッドでUIを更新します
        Application.Current.Dispatcher.Invoke(() =&amp;gt;
        {
            LabelStatus.Text = $&amp;quot;結果: {result}&amp;quot;;
        });
    });
}

private string LongRunningOperation()
{
    // 時間のかかる操作をシミュレーションします
    Thread.Sleep(5000);
    return &amp;quot;完了&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;asyncawaitキーワードとtaskrunの組み合わせ&#34;&gt;&lt;code&gt;async/await&lt;/code&gt;キーワードと&lt;code&gt;Task.Run&lt;/code&gt;の組み合わせ
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private async void Button_ClickAsync(object sender, RoutedEventArgs e)
{
    Button button = sender as Button;
    button.IsEnabled = false; // ユーザーが繰り返しクリックするのを防ぐ

    try
    {
        // バックグラウンドタスクを開始
        var result = await Task.Run(() =&amp;gt; LongRunningOperation());

        // バックグラウンドタスクが完了したら、UIスレッドに自動的に切り替えてUIを更新
        LabelStatus.Text = $&amp;quot;計算結果: {result}&amp;quot;;
    }
    catch (Exception ex)
    {
        MessageBox.Show($&amp;quot;エラーが発生しました: {ex.Message}&amp;quot;);
    }
    finally
    {
        button.IsEnabled = true; // ボタンを再度有効にする
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>GCCバージョンをアップグレードした結果、プログラムがクラッシュしました：コードの非規整性による問題点</title>
        <link>https://ttf248.life/ja/p/gcc-upgrade-causes-program-crash-code-irregularities/</link>
        <pubDate>Sun, 10 Mar 2024 23:19:06 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/gcc-upgrade-causes-program-crash-code-irregularities/</guid>
        <description>&lt;p&gt;同一段業務コードにおいて、プログラムが CentOS 7 環境下で正常にコンパイルおよび実行されていたが、CentOS 8 に切り替えて GCC の最新版を使用してコンパイルを行った際に、プログラムがクラッシュが発生した。注目すべきは、問題が &lt;strong&gt;Release モード&lt;/strong&gt; 下でのみ発生し、&lt;strong&gt;Debug モード&lt;/strong&gt; では完全に問題がない点である。これは初めての事例であり、3日間の調査を経て、問題の原因を特定することができた。&lt;/p&gt;
&lt;h3 id=&#34;問題の特定&#34;&gt;問題の特定
&lt;/h3&gt;&lt;p&gt;一番の原因究明の結果、問題の本質は &lt;strong&gt;関数に返り値がないこと&lt;/strong&gt; にあります。リリースモードにおいて、GCCの新バージョンではより多くの最適化が行われるため、本来返り値のない関数が実行中に未知の論理が発生し、それがクラッシュを引き起こしました。結論として、&lt;strong&gt;コンパイラの警告を無視することは許されません。特に、古いプロジェクトにおいては、一部の警告が無視される可能性がありますが、すべての警告を無効にすることは避けるべきです&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;環境説明&#34;&gt;環境説明
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CentOS 7 GCCバージョン:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CentOS 8 GCCバージョン:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;クラッシュ現象&#34;&gt;クラッシュ現象
&lt;/h3&gt;&lt;p&gt;プログラムのクラッシュに関するスタックを分析した結果、以下のスタック情報が得られました：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[New LWP 1385902]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib64/libthread_db.so.1&amp;quot;.
Core was generated by `./pstack_main`.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007ffe894b4420 in ?? ()
(gdb) bt
#0  0x00007ffe894b4420 in ?? ()
#1  0x00000000004008e9 in main ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このスタックは直感的ではありません。クラッシュ関数のスタック情報が &lt;code&gt;??&lt;/code&gt; と表示されるため、問題の特定がさらに複雑になります。&lt;/p&gt;
&lt;h3 id=&#34;コード例&#34;&gt;コード例
&lt;/h3&gt;&lt;p&gt;問題をより良く理解するために、クラッシュを再現するための最小コード例を示します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int test() {
    std::cout &amp;lt;&amp;lt; &amp;quot;1&amp;quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    test();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このコード内の &lt;code&gt;test()&lt;/code&gt; 関数は明らかに値を明示的に返していません。また、その戻り値の型は &lt;code&gt;int&lt;/code&gt; です。C++ 仕様によると、関数が &lt;code&gt;int&lt;/code&gt; 型で宣言されている場合、必ず戻り値を持つ必要があり、そうでない場合は未定義動作を引き起こす可能性があります。&lt;/p&gt;
&lt;h3 id=&#34;コンパイル警告&#34;&gt;コンパイル警告
&lt;/h3&gt;&lt;p&gt;当方のプロジェクトにおいて、CMake スクリプトが多くのコンパイル時の警告を抑制しており、その中に以下の警告情報が含まれています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/root/pstack/main.cpp: In function ‘int test()’:
/root/pstack/main.cpp:7:1: warning: no return statement in function returning non-void [-Wreturn-type]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この警告は、&lt;code&gt;test()&lt;/code&gt; 関数が戻り値を持たないことを示しており、これがまさに問題の原因です。GCC の高バージョン（例：8.5.0）では、コードを最適化する際にこのような未定義の動作に対して不安定な最適化を行う可能性があり、プログラムがクラッシュする原因となることがあります。&lt;/p&gt;
&lt;h3 id=&#34;어셈블리-코드-차이점&#34;&gt;어셈블리 코드 차이점
&lt;/h3&gt;&lt;p&gt;GCC 컴파일러 최적화 동작의 차이를 설명하기 위해, 서로 다른 버전의 GCC가 생성한 어셈블리 코드를 비교했습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GCC 4.8.5 생성된 어셈블리 코드:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;어셈블리 코드가 다소 길고 표준 출력 스트림(예: &lt;code&gt;std::cout&lt;/code&gt;) 처리에 대한 로직을 포함하고 있습니다. 이는 컴파일러가 &lt;code&gt;test()&lt;/code&gt; 함수에서 누락된 반환 값 문제에 대해 과도하게 최적화하지 않았음을 나타내며, 이로 인해 잠재적으로 충돌을 피했을 수 있음을 시사합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GCC 8.5.0 생성된 어셈블리 코드:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;새로운 버전의 GCC는 더 많은 최적화를 수행하여 코드 양을 줄였습니다. 그러나 이러한 최적화가 누락된 반환 값을 갖는 함수의 실행 시 동작이 불확실하게 되어 프로그램 충돌을 유발할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;結論&#34;&gt;結論
&lt;/h3&gt;&lt;p&gt;今回の問題解決を通して、C++において&lt;strong&gt;関数が返す値は明確に定義されるべきである&lt;/strong&gt;という点を深く認識しました。特に、関数を&lt;code&gt;int&lt;/code&gt;型として宣言する場合、必ず戻り値を提示する必要があります。古いコンパイラ版を使用しているプロジェクトでGCCの新しいバージョンにアップグレードした場合、より多くの最適化や厳格な警告メカニズムが導入される可能性があります。そのため、コンパイル時に&lt;strong&gt;すべての警告を無効化しない&lt;/strong&gt;ことを推奨します。代わりに、関数が返す値、型の一致など、一般的な問題に対して選択的に対処する必要があります。
最終的に、&lt;code&gt;test()&lt;/code&gt;関数に戻り値を付与することで問題は解決し、プログラムは正常に動作するようになりました。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>VMware仮想マシンのCPUリソース使用率異常</title>
        <link>https://ttf248.life/ja/p/vmware-virtual-machine-cpu-usage-anomaly/</link>
        <pubDate>Sun, 10 Mar 2024 22:14:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/vmware-virtual-machine-cpu-usage-anomaly/</guid>
        <description>&lt;p&gt;背景：ローカルマシンにデプロイされたWindows版の業務システムで、CPU使用率が約5％です。VMwareにインストールしたCentOS8上にLinux版の業務システムをデプロイし、リソース使用量に異常が見られます。&lt;/p&gt;
&lt;h2 id=&#34;問題の記述&#34;&gt;問題の記述
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;宿主机：win10 企业版&lt;/li&gt;
&lt;li&gt;VMware：17.5&lt;/li&gt;
&lt;li&gt;仮想マシン：centos8
仮想マシンのリソース配分は&lt;code&gt;4C8GB&lt;/code&gt;で、ビジネスシステムを起動します。ビジネスシステムが仮想マシンLinuxシステムにデプロイされており、仮想マシン内部のtopコマンドでシステムのリソース使用率を確認すると、CPU使用率は高くありません。しかし、外側のWindowsシステムでタスクマネージャーを見ると、CPUリソース使用率は非常に高くなっています。プロセスを確認すると、VMware プロセスがCPUリソースを大量に使用しています。
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+
|         Windows           |
|                           |
|   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+  |
|   |      VMware        |  |
|   |      Program       |  |
|   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+  |
|                           |
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;知識点&#34;&gt;知識点
&lt;/h2&gt;&lt;p&gt;この問題のトラブルシューティングは、スムーズに進まず、原因はビジネスシステム自体ではなく、仮想マシンの問題にある。通常のビジネスコードからの思考を、システム負荷に転換し、さらに負荷データの異常から、スワップ中断へと追跡し、最終的に重要なポイントにたどり着くには、VMwareのスワップ中断のパフォーマンスに影響を与えるものは何か？ 本稿ではまず各知識点を解説し、最後に解決策を示す。&lt;/p&gt;
&lt;h3 id=&#34;hyper-v&#34;&gt;Hyper-V
&lt;/h3&gt;&lt;p&gt;Windowsオペレーティングシステムの仮想化技術において、大きな変革がありました。Microsoftが最初にWSL（Windows Subsystem for Linux）をリリースした際、Hyper-Vサービスを有効にすると、VMware仮想マシンの同時使用ができなくなっていました。その後、バージョンアップにより、VMwareはHyper-Vサービスと互換性を持つようになりました。&lt;/p&gt;
&lt;h3 id=&#34;システム負荷&#34;&gt;システム負荷
&lt;/h3&gt;&lt;p&gt;Linuxシステムにおいて、「負荷」（load）とは、実行中または実行を待っているプロセスの数です。負荷は通常、1分間、5分間、および15分間の実行キュー内の平均プロセス数を表す3つの数字で示されます。これらの数字は、「uptime」コマンドまたは「top」コマンドを実行することで確認できます。&lt;/p&gt;
&lt;p&gt;具体的には、この3つの数字はそれぞれ以下の意味を持ちます。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;1分負荷&lt;/strong&gt;: システムが過去1分間に実行キュー内に存在していた平均プロセス数です。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;5分負荷&lt;/strong&gt;: システムが過去5分間に実行キュー内に存在していた平均プロセス数です。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;15分負荷&lt;/strong&gt;: システムが過去15分間に実行キュー内に存在していた平均プロセス数です。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;負荷の概念は、システム内で待っているプロセスの数です。この数値が高い場合、システムに多くのプロセスがCPUリソースを待機していることを意味し、システムが遅くなるか応答しなくなる可能性があります（ただし、負荷の高さとシステムの構成およびパフォーマンスによって異なります）。&lt;/p&gt;
&lt;p&gt;理想的には、負荷はシステムの論理CPU数の範囲内に保つことが望ましく、これによりシステムのパフォーマンスを最適化できます。負荷が継続的にCPU数を超過する場合、システム内のプロセスを分析して負荷の原因を特定し、適切な対策を講じることで、リソース割り当てを調整したり、プロセスの実行方法を最適化したりすることができます。&lt;/p&gt;
&lt;h3 id=&#34;負荷の分析---mpstat&#34;&gt;負荷の分析 - mpstat
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;mpstat&lt;/code&gt;コマンドは、個々のプロセッサまたは複数のプロセッサに関するさまざまな情報を報告するために使用されます。これには、平均負荷、CPU利用率、割り込み、コンテキストスイッチングなどが含まれます。&lt;code&gt;sysstat&lt;/code&gt;パッケージの一部として、&lt;code&gt;mpstat&lt;/code&gt;はシステムの負荷状況を分析するための非常に便利なツールです。以下に、&lt;code&gt;mpstat&lt;/code&gt;を使用して負荷を分析する手順を示します。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;sysstatのインストール:&lt;/strong&gt;
システムに&lt;code&gt;sysstat&lt;/code&gt;がインストールされていない場合は、使用しているシステムに適したパッケージマネージャを使用してインストールしてください。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;mpstatの実行:&lt;/strong&gt;
&lt;code&gt;mpstat&lt;/code&gt;コマンドを実行して、CPUの使用状況と負荷を確認します。デフォルトでは、&lt;code&gt;mpstat&lt;/code&gt;は1秒ごとにCPU利用率の平均値を表示します。出力頻度を調整するには、時間間隔を指定できます。たとえば、&lt;code&gt;mpstat -P ALL 2&lt;/code&gt;を使用して、毎秒1回&lt;code&gt;mpstat&lt;/code&gt;を実行し、&lt;code&gt;irq&lt;/code&gt;で割り込みの使用状況を確認します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;出力の分析:&lt;/strong&gt;
&lt;code&gt;mpstat&lt;/code&gt;の出力には、各プロセッサの利用率とシステムの平均負荷が含まれています。平均負荷と各プロセッサの利用率に特に注意してください。これにより、システムの負荷状況を理解できます。負荷が高い場合は、どのプロセスが原因であるかをさらに分析し、パフォーマンスボトルネックがないか確認します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;他のツールの併用:&lt;/strong&gt;
&lt;code&gt;mpstat&lt;/code&gt;に加えて、&lt;code&gt;sar&lt;/code&gt;、&lt;code&gt;pidstat&lt;/code&gt;、&lt;code&gt;iostat&lt;/code&gt;などのツールを使用して、システム全体のパフォーマンスを総合的に分析できます。複数のツールの出力を組み合わせることで、システムの負荷状況をより包括的に理解し、パフォーマンスの問題の根本原因を特定することができます。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;割り込み&#34;&gt;割り込み
&lt;/h3&gt;&lt;p&gt;本内容は詳細に説明しないため、過度な解説は省略します。
推奨: &lt;a class=&#34;link&#34; href=&#34;https://www.codedump.info/post/20200522-sgfap-softirq/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;アプリケーション開発者向けシステムガイド CPU編 - ソフトウェア割り込み&lt;/a&gt;
頻繁にソフトウェア割り込みをトリガーすると、システム負荷にも反映されます。&lt;/p&gt;
&lt;h2 id=&#34;問題のトラブルシューティング&#34;&gt;問題のトラブルシューティング
&lt;/h2&gt;&lt;p&gt;CPUのみから分析するだけでは問題の原因を特定できないため、システムに異常が発生しているのではないかと疑うべきでしょうか。おそらくLinuxオペレーティングシステムの負荷が高くなり、VMwareが過剰なCPUリソースを使用している可能性があります。&lt;code&gt;mpstat&lt;/code&gt;を使用してローカル仮想マシンを分析したところ、&lt;code&gt;irq&lt;/code&gt;の使用量が異常で、単一コアあたり25%近く占めており、正常時にはビジネスプロセス起動時に空転する場合、&lt;code&gt;irq&lt;/code&gt;の割合は約5%程度であるはずでした。&lt;/p&gt;
&lt;p&gt;グループ内の同僚の開発環境では、CentOS 7がVMware上でデプロイされており、リソース使用量は正常でした。一方、上海の開発環境では、VMware上にデプロイされていましたが、ホストマシンのCPUリソース状況を直接観察することはできませんでした。この時、当社は複数の変数に直面していました：VMware仮想マシン、Linuxオペレーティングシステム、GCCバージョン。&lt;/p&gt;
&lt;p&gt;そこでテスト環境を分析することにしました。深圳のテスト環境は物理マシン上にデプロイされており、低バージョンのGCCでコンパイルされたサービスを実行し、CentOS 8上で動作していました。興味深いことに、深圳環境では&lt;code&gt;irq&lt;/code&gt;の使用量は正常でした。&lt;/p&gt;
&lt;p&gt;GCCバージョンに関連する問題が原因である可能性を調査するために、高バージョンのGCCでコンパイルしたプログラムを深圳環境にデプロイしてテストしましたが、結果も正常でした。&lt;/p&gt;
&lt;p&gt;問題は徐々に明確になってきました。オペレーティングシステムに問題があるのではないかと疑い始めました。毕竟、CentOS 8はすでに公式サポートを受けていないためです。しかし、純粋なCentOS 7とCentOS 8を再デプロイしても問題は解決しませんでした。&lt;/p&gt;
&lt;p&gt;この時、当社は唯一の不確実要素、つまりVMware仮想マシンソフトウェアに疑念を抱くようになりました。突然、閃きが起こり、Hyper-V技術が以前有効になっていたものの、完全にシャットダウンされなかったのではないかと考えました。毕竟、ソフトウェア中断も仮想マシンソフトウェアを通じて実現されるためです。異なる仮想マシン仮想化技術にはバグが存在する可能性があります。これらの問題は深く考える価値があります。&lt;/p&gt;
&lt;h2 id=&#34;結論&#34;&gt;結論
&lt;/h2&gt;&lt;p&gt;マイクロソフト公式のマニュアルに従い、本機のHyper-Vサービスを完全に停止した後、VMwareがホストマシン上で正常に動作することが確認されました。これで問題はついに解決に至りました。当初述べたように、この経験は曲折で困難なものであり、包括的な分析と判断が必要でした。また、今回初めて問題を調査し、仮想マシンというレベルまで特定することができました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Disable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V-Hypervisor
bcdedit /set hypervisorlaunchtype off
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/application-management/virtualization-apps-not-work-with-hyper-v&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/application-management/virtualization-apps-not-work-with-hyper-v&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>C&#43;&#43;プログラミングにおける罠：`std::map`の誤用がプログラムをクラッシュさせることの詳細な解説</title>
        <link>https://ttf248.life/ja/p/cpp-programming-traps-std-map-crash-details/</link>
        <pubDate>Sun, 10 Mar 2024 22:03:06 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cpp-programming-traps-std-map-crash-details/</guid>
        <description>e&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;std::map&lt;/code&gt; は C++ 標準ライブラリにおける連想コンテナであり、キー（key）を昇順にソートして要素を格納し、効率的なキーワード検索機能を提供します。しかし、初心者開発者は &lt;code&gt;std::map&lt;/code&gt; の中括弧演算子 &lt;code&gt;[]&lt;/code&gt; の動作について理解不足なために困惑することがあります。実際には、&lt;code&gt;[]&lt;/code&gt; を使用して存在しないキーにアクセスすると、&lt;code&gt;std::map&lt;/code&gt; は新しいキー値ペアを挿入し、デフォルトコンストラクタを使用してそのキーに対応する値の型を初期化します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int main() {
    std::map&amp;lt;std::string, int&amp;gt; myMap;

    // 誤った使い方：存在しないキーにアクセスし、0 が返ると仮定する
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for &#39;nonexistent_key&#39;: &amp;quot; &amp;lt;&amp;lt; myMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;

    // 実際には、上記の行は新しいキー値ペアを作成し、その値を int のデフォルト値（通常は 0）で初期化します。
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このコードは直接プログラムをクラッシュさせませんが、このような暗黙的な挿入動作は、リソースリークや予期しない状態の変更など、いくつかの状況で意図しない副作用を引き起こす可能性があります。さらに悪いことに、マルチスレッド環境での未初期化メモリ領域への同時アクセスにより、プログラムがクラッシュする可能性もあります。&lt;/p&gt;
&lt;p&gt;これらの問題を回避するために、&lt;code&gt;std::map::find()&lt;/code&gt; または &lt;code&gt;std::map::count()&lt;/code&gt; メソッドを使用してキーの存在を確認するか、&lt;code&gt;std::map::insert()&lt;/code&gt; を使用して明示的に要素を挿入することをお勧めします。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::map&amp;lt;std::string, int&amp;gt; safeMap;
if (safeMap.count(&amp;quot;nonexistent_key&amp;quot;) == 0) {
    std::cout &amp;lt;&amp;lt; &amp;quot;Key does not exist.&amp;quot; &amp;lt;&amp;lt; std::endl;
} else {
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for existing key: &amp;quot; &amp;lt;&amp;lt; safeMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;
}

// または、キーと値を明示的に挿入する
safeMap.insert({ &amp;quot;new_key&amp;quot;, 0 });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;マップコンテナ内のオブジェクトがポインタ型の場合、暗黙的な挿入動作は未初期化のポインタを保存し、そのポインタへの呼び出しはプログラムのクラッシュにつながります。&lt;/p&gt;</description>
        </item>
        <item>
        <title>pstack でプロセスがフリーズしている原因を調査する</title>
        <link>https://ttf248.life/ja/p/pstack-troubleshooting-process-hangs/</link>
        <pubDate>Sat, 24 Feb 2024 23:55:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/pstack-troubleshooting-process-hangs/</guid>
        <description>&lt;p&gt;ソフトウェア開発および運用において、プロセスがフリーズしてしまう状況は頻繁に発生します。この状態はシステム性能の低下やサービスの停止を引き起こす可能性があります。本稿では、pstackツールを使用してプロセスフリーズの問題を診断する方法について解説します。プロセスのスタック情報を分析することで、問題の原因を特定し解決策を見つけ出すことができます。&lt;/p&gt;
&lt;p&gt;背景：リスク管理システムの子サービスでフリーズが発生し、リスク管理サービスが利用不可となりました。可用性監視の欠如により、プロセスフリーズの状態を早期に検知することができず、システム全体が停止するという事態に至りました。&lt;/p&gt;
&lt;h2 id=&#34;本文&#34;&gt;本文
&lt;/h2&gt;&lt;p&gt;プロセスのフォジー（ゾンビプロセス）とは、プロセスが応答を停止しているにもかかわらず、終了していない状態を指します。この状況は、デッドロック、リソースの枯渇、例外など、さまざまな原因によって引き起こされる可能性があります。これらの問題に対処するためには、&lt;code&gt;pstack&lt;/code&gt; ツールを使用してプロセスのスタック情報を分析し、根本原因を特定することができます。&lt;/p&gt;
&lt;h2 id=&#34;ステップ&#34;&gt;ステップ
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;pstack&lt;/code&gt; は一般的なツールで、通常は &lt;code&gt;gdb&lt;/code&gt; (GNU デバッガ) と共に提供されます。以下のコマンドでインストールできます：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt-get install gdb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;プロセスのIDを取得する: まず、スタックされたプロセスのプロセスID (PID) を取得する必要があります。&lt;code&gt;ps&lt;/code&gt; コマンドを使用してすべてのプロセスをリストし、調査対象のプロセスIDを見つけます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pstack&lt;/code&gt; ツールを使ってプロセスのスタック情報を分析します。プロセスIDを取得したら、以下のコマンドを実行してスタック情報を取得できます：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pstack &amp;lt;PID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これにより、現在の呼び出しシーケンスで実行中の関数が示されたプロセスのスタック情報が出力されます。この情報を分析することで、プロセスが停止した場所を特定し、問題の診断に役立てることができます。&lt;/p&gt;
&lt;p&gt;スタック情報を分析する: スタック情報を確認することで、プロセスがスタック状に停止している原因を見つけることができます。ロックによる競合状態、無限ループ、またはその他の異常な状況などが見つかる可能性があります。具体的な状況に応じて、適切な対策（ロックの解放、コードロジックの修正など）を講じてください。&lt;/p&gt;
&lt;h2 id=&#34;実行例&#34;&gt;実行例
&lt;/h2&gt;&lt;p&gt;簡単なデモで、&lt;code&gt;main&lt;/code&gt;関数が起動した後、新しいスレッドを作成し、実際の関数を実行することで無限ループに陥り、プログラムが正常に終了できず、偽の停止状態になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cmake_minimum_required(VERSION 3.0.0)
project(pstack_main VERSION 0.1.0 LANGUAGES C CXX)

include(CTest)
enable_testing()

# スレッドライブラリを検索
find_package(Threads REQUIRED)

add_executable(pstack_main main.cpp)

# スレッドライブラリへのリンク
target_link_libraries(pstack_main PRIVATE Threads::Threads)

set(CPACK_PROJECT_NAME ${PROJECT_NAME})
set(CPACK_PROJECT_VERSION ${PROJECT_VERSION})
include(CPack)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;
#include &amp;lt;chrono&amp;gt;

void infiniteLoop() {
    while (true) {
        // メインスレッドが無限ループに陥る
    }
}

int main() {
    std::thread thread(infiniteLoop); // 無限ループを実行する関数を持つスレッドを作成
    thread.join(); // スレッドの終了を待つ
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;プログラムを実行し、&lt;code&gt;pstack&lt;/code&gt;の結果を確認します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Thread 2 (Thread 0x7eff3619b700 (LWP 1315017)):
#0  infiniteLoop () at /root/pstack/main.cpp:6
#1  0x0000000000402ca9 in std::__invoke_impl&amp;lt;void, void (*)()&amp;gt; (__f=@0x2260eb8: 0x4029a6 &amp;lt;infiniteLoop()&amp;gt;) at /usr/include/c++/8/bits/invoke.h:60
#2  0x0000000000402b02 in std::__invoke&amp;lt;void (*)()&amp;gt; (__fn=@0x2260eb8: 0x4029a6 &amp;lt;infiniteLoop()&amp;gt;) at /usr/include/c++/8/bits/invoke.h:95
#3  0x0000000000403150 in std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt;::_M_invoke&amp;lt;0ul&amp;gt; (this=0x2260eb8) at /usr/include/c++/8/thread:244
#4  0x0000000000403126 in std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt;::operator() (this=0x2260eb8) at /usr/include/c++/8/thread:253
#5  0x000000000040310a in std::thread::_State_impl&amp;lt;std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt; &amp;gt;::_M_run (this=0x2260eb0) at /usr/include/c++/8/thread:196
#6  0x00007eff36bceb23 in execute_native_thread_routine () from /lib64/libstdc++.so.6
#7  0x00007eff36ea91ca in start_thread () from /lib64/libpthread.so.0
#8  0x00007eff361d58d3 in clone () from /lib64/libc.so.6
Thread 1 (Thread 0x7eff372e1740 (LWP 1315016)):
#0  0x00007eff36eaa6cd in __pthread_timedjoin_ex () from /lib64/libpthread.so.0
#1  0x00007eff36bceda7 in std::thread::join() () from /lib64/libstdc++.so.6
#2  0x00000000004029d2 in main () at /root/pstack/main.cpp:13
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;プロセスが偽の停止状態になっているのは、無限ループに入っているためで、メイン&lt;/p&gt;
</description>
        </item>
        <item>
        <title>C&#43;&#43;関数呼び出しのオーバーヘッド時間 / 関数呼び出し時のパフォーマンスに関する問題</title>
        <link>https://ttf248.life/ja/p/cpp-function-call-timing/</link>
        <pubDate>Wed, 24 Jan 2024 14:11:33 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cpp-function-call-timing/</guid>
        <description>&lt;p&gt;設計行情 SDK、針對不同的回呼函數實現方式，進行了一次耗時的測試。近期在看 C++ 函數編程，當函數變成了一等公民，在程式內部流轉，耗時有什么不同？&lt;/p&gt;
&lt;p&gt;前文連結：&lt;a class=&#34;link&#34; href=&#34;https://ttf248.life/ja/p/compiler-callback-performance-testing/&#34; &gt;编译器、回调函数、性能测试&lt;/a&gt;
&lt;code&gt;leimao&lt;/code&gt; 大佬刚好也做了类似的測試，借代码一用。&lt;/p&gt;
&lt;h2 id=&#34;本文&#34;&gt;本文
&lt;/h2&gt;&lt;p&gt;実行プラットフォームは引き続き、当社の旧友である &lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt; です。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;cassert&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

int add_one(int input) { return input + 1; }

bool validate_vector_add_one(std::vector&amp;lt;int&amp;gt; const&amp;amp; input_vector,
                             std::vector&amp;lt;int&amp;gt; const&amp;amp; output_vector)
{
    bool is_valid{true};
    for (size_t i{0}; i &amp;lt; input_vector.size(); ++i)
    {
        if (output_vector.at(i) != input_vector.at(i) + 1)
        {
            is_valid = false;
            break;
        }
    }
    return is_valid;
}

void reset_vector(std::vector&amp;lt;int&amp;gt;&amp;amp; input_vector)
{
    for (size_t i{0}; i &amp;lt; input_vector.size(); ++i)
    {
        input_vector.at(i) = 0;
    }
}

template &amp;lt;typename T, typename Func&amp;gt;
void unitary_function_pass_by_lambda_function(T&amp;amp; output, T const&amp;amp; input,
                                              Func const func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_std_function_value(T&amp;amp; output, T const&amp;amp; input,
                                                 std::function&amp;lt;T(T)&amp;gt; const func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_std_function_reference(
    T&amp;amp; output, T const&amp;amp; input, std::function&amp;lt;T(T)&amp;gt; const&amp;amp; func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_function_pointer(T&amp;amp; output, T const&amp;amp; input,
                                               T (*func)(T))
{
    output = func(input);
}

int main()
{
    // Set floating point format std::cout with 3 decimal places.
    std::cout.precision(3);

    size_t const num_elements{10000000};
    std::vector&amp;lt;int&amp;gt; input_vector(num_elements, 0);
    std::vector&amp;lt;int&amp;gt; output_vector(num_elements, 0);

    auto const lambda_function_add_one{[](int const&amp;amp; input) -&amp;gt; int
                                       { return input + 1; }};
    std::function&amp;lt;int(int)&amp;gt; const std_function_add_one{lambda_function_add_one};

    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a function pointer: &amp;quot; &amp;lt;&amp;lt; sizeof(&amp;amp;add_one)
              &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a std::function pointer: &amp;quot;
              &amp;lt;&amp;lt; sizeof(&amp;amp;std_function_add_one) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a std::function: &amp;quot; &amp;lt;&amp;lt; sizeof(std_function_add_one)
              &amp;lt;&amp;lt; std::endl;

    // Call function frequently in a vanilla way.
    // The compiler knows what function to call at compile time and can optimize
    // the code.
    // This is the best performance we could get.
    std::chrono::steady_clock::time_point const time_start_vanilla{
        std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        output_vector.at(i) = add_one(input_vector.at(i));
    }
    std::chrono::steady_clock::time_point const time_end_vanilla{
        std::chrono::steady_clock::now()};
    auto const time_elapsed_vanilla{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(time_end_vanilla -
                                                             time_start_vanilla)
            .count()};
    float const latency_vanilla{time_elapsed_vanilla /
                                static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass Vanilla: &amp;quot; &amp;lt;&amp;lt; latency_vanilla &amp;lt;&amp;lt; &amp;quot; ns&amp;quot;
              &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector

## 正文
// 時々、コンパイル時に呼び出す関数を知らない場合があります。
// `std::function` を使用して、関数を引数として渡すことができます。
// この場合は、`std::function` を値で渡します。
// `std::function` のサイズが 32 バイトであるため、値を渡すと多くのコピーが発生し、パフォーマンスが悪くなります。
std::chrono::steady_clock::time_point const
    time_start_pass_by_std_function_value{std::chrono::steady_clock::now()};
for (size_t i{0}; i &amp;lt; num_elements; ++i)
{
    unitary_function_pass_by_std_function_value(
        output_vector.at(i), input_vector.at(i), std_function_add_one);
}
std::chrono::steady_clock::time_point const
    time_end_pass_by_std_function_value{std::chrono::steady_clock::now()};
auto const time_elapsed_pass_by_std_function_value{
    std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
        time_end_pass_by_std_function_value -
        time_start_pass_by_std_function_value)
        .count()};
float const latency_pass_by_std_function_value{
    time_elapsed_pass_by_std_function_value /
    static_cast&amp;lt;float&amp;gt;(num_elements)};
std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Std Function Value: &amp;quot;
          &amp;lt;&amp;lt; latency_pass_by_std_function_value &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
assert(validate_vector_add_one(input_vector, output_vector));
reset_vector(output_vector);

// `std::function` を値で渡す代わりに、参照（ポインタ）で渡すこともできます。
// この場合、オブジェクトのコピーは排除されます。パフォーマンスは、`std::function` を値で渡した場合よりも優れています。
// ただし、ワイルドな方法ほどではありません。
std::chrono::steady_clock::time_point const
    time_start_pass_by_std_function_reference{
        std::chrono::steady_clock::now()};
for (size_t i{0}; i &amp;lt; num_elements; ++i)
{
    unitary_function_pass_by_std_function_reference(
        output_vector.at(i), input_vector.at(i), std_function_add_one);
}
std::chrono::steady_clock::time_point const
    time_end_pass_by_std_function_reference{
        std::chrono::steady_clock::now()};
auto const time_elapsed_pass_by_std_function_reference{
    std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
        time_end_pass_by_std_function_reference -
        time_start_pass_by_std_function_reference)
        .count()};
float const latency_pass_by_std_function_reference{
    time_elapsed_pass_by_std_function_reference /
    static_cast&amp;lt;float&amp;gt;(num_elements)};
std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Std Function Reference: &amp;quot;
          &amp;lt;&amp;lt; latency_pass_by_std_function_reference &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
assert(validate_vector_add_one(input_vector, output_vector));
reset_vector(output_vector);

## 本文
// `std::function` は、関数ポインタ、呼び出し可能オブジェクト、ラムダ関数をラップする汎用的なものです。
// 汎用性があるため、関数ポインタほど効率的ではありません。この場合は、関数ポインタを関数に渡します。
// `std::function` を参照で渡すよりもパフォーマンスが優れています。
std::chrono::steady_clock::time_point const time_start_pass_by_function_pointer{std::chrono::steady_clock::now()};
for (size_t i{0}; i &amp;lt; num_elements; ++i)
{
    unitary_function_pass_by_function_pointer(output_vector.at(i),
                                                  input_vector.at(i), &amp;amp;add_one);
}
std::chrono::steady_clock::time_point const time_end_pass_by_function_pointer{std::chrono::steady_clock::now()};
auto const time_elapsed_pass_by_function_pointer{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_function_pointer -
            time_start_pass_by_function_pointer)
            .count()};
float const latency_pass_by_function_pointer{
        time_elapsed_pass_by_function_pointer /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Function Pointer: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_function_pointer &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
assert(validate_vector_add_one(input_vector, output_vector));
reset_vector(output_vector);

// ラムダ関数を関数に渡すこともできます。
// コンパイラは、コンパイル時に呼び出す関数を知っており、コードを最適化できます。
// `std::function` を参照で渡すよりもパフォーマンスも優れています。
std::chrono::steady_clock::time_point const time_start_pass_by_lambda_function{std::chrono::steady_clock::now()};
for (size_t i{0}; i &amp;lt; num_elements; ++i)
{
    unitary_function_pass_by_lambda_function(
        output_vector.at(i), input_vector.at(i), lambda_function_add_one);
}
std::chrono::steady_clock::time_point const time_end_pass_by_lambda_function{std::chrono::steady_clock::now()};
auto const time_elapsed_pass_by_lambda_function{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_lambda_function -
            time_start_pass_by_lambda_function)
            .count()};
float const latency_pass_by_lambda_function{
        time_elapsed_pass_by_lambda_function /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Lambda Function: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_lambda_function &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
assert(validate_vector_add_one(input_vector, output_vector));
reset_vector(output_vector);

## 本文

```shell
# チーム全体の最適化 (O2) を有効にし、コンパイルには gcc13 を選択しました。gcc のバージョンが異なる場合、性能と時間の違いはわずかに異なりますが、バージョンが高いほど lambda の効果が良いです。
関数のポインタのサイズ: 8 バイト
std::function ポインタのサイズ: 8 バイト
std::function オブジェクトのサイズ: 32 バイト
Vanilla パスのレイテンシ: 0.418 ns
std::function 値でパスするレイテンシ: 3.47 ns
std::function リファレンスでパスするレイテンシ: 1.36 ns
ポインタで関数をパスするレイテンシ: 0.396 ns
ラムダ関数でパスするレイテンシ: 0.44 ns
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leimao.github.io/blog/CPP-Function-Call-Performance/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://leimao.github.io/blog/CPP-Function-Call-Performance/&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>プログラムのデバッグを防止する方法</title>
        <link>https://ttf248.life/ja/p/program-anti-debug/</link>
        <pubDate>Tue, 23 Jan 2024 19:46:36 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/program-anti-debug/</guid>
        <description>&lt;p&gt;心血を注ぎ、新しい壁紙を探し求めた。習慣は黒系の壁紙だが、一部の領域には色を加えても良いだろう。デスクトップにはアイコンを配置する必要があるため、他の色系が壁紙だとアイコンが不明瞭になってしまう。&lt;/p&gt;
&lt;p&gt;上記のコードを睨めつけ、理解できずにいた。AIに投げかけて説明したが、状況を説明していなかったのだ。それは特定の状況下で使われる指示であり、通常のコードではこのような形ではない。&lt;/p&gt;
&lt;p&gt;AIは今や検索エンジンには及ばない。アセンブリの知識が不足している。&lt;/p&gt;
&lt;h2 id=&#34;壁紙&#34;&gt;壁紙
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/program-anti-debug/Snipaste_2024-01-23_19-50-53.png&#34;
	width=&#34;1020&#34;
	height=&#34;470&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;黒色のアセンブル壁紙&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;217&#34;
		data-flex-basis=&#34;520px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;彙集コード&#34;&gt;彙集コード
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;PUSHFD
MOV DWORD PTR [ESP],0X100
POPFD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;実用例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool IsDebugged()
{
    __try
    {
        __asm
        {
            pushfd
            mov dword ptr [esp], 0x100
            popfd
            nop
        }
        return true;
    }
    __except(GetExceptionCode() == EXCEPTION_SINGLE_STEP
        ? EXCEPTION_EXECUTE_HANDLER
        : EXCEPTION_CONTINUE_EXECUTION)
    {
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;彙編コード&#34;&gt;彙編コード
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;PUSHFD&lt;/code&gt; および &lt;code&gt;POPFD&lt;/code&gt; は、フラグレジスタの値をスタックにプッシュおよびポップする命令です。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MOV DWORD PTR [ESP], 0X100&lt;/code&gt; は、スタックポインタ (&lt;code&gt;ESP&lt;/code&gt;) のアドレスにある4バイト（DWORD）領域に &lt;code&gt;0x100&lt;/code&gt; の値を移動する命令です。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nop&lt;/code&gt; は、何もしない命令です。デバッグやテストのために使用されることがあります。&lt;/p&gt;
&lt;h3 id=&#34;実用例&#34;&gt;実用例
&lt;/h3&gt;&lt;p&gt;このコードは、デバッグモードでプログラムが実行されているかどうかを判断します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;__try&lt;/code&gt; ブロック内でアセンブリコードを実行し、例外が発生した場合に &lt;code&gt;__except&lt;/code&gt; ブロックが実行されます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GetExceptionCode() == EXCEPTION_SINGLE_STEP&lt;/code&gt; は、プログラムがシングルステップモードで実行されているかどうかを確認します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;EXCEPTION_EXECUTE_HANDLER&lt;/code&gt; および &lt;code&gt;EXCEPTION_CONTINUE_EXECUTION&lt;/code&gt; は、それぞれハンドラを実行するか、実行の継続を許可する例外コードです。&lt;/p&gt;
&lt;p&gt;この例では、プログラムがシングルステップモードで実行されている場合、&lt;code&gt;true&lt;/code&gt; が返されます。それ以外の場合は、&lt;code&gt;false&lt;/code&gt; が返されます。&lt;/p&gt;
&lt;h2 id=&#34;説明&#34;&gt;説明
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;TrapFlag&lt;/code&gt;はレジスタフラグ領域内のフラグであり、このフラグが設定されると、&lt;code&gt;SINGLE_STEP&lt;/code&gt;例外が発生します。なぜなら、デバッガーでコードをトレースしている場合、このフラグはデバッガーによってリセットされ、その例外を捕捉できないからです。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;実際のテストでは、直接ステップオーバーしてデバッグ対象の関数を実行すると、デバッグが検出されないことがわかります。例外は、その関数にエントリする実行時のみ検出されます（資料参照、未検証）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献
&lt;/h2&gt;&lt;p&gt;中国語の関連資料は、すべてウェブサイトの英文稿を翻訳したものです。このサイトでは、さまざまな反调试技術について解説しています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://anti-debug.checkpoint.com/techniques/assembly.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://anti-debug.checkpoint.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://song-10.gitee.io/2021/08/08/Reverse-2021-08-08-anti-debug/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://song-10.gitee.io/2021/08/08/Reverse-2021-08-08-anti-debug/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>焦点访談/CCTV動画ファイルのダウンロード方法</title>
        <link>https://ttf248.life/ja/p/how-to-download-focus-interview-cctv-videos/</link>
        <pubDate>Tue, 23 Jan 2024 19:23:35 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/how-to-download-focus-interview-cctv-videos/</guid>
        <description>&lt;p&gt;最近、有人相談してきて、焦点访谈の動画をダウンロードする方法を聞かれたんだけど、頭の中で考えていたのは、おそらくまた &lt;code&gt;m3u8&lt;/code&gt; 形式で暗号化されているだろうという考えだったんだ。ちょっと手軽に処理してみようか。&lt;/p&gt;
&lt;h2 id=&#34;ダウンローダー&#34;&gt;ダウンローダー
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/nilaoda/N_m3u8DL-CLI&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/nilaoda/N_m3u8DL-CLI&lt;/a&gt;
&lt;code&gt;m3u8 downloader&lt;/code&gt; のオープンソース 命令行 m3u8/HLS/dash ダウンローダーです。普通 AES-128-CBC 解密、マルチスレッド、カスタムリクエストヘッダなどをサポートしています。简体中文、繁体中文、英語に対応しています。English Supported.&lt;/p&gt;
&lt;h2 id=&#34;ブラウザ拡張機能&#34;&gt;ブラウザ拡張機能
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://microsoftedge.microsoft.com/addons/detail/ngjclnbcdbahekojpkhancmiobdahemb&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Live Stream Downloader&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;蜜汁自信&#34;&gt;蜜汁自信
&lt;/h2&gt;&lt;p&gt;アドレスを取得し、これで片付くと思ったが、結果は何もかも役に立たない。正常にセグメント内容を解析したり、資料を検索したりすることができなかった。公式がダウンロードアドレスを処理しており、ある程度の置換を手動で行う必要があることを発見した。プラグインで解析された &lt;code&gt;key&lt;/code&gt; を以下のリンクに手動でコピー＆置き換えなければならない。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;https://newcntv.qcloudcdn.com/asp/hls/2000/0303000a/3/default/***********************/2000.m3u8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2024年1月現在、アドレスは有効。今後変更がある場合は、ウェブページを分析してご自身で判断してください。
過去のアドレスのバックアップ：&lt;code&gt;https://hlswx.cntv.kcdnvip.com/asp/hls/main/0303000a/3/default/一串字符/main.m3u8?maxbr=2000&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://jln.cn/post/517.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://jln.cn/post/517.html&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>SQL Serverデータベースのディスクファイルの権限を一括で変更する</title>
        <link>https://ttf248.life/ja/p/bulk-modify-sqlserver-database-disk-permissions/</link>
        <pubDate>Tue, 23 Jan 2024 19:06:36 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/bulk-modify-sqlserver-database-disk-permissions/</guid>
        <description>&lt;p&gt;会社セキュリティポリシーの調整により、&lt;code&gt;機械師 mini&lt;/code&gt;は最終的に自宅へ移転し、予備サーバーとして利用。同時にマシンシステムを再インストールし、&lt;code&gt;ubuntu&lt;/code&gt;が&lt;code&gt;windows server&lt;/code&gt;に切り替えられました。アクティベーション手段が不正であったため、自宅で使用しても問題ないように見えていましたが、実際にはアクティベーションができていないと様子がおかしくなりました。&lt;/p&gt;
&lt;p&gt;Microsoftによる検出がトリガーされ、通常稼働していたサーバーが起動から1時間で自動シャットダウン。システムログを徹底的に調査した結果、盗版であることに至りました。&lt;/p&gt;
&lt;p&gt;仕方なく再度システムを再インストールし、&lt;code&gt;SqlServer&lt;/code&gt;も再インストールする必要が生じました。毎回トラブルシューティングを行うと非常に面倒であり、ファイル権限管理が厳格であるため、データベースの追加が正常に行えませんでした。&lt;/p&gt;
&lt;h2 id=&#34;エラーメッセージ&#34;&gt;エラーメッセージ
&lt;/h2&gt;&lt;p&gt;システムを再インストールした後、&lt;code&gt;SqlServer&lt;/code&gt;がデータベースに接続しようとすると、オペレーティングシステムのアクセス拒否エラー5120が発生することがあります。&lt;/p&gt;
&lt;h2 id=&#34;処理スクリプト&#34;&gt;処理スクリプト
&lt;/h2&gt;&lt;p&gt;前文リンク：&lt;a class=&#34;link&#34; href=&#34;https://ttf248.life/ja/p/bulk-update-local-git-and-legacy-permissions/&#34; &gt;ローカルGitリポジトリの一括更新&lt;/a&gt;、やはりこの馴染み深いスクリプトだ。改造して、フォルダをトラバースしながらファイルの権限を変更し、現在のユーザーに完全な編集権限を与えるようにする。&lt;/p&gt;
&lt;p&gt;ネット上のチュートリアルはほとんどが手動で修正する方法を示しており、毎回数個のファイルだけ修正するのだろうか？ 私は毎回多数のファイルを処理する必要があり、すべてを手作業で処理すると、精神的に疲れてしまう。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$currentUserName = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8
$rootDirectory = &amp;quot;D:\data\2013_RujiaInfo&amp;quot;

Get-ChildItem -Path $rootDirectory -Recurse | ForEach-Object {
    $itemPath = $_.FullName

    if ($_ -is [System.IO.DirectoryInfo]) {
        $icaclsResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            Write-Host &amp;quot;フォルダ $itemPath の所有者を $currentUserName に変更しました&amp;quot;
            # 現在のユーザーに書き込み権限を付与
            Invoke-Expression &amp;quot;icacls `&amp;quot;$itemPath`&amp;quot; /grant `&amp;quot;$($currentUserName):(OI)(CI)F`&amp;quot;&amp;quot;
            Write-Host &amp;quot;$currentUserName がフォルダを編集するための権限が付与されました&amp;quot;
        } else {
            Write-Host &amp;quot;フォルダ $itemPath の所有者を変更できません。エラー情報: $icaclsResult&amp;quot;
        }
    } else {
        $takeownResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            # 現在のユーザーに書き込み権限を付与
            Invoke-Expression &amp;quot;icacls `&amp;quot;$itemPath`&amp;quot; /grant `&amp;quot;$($currentUserName):(F)`&amp;quot;&amp;quot;
            Write-Host &amp;quot;$currentUserName がファイルを編集するための権限が付与されました&amp;quot;
        } else {
            Write-Host &amp;quot;ファイル $itemPath の所有者を変更できません。エラー情報: $takeownResult&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Linuxシステムベンチマークテスト</title>
        <link>https://ttf248.life/ja/p/linux-system-benchmark-test/</link>
        <pubDate>Tue, 09 Jan 2024 10:56:23 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-system-benchmark-test/</guid>
        <description>&lt;p&gt;Windows 平台上有鲁大师（娱乐大师），不能说数据很准，但总归有个参考，当然也有其他的专业跑分软件。到了 Linux 系统，好像一直没遇到特别合适的跑分软件。&lt;/p&gt;
&lt;p&gt;Sysbench 是一款多功能的基准测试工具，可用于测试 CPU、内存、文件 I/O、线程性能等。您可以使用 Sysbench 来执行各种性能测试任务。&lt;/p&gt;
&lt;p&gt;手头上刚好有三台机器用于测试：机械师 mini 本地小主机、阿里云 dev 开发云服务器、华为云开发服务器。&lt;/p&gt;
&lt;h2 id=&#34;sysbench-のインストール&#34;&gt;Sysbench のインストール
&lt;/h2&gt;&lt;p&gt;ほとんどの Linux ディストリビューションでは、パッケージマネージャを使用して Sysbench をインストールできます。例えば、CentOS 8 では、次のコマンドを使用します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo dnf install sysbench
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sysbenchの使用例&#34;&gt;Sysbenchの使用例
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CPU性能のテスト: &lt;code&gt;sysbench --test=cpu run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;メモリ読み取り性能のテスト: &lt;code&gt;sysbench --test=memory run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ファイルI/O性能のテスト:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysbench --test=fileio --file-test-mode=rndrw prepare
sysbench --test=fileio --file-test-mode=rndrw run
sysbench --test=fileio --file-test-mode=rndrw cleanup
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;マルチスレッド性能のテスト: &lt;code&gt;sysbench --test=threads --num-threads=4 run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;MySQLデータベース性能のテスト（最大接続数を調整する必要あり）：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword --oltp-table-size=1000000 prepare
sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword --max-time=60 --oltp-read-only=off --oltp-test-mode=complex --max-requests=0 run
sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword cleanup
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ランニングデータレポート&#34;&gt;ランニングデータレポート
&lt;/h2&gt;&lt;meta http-equiv=&#34;Content-Type&#34; content=&#34;text/html; charset=utf-8&#34;&gt;&lt;link type=&#34;text/css&#34; rel=&#34;stylesheet&#34; href=&#34;resources/sheet.css&#34; &gt;
&lt;h2 id=&#34;実行データレポート&#34;&gt;実行データレポート
&lt;/h2&gt;&lt;style type=&#34;text/css&#34;&gt;.ritz .waffle a { color: inherit; }.ritz .waffle .s0{background-color:#ffffff;text-align:left;color:#000000;font-family:&#39;Arial&#39;;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}&lt;/style&gt;&lt;div class=&#34;ritz grid-container&#34; dir=&#34;ltr&#34;&gt;&lt;table class=&#34;waffle&#34; cellspacing=&#34;0&#34; cellpadding=&#34;0&#34;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th class=&#34;row-header freezebar-origin-ltr&#34;&gt;&lt;/th&gt;&lt;th id=&#34;0C0&#34; style=&#34;width:100px;&#34; class=&#34;column-headers-background&#34;&gt;A&lt;/th&gt;&lt;th id=&#34;0C1&#34; style=&#34;width:421px;&#34; class=&#34;column-headers-background&#34;&gt;B&lt;/th&gt;&lt;th id=&#34;0C2&#34; style=&#34;width:398px;&#34; class=&#34;column-headers-background&#34;&gt;C&lt;/th&gt;&lt;th id=&#34;0C3&#34; style=&#34;width:422px;&#34; class=&#34;column-headers-background&#34;&gt;D&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R0&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;1&lt;/div&gt;&lt;/th&gt;&lt;td&gt;&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;ローカル機械師&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;阿里云&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;华为云&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R1&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;2&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;システム構成&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;システム情報&lt;br&gt;  オペレーティングシステム              Ubuntu 23.04&lt;br&gt;  カーネル                        Linux 6.2.0-36-generic x86_64&lt;br&gt;  モデル                         Machenike Machenike DT Computer&lt;br&gt;  マザーボード                   Machenike Machenike DT Computer&lt;br&gt;  BIOS                          American Megatrends International, LLC.&lt;br&gt;DB19V012&lt;br&gt;&lt;br&gt;CPU情報&lt;br&gt;  名前                          Intel Core i7-12650H&lt;br&gt;  トポロジー                      1 プロセッサ、10 コア、16 スレッド&lt;br&gt;  識別子                    GenuineIntel Family 6 Model 154 Stepping 3&lt;br&gt;  ベース周波数                4.60 GHz&lt;br&gt;  L1 命令キャッシュ          32.0 KB x 8&lt;br&gt;  L1 データキャッシュ                 48.0 KB x 8&lt;br&gt;  L2 キャッシュ                      1.25 MB x 2&lt;br&gt;  L3 キャッシュ                      24.0 MB&lt;br&gt;&lt;br&gt;メモリ情報&lt;br&gt;  サイズ                          62.6 GB&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;システム情報&lt;br&gt;  オペレーティングシステム              CentOS Stream 8&lt;br&gt;  カーネル                        Linux 4.18.0-513.el8.x86_64 x86_64&lt;br&gt;  モデル                         Alibaba Cloud Alibaba Cloud ECS&lt;br&gt;  マザーボード                   N/A&lt;br&gt;  BIOS                          SeaBIOS 449e491&lt;br&gt;&lt;br&gt;CPU情報&lt;br&gt;  名前                          Intel(R) Xeon(R) Platinum&lt;br&gt;  トポロジー                      1 プロセッサ、1 コア、2 スレッド&lt;br&gt;  識別子                    GenuineIntel Family 6 Model 85 Stepping 4&lt;br&gt;  ベース周波数                2.50 GHz&lt;br&gt;  L1 命令キャッシュ          32.0 KB&lt;br&gt;  L1 データキャッシュ                 32.0 KB&lt;br&gt;  L2 キャッシュ                      1.00 MB&lt;br&gt;  L3 キャッシュ                      33.0 MB&lt;br&gt;&lt;br&gt;メモリ情報&lt;br&gt;  サイズ                          1.65 GB&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;システム情報&lt;br&gt;  オペレーティングシステム              Ubuntu 22.04.1 LTS&lt;br&gt;  カーネル                        Linux 5. - 64 GB
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;実行データレポート
system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;テストの実行方法：指定されたオプションで&lt;br&gt;スレッド数: 1&lt;br&gt;乱数ジェネレーターを現在の時間から初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;素数の制限: 10000&lt;br&gt;&lt;br&gt;ワーカーのスレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドが開始されました!&lt;br&gt;&lt;br&gt;CPU速度:&lt;br&gt;    毎秒イベント数: 4032.48&lt;br&gt;&lt;br&gt;一般的な統計情報:&lt;br&gt;    合計時間: 10.0004秒&lt;br&gt;    イベントの総数: 40330&lt;br&gt;&lt;br&gt;遅延 (ms):&lt;br&gt;         最小値: 0.25&lt;br&gt;         平均値: 0.25&lt;br&gt;         最大値: 0.73&lt;br&gt;         95パーセンタイル: 0.25&lt;br&gt;         合計: 9997.55&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント (平均/標準偏差): 40330.0000/0.00&lt;br&gt;    実行時間 (平均/標準偏差): 9.9975/0.00&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;データマイニング&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ディープラーニング&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ニューラルネットワーク - 実行データレポート
system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;テストの実行方法：指定されたオプションで&lt;br&gt;スレッド数: 1&lt;br&gt;乱数ジェネレーターを現在の時間から初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;素数の制限: 10000&lt;br&gt;&lt;br&gt;ワーカーのスレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドが開始されました!&lt;br&gt;&lt;br&gt;CPU速度:&lt;br&gt;    毎秒イベント数: 4032.48&lt;br&gt;&lt;br&gt;一般的な統計情報:&lt;br&gt;    合計時間: 10.0004秒&lt;br&gt;    合計イベント数: 40330&lt;br&gt;&lt;br&gt;遅延 (ms):&lt;br&gt;         最小: 0.25&lt;br&gt;         平均: 0.25&lt;br&gt;         最大: 0.73&lt;br&gt;         95パーセンタイル: 0.25&lt;br&gt;         合計: 9997.55&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント (平均/標準偏差): 40330.0000/0.00&lt;br&gt;    実行時間 (平均/標準偏差): 9.9975/0.00&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sysbench 1.0.20 (system LuaJIT 2.1.0-beta3を使用)&lt;br&gt;&lt;br&gt;テストの実行方法：指定されたオプションで&lt;br&gt;スレッド数: 1&lt;br&gt;乱数ジェネレーターを現在の時間から初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;素数の制限: 10000&lt;br&gt;&lt;br&gt;ワーカーのスレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドが開始されました!&lt;br&gt;&lt;br&gt;CPU速度:&lt;br&gt;    毎秒イベント数: 1062.51&lt;br&gt;&lt;br&gt;一般的な統計情報:&lt;br&gt;    合計時間: 10.0008秒&lt;br&gt;    合計イベント数: 10628&lt;br&gt;&lt;br&gt;遅延 (ms):&lt;br&gt;         最小: 0.91&lt;br&gt;         平均: 0.94&lt;br&gt;         最大: 22.84&lt;br&gt;         95パーセンタイル: 1.06&lt;br&gt;         合計: 9993.46&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント (平均/標準偏差): 10628.0000/0.00&lt;br&gt;    実行時間 (平均/標準偏差): 9.9935/0.00&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sysbench 1.0.20 (system LuaJIT 2.1.0-beta3を使用)&lt;br&gt;&lt;br&gt;テストの実行方法：指定されたオプションで&lt;br&gt;スレッド数: 1&lt;br&gt;乱数ジェネレーターを現在の時間から初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;素数の制限: 10000&lt;br&gt;&lt;br&gt;ワーカーのスレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドが開始されました!&lt;br&gt;&lt;br&gt;CPU速度:&lt;br&gt;    毎秒イベント数: 1125.56&lt;br&gt;&lt;br&gt;一般的な統計情報:&lt;br&gt;    合計時間: 10.0005秒&lt;br&gt;    合計イベント数: 11258&lt;br&gt;&lt;br&gt;遅延 (ms):&lt;br&gt;         最小: 0.86&lt;br&gt;         平均: 0.89&lt;br&gt;         最大: 1.70&lt;br&gt;         95パーセンタイル: 0.99&lt;br&gt;         合計: 9995.40&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント (平均/標準偏差): 11258.0000/0.00&lt;br&gt;    実行時間 (平均/標準偏差): 9.9954/0.00&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;メモリテストを実行するオプション：指定されたオプションで&lt;br&gt;ブロックサイズ: 1KiB&lt;br&gt;合計サイズ: 102400MiB&lt;br&gt;操作: 書き込み&lt;br&gt;範囲: グローバル&lt;br&gt;&lt;br&gt;ワーカーのスレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドが開始されました!&lt;br&gt;&lt;br&gt;総イベント数: 101993199 (10198146.52/秒)&lt;br&gt;&amp;lt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ランダム数生成レポート&#34;&gt;ランダム数生成レポート
&lt;/h2&gt;&lt;p&gt;現在の時刻からの乱数ジェネレーター&lt;br&gt;&lt;br&gt;&lt;br&gt;次のオプションでメモリ速度テストを実行中:&lt;br&gt;  ブロックサイズ：1KiB&lt;br&gt;  合計サイズ：102400MiB&lt;br&gt;  操作：書き込み&lt;br&gt;  範囲：グローバル&lt;br&gt;&lt;br&gt;ワーカースレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッド開始!&lt;br&gt;&lt;br&gt;総操作数：48418803 (1秒あたり4841004.79)&lt;br&gt;&lt;br&gt;転送されたデータ：47283.99 MiB (1秒あたり4727.54 MiB)&lt;br&gt;&lt;br&gt;&lt;br&gt;一般的な統計:&lt;br&gt;    合計時間：                          10.0001s&lt;br&gt;    イベント総数：              48418803&lt;br&gt;&lt;br&gt;レイテンシ（ms）：&lt;br&gt;         最小：                                    0.00&lt;br&gt;         平均：                                    0.00&lt;br&gt;         最大：                                   25.26&lt;br&gt;         95パーセンタイル：                        0.00&lt;br&gt;         合計：                                 4578.95&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント（平均/標準偏差）：           48418803.0000/0.00&lt;br&gt;    実行時間（平均/標準偏差）：   4.5789/0.00&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;ランニングテストで次のオプションを使用中：&lt;br&gt;スレッド数：1&lt;br&gt;現在の時刻からの乱数ジェネレーターの初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;追加ファイルオープンフラグ：（なし）&lt;br&gt;128ファイル、各16MiB&lt;br&gt;2GiBの合計ファイルサイズ&lt;br&gt;ブロックサイズ 16KiB&lt;br&gt;IOリクエスト数：0&lt;br&gt;組み合わせてランダムIOテストの読み取り/書き込み比率：1.50&lt;br&gt;定期的なFSYNCが有効になっており、各100リクエストごとにfsync()を呼び出しています。&lt;br&gt;テストの最後にfsync()を呼び出すことが有効になっています。&lt;br&gt;同期I/Oモードを使用&lt;br&gt;ランダムな読み取り/書き込みテストを実行中&lt;br&gt;ワーカースレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッド開始!&lt;br&gt;&lt;br&gt;&lt;br&gt;ファイル操作：&lt;br&gt;    読み取り/秒：                      3373.41&lt;br&gt;    書き込み/秒：                     2248.94&lt;br&gt;    fsync/秒：                     7201.80&lt;br&gt;&lt;br&gt;スループット：&lt;br&gt;    読み取り、MiB/s：                  52.71&lt;br&gt;    書き込み、MiB/s：               35.14&lt;br&gt;&lt;br&gt;一般的な統計：&lt;br&gt;    合計時間：                          10.0127s&lt;br&gt;    イベント総数：              128288&lt;br&gt;&lt;br&gt;レイテンシ（ms）：&lt;br&gt;         最小：                                    0.00&lt;br&gt;         平均：                                    0.08&lt;br&gt;         最大：                                    5.14&lt;br&gt;         95パーセンタイル：                        0.34&lt;br&gt;         合計：                                 9977.78&lt;br&gt;&lt;br&gt;スレッドの公平性：&lt;br&gt;    イベント（平均/標準偏差）：           128288.0000/0.00&lt;br&gt;    実行時間（平均/標準偏差）：   9.9778/0.00&lt;/p&gt;
&lt;p&gt;スループット：&lt;br&gt;    読み取り、MiB/s：                  52.71&lt;br&gt;    書き込み、MiB/s：               35.14&lt;br&gt;&lt;br&gt;一般的な統計：&lt;br&gt;    合計時間：                          10.0127s&lt;br&gt;    イベント総数：              128288&lt;br&gt;&lt;br&gt;レイテンシ（ms）：&lt;br&gt;         最小：                                    0.00&lt;br&gt;         平均：                                    0.08&lt;br&gt;         最大：                                    5.14&lt;br&gt;         95パーセンタイル：                        0.34&lt;br&gt;         合計：                                 9977.78&lt;br&gt;&lt;br&gt;スレッドの公平性：&lt;br&gt;    イベント（平均/標準 ## ランダム数生成データレポート
現在の時刻からの乱数ジェネレーター&lt;br&gt;&lt;br&gt;&lt;br&gt;次のオプションでメモリ速度テストを実行中:&lt;br&gt;  ブロックサイズ：1KiB&lt;br&gt;  合計サイズ：102400MiB&lt;br&gt;  操作：書き込み&lt;br&gt;  範囲：グローバル&lt;br&gt;&lt;br&gt;ワーカースレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッド開始!&lt;br&gt;&lt;br&gt;総操作数：48418803 (1秒あたり4841004.79)&lt;br&gt;&lt;br&gt;転送されたデータ：47283.99 MiB (1秒あたり4727.54 MiB)&lt;br&gt;&lt;br&gt;&lt;br&gt;一般的な統計:&lt;br&gt;    合計時間：                          10.0001s&lt;br&gt;    イベント総数：              48418803&lt;br&gt;&lt;br&gt;遅延（ms）：&lt;br&gt;         最小：                                    0.00&lt;br&gt;         平均：                                    0.00&lt;br&gt;         最大：                                   25.26&lt;br&gt;         95パーセンタイル：                        0.00&lt;br&gt;         合計：                                 4578.95&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント（平均/標準偏差）：           48418803.0000/0.00&lt;br&gt;    実行時間（平均/標準偏差）：   4.5789/0.00&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;テストオプションで実行中:&lt;br&gt;スレッド数：1&lt;br&gt;現在の時刻からの乱数ジェネレーターの初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;追加ファイルオープンフラグ：（なし）&lt;br&gt;128ファイル、各16MiB&lt;br&gt;2GiBの合計ファイルサイズ&lt;br&gt;ブロックサイズ 16KiB&lt;br&gt;IOリクエスト数：0&lt;br&gt;組み合わせてランダムIOテストの読み取り/書き込み比率：1.50&lt;br&gt;定期的なFSYNCが有効になり、各100リクエストごとにfsync()が呼び出されます。&lt;br&gt;テストの終了時にfsync()を呼び出す。有効になっています。&lt;br&gt;同期I/Oモードを使用&lt;br&gt;ランダムな読み取り/書き込みテストを実行中&lt;br&gt;ワーカースレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッド開始!&lt;br&gt;&lt;br&gt;&lt;br&gt;ファイル操作:&lt;br&gt;    読み取り/秒：                      3373.41&lt;br&gt;    書き込み/秒：                     2248.94&lt;br&gt;    fsync/秒：                     7201.80&lt;br&gt;&lt;br&gt;スループット:&lt;br&gt;    読み取り、MiB/s：                  52.71&lt;br&gt;    書き込み、MiB/s：               35.14&lt;br&gt;&lt;br&gt;一般的な統計:&lt;br&gt;    合計時間：                          10.0127s&lt;br&gt;    イベント総数：              128288&lt;br&gt;&lt;br&gt;遅延（ms）：&lt;br&gt;         最小：                                    0.00&lt;br&gt;         平均：                                    0.08&lt;br&gt;         最大：                                    5.14&lt;br&gt;         95パーセンタイル：                        0.34&lt;br&gt;         合計：                                 9977.78&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント（平均/標準偏差）：           128288.0000/0.00&lt;br&gt;    実行時間（平均/標準偏差）：   9.9778/0.00&lt;/p&gt;
&lt;p&gt;スループット：
読み取り、MiB/s： 52.71
書き込み、MiB/s： 35.14&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;ディスク: 2147483648 バイトを 1.81 秒で書き込みました (1129.59 MiB/秒)。&lt;br&gt;&lt;br&gt;テストオプションで実行中:&lt;br&gt;スレッド数：1&lt;br&gt;現在の時刻からの乱数ジェネレーターの初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;追加ファイルオープンフラグ：（なし）&lt;br&gt;128ファイル、各16MiB&lt;br&gt;2GiBの合計ファイルサイズ&lt;br&gt;ブロックサイズ 16KiB&lt;br&gt;IOリクエスト数：0&lt;br&gt;組み合わせてランダムIOテストの読み取り/書き込み比率：1.&lt;/p&gt;
&lt;h2 id=&#34;実行データレポート-1&#34;&gt;実行データレポート
&lt;/h2&gt;&lt;p&gt;enabled, 各100リクエストごとにfsync()を呼び出す。&lt;br&gt;テストの終了時にfsync()を呼び出し、有効化。&lt;br&gt;同期I/Oモードを使用中&lt;br&gt;ランダムなr/wテストを実行中&lt;br&gt;ワーカースレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドが開始されました!&lt;br&gt;&lt;br&gt;&lt;br&gt;ファイル操作:&lt;br&gt;    読み込み/秒:                      1593.12&lt;br&gt;    書き込み/秒:                     1062.08&lt;br&gt;    fsync/秒:                     3406.64&lt;br&gt;&lt;br&gt;帯域幅:&lt;br&gt;    読み取り (MiB/s):                  24.89&lt;br&gt;    書き込み (MiB/s):               16.60&lt;br&gt;&lt;br&gt;一般的な統計:&lt;br&gt;    合計時間:                          10.0164秒&lt;br&gt;    イベント総数:              60600&lt;br&gt;&lt;br&gt;レイテンシ (ms):&lt;br&gt;         最小:                                    0.00&lt;br&gt;         平均:                                    0.16&lt;br&gt;         最大:                                   31.32&lt;br&gt;         95パーセンタイル:                        0.54&lt;br&gt;         合計:                                 9956.30&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント (平均/標準偏差):           60600.0000/0.00&lt;br&gt;    実行時間 (平均/標準偏差):   9.9563/0.00&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;2147483648 バイトを 18.29 秒で書き込みました (111.98 MiB/秒)。&lt;br&gt;&lt;br&gt;以下のオプションでテストを実行中:&lt;br&gt;スレッド数: 1&lt;br&gt;現在の時刻から乱数ジェネレーターを初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;追加のファイルオープンフラグ:(なし)&lt;br&gt;128 ファイル、各 16MiB&lt;br&gt;2GiB の合計ファイルサイズ&lt;br&gt;ブロックサイズ 16KiB&lt;br&gt;IO リクエスト数: 0&lt;br&gt;ランダムな IO テストの読み取り/書き込み比率: 1.50&lt;br&gt;定期的な FS INC を有効にし、各 100 リクエストごとに fsync() を呼び出す。&lt;br&gt;テストの終了時に fsync() を呼び出し、有効化。&lt;br&gt;同期 I/O モードを使用中&lt;br&gt;ランダムな r/w テストを実行中&lt;br&gt;ワーカースレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドが開始されました!&lt;br&gt;&lt;br&gt;&lt;br&gt;ファイル操作:&lt;br&gt;    読み込み/秒:                      1665.88&lt;br&gt;    書き込み/秒:                     1110.59&lt;br&gt;    fsync/秒:                     3563.77&lt;br&gt;&lt;br&gt;帯域幅:&lt;br&gt;    読み取り (MiB/s):                  26.03&lt;br&gt;    書き込み (MiB/s):               17.35&lt;br&gt;&lt;br&gt;一般的な統計:&lt;br&gt;    合計時間:                          10.0112秒&lt;br&gt;    イベント総数:              63355&lt;br&gt;&lt;br&gt;レイテンシ (ms):&lt;br&gt;         最小:                                    0.00&lt;br&gt;         平均:                                    0.16&lt;br&gt;         最大:                                  205.01&lt;br&gt;         95パーセンタイル:                        0.78&lt;br&gt;         合計:                                 9972.64&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント (平均/標準偏差):           63355.0000/0.00&lt;br&gt;    実行時間 (平均/標準偏差):   9.9726/0.00&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;スレッド数: 4
初期化されたランダムな数値ジェネレーターから現在の時刻を初期化&amp;hellip;&lt;br&gt;&lt;br&gt;ワーカースレッドが開始されました!&lt;br&gt;&lt;br&gt;&lt;br&gt;一般的な統計:&lt;br&gt;    合計時間:                          10.0002秒&lt;br&gt;    イベント総数:              197956&lt;br&gt;&lt;br&gt;レイテンシ (ms):&lt;br&gt;         最小:                                    0.16&lt;br&gt;         平均:                                    0.20&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;実行結果レポート&#34;&gt;実行結果レポート
&lt;/h2&gt;&lt;p&gt;合計: 40050.41&lt;br&gt;&lt;br&gt;スレッド公平性:&lt;br&gt;  イベント (平均/標準偏差): 4590.0000/94.36&lt;br&gt;  実行時間 (平均/標準偏差): 10.0126/0.00&lt;/p&gt;
&lt;p&gt;テスト実行時のオプション:
スレッド数: 4
現在の時刻から乱数生成器を初期化
&lt;br&gt;&lt;br&gt;&lt;br&gt;ワーカースレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;
スレッド起動!&lt;br&gt;&lt;br&gt;&lt;br&gt;
一般統計:
合計時間: 10.0004秒
合計イベント数: 28536&lt;br&gt;&lt;br&gt;遅延 (ms):
最小: 0.23
平均: 1.40
最大: 3.56
95パーセンタイル: 1.47
合計: 39975.16&lt;br&gt;&lt;br&gt;スレッド公平性:
イベント (平均/標準偏差): 7134.0000/39.87
実行時間 (平均/標準偏差): 9.9938/0.01&lt;/p&gt;
&lt;h2 id=&#34;追記&#34;&gt;追記
&lt;/h2&gt;&lt;p&gt;ChatGPTは依然として優れたものですが、以前習得していたMarkdownで完全にテーブルを作成できず、テーブルとして表示すると効果が著しく低下します。カスタムテーマによってページの最大幅が制限されるため、幅を百分率制に調整しました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;簡単な方法としては、TablesGeneratorのようなオンラインツールを使用してHTMLテーブルを生成する方法がありますが（内容が複雑だと不向きです）。&lt;/li&gt;
&lt;li&gt;または、Googleドキュメントで作成し、HTMLドキュメントとしてダウンロードして保存し、ブログに直接コピーする方法を採用しました（シンプルかつ直接的です）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;configの設定でunsafeな設定項目を有効にし、ページごとの幅設定を個別に指定するようにしてください。Hugoでは、ページごとに個別に幅を設定できます。これは、ページのFront Matterにカスタムパラメータを追加することで実現できます。以下はその例です。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MarkdownファイルのFront Matterセクション（通常はファイルの冒頭部分）にカスタムパラメータ（例えば&lt;code&gt;custom_width&lt;/code&gt;）を追加します：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;---
title: &amp;quot;私のページ&amp;quot;
date: 2024-01-09
custom_width: &amp;quot;800px&amp;quot;  # 幅を800ピクセルに設定
---

本文内容...
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Hugoのテーマで、対応する単一ページテンプレートファイル（例えば&lt;code&gt;layouts/_default/single.html&lt;/code&gt;）を見つけてください。&lt;/li&gt;
&lt;li&gt;単一ページテンプレート内で、Front Matterに&lt;code&gt;custom_width&lt;/code&gt;パラメータが存在するか確認し、それを適切なHTML要素（例えば&lt;code&gt;div&lt;/code&gt;）に適用します：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{{ define &amp;quot;main&amp;quot; }}
  &amp;lt;div style=&amp;quot;max-width: {{ with .Params.custom_width }}{{ . }}{{ else }}100%{{ end }}; margin: 0 auto;&amp;quot;&amp;gt;
    {{ .Content }}
  &amp;lt;/div&amp;gt;
{{ end }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この例では、内联スタイル（&lt;code&gt;style&lt;/code&gt;属性）を使用して&lt;code&gt;div&lt;/code&gt;要素の&lt;code&gt;max-width&lt;/code&gt;属性を設定し、&lt;code&gt;custom_width&lt;/code&gt;パラメータが指定されていない場合、幅をデフォルトで100%にしています。&lt;code&gt;margin: 0 auto;&lt;/code&gt;は&lt;code&gt;div&lt;/code&gt;要素を中央揃えにします。&lt;/p&gt;
&lt;p&gt;実際のアプリケーションでは、テーマの構造やCSSスタイルの詳細に応じて、上記の例を調整する必要がある場合があります。スタイルを調整する際には、テーマの一貫性と可読性を維持するようにしてください。&lt;/p&gt;
&lt;p&gt;最後に、使用しているテーマが若干異なるため、サイト全体でカスタムCSSの設定も調整しました。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Git で HTTP リポジトリを無効にする</title>
        <link>https://ttf248.life/ja/p/git-disable-http-repositories/</link>
        <pubDate>Mon, 08 Jan 2024 21:22:04 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/git-disable-http-repositories/</guid>
        <description>&lt;p&gt;習慣更新ソフトウェアバージョンです。Gitのどのバージョンの場合にHTTPリポジトリからのコード取得が許可されないか不明ですが、以下のエラーが発生します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;fatal: Unencrypted HTTP is not supported for GitLab. Ensure the repository remote URL is using HTTPS
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;背景説明&#34;&gt;背景説明
&lt;/h2&gt;&lt;p&gt;環境：Windows 平台、これまで小烏龟を使ってgitを操作しており、鍵の認証も小烏龜で処理していました。以前、ローカルリポジトリを一括更新するスクリプトを作成したこともあります。&lt;/p&gt;
&lt;p&gt;前回の記事へのリンク：[ローカルGitリポジトリの一括更新](&amp;lt;{{ relref &amp;ldquo;/post/2023/10-19-批量更新本地git仓库&amp;rdquo; &amp;gt;})&lt;/p&gt;
&lt;p&gt;今日、帰宅してコードの更新を実行したところ、上記のエラーが発生し、リポジトリが正常に更新されなくなりました。&lt;code&gt;Git&lt;/code&gt;の設定でHTTPプロトコルを使用するように変更してみるのが妥当だと思って探しましたが、対応する設定項目は見つかりませんでした。&lt;/p&gt;
&lt;p&gt;最も簡単な解決策は、SSHプロトコルに変更してリポジトリを更新することです。会社側で設定している&lt;code&gt;gitlab&lt;/code&gt;は短期的にHTTPSプロトコルを提供しません。&lt;/p&gt;
&lt;h2 id=&#34;既存の問題&#34;&gt;既存の問題
&lt;/h2&gt;&lt;p&gt;以前、ローカルリポジトリをバッチ更新するためのスクリプトを作成する際に、&lt;code&gt;ssh&lt;/code&gt; を使ってリポジトリをプルすることを検討していたが、詳細を確認しなかった。小烏龟（TortoiseGit）で設定した &lt;code&gt;git&lt;/code&gt; 設定情報を config に同期していなかったため、コマンドラインから&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git pull # 権限がないために正常に更新できない
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;と表示された。&lt;/p&gt;
&lt;p&gt;SSH キーの確認コマンド (&lt;code&gt;ssh -T git@gitlab.yintech.net&lt;/code&gt;) を実行しても問題なく動作するため、小烏龟（TortoiseGit）でコードをプルできるのに、コマンドラインで &lt;code&gt;git pull&lt;/code&gt; コマンドを実行すると SSH キーが正しくないというエラーが表示される場合、小烏龟は PuTTY の SSH 鍵を使用しているのに対し、コマンドラインは OpenSSH の SSH 鍵を使用している可能性がある。&lt;/p&gt;
&lt;p&gt;小烏亀の秘钥設定は、システム &lt;code&gt;.ssh&lt;/code&gt; フォルダから秘钥ファイル情報を読み取らず、インターフェースでリポジトリ設定を行う際に、個別に秘钥ファイルのパスを設定する。このテクニックを利用すると、プルした最初のリポジトリの設定で秘钥を設定すれば、他のリポジトリも同じ秘钥ファイルを共有できる。PuTTY は秘钥をロードした後、すぐに終了せず、代理サービスを開始する。&lt;/p&gt;
&lt;p&gt;グローバル設定を調整し、システムデフォルトの &lt;code&gt;ssh&lt;/code&gt; 設定を使用しないようにすることで、Git Bash は TortoisePlink を使用して SSH 操作を実行するように構成する。この設定は、TortoiseGit に付属の PuTTY ツールを使用する場合に適している。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global core.sshCommand &amp;quot;&#39;C:/Program Files/TortoiseGit/bin/TortoisePlink.exe&#39; -batch -ssh&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記の実行ファイルパスを、ご自身の TortoiseGit のパスに合わせて変更してください。完全なパスを設定することで、システム環境変数に追加する必要はありません。&lt;/p&gt;</description>
        </item>
        <item>
        <title>AIプログラミングとタスク分解</title>
        <link>https://ttf248.life/ja/p/ai-programming-and-task-decomposition/</link>
        <pubDate>Fri, 22 Dec 2023 08:44:26 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/ai-programming-and-task-decomposition/</guid>
        <description>&lt;p&gt;2年前、サイトにコード領域のコピー機能を追加するために、半日ほど試行錯誤した結果、レンダリング効果が少し不満だった。半ば無能なフロントエンド開発者として、改善することも思わなかった。動けばそれで十分だ、と割り切っていた。今年、&lt;code&gt;AI&lt;/code&gt;を使って小程序を開発し、フロントエンドの開発もより慣れてきた。そしてリファクタリングを行った（&lt;code&gt;AI&lt;/code&gt;が再設計）。&lt;/p&gt;
&lt;p&gt;悟り：タスク分解をして、多くの小さなタスクは&lt;code&gt;AI&lt;/code&gt;で開発すると自然にこなせる。すでに閉鎖された小程序において、&lt;code&gt;75%&lt;/code&gt;のコードを&lt;code&gt;AI&lt;/code&gt;が提供し、複数のタスクを分割して引き渡すことで、人工によってプロジェクトコードが&lt;code&gt;組み立て&lt;/code&gt;られた。&lt;/p&gt;
&lt;h2 id=&#34;前文&#34;&gt;前文
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://ttf248.github.io/post/2022/001/%E4%BB%A5%E4%B8%BA%E5%BE%88%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E6%83%85%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E5%A4%8D%E5%88%B6%E6%8C%89%E9%92%AE/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;簡単なことだと考えたけど、コードのコピーボタンを追加する&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;promot&lt;/strong&gt;: クラス &amp;ldquo;highlight&amp;rdquo; を持つウェブページの要素のコンテナ内に、コードと JavaScript の CSS およびコードを記述して、テキストのコピー機能を実現するコピーボタンを追加します。&lt;/p&gt;
&lt;p&gt;最初のドラフトのコードは一見問題があり、基本的には使用可能なものを生成し、コピーされた内容が正しくなく、冗長な文字が含まれているため、最適化を再度誘導し、コアの色設計を指定し、エフェクトを含めるようにしました。&lt;/p&gt;
&lt;p&gt;お客様がボタンのサイズと色に関して特定の要件をお持ちであることを認識しており、これらの要件に合わせてスタイルのデザインを再構築できます。以下は、提供されたカラーパレットとボタンサイズの最適化を含むスタイルです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.copy-btn {
  position: absolute;
  top: 2px; /* 位置調整 */
  right: 2px;
  padding: 3px 6px; /* サイズ縮小 */
  font-size: 12px; /* フォントサイズ縮小 */
  background-color: #8FD1E1; /* ボタンの背景色 */
  color: #272822; /* テキストの色 */
  border: 1px solid #272822; /* ボーダーの色 */
  border-radius: 3px; /* 角丸 */
  cursor: pointer;
  opacity: 0.7; /* デフォルトの不透明度 */
  transition: opacity 0.3s ease, background-color 0.3s ease; /* 平滑なトランジション効果 */
}

.copy-btn:hover {
  opacity: 1; /* マウスオーバー時に完全表示 */
  background-color: #A3D4E5; /* マウスオーバー時の背景色 */
}

.highlight {
  position: relative;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このスタイルでは、ボタンのサイズとフォントサイズを小さくして、より洗練された外観にしています。また、ボタンはデフォルトで半透明になっており、マウスをホバーすると完全表示され、背景色がわずかに明るくなることで視覚的なフィードバックを提供します。これにより、お客様のカラー要件を満たしつつ、モダンでユーザーフレンドリーな特徴を備えたデザインを実現しています。&lt;/p&gt;
&lt;p&gt;以下はよりシンプルな JavaScript です。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;document.addEventListener(&#39;DOMContentLoaded&#39;, function() {
  // すべての .highlight 要素を検索
  const highlights = document.querySelectorAll(&#39;.highlight&#39;);

  highlights.forEach(function(highlight) {
    // コピーボタンを作成
    const copyBtn = document.createElement(&#39;button&#39;);
    copyBtn.textContent = &#39;コピー&#39;;
    copyBtn.classList.add(&#39;copy-btn&#39;);

    // ボタンを各 .highlight 要素に追加
    highlight.appendChild(copyBtn);

    // クリックイベントリスナーを追加
    copyBtn.addEventListener(&#39;click&#39;, function() {
      // .highlight 内の最初の &amp;lt;code&amp;gt; 要素からコピーするコードを取得 (存在する場合)
      const code = highlight.querySelector(&#39;code&#39;) ? highlight.querySelector(&#39;code&#39;).textContent : &#39;&#39;;

      navigator.clipboard.writeText(code).then(() =&amp;gt; {
        // コピー成功メッセージを表示
        copyBtn.textContent = &#39;已コピー!&#39;;
        setTimeout(() =&amp;gt; {
          copyBtn.textContent = &#39;コピー&#39;;
        }, 2000);
      }).catch(err =&amp;gt; {
        console.error(&#39;コピー失敗: &#39;, err);
      });
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;終わりに&#34;&gt;終わりに
&lt;/h2&gt;&lt;p&gt;コード領域の右上隅に、トップエリアにコピーボタンを追加することを望んでいたが、フロントエンドに関する知識が不足しており、キーワードに基づいて機能を正確に記述することができなかったため、AIと何度もやり取りして期待に応えられなかった。&lt;/p&gt;
&lt;p&gt;しかし、時間の経過とともに、AIがプログラミング開発にどの程度の影響を与えるのかは分からない。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>クラウドサーバーとスクリプトキッド</title>
        <link>https://ttf248.life/ja/p/cloud-servers-and-script-kids/</link>
        <pubDate>Mon, 20 Nov 2023 15:08:53 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cloud-servers-and-script-kids/</guid>
        <description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;データマイニング&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ディープラーニング&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ニューラルネットワーク&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;双十一のセールで、阿里云に新しいサーバーを導入しました：経済的なモデル、99ドル年間契約、構成は高くありません。ホップサーバーとして、自宅のサービスを代理するのに適しています。イベントは2026年まで続きます。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特に上海地域のサーバーを選びました。低遅延で自宅の機械を代理し、Windows 11とWindows Server 2022を使用しました。Server版は後から展開したもので、使用中に拒否アクセスメッセージを受け取りました。当初はサーバーのアップデートだと考えましたが、すぐに回復しませんでした。関連するエラーメッセージを検索すると、誰かがログインを試みていることが示され、パスワードが間違っているため、ログインできなくなりました。
以前にもセキュリティ攻撃のスクリプトに触れたことがあります。すぐに、これらのログインは正常な行動ではないことに気づきました。サーバーが攻撃を受けており、ログインを暴力的に試みている可能性があります。サーバーのファイアウォール設定は簡素で、ホワイトリストを設定していませんでした。自宅の2台の機械の3389ポートをパブリックに公開したため、魚塘の餌のように、誰かがターゲットになりました。攻撃者がスクリプト小子であることを知ったので、次のことは単純でした。ファイアウォールのホワイトリストを設定し、会社のIPアドレスと自宅のIPアドレスのみが代理サービスへのアクセスを許可するようにしました。
&lt;code&gt;frps&lt;/code&gt; 代理サーバーの以前の設定では、ログ記録が無効でした。ログを有効にすると、全国各地の代理IPアドレスが自宅サーバーにログインしようとしていたことがわかりました。幸いなことに、Server版の1台がありました。それによって、Windows 11の機械は必ず攻撃され、パスワード設定が簡単だったため、問題が発生するのを防ぐことができました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;2023/11/17 16:51:14 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [101.43.98.211:50486]
2023/11/17 16:51:14 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [218.93.202.63:56970]
2023/11/17 16:51:14 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [222.179.106.174:60812]
2023/11/17 16:51:15 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [58.16.204.238:2839]
2023/11/17 16:51:15 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [124.223.47.24:50274]
2023/11/17 16:51:16 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [43.248.128.22:55883]
2023/11/17 16:51:16 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [43.143.53.138:56955]
2023/11/17 16:51:16 [I] [proxy.go:204] [639d89473251

```shell
Nov 16 04:46:34 aliyun-sh sshd[156625]: 無効なパスワード：root から 120.55.164.64 ポート 53410 の ssh2
Nov 16 04:46:34 aliyun-sh sshd[156623]: 無効なパスワード：root から 111.16.215.122 ポート 36548 の ssh2
Nov 16 04:46:58 aliyun-sh sshd[156630]: 無効なパスワード：無効なユーザー share から 139.9.233.78 ポート 53872 の ssh2
Nov 16 04:47:23 aliyun-sh sshd[156634]: 無効なパスワード：無効なユーザー spark から 139.9.233.78 ポート 36134 の ssh2
Nov 16 04:47:26 aliyun-sh sshd[156636]: 無効なパスワード：root から 120.55.164.64 ポート 46142 の ssh2
Nov 16 04:47:47 aliyun-sh sshd[156640]: 無効なパスワード：root から 111.16.215.122 ポート 42962 の ssh2
Nov 16 04:48:24 aliyun-sh sshd[156652]: 無効なパスワード：root から 120.55.164.64 ポート 38868 の ssh2
Nov 16 04:48:25 aliyun-sh sshd[156654]: 無効なパスワード：root から 111.16.215.122 ポート 46164 の ssh2
Nov 16 04:48:39 aliyun-sh sshd[156657]: 無効なパスワード：無効なユーザー test から 139.9.233.78 ポート 39386 の ssh2
Nov 16 04:48:50 aliyun-sh sshd[156659]: 無効なパスワード：root から 111.16.215.122 ポート 38892 の ssh2
Nov 16 04:48:53 aliyun-sh sshd[156662]: 無効なパスワード：root から 120.55.164.64 ポート 49348 の ssh2
Nov 16 04:48:53 aliyun-sh sshd[156664]: 無効なパスワード：無効なユーザー test から 139.9.233.78 ポート 49864 の ssh2
Nov 16 04:50:02 aliyun-sh sshd[156672]: 無効なパスワード：root から 111.16.215.122 ポート 45294 の ssh2
Nov 16 04:50:30 aliyun-sh sshd[156680]: 無効なパスワード：無効なユーザー zabbix から 139.9.233.78 ポート 52206 の ssh2
Nov 16 04:50:50 aliyun-sh sshd[156683]: 無効なパスワード：root から 120.55.164.64 ポート 34820 の ssh2
Nov 16 04:50:51 aliyun-sh sshd[156685]: 無効なパスワード：root から 111.16.

## 付録
独自のサーバーを構築する場合、Windows のパブリックアクセスにはホワイトリストの設定が必要です。Linux では、パスワードログインの無効化と、キーファイルによる認証の有効化をお勧めします。&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>ローカルのGitリポジトリと履歴上の遺留権限の問題の一括更新</title>
        <link>https://ttf248.life/ja/p/bulk-update-local-git-and-legacy-permissions/</link>
        <pubDate>Thu, 19 Oct 2023 14:16:22 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/bulk-update-local-git-and-legacy-permissions/</guid>
        <description>&lt;p&gt;チームのプロジェクト間に依存関係があり、歴史的な理由から &lt;code&gt;submodule&lt;/code&gt; を使用せずにプロジェクトの依存を管理してきました。日常の開発では、リポジトリコードを順番に手動で更新する必要があり、そうでない場合、さまざまな奇妙な問題が発生する可能性があります。&lt;/p&gt;
&lt;p&gt;オンラインの情報源を参照して、構造は基本的に同じです。ローカルで &lt;code&gt;git_list.txt&lt;/code&gt; というディレクトリを維持し、スクリプトを使用してディレクトリを反復処理し、一度に更新を実行し、その後、作業を開始する前にこのスクリプトを実行します。&lt;/p&gt;
&lt;h2 id=&#34;linux&#34;&gt;Linux
&lt;/h2&gt;&lt;p&gt;新しいファイルを作成: batch_pull.sh&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash

echo &amp;quot;============ リポジトリの更新 ===================&amp;quot;

# git_list.txt が存在するか確認
if [ ! -f &amp;quot;git_list.txt&amp;quot; ]; then
  echo &amp;quot;git_list.txt ファイルが存在しません！git をプルするリポジトリ URL を作成し、追加してください。&amp;quot;
  exit 1
else
  echo &amp;quot;============ git リポジトリリストを検出しました ====&amp;quot;
fi

# git_list.txt から URL を一行ずつ読み込み、プル操作を実行
while read -r url; do
  if [ -d &amp;quot;$url&amp;quot; ]; then
    cd &amp;quot;$url&amp;quot; || continue
    git pull
    cd ..
    echo &amp;quot;Pull $url が完了しました！&amp;quot;
    echo &amp;quot;========================================&amp;quot;
  else
    echo &amp;quot;ディレクトリ $url は存在しません。プルをスキップします。&amp;quot;
  fi
done &amp;lt; &amp;quot;git_list.txt&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;windows&#34;&gt;Windows
&lt;/h2&gt;&lt;p&gt;新しいファイルを作成: batch_pull.bat&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bat&#34;&gt;@echo off
chcp 65001 &amp;gt; nul
rem スクリプトの存在するディレクトリへ移動
cd /d &amp;quot;%~dp0&amp;quot;

rem git_list.txt が存在するか確認
if not exist &amp;quot;git_list.txt&amp;quot; (
  echo git_list.txt ファイルが見つかりません！ git リポジトリ URL を作成し、追加してください。
  exit /b 1
) else (
  echo ============ git リポジトリリストファイルが検出されました =========
)

rem git_list.txt 内の URL を行ごとに読み込み、プル操作を実行
for /f %%i in (git_list.txt) do (
  if exist &amp;quot;%%i&amp;quot; (
    pushd &amp;quot;%%i&amp;quot;
    git pull
    popd
    echo %%i のプルが完了しました！
    echo ========================================
  ) else (
    echo ディレクトリ %%i は存在しません。スキップします。
  )
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;過去の遺留問題&#34;&gt;過去の遺留問題
&lt;/h3&gt;&lt;p&gt;再装システム後に発生した &lt;code&gt;git&lt;/code&gt; フォルダの権限ファイルに関する問題を解決します：&lt;strong&gt;致命的なエラー「unsafe repository (&amp;rsquo;/home/repon&amp;rsquo; is owned by someone else)」&lt;/strong&gt;
オンラインで提案されている解決策は、主に &lt;code&gt;stack overflow&lt;/code&gt; から提供されています。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;リポジトリディレクトリに信頼を追加: &lt;code&gt;git config --global --add safe.directory /home/repon&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.gitconfig&lt;/code&gt; ファイルを手動で編集し、ディレクトリを信頼として指定&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[safe]
    directory = /home/repon
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記の方法により、リポジトリの更新は正常になりましたが、毎回 &lt;code&gt;git pull&lt;/code&gt; を実行する際にコンソールに多数の警告メッセージが表示され、所有者に関するエラーを示しています。&lt;/p&gt;
&lt;h3 id=&#34;デスクトップpcのシステム再インストール&#34;&gt;デスクトップPCのシステム再インストール
&lt;/h3&gt;&lt;p&gt;長らくシステムを再インストールしていなかったマシンで、システムディスクにゴミファイルが爆発的に発生し、仕方なく空き時間を利用してシステムを再構築した。再度この権限の問題に遭遇し、以前のスクリプトが動作しない原因は、修正した権限が不完全だったことによるもの。&lt;/p&gt;
&lt;p&gt;新しい解決策を採用し、&lt;code&gt;*&lt;/code&gt;を追加することで、&lt;code&gt;git&lt;/code&gt;がすべてのディレクトリを自動的に信頼するように設定した。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global --add safe.directory &amp;quot;*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;これはユーザーの権限の問題か、それとも皆さんがWindowsプラットフォームに慣れていないことが原因なのか。実際には&lt;code&gt;chown&lt;/code&gt;のようなコマンドも存在する。フォルダの所有者を変更することはもちろん可能だが、もしディレクトリ数が少ない場合は、手動で所有者を変えることもできる。しかし、このワークステーションはドメイン情報を追加しており、おそらく会社のドメインが異常を抱えているか、あるいはローカルシステムの設定に問題があるため、ユーザーリストからログインに使用するユーザーが見つからない状態だった。最終的にはコマンドラインを使用して問題を解決した。&lt;/p&gt;
&lt;p&gt;管理者権限で&lt;code&gt;powershell&lt;/code&gt;スクリプト&lt;code&gt;change_ower.ps1&lt;/code&gt;を実行し、スクリプトファイルのエンコーディングを&lt;code&gt;gbk&lt;/code&gt;に設定することを忘れないでください。中国語のオペレーティングシステムでは、そうしないと文字化けしてしまうため。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;# 現在のユーザー名を取得
$currentUserName = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name

# PowerShell の文字エンコーディングを UTF-8 に設定
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8

# 所有者を変更するルートディレクトリパス
$rootDirectory = &amp;quot;G:\workspace&amp;quot;  # 実際のパスに置き換えてください

# ディレクトリとファイルを再帰的に取得し、所有者を変更
Get-ChildItem -Path $rootDirectory -Recurse | ForEach-Object {
    $itemPath = $_.FullName

    # アイテムがファイルかディレクトリかをチェック
    if ($_ -is [System.IO.DirectoryInfo]) {
        # ディレクトリの場合、icacls コマンドを使用して所有者権限を変更
        $icaclsResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            Write-Host &amp;quot;ディレクトリ $itemPath の所有者を $currentUserName に変更しました&amp;quot;
        } else {
            Write-Host &amp;quot;ディレクトリ $itemPath の所有者変更に失敗しました。エラー情報: $icaclsResult&amp;quot;
        }
    } else {
        # ファイルの場合、icacls コマンドを使用して所有者権限を変更
        $takeownResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            # Write-Host &amp;quot;ファイル $itemPath の所有者を $currentUserName に変更しました&amp;quot;
        } else {
            Write-Host &amp;quot;ファイル $itemPath の所有者変更に失敗しました。エラー情報: $takeownResult&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;予想外の事態が再び発生し、スクリプト実行時の出力された日本語の情報が文字化けした。コンソールエンコーディングの設定を調整したり、スクリプトのエンコーディングを変更したりしたが、すべて文字化けしてしまう。おそらく脳みそが完全に機能停止しているのだろうと推測し、コントロールパネル - 領域 - 言語設定のベータ機能を試してみた。グローバルにUnicodeエンコーディングを有効にし、スクリプト実行は正常になった。いくつかの開発ソフトウェアが正常に動作しないままであり、後で資料を整理したところ、スクリプトファイルのエンコーディングを&lt;code&gt;gbk&lt;/code&gt;に設定する必要があることを思い出した。&lt;/p&gt;
&lt;h2 id=&#34;资料&#34;&gt;资料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://ganzhixiong.com/p/f1b9f4fc/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ganzhixiong.com/p/f1b9f4fc/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/71901632/fatal-error-unsafe-repository-home-repon-is-owned-by-someone-else&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stackoverflow.com/questions/71901632/fatal-error-unsafe-repository-home-repon-is-owned-by-someone-else&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>WPF学習資料</title>
        <link>https://ttf248.life/ja/p/wpf-learning-resources/</link>
        <pubDate>Tue, 17 Oct 2023 10:49:24 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/wpf-learning-resources/</guid>
        <description>&lt;p&gt;小規模アプリ（ミニプログラム）開発の設計上の問題がまだ解決されておらず、新たに&lt;strong&gt;WPF&lt;/strong&gt;を立ち上げました。最近会社にも波乱があり、遠隔地での共同作業におけるコミュニケーション効率は依然として不十分で、思い切ってクライアント側のUI開発を受注しました。&lt;/p&gt;
&lt;h2 id=&#34;wpf&#34;&gt;WPF
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/dotnet/desktop/wpf/introduction-to-wpf?view=netframeworkdesktop-4.8&amp;amp;preserve-view=true&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 微软官网学习资料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/zh7791/p/11502696.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 基础总结(学習建議)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.wpfsoft.com/introduction&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 中文網&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/638815741&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 个人まとめと学習推奨&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;WPF&lt;/code&gt; のインターフェースデザインで使われる多くの概念は、ウェブページフロントエンドのデザインに似ています。可能な限り UI デザインとビジネスロジックを分離し、UI デザインを独立して開発することも、インターネット企業が期待する分業方法です。今年、小程序（ミニアプリ）の開発をした経験があり、多くの概念は共通しているため、習得も比較的容易でした。これらのものは現代の UI 設計における「道」であり、基本的なフレームワークの概念を理解することで、その後の道が曲がりにくくなります。&lt;/p&gt;
&lt;p&gt;以前 &lt;code&gt;WinForm&lt;/code&gt; 開発の経験がある読者の場合は、&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/zh7791/p/11502696.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 基礎まとめ(学習建議)&lt;/a&gt; を読んでください。内容は短いため、経験豊富な読者が学習ルートを計画するのに適しています。&lt;/p&gt;
&lt;p&gt;初心者の方は、&lt;a class=&#34;link&#34; href=&#34;http://www.wpfsoft.com/introduction&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 中文網&lt;/a&gt; から始めて、基本的な概念、発展の歴史、低レベルクラスの論理的認知について理解してください。このウェブサイトは偶然にもタイミングが合っており、今年8月に作者がリリースしたばかりで、読者を惹きつけ、コースの購入を促すためのものです。私のコンテンツとのタイミングが一致しなかったら、ほぼ無縁になっていたでしょう。&lt;/p&gt;
&lt;p&gt;最も本格的な学習資料は、もちろん Microsoft の公式資料ですが、内容は少し退屈なので、新参者は根気強く学ぶ必要があります。&lt;/p&gt;
&lt;p&gt;古典的な電子書籍もたくさんありますが、日常業務に追われるため、静かに読書する時間は限られています。プロジェクトで実践しながら学習することが最適です。&lt;/p&gt;
&lt;h2 id=&#34;c-と-net-のリリース履歴&#34;&gt;C# と .NET のリリース履歴
&lt;/h2&gt;&lt;p&gt;以前学習した言語について、最近数年間の新機能のリリースが少し多いため、文法のバージョンが毎年更新されています。
&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/C_Sharp_%28programming_language%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://en.wikipedia.org/wiki/C_Sharp_(programming_language)&lt;/a&gt;
公式学習資料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/dotnet/csharp/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/dotnet/csharp/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/dotnet/core/tutorials/with-visual-studio?pivots=dotnet-7-0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/dotnet/core/tutorials/with-visual-studio?pivots=dotnet-7-0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>ゼロティア・ローカルエリアネットワーク</title>
        <link>https://ttf248.life/ja/p/zero-tier-remote-lan/</link>
        <pubDate>Tue, 19 Sep 2023 04:58:03 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/zero-tier-remote-lan/</guid>
        <description>&lt;p&gt;オフィスに新たにミニPCを入手し、環境構築を兼ねて便利に考えたのですが、自宅でも時折アクセスする必要があるため、一時的に社内ネットワークのトンネリングを実施することになりました。これまでの経験から、&lt;code&gt;frp&lt;/code&gt;サービスをデプロイしてポートフォワーディングを設定する方法を選びましたが、その品質は公開サーバーの帯域幅に依存します。少しばかり新鮮な&lt;code&gt;Zerotier&lt;/code&gt;仮想マシンによるローカルエリアネットワーク（LAN）を試してみることにしました。これは&lt;code&gt;VPN&lt;/code&gt;と似ており、ローカルで仮想ネットワークインターフェースを作成し、すべてのマシンを1つの仮想ネットワークに参加させます。&lt;/p&gt;
&lt;h2 id=&#34;zerotierとは&#34;&gt;Zerotierとは
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ZeroTier&lt;/code&gt;は、ソフトウェア定義の広域ネットワーク（SD-WAN）ソリューションであり、異なる地理的な場所にあるデバイス間で安全な仮想ネットワークを作成することを可能にします。 &lt;code&gt;ZeroTier&lt;/code&gt;を使用すると、複数のコンピューター、サーバー、およびデバイスを、あたかも同じローカルネットワーク上にいるかのように、一元的に暗号化された仮想ネットワークに接続できます。これにより、開発者やIT専門家は、複雑なネットワーク設定やVPN構成なしで、異なる場所間で安全にデータを共有し、リソースを共有することができます。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ZeroTierネットワーク&lt;/strong&gt;: ZeroTierネットワークは、異なるデバイスがインターネット経由で互いに接続されることを可能にする、仮想的かつグローバルなローカルエリアネットワーク（LAN）です。このネットワークには複数のサブネットを含めることができ、すべてのデバイスはZeroTierの技術を使用して相互に接続されます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;惑星サーバー&lt;/strong&gt;: 惑星サーバーは、ZeroTierネットワークの中核コンポーネントであり、その一元的なトポロジー構造、ルーティング情報、およびネットワーク状態を維持・管理します。惑星サーバーはグローバルなネットワーク制御センターとして機能しますが、直接データを転送しません。ユーザーのデバイスは、少なくとも1つの惑星サーバーに接続してZeroTierネットワークに参加する必要があります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;中継サーバー&lt;/strong&gt;: 中継サーバーは、ZeroTierネットワーク内の補助的なノードであり、デバイス間の直接通信チャネルを確立するのを支援します。デバイスが直接接続できない場合、データ転送のために中継サーバーを経由することができます。これにより、ネットワークの到達性とパフォーマンスが向上します。中継サーバーは通常、世界中に配置され、データの転送ハブとして機能します。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;全体として、ZeroTierは惑星サーバーと中継サーバーの支援により、デバイスがグローバル範囲で仮想LANを作成し、安全かつ高速なデバイス間の通信を実現します。惑星サーバーはグローバルネットワーク管理を担当し、中継サーバーは必要に応じてデバイス間の接続を確立するのに役立ちます。&lt;/p&gt;
&lt;h2 id=&#34;インストールと展開&#34;&gt;インストールと展開
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.zerotier.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.zerotier.com/&lt;/a&gt; の公式ウェブサイトにアクセスし、インストールファイルおよびドキュメントを入手してください。&lt;/li&gt;
&lt;li&gt;お使いのオペレーティングシステムに応じて、ZeroTier One クライアントをダウンロードしてインストールします。Windows、macOS、Linux など、多くのプラットフォームに対応しています。&lt;/li&gt;
&lt;li&gt;インストールが完了したら、ZeroTier One クライアントを起動します。&lt;/li&gt;
&lt;li&gt;まだアカウントをお持ちでない場合は、ZeroTier アカウントを作成します。クライアント内でアカウントを作成できます。&lt;/li&gt;
&lt;li&gt;ZeroTier アカウントにログインし、新しいネットワークを作成します。ネットワークには一意の16桁IDが割り当てられ、これを覚えておく必要があります。&lt;/li&gt;
&lt;li&gt;デバイスをこのネットワークに参加させます。クライアントでネットワークIDを入力するか、QRコードスキャン機能を使用します。&lt;/li&gt;
&lt;li&gt;ZeroTier クライアントのインストールおよび設定されたデバイスは、同じ仮想ネットワークに追加されます。これらのデバイス間では、現在、ローカルネットワークにあるかのように直接通信できるようになります。&lt;/li&gt;
&lt;li&gt;ZeroTier のコントロールパネルで、ネットワーク設定を管理したり、デバイスを追加したり、ネットワークトラフィックを監視したりできます。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;moon-のインストールとデプロイ&#34;&gt;moon のインストールとデプロイ
&lt;/h2&gt;&lt;p&gt;国内の多くのキャリアが UDP トンネリングを禁止しているため、&lt;code&gt;frp&lt;/code&gt; サービスは安定しており、TCP プロトコルを使用するため、&lt;code&gt;Zerotier&lt;/code&gt; の中継サーバーも同様の効果を実現できます。ファイアウォールで UDP 9993 を開通する必要があります。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -s https://install.zerotier.com/ | sudo bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;インストールが成功したか確認する&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zerotier-cli info
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ローカルネットワークへの参加&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zerotier-cli join network-id
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;moon&lt;/code&gt; の作成&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd /var/lib/zerotier-one &amp;amp;&amp;amp; sudo zerotier-idtool initmoon identity.public &amp;gt; moon.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;stableEndpoints&lt;/code&gt; ノードを調整するために構成ファイルを開き、&amp;ldquo;サーバーのパブリック IP アドレス/9993&amp;rdquo; を設定します。署名構成を生成し、&lt;code&gt;moons.d&lt;/code&gt; フォルダを作成し、既存のファイルをこのフォルダに移動してサービスを再起動します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo zerotier-idtool genmoon moon.json
mkdir moons.d &amp;amp;&amp;amp; mv 000000eb444ec0d8.moon moons.d/
systemctl restart zerotier-one.service
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;クライアントノードが &lt;code&gt;moon&lt;/code&gt; サーバーに参加し、ID は前の JSON 設定ファイル内の ID フィールドから取得します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zerotier-cli.bat orbit ztaddr ztaddr
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;確認:&lt;/strong&gt; 新しい moon ノードが作成され、ID と情報はサーバー構成と同じであることを確認してください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 新規 moon 节点の出現を確認し、ID と情報がサーバー設定と一致することを確認します
[root@idv-36f9d5 ~]# zerotier-cli listpeers
200 listpeers &amp;lt;ztaddr&amp;gt; &amp;lt;path&amp;gt; &amp;lt;latency&amp;gt; &amp;lt;version&amp;gt; &amp;lt;role&amp;gt;
200 listpeers 0cccb***** 35.236.*.*/64393;110;10726 327 1.6.3 LEAF
200 listpeers 3a46f***** 185.180.*.*/9993;110;757 -1 - PLANET
200 listpeers 3ed7c***** 39.97.*.*/9993;172;79 32 1.6.3 MOON
200 listpeers 4f838***** - -1 - LEAF
200 listpeers 62f86***** 50.7.*.*/9993;110;4796 351 - PLANET
200 listpeers 778cd***** 103.195.*.*/9993;5148;4887 253 - PLANET
200 listpeers 992fc***** 195.181.*.*/9993;10161;4921 226 - PLANET
200 listpeers 9d2b5***** - -1 - LEAF
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Windows プラットフォームでは、管理者権限でターミナルを起動し、&lt;code&gt;zerotier-cli.bat&lt;/code&gt; コマンドラインを使用して操作します。Linux プラットフォームでは、&lt;code&gt;zerotier-cli&lt;/code&gt; コマンドラインを使用して操作します。 &lt;code&gt;listpeers&lt;/code&gt; サブコマンドは正常に moon 节点を表示するため、参加が成功したことを示しています。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;卸载方法&#34;&gt;卸载方法
&lt;/h2&gt;&lt;p&gt;Windowsプラットフォームの卸載方法は後述します。通常の操作手順に従い、コントロールパネルからアンインストールしてください。ここではUbuntuについて詳しく説明します。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;dpkgコマンドでzerotier-oneサービスを削除する&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo dpkg -P zerotier-one
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;zerotier-oneフォルダを削除する。このフォルダにはaddressアドレスが保存されており、削除後に再インストールを行うと新しいaddressアドレスを取得します。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo rm -rf /var/lib/zerotier-one/
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;跋談&#34;&gt;跋談
&lt;/h2&gt;&lt;p&gt;元々は既にアンインストールされていたものが、サーバーが到着し、適切なプロキシノードが存在しないため、阿里云が営業活動を行い、開発用特供サーバーを提供しました。構成は高くなく、1999年、価格も手頃で、2年間運用しました。主な理由はサーバーから提供される帯域幅でした。&lt;/p&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.wnark.com/archives/152.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.wnark.com/archives/152.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/Yogile/p/12642423.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cnblogs.com/Yogile/p/12642423.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>VMware 仮想マシンのディスクスペース最適化</title>
        <link>https://ttf248.life/ja/p/vmware-virtual-machine-disk-space-optimization/</link>
        <pubDate>Wed, 21 Jun 2023 18:35:41 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/vmware-virtual-machine-disk-space-optimization/</guid>
        <description>&lt;p&gt;VMWareの仮想マシンをインストールして開発を行う際、通常はディスク容量を多めに確保します。使用していくうちに、ホスト側の使用ディスク容量が仮想マシンの実際のファイルサイズを大幅に上回ることがあります。&lt;/p&gt;
&lt;h2 id=&#34;シナリオの説明&#34;&gt;シナリオの説明
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;df -h&lt;/code&gt;コマンドを実行し、現在のマシンのディスク情報を確認したところ、実際に使用されているのは60GBであり、すべてのシャットアウトとクローンイメージを削除しても、ローカル仮想マシンが占有するディスクスペースは依然として60GBよりも大幅に大きい。これにより、すでに限られたハードドライブの状態が悪化している。&lt;/p&gt;
&lt;h2 id=&#34;前提条件&#34;&gt;前提条件
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;仮想マシンのインストール時に、ディスクの事前割り当てをチェックしなかった&lt;/li&gt;
&lt;li&gt;ローカルに保存された仮想マシンのハードドライブが、現在使用されている容量より十分な空き容量を持っていること
空き容量が不足している場合は、一時的に仮想マシンをポータブルHDDに移動してディスクを最適化した後、再度移行することを検討してください。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ツール&#34;&gt;ツール
&lt;/h2&gt;&lt;p&gt;公式から &lt;code&gt;open-vm-tools&lt;/code&gt; パッケージが提供されており、yum でインストールするか、vmware-tools イメージパッケージでインストールできます。&lt;/p&gt;
&lt;h2 id=&#34;命令&#34;&gt;命令
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vmware-toolbox-cmd disk shrink /
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これを実行すると、仮想マシンは自動的にシャットダウンされ、VMware ホストプログラムがディスクの縮小を実行します。 実行時間は仮想マシンのサイズとディスクへのアクセス速度によって異なります。
実行効果は非常に良く、仮想マシンのディスク使用量が &lt;code&gt;df -h&lt;/code&gt; のディスク情報とほぼ一致します。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Stable-diffusion - そのインストールから始まる喜びと苦悩 (安定拡散 - そのインストールから始まる喜びと苦悩)</title>
        <link>https://ttf248.life/ja/p/stable-diffusion-zero-install-story/</link>
        <pubDate>Thu, 13 Apr 2023 00:23:54 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/stable-diffusion-zero-install-story/</guid>
        <description>&lt;p&gt;国内の資料は、基本的には&lt;strong&gt;秋葉&lt;/strong&gt;さんのワンクリックデプロイパッケージを推奨されています。すべてPythonベースのオープンソースプロジェクトなので、デプロイもそれほど複雑ではないだろうと考え、ゼロから試してみることにしました。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;AI生成画像に苦労したので、意図的にグラフィックカードを変更しました。入門版の&lt;code&gt;3060 12g&lt;/code&gt;です。7年勤めた&lt;code&gt;960&lt;/code&gt;が栄光のうちに退役しました。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;コアの &lt;code&gt;pytorch cuda&lt;/code&gt; のインストールですが、以前 &lt;code&gt;python&lt;/code&gt; ゲーム補助スクリプトを書いた際にローカルにインストールしたことがありましたが、やはり問題が発生しました。&lt;code&gt;cuda&lt;/code&gt; の暗号化が常に有効にならないという問題です。&lt;/p&gt;
&lt;h2 id=&#34;待処理&#34;&gt;待処理
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;文章構造を再計画し、まず PyTorch を紹介する。バージョン対応関係とバージョン確認方法&lt;/li&gt;
&lt;li&gt;ローカル環境から PyTorch をゼロから新規に作成・デプロイする方法&lt;/li&gt;
&lt;li&gt;Stable Diffusion の翻訳稿を作成する（https://stable-diffusion-art.com/install-windows/ から開始）&lt;/li&gt;
&lt;li&gt;参照資料の整理&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ステップ&#34;&gt;ステップ
&lt;/h2&gt;&lt;p&gt;中国語で検索すると、手順を追ったインストール方法が見つかりにくい可能性があります。&lt;code&gt;Google&lt;/code&gt; で英語で検索すると、同様のチュートリアルがたくさんあります。ゼロから始めるものばかりです。いくつか説明した後、&lt;code&gt;git&lt;/code&gt; のインストールが必要であること、そして &lt;code&gt;python&lt;/code&gt; のインストールについても言及します。その後は、リポジトリをダウンロードし、直接スクリプトをダブルクリックして完了となります。
&lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/AUTOMATIC1111/stable-diffusion-webui&lt;/a&gt;
詳細な使用方法や疑問点については、&lt;code&gt;issues&lt;/code&gt; を参照してください。&lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki&lt;/a&gt;
なぜ誰もこのリポジトリが何をするものなのか説明していないのかわかりません。名前からして、それはインターフェース制御台であり、より簡単に使用できるように設計されていることがわかります。インストール時には、現在のフォルダに &lt;code&gt;Python&lt;/code&gt; 仮想環境があるかどうかを自動的に認識し、存在する場合は現在のパスの &lt;code&gt;python&lt;/code&gt; を使用します。
初心者の方には、&lt;a class=&#34;link&#34; href=&#34;https://stable-diffusion-art.com/install-windows/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stable-diffusion-art.com/install-windows/&lt;/a&gt; を参照することをお勧めします。&lt;/p&gt;
&lt;h2 id=&#34;pytorch&#34;&gt;PyTorch
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://pytorch.org/get-started/locally/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pytorch.org/get-started/locally/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今日は私が話したいのは、まず彼らの手順をそのまま実行しないでください。Pythonはrequirementファイルを使って依存ライブラリをインストールします。これは小さな問題です。重要なのはあなたのGPUのバージョンとドライバーのバージョンがPyTorchに対応していることです。これは多くの人が対応関係を紹介しているので、ネットで調べてみればわかります。
参考：&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/weixin_40660408/article/details/129896700&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/weixin_40660408/article/details/129896700&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;仮想環境を作成するのは、空の仮想環境を作り、その中でまず公式サイトのスクリプトを実行してPyTorchをインストールすることです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python -c &amp;quot;import torch; print(torch.version.cuda)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python -c &amp;quot;import torch; print(torch.__version__, torch.cuda.is_available())&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記の2つのスクリプトで、必要なCUDAバージョンを確認したり、インストールが成功したかどうかを確認したりできます。&lt;/p&gt;
&lt;p&gt;ここでは、派手な操作をするのではなく、まず公式サイトのロジックをそのままコピーしてインストールすることをお勧めします。直接pipを使ってインストールすると、PyTorchが失敗する可能性や、CUDAがアクティブにならない可能性があります。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ポイントは、フォルダのパスに不要なものが含まれていないことです。そうでないと、PyTorchを使用できなくなる可能性があります。&lt;/p&gt;
&lt;p&gt;何度もインストールを試みたり、公式のインストールファイルをダウンロードして手動でインストールしたりしました。2.0バージョンをアップグレードしたいと考えていましたが、公式ドキュメントでは2.0がより高速であると記載されています。しかし、以前はあまり使用していなかったので、Pythonのバージョンやそれが影響するかどうか分からずでした。また、公式マニュアルには3.8バージョンの推奨があることが書かれていました。これにより小さな競合が発生しました。以前、ワンクリックインストールパッケージを使用しており、その中に3.10バージョンが含まれていました。最終的には、空のフォルダを作成し、仮想環境を作成して、PyTorchが正しくインストールされていることを確認してから、インストールを開始しました。&lt;/p&gt;
&lt;p&gt;その後、インストールされた仮想環境をWeb UIのフォルダに移動しました。この状態でスクリプトを実行して、他の依存関係の問題は解決されました。&lt;/p&gt;
&lt;p&gt;移動後、次のコマンドを実行する必要があります：&lt;code&gt;python -m pip install --upgrade --force-reinstall pip&lt;/code&gt;  pipを修復します。&lt;/p&gt;
&lt;p&gt;おそらく、これは非常に奇妙に見えるかもしれませんが、この場所でかなり時間を費やしました。なぜなら、常にPyTorchを正しく認識できなかったからです。すべての干渉要因を除外するために、まずそれをインストールし、次に他の依存ライブラリをインストールすることを思いつきました。&lt;/p&gt;
&lt;h2 id=&#34;xformers&#34;&gt;Xformers
&lt;/h2&gt;&lt;p&gt;有効化することを推奨します。画像生成を高速化し、既存の占有量を削減できますが、副作用として、同じパラメータセットで&lt;strong&gt;生成される画像は比較的安定しません&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Xformers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;stable-diffusion-webui:Xformers&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://huggingface.co/docs/diffusers/optimization/xformers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;huggingface optimization&lt;/a&gt;
| 100.00% | 2分57秒33 | 7440MiB / 10058MiB | 12288MiB / 12288MiB (100.0%) |&lt;/p&gt;
&lt;h2 id=&#34;xformers-1&#34;&gt;Xformers
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;最適化比率&lt;/th&gt;
&lt;th&gt;時間&lt;/th&gt;
&lt;th&gt;Torch 活性/予約メモリ&lt;/th&gt;
&lt;th&gt;システムVRAM&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;51.02%&lt;/td&gt;
&lt;td&gt;1分29秒21&lt;/td&gt;
&lt;td&gt;4547/7164 MiB&lt;/td&gt;
&lt;td&gt;9298/12288 MiB (75.67%)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;xformers-2&#34;&gt;Xformers
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;((masterpiece)),((best quality)),((high detail)),((realistic,))
産業時代の都市、中央に深い峡谷、中国式の街並み、バザール、橋、（雨の日:1.2）、（スチームパンク:0.8）、中国建築
ネガティブプロンプト：nsfw,((カウボーイ)),(((陰毛))), ((((陰毛の髪の毛))))スケッチ、重複、醜い、大きな目、テキスト、ロゴ、モノクロ、最悪の顔、（悪いおよび変異した手:1.3）、(最悪の品質:2.0)、(低品質:2.0)、(ぼやけ:2.0)、ホラー、ジオメトリ、bad_prompt、（悪い手）、(指が足りない)、複数の四肢、悪い解剖学、（交差した指:1.2）、醜い指、（追加の指と手と足と腕:1.4）、冠髪飾り、（2girl）、(変形した指:1.2)、(長い指:1.2)、サキュバスの翼、角、サキュバスの角、サキュバスのヘアスタイル、（悪いアーティストアニメ）、悪いアーティスト、悪い手、借りたキャラクター、テキスト重視、ウォーターマーク、サンプルウォーターマーク、キャラクターウォーターマーク、Lofterユーザー名、写真の日付ウォーターマーク、映画ポスター、雑誌表紙、ジャーナル、表紙、表紙ページ、道行表、アルバム表紙、漫画表紙、ブランド名の模倣、EasyNegative、タイツ、シルクストッキング、ショート
ステップ数：35、サンプラー：DPM adaptive、CFGスケール：5.5、シード：2223996555、サイズ：1088x1088、モデルハッシュ：543bcbc212、モデル：base_Anything-V3.0-pruned、Clipスキップ：2、ENSD：31337
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;終わりに&#34;&gt;終わりに
&lt;/h2&gt;&lt;p&gt;なぜデプロイメントパッケージを推奨しなかったのかというと、そのパッケージには作者が個人的にカスタマイズした設定が含まれており、公式のオリジナルのものとは異なっているためです。もしあなたが初心者であれば、なぜそれらのパラメータが最適なのか分からないかもしれません。しかし、使用していくうちに公式のマニュアルを参照することで、どのパラメータを調整する必要があるかを知ることができます。&lt;/p&gt;
&lt;h2 id=&#34;グラフィックボードの選択&#34;&gt;グラフィックボードの選択
&lt;/h2&gt;&lt;p&gt;データマネーマイニングの後、グラフィックボードの価格は比較的高くありません。一般的なエントリーレベルのプレイヤーが、&lt;code&gt;3060&lt;/code&gt;と&lt;code&gt;3060Ti&lt;/code&gt;の間で選択する場合、一般的には大容量&lt;code&gt;12G&lt;/code&gt;版の3060が推奨されます。なぜなら、より高い解像度の画像を生成できるからです。なぜ高い解像度が必要なのでしょうか？それは、生成時に解像度を上げることによって、生成される画像がより鮮明で詳細になるためです。もしあなたが小さな画像を生成したいのであれば、&lt;code&gt;8G&lt;/code&gt;のVRAMでも十分です。&lt;/p&gt;
&lt;p&gt;さらに、&lt;strong&gt;高解像度アップスケーリング&lt;/strong&gt;オプションがあり、ディテールを強調し、画面の詳細さを豊かにすることも、より多くのVRAMが必要です。&lt;/p&gt;
&lt;p&gt;以下はNVIDIA GeForce GTX 970、GeForce RTX 3060 Ti、GeForce RTX 3060、GeForce RTX 3080およびGeForce RTX 3080 Tiの単精度（FP32）、半精度（FP16）および双精度（FP64）浮動小数点演算能力の仕様一覧表：&lt;/p&gt;
&lt;p&gt;| GeForce GTX 970 | 2014 | 3.49 | 87.2 | 0.109 |&lt;/p&gt;
&lt;h2 id=&#34;グラフィックボードの選択-1&#34;&gt;グラフィックボードの選択
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;グラフィックボードモデル&lt;/th&gt;
&lt;th&gt;リリース年&lt;/th&gt;
&lt;th&gt;単精度浮動小数点演算能力 (TFLOPS)&lt;/th&gt;
&lt;th&gt;半精度浮動小数点演算能力 (TFLOPS)&lt;/th&gt;
&lt;th&gt;双精度浮動小数点演算能力 (TFLOPS)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3060 Ti&lt;/td&gt;
&lt;td&gt;2020&lt;/td&gt;
&lt;td&gt;16.2&lt;/td&gt;
&lt;td&gt;32.4&lt;/td&gt;
&lt;td&gt;0.51&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;グラフィックボードの選択-2&#34;&gt;グラフィックボードの選択
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;グラフィックボードモデル&lt;/th&gt;
&lt;th&gt;リリース年&lt;/th&gt;
&lt;th&gt;単精度浮動小数点演算能力 (TFLOPS)&lt;/th&gt;
&lt;th&gt;半精度浮動小数点演算能力 (TFLOPS)&lt;/th&gt;
&lt;th&gt;双精度浮動小数点演算能力 (TFLOPS)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3060&lt;/td&gt;
&lt;td&gt;2021&lt;/td&gt;
&lt;td&gt;12.7&lt;/td&gt;
&lt;td&gt;25.4&lt;/td&gt;
&lt;td&gt;0.39&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;グラフィックボードの選択-3&#34;&gt;グラフィックボードの選択
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;グラフィックボードモデル&lt;/th&gt;
&lt;th&gt;リリース年&lt;/th&gt;
&lt;th&gt;単精度浮動小数点演算能力 (TFLOPS)&lt;/th&gt;
&lt;th&gt;半精度浮動小数点演算能力 (TFLOPS)&lt;/th&gt;
&lt;th&gt;双精度浮動小数点演算能力 (TFLOPS)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3080&lt;/td&gt;
&lt;td&gt;2020&lt;/td&gt;
&lt;td&gt;29.8&lt;/td&gt;
&lt;td&gt;58.9&lt;/td&gt;
&lt;td&gt;0.93&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;グラフィックボードの選択-4&#34;&gt;グラフィックボードの選択
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;グラフィックボードモデル&lt;/th&gt;
&lt;th&gt;リリース年&lt;/th&gt;
&lt;th&gt;単精度浮動小数点演算能力 (TFLOPS)&lt;/th&gt;
&lt;th&gt;半精度浮動小数点演算能力 (TFLOPS)&lt;/th&gt;
&lt;th&gt;双精度浮動小数点演算能力 (TFLOPS)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3080 Ti&lt;/td&gt;
&lt;td&gt;2021&lt;/td&gt;
&lt;td&gt;34.8&lt;/td&gt;
&lt;td&gt;68.7&lt;/td&gt;
&lt;td&gt;1.36&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;显卡的選択&#34;&gt;显卡的選択
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.google.com/spreadsheets/d/1Zlv4UFiciSgmJZncCujuXKHwc4BcxbjbSBg71-SdeNk/edit#gid=0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;各種グラフィックカード性能テストデータ&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;更新&#34;&gt;更新
&lt;/h2&gt;&lt;p&gt;半年ごとに、改めてインストール手順を整理したり、基礎概念を解説したりする予定でしたが、一般的にAIイラストを生成する場合、結局はベテランユーザーが提供した画像パラメータを調整したり、既存の画像をフォーマットして再レンダリングしたりすることになるという事実に気づきました。&lt;/p&gt;
&lt;p&gt;以前、AIを使ってミニプログラムのUI素材を描画するというプロジェクトがありましたが、半日かけても期待通りの結果が得られず、結局公式のミニプログラムから画像素材を直接ダウンロードする方が良いという結論に至りました。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>プログラムの最適化は、ハードウェアと戦おうとするべきではありません。</title>
        <link>https://ttf248.life/ja/p/program-optimization-dont-fight-hardware/</link>
        <pubDate>Fri, 07 Apr 2023 16:30:15 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/program-optimization-dont-fight-hardware/</guid>
        <description>&lt;p&gt;&lt;code&gt;one loop thread&lt;/code&gt;（単一ループスレッド）の実行時間がすでに&lt;strong&gt;マイクロ秒&lt;/strong&gt;レベルで、サーバーを交換した結果、最大6万パケットまでバックログが積み重なるのをほぼゼロにすることができた。&lt;/p&gt;
&lt;p&gt;シングルスレッドでのループ処理でデータを扱う場合、CPUの性能はクロック周波数、キャッシュサイズ、命令セットアーキテクチャなどの要因によって決まる。一般的に、クロック周波数が高く、キャッシュサイズが大きい、そして命令セットアーキテクチャが高度なCPUほど、シングルスレッドでデータを処理する際の性能が良い。&lt;/p&gt;
&lt;h2 id=&#34;シングルスレッド&#34;&gt;シングルスレッド
&lt;/h2&gt;&lt;p&gt;パフォーマンス向上のために、スレッドを追加することは必ずしも必要ではありません。プロジェクトのプロセスを整理し、時間がかかる箇所を特定し、シングルスレッドで要件を満たせるか検討します。シングルスレッドでは考慮すべき点が少なく、問題が発生する可能性も低くなります。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最初からスレッドについて言及するのは、多少不適切です&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;イベント&#34;&gt;イベント
&lt;/h2&gt;&lt;p&gt;処理しているデータは&lt;strong&gt;市場データであり、遅延に敏感&lt;/strong&gt;です。
一晩中ひたすら加班し、新しい最適化版をリリースし、ローカルでインターフェースを剥離してテストを行い、速度はそれなりに良かった（tps：4.2万）。
サーバーにデプロイしたところ、tpsが急降下し、2.1万になった。台式机に戻って試すと、tpsは7.9万だった。グループ内のサービス仮想マシンの問題があるのではないかと疑い始め、まずCPUのクロック周波数（主頻度）の違いを疑った。家庭用PCとサーバーの&lt;code&gt;CPU&lt;/code&gt;では、クロック周波数が最も異なる点だった。&lt;/p&gt;
&lt;p&gt;テストサーバーA&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;processor	: 7
vendor_id	: GenuineIntel
cpu family	: 6
model		: 47
model name	: Intel(R) Xeon(R) CPU E7- 4807  @ 1.87GHz
stepping	: 2
microcode	: 0x34
cpu MHz		: 1866.733
cache size	: 18432 KB
physical id	: 1
siblings	: 4
core id		: 3
cpu cores	: 4
apicid		: 7
initial apicid	: 7
fpu		: yes
fpu_exception	: yes
cpuid level	: 11
wp		: yes
flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss syscall nx rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc cpuid aperfmperf pni pclmulqdq ssse3 cx16 sse4_1 sse4_2 popcnt aes hypervisor lahf_lm pti dtherm arat
bugs		: clflush_monitor cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit
bogomips	: 3733.46
clflush size	: 64
cache_alignment	: 64
address sizes	: 40 bits physical, 48 bits virtual
power management:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;テストサーバーB&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;processor	: 7
vendor_id	: GenuineIntel
cpu family	: 6
model		: 63
model name	: Intel(R) Xeon(R) CPU E5-2640 v3 @ 2.60GHz
stepping	: 2
microcode	: 0x3c
cpu MHz		: 2599.998
cache size	: 20480 KB
physical id	: 14
siblings	: 1
core id		: 0
cpu cores	: 1
apicid		: 14
initial apicid	: 14
fpu		: yes
fpu_exception	: yes
cpuid level	: 15
wp		: yes
flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc cpuid aperfmperf pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand hypervisor lahf_lm cpuid_fault epb pti fsgsbase smep xsaveopt cqm_llc cqm_occup_llc dtherm ida arat pln pts
bugs		: cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit
bogomips	: 5199.99
clflush size	: 64
cache_alignment	: 64
address sizes	: 40 bits physical, 48 bits virtual
power management:
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;openaiへの相談&#34;&gt;OpenAIへの相談
&lt;/h2&gt;&lt;p&gt;まず、コア数とクロック周波数に関しては、Intel(R) Xeon(R) CPU E7-4807 @ 1.87GHzは6つの物理コアと12個の論理コアを持ち、クロック周波数は1.87GHzです。一方、Intel(R) Xeon(R) CPU E5-2640 v3 @ 2.60GHzは8つの物理コアと16個の論理コアを持ち、クロック周波数は2.60GHzです。したがって、コア数とクロック周波数という点では、E5-2640 v3がE7-4807よりもシングルスレッドでのデータ処理において有利であると考えられます。
次に、キャッシュサイズに関しては、E7-4807のキャッシュサイズは12MBであり、E5-2640 v3のキャッシュサイズは20MBです。したがって、E5-2640 v3はより大きなキャッシュスペースを持ち、データのアクセス速度とキャッシュヒット率を向上させることができます。
最後に、アーキテクチャに関しては、E5-2640 v3はより高度なHaswellアーキテクチャを採用しており、E7-4807は旧いNehalemアーキテクチャを採用しています。HaswellアーキテクチャはNehalemアーキテクチャと比較して性能が向上しているため、これもE5-2640 v3のシングルスレッドでのデータ処理時の性能向上に影響を与える可能性があります。
したがって、総合的に考えると、シングルスレッドでループ処理を行うシナリオでは、E5-2640 v3はE7-4807よりも優れたパフォーマンスを発揮すると考えられます。ただし、具体的なパフォーマンスの違いは、データ処理のアルゴリズム、メモリ帯域幅、システム負荷など、さまざまな要因によって影響を受けるため、個別の問題に対して具体的に分析する必要があります。&lt;/p&gt;
&lt;h2 id=&#34;ハードウェア情報&#34;&gt;ハードウェア情報
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cpubenchmark.net/compare/3786.2vs2365.2/%5BDual-CPU%5D-Intel-Xeon-E7%e2%80%934807-vs-%5BDual-CPU%5D-Intel-Xeon-E5-2640-v3&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cpubenchmark.net/compare/3786.2vs2365.2/%5BDual-CPU%5D-Intel-Xeon-E7–4807-vs-%5BDual-CPU%5D-Intel-Xeon-E5-2640-v3&lt;/a&gt;
| 価格 | オンライン検索 $78 - 購入 |  |&lt;/p&gt;
&lt;h2 id=&#34;ハードウェア仕様&#34;&gt;ハードウェア仕様
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Intel Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Intel Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ハードウェア仕様-1&#34;&gt;ハードウェア仕様
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ハードウェア仕様-2&#34;&gt;ハードウェア仕様
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Intel Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Intel Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ハードウェア仕様-3&#34;&gt;ハードウェア仕様
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Intel Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Intel Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ハードウェア仕様-4&#34;&gt;ハードウェア仕様
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ハードウェア仕様-5&#34;&gt;ハードウェア仕様
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Intel Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Intel Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ハードウェア仕様-6&#34;&gt;ハードウェア仕様
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ハードウェア仕様-7&#34;&gt;ハードウェア仕様
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Intel Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Intel Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ハードウェア仕様-8&#34;&gt;ハードウェア仕様
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Intel Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Intel Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ハードウェア情報-1&#34;&gt;ハードウェア情報
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;初登場&lt;/td&gt;
&lt;td&gt;Q3 2020&lt;/td&gt;
&lt;td&gt;Q3 2014&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ハードウェア仕様-9&#34;&gt;ハードウェア仕様
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Intel Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Intel Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;サンプル数&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;46&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ハードウェア仕様-10&#34;&gt;ハードウェア仕様
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Intel Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Intel Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ハードウェア仕様-11&#34;&gt;ハードウェア仕様
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ハードウェア仕様-12&#34;&gt;ハードウェア仕様
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;仕様&lt;/th&gt;
&lt;th&gt;Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
</description>
        </item>
        <item>
        <title>プロンプトエンジニア</title>
        <link>https://ttf248.life/ja/p/prompt-engineer/</link>
        <pubDate>Sun, 26 Mar 2023 20:46:53 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/prompt-engineer/</guid>
        <description>&lt;p&gt;例として、かつて検索エンジンのテクニックを学んだように、私たちはまた、&lt;code&gt;AI&lt;/code&gt;とコミュニケーションするためのテクニックも習得する必要がある。合理的な制約条件を与え、効率的に必要な答えを得る方法を学ぶのだ。&lt;/p&gt;
&lt;p&gt;もし角度を変えて考えると、現在の&lt;code&gt;AI&lt;/code&gt;は記憶力に優れた小さな子供であり、完璧に暗記し、宿題をコピーできる能力を持っている。私たちがやるべきことは、&lt;code&gt;AI&lt;/code&gt;と正確かつ効果的にコミュニケーションする方法を学び、要求を正確に記述することで、&lt;code&gt;AI&lt;/code&gt;が期待される結果を生み出すのを助けることだ。&lt;/p&gt;
&lt;h2 id=&#34;科学普及&#34;&gt;科学普及
&lt;/h2&gt;&lt;p&gt;話題となっている&lt;code&gt;AI&lt;/code&gt;（人工知能）を具体的に言うと&lt;code&gt;Generative Pre-Training&lt;/code&gt;（生成事前学習）です。これはインターネット上で利用可能なデータを用いてテキスト生成を行う深層学習モデルであり、質問応答、テキスト要約生成、機械翻訳、分類、コード生成、対話型AIなど様々なタスクに用いられます。現在、GPT-1、GPT-2、GPT-3、GPT-4といった異なるバージョンのモデルが存在し、それぞれが前バージョンよりも規模が大きく、性能も向上しています。&lt;/p&gt;
&lt;h2 id=&#34;到底有没有智能&#34;&gt;到底有没有智能
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;類似度が高ければ高いほど、精度も高くなる&lt;/li&gt;
&lt;li&gt;基本的な、反復性の仕事は、特定の訓練を受けることで、人工の介入が不要になる
生成式AIとは、既存のテキスト、音声、画像などのデータを活用して新しいコンテンツを作成する技術である。テキスト生成、音声合成、画像生成、対話システムなど、様々なタスクに使用できる。生成式AIの論理性は、その学習データとモデル構造に依存する。一般的に、生成式AIは一定程度、文法、論理、常識に従うことができるが、誤りや偏見、または不真実を含むコンテンツを生成することもある。そのため、生成式AIの出力は人間の判断と検証が必要であり、盲目的に信頼したり使用したりすることはできない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;プロンプトエンジニア&#34;&gt;プロンプトエンジニア
&lt;/h2&gt;&lt;p&gt;時間は流れの法則を変えない。人は潮流に適応することを学ぶ必要がある。AIを無智能で論理性に欠けるものと捉えがちだが、よく書けば使えないコードを生成することも少なくない。&lt;/p&gt;
&lt;p&gt;もし別の角度から考えると、現在のAIは記憶力に優れた幼い子供であり、丸暗記する能力を持っている。つまり、問題をコピーする能力があるのだ。私たちがやるべきことは、AIに対して適切で効果的かつ正確なコミュニケーションを学び、要求を明確に記述し、AIが期待される結果を生み出すのを支援することだ。&lt;/p&gt;
&lt;h2 id=&#34;対話モデル&#34;&gt;対話モデル
&lt;/h2&gt;&lt;p&gt;2年前、GitHub Copilotの発表は誰も予想していませんでした。その結果、OpenAIが横空に出現し、人類は大規模言語モデルの能力を認識するに至りました。&lt;/p&gt;
&lt;p&gt;コメントベースのプログラミングと対話ベースのプログラミングに基づき、インタラクティブなロジックは完全に異なり、対話のパターンは初心者ユーザーにとって親しみやすく、NewBingが各質問の後に提示するフォローアップのヒントは必須です。Microsoftは、AI知識ベースにあるより多くのコンテンツを取得するために、ユーザーを誘導しようとしています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;データの前処理&lt;/li&gt;
&lt;li&gt;深層学習&lt;/li&gt;
&lt;li&gt;ニューラルネットワーク&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;栗子&#34;&gt;栗子
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 必要なライブラリをインポート
import argparse
import logging
import multiprocessing
import os

from PIL import Image


# 画像をグレースケールに変換し、透明背景を維持して画像を保存し、ファイルサイズを返す関数を定義します。
def convert_and_save(image_file):
    # 画像を開く
    try:
        image = Image.open(image_file)
    except Exception as e:
        logging.error(f&amp;quot;画像 {image_file} のオープンに失敗しました：{e}&amp;quot;)
        return None, None
    # 画像のモードを取得します。RGBA モードの場合、透明背景があります。
    mode = image.mode
    if mode == &amp;quot;RGBA&amp;quot;:
        # 画像と同じサイズの白い背景画像を生成します。
        background = Image.new(&amp;quot;RGB&amp;quot;, image.size, (255, 255, 255))
        # 元の画像に背景を貼り付け、透明ピクセルを無視します。
        background.paste(image, mask=image.split()[3])
        # 合成された画像をグレースケールモードに変換します。
        gray_image = background.convert(&amp;quot;L&amp;quot;)
        # グレースケール画像をRGBAモードに戻して透明背景を維持します。
        final_image = gray_image.convert(&amp;quot;RGBA&amp;quot;)
    else:
        # RGBA モードでない場合は、画像が直接グレースケールモードに変換されます。
        final_image = image.convert(&amp;quot;L&amp;quot;)
    # 元の画像のファイル名と拡張子を取得します。
    file_name, file_ext = os.path.splitext(image_file)
    # 新しい画像のファイル名を定義し、_bw サフィックスを追加して黒白であることを示します。
    new_file_name = file_name + &amp;quot;_bw&amp;quot; + file_ext
    # 新しい画像を保存し、品質を最適化してファイルサイズを削減します。
    try:
        final_image.save(new_file_name, optimize=True)
    except Exception as e:
        logging.error(f&amp;quot;{new_file_name} の保存に失敗しました：{e}&amp;quot;)
        return None, None
    # 元の画像と新しい画像のファイルサイズを取得し、返します。
    old_size = os.path.getsize(image_file)
    new_size = os.path.getsize(new_file_name)
    return file_name, old_size, new_size

# コマンドライン引数を解析し、フォルダパスと拡張名リストを返す関数を定義します。
def parse_args():
    # 解析器オブジェクトを作成します。
    parser = argparse.ArgumentParser(description=&amp;quot;画像を黒白に変換し、品質を最適化します。&amp;quot;)
    # 位置パラメータを追加してフォルダパスを指定します。
    parser.add_argument(&amp;quot;folder_path&amp;quot;, help=&amp;quot;画像が含まれるフォルダーのパスです。&amp;quot;)
    # オプションパラメータを追加して拡張名リストを指定します。デフォルトは png, jpg, jpeg, gif です。
    parser.add_argument(&amp;quot;-e&amp;quot;, &amp;quot;--extensions&amp;quot;, nargs=&amp;quot;+&amp;quot;, default=[&amp;quot;.png&amp;quot;, &amp;quot;.jpg&amp;quot;, &amp;quot;.jpeg&amp;quot;, &amp;quot;.gif&amp;quot;], help=&amp;quot;画像ファイルの拡張子です。&amp;quot;)
    # コマンドライン引数を解析し、結果オブジェクトを返します。
    args = parser.parse_args()
    return args.folder_path, args.extensions

# 変換前後のファイルサイズの違いを出力する関数を定義します。
def print_result(result):
    # 結果が空でない場合、変換と保存が成功したことを示します。
    if result:
        # 結果をファイル名とファイルサイズのタプルに分解します。
        if len(result) == 3:
            file, old_size, new_size = result
            # コントロールパネルで変換前後のファイルサイズの違いを出力します。
            logging.info(f&amp;quot;{file}: {old_size} バイト -&amp;gt; {new_size} バイト&amp;quot;)
        else:
            # 結果を出力します。
            logging.info(f&amp;quot;{result}&amp;quot;)

# 日志記録器を設定し、ログをコンソールとファイルに出力し、ログレベルを INFO に設定します。
logging.basicConfig(level=logging.INFO,
                    format=&amp;quot;%(asctime)s %(levelname)s %(message)s&amp;quot;,
                    handlers=[logging.StreamHandler(),
                              logging.FileHandler(&amp;quot;log.txt&amp;quot;)])

# # 別のプロセスに、パイプを介して渡されたコードを実行するように通知されます。これは、`--multiprocessing-fork` コマンドライン引数を渡すことで行われます。
# `freeze_support()` 関数の実装を見ると、それが実行されているプロセスの確認と、パイプを介して渡されたコードの実行が必要かどうかを確認するタスクを実行します。
# `multiprocessing.freeze_support()`

# コア数に基づいてコンピューターに自動的にプロセスを割り当てるプロセスプールを作成します。
# プロセスプール = multiprocessing.Pool()
# 异步タスクの結果オブジェクトを格納するための空のリストを作成します。
# results = []
# フォルダー内のすべてのファイルに対して反復処理を行います。
# for file in os.listdir(folder_path):
#     # ファイルパスを結合します。
#     file_path = os.path.join(folder_path, file)
#     # 拡張子リストに基づいて画像ファイルを判断します。必要に応じて拡張子リストを変更できます。
#     if any(file_path.endswith(ext) for ext in extensions):
#         # 関数を呼び出して、画像を変換して保存し、ファイルサイズを取得します。パイプを介したコードの実行は、メインプロセスをブロックすることなく、非同期で行われます。
#         result = pool.apply_async(convert_and_save, args=(file_path,), callback=print_result)
#         # 結果オブジェクトをリストに追加します。
#         results.append((file, result))
# プロセスプールを閉じ、新しいタスクの受け入れをやめます。
# pool.close()
# すべてのタスクが完了するまで待ちます。
# pool.join()

## 終わりに

ローカル開発が `windows` システムであるため、AI が最初に提示した回答には `main` 関数も `multiprocessing.freeze_support` も含まれておらず、エラーが発生しました。質問を重ねることでエラーの原因を特定し、コードを修正しました。

かつて検索エンジンの技術を学ぶように、AI とコミュニケーションする上でも、適切な制約条件を与え、効率的に必要な回答を得るためのスキルを習得する必要があります。

注意：**もしあなたがプログラミング初心者であれば、提示されたコメントと合わせて理解できない点がある場合は、引き続き関連コードについて質問してください。**&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>微信ミニプログラムの背景と開発環境</title>
        <link>https://ttf248.life/ja/p/wechat-mini-program-background-and-development-environment/</link>
        <pubDate>Fri, 24 Mar 2023 21:59:11 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/wechat-mini-program-background-and-development-environment/</guid>
        <description>&lt;p&gt;WeChat Mini Program Introduction and Development Preparation&lt;/p&gt;
&lt;h2 id=&#34;なぜミニプログラムが存在するのか&#34;&gt;なぜミニプログラムが存在するのか
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;より良い体験：埋め込みウェブの読み込みが遅延し、白画面になる問題を解決。ネイティブアプリの方がより高速にロードできる。&lt;/li&gt;
&lt;li&gt;規範と管理：微信にとって、アクセスと管理を行うため。
小程序のリリース前に、微信は&lt;code&gt;SDK&lt;/code&gt;である&lt;code&gt;JSSDK&lt;/code&gt;を公開しており、微信支付や券などの微信のネイティブ機能を一部開放していた。しかし、開発者はウェブ開発言語でロジックを構築し、微信の規制を回避することができた。小程序には独自の記述言語が搭載されている。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;小プログラムとは&#34;&gt;小プログラムとは
&lt;/h2&gt;&lt;p&gt;小プログラムは、ダウンロードやインストールが不要で利用できるアプリケーションです。アプリを手の届くところに持つという夢を実現します。&lt;/p&gt;
&lt;p&gt;ユーザーはスキャンするか検索することでアプリを開き、使い終わったらすぐに終了するというコンセプト（「使ったら片付ける」の理念）も体現しています。&lt;/p&gt;
&lt;p&gt;ユーザーは、多くのアプリをインストールすることなく、いつでもどこでも利用できるというメリットがあります。また、インストールやアンインストールなどの手間がかかりません。&lt;/p&gt;
&lt;h2 id=&#34;ミニアプリとモバイルアプリケーションの違い&#34;&gt;ミニアプリとモバイルアプリケーションの違い
&lt;/h2&gt;&lt;p&gt;インストール不要、メモリを消費しない、拡散が容易：スキャンコード、ミニアプリカード、そーいちょうすう&lt;/p&gt;
&lt;h2 id=&#34;小程序が何ができるか&#34;&gt;小程序が何ができるか
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;コンテンツツール：知乎熱榜、微博热门、摩拜单车、今日头条、腾讯地图、腾讯翻訳&lt;/li&gt;
&lt;li&gt;小売：拼多多、京东购物、蘑菇街、每日优鲜、小米商城、屈臣氏&lt;/li&gt;
&lt;li&gt;ゲーム：跳一跳、欢乐斗地主、欢乐麻将、斗鱼直播、YY直播&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;2018年のコース内容。現在までに一部のアプリベンダーが倒産しているものもあります。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;開発準備&#34;&gt;開発準備
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;小プログラムアカウントの登録：通常通り情報を入力して登録し、メールに記載された有効化リンクをクリックします。&lt;/li&gt;
&lt;li&gt;情報登録&lt;/li&gt;
&lt;li&gt;小プログラム管理後台へのログイン&lt;/li&gt;
&lt;li&gt;小プログラム情報の充実&lt;/li&gt;
&lt;li&gt;開発者との連携：個人開発者は、ログインに使用するWeChatのIDを管理者アカウントとして使用し、追加の設定は不要です。
メールには制限があり、新しいメールアドレスが必要です。しかし、QQメールで別名を登録でき、WeChat後台での検証はありません。試行錯誤の結果、小プログラムの名前は複雑になりやすく、商標に関わる場合は審査に通りにくい可能性があります。
サービスカテゴリーを選択することも、必要に応じて追加することもできます。1つの小プログラムには最大5つのカテゴリーを追加できます。
設定画面では、小プログラムの&lt;code&gt;ID&lt;/code&gt;を確認でき、メッセージプッシュも有効化できます。メッセージプッシュを有効化すると、メッセージテンプレート機能を使用できます。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;開発者ツール筆者談&#34;&gt;開発者ツール（筆者談）
&lt;/h2&gt;&lt;p&gt;正常にダウンロードおよびインストールでき、特別な注意点はなく、概要を把握するだけで、すぐにゲストモードでアクセスします。モバイルデバッグを有効にするには、つまり小程序的開発バージョンを確認するには、小程序的開発者にログインし、設定をクリックしてプロジェクトの詳細から指定された小程序的&lt;code&gt;ID&lt;/code&gt;に切り替える必要があります。&lt;/p&gt;
&lt;h2 id=&#34;コード構造&#34;&gt;コード構造
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;js: 相互作用ロジック&lt;/li&gt;
&lt;li&gt;json: データ設定&lt;/li&gt;
&lt;li&gt;wxml: 界面の要素&lt;/li&gt;
&lt;li&gt;wxss: 界面のスタイル&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>オフィスへの引っ越しにより、サーバーにアクセスできなくなりました。</title>
        <link>https://ttf248.life/ja/p/office-move-server-inaccessible/</link>
        <pubDate>Sat, 11 Mar 2023 01:42:05 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/office-move-server-inaccessible/</guid>
        <description>&lt;p&gt;行政通知、オフィス配置の変更（元の2階から15階への移動）、通常の事務室の移転&lt;/p&gt;
&lt;h2 id=&#34;デザインセンス&#34;&gt;デザインセンス
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/office-move-server-inaccessible/20230311014537.png&#34;
	width=&#34;511&#34;
	height=&#34;916&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;オフィスビル&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;55&#34;
		data-flex-basis=&#34;133px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;移住&#34;&gt;移住
&lt;/h2&gt;&lt;p&gt;荷造り、スムーズな進路、新しい作業場所でのPCの配線整理、心地よい姿勢で仕事を開始
(ÒωÓױ)！、ネットワークケーブルを接続し、チームメンバーがよく使うサーバーにアクセスできなくなりました。無線LANに切り替えてみましたが、正常に戻りました。
当初はサーバーのIPアドレス設定の問題だと思っていました。新しい作業場所の有線LANは、ファイアウォール設定のリストに含まれていませんでした。IT担当者に連絡して調整したら解決しました。このIPアドレス範囲は、他のサーバーにも使用されており、他のサーバーにアクセスしても正常でした。徐々に疑問が生じ始めました。専門的なことは専門家に任せるべきです。最終的に運用部門の同僚が特定し、このサーバーに&lt;code&gt;docker&lt;/code&gt;がデプロイされているため、サービスのデフォルトネットワーク&lt;code&gt;docker0&lt;/code&gt;とオフィスLANの設定IPアドレス範囲が競合してしまい、送信したデータパケットを受信できなくなり、ルーティングされて&lt;code&gt;docker&lt;/code&gt;サービスに渡りました。
他のサーバーには&lt;code&gt;docker&lt;/code&gt;サービスがデプロイされていないため、このサーバーだけでした。私がよく使うので、時々コンテナを使用してテストサービスをデプロイすることがありましたが、このような状況に遭遇したとは思いませんでした。後から考えると、グループ全体が同じオフィスビル内に存在しているため、IT部門の同僚がIPアドレス範囲を割り当てたことは珍しくありません。&lt;/p&gt;
&lt;h2 id=&#34;docker0&#34;&gt;docker0
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# vim /etc/docker/daemon.json
{
    &amp;quot;bip&amp;quot;:&amp;quot;172.200.0.1/24&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;サービスを再起動し、新しいネットワークに切り替えると、サーバーが正常にアクセスできるようになりました。&lt;/p&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://yeasy.gitbook.io/docker_practice/advanced_network/docker0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Docker入門から実践 - docker0&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>組み込みシステム入門編１ - プロフェッショナルな用語集</title>
        <link>https://ttf248.life/ja/p/embedded-entry-professional-terms/</link>
        <pubDate>Tue, 07 Mar 2023 13:42:36 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/embedded-entry-professional-terms/</guid>
        <description>&lt;p&gt;組み込みシステムについて言及すると、脳裏に浮かぶのは、かつて学校の実験室で使っていた51ジャンク機とファルコムのイメージです。&lt;/p&gt;
&lt;p&gt;LPA3399Proは、瑞芯微RK3399Proプラットフォームをベースに開発されたビジュアルホストであり、大量の視覚演算が必要な携帯型コンピューティングホスト向けに設計されています。NPU（ニューラルプロセッシングユニット）内蔵で、3.0TOPSの演算能力を持ち、多様なアルゴリズムモデルに対応しています。&lt;/p&gt;
&lt;p&gt;RV1109は、瑞芯微におけるAI分野の機械視覚ブランチ向けのSoC（システムオンチップ）であり、独立したNPUを搭載しています。RV1109は、1TOPSの演算能力を提供します。&lt;/p&gt;
&lt;h2 id=&#34;system-on-chip&#34;&gt;System on Chip
&lt;/h2&gt;&lt;p&gt;SoC は System on a Chip の略で、「片上システム」を意味します。これは、複数の電子システムを 1 つのチップに統合する技術です。この技術により、電子製品のサイズと重量を大幅に削減すると同時に、性能を向上させ、消費電力を低減することができます。&lt;/p&gt;
&lt;p&gt;SoC（System on a Chip）および CPU（Central Processing Unit）は、コンピュータシステムの重要な構成要素ですが、その間にはいくつかの違いがあります。&lt;/p&gt;
&lt;p&gt;CPU は、コンピュータシステムの中核となるプロセッサであり、プログラムの命令を実行します。通常、演算ユニット、制御ユニット、レジスタなどの基本的な部品のみを含みます。&lt;/p&gt;
&lt;p&gt;一方、SoC は、CPU 以外にもメモリ、グラフィックス プロセッサ、入出力インターフェースなど、他のコンポーネントを 1 つのチップに統合します。これにより、電子製品のサイズと重量を大幅に削減し、性能を向上させ、消費電力を低減することができます。&lt;/p&gt;
&lt;p&gt;まとめると、CPU は SoC の構成要素であり、SoC はより複雑で、集積度の高い電子システムです。&lt;/p&gt;
&lt;h2 id=&#34;マイクロコントローラユニット-microcontroller-unit&#34;&gt;マイクロコントローラユニット (Microcontroller Unit)
&lt;/h2&gt;&lt;p&gt;SoC（System on a Chip）と MCU（Microcontroller Unit）は、複数の電子システムを1つのチップに統合する技術ですが、両者にはいくつかの違いがあります。&lt;/p&gt;
&lt;p&gt;MCU はマイクロコントローラの一種で、通常、CPU、メモリ、入出力インターフェースなどの基本的な部品が含まれています。これは、家電製品や自動車電子システムなど、他の電子機器を制御するために一般的に使用されます。&lt;/p&gt;
&lt;p&gt;一方、SoC（System on a Chip）は、MCU の基本的な部品に加えて、グラフィックスプロセッサや無線通信モジュールなど、さらに多くの電子システムを1つのチップに統合します。これにより、電子製品のサイズと重量を大幅に削減し、同時に性能を向上させ、消費電力を低減することができます。&lt;/p&gt;
&lt;p&gt;まとめると、MCU はシンプルなマイクロコントローラであり、SoC はより複雑で、統合度が高い電子システムです。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>AIによるプログラミング支援、生産性の進化</title>
        <link>https://ttf248.life/ja/p/ai-assisted-programming-productivity-evolution/</link>
        <pubDate>Tue, 28 Feb 2023 17:05:17 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/ai-assisted-programming-productivity-evolution/</guid>
        <description>&lt;p&gt;GitHub Copilot のリリースからわずか 2 年しか経っていないのに、ChatGPT が登場し、裏にある原理をよく理解していない状態で、しばらく使ってみた。2 つのツールのサポートレベルは完全に異なり、どちらも生産性を大幅に向上させた。&lt;/p&gt;
&lt;p&gt;あまりにも複雑なことについては、AI ではまだできないだろう。なぜなら、彼らは論理がなく、パターンや形式固定されたもの、あるいは范式を定めているからだ。学習データは十分で、AI の効果は 9 分満点になる。&lt;/p&gt;
&lt;h2 id=&#34;github-copilot&#34;&gt;GitHub Copilot
&lt;/h2&gt;&lt;p&gt;リリース時に、公式サイトの紹介の &lt;code&gt;demo&lt;/code&gt; を見ると、あまり賢くなく、試用してみましたが、使い勝手が良くありませんでしたので、諦めました。
2022年以前に、暇つぶしで切り替えて新バージョンを体験したところ、かなり良くなっており、ただ国内の速度が少し遅いのは、ネットワークの問題である可能性が高いです。&lt;code&gt;Python&lt;/code&gt;のような言語では、コメントに基づいて書かれたコードもそれなりによくできており、自分で資料を探して書いていたよりもはるかに速かったです。&lt;/p&gt;
&lt;h2 id=&#34;chatgpt&#34;&gt;ChatGPT
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Github Copilot&lt;/code&gt;は、プログラマー、つまり開発者の視点から製品を設計しており、プログラミングの知識が必要であり、コメントを通じてAIによるコーディング支援を誘導していくものでした。
&lt;code&gt;ChatGPT&lt;/code&gt;は次の段階に進み、&lt;strong&gt;専門家でなくてもすぐに使いこなせるように設計されています&lt;/strong&gt;。対話形式でのチャットインターフェースにより、質問や要件の説明、理解できない場合は引き続き質問することができます。&lt;/p&gt;
&lt;p&gt;例えば、品詞分割の概念を知っているものの、コーディング方法がわからない状態で、文字列の類似度を計算したい場合を考えてみましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Python 品詞分割 維天運通 LOGORY と 合肥維天運通情報科技股份有限公司 2 つの文字列の類似度を計算します。
比較前に、文字列を英語小文字に変換するなどして統一処理を行います。
2 番目の文字列の中に最初の文字列の最初の文字が見つかれば、2 番目の文字列を最初の文字列の長さと同じ長さで切り捨てます。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;こんにちは、これはBingです。😊
オンラインの情報123に基づき、Python の品詞分割には &lt;code&gt;jieba&lt;/code&gt; などのライブラリを使用できます。&lt;code&gt;jieba&lt;/code&gt; ライブラリは、精密モード、全模式、検索エンジンモードの 3 つの分詞モードをサポートしています。要件に応じて適切なモードを選択できます。
文字列の類似度を比較するには、まず文字列を品詞分割し、その後の単語ベクトルまたは編集距離などの指標を計算する必要があります。&lt;code&gt;numpy&lt;/code&gt; や &lt;code&gt;scipy&lt;/code&gt; などのライブラリを使用して数学演算を行うことができます。
文字列を統一的に処理するために、英語を小文字に変換するには、Python の組み込み関数 &lt;code&gt;lower()&lt;/code&gt; を使用できます。
2 番目の文字列を切り出すには、Python のスライス操作符 &lt;code&gt;[ ]&lt;/code&gt; を使用できます。&lt;/p&gt;
&lt;p&gt;以下は、その際のコード例です。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import jieba
import numpy as np
from scipy.spatial.distance import cosine

# 定義する 2 つの文字列
str1 = &amp;quot;維天運通 LOGORY&amp;quot;
str2 = &amp;quot;合肥維天運通情報科技股份有限公司&amp;quot;

# 統一処理：英語を小文字に変換
str1 = str1.lower()
str2 = str2.lower()

# 2 番目の文字列の中に最初の文字列の最初の文字が見つかる位置を探す
index = str2.find(str1[0])

# 見つかった場合、2 番目の文字列を切り出す
if index != -1:
    str2 = str2[index:index+len(str1)]

# jieba 库を使用して文字列を品詞分割する
words1 = list(jieba.cut(str1))
words2 = list(jieba.cut(str2))

# 2 つの文字列の単語ベクトル（頻度を重みとして使用）を計算する
vector1 = np.zeros(len(words1))
vector2 = np.zeros(len(words1))

for i, word in enumerate(words1):
    vector1[i] += 1 # 最初の文字列内の各単語の出現回数をカウント
    if word in words2:
        vector2[i] += 1 # 2 番目の文字列内の各単語の出現回数をカウント

# 2 つの文字列の類似度（余弦距離を指標として使用）を計算する
similarity = 1 - cosine(vector1, vector2)

print(&amp;quot;2 つの文字列の類似度は：&amp;quot;, similarity)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;さらに、結果を確認し、問題点を発見します。結果はランダムで、実際のコードを実行していませんが、良い結果を提供します。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;栗子&#34;&gt;栗子
&lt;/h3&gt;&lt;p&gt;質問：SQL文で、製品コードテーブルから、製品コードが80000～89999の範囲にあるレコードを抽出するには？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;こんにちは、Bingです。😊

検索結果12によると、指定された範囲内の値を選択するために、BETWEEN演算子を使用できます。BETWEEN演算子は、開始値と終了値を両方含みます。

まず、クエリするテーブル名と列名を指定し、WHERE句でBETWEEN演算子と範囲値を指定する必要があります。

たとえば、製品コードが80000から89999の範囲にある製品コードテーブルからレコードを抽出するには、次のステートメントを使用できます。

SELECT * FROM product_code
WHERE code BETWEEN 80000 AND 89999;
ここで、*はすべての列3を選択します。特定の列（たとえば、製品名と価格）のみを選択する場合は、カンマで区切って指定できます。例えば：

SELECT name, price FROM product_code
WHERE code BETWEEN 80000 AND 89999;
これで役に立つことを願っています。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;さらに質問します。否定して：製品コードは文字列であり、あなたのコードは間違っています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;申し訳ありませんが、製品コードが文字列であることに気づいていませんでした。もしそうであれば、範囲の値の前後にはシングルクォートを追加する必要があります。例えば：

SELECT * FROM product_code
WHERE code BETWEEN &#39;80000&#39; AND &#39;89999&#39;;
私の誤りを許してください。🙏
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;おめでとうございます。正しく認識します。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>いくつかのGitコマンドのまとめ</title>
        <link>https://ttf248.life/ja/p/less-common-git-commands-summary/</link>
        <pubDate>Fri, 17 Feb 2023 10:08:57 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/less-common-git-commands-summary/</guid>
        <description>&lt;p&gt;あまり使わないけれど非常に便利な &lt;code&gt;git&lt;/code&gt; コマンド&lt;/p&gt;
&lt;h3 id=&#34;システムを再インストールした結果windows上のフォルダーの所有権が変更されました&#34;&gt;システムを再インストールした結果、Windows上のフォルダーの所有権が変更されました。
&lt;/h3&gt;&lt;p&gt;新しいバージョンのGitにはセキュリティチェックが追加され、不安全であると警告が表示されるため、操作できなくなりました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global --add safe.directory
git config --global --add safe.directory &amp;quot;*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;ユーザーの新しいコンピューターにアカウントとパスワード情報を保存する&#34;&gt;ユーザーの新しいコンピューターにアカウントとパスワード情報を保存する
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global credential.helper store
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;保存された情報が更新が必要な場合は、まず古い認証情報を削除してください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --system --unset credential.helper
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>- コンパイラ
- コールバック関数
- パフォーマンステスト</title>
        <link>https://ttf248.life/ja/p/compiler-callback-performance-testing/</link>
        <pubDate>Wed, 15 Feb 2023 13:59:25 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/compiler-callback-performance-testing/</guid>
        <description>&lt;p&gt;昨年、SDKを設計し、イベントのパッキング処理を担当しました。外部に対してはクラスインターフェースを提供し、サービス初期化時に呼び出し元が対応するクラスを実装し、オブジェクトポインタをモジュールに渡します。&lt;/p&gt;
&lt;p&gt;C11にも触れており、好奇心で猫が死ぬように、これらのインターフェースをlambda関数オブジェクトのコールバックとして実現するとどうなるのか、純粋仮想関数インターフェース定義方法と比較して、より柔軟になるのか試してみようと考えました。&lt;/p&gt;
&lt;p&gt;疑問が生じました。2つの異なる構文、性能面からどちらが速いのか不明です。コンパイラ原理は理解していないので、コードを書いて試してみます。&lt;/p&gt;
&lt;h2 id=&#34;はじめに&#34;&gt;はじめに
&lt;/h2&gt;&lt;p&gt;オンラインのURLで、異なるコンパイラを選択したり、コンパイルパラメータを設定したり、&lt;code&gt;linux&lt;/code&gt;プラットフォーム上でコードを実行したり、対応するアセンブリコードを確認したりできます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt;：時々技術検証のために、ウェブ上で小さなコードスニペットを実行するのは非常に便利です。&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://godbolt.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://godbolt.org/&lt;/a&gt;：異なる色でアセンブリコードと対応するコードを区別できるため、ローカルのデバッガよりもさらに便利です。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;本文&#34;&gt;本文
&lt;/h2&gt;&lt;p&gt;標準委員会が定める文法規則について、コンパイルレベルにおいてどのように実現するかは、各社のコンパイラに依存します。この点については、特にマイクロソフトのコンパイラは非常に優れていると言わざるを得ません。文法糖衣は万能ではなく、コールバックインターフェースが少ないこと、ラムダ式を使用することでより便利であり、空のコールバック関数インターフェースを定義する必要がないことが挙げられます。コールバックインターフェースの種類が多い場合には、従来の仮想関数の方がビジネスインターフェースの統一に有利です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windowsプラットフォームでは、両者の性能はほぼ同等で、大きな違いはありません。&lt;/li&gt;
&lt;li&gt;Linuxプラットフォームでは、仮想関数とラムダ式を比較すると、単回りは1.35ns増加します。
通常のビジネスシステム開発においては、この程度の性能損失は無視できる範囲内であり、ラムダ式を使用することで、設計面での利便性が向上します。特に多重信号処理を行う場合には顕著であり、底层にはイベントトリガーがあり、ログ出力が必要な場合、ログオブジェクトへの処理関数を呼び出します。より多くのビジネス処理インターフェースが必要な場合には、底层で&lt;code&gt;vector&lt;/code&gt;にラムダオブジェクトを保存し、イベントトリガー時に順次呼び出しを行います。これはQTのシグナルとスロットに類似しており、ログ、監視、ビジネス1、ビジネス2といったものが完全に疎結合です。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;コード&#34;&gt;コード
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;カウンター：1000000
時間：3966us
カウンター：1000000
時間：5316us
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;memory&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;atomic&amp;gt;
#include &amp;lt;string&amp;gt;

std::atomic_int64_t カウンター = 0;

// 回呼インターフェースを定義
class UserInterface
{
public:
    virtual void name() = 0;
    virtual void full_name() = 0;
};

class User : public UserInterface
{
public:
    void name() {}
    void full_name() { カウンター++; }
};

void to_string(UserInterface* user)
{
    user-&amp;gt;name();
    user-&amp;gt;full_name();
}

using name_handler = std::function&amp;lt;void()&amp;gt;;
using full_name_handler = std::function&amp;lt;void()&amp;gt;;

class Test
{
    name_handler name_;
    full_name_handler full_name_;

public:
    void set_name_handler(name_handler name)
    {
        name_ = name;
    }

    void set_full_name_handler(full_name_handler full_name)
    {
        full_name_ = full_name;
    }

    void to_string()
    {
        name_();
        full_name_();
    }
};

int main()
{
    User user;

    auto start = std::chrono::high_resolution_clock::now();

    for (int i = 0; i &amp;lt; 1000000; i++)
    {
        to_string(&amp;amp;user);
    }

    auto end = std::chrono::high_resolution_clock::now();
    std::cout &amp;lt;&amp;lt; &amp;quot;カウンター： &amp;quot; &amp;lt;&amp;lt; カウンター &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;時間： &amp;quot; &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(end - start).count() &amp;lt;&amp;lt; &amp;quot;us&amp;quot; &amp;lt;&amp;lt; std::endl;

    counter = 0;
    auto name = []() {};
    auto full_name = []() { カウンター++; };

    Test test;
    test.set_name_handler(name);
    test.set_full_name_handler(full_name);

    start = std::chrono::high_resolution_clock::now();

    for (int i = 0; i &amp;lt; 1000000; i++)
    {
        test.to_string();
    }

    end = std::chrono::high_resolution_clock::now();
    std::cout &amp;lt;&amp;lt; &amp;quot;カウンター： &amp;quot; &amp;lt;&amp;lt; カウンター &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;時間： &amp;quot; &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(end - start).count() &amp;lt;&amp;lt; &amp;quot;us&amp;quot; &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;付録
gist.githubusercontent.com/benloong/8050171/raw/fa577ec923b460862078b8b40233a42a1c619eeb/functionperformance.cpp のようなコードスニペットを参考にしました。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;memory&amp;gt;
#include &amp;lt;functional&amp;gt;

using namespace std;
using namespace std::chrono;

class Base
{
public:
	Base(){}
	virtual ~Base(){}
	virtual int func(int i) = 0;
};

class Derived : public Base
{
public:
	Derived(int base = 10) : base{base}
	{

	}
	~Derived(){}

	virtual int func(int i)
	{
		return i*base;
	}
private:
	int base;
};

struct Func
{
	int base;
	int operator()(int i)
	{
		return i*base;
	}
	Func(int base) : base {base}
	{

	}
};
const int base = 10;
int calculate(int i)
{
	return base*i;
}

int main()
{
	const int num = 10000;
	Base *p = new Derived{10};
	int total = 0;
	auto start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += p-&amp;gt;func(i);
	}
	auto end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nvirtual call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;

	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += calculate(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\ndirect function call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;

	Func functor{10};
	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += functor(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nfunctor call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;
	int base = 10;
	function&amp;lt;int(int)&amp;gt; lambda = [base](int i)
	{
		return i*base;
	};
	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += lambda(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nlambda call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;
	return 0;
}

/*
test on mac mini i7 2.7GHz
clang++ -std=c++11 chronotest.cpp -O0
output:
result: 499950000
virtual call elapsed: 	43171 nanoseconds.

result: 499950000
direct function call elapsed: 	31379 nanoseconds.

result: 499950000
functor call elapsed: 	41497 nanoseconds.

result: 499950000
lambda call elapsed: 	207416 nanoseconds.
===================================================
clang++ -std=c++11 chronotest.cpp -O1
output:
result: 499950000
virtual call elapsed: 	261 ```
/*
*/

ここに、通常の関数と汎関数（ラムダ式）があり、コールバックインターフェースによる比較と直接呼び出しのパフォーマンスの違いは桁違いです。汎関数は関数に近いため、場合によっては汎関数のパフォーマンスが優れています。コンパイラの仕組みについては知識が不足しており、変数へのアクセスアドレスや関数が隣接していることがCPU処理を有利にするという推測です。

wandboxの結果を添付します。
``` - 付録
コードスニペット [functionperformance.cpp](https://gist.githubusercontent.com/benloong/8050171/raw/fa577ec923b460862078b8b40233a42a1c619eeb/functionperformance.cpp) を見つけました。

```c++
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;memory&amp;gt;
#include &amp;lt;functional&amp;gt;

using namespace std;
using namespace std::chrono;

class Base
{
public:
	Base(){}
	~Base(){}
	virtual int func(int i) = 0;
};

class Derived : public Base
{
public:
	Derived(int base = 10) : base{base}
	{

	}
	~Derived(){}

	virtual int func(int i)
	{
		return i*base;
	}
private:
	int base;
};

struct Func
{
	int base;
	int operator()(int i)
	{
		return i*base;
	}
	Func(int base) : base {base}
	{

	}
};
const int base = 10;
int calculate(int i)
{
	return base*i;
}

int main()
{
	const int num = 10000;
	Base *p = new Derived{10};
	int total = 0;
	auto start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += p-&amp;gt;func(i);
	}
	auto end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nvirtual call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;

	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += calculate(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\ndirect function call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;

	Func functor{10};
	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += functor(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nfunctor call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;
	int base = 10;
	function&amp;lt;int(int)&amp;gt; lambda = [base](int i)
	{
		return i*base;
	};
	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += lambda(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nlambda call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;
	return 0;
}

/*
test on mac mini i7 2.7GHz
clang++ -std=c++11 chronotest.cpp -O0
output:
result: 499950000
virtual call elapsed: 	43171 nanoseconds.

result: 499950000
direct function call elapsed: 	31379 nanoseconds.

result: 499950000
functor call elapsed: 	41497 nanoseconds.

result: 499950000
lambda call elapsed: 	207416 nanoseconds.
===================================================
clang++ -std=c++11 chronotest.cpp -O1
output:
result: 499950000
virtual call

## 付録

```shell
結果: 499950000
仮想呼び出し時間: 6143 ナノ秒。

結果: 499950000
直接関数呼び出し時間: 30 ナノ秒。

結果: 499950000
ファンクタ呼び出し時間: 31 ナノ秒。

結果: 499950000
ラムダ呼び出し時間: 15134 ナノ秒。
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>ホストモード、ネットワークモード、デバッガを使用して直接観察する</title>
        <link>https://ttf248.life/ja/p/host-network-byte-order-debugger/</link>
        <pubDate>Tue, 10 Jan 2023 14:18:12 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/host-network-byte-order-debugger/</guid>
        <description>&lt;p&gt;コンピュータの発展の歴史において、データの保存方法には統一された標準は存在しませんでした。
バイトの並び方は2つの一般的なルールに従っていました。例えば、ある多桁数の低いバイトを小さいアドレスに、高いバイトを大きいアドレスに配置する場合、これを小端序と呼びます。その逆の場合、大端序と呼びます。ネットワークアプリケーションにおいては、バイトオーダーは考慮すべき重要な要素であり、異なる種類のコンピュータが異なる標準のバイトオーダーを採用している可能性があるため、すべてネットワーク標準に変換されます。
読解習慣に従うと、大端バイトオーダーは左から右への読み込み順序に合致します。&lt;/p&gt;
&lt;h2 id=&#34;プロセッサアーキテクチャhttpszhwikipediaorgwikie5ad97e88a82e5ba8f&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;プロセッサアーキテクチャ&lt;/a&gt;
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;x86、MOS Technology 6502、Z80、VAX、PDP-11などのプロセッサは小端序を採用&lt;/li&gt;
&lt;li&gt;Motorola 6800、Motorola 68000、PowerPC 970などのプロセッサは大端序を採用&lt;/li&gt;
&lt;li&gt;ARM、PowerPC（PowerPC 970を除く）、DEC Alpha、SPARC V9、MIPS、PA-RISCおよびIA64のバイトオーダーは可変式&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;网络序&#34;&gt;网络序
&lt;/h2&gt;&lt;p&gt;ネットワーク転送では一般的に大端序が採用され、ネットワークバイト序とも呼ばれ、ネットワーク序とも言います。IPプロトコルにおいて大端序はネットワークバイト序として定義されています。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Berkeley&lt;/code&gt;ソケットは、16ビットおよび32ビット整数をネットワーク序とホストバイト序間で変換するための変換関数群を定義しています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;arpa/inet.h&amp;gt;

uint32_t htonl(uint32_t hostlong); // uint32_t をネットワーク序に変換
uint16_t htons(uint16_t hostshort); // uint16_t をネットワーク序に変換
uint32_t ntohl(uint32_t netlong); // uint32_t をネットワーク序からホスト序へ変換
uint16_t ntohs(uint16_t netshort); // uint16_t をネットワーク序からホスト序へ変換
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;asio&lt;/code&gt; をネットワークライブラリとして使用する場合、組み込みの名前空間には、クロスプラットフォームに対応した関数名が用意されています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;boost::asio::detail::socket_ops::network_to_host_long&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::network_to_host_short&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::host_to_network_long&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::host_to_network_short&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;visual-studio-デバッガー&#34;&gt;Visual Studio デバッガー
&lt;/h2&gt;&lt;p&gt;デバッグモードでは、デバッグメニューを選択し、ウィンドウからメモリウィンドウにチェックを入れます。
Visual Studio では、デバッガー内で直接メモリ内のデータを表示できます（下記画像参照）。
&lt;img src=&#34;https://ttf248.life/p/host-network-byte-order-debugger/Snipaste_2023-01-10_14-44-00.png&#34;
	width=&#34;535&#34;
	height=&#34;147&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;デバッガーメニュー&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;363&#34;
		data-flex-basis=&#34;873px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;メモリの確認方法&#34;&gt;メモリの確認方法
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ウィンドウから直接変数名を表示し、対応する変数のアドレスにジャンプ&lt;/li&gt;
&lt;li&gt;変数が元のポインタ型である場合、ウィンドウで変数をダブルクリックして選択し、メモリウィンドウにドラッグすることで、対応する内容のアドレスを表示&lt;/li&gt;
&lt;li&gt;変数がポインタ型でない場合は、計算ウィンドウに追加し、アドレスを取得してから、手動でメモリウィンドウにコピー&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例を挙げて説明します&#34;&gt;例を挙げて説明します
&lt;/h3&gt;&lt;p&gt;データを受信し、&lt;code&gt;buffer&lt;/code&gt;オブジェクトに格納します。ネットワークバイトオーダーをホストバイトオーダーに変換し、&lt;code&gt;body_length&lt;/code&gt;が30になります。サーバー側では、このデータを送信するために4バイトを使用します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool NetworkMessage::decode_header()
{
    // ネットワークバイトオーダーをホストバイトオーダーに変換
    body_length_ = boost::asio::detail::socket_ops::network_to_host_long(*(int *)buffer_.data());
    return auto_reserve(body_length_);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;大端型バイトオーダー&lt;/strong&gt;: メモリウィンドウ内の&lt;code&gt;buffer_&lt;/code&gt;の内容を観察します。
&lt;img src=&#34;https://ttf248.life/p/host-network-byte-order-debugger/buffer_.png&#34;
	width=&#34;603&#34;
	height=&#34;318&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;buffer_&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;189&#34;
		data-flex-basis=&#34;455px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;小端型バイトオーダー&lt;/strong&gt;: メモリウィンドウ内の&lt;code&gt;body_length_&lt;/code&gt;の内容を観察します。
&lt;img src=&#34;https://ttf248.life/p/host-network-byte-order-debugger/body_length_.png&#34;
	width=&#34;581&#34;
	height=&#34;333&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;body_length_&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;174&#34;
		data-flex-basis=&#34;418px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>C11: sleep for vs yield</title>
        <link>https://ttf248.life/ja/p/c11-sleep-for-vs-yield/</link>
        <pubDate>Tue, 20 Sep 2022 20:54:51 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/c11-sleep-for-vs-yield/</guid>
        <description>&lt;p&gt;コードを眺めていると、&lt;code&gt;std::this_thread::yield()&lt;/code&gt; が突然視線を集めました。C11 の構文糖で、これほど多く使われていたのは初めてです。&lt;code&gt;yield&lt;/code&gt; を以前は目にすることはありませんでした。&lt;/p&gt;
&lt;p&gt;マニュアルを確認せず、まず思い浮かべたのは、それが非同期処理と関連しているのではないかということでした。&lt;code&gt;yield&lt;/code&gt; は boost 協程の実装の中に見られる単語であり、ここでは非同期処理とは関係ありません。制御ロジックは通常のスレッドに関連しています。&lt;/p&gt;
&lt;h2 id=&#34;ドキュメント&#34;&gt;ドキュメント
&lt;/h2&gt;&lt;h3 id=&#34;yield&#34;&gt;yield
&lt;/h3&gt;&lt;p&gt;この関数の正確性は、実装に依存し、特に使用されている OS のスケジューラメカニズムとシステムの状態に依存します。例えば、先入れ先出しリアルタイムスケジューラ（Linux の SCHED_FIFO）が現在のスレッドをサスペンドし、それを実行可能な同優先度のスレッドのキューの末尾に置く（同優先度で他のスレッドがない場合、yield は効果がない）といった具合です。&lt;/p&gt;
&lt;h3 id=&#34;sleep_for&#34;&gt;sleep_for
&lt;/h3&gt;&lt;p&gt;現在のスレッドの実行をブロックし、指定された &lt;code&gt;sleep_duration&lt;/code&gt; 分間少なくとも停止します。
この関数は、スケジューリングやリソース競合による遅延のため、&lt;code&gt;sleep_duration&lt;/code&gt; より長くブロックされる可能性があります。
標準ライブラリでは、安定したクロックを使用して時間を測定することをお勧めします。システム時間で実装する場合は、待機時間がクロック調整に敏感になる可能性があることに注意してください。&lt;/p&gt;
&lt;h3 id=&#34;分析&#34;&gt;分析
&lt;/h3&gt;&lt;p&gt;両方の関数は、現在のスレッドがスレッドを占有しないようにし、実行効果はプラットフォームによって異なる可能性があります。ここまでの内容でまだ少し理解が曖昧ですが、コードを実行して結果を確認してみましょう。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ThinkPad ノートパソコン（Visual Studio Community 2022）、腾讯云 S2 標準サーバー（gcc8.5）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;分析-1&#34;&gt;分析
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;実行プラットフォーム&lt;/th&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;初回/us&lt;/th&gt;
&lt;th&gt;二次/us&lt;/th&gt;
&lt;th&gt;三次/us&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;sleep_for&lt;/td&gt;
&lt;td&gt;9872&lt;/td&gt;
&lt;td&gt;1884&lt;/td&gt;
&lt;td&gt;11302&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;分析-2&#34;&gt;分析
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;実行プラットフォーム&lt;/th&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;初回/US&lt;/th&gt;
&lt;th&gt;二回目/US&lt;/th&gt;
&lt;th&gt;三回目/US&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;h3 id=&#34;分析-3&#34;&gt;分析
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;実行プラットフォーム&lt;/th&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;初回/us&lt;/th&gt;
&lt;th&gt;二回/us&lt;/th&gt;
&lt;th&gt;三回/us&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;sleep_for&lt;/td&gt;
&lt;td&gt;171&lt;/td&gt;
&lt;td&gt;168&lt;/td&gt;
&lt;td&gt;167&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;分析-4&#34;&gt;分析
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;実行プラットフォーム&lt;/th&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;初回/us&lt;/th&gt;
&lt;th&gt;二次/us&lt;/th&gt;
&lt;th&gt;三次/us&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;yield&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;td&gt;102&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;分析-5&#34;&gt;分析
&lt;/h3&gt;&lt;p&gt;実行結果から判断すると、オペレーティングシステムの異なる実装により、高精度なスリープ（休眠）時の &lt;code&gt;sleep_for&lt;/code&gt; の安定性差が非常に大きいことがわかります。高精度なスリープを実現するためには、&lt;code&gt;yield&lt;/code&gt; を使用する方が適しています。&lt;/p&gt;
&lt;p&gt;時間精度を &lt;code&gt;ms&lt;/code&gt; (ミリ秒) に向上させた場合、両者の差異はほとんど見られなくなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;thread&amp;gt;

// 別のスレッドで短い時間の“忙しいスリープ”を実行することを推奨します
void little_sleep(std::chrono::microseconds us)
{
    auto start = std::chrono::high_resolution_clock::now();
    auto end = start + us;
    do {
        std::this_thread::yield();
    } while (std::chrono::high_resolution_clock::now() &amp;lt; end);
}

int main()
{
    auto start = std::chrono::high_resolution_clock::now();

    little_sleep(std::chrono::microseconds(100));
    std::this_thread::sleep_for(std::chrono::microseconds(100));

    auto elapsed = std::chrono::high_resolution_clock::now() - start;
    std::cout &amp;lt;&amp;lt; &amp;quot;waited for &amp;quot;
              &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(elapsed).count()
              &amp;lt;&amp;lt; &amp;quot; microseconds\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参照&#34;&gt;参照
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/header/thread.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/header/thread.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/thread/sleep_for.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/thread/sleep_for.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Linuxサーバー、MySQLパスワードのリセット</title>
        <link>https://ttf248.life/ja/p/linux-server-reset-mysql-password/</link>
        <pubDate>Tue, 20 Sep 2022 14:27:35 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-server-reset-mysql-password/</guid>
        <description>&lt;p&gt;闲置の腾讯クラウドサーバーがあり、年末に契約が満了し、更新も考えていなかったので、開発用のデータベースとしてMySQLをデプロイすることにした。システムを再構築する際に、手間を省いて、腾讯クラウドから提供されている汎用イメージを選択した。すでにMySQLデータベースがインストールされていた。本来はシステム内にReadmeのようなファイルがあり、パスワードや設定ファイルの場所などを説明してくれるだろうと期待していた。&lt;/p&gt;
&lt;p&gt;腾讯クラウドのシステム再構築は非常に速く、約1分で完了通知が来た。ログインして&lt;code&gt;systemctl status mysql&lt;/code&gt;コマンドを実行したところ、MySQLサービスが起動していることが確認できた。パスワードを探し回ったがどこにも見つからず、次第に焦り始めた。&lt;/p&gt;
&lt;p&gt;そこで、サーバーにアクセスしているのであれば、root権限を使ってパスワードをリセットする方法があるはずだと考えた。資料を調べたり、阿里云フォーラムの投稿を参考にしたりして、さらに試行錯誤を続けた。&lt;/p&gt;
&lt;h2 id=&#34;パスワードのリセット&#34;&gt;パスワードのリセット
&lt;/h2&gt;&lt;p&gt;構成ファイル &lt;code&gt;vim /etc/my.cnf&lt;/code&gt; を編集し、&lt;code&gt;mysqld&lt;/code&gt; ノードに以下の設定を追加します：&lt;code&gt;skip-grant-tables&lt;/code&gt; 、&lt;code&gt;systemctl restart mysql&lt;/code&gt; コマンドを実行してデータベースを再起動します。
その後、&lt;code&gt;mysql&lt;/code&gt; を直接使用してデータベースにログインし、通常の操作が続行できます。 &lt;code&gt;root&lt;/code&gt; ユーザーのパスワードをリセットし、同時にリモートログインを許可します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;USE mysql;
UPDATE user SET authentication_string = password(&#39;pass&#39;) WHERE User = &#39;root&#39;;
GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;pass&#39; WITH GRANT OPTION;
FLUSH PRIVILEGES;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;変更した構成ファイルをロールバックし、データベースを再起動して完了です。&lt;/p&gt;
&lt;h2 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://help.aliyun.com/document_detail/42520.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://help.aliyun.com/document_detail/42520.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>自動テストに関する考察</title>
        <link>https://ttf248.life/ja/p/automated-testing-overview/</link>
        <pubDate>Thu, 04 Aug 2022 11:39:18 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/automated-testing-overview/</guid>
        <description>&lt;p&gt;金融取引システムにおけるテストへの投資は、他のシステムを大幅に上回っており、煩雑なテスト手順が繰り返し行われていました。ROI（投資対効果）は著しく低く、プロジェクトや人員の変更に伴い、不可避的に多くのコントロールできない要因が導入されました。よく見られるのは、Aインターフェースからの出力フィールドを修正するとBインターフェースの結果に影響が出るケースです。各バージョンリリースごとにリスクも蓄積されていきます。&lt;/p&gt;
&lt;h2 id=&#34;理論的知識&#34;&gt;理論的知識
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;自動化の価値をどのように測定するか？&lt;/strong&gt;
自動テストのROI = (手動実行時間) * (実行回数) / (開発コスト + メンテナンスコスト)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;どのような機能に自動テストを行うべきか？&lt;/strong&gt;
ユーザーが頻繁に使用し、頻繁に変更されない機能。このようなインターフェースに対して自動テストコードを作成することで、最大の利益が得られます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;なぜこのタイミングで自動テストを推進するか？&lt;/strong&gt;
プロジェクトのリリース直前は不適切であり、遠い水の問題を近渴（近隣の渇き）で解決しようとするのは無駄です。自動化は長期的な収益モデルであるため、最も適切なタイミングは、プロジェクトが&lt;strong&gt;本番環境&lt;/strong&gt;で稼働し、安定したリリースサイクルに入っている時点です。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;フレームワークの選択&#34;&gt;フレームワークの選択
&lt;/h2&gt;&lt;p&gt;関連の実践経験が不足している状態で、このような自動化テストのタスクを受け取った場合、一般的なスタートは、検索エンジンを開いて、現在のシステム&lt;strong&gt;技術スタック&lt;/strong&gt;で利用可能なツールやフレームワークを探し、マニュアルを読み、一発勝負。適切なツールを見つけられれば、おめでとうございます、&lt;strong&gt;完璧なスタート&lt;/strong&gt;です。
まず「間違っていた」と言っておきながら、関連資料を調べ直すと、これは存在しないわけではなく、むしろフレームワーク自体が複雑で、デプロイに必要なリソースも多すぎることがわかります。初心者にとって必要なのは、小さくて、簡潔で、テストチームの同僚に相談すると、&lt;code&gt;Python&lt;/code&gt; 自体構築のフレームワークについて提案され、簡単に言うと、既存のユニットテストフレームワークを自動テストフレームワークとして活用するというものです。
参考となるプロジェクトのデザイン思路：&lt;a class=&#34;link&#34; href=&#34;https://github.com/wintests/pytestDemo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/wintests/pytestDemo&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;フレームが必要な理由&#34;&gt;フレームが必要な理由
&lt;/h2&gt;&lt;p&gt;サービスには、開発環境、テスト環境、本番テスト環境など、複数の異なるデプロイ環境が存在します。フレームワークの役割は、これらの環境間の抽象化層を提供することです。テストケースとデータが分離され、それぞれの環境設定に合わせて異なるケースデータを適用できます。また、共通のデータをサポートすることも可能です。&lt;/p&gt;
&lt;p&gt;主な目的は、自動化の利用率を向上させることです。より複雑なシナリオでは、異なる環境間でのデータ連携は存在せず、全く関係ありません。ケースデータを設定する際に &lt;code&gt;label&lt;/code&gt; 属性を追加し、現在のデータがサポートする環境を指定するだけで済みます。&lt;/p&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://time.geekbang.org/column/article/496850&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;最高のコストパフォーマンスな自動テスト&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>新しい言語を学ぶべき理由は何ですか？</title>
        <link>https://ttf248.life/ja/p/why-learn-a-new-language/</link>
        <pubDate>Thu, 04 Aug 2022 11:27:30 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/why-learn-a-new-language/</guid>
        <description>&lt;p&gt;学歴から算じると、C++に触れるのは10年以上になる。他のプログラミング言語を学ぶ必要がなぜあるのか？&lt;/p&gt;
&lt;p&gt;職務経験：エレガントなモジュール設計の経験が不足しており、C++の構文は自由度が高いため、他の言語を学習することで、よりエレガントな設計を書くことができるように導かれている。&lt;/p&gt;
&lt;p&gt;いくつかのツールを作成する際に、頻繁に利用することがある。&lt;/p&gt;
&lt;p&gt;低レベルライブラリのデザインやビジネスモジュールの実装など、デザインの原則もすべて理解できている。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Visual Studio コンパイル文字セット [転送]</title>
        <link>https://ttf248.life/ja/p/visual-studio-character-set/</link>
        <pubDate>Thu, 04 Aug 2022 10:51:43 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/visual-studio-character-set/</guid>
        <description>&lt;p&gt;C++をクロスプラットフォームで開発する際、中国のオペレーティングシステムではよく遭遇するエラーは、&lt;code&gt;error C2001&lt;/code&gt;（定数に改行文字が含まれています）です。&lt;/p&gt;
&lt;h2 id=&#34;visual-studio&#34;&gt;Visual Studio
&lt;/h2&gt;&lt;p&gt;CMakeはプロジェクトのコンパイルスクリプトを組織し、Windows環境での開発時に一時的にソリューションファイルを生成します。クロスプラットフォームである理由として、ファイルエンコーディングにUTF-8を選択しています。&lt;/p&gt;
&lt;p&gt;引用資料では、問題の原因について原理に基づき詳細な説明が提供されています。&lt;/p&gt;
&lt;p&gt;エンコーディングに関して、MSVCにはコンパイルオプション&lt;code&gt;/source-charset&lt;/code&gt;と&lt;code&gt;/execution-charset&lt;/code&gt;があり、これらを使用することで、ほとんどのエンコーディング問題を解決できます。&lt;/p&gt;
&lt;p&gt;例えば、WindowsのcmdコマンドプロンプトはデフォルトでGBKエンコーディングしか表示できない場合でも、コードファイル自体がUTF-8で記述されているため、クロスプラットフォームであることや、直接GBKに変換する変更を加えることが難しい状況です。そこで、Win10上で&lt;code&gt;/source-charset:utf-8 /execution-charset:gbk&lt;/code&gt;というコンパイルオプションを設定し、コンパイラをUTF-8エンコーディングで読み込み、内部の文字列配列にはGBKエンコーディングで保存することで、直接printf関数を使用してcmdコマンドプロンプトで漢字を表示することができます。&lt;/p&gt;
&lt;h2 id=&#34;visual-studio-用の-cmake-設定&#34;&gt;Visual Studio 用の CMake 設定
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;if(WIN32)
  message(STATUS &amp;quot;WIN32 での構成実行中&amp;quot;)
  set(CMAKE_CXX_FLAGS &amp;quot;${CMAKE_CXX_FLAGS} /source-charset:utf-8 /execution-charset:gbk&amp;quot;)
endif()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhaolan.zhihu.com/p/146543940&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhaolan.zhihu.com/p/146543940&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Windowsプラットフォームでフォルダのサイズを迅速にカウントする</title>
        <link>https://ttf248.life/ja/p/windows-platform-quick-folder-size-statistics/</link>
        <pubDate>Mon, 01 Aug 2022 19:54:18 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/windows-platform-quick-folder-size-statistics/</guid>
        <description>&lt;p&gt;Linuxプラットフォームは非常にシンプルです。「du -sh *」という一行のコードで済みます。Windowsはどうでしょうか？ディスクが複数あり、クリーンアップしたいのですが、ファイル数が多くて、システム標準の「リソースマネージャー」でフォルダサイズを統計すると、速度が遅くて諦めそうになります。&lt;/p&gt;
&lt;h2 id=&#34;everything&#34;&gt;Everything
&lt;/h2&gt;&lt;p&gt;Windows 平台で開発をしている方で、Everything を実際に使ったことがない方もいるかもしれません。検索速度はシステム標準のファイルエクスプローラーを圧倒的に上回ります。システムレベルでファイルの高速インデックス作成がサポートされているので、同様のツールを見つけることができるはずです。ファイルサイズも同時に統計できます。&lt;/p&gt;
&lt;h2 id=&#34;wiztree&#34;&gt;WizTree
&lt;/h2&gt;&lt;p&gt;公式サイト：&lt;a class=&#34;link&#34; href=&#34;https://www.diskanalyzer.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.diskanalyzer.com/&lt;/a&gt;
通常のインストールモードまたはグリーン版を解凍して実行
高速、データ表示タイプが豊富で、左側はツリー状図モード、右側にはファイルの種類が表示され、もちろんグラフィカルな表示も、ソフトウェアの下欄にあります。&lt;/p&gt;
&lt;h2 id=&#34;spacesniffer-2023年不再维护更新&#34;&gt;SpaceSniffer (2023年不再维护更新)
&lt;/h2&gt;&lt;p&gt;ソフトウェア公式サイト：&lt;a class=&#34;link&#34; href=&#34;http://www.uderzo.it/main_products/space_sniffer/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.uderzo.it/main_products/space_sniffer/&lt;/a&gt;
操作は非常に簡単です。対応するドライブを選択すると、ソフトウェアはグラフィカルな方法でフォルダのサイズを表示し、サイズが大きいほど画像内の対応する行列も大きくなります。その他の操作は、自分でクリックすれば理解できます。ファイル条件フィルタリングをサポートしています：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ファイルサイズのフィルタリング&lt;/li&gt;
&lt;li&gt;ファイルの日付フィルタリング&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;space_sniffer.gif&#34; &gt;基本的な使い方&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;advance.gif&#34; &gt;高度な使い方&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://moe.best/software/spacesniffer.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://moe.best/software/spacesniffer.html&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>ウェブページのスタイルシート（CSS）をコピーする方法：要素の検証</title>
        <link>https://ttf248.life/ja/p/how-to-copy-webpage-css-element-inspect/</link>
        <pubDate>Sun, 31 Jul 2022 23:36:48 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/how-to-copy-webpage-css-element-inspect/</guid>
        <description>&lt;p&gt;静的ブログのテーマは、主流が海外製のテンプレートで、調整や修正を行うことが多く、中国語コンテンツのレイアウトにはあまり考慮されない。&lt;/p&gt;
&lt;h2 id=&#34;本文&#34;&gt;本文
&lt;/h2&gt;&lt;p&gt;半月ほど前、ブログのスタイルシートを調整しました。長年バックエンドサービスの開発をしているのですが、フロントエンドは純粋な初心者です。前後とも半日かけて苦戦した結果、デザインがなかなか良くありませんでした。突然閃いて、よく読む技術ブログ（infoq、开源中国など）のデザインが良いなと思い、参考にしてみようと思いました。ソースコードを拝見し、関連する要素を特定しようとしましたが、霧だらけでした。&lt;/p&gt;
&lt;p&gt;フロントエンドの友人がこの部分を見ると笑ってしまうかもしれません。指定された要素を特定することも理解できません。理解する必要はありません。週末は時間があるから、立ち止まって考えればいいのです。以前、&lt;code&gt;python&lt;/code&gt; で爬虫（ウェブスクレイピング）を書いたときには、似たようなものを使っていたように思います。&lt;/p&gt;
&lt;h3 id=&#34;要素検査&#34;&gt;要素検査
&lt;/h3&gt;&lt;p&gt;そうです、ブラウザに標準搭載されている要素検査ツールを使って、スタイルシートをコピーしたり、指定した要素の位置を特定したりするのは、あっという間です。&lt;code&gt;selector&lt;/code&gt; で要素を特定したり、&lt;code&gt;hugo&lt;/code&gt; で &lt;code&gt;user define css&lt;/code&gt; を新規作成したりすることも可能です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;元素のコピー&lt;/li&gt;
&lt;li&gt;outerHTML のコピー&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;セレクタのコピー&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;JS パスのコピー&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;スタイルのコピー&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;XPath のコピー&lt;/li&gt;
&lt;li&gt;完整的 XPath のコピー&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Windowsプラットフォームで超大型ファイルを編集する：EmEditor (テキストエディタ)</title>
        <link>https://ttf248.life/ja/p/windows-platform-edit-large-files-emeditor-text-editor/</link>
        <pubDate>Sun, 31 Jul 2022 23:21:24 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/windows-platform-edit-large-files-emeditor-text-editor/</guid>
        <description>&lt;p&gt;上海国安数据库事件、在黑客圈子内闹得沸沸扬扬，不知真假，过两年如果还记得，再回头看看。根据以往的经验，更新了一波本地的社工数据库资料，看到一个巨型SQL文件：17.9G，一般的文本编辑器，预览都是个问题，更别说打开了，和网友闲聊，提到了：EmEditor。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;公式サイト：&lt;a class=&#34;link&#34; href=&#34;https://www.emeditor.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.emeditor.com/&lt;/a&gt;
週末に時間を割いて試してみたところ、非常に便利で、デザイン面でも大ファイル編集をサポートしており、十分なメモリがあれば、ファイル全体をメモリ上に読み込んで検索や編集速度が非常に速く、分割機能も利用できます。&lt;/p&gt;</description>
        </item>
        <item>
        <title>単なる簡単なことに追加のコードコピーボタンを実装する</title>
        <link>https://ttf248.life/ja/p/add-copy-button-for-simple-task/</link>
        <pubDate>Fri, 25 Feb 2022 01:23:39 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/add-copy-button-for-simple-task/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;「ouuan」を４時間も調べて、その時この文章を見ていると、まだ面白がっていて、どうしてこんなに時間がかかったのか不思議だった。最後に時間を調べると３時間だった。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;これは2022年の年初に書いた最初の記事で、扱うべきことは単純なもので、タイトル通り完全に同じ内容（当時としてはまだ若かった私）だと考えて、&lt;a class=&#34;link&#34; href=&#34;https://ouuan.github.io/post/from-hexo-to-hugo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;作业&lt;/a&gt;をそのままコピーしてブックマークに入れて、しばらく放置していました。ようやくこの件を思い出したのです。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hugo&lt;/code&gt;に移行する際、プラグインが少なすぎて、コードをコピーできず、多くのメモを印象派からブログに移行する際に、コードをコピーする作業が煩雑になり、私の水面下ブログのモチベーションを著しく低下させてしまいました。&lt;/p&gt;
&lt;h2 id=&#34;序章&#34;&gt;序章
&lt;/h2&gt;&lt;p&gt;まず、原作者の稿をじっくりと見直し、通読し、作者紹介も確認します。うわー、すごい大佬だ！清華大学で学んでいる学部生で、昔からコンピュータに触れているんだ。なるほど、クールなやつだ。まずはこのブログを確認し、自分が何をすべきか全く覚えていない。ついでに作者のGitHubリポジトリをチェックする。この修正された「even」テーマは今のよりずっと見栄えが良く、新しい機能もたくさんある。早速取り掛かり、関連コードをマージしよう。
&lt;img src=&#34;https://ttf248.life/p/add-copy-button-for-simple-task/2022-02-25-02-08-19.png&#34;
	width=&#34;215&#34;
	height=&#34;150&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;143&#34;
		data-flex-basis=&#34;344px&#34;
	
&gt; &lt;img src=&#34;https://ttf248.life/p/add-copy-button-for-simple-task/2022-02-25-02-08-40.png&#34;
	width=&#34;217&#34;
	height=&#34;167&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;129&#34;
		data-flex-basis=&#34;311px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;新機能記事の履歴表示関連提出記録の確認&#34;&gt;新機能：記事の履歴表示、関連提出記録の確認
&lt;/h3&gt;&lt;p&gt;効果はなかなか良く、記事末尾にスクロールすることで体験できます。
マージ前に作者の元のリポジトリの履歴を確認していなかったので、簡単なマージで済むと思っていましたが、最終的に大量のコードをマージし、その中に衝突やN回の巻き戻しが発生し、無脑覆盖（強制上書き）を行いました。それはすべてフロントエンドとレンダリングのテンプレートコードであり、私が使用するものに合わせました。
リポジトリ：&lt;a class=&#34;link&#34; href=&#34;https://github.com/TianlongXiang/hugo-theme-even&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/TianlongXiang/hugo-theme-even&lt;/a&gt;
中国語の罠です。&lt;code&gt;git&lt;/code&gt;でこのパラメータを調整しないと、生成される履歴リンクが現在の記事の&lt;code&gt;commit hash&lt;/code&gt;を取得できず、履歴リンクの生成に失敗します。完全な記事履歴を生成する際も、自動統合スクリプトを修正する必要があります。必ず現在のリポジトリ全体の履歴をプルしてください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/TianlongXiang/TianlongXiang.github.io/commit/0d860154de9b335ed88a57d62eedd4b6e3ccbeee&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;feat: 完全に GitHub リポジトリをプルして、記事の最終更新履歴を動的に更新&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/TianlongXiang/TianlongXiang.github.io/commit/1b5d719966737f16a8c67880370dc2722adea0b3&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;chore: パスに日本語が含まれているため、hugo GitInfo でこの設定を有効にする必要がある&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;name: Build Github
run: git config --global core.quotePath false &amp;amp;&amp;amp; hugo -b &amp;quot;https://www.xiangtianlong.com/&amp;quot; -d &amp;quot;github_public&amp;quot; &amp;amp;&amp;amp; ls
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;スタイル調整&#34;&gt;スタイル調整
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;サイトコンテンツの幅を調整します。以前のデザインはモバイルとPCの両方に対応していましたが、実際にスマートフォンでの閲覧はほとんどなく、私はPCで確認しています。&lt;/li&gt;
&lt;li&gt;目次バーを自動伸縮するように変更します。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;本文&#34;&gt;本文
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ouuan&lt;/code&gt;のコード記録を参考に半時間以上見てみても、コピーボタンの追加方法がよく分からなかった。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;時光穿梭，一月之后，又想到这事&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;今回この課題が理解できなかったため、別の課題をコピーし、必ずしも理解できるものにしました。検索で見つけた結果は、意外にも&lt;code&gt;hugo&lt;/code&gt;公式フォーラムにコードのコピーボタンを追加する方法についての投稿がありました。そこを拝見すると、論理が明確でわかりました。混乱していた状況でしたが、戻ってサイトを見ると&lt;code&gt;even&lt;/code&gt;レンダリング生成したコードブロックのスタイルと資料の説明が異なり、この部分は少し複雑です。簡単に記録しておきます。
基本的にはフロントエンド開発は理解していないため、わからない箇所はブラウザの「要素を検査」ツールを使ってコードを分析し、右側のスタイル情報に頼って徐々に論理を理解していきました。「JavaScript」についてはコンソールでログを出力しました。最初は多くのことがわからず、落ち着いて、少しずつ論理を整理・分割していき、必ずや解決策が見つかります。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;ノードが複数存在し、ここでは個々のコードブロックを指します。テーマが自動的に行番号を表示しており、その結果コピーボタンが2つ表示される&lt;/li&gt;
&lt;li&gt;テーマの組み込みされたコードハイライト機能を無効化したいのですが、このテーマの設定はよくわかりません。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hugo&lt;/code&gt;公式ドキュメントで資料を参照し、半ば理解しながら、コードハイライトを制御できる「markup」設定があることを知りました。&lt;/li&gt;
&lt;li&gt;設定ファイルを調整してもなかなかうまくいかず、レンダリング結果と期待値が異なっていた&lt;/li&gt;
&lt;li&gt;このような設定の「pygmentsOptions」を発見し、さらに資料を調べて設定を調整しました。まず行番号を削除する&lt;/li&gt;
&lt;li&gt;カスタムCSSスタイルシートとカスタムJavaScriptスクリプトを設定しました。&lt;/li&gt;
&lt;li&gt;結局これだけの作業をしたので、この文を見つけたときには、なぜこんなに時間がかかったのか笑ってしまいました。実際には3時間でした。最後に時間をを見ると：3時間。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;参考リンク&#34;&gt;参考リンク
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://ouuan.github.io/post/from-hexo-to-hugo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ouuan.github.io/post/from-hexo-to-hugo/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://gohugobrasil.netlify.app/content-management/syntax-highlighting/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://gohugobrasil.netlify.app/content-management/syntax-highlighting/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://gohugo.io/getting-started/configuration-markup#highlight&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://gohugo.io/getting-started/configuration-markup#highlight&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.dannyguo.com/blog/how-to-add-copy-to-clipboard-buttons-to-code-blocks-in-hugo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.dannyguo.com/blog/how-to-add-copy-to-clipboard-buttons-to-code-blocks-in-hugo/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>混沌エンジニアリング</title>
        <link>https://ttf248.life/ja/p/chaos-engineering/</link>
        <pubDate>Wed, 28 Jul 2021 14:35:07 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/chaos-engineering/</guid>
        <description>&lt;p&gt;システム安定性テストを行うための、システムを破壊するパターン。&lt;/p&gt;
&lt;h2 id=&#34;本文&#34;&gt;本文
&lt;/h2&gt;&lt;p&gt;国内的互联网行业总是喜欢折腾点新东西出来，有时候听到个名词，一般人都想不到它是什么东西？&lt;/p&gt;
&lt;p&gt;看了部分文章，还是这段针对混沌工程初期的定义，较为容易接受：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;混沌工程的早期探索，其实在行业内一直有，曾经是以故障测试、容灾演练等身份存在。而随着微服务架构的不断发展，以及分布式系统的不断庞大，混沌工程开始崭露头角，越来越被重视。当 Netflix 正式提出混沌工程概念后，相关理论也开始飞快丰富。Netflix 的实践也证明了混沌工程在稳定性领域所带来的巨大意义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;参照リンク&#34;&gt;参照リンク
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.infoq.cn/article/gsqtykoa3uvrtqi1kkmo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ByteDance 混沌工程実践まとめ&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>KubernetesでPodが停止しました。</title>
        <link>https://ttf248.life/ja/p/kubernetes-pause-pod/</link>
        <pubDate>Mon, 12 Jul 2021 11:23:09 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/kubernetes-pause-pod/</guid>
        <description>&lt;p&gt;デプロイメントコントローラは、Kubernetesクラスタにおいて非常に重要な機能であるPodの水平スケーリングと縮小を実現します。これは従来のクラウド時代プラットフォームが必須とする能力です。&lt;/p&gt;
&lt;p&gt;あるビジネスシーンで、データベース内のデータを修正する必要があり、修正後にPodノードを再起動します。しかし、Podが実行中に表のフィールドを継続的に変更する必要があるため、一時的にアプリケーションによるテーブルへの更新を停止し、データ修正後にPodを復旧する必要があります。&lt;/p&gt;
&lt;p&gt;削除以外の方法で、同様に一時停止の効果を実現する方法はありますか？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl scale --replicas=0 deployment/&amp;lt;your-deployment&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;回答を見る前に、多くの人が直接プロセスを操作する時代に思い当たり、ビジネスプロセスの直接操作を考えてしまうかもしれません。&lt;/p&gt;
&lt;h2 id=&#34;参照リンク&#34;&gt;参照リンク
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/54821044/how-to-stop-pause-a-pod-in-kubernetes&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Kubernetesでポッドを停止/一時停止する方法&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Dockerの基礎を理解するための３つのポイント (または、Dockerの基本を理解するための３つのこと)</title>
        <link>https://ttf248.life/ja/p/docker-two-three-things/</link>
        <pubDate>Thu, 21 Jan 2021 09:26:07 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/docker-two-three-things/</guid>
        <description>&lt;p&gt;長年携わってきたのは &lt;code&gt;CentOS&lt;/code&gt; オペレーティングシステムであり、&lt;code&gt;mac&lt;/code&gt; ユーザーや &lt;code&gt;Ubuntu&lt;/code&gt; ユーザーの場合、一部の内容は適用できない。
インストールに関する部分は、清華大学のドキュメントを参照するのが参考になる：&lt;a class=&#34;link&#34; href=&#34;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;インストール&#34;&gt;インストール
&lt;/h2&gt;&lt;p&gt;未知の神秘的な力により、国内でのDockerのインストールには、クラウドプロバイダーが提供するレジストリのアドレスを設定することを推奨します。ここでは&lt;strong&gt;Alibaba Cloud&lt;/strong&gt;を使用することをお勧めします。&lt;/p&gt;
&lt;h3 id=&#34;リポジトリソースの設定&#34;&gt;リポジトリソースの設定
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install yum-utils device-mapper-persistent-data lvm2 &amp;amp;&amp;amp; \
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;最新版のインストール&#34;&gt;最新版のインストール
&lt;/h3&gt;&lt;p&gt;Dockerは一般的なバックエンドサービスとして、起動時に自動で開始されるように設定することを推奨します。以下のコマンドはCentOS 7向けです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum install -y docker-ce docker-ce-cli containerd.io &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;指定バージョン展開&#34;&gt;指定バージョン展開
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;kubernetes&lt;/code&gt;および&lt;code&gt;docker&lt;/code&gt;のリリースは完全に同期されておらず、今後&lt;code&gt;kubernetes&lt;/code&gt;を展開する場合は、&lt;code&gt;kubernetes&lt;/code&gt;展開手順を参照し、指定バージョンの&lt;code&gt;docker&lt;/code&gt;をインストールしてください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum list docker-ce --showduplicates | sort -r
sudo yum install -y docker-ce-18.09.2-3.el7 docker-ce-cli-18.09.2-3.el7 containerd.io-18.09.2-3.el7 &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;通常ユーザーにdocker権限を追加する&#34;&gt;通常ユーザーにDocker権限を追加する
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo usermod -aG docker ${USER}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;卸載&#34;&gt;卸載
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum remove -y docker-ce docker-ce-cli containerd.io
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;日常使用-にちじょうしよう&#34;&gt;日常使用 (にちじょうしよう)
&lt;/h2&gt;&lt;h3 id=&#34;镜像加速&#34;&gt;镜像加速
&lt;/h3&gt;&lt;p&gt;未知の神秘的な力により、イメージの取得時に速度が低下することがあります。この問題を解決するために、国内のクラウドプロバイダーが多くの加速サービスを提供し、引き続き&lt;strong&gt;阿里云&lt;/strong&gt;を推奨します。&lt;/p&gt;
&lt;p&gt;加速用のURLは、ご自身の登録した阿里云アカウントで取得してください。このサービスは無料で利用でき、阿里云からは無料のイメージ構築サービスも提供されています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt; /etc/docker/daemon.json &amp;lt;&amp;lt;EOF
{
  &amp;quot;registry-mirrors&amp;quot;: [
    &amp;quot;https://docker.nju.edu.cn&amp;quot;,
    &amp;quot;https://mirror.baidubce.com&amp;quot;,
    &amp;quot;https://docker.m.daocloud.io&amp;quot;,
    &amp;quot;https://docker.mirrors.sjtug.sjtu.edu.cn&amp;quot;
  ]
}
EOF
systemctl daemon-reload &amp;amp;&amp;amp; \
systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;強く推奨されるコントロールパネル&#34;&gt;強く推奨されるコントロールパネル
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker volume create portainer_data &amp;amp;&amp;amp; \
docker run -d --name=portainer --restart=always -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:2.20.3-alpine
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;常用イメージの取得集&#34;&gt;常用イメージの取得集
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker pull rancher/rancher:stable &amp;amp;&amp;amp; docker pull portainer/portainer-ce:2.0.1 &amp;amp;&amp;amp; \
docker pull centos:7 &amp;amp;&amp;amp; docker pull ubuntu:20.04 &amp;amp;&amp;amp; docker pull ubuntu:18.04 &amp;amp;&amp;amp; \
docker pull redis:5 &amp;amp;&amp;amp; docker pull redis:6 &amp;amp;&amp;amp; \
docker pull alpine:3.11 &amp;amp;&amp;amp; docker pull busybox:1.32 &amp;amp;&amp;amp; \
docker pull rabbitmq:3.7-management &amp;amp;&amp;amp; \
docker pull mariadb:10.2 &amp;amp;&amp;amp; \
docker pull nginx:1.18 &amp;amp;&amp;amp; docker pull nginx:1.19 &amp;amp;&amp;amp; \
docker pull mysql:5.6 &amp;amp;&amp;amp; docker pull mysql:8 &amp;amp;&amp;amp; \
docker pull elasticsearch:6.8.11 &amp;amp;&amp;amp; docker pull logstash:6.8.11 &amp;amp;&amp;amp; docker pull kibana:6.8.11 &amp;amp;&amp;amp; \
docker pull zookeeper:3.4 &amp;amp;&amp;amp; \
docker pull influxdb:1.7 &amp;amp;&amp;amp; docker pull grafana/grafana:7.3.1 &amp;amp;&amp;amp; \
docker pull percona:8 &amp;amp;&amp;amp; docker pull percona:5.6 &amp;amp;&amp;amp; \
docker pull cloverzrg/frps-docker:0.34.3 &amp;amp;&amp;amp; docker pull cloverzrg/frpc-docker:0.34.3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;常用コマンドの組み合わせ&#34;&gt;常用コマンドの組み合わせ
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/engine/reference/commandline/docker/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.docker.com/engine/reference/commandline/docker/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;コンテナの実行状態を確認し、&lt;code&gt;format&lt;/code&gt;パラメータを追加して詳細なコンテナ情報を取得（イメージ情報は無視）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker ps --format &amp;quot;{{.Names}}: {{.Ports}}: {{.Size}}&amp;quot;
#portainer: 0.0.0.0:8000-&amp;gt;8000/tcp, 0.0.0.0:9000-&amp;gt;9000/tcp: 0B (virtual 172MB)
#influxdb: 0.0.0.0:8086-&amp;gt;8086/tcp: 183B (virtual 311MB)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;すべてのコンテナをワンクリックで停止&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker stop $(docker ps -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;すべてのイメージをワンクリックで削除&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dokcer rmi $(docker images -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;イメージのエクスポート&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; &amp;gt; -o XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;イメージをエクスポートして圧縮&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; | gzip &amp;gt; XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;イメージをインポート&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker load -i XXX.tar
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>LinuxでJMeterの負荷テスト環境を構築する</title>
        <link>https://ttf248.life/ja/p/linux-setup-jmeter-testing-environment/</link>
        <pubDate>Tue, 22 Dec 2020 10:12:50 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-setup-jmeter-testing-environment/</guid>
        <description>&lt;p&gt;著者はハードウェアに強い関心を持ち、JMeterを用いて負荷テストを実施し、CentOS 7上にJMeter、InfluxDB、Grafanaをデプロイするプロセスを記録しました。JMeterのインストールとコマンドの使用方法、InfluxDBの特徴とDockerによるインストール方法、Grafanaの簡易的なデプロイと設定について共有しています。高性能プログラムモードに関する経験や参考資料をまとめました。&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;広く知られているように&lt;/code&gt;、私にはハードウェアに対する強い関心が持っており、テストグループが &lt;code&gt;JMeter&lt;/code&gt; を使用して負荷テストを行っている際に、パフォーマンスが向上しないことを発見しました。好奇心旺盛な私は、会社の負荷テストの方法を試してみることに決意しました。また、ある頃合いにオープンソース中国で、より洗練された高性能のパフォーマンス測定グラフを作成する方法に関する投稿を読んだことがあります。&lt;code&gt;Windows&lt;/code&gt;版でのテスト実行時に、可視化された &lt;code&gt;TPS&lt;/code&gt; データの表示を実現しており、Webパネルを設定することでどのような効果があるのか疑問に思っていました。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;頭の中で思いついたのは、当然のことばかりです。実際に試してみないとしかたないことを理解します。
負荷テストには GUI モードを使用しないでください！ テスト作成とデバッグのみに使用してください。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;背景-1&#34;&gt;背景
&lt;/h2&gt;&lt;p&gt;公式推奨は、コマンドラインで負荷テストレポートを取得し、GUIで表示する方法ですが、データに誤差が含まれているという問題があります。JMeterの理解が十分ではないため、少なくとも&lt;code&gt;Linux&lt;/code&gt;版のコンソールパネルを弄り転げる理由を見つけたいと思います。&lt;/p&gt;
&lt;p&gt;開かれた中国（オープンチャイナ）の投稿では、コアコンポーネントのデプロイメント方法があまりにも友好的ではなく、インストールに必要なファイルは公众号を通じてダウンロードする必要があり、現代的な若者として、もちろん&lt;code&gt;Docker&lt;/code&gt;で代替します。要するに、サーバーは国内であり、国境を越えたソースアドレスへのアクセス速度が遅いため、少なくともイメージサービスとしては、阿里云には無料の加速があります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker&lt;/code&gt; のインストールとデプロイメントについては、ここでは詳細な説明を省略し、以前の記事を参照してください。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;次の内容は、2つの主要な領域に分かれています：基本的なテスト環境コンポーネントの構築、および各コンポーネントの簡単な認識の説明&lt;/p&gt;
&lt;h2 id=&#34;jmeter&#34;&gt;JMeter
&lt;/h2&gt;&lt;p&gt;Apache JMeterはApache組織が開発したJavaベースの負荷テストツールです。ソフトウェアに対する負荷テストに使用され、当初はWebアプリケーションのテスト用に設計されましたが、その後、他のテスト分野にも拡張されています。静的および動的なリソース（静的ファイル、Java小型サービスプログラム、CGIスクリプト、Javaオブジェクト、データベース、FTPサーバーなど）をテストするために使用できます。JMeterは、さまざまな負荷カテゴリからの巨大な負荷をシミュレートして、それらの強度をテストし、全体的なパフォーマンスを分析するために使用できます。さらに、JMeterはアプリケーションの機能/回帰テストに使用でき、断言を含むスクリプトを作成することで、プログラムが期待どおりの結果を返していることを検証します。最大限の柔軟性のため、JMeterは正規表現を使用して断言を作成することを許可しています。&lt;/p&gt;
&lt;p&gt;Apache jmeter は、静的および動的なリソース（ファイル、Servlet、Perlスクリプト、Java オブジェクト、データベースとクエリ、FTPサーバーなど）のパフォーマンスをテストするために使用できます。 サーバー、ネットワーク、またはオブジェクトに過剰な負荷をシミュレートして、それらの強度をテストしたり、さまざまなストレスタイプの下での全体的なパフォーマンスを分析したりすることができます。 大規模な同時負荷テストでサーバー/スクリプト/オブジェクトのパフォーマンスを分析したり、グラフィカルなパフォーマンス分析を行ったりするために使用できます。&lt;/p&gt;
&lt;h3 id=&#34;jmeter-導入-centos7&#34;&gt;Jmeter 導入 CentOS7
&lt;/h3&gt;&lt;p&gt;JDK の実行環境をインストールし、JMeter のインストールパッケージをダウンロードします。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install java-1.8.0-openjdk -y &amp;amp;&amp;amp; \
wget https://mirrors.bfsu.edu.cn/apache//jmeter/binaries/apache-jmeter-5.4.tgz &amp;amp;&amp;amp; tar -xf apache-jmeter-5.4.tgz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;環境変数を設定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export JMETER_HOME=$HOME/jmeter/apache-jmeter-5.4
export PATH=$JMETER_HOME/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;jmeter-コマンド&#34;&gt;JMeter コマンド
&lt;/h3&gt;&lt;p&gt;最後に &lt;code&gt;Grafana&lt;/code&gt; ダッシュボードに送信し、&lt;code&gt;-l&lt;/code&gt; パラメータを入力しなくても、&lt;code&gt;web&lt;/code&gt; コンソールでデータを観察できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;jmeter -n -t /tmp/order-500-10s.jmx -l /tmp/jmeter-order-report-20200109/order-500-10s.jtl
# 通常、テスト結果とテストレポートは省略し、コマンドを簡略化します。
jmeter -n -t /tmp/order-500-10s.jmx
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;influxdb&#34;&gt;InfluxDB
&lt;/h2&gt;&lt;p&gt;InfluxDBは、Go言語で記述されたオープンソースの分散型時系列、イベント、指標データベースです。外部依存なしで動作します。このデータベースは現在、大量の時間スタンプデータ（DevOpsモニタリングデータ、APPメトリクス、IoTセンサーデータ、リアルタイム分析データなど）を保存するために主に利用されています。&lt;/p&gt;
&lt;h3 id=&#34;influxdbの特徴&#34;&gt;InfluxDBの特徴
&lt;/h3&gt;&lt;p&gt;InfluxDBの特徴は、以下の9点にまとめられます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非構造化（非モデリング）：任意の数の列を含めることができます。&lt;/li&gt;
&lt;li&gt;メトリクスの保存期間を設定できます。&lt;/li&gt;
&lt;li&gt;時間に関連する関数（min、max、sum、count、mean、medianなど）をサポートし、統計分析が容易です。&lt;/li&gt;
&lt;li&gt;ストアポリシーのサポート：データの削除および変更に使用できます。（InfluxDBはデータの削除と変更の方法を提供していません。）&lt;/li&gt;
&lt;li&gt;連続クエリのサポート：データベース内で自動的にスケジュールされたステートメントのセットであり、ストアポリシーと組み合わせてInfluxDBのシステム使用量を削減できます。&lt;/li&gt;
&lt;li&gt;ネイティブなHTTPサポート、組み込みHTTP API。&lt;/li&gt;
&lt;li&gt;SQLライクな構文をサポート。&lt;/li&gt;
&lt;li&gt;クラスタ内のデータのレプリカ数を設定できます。&lt;/li&gt;
&lt;li&gt;定期的なサンプリングデータによる別の測定項目の書き込みをサポートし、粒度ごとのデータを保存できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;influxdb-docker-インストール&#34;&gt;InfluxDB Docker インストール
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir influxdb &amp;amp;&amp;amp; cd influxdb &amp;amp;&amp;amp; \
docker run -p 8086:8086 -d --name influxdb -v $PWD:/var/lib/influxdb influxdb:1.7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker exec -it influxdb /bin/bash&lt;/code&gt; でコンテナに入り、コマンドを実行し、手動でデータベースを作成&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;root@bce0a55bbc72:/# influx
http://localhost:8086 への接続、バージョン 1.7.10
InfluxDB シェル バージョン：1.7.10
&amp;gt; 対話式パネルでコマンドを実行
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;influxdbデータベースとユーザーの作成&#34;&gt;InfluxDBデータベースとユーザーの作成
&lt;/h3&gt;&lt;p&gt;データベースの作成: &lt;code&gt;create database jmeter_t2&lt;/code&gt;
データベースの表示: &lt;code&gt;show databases&lt;/code&gt;
データベースの切り替え: &lt;code&gt;use jmeter_t2&lt;/code&gt;
ユーザーの作成: &lt;code&gt;create user &amp;quot;admin&amp;quot; with password &#39;admin&#39; with all privileges&lt;/code&gt;
ユーザーの表示: &lt;code&gt;show users&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; show users
user  admin
----  -----
admin true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ユーザー権限が&lt;code&gt;admin&lt;/code&gt;で&lt;code&gt;true&lt;/code&gt;と表示されれば、データベースの準備は完了です。&lt;/p&gt;
&lt;h2 id=&#34;grafana&#34;&gt;Grafana
&lt;/h2&gt;&lt;p&gt;テストケースの作成時に、グラフによる表現はあまり必要ないことがわかりました。インターフェースの &lt;code&gt;tps&lt;/code&gt; データのコマンドライン実行で十分観測できます。むしろ、プログラム内部の処理時間を確認したいと考えています。&lt;/p&gt;
&lt;p&gt;Grafana の簡易的なコンソールパネルをデプロイし、InfluxDB と連携するための設定ファイルをインポートします。&lt;/p&gt;
&lt;p&gt;コンソールはラベルによるフィルタリングをサポートしており、通常は 1 つの InfluxDB データベースを設定するだけで済みます：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アプリケーション名&lt;/li&gt;
&lt;li&gt;テストケース名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/linux-setup-jmeter-testing-environment/Snipaste_2021-03-09_19-44-22.png&#34;
	width=&#34;861&#34;
	height=&#34;357&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;grafana&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;241&#34;
		data-flex-basis=&#34;578px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -d --name=grafana -p 3000:3000 grafana/grafana:7.3.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ブラウザ版ではサンプリング間隔により、計算された &lt;code&gt;TPS&lt;/code&gt; や関連数値が JMeter の集計レポートと一致しないため、参照リンク：&lt;a class=&#34;link&#34; href=&#34;https://www.vinsguru.com/jmeter-real-time-results-influxdb-grafana/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.vinsguru.com/jmeter-real-time-results-influxdb-grafana/&lt;/a&gt; を参考にしています。&lt;/p&gt;
&lt;p&gt;資料には、リスナーのカスタム設定方法も記載されています。&lt;/p&gt;
&lt;h2 id=&#34;付録&#34;&gt;付録
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;高性能のプログラムパターンは、必然的にone loop threadであるべきであり、ロック、入隊列、出隊列などのものは、不必要なパフォーマンス損失を引き起こす&lt;/li&gt;
&lt;li&gt;核心ビジネスロジックの実行時間が、他のコードを導入する時間よりも大きい場合のみ、並行処理が有効に効率を向上させることができ、コアな実行時間が十分に小さい場合は、慎重に他のコードを導入すべき&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考資料&#34;&gt;参考資料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://my.oschina.net/u/4617935/blog/4680856&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;JMeterシリーズのJMeter+Grafana+InfluxDB リアルタイム監視&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/_/influxdb&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;influxdb 公式イメージ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/r/grafana/grafana&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;grafana 公式イメージ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://jmeter.apache.org/download_jmeter.cgi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;JMeter 公式サイト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@jasonli.studio/to-install-apache-jmeter-in-centos7-294bc72a97ba&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CentOS7にApache JMeterをインストールする方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Red Hat と CentOS のライフサイクル</title>
        <link>https://ttf248.life/ja/p/redhat-centos-lifecycle/</link>
        <pubDate>Tue, 21 Jul 2020 20:02:35 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/redhat-centos-lifecycle/</guid>
        <description>&lt;p&gt;オンラインプロ덕ション環境のオペレーティングシステムとして、Red HatとCentOSが主流の選択肢です。2つのシステムのライフサイクルに関する公式サイトへのリンクを記録し、CentOS 8からCentOS 8 Streamへのアップグレード経験を共有しています。&lt;/p&gt;
&lt;h2 id=&#34;はじめに&#34;&gt;はじめに
&lt;/h2&gt;&lt;p&gt;オンプレミス（本番環境）のオペレーティングシステムですが、現在の国内環境においては、Red HatとCentOSが主流の選択肢です。2年前にはRed Hat 6のEOL（End of Life）を迎えたため、両システムのライフサイクルに関する公式ウェブサイトへのリンクを記録します。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://access.redhat.com/support/policy/updates/errata&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Red Hat Enterprise Linux 生命周期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://wiki.centos.org/zh/About/Product&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CentOS 产品规范&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Red Hat Enterprise Linux（RHEL）および CentOS は、エンタープライズ向けの主要なサーバーオペレーティングシステムです。RHEL は安定したサポートと更新サイクルを提供し、エンタープライズアプリケーションに適しています。CentOS は RHEL のコミュニティ版であり、同様の機能と安定性を提供しますが、公式なサポートはありません。&lt;/p&gt;
&lt;h2 id=&#34;追記&#34;&gt;追記
&lt;/h2&gt;&lt;p&gt;この記事を執筆した時点では、2年後に自分が更新することなど想像もしていませんでした。先日、普段使っている仮想マシンをCentOS 8からCentOS 8 Streamにアップグレードしました。本番環境で何を選ぶかは、お話するのが難しいので、ここでは触れません。ローカル環境は最新版を追求します。&lt;/p&gt;
&lt;p&gt;CentOS 8 Streamは、従来のCentOSよりも迅速なアップデートと新機能を提供する、継続的リリース版であり、開発やテスト環境での利用に適しています。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>PC自作のあれこれ</title>
        <link>https://ttf248.life/ja/p/computer-assembly/</link>
        <pubDate>Sat, 18 Jul 2020 14:33:46 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/computer-assembly/</guid>
        <description>&lt;p&gt;著者は幼い頃からPCの組み立てに興味を持ち、大学卒業後に本格的にハードウェアの組み立てを始めました。彼は、CPU、SSD（ソリッドステートドライブ）、HDD（ハードディスクドライブ）やメモリのクロック周波数など、各パーツの性能比較サイトを紹介し、購入に関するアドバイスも行いました。また、ハードウェア選びでの経験談や注意点なども共有しました。&lt;/p&gt;
&lt;h3 id=&#34;縁語り尽くせぬもの&#34;&gt;縁・語り尽くせぬもの
&lt;/h3&gt;&lt;p&gt;幼い頃から、自分だけのコンピュータを組み立てたいと考えていた。しかし、経済的な条件が許さなかった。ようやく大学に上ると、持ち運びやすいため、構成したのはノートパソコンだった。もし具体的な時期を挙げるとすれば、自分が組立てることを思い始めたのは、故郷の図書館でさえあっただろう。毕竟これは市区レベルの図書館であり、電子閲覧室（実際にはほとんど行ったことがなく、時間課金制だという）や雑誌閲覧室（まさにここで『大众软件』、『电脑报』のような雑誌を読み、コンピュータにあまり触れていなかった私にとって、神に近い科普資料だった）があったからだ。打副本の章节を見て自分もコンピュータを組んで、モンスターを倒し、主力として出力することを考えたし、黒科技を見て本の内容通りに再現できると夢を見た（ハッキングツールの使用について）。もちろん高校では勉強が忙しく、当時の私の認知能力では、読書も遊びも両方楽しむ必要があった。そうした「天真爛漫」な日々を過ごし、図書館へ行くという由縁を作った。特に何もすることがない時、小さな袋を提げてそこへ向かい、市区はそれほど大きくなく、ほとんどが徒歩で図書館へ行った。到着すると空調の効いた部屋で小説、漫画、ゲーム雑誌を見たり、時には真面目な本も読んだりした。&lt;/p&gt;
&lt;p&gt;年を取ると忘れっぽくなるのが普通だ。図書館で生まれたものが初めだったのかもしれない。中学校の頃には、親戚がコンピュータを組み立てていたが、当初その機械は何に使われたのか覚えていない。オペレーティングシステムはWindows 2003で、ゲームは標準搭載のカード＋帝国時代があった。様々な「斗智斗勇」な考えで鍵を盗み、甥っ子と一緒にゲームをした。&lt;/p&gt;
&lt;p&gt;初等学校に入ると学校でコンピュータの基礎的なトレーニングを受けた後、転校し、コンピュータ競技会についても少し知識を得た。そして高校ではNOIPに合格した。ここで言及するのは、校友たちの力だ。高校のコンピュータ棟は校友たちからの寄付によって建てられたもので、コンピュータ教育室と図書館が含まれていた。これは当時、国内インターネット浪潮の初期の波だった。校長もコンピュータ競技会への参加を支援し、前2学年の先輩たちが数名、コンピュータを通じて重点大学に合格していたからだ。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;これまでこのようなことを振り返ったことはなかった。そうはならないのは当然だろう。卒業後、私は自動化専攻を義無反顧的にコンピュータ業界に転身したが、種はすでに植えられていた。局中の人は自分の状況を知らないだけだった。幼い頃から多くのものに触れていたため、自分がとても優秀だと思っていたが、実際には表面的な知識しか持っていなかった。最大の強みは最初の情熱だった。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;硬件组装&#34;&gt;硬件组装
&lt;/h3&gt;&lt;p&gt;PCバカ、chiphell、知乎のPC自作の板を逛逛し、萌新でも比較的簡単に自分に必要な機材リストを作成できます。2019年以降にCPUを選ぶ場合、経済的な条件が限られている場合は、より高い性能を得るためにAMDを優先的に選びます。
一般的なハードウェア性能比較サイトをご紹介します：&lt;a class=&#34;link&#34; href=&#34;https://cpu.userbenchmark.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cpu.userbenchmark.com/&lt;/a&gt;　価格に関しては、eBayの米版と咸鱼（中国版ヤフオク）で比較するのが良いでしょう。真の達人であれば、咸魚で中古品を探すことも可能です。大幅に安く購入できます。あまりPCに詳しくない場合は、咸魚は推奨しません。私は偽メモリを購入しましたが、現状使用しても問題がないようです。詳細は不明で、型番とパラメータが完全に一致していません。&lt;/p&gt;
&lt;h4 id=&#34;sn550-vs-sn750&#34;&gt;SN550 VS SN750
&lt;/h4&gt;&lt;p&gt;SN550とSN750の1TB容量の違いは、両者の継続的な読み書き速度が倍になることです。SN550では850MB、SN750では1.6GBですが、日常使用においては違いを感じられません。これは両者が4K性能において同じであるためです。もちろん、ここで言うSN550は1TB容量のものです。500Gや250Gの容量では、順応読み書き速度がより遅くなります。実際には、お金を惜しまないわけではない限り、日常使用であればSN550を購入するのが良いでしょう。私がこのモデルを選ばなかった主な理由は、その容量が最大1TBであることと、SN750が2TB容量を持つことです。私にとって、追加の拡張なしに、マザーボードのM.2 NVMeインターフェースの方がより価値があると感じたからです。&lt;/p&gt;
&lt;p&gt;総じて、ネットユーザーの結論として、B150のマザーボードでもM.2インターフェースに対応したSSDを導入することができます。&lt;/p&gt;
&lt;h4 id=&#34;机械硬盘選购&#34;&gt;机械硬盘選购
&lt;/h4&gt;&lt;p&gt;機械硬盘現在價格趨於穩定，對於有大量儲存需求的使用者，需要選購一款合適的機械硬盘，頻繁下載資源的使用者推薦企業級硬盘，常見的有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;西數金盤&lt;/li&gt;
&lt;li&gt;希捷Exos
&lt;strong&gt;大容量的機械硬盘推薦進行分区，頻繁的下載操作固定在某个分区進行，日後出現壞道，可以集中在某个分区，廢棄當前分区即可，能有效延長機械硬盘寿命。&lt;/strong&gt;
希捷系列&lt;a class=&#34;link&#34; href=&#34;https://www.seagate.com/cn/zh/enterprise-storage/exos-drives/exos-e-drives/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方介紹&lt;/a&gt;
&lt;img src=&#34;https://ttf248.life/p/computer-assembly/%E5%B8%8C%E6%8D%B7exos1.png&#34;
	width=&#34;589&#34;
	height=&#34;659&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;希捷企業級硬盘概述&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;89&#34;
		data-flex-basis=&#34;214px&#34;
	
&gt;
&lt;img src=&#34;https://ttf248.life/p/computer-assembly/%E5%B8%8C%E6%8D%B7exos2.png&#34;
	width=&#34;588&#34;
	height=&#34;661&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;希捷企業級硬盘概述&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;88&#34;
		data-flex-basis=&#34;213px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;メモリ周波数&#34;&gt;メモリ周波数
&lt;/h4&gt;&lt;p&gt;日常業務の観点から見ると、周波数はパフォーマンスに大きな影響を与えません。
&lt;a class=&#34;link&#34; href=&#34;%e3%83%a1%e3%83%a2%e3%83%aa.png&#34; &gt;メモリ時系列画像&lt;/a&gt; &lt;a class=&#34;link&#34; href=&#34;%e5%92%b8%e9%ad%9a%e3%83%a1%e3%83%a2%e3%83%aa.png&#34; &gt;咸鱼メモリ画像&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;メモリ時系列（英語：Memory timingsまたはRAM timings）は、シリアル・ダイナミック・ランダム＝アクセスの記憶装置（SDRAM）のパフォーマンスを記述する4つのパラメータです。CL、TRCD、TRP、およびTRASで、クロックサイクル単位で測定されます。これらのパラメータは通常、破折号で区切られた4桁の数字として記述されます（例：7-8-8-24）。第4パラメータ（RAS）は頻繁に省略され、場合によっては5番目のパラメータであるコマンドレート（命令レート）が追加されることがあります。これは通常2Tまたは1Tで、2N、1Nと表記されます。これらのパラメータは、ランダムアクセスメモリの速度に影響を与える潜伏時間（遅延時間）を指定します。数字が低いほど、一般的にパフォーマンスは向上します。&lt;/p&gt;
&lt;p&gt;システム性能を決定する最終的な要素は、実際の遅延時間です。これは通常ナノ秒単位で測定されます。&lt;/p&gt;
&lt;p&gt;メモリ時系列を実際の遅延時間に変換する場合、クロックサイクル単位であることに注意することが重要です。クロックサイクルの時間を知らない場合、2つの数字のセットがどちらがより速いかを判断することはできません。&lt;/p&gt;
&lt;p&gt;たとえば、DDR3-2000 メモリのクロック周波数は1000 MHzで、そのクロック周期は1 nsです。この1 nsのクロックに基づいて、CL=7 が与えられた絶対遅延は7 ns です。より高速な DDR3-2666（クロック 1333 MHz、各サイクルあたり 0.75 ns）では、より大きな CL=9 を使用できますが、生成される絶対遅延は 6.75 ns となります。&lt;/p&gt;
&lt;p&gt;現代の DIMM には、自動構成を推奨するシリアル存在検出 (SPD) ROM チップが含まれています。PC の BIOS は、パフォーマンスを向上させるためにユーザーがメモリ時系列を調整できるように（安定性にリスクがある）、または特定の状況で安定性を高めるために（推奨された時系列を使用するなど）許可することがあります。&lt;/p&gt;
&lt;p&gt;注：メモリ帯域幅は、メモリの透過量（スループット）を測定し、通常は転送レートによって制限されます。複数の内部バンクに並行して SDRAM にアクセスすることで、ピークレートで連続的にデータを転送できます。潜伏時間を増やすことで帯域幅を増加させる可能性があります。具体的には、各新しい DDR メモリ世代には高い転送レートがありますが、絶対遅延はほとんど変化しません。特に市場に出回った最初の新世代製品では、前世代よりも遅延が長くなる傾向があります。&lt;/p&gt;
&lt;p&gt;メモリの遅延が増加しても、メモリ帯域幅を増やすことで、マルチプロセッサまたは複数の実行スレッドを持つコンピュータシステムのパフォーマンスを向上させることができます。より高い帯域幅は、専用ビデオメモリのない統合グラフィックス カードのパフォーマンスも向上させます。
&lt;a class=&#34;link&#34; href=&#34;%e3%83%a1%e3%83%a2%e3%83%aa%e6%99%82%e5%ba%8f%e5%8f%82%e6%95%b0%e8%af%b4%e6%98%8e.png&#34; &gt;メモリ時系列パラメータの説明画像&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;参考文献&#34;&gt;参考文献
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E6%97%B6%E5%BA%8F&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;メモリ時系列パラメータに関する説明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>ウェブサイトの高速化とドメイン設定</title>
        <link>https://ttf248.life/ja/p/website-acceleration-and-domain-setup/</link>
        <pubDate>Sat, 20 Jun 2020 10:36:27 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/website-acceleration-and-domain-setup/</guid>
        <description>&lt;p&gt;境内アクセス時のGitHub Pagesの速度が遅いため、著者が個人ドメインを取得し、国内クラウドホスティングプロバイダーのCDN加速サービスを購入しました。設定中に、wwwサフィックスドメインへのアクセスができない問題が発生しましたが、最終的に汎用ドメインのDNS解析を削除し、セカンドレ벨ドメインを個別に設定することで解決しました。著者はまた、CDN加速の原理と設定経験、およびNginxを用いた逆プロキシの試みと教訓についても共有しています。&lt;/p&gt;
&lt;h3 id=&#34;背景&#34;&gt;背景
&lt;/h3&gt;&lt;p&gt;ウェブサイトはGitHub Pagesにホストされており、周知のところ、GitHub Pagesへの国内アクセスが遅いことがありました。そこで個人ドメインを取得し、国内クラウドホスティングプロバイダーのCDN加速サービスを購入しました。加速サービスのセットアップ時に、開発マシンにもDocker、frp、k8sなどのサービスをデプロイしており、これらのサービスにはそれぞれダッシュボードが用意されていることを思い出し、無駄を省くという原則に基づき、複数のリバースプロキシを設定し、すべてサブドメインに付与しました。
その時、サブドメインであるwwwがアクセスできなくなったことに気づきました。阿里云でDNS設定を行い、www.xiangtianlong.comとxiangtianlong.comの両方を解析するように設定しましたが、CDN加速を有効にしていないときは両方のドメインが正常に使用できました。
CDN加速を設定した際、サブドメインが多数存在するため、汎用的なルールを有効にし、すべて開発マシンにルーティングしました。その結果、wwwというサブドメインもダウンしてしまいました。はい、正しく理解してくださいましたか？wwwプレフィックスはサブドメインです。実際にはウェブサイトはGitHub Pagesにデプロイされており、開発マシンにはウェブサイトのキャッシュ情報は一切ありません。
開発マシンにサイトをデプロイしなかったのは、静的ブログであり、GitHubが提供するActionで自動的に統合して公開されるため、本当に美味しかった（真香）からです。&lt;/p&gt;
&lt;h3 id=&#34;ドメイン&#34;&gt;ドメイン
&lt;/h3&gt;&lt;p&gt;非専門的なWeb開発において、ドメインの理解はSEOやクロスオリジン問題といった概念を含まない。ブログサイトとして、裸ドメインがブログ主のサイトを強調しやすく、特に私が漢数字でのローマ字表記をドメイン名としている場合や、現在のモバイルアクセスが多い状況では、入力する文字数を減らすことが望ましい。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PC版ではキーボードショートカットでwwwとcomの入力を省略可能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;cdn&#34;&gt;CDN
&lt;/h3&gt;&lt;p&gt;阿里云和腾讯云都用过，初心者でも扱いやすく、腾讯云には動画で関連概念を解説しています。CDN加速の原理は、京东倉庫と似ています。新商品が出版される際、全国各地の倉庫にまとめて配送し、配送リクエストが発生した際に、最も近い倉庫から配信します。&lt;/p&gt;
&lt;p&gt;キャッシュサーバー（回源アドレス）：ウェブサイトのリソースが元の場所で保存されている場所
キャッシュファイルの設定：ブラウザのF12で管理コンソールを開き、静的リソースと動的リソースを分析する&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全て0日有効期限&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.php;.jsp;.asp;.aspx&lt;/code&gt; 0日有効期限&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.jpg;.png;.js;.css;.woff2&lt;/code&gt; 1日有効期限&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;腾讯云設定ルール：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;キャッシュ过期ルールは最大10件まで設定可能&lt;/li&gt;
&lt;li&gt;複数のキャッシュ过期ルール間の優先順位は、下から上にいくほど高い&lt;/li&gt;
&lt;li&gt;キャッシュ过期時間は最大365日まで設定可能&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;悲惨自述&#34;&gt;悲惨自述
&lt;/h3&gt;&lt;p&gt;以前从未用过Nginx，以为网站随便搜索就能明白反向代理的配置，结果有点混乱，折腾半天连个302跳转也没弄明白，最终毫无用处。就想着笨办法解决一下，DNS解析删除*模式的泛域名解析，单个二级域名进行独立设置。这时突然注意到了阿里云DNS解析有一个叫做“显示URL跳转”的模式，尝试了一下，这不就是我想要的302跳转吗。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设置了第一个二级域名正常访问，等我设置第二个的时候，发现没用，都快怀疑人生了，等了一会突然就能用了，看来阿里云的DNS扩散偶尔也是会抽风的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;参考資料&#34;&gt;参考資料
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/question/20414602&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;なぜ多くのウェブサイトのドメイン名に「www」プレフィックスが付加されないのか？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cloudxns.net/Support/detail/id/918.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;www付きとそうでないドメイン名の違いは何ですか？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://gythialy.github.io/Docker-nginx-reverse-proxy/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Docker nginx 反向プロキシ設定&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>ブログIDE環境と雑感</title>
        <link>https://ttf248.life/ja/p/blog-ide-environment-and-ramblings/</link>
        <pubDate>Tue, 31 Mar 2020 13:54:27 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/blog-ide-environment-and-ramblings/</guid>
        <description>&lt;p&gt;本記事では、Markdownの基本的な概念と、さまざまなソフトウェアでの利用について紹介しています。VSCodeをIDEとして推奨し、おすすめプラグインも列挙しています。作者はHexoからHugoへの移行経験を共有し、Hugoの柔軟性とカスタマイズ性を強調しています。最後に、新しい技術を迅速に習得するためのヒントや、Hugoテーマのスタイルが更新されない問題を解決する簡単なコツを紹介します。&lt;/p&gt;
&lt;h2 id=&#34;はじめに&#34;&gt;はじめに
&lt;/h2&gt;&lt;h3 id=&#34;markdown&#34;&gt;Markdown
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;軽量マークアップ言語であり、人間が読み書きしやすいプレーンテキスト形式でドキュメントを作成することを可能にする。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;markdown-1&#34;&gt;Markdown
&lt;/h3&gt;&lt;p&gt;詳細なMarkdown構文については、本文で別途詳述しません。電子書籍を推奨します。&lt;a class=&#34;link&#34; href=&#34;https://markdown-zh.readthedocs.io/en/latest/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;こちらをクリック&lt;/a&gt;
市場には多くのソフトウェアがMDを記述方法としてサポートしています。CSDNのブログシステムはMD構文に対応したオンラインエディターを導入しており、初回使用時にデフォルトでMD構文に関する紹介記事が表示されます。筆記者自身もそれなりに有用だと感じています。印象笔记では2018年にMDノートのサポートを追加し、ショートカットバーには様々なMDマークアップのオプションがあり、普通の文章を編集するのとほぼ同じように使えます。全体的なインタラクションフローは初心者にもフレンドリーです&lt;/p&gt;
&lt;h3 id=&#34;ide-推奨&#34;&gt;IDE 推奨
&lt;/h3&gt;&lt;p&gt;この記事を書いているのは2020年であり、VS Code は当然のことながら皆知っているでしょう。なぜなら、Git Page をブログシステムとして構築することを考える業界人は少なくないからです。数年前には、Sublime や Atom も優れた選択肢でした。オープンソースコミュニティの推進により 2 年間にわたって発展し、現在では VS Code が初心者にとっての最初の選択肢となっています。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Microsoft の巨頭とオープンソースコミュニティの関係は、対立状態から成功裏に蜜月期に入りました：オープンソースを抱擁しています。筆者所在の会社も最近 2 年間にわたり積極的に Java エコシステムを取り入れており、ビジネス開発においては、現在国内で Java エコシステムはまさに「魅力的」です。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;vscodeプラグインのおすすめ&#34;&gt;VSCodeプラグインのおすすめ
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/blog-ide-environment-and-ramblings/2020-03-31-14-07-17.png&#34;
	width=&#34;310&#34;
	height=&#34;306&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;プラグインリスト&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;101&#34;
		data-flex-basis=&#34;243px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;プラグインにはそれぞれReadmeがあり、基本的な使い方や主要な機能が紹介されています。一部のプラグイン作者は、動的な効果を表示する画像も提供しています。
&lt;code&gt;Paste Image&lt;/code&gt;とhugoの画像プラグイン方式を組み合わせることで、非常に簡単に画像を挿入できます。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ショートカットキーを忘れてしまった場合、VSCodeのショートカットキー管理メニューを開き、「md」で検索して数回確認しましょう。Readmeをもう一度見直すのも良いでしょう。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;hugo&#34;&gt;Hugo
&lt;/h2&gt;&lt;p&gt;筆者は&lt;code&gt;hexo&lt;/code&gt;から&lt;code&gt;hugo&lt;/code&gt;に切り替えた。愛折衝は私の天性であり、結局は忍耐強く静かに記事を書くことができないのだ。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Hugoは、個別のフォルダに画像とmdドキュメントを置くことをサポートする。&lt;/li&gt;
&lt;li&gt;Academicテーマのデザイン上では、様々な種類の文章スタイルをサポートしている。&lt;/li&gt;
&lt;li&gt;様々な便利なカスタム拡張機能がある。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;学術&#34;&gt;学術
&lt;/h2&gt;&lt;p&gt;公式サイトではデフォルトで&lt;code&gt;exampleSite&lt;/code&gt;を使用し、メニューのインポートには&lt;code&gt;#component&lt;/code&gt;形式が推奨されます。URLのパターンは、ナビゲーションバーをクリックすることで単一ページのジャンプを実現し、ホームページでのスクロールを回避します（これは純粋な個人的な好みです）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;スタイル：ノート、講演、電子書籍&lt;/li&gt;
&lt;li&gt;柔軟性：全体的なスタイルのカスタマイズ、カスタムCSSスタイルの適用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このテーマは、中国語のサポートがまだ十分ではありません。主に視覚的な観点からすると、フォントサイズが中国語の読書習慣に合っていません。Hexoの開発者はほとんどが中国人であり、この点ではHugoよりも優れています。しかし、自分で手を加えて、ブラウザで要素を検証することで、要素を見つけ出し、変更するCSSスタイルの名前を知ることができます。サイドバーで&lt;strong&gt;Insert Style Rule Below&lt;/strong&gt;をクリックすると、ネストされた多層構造のCSSでも簡単にノード名を取得できます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://sourcethemes.com/academic/docs/customization/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;カスタムCSSの導入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://sourcethemes.com/academic/docs/customization/#add-scripts-js&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;カスタムJSの導入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;テーマに組み込まれている構文強調表示の設定については、&lt;a class=&#34;link&#34; href=&#34;https://sourcethemes.com/academic/docs/writing-markdown-latex/#highlighting-options.&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;公式ドキュメント&lt;/a&gt;を参照してください。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;結論&#34;&gt;結論
&lt;/h2&gt;&lt;p&gt;子供たちがまた文句を言っているようだ。「最初から最後まで、曖昧で、細かいこと何も言ってない」と。&lt;/p&gt;
&lt;p&gt;私はこう言うつもりだ。以下のものがあれば十分だ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公式マニュアル&lt;/li&gt;
&lt;li&gt;プラグインの説明書&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新しい技術をすぐに使いこなすには、まず公式サイトのドキュメントを読むことを推奨する。完璧に理解しようとする必要はないし、一度読んで理解する必要もない。少なくとも、ある程度の知識は持っておくべきだ。検索エンジンで見つかる結果が、必ずしも最新版と一致しない。誤解を招く可能性もある。新しい本も同様だ。まず目次を見て、著者が何を説明するのか把握する。場合によっては、序文を読むのが良い。特に海外の著作を翻訳した際に、翻訳者の序文は書籍と核心的な内容をカバーしていることがある。&lt;/p&gt;
&lt;h2 id=&#34;エッグ卵&#34;&gt;エッグ（卵）
&lt;/h2&gt;&lt;p&gt;Hugo Academicの組み込みスタイルを切り替え、サイトに公開後、アクセス時にスタイルが変更されない。賢い仲間たちはすでに解決策を見つけており、「ブラウザキャッシュをクリア」することで問題が解決する。私のような機転の利いた者：「F12開発者ツール」で&lt;code&gt;network&lt;/code&gt;タブを選択し、&lt;code&gt;disable cache&lt;/code&gt;オプションをチェックしてリフレッシュすれば、完璧！
&lt;img src=&#34;https://ttf248.life/p/blog-ide-environment-and-ramblings/2020-03-31-14-27-15.png&#34;
	width=&#34;399&#34;
	height=&#34;142&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;network&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;280&#34;
		data-flex-basis=&#34;674px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>自動統合システム切り替え</title>
        <link>https://ttf248.life/ja/p/auto-integration-system-switch/</link>
        <pubDate>Sun, 29 Mar 2020 02:11:33 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/auto-integration-system-switch/</guid>
        <description>&lt;p&gt;GitHub Actions を使用して、Hugo ブログを GitHub Pages および Gitee に自動でデプロイします。&lt;/p&gt;
&lt;h4 id=&#34;背景説明&#34;&gt;背景説明
&lt;/h4&gt;&lt;p&gt;昨日ブログを更新した際に、Travisサービスが利用できないことを発見しました。Travisのウェブサイトを確認すると、ソースコードの取得時に進捗が止まっていることがわかりました。そこで、GitHubが以前に発表していたActionサービスを思いつきました。
当時、業務が多忙であり、Actionを利用するには申請が必要だったため、現在は正式にリリースされ、週末に暇を持て余している間に、新しいおもちゃを試してみようかと思いました？
公式資料は、ご自身でウェブサイトをご確認ください。本記事では、より多くの転載を行いません。もしKubernetesをご利用経験がある場合、ActionのYAMLファイル設定がKubernetesと非常に似ていることに気づくでしょう。
入門チュートリアル、あるいは中国語の説明資料については、&lt;strong&gt;阮一峰のブログ&lt;/strong&gt;を検索することをお勧めします。2つの記事があり、1つ目は基本的な構文の紹介であり、もう1つは実際のケーススタディです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
正文
必要な知識点
- GitHub Secrets
- Action の構文
コアのジョブは既存のコンポーネントを使用して完了し、国内のGiteeにプッシュするにはコマンドを使用します。このコマンド部分は粗暴で、強制プッシュのみを実装しており、Travisを使用していた際のロジックを継承しています。

```yaml
name: github pages and gitee pages

on:
  push:
    branches:
      - hugo

jobs:
  deploy:
    runs-on: ubuntu-18.04
    steps:
      - uses: actions/checkout@v2
        with:
          submodules: true

      - name: Setup Hugo
        uses: peaceiris/actions-hugo@v2
        with:
          hugo-version: &#39;latest&#39;
          extended: true

      - name: Build Github and Gitee ## 単独ステップには1つのrunコマンドしか書けない
        run: hugo -b &amp;quot;https://www.xiangtianlong.com/&amp;quot; -d &amp;quot;github_public&amp;quot; &amp;amp;&amp;amp; hugo -b &amp;quot;https://www.xiangtianlong.com/&amp;quot; -d &amp;quot;gitee_public&amp;quot; &amp;amp;&amp;amp; ls

      - name: Deploy Github
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.BLOG_TOKEN }}
          publish_dir: ./github_public
          publish_branch: master
          cname: xiangtianlong.com

      - name: Deploy Gitee
        run: cd ./gitee_public &amp;amp;&amp;amp; git init &amp;amp;&amp;amp; git config user.name &amp;quot;TianlongXiang&amp;quot; &amp;amp;&amp;amp; git config user.email &amp;quot;tianlongxiang51@gmail.com&amp;quot; &amp;amp;&amp;amp; git add . &amp;amp;&amp;amp; git commit -m &amp;quot;Update TianlongXiang&#39;s Blog&amp;quot; &amp;amp;&amp;amp; git push --force &amp;quot;https://xiangtianlong:${{ secrets.GITEE_PASSWORD }}@gitee.com/xiangtianlong/xiangtianlong.git&amp;quot; master:master
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;付録&#34;&gt;付録
&lt;/h4&gt;&lt;p&gt;公式マーケットで提供されているactionを見ると、現在サポートされている遊び方があまりにも多い。Dockerイメージを構築すれば、Docker Hubから提供されるサービスへの依存関係もなくなります。&lt;/p&gt;
&lt;p&gt;Hugoのissueを調査すると、GitHub Actionを使ってgit pagesを自動デプロイする際に、最終的に公開されるウェブサイトがmasterブランチにある必要があることがわかります。もし他のブランチにデプロイする場合は、設定画面でGitHubはウェブサイトに構文エラーがあると警告します。&lt;/p&gt;
&lt;p&gt;これは単にHugoのソースファイルがmasterブランチにあるため、GitHubがjellyブログのソースコードとして検出し、構文チェックが通らない場合に発生するエラーです。&lt;/p&gt;
&lt;p&gt;解決策は簡単です。Hugoのソースファイルを他のブランチに配置し、静的ファイルをmasterブランチに公開します。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>標準ライブラリコンテナのメモリ割り当て子：allocator</title>
        <link>https://ttf248.life/ja/p/standard-library-container-memory-allocator/</link>
        <pubDate>Mon, 30 Dec 2019 13:26:19 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/standard-library-container-memory-allocator/</guid>
        <description>&lt;p&gt;カスタムディストリビューターは、パフォーマンスを向上させ、メモリ使用効率を高め、頻繁な少量のメモリ割り当ての問題を解決できます。&lt;/p&gt;
&lt;h4 id=&#34;前因&#34;&gt;前因
&lt;/h4&gt;&lt;p&gt;近頃、ネットワークパケットの開発に携わり、頻繁に小さなメモリ領域を申請し解放する必要があり、当初はメモリプールを使用することを検討していました。いくつかの既存のメモリプールを確認したところ、この
&lt;a class=&#34;link&#34; href=&#34;https://github.com/cacay/MemoryPool&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/cacay/MemoryPool&lt;/a&gt;
を見つけました。インターフェースを見たとき、このメモリプールの実装が少し奇妙だと疑問に思いました。「MemoryPool」の実装ロジックは、固定サイズのメモリ領域を申請することです。boostのメモリプールインターフェースを見てみると、テンプレートを提供し、使用時にインスタンス化します。ちょうどこのライブラリには、&lt;code&gt;allocator&lt;/code&gt;という概念について言及した記事があります。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;#### [wiki](https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_(C%2B%2B))

C++プログラミングにおいて、割り当て子（英語：allocator）はC++標準ライブラリの重要な構成要素です。C++のライブラリには、リスト、集合などのように、さまざまな「コンテナ」と呼ばれるデータ構造が定義されており、これらのコンテナの共通の特徴は、プログラムの実行時にサイズを変更できることです。この機能を実装するために、動的メモリ割り当てが必要となります。割り当て子は、これらのコンテナがメモリへの割り当てと解放のリクエストを処理するために使用されます。言い換えれば、割り当て子は、標準テンプレートライブラリ（STL）コンテナのメモリ管理に関する低レベルの詳細をカプセル化します。

割り当て子は、アレクサンドル・ステパノフによってC++標準テンプレートライブラリ（STL）の一部として最初に発明されました。その目的は、「ライブラリをより柔軟にし、低レベルのデータモデルに独立した方法で利用できるようにする」ことであり、プログラマがライブラリ内でカスタムポインタや参照型を使用することを可能にするものでした。ただし、標準テンプレートライブラリをC++標準に組み込む際、C++標準委員会は、完全なデータモデル抽象化処理が不可受容なパフォーマンス低下をもたらすことを認識しました。そのため、妥協策として、割り当て子の制限がより厳しくなり、ステパノフの当初の構想と比較して、現在の標準で記述されている割り当て子のカスタマイズ性は大幅に制限されています。

割り当て子のカスタマイズは制限されていますが、多くの状況ではカスタム割り当て子が必要となります。これは通常、異なる種類のメモリ空間（共有メモリと回収されたメモリなど）へのアクセス方法をカプセル化したり、メモリプールを使用したメモリ割り当てのパフォーマンスを向上させたりするために行われます。さらに、メモリ使用量と実行時間から見ると、頻繁に少量のメモリを割り当てるプログラムでは、専用の割り当て子を作成することで利益を得ることができます。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;#### [使用需求](https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_(C%2B%2B))

カスタムアロケータの主な理由は性能向上です。専用のアロケータを使用することで、プログラムのパフォーマンスを向上させたり、メモリ使用量を削減したり、あるいは両方を組み合わせることも可能です[4][8]。デフォルトのアロケータは`new`演算子を使用してストレージスペースを割り当てるため、これは通常C言語のヒープ割り当て関数（`malloc()`）によって実装されます[9]。ヒープ割り当て関数は、偶発的な大量メモリ割り当てを最適化するように設計されているため、ベクトルや双端キューなどの、一度に大量のメモリを必要とするコンテナにメモリを割り当てる場合は、デフォルトのアロケータは通常効率的です[8]。しかし、連想コンテナと双方向リストのような、頻繁に少量メモリを割り当てて解除するコンテナの場合、デフォルトのアロケータを使用すると、通常効率が低下します[4][9]。さらに、`malloc()`に基づくデフォルトのアロケータには、より悪い参照局所性や、メモリの断片化を引き起こす可能性があるなど、多くの問題があります[4][9]。

要するに、このセクション（……）（まるで）は、この標準におけるアロケータに関する「夢を見た」のスピーチです。夢が実現する前に、移植性を重視するプログラマーは、ステートレスなカスタムアロケータを使用することになります。
——スコット・メイエス，《Effective STL》

上記を踏まえ、メモリ割り当ての頻度が多い場合に、メモリプールベースのアロケータを使用して問題を解決することがよくあります[8]。オンデマンド割り当てとは異なり、メモリプールベースのアロケータを使用する場合、プログラムは事前に大きなブロックのメモリ（つまり「メモリプール」）を割り当て、次にメモリを割り当てる必要がある場合、カスタムアロケータは、リクエスト元にプール内のメモリへのポインタを返します。オブジェクトが破棄される際には、実際の割り当て解除を行うのではなく、メモリプールのライフサイクルが終了するまで遅延させます[注 1][8]。

「カスタムアロケータ」というトピックに関しては、多くのC++専門家や著者がこの分野で議論しており、スコット・メイエス著の《Effective STL》やアンデル・アレクサンドレスク著の《Modern C++ Design》に言及しています。メイエスは、特定の型`T`のアロケータのすべてのインスタンスが等しいという要件を満たす移植可能なアロケータのインスタンスにはステートを含めない必要があると洞察しており、ステートレスなアロケータの使用を推奨しています。C++標準はライブラリの実装者が状態を含むアロケータをサポートするように奨励していますが、メイエスは「このセクションは、（まるで）素晴らしい見方ですが、ほとんど空言であり」、アロケータの制約は「過度に厳格」であると述べています[4]。たとえば、STLの`list`は`splice`メソッドをサポートしており、これは1つのリストオブジェクト`A`のノードが別のリストオブジェクト`B`に直接挿入されることを意味し、`A`のアロケータによって割り当てられたメモリが`B`のアロケータによって解放される必要があるため、`A`と`B`のアロケータインスタンスは等しいことが導き出されます。メイセスの結論は、アロケータはステートレスな静的メソッドの型として定義するのが最善であるということです。たとえば、C++標準では、アロケータは`rebind`メソッドを実装するその他のクラステンプレートを持つ必要があります。

さらに、ヤン・ストローストルップ著『C++プログラミング言語』では、「割り当てを厳密に制限し、各オブジェクトの情報を異なるようにすることについては、明らかに問題ありません」（大意）と述べており、ほとんどのアロケータはステートを持たず、ステートを持たない場合でもパフォーマンスが向上するという意見を示しています。彼は、メモリプール型アロケータ、共有メモリ型アロケータ、ガベージコレクション型アロケータの3種類のカスタムアロケータを提案し、内部メモリプールを使用して少量メモリを高速に割り当て/解除するアロケータの実装を示しました[3]。ただし、このような最適化は、彼の提供したサンプルアロケータで既に実現されている可能性があると彼は指摘しています。

カスタムアロケータのもう1つの用途は&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
    </channel>
</rss>
