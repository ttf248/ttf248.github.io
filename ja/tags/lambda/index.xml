<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Lambda on 向叔の手帳</title>
        <link>https://ttf248.life/ja/tags/lambda/</link>
        <description>Recent content in Lambda on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Sun, 25 May 2025 14:10:37 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/tags/lambda/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>C&#43;&#43;ラムダ式パラメータのライフサイクル</title>
        <link>https://ttf248.life/ja/p/cpp-lambda-parameter-lifetime/</link>
        <pubDate>Wed, 13 Nov 2024 19:23:02 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cpp-lambda-parameter-lifetime/</guid>
        <description>&lt;p&gt;C++において、ラムダ式は便利な匿名関数であり、外部変数をキャプチャしてその内部で使用できます。これにより、ラムダ式は柔軟なプログラミングツールとなります。ただし、ラムダ式のパラメータのライフサイクルは特に注意すべき点であり、特にキャプチャおよびパラメータの伝送時にはそうです。&lt;/p&gt;
&lt;h3 id=&#34;ラムダ式のパラメータのライフサイクル&#34;&gt;ラムダ式のパラメータのライフサイクル
&lt;/h3&gt;&lt;p&gt;ラムダ式のパラメータの寿命は、通常、他のC++関数と同様です。関数のパラメータは、関数呼び出し中に存在し、関数呼び出しが終了すると、パラメータの寿命は終了します。しかしながら、ラムダ式が外部変数にキャプチャする場合、パラメータの寿命はキャプチャ方法の影響も受けます。&lt;/p&gt;
&lt;h3 id=&#34;キャプチャとパラメータのライフサイクルとの関係&#34;&gt;キャプチャとパラメータのライフサイクルとの関係
&lt;/h3&gt;&lt;h4 id=&#34;21-外部変数の捕捉&#34;&gt;2.1 外部変数の捕捉
&lt;/h4&gt;&lt;p&gt;C++のラムダ式は、外部変数を2つの方法でキャプチャできます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;値キャプチャ：値キャプチャによって、外部変数の値がラムダ関数内にコピーされ、そのコピーのライフサイクルはラムダ関数のライフサイクルによって制御されます。&lt;/li&gt;
&lt;li&gt;参照獲得：参照獲得により、外部変数の参照は保持され、ラムダ内の参照は元の外部変数を示し、寿命はその外部変数に依存します。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda_by_value = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };  // 捕获x的副本
auto lambda_by_reference = [&amp;amp;x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };  // 捕获x的引用

lambda_by_value();  // 打印10
lambda_by_reference();  // 打印10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;捕捉された変数のライフサイクルは以下の通りです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;値によるキャプチャ：キャプチャされたとき、外部変数の値がラムダにコピーされます。そして、ラムダのライフサイクルが終わると、そのコピーが破棄されます。&lt;/li&gt;
&lt;li&gt;参照によるキャプチャ：ラムダが外部変数への参照を持つ場合、&lt;strong&gt;外部変数はラムダの使用前に有効である必要があり、そうでないと未定義の動作が発生する可能性がある&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ラムダパラメータ&#34;&gt;ラムダパラメータ
&lt;/h4&gt;&lt;p&gt;ラムダのパラメータは通常の関数パラメータと同様で、そのライフサイクルはラムダ関数内に限定されます。つまり、ラムダパラメータはラムダ呼び出し時に作成され、ラムダ呼び出しが終了すると、パラメータのライフサイクルも終了します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto lambda = [](int a, int b) {
    std::cout &amp;lt;&amp;lt; a + b &amp;lt;&amp;lt; std::endl;
};
lambda(5, 10);  // a和b在这里是lambda的参数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この例では、&lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; はラムダ式のパラメータであり、ラムダ式の呼び出し時に作成され、実行終了後に破棄されます。&lt;/p&gt;
&lt;h3 id=&#34;キャプチャした外部変数のライフサイクルに関する問題&#34;&gt;キャプチャした外部変数のライフサイクルに関する問題
&lt;/h3&gt;&lt;h4 id=&#34;キャプチャされた変数はラムダ関数外で有効に利用できるか&#34;&gt;キャプチャされた変数は、ラムダ関数外で有効に利用できるか。
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;値によるキャプチャ：ラムダ呼び出し後に外部変数が破棄されても、ラムダ内部は外部変数のコピーを保持します。したがって、外部変数はもう存在しなくても、ラムダ内部のコピーは安全に使用できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x 在lambda调用后修改
lambda();  // 打印10，捕获的是x的副本
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;参照によるキャプチャ：ラムダが外部変数の参照をキャプチャする場合、ラムダ内部でのその参照へのアクセスは外部変数のライフサイクルに依存します。外部変数がラムダの実行前に破棄されると、ハングリング参照の問題が発生し、未定義の動作につながる可能性があります。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [&amp;amp;x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x 在lambda调用前修改
lambda();  // 打印20，捕获的是x的引用
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ラムダの実行順序が確定しない場合、ラムダが実行される際にキャプチャされた外部変数が有効であることを保証することが非常に重要です。&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
