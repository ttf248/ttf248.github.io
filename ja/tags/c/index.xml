<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>C# on 向叔の手帳</title>
        <link>https://ttf248.life/ja/tags/c/</link>
        <description>Recent content in C# on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Sun, 25 May 2025 14:10:37 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/tags/c/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>WPFのUIスレッドと、その応答性の問題とその解決策</title>
        <link>https://ttf248.life/ja/p/wpf-ui-thread-and-freezing-issues-solutions/</link>
        <pubDate>Tue, 12 Mar 2024 07:12:21 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/wpf-ui-thread-and-freezing-issues-solutions/</guid>
        <description>&lt;p&gt;デスクトップアプリケーションを開発する際、特にWindows Presentation Foundation (WPF) フレームワークを使用してリッチクライアントアプリケーションを構築する場合、ユーザーインターフェース（UI）スレッドを正しく処理することは、アプリケーションの滑らかさと応答性を保証するために非常に重要です。UIスレッドは、メインスレッドとも呼ばれ、ウィンドウやコントロールイベントの処理、レイアウト計算、およびインターフェースの描画を担当するコアスレッドです。UI要素とのインタラクションに関わる操作はすべて、UIスレッド上で実行されるべきであり、これはWPFをはじめとする多くのGUIフレームワークが遵守する基本的な原則です。&lt;/p&gt;
&lt;h2 id=&#34;uiスレッドとは何ですか&#34;&gt;UIスレッドとは何ですか？
&lt;/h2&gt;&lt;p&gt;WPFアプリケーションの起動時に、OSによってUIスレッドが作成され、アプリケーションのメインウィンドウが初期化されます。これは、アプリケーション内で直接UIコンポーネントの状態にアクセスおよび変更できる唯一のスレッドです。つまり、ボタンクリック、テキストボックスへの入力、ウィンドウサイズの変更など、すべてのユーザーインタラクションによって発生するイベントは、このスレッドのコンテキストで処理されます。同時に、WPFの依存プロパティシステム、データバインディングメカニズム、およびレイアウトロジックもUIスレッド上で同期的に実行されます。&lt;/p&gt;
&lt;h2 id=&#34;カクつき現象とその原因&#34;&gt;カクつき現象とその原因
&lt;/h2&gt;&lt;p&gt;UIスレッドが長時間占有またはブロックされると、例えば時間のかかる計算や大量のデータ読み込み、データベースクエリなどのI/O集約型のタスクを実行すると、UIスレッドはユーザーからのインタラクションリクエストにタイムリーに応答できなくなり、結果として画面がフリーズ（応答なし）したように見える、「カドゥン」と呼ばれる状態になります。このような状況下では、ユーザーはアプリケーションの遅延や不具合を強く感じることがあり、深刻な場合には「Application Not Responding」（ANR）警告が表示されることもあります。&lt;/p&gt;
&lt;h2 id=&#34;uiスレッドの2つの基本的なルール&#34;&gt;UIスレッドの2つの基本的なルール
&lt;/h2&gt;&lt;p&gt;上記のような状況を避けるために、WPF開発者は以下の2つの重要なルールに従うべきです。&lt;/p&gt;
&lt;p&gt;UIスレッドで時間のかかる処理を実行しないでください。UIスレッドがユーザーの入力にタイムリーに応答し、画面の変化をレンダリングできるように、可能な限り時間のかかる操作はバックグラウンドスレッドで実行するようにしてください。
UIスレッド以外のスレッドで直接UI要素を更新しないでください。WPFのセキュリティ機構により、UI要素の変更はUIスレッドのみが許可されています。他のスレッドから直接UIの状態を変更しようとすると例外が発生します。したがって、バックグラウンドスレッドで計算やデータ準備が完了した場合でも、適切なクロススレッド通信メカニズムを通じて結果をUIに表示する必要があります。&lt;/p&gt;
&lt;h2 id=&#34;解決策非同期プログラミングとスレッドセーフな更新&#34;&gt;解決策：非同期プログラミングとスレッドセーフな更新
&lt;/h2&gt;&lt;p&gt;UI のスムーズさを維持しながら、時間のかかるタスクを実行するために、WPF は開発者がこの目標を達成するのを支援するためのさまざまな非同期プログラミングモデルとツールを提供します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ディスパッチャオブジェクト：WPFのDispatcherクラスを使用すると、作業項目をUIスレッドのタスクキューに配置して実行できます。&lt;code&gt;Dispatcher.Invoke&lt;/code&gt;または&lt;code&gt;Dispatcher.BeginInvoke&lt;/code&gt;メソッドを使用して、バックグラウンドスレッドから安全にUIを更新できます。&lt;/li&gt;
&lt;li&gt;C#言語の非同期機能を利用することで、非同期メソッドを記述し、その中で&lt;code&gt;await&lt;/code&gt;キーワードを使用してバックグラウンドタスク完了を待機し、完了後に自動的にUIスレッドで実行して、後続のUI更新コードを実行できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;事例&#34;&gt;事例
&lt;/h2&gt;&lt;h3 id=&#34;dispatcherinvokeメソッドを使用してuiを更新する&#34;&gt;&lt;code&gt;Dispatcher.Invoke&lt;/code&gt;メソッドを使用してUIを更新する。
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private void Button_Click(object sender, RoutedEventArgs e)
{
    // 假设这是一个耗时操作
    Task.Run(() =&amp;gt;
    {
        var result = LongRunningOperation(); // 这里是模拟一个耗时计算的方法
        
        // 当耗时操作完成后，在UI线程上更新UI
        Application.Current.Dispatcher.Invoke(() =&amp;gt;
        {
            LabelStatus.Text = $&amp;quot;计算结果: {result}&amp;quot;;
        });
    });
}

private string LongRunningOperation()
{
    // 模拟耗时操作
    Thread.Sleep(5000);
    return &amp;quot;已完成&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;asyncawaitキーワードとtaskrunを組み合わせる&#34;&gt;&lt;code&gt;async/await&lt;/code&gt;キーワードと&lt;code&gt;Task.Run&lt;/code&gt;を組み合わせる。
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private async void Button_ClickAsync(object sender, RoutedEventArgs e)
{
    Button button = sender as Button;
    button.IsEnabled = false; // 防止用户重复点击

    try
    {
        // 开启后台任务
        var result = await Task.Run(() =&amp;gt; LongRunningOperation());

        // 在后台任务完成后，自动切换回UI线程更新UI
        LabelStatus.Text = $&amp;quot;计算结果: {result}&amp;quot;;
    }
    catch (Exception ex)
    {
        MessageBox.Show($&amp;quot;发生错误: {ex.Message}&amp;quot;);
    }
    finally
    {
        button.IsEnabled = true; // 重新启用按钮
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        
    </channel>
</rss>
