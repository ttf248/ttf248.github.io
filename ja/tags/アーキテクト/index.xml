<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>アーキテクト on 向叔の手帳</title>
        <link>https://ttf248.life/ja/tags/%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%88/</link>
        <description>Recent content in アーキテクト on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Sun, 25 May 2025 14:10:37 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/tags/%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%88/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>自動テストの簡単な考察</title>
        <link>https://ttf248.life/ja/p/shallow-discussion-on-automation-testing/</link>
        <pubDate>Thu, 04 Aug 2022 11:39:18 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/shallow-discussion-on-automation-testing/</guid>
        <description>&lt;p&gt;金融取引システムにおけるテストへの投資は、他のシステムを大きく上回っており、煩雑なテスト手順が繰り返され、&lt;code&gt;ROI&lt;/code&gt; が低すぎる。プロジェクトや人員の交代に伴い、避けられない形で多くの制御不能な要因が導入され、よくあるのはAインターフェースの出力する特定のフィールドを変更した結果、Bインターフェースの結果に影響が出てしまうというケースだ。バージョンリリースごとにリスクも蓄積している。&lt;/p&gt;
&lt;h2 id=&#34;理論知識&#34;&gt;理論知識
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;自動化の価値をどのように測るか？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自動化テストケースのROI = （手動実行時間）*（実行回数） / （開発コスト + メンテナンスコスト）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;どの機能を自動テストする必要がありますか？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ユーザーがよく使う機能、頻繁に変更されない機能。このタイプのインターフェースに対して自動テストコードを書くことで、最も効果が得られます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;なぜこのタイミングで自動テストを推進するのか。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;プロジェクトのリリースが近づいている時期では、明らかに不適切です。遠い水を近くの渇きを癒すことはできず、自動化は長期的な収益モデルです。プロジェクトはすでに&lt;strong&gt;本番環境&lt;/strong&gt;にリリースされ、安定したリリースサイクルに入っており、まさにこのタイミングが最適です。&lt;/p&gt;
&lt;h2 id=&#34;フレームの選択&#34;&gt;フレームの選択
&lt;/h2&gt;&lt;p&gt;関連する実践経験がないまま、自動テストというタスクを得て、典型的な始め方：検索エンジンを開いて、現在のシステム&lt;strong&gt;技術スタック&lt;/strong&gt;で利用できるツールやフレームワークを探し、マニュアルを一度通して、作業開始だ。すぐに適切なツールが見つかれば、おめでとうございます、&lt;strong&gt;完璧なスタート&lt;/strong&gt;です。&lt;/p&gt;
&lt;p&gt;先に謝罪いたします。関連資料を調べたところ、存在しないというわけではなく、単にフレームワーク自体が複雑で、デプロイに必要なリソースも多すぎるようです。初心者向けのものは小さくて簡潔なものが求められます。テストチームの同僚に相談したところ、&lt;code&gt;Python&lt;/code&gt; で自作のフレームワークを作るという提案があり、簡単に言うと、既存のユニットテストフレームワークを使い、自動テストフレームワークとしてパッケージ化するというものです。&lt;/p&gt;
&lt;p&gt;このプロジェクトのデザインのアイデアを参考にしてください：&lt;a class=&#34;link&#34; href=&#34;https://github.com/wintests/pytestDemo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/wintests/pytestDemo&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;フレームが必要な理由は何ですか&#34;&gt;フレームが必要な理由は何ですか？
&lt;/h2&gt;&lt;p&gt;サービスには複数の異なるデプロイ環境があり、開発環境、テスト環境、本番環境があります。フレームワークの役割は、これらの環境を分離し、テストケースとデータを切り離すことです。異なる環境ごとに異なるテストデータが設定されており、もちろん共通データもサポートしています。&lt;/p&gt;
&lt;p&gt;根本的なロジックは、自動化の活用率を向上させるためのものです。 シナリオがいくら複雑になっても、異なる環境間のデータは互換性がなく、全く関係ありません。 設定事例データを追加する際は、&lt;code&gt;label&lt;/code&gt;タグを追加して、現在のデータがサポートしている環境を指定してください。&lt;/p&gt;
&lt;h2 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h2&gt;&lt;p&gt;最もコストパフォーマンスの高い自動テストをする&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
