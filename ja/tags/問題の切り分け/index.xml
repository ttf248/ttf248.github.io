<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>問題の切り分け on 向叔の手帳</title>
        <link>https://ttf248.life/ja/tags/%E5%95%8F%E9%A1%8C%E3%81%AE%E5%88%87%E3%82%8A%E5%88%86%E3%81%91/</link>
        <description>Recent content in 問題の切り分け on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Wed, 28 May 2025 09:47:38 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/tags/%E5%95%8F%E9%A1%8C%E3%81%AE%E5%88%87%E3%82%8A%E5%88%86%E3%81%91/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>プロトバッファのゼロ値の落とし穴：デフォルト値がビジネスロジックを密かに破滅させる</title>
        <link>https://ttf248.life/ja/p/protobuf-zero-value-traps/</link>
        <pubDate>Thu, 20 Feb 2025 15:26:51 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/protobuf-zero-value-traps/</guid>
        <description>&lt;p&gt;米国株には3つの取引時間帯があり、それぞれ盤前、盤中、盤後です。データインターフェースは、可能な限り帯域幅を節約するため、最初に全量データを送信し、その後はすべてのフィールドで増分データのみをプッシュするロジックを採用しています。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;なぜ最適な方法を使わないのか？異なるプロジェクトチームが関わっていて、すでに何年も稼働しているものもある。当方は新規連携なので、できる限り互換性を保つしかない。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;一連の問題&#34;&gt;一連の問題
&lt;/h2&gt;&lt;p&gt;概要だけ見れば、まだ問題なさそうに見えるかもしれない。しかし、システムアーキテクチャに問題が持ち込まれ、一連の問題を引き起こしている。先の問題を解決したと思えば、また新しい問題が発生し、それは以前の問題が原因だ。&lt;/p&gt;
&lt;h3 id=&#34;取引期間を識別できません&#34;&gt;取引期間を識別できません。
&lt;/h3&gt;&lt;p&gt;既知ディスク上の段階定義は、&lt;code&gt;protobuf&lt;/code&gt; 中定义为 0，但是在收到数据的时候由于是增量推送，业务方无法有效识别这个__INLINE_CODE_1__がデフォルト値か、実際のビジネス値かを指すものとします。&lt;/p&gt;
&lt;p&gt;毎回0を受け取ると、この0が新しいクォート設定の値なのか、protobufのデフォルト値なのかを判断できない。&lt;/p&gt;
&lt;h3 id=&#34;オプション導入&#34;&gt;オプション導入
&lt;/h3&gt;&lt;p&gt;Since protobuf release 3.15, proto3 supports using the optional keyword (just as in proto2) to give a scalar field presence information&lt;/p&gt;
&lt;p&gt;グループ内の通信プロトコルは、&lt;strong&gt;&lt;em&gt;5&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;3&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;6&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;4&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;7&lt;/em&gt;&lt;/strong&gt; に基づいており、プロジェクトの基盤が静的ライブラリとして提供されているため、コンパイルチェーン全体をアップグレードする必要があり、コストは非常に高い。&lt;/p&gt;
&lt;h3 id=&#34;gccのバージョン問題&#34;&gt;GCCのバージョン問題
&lt;/h3&gt;&lt;p&gt;なんとか案を思いついたものの、基盤で2つの異なるバージョンをリリースし、可能な限り &lt;code&gt;protobuf&lt;/code&gt; 新版本的编译依赖传播。但是在编译的时候，发现 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; 版本太低，不支持 &lt;strong&gt;INLINE_CODE_2&lt;/strong&gt; の新機能を抑制する。&lt;/p&gt;
&lt;p&gt;チーム内でよく使用されるサーバーの種類：CentOS 7、CentOS 8。CentOS 7 のデフォルトバージョンは 7.4 以上であるため、CentOS 7 はサポートできません。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=82461&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Bug 82461 - [7 Regression] Temporary required for brace-initializing (non-literal-type) member variable&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;最終、関連サービスのデプロイやコンパイルサーバーをCentOS 8に移行することで、この問題が解決した。&lt;/p&gt;
&lt;h2 id=&#34;合理な列挙&#34;&gt;合理な列挙
&lt;/h2&gt;&lt;p&gt;問題全体を振り返ると、実はもっと簡単で効率的な解決策があります。それは、列挙の定義を0からではなく1から始めるように調整することです。これにより、デフォルト値とビジネス値を効果的に区別でき、上記の様々な問題を回避できます。&lt;/p&gt;
&lt;h3 id=&#34;なぜ1から始めるのが妥当だろうか&#34;&gt;なぜ1から始めるのが妥当だろうか？
&lt;/h3&gt;&lt;p&gt;__INLINE_CODE_0__において、列挙型のデフォルト値は常に0に固定されています。もしビジネス上の意味を持つ値を0として定義した場合（例えば「盤中」）、増分プッシュ時に受信した0がビジネス値なのか未設定のデフォルト値なのかを判断することができません。しかし、列挙型を1から開始して定義すれば、0を有意義でないデフォルト値や「不明」な状態として保持できるため、問題は解決されます。&lt;/p&gt;
&lt;p&gt;推奨される実践：&lt;/p&gt;
&lt;p&gt;プロトバッファの列挙型を設計する際は、常に 0 を無意味なデフォルト値として定義してください（例：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 或 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt;）。
実際のビジネス値を1から割り当て、デフォルト値の0と区別する。&lt;/p&gt;
&lt;p&gt;この小さな調整により、取引セッションの識別問題を解決するだけでなく、将来のプロトコル設計のための貴重な経験となりました。&lt;/p&gt;</description>
        </item>
        <item>
        <title>バックエンドサービスTCP通信異常のトラブルシューティング</title>
        <link>https://ttf248.life/ja/p/backend-service-tcp-communication-troubleshooting/</link>
        <pubDate>Fri, 14 Feb 2025 22:54:13 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/backend-service-tcp-communication-troubleshooting/</guid>
        <description>&lt;p&gt;ビジネスモデル：バックエンドサービスはTCP経由でグループのマーケットデータゲートウェイと接続を確立します。接続時にはまず認証リクエストを送信し、その後、継続的にハートビートパケットを送信して接続状態を維持します。
しかし、ある日、サービス接続が切れたという警告メッセージを受け取りました。詳細なログ調査の結果、バックグラウンドサービスは継続的にハートビートを送信しているものの、相手からの応答はなく、それでも接続は切断されませんでした。&lt;/p&gt;
&lt;h2 id=&#34;現場概説&#34;&gt;現場概説
&lt;/h2&gt;&lt;p&gt;元々会社で残業中、プロジェクトの進捗を詰めていたところ、仕事グループに突然警告メッセージが飛び込んできた。最初はよくあるエラーかと思ったが、ネットワークタイムアウトで心跳送信が失敗し、結果としてサービス接続が切れたのだろうと推測した。しかし、ログを詳しく調査した結果、実際はそうではなかった。バックエンドから認証ログインメッセージは送信されているものの、応答がないまま、心跳パケットは継続的に送られ続けており、相手側からは一切の心跳データが返されていない。ログを詳細に分析した結果、以下の重要な問題点が明らかになった：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;認証メッセージに対する応答なし：相手のシステムが再起動中の可能性が高く、認証メッセージがタイムリーに処理されなかったと考えられます。&lt;/li&gt;
&lt;li&gt;認証に失敗したにも関わらずハートビートデータが送信される事象について調査した結果、プログラムのロジック上の欠陥であることが判明しました。ハートビート送信関数における判断ロジックに問題があり、接続状態のみを検証し、認証状態の検証を怠っていました。&lt;/li&gt;
&lt;li&gt;サービス接続が切断されない場合、切断を促すことで再接続メカニズムを起動し、再度認証メッセージを送信できます。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;現在、まだ最後の解決すべき問題が残っています — なぜサービスが切断されていないのかです。この問題を解決するには、より詳細な調査が必要です。&lt;/p&gt;
&lt;h2 id=&#34;ネットワークデータパケットの解析&#34;&gt;ネットワークデータパケットの解析
&lt;/h2&gt;&lt;p&gt;ネットワークデータパケットを捕捉し、さらに分析するために。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/backend-service-tcp-communication-troubleshooting/20250220151952.png&#34;
	width=&#34;1126&#34;
	height=&#34;202&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;tcpdump&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;557&#34;
		data-flex-basis=&#34;1337px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;グラフのデータから、心拍は常に正常に送信されていることがわかりますが、相手サーバーからの応答はなく、代わりに &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; が与えられているため、接続は自動的に切断されません。&lt;/p&gt;
&lt;h2 id=&#34;一般的なフラグの説明&#34;&gt;一般的なフラグの説明
&lt;/h2&gt;&lt;p&gt;TCPプロトコルにおいて、&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;（Push）和 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt;（Acknowledgment）は、データ転送とフロー制御を管理する上で重要なフラグです。その役割は以下の通りです。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;1-pshpush-flag&#34;&gt;&lt;strong&gt;1. PSH（Push Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;:
受信側は、バッファ内のデータを可能な限り速やかに上位アプリケーションへプッシュし、オペレーティングシステムバッファに一時保存しないこと。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;典型场景&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;クライアントがリクエストを送信する際（例えば、&lt;code&gt;GET /index.html&lt;/code&gt;）会设置 &lt;code&gt;PSH&lt;/code&gt;）、サーバーに即時応答を期待します。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;入力時に毎回 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; がトリガーされ、入力文字がリアルタイムで送信されます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;動画ストリーミングやオンラインゲームなどの低遅延シーンでは、&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; を用いて遅延を削減することがあります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PSH&lt;/code&gt; は必須ではなく、受信側は無視しても構いません（ただし、データは通常通り処理する必要があります）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;送信者は &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; を設定しない場合があるため、受信者は自身のバッファリングポリシーに基づいてデータをいつプッシュするか決定します。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2-ackacknowledgment-flag&#34;&gt;&lt;strong&gt;2. ACK（Acknowledgment Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;:
受信確認（前続データセグメントの受信が完了したことを示す）であり、次を受信するべきバイトのシーケンス番号です。これはTCP信頼性のある転送の中核をなすメカニズムです。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;工作原理&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;受信者は、送信者がデータセグメントを送信する際に添付する情報（&lt;code&gt;ACK&lt;/code&gt; 值（例如 &lt;code&gt;ACK = 序列号 + 数据长度&lt;/code&gt;）を持つ。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;受信側はデータを受信後、__INLINE_CODE_0__メッセージを生成し、受信確認済みデータのシーケンス番号を示す。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;送信者は、対応する &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; を受信した場合のみ、未確認のデータを再送します。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;送信者は、インラインのイタリック体5、太字4、インラインのイタリック体6、太字3、インラインのイタリック体7を送信しました。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;受信者が &lt;code&gt;100~199&lt;/code&gt; 中的某些数据，会通过 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; を受け取らない場合、送信者は再送を通知する。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;申し訳ありませんが翻訳する中国語のテキストが提供されていませんテキストを提供してください&#34;&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。
&lt;/h3&gt;&lt;p&gt;TCPパケットにおいて、&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 和 __INLINE_CODE_1__は同時に出現することがあり、主に以下の状況で確認されます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;HTTP 请求响应&lt;/strong&gt;:
クライアントが、&lt;code&gt;POST&lt;/code&gt; 请求时（含数据），会设置 &lt;code&gt;PSH&lt;/code&gt; 和 &lt;strong&gt;INLINE_CODE_2&lt;/strong&gt;（以前の応答を確認）を送信します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Client → Server: SYN, ACK=1 → 建立连接
Client → Server: PSH, ACK=1, 数据 → 发送请求数据
Server → Client: PSH, ACK=数据长度+1 → 返回响应
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SSH 握手后传输命令&lt;/strong&gt;:
クライアントがコマンドを入力後、&lt;code&gt;PSH&lt;/code&gt;BOLD_2&lt;code&gt;ACK&lt;/code&gt; が含まれるデータセグメントを送信し、コマンドの即時伝送とサーバーでの処理を保証します。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;申し訳ありませんが翻訳する中国語のテキストが提供されていませんテキストを提供してください-1&#34;&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;フラグ&lt;/th&gt;
&lt;th&gt;名&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;同期　初期化接続（三次握手）&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FIN&lt;/td&gt;
&lt;td&gt;終了&lt;/td&gt;
&lt;td&gt;エレガントな接続のクローズ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;リセット&lt;/td&gt;
&lt;td&gt;強制終了 (異常時)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;URG&lt;/td&gt;
&lt;td&gt;緊急&lt;/td&gt;
&lt;td&gt;緊急ポインタをマークする（ほとんど使用しない）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h3 id=&#34;申し訳ありませんが翻訳する中国語のテキストが提供されていませんテキストを提供してください-2&#34;&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;遅延の低減に焦点を当てる。&lt;/li&gt;
&lt;li&gt;データの完全性と順序を保つことが重要です。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;両者は協調して働き、TCPプロトコルの効率と信頼性のバランスを取っています。&lt;/p&gt;</description>
        </item>
        <item>
        <title>atopツールによるLinuxシステム指標の監視：インストール、設定と利用完全ガイド</title>
        <link>https://ttf248.life/ja/p/using-atop-to-monitor-linux-system-metrics-installation-configuration-and-usage-guide/</link>
        <pubDate>Thu, 06 Feb 2025 22:48:55 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/using-atop-to-monitor-linux-system-metrics-installation-configuration-and-usage-guide/</guid>
        <description>&lt;p&gt;Linuxシステム運用において、システムリソースとプロセス状態をリアルタイムかつ包括的に監視することは非常に重要です。atopは強力な監視ツールであり、この目標を容易に達成するのに役立ちます。本稿では、Linuxインスタンスにおけるatop監視ツールのインストール、設定、使用方法について詳細に説明します。&lt;/p&gt;
&lt;h2 id=&#34;一atopツール紹介&#34;&gt;一、atopツール紹介
&lt;/h2&gt;&lt;p&gt;atopは、Linuxシステムのリソースとプロセスを監視するためのツールです。システムおよびプロセスの活動を記録し、すべてのプロセスの実行状況を報告します。CPU、メモリ、ディスク、ネットワークなどのリソース使用状況やプロセス状態に関するデータを収集し、ログファイルとして保存できます。各プロセスについて、CPU使用率、メモリ増加量、ディスク使用率、優先度、ユーザー名、状態、終了コードなどの主要な情報を取得可能です。さらに、atopの設定ファイルを通じて、ログの収集頻度、ログファイルの保存パス、ローテーションポリシーなどのパラメータをカスタマイズできます。&lt;/p&gt;
&lt;h2 id=&#34;二atopツールのインストール&#34;&gt;二、atopツールのインストール
&lt;/h2&gt;&lt;p&gt;様々なLinuxディストリビューションでのatopのインストール方法は若干異なります。以下では、一般的なOSを例として説明します。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Alibaba Cloud Linux 3/2、CentOS 7/8、Fedora、Rocky Linux 9&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;実行インストールコマンド：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;atopサービスを開始します。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;Ubuntu / Debian&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ソフトウェアリポジトリの更新：&lt;/li&gt;
&lt;li&gt;実行インストールコマンド：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;atopサービスを開始します。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;CentOS Stream 9&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ダウンロードしてインストール：&lt;/li&gt;
&lt;li&gt;atopサービスを開始します。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;openSUSE&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;実行インストールコマンド：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;atopサービスを開始します。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;もし上記に挙げられているオペレーティングシステムに利用しているディストリビューションが含まれていない場合は、atop公式サイトでインストール情報を確認してください。&lt;/p&gt;
&lt;h2 id=&#34;監視期間とログ保持期間の設定&#34;&gt;監視期間とログ保持期間の設定
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Alibaba Cloud Linux 3/2、CentOS 7/8およびFedoraシステムでは、atopの構成ファイルは*&lt;strong&gt;；在Ubuntu、Debian和openSUSE系统中，配置文件是&lt;/strong&gt;*です。&lt;/li&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ログファイル記録オプションを制御します。デフォルトは空です。&lt;/li&gt;
&lt;li&gt;監視期間はデフォルトで600秒です。過去のログを追跡する場合は、必要に応じてこの頻度を調整することをお勧めします。&lt;/li&gt;
&lt;li&gt;ログ保持期間、デフォルト28日。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;斜体&lt;/em&gt;&lt;strong&gt;太字&lt;/strong&gt;&lt;em&gt;斜体&lt;/em&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;コマンドを実行して設定ファイルを開きます。&lt;/li&gt;
&lt;li&gt;Alibaba Cloud Linux 3/2、CentOS 7/8、Fedoraシステムにおいて：&lt;/li&gt;
&lt;li&gt;Ubuntu、Debian、openSUSE、CentOS Stream 9、Rocky Linux 9 システムにおいて：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;__INLINE_CODE_0__を選択して編集モードに入り、必要に応じて設定パラメータを調整します。例えば、監視サイクルを30秒に修正し、ログ保持期間を7日に設定し、ログパスはデフォルトのままにします。&lt;/li&gt;
&lt;li&gt;押して、保存して終了します。&lt;/li&gt;
&lt;li&gt;サービスを再起動して設定を有効にする：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;LOGOPTS=&amp;quot;&amp;quot;
LOGINTERVAL=30
LOGGENERATIONS=7
LOGPATH=/var/log/atop 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;四atopツールを使用する&#34;&gt;四、atopツールを使用する
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;対話型コマンドモードでは、以下のよく使用されるコマンドがあります。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;デフォルトの統合出力ビューに戻ります。&lt;/li&gt;
&lt;li&gt;プロセスの一覧を完全なコマンドラインと共に表示します。&lt;/li&gt;
&lt;li&gt;プロセスメモリ使用率で降順にフィルタリングします。&lt;/li&gt;
&lt;li&gt;プロセスディスク使用率で降順にフィルタリングします。&lt;/li&gt;
&lt;li&gt;プロセス資源の総合利用率で降順にフィルタリングします。&lt;/li&gt;
&lt;li&gt;プロセスネットワーク利用率で降順にフィルタリングします。&lt;/li&gt;
&lt;li&gt;次の監視収集ポイントへ移動します。&lt;/li&gt;
&lt;li&gt;前の監視ポイントへ移動します。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;斜体&lt;/em&gt;&lt;strong&gt;太字&lt;/strong&gt;&lt;em&gt;斜体&lt;/em&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ホスト名、情報サンプリングの日付と時刻。&lt;/li&gt;
&lt;li&gt;プロセス全体の実行状況。カーネルモードおよびユーザーモードの実行時間、プロセスの総数、各種状態のプロセス数などを含む。&lt;/li&gt;
&lt;li&gt;CPU全体の利用状況で、各フィールドの数値の合計は__INLINE_CODE_0__（NはCPUコア数）です。カーネルモード、ユーザーモード、割り込み、アイドル、ディスクI/O待ちなどの時間割合を含みます。&lt;/li&gt;
&lt;li&gt;CPU負荷状況：過去1分間、5分間、15分間の実行キューの平均プロセス数、コンテキストスイッチ回数、割り込み発生回数。&lt;/li&gt;
&lt;li&gt;メモリ使用状況。物理メモリ合計、空きメモリ、ページキャッシュメモリ、ファイルキャッシュメモリ、カーネル使用メモリなどを含む。&lt;/li&gt;
&lt;li&gt;スワップ領域の使用状況を示します。割り当てられた合計サイズと利用可能なスワップ領域のサイズが含まれます。&lt;/li&gt;
&lt;li&gt;仮想メモリのページング状況、例えばスワップインおよびスワップアウトされたページ数。&lt;/li&gt;
&lt;li&gt;ディスクの使用状況。各ディスクデバイスごとに1行で、デバイス識別子、ビジー状態の時間割合、読み書きリクエスト数を示します。&lt;/li&gt;
&lt;li&gt;ネットワーク状況を表示し、転送層のTCPとUDP、IP層、および各アクティブポートでの受信・送信パケットサイズを示します。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;5秒ごとにシステム指標を確認する。&lt;/li&gt;
&lt;li&gt;現在時刻の5分後（合計30回、10秒間隔）にシステム指標を確認します。&lt;/li&gt;
&lt;li&gt;現在時刻の10分後のシステム指標を確認し（10回、60秒間隔で）、結果をファイルに書き込む：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;起動後、データはデフォルトで__INLINE_CODE_0__ディレクトリに保存されます。確認する際は、指定した日付のログファイルが存在することを確認してください。存在しない場合、エラーが発生します。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;当日の履歴指標ログを確認：&lt;/li&gt;
&lt;li&gt;昨日のヒストリ指標ログを見る：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;指定日の過去の指標ログを確認します。例：2024年11月06日&lt;/li&gt;
&lt;li&gt;指定された日付から指定時間以降の履歴指標ログを表示します。例：2024年11月06日14:00以降：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;指定された日付範囲内の過去の指標ログを表示します。例えば、2024年11月5日の00:04～00:08：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;現在のシステムにおけるCPU使用率レポートを1分間（12回、5秒間隔で）：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当日指定時間帯のメモリ指標レポートを確認します。例：18:00～18:01。&lt;/li&gt;
&lt;li&gt;指定された日付の指定時間帯におけるメモリ指標レポートを確認します。例えば、2024年11月5日18:00～18:01：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;その他操作&#34;&gt;その他操作
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;毎日atop指標ログファイルを生成したい場合は、以下の手順を実行してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;必要に応じて、監視期間、ログ保持時間、およびログ保存パスを調整できます。&lt;/li&gt;
&lt;li&gt;コマンド実行で、毎日ログローテーション関連サービスの起動設定を行い、サービスを開始します。&lt;/li&gt;
&lt;li&gt;ビジネスがログ処理に複雑な要件を持つ場合、logrotateやカスタムスクリプトを組み合わせてログ管理を実現できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;加载可选的netatop内核模块&lt;/strong&gt;: ネットワーク利用率の監視が必要な場合は、netatopモジュール（atopではデフォルトでインストールされていません）をインストールします。例として、Alibaba Cloud Linux 3システムの場合：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;カーネル開発パッケージのインストールとコンパイルに必要なソフトウェア環境：&lt;code&gt;sudo yum install -y kernel-devel dkms elfutils-libelf-devel&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最新バージョンのnetatopソースコードを、指定のディレクトリにダウンロードします。&lt;/li&gt;
&lt;li&gt;ソースコードを解凍し、ソースディレクトリへ移動します。&lt;/li&gt;
&lt;li&gt;ソースコードからモジュールとデーモンを構築・インストール：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;netatopサービスを開始します。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;atopツールは機能が強力で柔軟性があり、適切なインストール、設定、利用によって、Linuxシステムの稼働状況をより深く理解し、潜在的な問題を早期に発見・解決できます。本稿が皆様のLinuxシステム監視スキル向上の一助となれば幸いです。&lt;/p&gt;
&lt;h2 id=&#34;参考リンク&#34;&gt;参考リンク
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Visual Studio で「非対応」の PDB ファイルを読み込む</title>
        <link>https://ttf248.life/ja/p/visual-studio-loading-unmatched-pdb-files/</link>
        <pubDate>Thu, 23 Jan 2025 20:04:33 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/visual-studio-loading-unmatched-pdb-files/</guid>
        <description>&lt;p&gt;Windows 環境で Visual Studio でプログラムをデバッグする際、pdb ファイルと実行ファイルが一致しない場合、「シンボルファイルを読み込めません」というエラーが表示されます。プログラムがクラッシュし、ダンプファイルが生成された場合でも、不一致の pdb ファイルが存在すると、Visual Studio は正常にクラッシュ現場に入りません。&lt;/p&gt;
&lt;h2 id=&#34;pdbファイルとは何か&#34;&gt;pdbファイルとは何か。
&lt;/h2&gt;&lt;p&gt;PDBファイルは、Microsoftが提供するデバッグ情報ファイルで、プログラムのデバッグに用いられます。PDBファイルには、プログラムのシンボルテーブル、ソースコードファイル名、行番号などの情報が含まれます。プログラムのコンパイル時に生成され、デバッグに使用されます。&lt;/p&gt;
&lt;h2 id=&#34;windbg-デバッグ&#34;&gt;WinDbg デバッグ
&lt;/h2&gt;&lt;p&gt;WinDbgは、Microsoftが提供するデバッグツールで、Windowsプログラムのデバッグに利用できます。WinDbgは互換性のないpdbファイルを読み込めますが、手動でのロードが必要です。__INLINE_CODE_0__コマンドを使用することで、互換性のないpdbファイルを強制的にロードできます。&lt;/p&gt;
&lt;p&gt;しかし、WinDbg は Visual Studio ほど使いやすくないので、Visual Studio でもミスマッチの PDB ファイルをロードできるようにしたいと考えています。&lt;/p&gt;
&lt;h2 id=&#34;visual-studio-で互換性のない-pdb-ファイルを読み込む&#34;&gt;Visual Studio で互換性のない PDB ファイルを読み込む
&lt;/h2&gt;&lt;p&gt;ソースコードは通常、gitで管理されているため、対応するバージョンのコードを容易に見つけられ、再コンパイルして対応するpdbファイルを生成できます。なぜロードできないのでしょうか？主な原因はメタデータが一致しないことです。&lt;/p&gt;
&lt;p&gt;小さなツールがあり、実行可能ファイルの情報に基づいてメタデータを修正し、Visual Studioが読み込める新しいpdbファイルを生成する。&lt;/p&gt;
&lt;p&gt;ダウンロード先：&lt;a class=&#34;link&#34; href=&#34;https://www.debuginfo.com/tools/chkmatch.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.debuginfo.com/tools/chkmatch.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;サイトキャッシュアドレス：&lt;a class=&#34;link&#34; href=&#34;chkmatch.zip&#34; &gt;chkmatch.zip&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ChkMatch utility can be used to check whether an executable and debug information file match. It can also be used to enforce matching between an executable and debug information file, if they are compatible.

For more information about debug information matching and related issues, see this article.

Supported debug information formats: DBG, PDB 2.0, PDB 7.0.

chkmatch [-c ExeFile DebugInfoFile ] |
         [-m ExeFile DebugInfoFile]
-c
Check matching between the executable and the debug information file.
-m
Make the executable and the debug information file match.
ExeFile
The name of the executable file.
DebugInfoFile
The name of the debug information file.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;chkmatch-を使用する&#34;&gt;chkmatch を使用する
&lt;/h2&gt;&lt;p&gt;まずチェック処理を実行し、不一致の原因を分析後、署名不一致を通知します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\tianlong.xiang\Downloads\chkmatch&amp;gt;ChkMatch.exe -c &amp;quot;D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe&amp;quot; E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb
ChkMatch - version 1.0
Copyright (C) 2004 Oleg Starodumov
http://www.debuginfo.com/


Executable: D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe
Debug info file: E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb

Executable:
TimeDateStamp: c26d9be3
Debug info: 2 ( CodeView )
TimeStamp: f86b0a4f  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 122  RVA: 001cdc44  FileOffset: 001cbe44
CodeView format: RSDS
Signature: {428c9b95-39a3-4a8d-a8e5-7be453684757}  Age: 1
PdbFile: D:\stock_UAT\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\obj\Release\YinTrade.Main.pdb
Debug info: 16 ( Unknown )
TimeStamp: 00000000  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 0  RVA: 00000000  FileOffset: 00000000

Debug information file:
Format: PDB 7.00
Signature: {06fae08e-c0a2-4f3d-9c7c-dfc684445dd1}  Age: 1

Result: Unmatched (reason: Signature mismatch)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;その後、pdbファイルとexeファイルを一致させるよう修正を実行します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\tianlong.xiang\Downloads\chkmatch&amp;gt;ChkMatch.exe -m &amp;quot;D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe&amp;quot; E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb
ChkMatch - version 1.0
Copyright (C) 2004 Oleg Starodumov
http://www.debuginfo.com/


Executable: D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe
Debug info file: E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb

Executable:
TimeDateStamp: c26d9be3
Debug info: 2 ( CodeView )
TimeStamp: f86b0a4f  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 122  RVA: 001cdc44  FileOffset: 001cbe44
CodeView format: RSDS
Signature: {428c9b95-39a3-4a8d-a8e5-7be453684757}  Age: 1
PdbFile: D:\stock_UAT\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\obj\Release\YinTrade.Main.pdb
Debug info: 16 ( Unknown )
TimeStamp: 00000000  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 0  RVA: 00000000  FileOffset: 00000000

Debug information file:
Format: PDB 7.00
Signature: {06fae08e-c0a2-4f3d-9c7c-dfc684445dd1}  Age: 1

Writing to the debug information file...
Result: Success.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/38147487/forcing-to-load-unmatched-symbols-in-visual-studio-2015-debugger&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;forcing-to-load-unmatched-symbols-in-visual-studio-2015-debugger&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Linuxバックエンドサービスにおける大量の文字列データ処理 - 効率が低い</title>
        <link>https://ttf248.life/ja/p/linux-backend-slow-string-processing/</link>
        <pubDate>Wed, 13 Nov 2024 19:42:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-backend-slow-string-processing/</guid>
        <description>&lt;p&gt;C++開発の過去プロジェクトにおいて、カスタムプロトコルを用いて通信しており、そのプロトコルは二次元配列の形式を採用していました。大量データを処理する際、ログ生成のために配列を走査しシリアライズを行う必要がありましたが、効率が悪く、高負荷時にシステムが顕著にカクつくという問題が発生しました。この件について、ビジネス部門からシステムの動作不良に関するフィードバックがありました。&lt;/p&gt;
&lt;h2 id=&#34;問題特定&#34;&gt;問題特定
&lt;/h2&gt;&lt;p&gt;問題の調査において、まずシステムを性能解析したところ、大量データを処理する際にCPU使用率が顕著に増加し、システム応答時間が長くなっていることが判明しました。システムのログを分析した結果、二次元配列の処理における効率の低いシリアライズ操作が多く存在することがわかり、これがシステムパフォーマンスの低下を引き起こしていると考えられます。&lt;/p&gt;
&lt;p&gt;ツール切り取りサービスの スレッド情報を確認した結果、ログスレッドの大部分の時間文字列の結合処理に費やされていることが判明しました。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ここが今日のポイントです。異なる加算方法によって、効率は大きく異なります。過去のコードでは &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 演算子を使用しており、この方法は頻繁に一時オブジェクトを作成するため、非常に低速です。それが非効率的だと知っていても、どれほど非効率的なのかを理解していないようなものです。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;デモ検証&#34;&gt;デモ検証
&lt;/h2&gt;&lt;p&gt;プロジェクトコードに基づいて、業務ロジックを抽出し、文字列結合の効率問題を検証するための簡単なデモを作成しました。&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 下的 __INLINE_CODE_1__BOLD_6&lt;code&gt;linux&lt;/code&gt; 下的 &lt;strong&gt;INLINE_CODE_3&lt;/strong&gt; 编译器，__INLINE_CODE_4__モードでコンパイル実行し、効率を比較します。&lt;/p&gt;
&lt;h3 id=&#34;主なポイント&#34;&gt;主なポイント
&lt;/h3&gt;&lt;p&gt;プロジェクトでは手法4を使用しており、テストデータを入手する前に、読者はどの方法が最も効率的か、またどれが最も非効率かを考えてみることができます。結果を見たときは、やはり驚きました。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;各フィールドを文字列に連結します。&lt;/li&gt;
&lt;li&gt;流（ストリーム）を使用して各フィールドを結合すると、この方法がより効率的です。特に大量のデータを結合する場合に有効です。&lt;/li&gt;
&lt;li&gt;事前に文字列に十分なメモリを割り当てることで、メモリ再配置のオーバーヘッドを削減し、パフォーマンスが向上します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;太字_1&lt;/strong&gt;インライン&lt;strong&gt;イタリック_3&lt;/strong&gt;、&lt;strong&gt;太字_2&lt;/strong&gt;：文字列を連結するたびに新しい一時的な文字列オブジェクトが作成されるため、特に大規模な連結ではパフォーマンスが低下します。これは、連結ごとに新しいメモリの割り当てとコピーが発生するためです。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参照結果から、プロジェクトは効率が最も悪い方法が選択されたことが分かります。&lt;/p&gt;
&lt;p&gt;さらに、異なるプラットフォームのコンパイラ最適化効率を分析すると、Microsoftの&lt;code&gt;visual studio&lt;/code&gt; 一如既往的优秀，针对字符串的优化效率很高，而 &lt;code&gt;gcc&lt;/code&gt;コンパイラは、この点において若干見劣りする。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;コードを異なるマシンで実行した場合、データの比較は直接的な意味を持たないため、それぞれの結合方法間の差異を比較するのが適切です。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;windows 平台下的 vs2022 编译器

----------------------------------------
Data Generation Time: 0.054 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.053 seconds.
+ ostringstream Data merging took: 0.054 seconds.
+ Pre-reserved Data merging took: 0.045 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 16.108 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;linux 平台下的 gcc8.5 编译器
----------------------------------------
Data Generation Time: 0.108 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.100 seconds.
+ ostringstream Data merging took: 0.083 seconds.
+ Pre-reserved Data merging took: 0.057 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 29.298 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完全コード&#34;&gt;完全コード
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;random&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;iomanip&amp;gt;

typedef std::vector&amp;lt;std::string&amp;gt; DataRow;
typedef std::vector&amp;lt;DataRow&amp;gt; DataGroup;

struct ResponsePackage
{
    std::string ErrorInfo;
    DataRow Head;
    std::string ClientId;
    std::string UUID;
    std::string MsgID;
    std::string SessionID;
    std::string ExtraInfo1;
    std::string ExtraInfo2;
    DataGroup DataBody;
};

// Generate specified length of random string
std::string generateRandomString(size_t length)
{
    const char charset[] = &amp;quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&amp;quot;;
    const size_t max_index = sizeof(charset) - 1;
    std::string random_string;
    random_string.reserve(length);

    std::random_device rd;
    std::mt19937 generator(rd());
    std::uniform_int_distribution&amp;lt;&amp;gt; distribution(0, max_index);

    for (size_t i = 0; i &amp;lt; length; ++i)
    {
        random_string += charset[distribution(generator)];
    }

    return random_string;
}

void create_large_string()
{
    // Example request package with 50 fields
    ResponsePackage requestPackage;

    requestPackage.Head = {
        &amp;quot;Field1&amp;quot;, &amp;quot;Field2&amp;quot;, &amp;quot;Field3&amp;quot;, &amp;quot;Field4&amp;quot;, &amp;quot;Field5&amp;quot;,
        &amp;quot;Field6&amp;quot;, &amp;quot;Field7&amp;quot;, &amp;quot;Field8&amp;quot;, &amp;quot;Field9&amp;quot;, &amp;quot;Field10&amp;quot;,
        &amp;quot;Field11&amp;quot;, &amp;quot;Field12&amp;quot;, &amp;quot;Field13&amp;quot;, &amp;quot;Field14&amp;quot;, &amp;quot;Field15&amp;quot;,
        &amp;quot;Field16&amp;quot;, &amp;quot;Field17&amp;quot;, &amp;quot;Field18&amp;quot;, &amp;quot;Field19&amp;quot;, &amp;quot;Field20&amp;quot;,
        &amp;quot;Field21&amp;quot;, &amp;quot;Field22&amp;quot;, &amp;quot;Field23&amp;quot;, &amp;quot;Field24&amp;quot;, &amp;quot;Field25&amp;quot;,
        &amp;quot;Field26&amp;quot;, &amp;quot;Field27&amp;quot;, &amp;quot;Field28&amp;quot;, &amp;quot;Field29&amp;quot;, &amp;quot;Field30&amp;quot;,
        &amp;quot;Field31&amp;quot;, &amp;quot;Field32&amp;quot;, &amp;quot;Field33&amp;quot;, &amp;quot;Field34&amp;quot;, &amp;quot;Field35&amp;quot;,
        &amp;quot;Field36&amp;quot;, &amp;quot;Field37&amp;quot;, &amp;quot;Field38&amp;quot;, &amp;quot;Field39&amp;quot;, &amp;quot;Field40&amp;quot;,
        &amp;quot;Field41&amp;quot;, &amp;quot;Field42&amp;quot;, &amp;quot;Field43&amp;quot;, &amp;quot;Field44&amp;quot;, &amp;quot;Field45&amp;quot;,
        &amp;quot;Field46&amp;quot;, &amp;quot;Field47&amp;quot;, &amp;quot;Field48&amp;quot;, &amp;quot;Field49&amp;quot;, &amp;quot;Field50&amp;quot;
    };

    requestPackage.ClientId = &amp;quot;ClientID&amp;quot;;
    requestPackage.UUID = &amp;quot;UUID&amp;quot;;
    requestPackage.MsgID = &amp;quot;MsgID&amp;quot;;
    requestPackage.SessionID = &amp;quot;SessionID&amp;quot;;
    requestPackage.ExtraInfo1 = &amp;quot;ExtraInfo1&amp;quot;;
    requestPackage.ExtraInfo2 = &amp;quot;ExtraInfo2&amp;quot;;

    // Start timing for data generation
    auto start_gen = std::chrono::high_resolution_clock::now();

    // Generate 10,000 rows of data, each with 50 fields
    for (size_t i = 0; i &amp;lt; 10000; ++i)
    {
        DataRow dataRow(50, &amp;quot;This is a test string&amp;quot;);
        requestPackage.DataBody.push_back(dataRow);
    }

    // End timing for data generation
    auto end_gen = std::chrono::high_resolution_clock::now();
    std::chrono::duration&amp;lt;double&amp;gt; duration_gen = end_gen - start_gen;

    // Display result generation time
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Generation Time: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_gen.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    // Data merging using different methods
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Performance:\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    {
        // Method 1: Using &#39;+=&#39; string concatenation
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (+=) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 2: Using ostringstream
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::ostringstream bodys;
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::ostringstream body;
            body &amp;lt;&amp;lt; &amp;quot;This is a test string&amp;quot;;
            for (auto&amp;amp; item : vec)
            {
                body &amp;lt;&amp;lt; item &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            }
            bodys &amp;lt;&amp;lt; body.str() &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ ostringstream Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 3: Pre-allocated memory
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys;
        bodys.reserve(1000 * 50 * 20); // Pre-allocate enough memory
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            body.reserve(50 * 20); // Pre-allocate memory for each row
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Pre-reserved Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 4: Using &#39;bodys = bodys + body + &amp;quot;\n&amp;quot;&#39;
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body = body + item + &amp;quot; &amp;quot;; // Note the use of &#39;body = body + item&#39;
            }
            bodys = bodys + body + &amp;quot;\n&amp;quot;; // Again, using &#39;bodys = bodys + body&#39;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (bodys = bodys + body + \&amp;quot;\\n\&amp;quot;) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Complete.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;
}

int main()
{
    try
    {
        create_large_string();
    }
    catch (const std::exception&amp;amp; e)
    {
        std::cerr &amp;lt;&amp;lt; &amp;quot;Caught exception: &amp;quot; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\nProgram finished.\n&amp;quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Win11 Logitech G431 ヘッドホン ドライバ インストール</title>
        <link>https://ttf248.life/ja/p/win11-logitech-g431-headphone-driver-installation/</link>
        <pubDate>Wed, 05 Jun 2024 07:20:17 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/win11-logitech-g431-headphone-driver-installation/</guid>
        <description>&lt;p&gt;続きから、帰宅してGhubのアップデートがあるのを見つけて少し嬉しい。カスタマーサポートで報告されていた問題駆動が正常にロードできない問題は解決したとのことだが、色々試しても再インストールやアンインストールしても、やはり正常に使えない。&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景
&lt;/h2&gt;&lt;p&gt;引き続きカスタマーサポートに連絡し対応策を確認したところ、エンジニアによるリモートサポートが可能とのことでしたが、エンジニアの勤務時間と私の勤務時間が完全に重なっており、残念ながら諦めざるを得ませんでした。以前の問題切り分けで残しておいた資料を調べ、手動でのドライバインストールを試すことにします。&lt;/p&gt;
&lt;h2 id=&#34;ドライバーのインストールパッケージを取得する&#34;&gt;ドライバーのインストールパッケージを取得する
&lt;/h2&gt;&lt;p&gt;ロジクールは個別のデバイスドライバを直接提供していません。ドライバファイルをどのように入手できますか？&lt;/p&gt;
&lt;p&gt;前回のリセット時に残ったシステムイメージインストールパッケージを利用して、ローカル仮想マシンで再度システムをリセットできます。完全にクリーンな状態のシステムに、Ghubを個別にデプロイし、ヘッドホンデバイスを仮想マシンに介入させます。すると、ドライバーのパスを見つけられ、それをコピーアウトすることで完了です。&lt;/p&gt;
&lt;p&gt;関連パス：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C:\ProgramData\LGHUB&lt;/li&gt;
&lt;li&gt;C:\Windows\System32\DriverStore\FileRepository\logi_audio.inf_amd64_010b035044e24be4&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;デバイスマネージャー&#34;&gt;デバイスマネージャー
&lt;/h2&gt;&lt;p&gt;Win11システムで手動でドライバーファイルを管理する方法を、まずは簡単に整理します。この部分について、&lt;strong&gt;重点は2つ目のパスを見つける方法です。&lt;/strong&gt; システムに標準搭載されているドライバーが2つあり、ロジクール製が1つあります。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;20240605073331.png&#34; &gt;驱动管理器&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;上記の画像中の2つ目のドライバは、ロジクール製です。現在のデバイスのドライバを分析し、仮想マシン内で全てのドライバパスを探します。まずlogiで始まるファイルを見つけ、ファイルの比較を行うことで、ドライバファイルを特定できます。フォルダ全体をコピーすれば、ドライバインストールパッケージを入手できます。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;20240605073933.png&#34; &gt;驱动安装包&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;ドライバーのインストール&#34;&gt;ドライバーのインストール
&lt;/h2&gt;&lt;p&gt;デバイスマネージャーの画面で、「ドライバーを更新」をクリックし、「私のコンピューターを参照してドライバーを選択」に進むと、以下の画面になります。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;20240605074130.png&#34; &gt;驱动安装&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;もちろん、開くと普通のUSBドライバとしてしか見えますが、ディスクからインストールを選択し、パスは先ほどコピーしたフォルダを指定してください。インストール後、プルダウンメニューにロジテック独自のドライバが表示されるので、デバイスドライバを新しくインストールされたドライバに切り替えてください。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;20240605074208.png&#34; &gt;磁盘安装&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;人体工学デバイスドライバ&#34;&gt;人体工学デバイスドライバ
&lt;/h2&gt;&lt;p&gt;このデバイスのドライバはシステム提供のもので、感嘆符 (!) が付いていないか確認してください。もしあれば、ドライバ選択画面に入り、別の種類のドライバに一時的に切り替えた後、元のドライバに戻すと正常に戻ります。&lt;/p&gt;
&lt;h2 id=&#34;完了&#34;&gt;完了
&lt;/h2&gt;&lt;p&gt;ヘッドホンマイクの音量が通常に戻り、おなじみのイアホン機能も復帰しました。&lt;/p&gt;
&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;20240605074823.png&#34; &gt;侧音&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>新しく設置したギガ光ファイバー、なぜ速度測定では100メガにしか見えないのか？</title>
        <link>https://ttf248.life/ja/p/new-gigabit-fiber-slow-speed/</link>
        <pubDate>Mon, 18 Mar 2024 00:29:02 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/new-gigabit-fiber-slow-speed/</guid>
        <description>&lt;p&gt;家庭のネットワークを光速のようにしたいですか？ 鍵は、LANケーブルの選択、ONU（光回線終端装置）とルーターの設定、そして些細なことへの注意です。 このブログでは、カテゴリー6 LANケーブルでギガビットネットワークを構築する方法、簡単なデバイスチェックと設定でネットワーク速度を最大限に引き出す方法をご紹介します。 さあ、一緒に探求して、家庭のインターネット回線を加速させましょう！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;！&lt;a class=&#34;link&#34; href=&#34;image.png&#34; &gt;手动修复&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;第1章ネットワーク伝送媒体の徹底分析&#34;&gt;第1章：ネットワーク伝送媒体の徹底分析
&lt;/h2&gt;&lt;p&gt;ギガビットネットワーク接続を実現する上で、情報を高速伝送する媒体であるLANケーブルは極めて重要な役割を果たします。以下に、カテゴリー5、カテゴリー6、カテゴリー7のLANケーブルについて詳しく解説します。&lt;/p&gt;
&lt;h3 id=&#34;大声で叫ぶ&#34;&gt;大声で叫ぶ。
&lt;/h3&gt;&lt;p&gt;5種類のLANケーブル（CAT5とも呼ばれる）は、比較的初期に普及したツイストペアケーブルの一種で、各芯線が精密な螺旋構造によって設計され、クロストークを低減しています。主に10/100Mbpsの高速イーサネットで使用され、最大伝送周波数はおよそ100MHzです。過去には広く利用されていましたが、現在のギガビット以上の高速通信ニーズに対しては、物理的な限界から5種類のLANケーブルでは要求を満たすことができません。&lt;/p&gt;
&lt;h3 id=&#34;heading&#34;&gt;
&lt;/h3&gt;&lt;p&gt;技術の発展に伴い、六類ケーブルが登場しました。五類ケーブルと比較して、六類ケーブルはより厳格な製造基準と高度な構造設計を採用しており、耐干渉性と伝送効率が大幅に向上しています。1Gbpsまでのデータ転送速度をサポートし、理想的な条件下では100メートルの伝送距離を実現します。これはまさにギガビットネットワークのアクセスニーズに合致しています。&lt;/p&gt;
&lt;h3 id=&#34;３&#34;&gt;３．
&lt;/h3&gt;&lt;p&gt;カテゴリー7のケーブルは、現在のツイストペア技術における最高水準を示しています。伝送速度が飛躍的に向上しており、理論上最大10Gbpsの超高速通信をサポートするだけでなく、各線対間のシールドと全体の外側のシールドを含む完全なシールドシステムを採用し、外部電磁干渉や近接クロストークを大幅に低減することで、データ転送の安定性と正確性を確保しています。ただし、カテゴリー7ケーブルは主に将来の10ギガビットイーサネットや特定の高要求な環境で使用されます。&lt;/p&gt;
&lt;p&gt;ギガホームネットワーク環境において、ギガファイバーの潜在能力を最大限に引き出すためには、カテゴリー6ケーブルを選択することが最も経済的かつ効率的な選択です。同時に、すべての接続ケーブルの品質が適切であることを確認し、標準的な配線方法を厳守することも、ネットワーク性能を確保する上で重要な要素となります。&lt;/p&gt;
&lt;h2 id=&#34;第2章ネットワークの中枢機器光回線終端装置ルーターlanポート帯域の影響を詳細に調査&#34;&gt;第2章：ネットワークの中枢機器（光回線終端装置、ルーターLANポート帯域）の影響を詳細に調査
&lt;/h2&gt;&lt;h3 id=&#34;光猫とlanポート帯域幅の重要性&#34;&gt;光猫とLANポート帯域幅の重要性
&lt;/h3&gt;&lt;p&gt;光ネコ（こうねこ）、正式名称は光ファイバーモデムであり、家庭ブロードバンド接続の中核機器です。光ファイバー内の光信号をデジタル信号に変換し、家庭内ネットワーク機器が利用できるようにする機能があります。ギガ光ファイバーユーザーにとって、光ネコがギガ伝送に対応しているかどうかが特に重要になります。光ネコのWANポートがギガビットに対応していない場合、戸別線路の光ファイバー速度がどれだけ高くても、このボトルネックによって100Mbps以内に制限されてしまいます。同様に、光ネコのLANポートもギガビット出力能力を備えている必要があり、そうでないと接続されたルーターやその他のデバイスは真のギガビット速度を得ることができません。&lt;/p&gt;
&lt;h3 id=&#34;ルーターlanポートの帯域幅の役割&#34;&gt;ルーターLANポートの帯域幅の役割
&lt;/h3&gt;&lt;p&gt;ルーターのLANポートは、受信したデータを各端末デバイスに配信する役割を担います。ルーターのLANポートが100Mbpsの場合、他の機器の設定に関わらず、100Mbpsの速度でしかローカルネットワーク通信を実現できません。そのため、ギガホームネットワークを構築する際は、ルーターのWANポートがギガデータを受信できること、そしてLANポートもギガレベルのデータ出力能力を提供できるようにすることが重要です。そうすることで、家庭内のすべてのスマートデバイスが高速ネットワークが生み出す快適な体験を享受できます。&lt;/p&gt;
&lt;p&gt;さらに注意すべき点として、一部の古いまたは低価格帯のルーターにはLANポートの自動速度ネゴシエーション機能が存在する場合があります。そのため、ルーター自体がギガビットに対応していても、ケーブルやデバイスの互換性などの理由で100Mbpsモードに降格することがあります。したがって、正しいルーター設定を行い、強制ギガビットモードを有効にし、ギガビットスイッチまたは直接接続されたデバイスと組み合わせることが、全ギガビットネットワークを実現するための重要なステップとなります。&lt;/p&gt;
&lt;p&gt;アップグレード後は、必ずギガ光ファイバー対応のONUとルーターに交換し、全ての機器インターフェースがギガビットに対応していることを確認してください。&lt;/p&gt;
&lt;h2 id=&#34;第3章隠された謎一本途切れられた細い線がテラビットネットワークにどう影響するか&#34;&gt;第3章：隠された謎—一本途切れられた細い線がテラビットネットワークにどう影響するか
&lt;/h2&gt;&lt;h3 id=&#34;サブスレッドの障害とネットワークパフォーマンスの低下&#34;&gt;サブスレッドの障害とネットワークパフォーマンスの低下
&lt;/h3&gt;&lt;p&gt;測速中はネットワーク接続は常に良好で、明らかな断線は見られませんでした。新しく導入された回線のため、配電盤内が整理整頓されておらず、光モデムのケーブルや電源コンセントの位置を調整している際に、たまたまギガビットに達することがありました。&lt;/p&gt;
&lt;p&gt;先行きの資料に基づき、LANケーブルの型番やONUのLAN口速度を分析・検証した結果、原因はLANケーブル内部の茶色のサブワイヤーが断線していたことが判明しました。&lt;/p&gt;
&lt;p&gt;設置の際に、水晶頭を取り付ける職人がケーブルを少し強く引っ張りすぎたことが原因で、内部の細い線が半分ほど断線していました。その後、光回線のモデムの位置を頻繁に移動させた結果、完全に断線しました。&lt;/p&gt;
&lt;h3 id=&#34;6種類のlanケーブルの8本の線の機能解説&#34;&gt;6種類のLANケーブルの8本の線の機能解説
&lt;/h3&gt;&lt;p&gt;六類網線は、TIA/EIA-568-B規格に準拠し、8芯のツイストペアケーブルで構成され、カラーコードは以下の通りです。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;白橙 / 橙&lt;/li&gt;
&lt;li&gt;白緑 / 緑&lt;/li&gt;
&lt;li&gt;藍 / 青&lt;/li&gt;
&lt;li&gt;茶色 / 濃茶&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ギガビットイーサネット（1000BASE-T）規格において、この8本のケーブルのうち4対が同時に動作し、それぞれ以下の役割を担います。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;白橙と橙のこのペアの線（1&amp;amp;2）は、データ送信（Tx+/-）に使用されます。&lt;/li&gt;
&lt;li&gt;白緑と緑のペア（3&amp;amp;6）は、データ受信（Rx+/-）に使用されます。&lt;/li&gt;
&lt;li&gt;白藍と青のペア（4&amp;amp;5）および白茶と茶のペア（7&amp;amp;8）は、ギガビットイーサネットでは通常はメインで使用されませんが、一部の高機能アプリケーション（例えば、特定のPoE給電や将来的な技術拡張）において有効になる可能性があります。一方、従来の100Mbpsネットワークでは、1, 2, 3, 6の4本の線を使用するだけで十分です。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;切断されたファイバーがネットワーク速度に与える影響&#34;&gt;切断されたファイバーがネットワーク速度に与える影響
&lt;/h3&gt;&lt;p&gt;上記の状況において、茶色のサブワイヤー（茶線または茶白線）が切れると、理論上はギガビットネットワーク環境では速度低下が生じます。なぜなら、ギガビットネットワークは全4対の線が双方向通信を行うことで高速を実現しているからです。しかしながら、家庭用ネットワーク機器にはオートネゴシエーション機能があり、ケーブルに問題が発生した場合、正常動作する低速モード、すなわち100Mbpsモードに切り替わります。これにより、サブワイヤーが切れても接続は維持され、100Mbpsで動作することが説明できます。&lt;/p&gt;
&lt;p&gt;要するに、単一の茶色のサブファイバーが切断されても、100Gbpsネットワークの基本的な動作には影響しませんが、ギガビットネットワーク環境下では、それが速度を制限する重要な要因となり得ます。徹底的な診断と修復を行うことで初めて、ギガ光ファイバーの潜在能力を最大限に発揮できます。これは、同様の問題に遭遇した場合、一見すると接続に影響がないように見える小さな故障であっても、ネットワークインフラストラクチャの潜在的な問題を無視してはならないことを示唆しています。そうした問題が高速ネットワーク体験の隠れた障害となる可能性があるからです。&lt;/p&gt;</description>
        </item>
        <item>
        <title>WPFのUIスレッドとフリーズ問題、およびその解決策</title>
        <link>https://ttf248.life/ja/p/wpf-ui-thread-and-freezing-issues-solutions/</link>
        <pubDate>Tue, 12 Mar 2024 07:12:21 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/wpf-ui-thread-and-freezing-issues-solutions/</guid>
        <description>&lt;p&gt;デスクトップアプリケーションを開発する際、特にWindows Presentation Foundation (WPF) フレームワークを使用してリッチクライアントアプリケーションを構築する場合、ユーザーインターフェース（UI）スレッドを正しく処理することは、アプリケーションの滑らかさと応答性を保証するために不可欠です。UI スレッド、別名メインスレッドは、ウィンドウやコントロールイベントの処理、レイアウト計算、およびインターフェースの描画を担当するコアスレッドです。UI 要素とのインタラクションに関わる操作はすべて UI スレッド上で実行されるべきであり、これは WPF および他のほとんどの GUI フレームワークが遵守する基本原則です。&lt;/p&gt;
&lt;h2 id=&#34;uiスレッドとは何ですか&#34;&gt;UIスレッドとは何ですか？
&lt;/h2&gt;&lt;p&gt;WPFアプリケーションの起動時にOSによって作成され、初期化されるUIスレッドは、アプリケーションのメインウィンドウを管理します。このスレッドのみがUIコンポーネントの状態に直接アクセスし、変更できます。ボタンクリックやテキストボックスへの入力、ウィンドウサイズ変更など、ユーザーインタラクションによって発生するすべてのイベントはこのスレッド上で処理されます。また、WPFの依存プロパティシステム、データバインディングメカニズム、およびレイアウトロジックもUIスレッド上で同期的に実行されます。&lt;/p&gt;
&lt;h2 id=&#34;動作不良とその原因&#34;&gt;動作不良とその原因
&lt;/h2&gt;&lt;p&gt;UIスレッドが長時間占有またはブロックされると、例えば時間のかかる計算処理や大量のデータ読み込み、データベースクエリなどのI/O集約型タスクを実行すると、UIスレッドはユーザーからのインタラクション要求にタイムリーに応答できなくなり、結果として画面がフリーズ（応答なし）したように見える。これにより、アプリケーションの遅延や不具合が顕著になり、最悪の場合「Application Not Responding」（ANR）警告が表示されることがある。&lt;/p&gt;
&lt;h2 id=&#34;uiスレッドの2つの基本ルール&#34;&gt;UIスレッドの2つの基本ルール
&lt;/h2&gt;&lt;p&gt;上記のような状況を避けるため、WPF開発者は以下の2つの重要なルールに従うべきです。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;UIスレッドがユーザーの入力にタイムリーに応答し、画面の変化をレンダリングできるように、UIスレッドをブロックする可能性のある操作は、可能な限りバックグラウンドスレッドで実行する必要があります。&lt;/li&gt;
&lt;li&gt;WPFのセキュリティ機構により、UI要素の変更はUIスレッドでのみ許可されます。他のスレッドから直接UIの状態を変更しようとすると例外が発生します。したがって、バックグラウンドスレッドで計算やデータ準備が完了した場合でも、適切なクロススレッド通信メカニズムを通じて結果をUIに表示する必要があります。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;非同期プログラミングとスレッドセーフな更新&#34;&gt;非同期プログラミングとスレッドセーフな更新
&lt;/h2&gt;&lt;p&gt;UIの応答性を維持しつつ、時間のかかるタスクを実行するために、WPFは開発者がこの目標を達成するのを支援するための様々な非同期プログラミングモデルとツールを提供します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WPFのDispatcherクラスを使用すると、タスクをUIスレッドのタスクキューに投入して実行できます。バックグラウンドスレッドから安全にUIを更新するために、&lt;code&gt;Dispatcher.Invoke&lt;/code&gt;或&lt;code&gt;Dispatcher.BeginInvoke&lt;/code&gt;メソッドを利用できます。&lt;/li&gt;
&lt;li&gt;C#の非同期機能を利用することで、非同期メソッドを記述し、その中で__INLINE_CODE_0__キーワードを使用してバックグラウンドタスク完了を待機し、完了後に自動的にUIスレッドで後続のUI更新コードを実行できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;事例&#34;&gt;事例
&lt;/h2&gt;&lt;h3 id=&#34;__inline_code_0__メソッドでuiを更新する&#34;&gt;__INLINE_CODE_0__メソッドでUIを更新する。
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private void Button_Click(object sender, RoutedEventArgs e)
{
    // 假设这是一个耗时操作
    Task.Run(() =&amp;gt;
    {
        var result = LongRunningOperation(); // 这里是模拟一个耗时计算的方法
        
        // 当耗时操作完成后，在UI线程上更新UI
        Application.Current.Dispatcher.Invoke(() =&amp;gt;
        {
            LabelStatus.Text = $&amp;quot;计算结果: {result}&amp;quot;;
        });
    });
}

private string LongRunningOperation()
{
    // 模拟耗时操作
    Thread.Sleep(5000);
    return &amp;quot;已完成&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用__斜体_3__粗体_2__斜体_4__&#34;&gt;使用__斜体_3__粗体_2__斜体_4__
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private async void Button_ClickAsync(object sender, RoutedEventArgs e)
{
    Button button = sender as Button;
    button.IsEnabled = false; // 防止用户重复点击

    try
    {
        // 开启后台任务
        var result = await Task.Run(() =&amp;gt; LongRunningOperation());

        // 在后台任务完成后，自动切换回UI线程更新UI
        LabelStatus.Text = $&amp;quot;计算结果: {result}&amp;quot;;
    }
    catch (Exception ex)
    {
        MessageBox.Show($&amp;quot;发生错误: {ex.Message}&amp;quot;);
    }
    finally
    {
        button.IsEnabled = true; // 重新启用按钮
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>GCCバージョンアップによりプログラムがクラッシュ：非標準コードの潜在的な問題</title>
        <link>https://ttf248.life/ja/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</link>
        <pubDate>Sun, 10 Mar 2024 23:19:06 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</guid>
        <description>&lt;p&gt;同一のビジネスコードの場合、プログラムは CentOS 7 環境で正常にコンパイルされ実行されたが、CentOS 8 に切り替えて更新版 GCC でコンパイルするとクラッシュした。問題は &lt;strong&gt;Release 模式&lt;/strong&gt; の場合にのみ発生し、&lt;strong&gt;Debug 模式&lt;/strong&gt; では全く問題なかった。今回初めてこのような事態に遭遇したが、3 日間の調査の結果、ようやく原因を突き止めた。&lt;/p&gt;
&lt;h3 id=&#34;問題特定&#34;&gt;問題特定
&lt;/h3&gt;&lt;p&gt;徹底的な調査の結果、問題の根本原因は &lt;strong&gt;函数缺少返回值&lt;/strong&gt; にありました。リリースモードでは、GCC の新バージョンがより多くの最適化を行うため、元々明示的な戻り値を持たない関数が実行中に予期せぬ動作を起こし、クラッシュを引き起こしました。結論として、&lt;strong&gt;编译器的警告不容忽视，尤其是在老项目中，部分警告可能被无视，但也应当避免屏蔽所有警告&lt;/strong&gt; です。&lt;/p&gt;
&lt;h3 id=&#34;環境説明&#34;&gt;環境説明
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39)
Copyright © 2015 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 8.5.0 20210514 (Red Hat 8.5.0-21)
Copyright (C) 2018 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;クラッシュ現象&#34;&gt;クラッシュ現象
&lt;/h3&gt;&lt;p&gt;プログラムクラッシュのスタックを解析した結果、以下のスタック情報が見られました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[New LWP 1385902]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib64/libthread_db.so.1&amp;quot;.
Core was generated by `./pstack_main`.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007ffe894b4420 in ?? ()
(gdb) bt
#0  0x00007ffe894b4420 in ?? ()
#1  0x00000000004008e9 in main ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このスタックは直感的ではなく、クラッシュした関数のスタック情報が &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; と表示されているため、問題の特定がより複雑になっています。&lt;/p&gt;
&lt;h3 id=&#34;コード例&#34;&gt;コード例
&lt;/h3&gt;&lt;p&gt;問題をより良く理解するために、クラッシュを再現する最小限のコード例を以下に示します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int test() {
    std::cout &amp;lt;&amp;lt; &amp;quot;1&amp;quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    test();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;そのコード内の &lt;code&gt;test()&lt;/code&gt; 函数显然没有显式返回一个值，而它的返回类型是 &lt;code&gt;int&lt;/code&gt;。根据 C++ 规范，当一个函数声明为 &lt;strong&gt;INLINE_CODE_2&lt;/strong&gt; 型では、必ず値を返す必要がある。さもなくば、未定義の動作を引き起こす可能性がある。&lt;/p&gt;
&lt;h3 id=&#34;コンパイル警告&#34;&gt;コンパイル警告
&lt;/h3&gt;&lt;p&gt;プロジェクトにおいて、CMakeスクリプトが多くのコンパイル時の警告を抑制しており、その中には以下の警告が含まれています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/root/pstack/main.cpp: In function ‘int test()’:
/root/pstack/main.cpp:7:1: warning: no return statement in function returning non-void [-Wreturn-type]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この警告は、__INLINE_CODE_0__関数が値を返さないことを示しており、これが問題の根本原因です。高バージョンGCC（例えば8.5.0）は、コードを最適化する際に、このような未定義の振る舞いに対して不安定な最適化を行い、プログラムをクラッシュさせる可能性があります。&lt;/p&gt;
&lt;h3 id=&#34;アセンブリコードの差異&#34;&gt;アセンブリコードの差異
&lt;/h3&gt;&lt;p&gt;GCCコンパイラ最適化の差異を説明するため、異なるバージョンのGCCが生成するアセンブリコードを比較しました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;アセンブリコードは冗長であり、標準出力ストリーム（&lt;code&gt;std::cout&lt;/code&gt;）的处理逻辑。这表明编译器进行了更保守的优化，未对 &lt;code&gt;test()&lt;/code&gt;関数における戻り値の欠落問題など）に対する過剰な最適化が含まれているため、クラッシュを回避できた可能性がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新しいGCCでは、より多くの最適化が行われ、コード量が削減されました。しかし、この最適化により、戻り値がない関数の実行時に動作が不安定になり、プログラムがクラッシュする可能性があります。&lt;/p&gt;
&lt;h3 id=&#34;結論&#34;&gt;結論
&lt;/h3&gt;&lt;p&gt;今回の問題の調査を通じて、C++において、&lt;strong&gt;函数返回值必须明确&lt;/strong&gt;（特に__INLINE_CODE_0__ 时，必须提供一个返回值。对于使用较旧版本编译器的项目，升级到新版本的 GCC 时，可能会遇到更多的优化和更严格的警告机制。因此，我们建议在编译时 **関数宣言の場合）、すべての警告を無視するのではなく、選択的に処理することが重要であると深く認識しました。特に、関数戻り値や型の一致など、一般的な問題には注意が必要です。&lt;/p&gt;
&lt;p&gt;最終、&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 関数に返り値を追加することで問題が解決し、プログラムは正常に動作するようになった。&lt;/p&gt;</description>
        </item>
        <item>
        <title>VMware仮想マシンのCPUリソース使用量異常</title>
        <link>https://ttf248.life/ja/p/vmware-virtual-machine-cpu-resource-usage-anomaly/</link>
        <pubDate>Sun, 10 Mar 2024 22:14:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/vmware-virtual-machine-cpu-resource-usage-anomaly/</guid>
        <description>&lt;p&gt;バックグラウンド：ローカルマシンにWindows版の業務システムがデプロイされており、CPUリソース使用率は約5%。VMwareにインストールされたCentOS8上にLinux版業務システムをデプロイしたところ、リソース使用量が異常です。&lt;/p&gt;
&lt;h2 id=&#34;問題説明&#34;&gt;問題説明
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;ホストOS：Windows 10 Enterprise&lt;/li&gt;
&lt;li&gt;vmware：17.5&lt;/li&gt;
&lt;li&gt;仮想マシン：CentOS 8&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;仮想マシンリソースの割り当ては__INLINE_CODE_0__です。ビジネスシステムを起動します。ビジネスシステムは仮想マシンLinuxにデプロイされており、仮想マシン内部のtopコマンドでシステムリソースの使用状況を確認したところ、CPU使用率は高くありませんでした。一方、外側のWindowsシステムではタスクマネージャーでCPUリソースの使用率が非常に高いことが確認でき、プロセスを確認するとVMwareプロセスがCPUリソースを大量に消費していました。&lt;/p&gt;
&lt;p&gt;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+
|         Windows           |
|                           |
|   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+  |
|   |      VMware        |  |
|   |      Program       |  |
|   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+  |
|                           |
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+&lt;/p&gt;
&lt;h2 id=&#34;知識点&#34;&gt;知識点
&lt;/h2&gt;&lt;p&gt;この問題の切り分けは順調に進まず、原因が通常のビジネスシステムではなく、仮想マシン自体の問題にあることが判明しました。いかにして発想を通常のビジネスコードからシステム負荷へ、そして負荷データの異常からソフト割り込みへと転換し、最終的に何がVMwareソフト割り込みの効率に影響を与えるかを特定するか？ 本稿ではまず各知識点を解説し、最後に解決策を示します。&lt;/p&gt;
&lt;h3 id=&#34;hyper-v&#34;&gt;hyper-v
&lt;/h3&gt;&lt;p&gt;Windows オペレーティングシステムの仮想化技術は大きな変革を遂げました。Microsoft が WSL を初めてリリースした際、Hyper-V サービスを有効にすると VMware 仮想マシンが同時に使用できませんでした。しかし、その後のバージョンで VMware は Hyper-V サービスとの互換性が得られました。&lt;/p&gt;
&lt;h3 id=&#34;システム負荷&#34;&gt;システム負荷
&lt;/h3&gt;&lt;p&gt;Linuxシステムにおいて、「ロード」（load）とは、実行中または実行待ちのプロセスの数を指します。通常、ロードは1分間、5分間、および15分間の実行キュー内の平均プロセス数を示す3つの数字で表されます。これらの数値は、「uptime」コマンドや「top」コマンドを実行することで確認できます。&lt;/p&gt;
&lt;p&gt;具体的には、この3つの数字はそれぞれ以下のものを表します。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;過去1分間の実行キューの平均プロセス数。&lt;/li&gt;
&lt;li&gt;過去5分間の実行キューの平均プロセス数。&lt;/li&gt;
&lt;li&gt;過去15分間の実行キューの平均プロセス数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;負荷とは、システム内で実行待ちのプロセス数を指します。この数がシステムの論理 CPU 数よりも高い場合、システム負荷が高いことを示し、多くのプロセスがプロセッサリソースを待機していることを意味します。これにより、システムが遅くなったり、応答しなくなったりする可能性があります。その程度やシステムの構成・性能によって異なります。&lt;/p&gt;
&lt;p&gt;理想的には、負荷はシステムの論理 CPU 数範囲内に維持し、システム性能を最適化することが望ましいです。もし負荷が継続的に CPU 数を超えた場合、システム内のプロセスを分析し、高負荷の原因を特定した上で、システムリソースの割り当て調整やプロセスの実行方法の最適化などの対策を講じる必要があるかもしれません。&lt;/p&gt;
&lt;h3 id=&#34;負荷解析-mpstat&#34;&gt;負荷解析 mpstat
&lt;/h3&gt;&lt;p&gt;負荷解析の手順：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;安装 sysstat&lt;/strong&gt;:
もし、あなたのシステムに &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; がインストールされていない場合は、システムに適したパッケージ管理ツールでインストールしてください。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;运行 mpstat&lt;/strong&gt;:
使用リソースの使用状況を表示&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;01:32:33 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
01:32:35 PM  all    0.00    0.00    0.26    0.00    3.73    0.26    0.00    0.00    0.00   95.76
01:32:35 PM    0    0.00    0.00    0.51    0.00    3.57    0.00    0.00    0.00    0.00   95.92
01:32:35 PM    1    0.00    0.00    0.00    0.00    3.59    0.51    0.00    0.00    0.00   95.90
01:32:35 PM    2    0.00    0.00    0.00    0.00    4.15    0.00    0.00    0.00    0.00   95.85
01:32:35 PM    3    0.00    0.00    0.52    0.00    3.61    0.52    0.00    0.00    0.00   95.36
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分析输出&lt;/strong&gt;:
出力には、各CPUの利用率とシステムの平均負荷が含まれます。平均負荷と各CPUの利用率に特に注意を払うことで、システムの負荷状況を把握できます。負荷が高い場合は、原因となっているプロセスやパフォーマンスボトルネックをさらに分析できます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;结合其他工具&lt;/strong&gt;:
様々なツールを用いてシステムパフォーマンスを総合的に分析します。複数のツールの出力を組み合わせることで、システムの負荷状況をより詳細に把握し、パフォーマンス問題の根本原因を特定できます。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;中断&#34;&gt;中断
&lt;/h3&gt;&lt;p&gt;ここでは詳細な説明は省略します。
推奨：&lt;a class=&#34;link&#34; href=&#34;https://www.codedump.info/post/20200522-sgfap-softirq/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《面向应用开发者的系统指南》CPU篇之软中断&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;頻繁なソフト割り込みの発生は、システム負荷に現れる。&lt;/p&gt;
&lt;h2 id=&#34;問題の切り分け&#34;&gt;問題の切り分け
&lt;/h2&gt;&lt;p&gt;CPUの観点だけで問題を特定できない場合、システムに異常が発生している可能性を疑うべきではないでしょうか？ Linuxオペレーティングシステムの負荷が高すぎて、VMwareが過剰なCPUリソースを消費しているのかもしれません。使用率（&lt;code&gt;mpstat&lt;/code&gt;BOLD_3&lt;code&gt;irq&lt;/code&gt;占用异常，单核接近25%，而在正常情况下，启动业务进程空跑时，&lt;code&gt;irq&lt;/code&gt;）は約5%であるはずです。&lt;/p&gt;
&lt;p&gt;グループ内チームメイトの開発環境では、彼のCentOS 7はVMware上にデプロイされており、リソース使用率は正常に表示されている。一方、上海の開発環境では、同様にVMwareだが、ホストのCPUリソース状況を直接観察できない。この際、VMware仮想マシン、Linuxオペレーティングシステム、そしてGCCバージョンという複数の変数が存在する。&lt;/p&gt;
&lt;p&gt;深圳のテスト環境を分析すると、物理マシン上に古いバージョンのGCCコンパイルサービスが稼働しており、CentOS 8上で動作している。興味深いことに、深圳環境では &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; の占有は正常である。&lt;/p&gt;
&lt;p&gt;問題の切り分けのため、より新しいバージョンの GCC でコンパイルしたプログラムを深セン環境にデプロイしてテストした結果、すべて正常でした。&lt;/p&gt;
&lt;p&gt;問題はより明確になりつつあり、オペレーティングシステムに問題があるのではないかと疑い始めています。結局のところ、CentOS 8 は公式サポートが終了しています。しかし、クリーンな CentOS 7 と CentOS 8 を再デプロイしても、問題は依然として存在します。&lt;/p&gt;
&lt;p&gt;今のところ、唯一の不確定要素であるVMware仮想マシンソフトウェアを疑い始めています。すると突然、Hyper-V技術が頭に浮かびました。以前にHyper-Vが有効になっていて、完全にシャットダウンされなかったためにこの問題が発生しているのでしょうか？結局のところ、ソフト割り込みも仮想マシンソフトウェアによって実現されます。異なる仮想化技術にバグは存在しないのでしょうか？これらの問題について深く考察し、調査する必要があります。&lt;/p&gt;
&lt;h2 id=&#34;結論&#34;&gt;結論
&lt;/h2&gt;&lt;p&gt;マイクロソフトの公式ドキュメントによると、ローカルのHyper-Vサービスを完全に停止したところ、VMwareがホスト上で正常に復旧しました。これで問題はついに解決しました。当初述べたように、この経験は紆余曲折があり、総合的な分析と判断が必要でした。また、今回初めて問題の切り分けを行い、仮想マシンレベルまで特定に至りました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Disable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V-Hypervisor
bcdedit /set hypervisorlaunchtype off
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/application-management/virtualization-apps-not-work-with-hyper-v&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/application-management/virtualization-apps-not-work-with-hyper-v&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43;プログラミングの落とし穴：`std::map` の誤った使用によるプログラムクラッシュの詳細解説</title>
        <link>https://ttf248.life/ja/p/cpp-programming-traps-std-map-crash-details/</link>
        <pubDate>Sun, 10 Mar 2024 22:03:06 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cpp-programming-traps-std-map-crash-details/</guid>
        <description>&lt;p&gt;C++プログラミングにおける&lt;code&gt;__INLINE_CODE_0__&lt;/code&gt;コンテナの誤った使用が、プログラムのクラッシュを引き起こす可能性があることを明らかにすることを目的としています。角括弧演算子で存在しないキーにアクセスしようとすると、自動的に空要素が追加されます。この誤解を深く分析し、サンプルコードを通じて潜在的なリスクを示します。&lt;/p&gt;
&lt;p&gt;単純な値を格納する分には問題ありませんが、ポインタを格納すると問題が生じます。ポインタはアドレスであり、初期化されていない場合、そのアドレスは未確定となり、プログラムのクラッシュにつながる可能性があります。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;C++標準ライブラリにおいて、``std::map&lt;code&gt;是一种关联容器，它按照键（key）的升序存储元素，并提供了高效的关键字查找功能。然而，新手开发者有时会因为对&lt;/code&gt;std::map&lt;code&gt;BOLD_6&lt;/code&gt;[]&lt;code&gt;BOLD_7&lt;/code&gt;[]&lt;code&gt; 访问一个不存在的键时，__INLINE_CODE_4__&lt;/code&gt;は新しいキーバリューペアを挿入し、デフォルトコンストラクタを用いてキーに対応する値の型を初期化します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int main() {
    std::map&amp;lt;std::string, int&amp;gt; myMap;
    
    // 错误的用法：假设这里试图访问一个不存在的键并认为会得到0
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for &#39;nonexistent_key&#39;: &amp;quot; &amp;lt;&amp;lt; myMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;

    // 实际上，上述行代码创建了一个新的键值对，其中值被默认初始化为int的默认值（通常是0）
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記のコードはプログラムを直接クラッシュさせることはありませんが、このような暗黙的な挿入処理は、リソースリークや予期せぬ状態変化といった副作用を引き起こす可能性があります。さらに悪いことに、マルチスレッド環境で未初期化のメモリ領域に同時にアクセスすると、プログラムがクラッシュする可能性もあります。&lt;/p&gt;
&lt;p&gt;類似の問題を防ぐため、__INLINE_CODE_0__BOLD_3&lt;code&gt;std::map::count()&lt;/code&gt;BOLD_4&lt;code&gt;std::map::insert()&lt;/code&gt;要素を明示的に挿入することを推奨します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::map&amp;lt;std::string, int&amp;gt; safeMap;
if (safeMap.count(&amp;quot;nonexistent_key&amp;quot;) == 0) {
    std::cout &amp;lt;&amp;lt; &amp;quot;Key does not exist.&amp;quot; &amp;lt;&amp;lt; std::endl;
} else {
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for existing key: &amp;quot; &amp;lt;&amp;lt; safeMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;
}

// 或者明确插入一个键值对，指定初始值
safeMap.insert({ &amp;quot;new_key&amp;quot;, 0 });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;もしmapコンテナ内にポインタ型のオブジェクトが格納されている場合、要素の自動挿入は初期化されていないポインタを保持し、そのポインタに対するいかなる操作もプログラムクラッシュを引き起こす可能性があります。&lt;/p&gt;</description>
        </item>
        <item>
        <title>pstackでプロセスフリーズを調査</title>
        <link>https://ttf248.life/ja/p/pstack-troubleshooting-process-hang/</link>
        <pubDate>Sat, 24 Feb 2024 23:55:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/pstack-troubleshooting-process-hang/</guid>
        <description>&lt;p&gt;ソフトウェア開発や運用において、プロセスがフリーズする状況に遭遇することがあります。この状況はシステムパフォーマンスの低下やサービス停止を引き起こす可能性があります。本稿では、pstackツールを使用してプロセスフリーズの問題をトラブルシューティングする方法について説明します。プロセスのスタック情報を分析することで、問題の原因を特定し解決策を見つけます。&lt;/p&gt;
&lt;p&gt;風控システムの子サービスが応答停止し、風控サービスが利用不能に。サービス可用性モニタリングの不足により、プロセス応答停止をタイムリーに検知できず、システムが利用不能となった。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;プロセスデッドロックとは、プロセスが応答しなくなるものの、終了しない状態を指します。これは、デッドロック、リソース枯渇、例外など、様々な原因で発生する可能性があります。このような問題を解決するためには、pstackツールを使用してプロセスのスタック情報を分析し、問題の根本原因を特定することができます。&lt;/p&gt;
&lt;h2 id=&#34;手順&#34;&gt;手順
&lt;/h2&gt;&lt;p&gt;pstack は、一般的に gdb（GNU デバッガー）と共に提供される便利なツールです。以下のコマンドでインストールできます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt-get install gdb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;プロセスIDの取得：まず、スリープ状態のプロセスのプロセスID（PID）を取得する必要があります。psコマンドを使用して、すべてのプロセスをリストし、調査対象のプロセスIDを見つけます。
pstack ツールを使用してプロセススタックを解析します。プロセス ID を取得したら、pstack ツールでそのプロセスのスタック情報を入手できます。以下のコマンドを実行してください:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pstack &amp;lt;PID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このプロセスが実行中の関数呼び出しシーケンスを表示し、スタック情報を出力します。これらの情報から、プロセスの停止位置を特定し、問題の箇所を突き止めることができます。&lt;/p&gt;
&lt;p&gt;スタック情報を解析することで、プロセスの応答なしの原因を特定できます。デッドロックや無限ループ、その他の異常が発見される可能性があります。状況に応じて、ロックの解放やコードロジックの修正などの対応策を講じてください。&lt;/p&gt;
&lt;h2 id=&#34;事例&#34;&gt;事例
&lt;/h2&gt;&lt;p&gt;簡単なデモで、メイン関数起動後、新しいスレッドを作成し、実際の実行関数が無限ループに入り、プログラムが正常に終了せず、フリーズした状態になる。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cmake_minimum_required(VERSION 3.0.0)
project(pstack_main VERSION 0.1.0 LANGUAGES C CXX)

include(CTest)
enable_testing()

# 查找线程库
find_package(Threads REQUIRED)

add_executable(pstack_main main.cpp)

# 链接线程库
target_link_libraries(pstack_main PRIVATE Threads::Threads)

set(CPACK_PROJECT_NAME ${PROJECT_NAME})
set(CPACK_PROJECT_VERSION ${PROJECT_VERSION})
include(CPack)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;
#include &amp;lt;chrono&amp;gt;

void infiniteLoop() {
    while (true) {
        // 主线程进入死循环
    }
}

int main() {
    std::thread thread(infiniteLoop); // 创建一个线程，执行死循环函数
    thread.join(); // 等待线程结束
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;プログラム起動、pstack結果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Thread 2 (Thread 0x7eff3619b700 (LWP 1315017)):
#0  infiniteLoop () at /root/pstack/main.cpp:6
#1  0x0000000000402ca9 in std::__invoke_impl&amp;lt;void, void (*)()&amp;gt; (__f=@0x2260eb8: 0x4029a6 &amp;lt;infiniteLoop()&amp;gt;) at /usr/include/c++/8/bits/invoke.h:60
#2  0x0000000000402b02 in std::__invoke&amp;lt;void (*)()&amp;gt; (__fn=@0x2260eb8: 0x4029a6 &amp;lt;infiniteLoop()&amp;gt;) at /usr/include/c++/8/bits/invoke.h:95
#3  0x0000000000403150 in std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt;::_M_invoke&amp;lt;0ul&amp;gt; (this=0x2260eb8) at /usr/include/c++/8/thread:244
#4  0x0000000000403126 in std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt;::operator() (this=0x2260eb8) at /usr/include/c++/8/thread:253
#5  0x000000000040310a in std::thread::_State_impl&amp;lt;std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt; &amp;gt;::_M_run (this=0x2260eb0) at /usr/include/c++/8/thread:196
#6  0x00007eff36bceb23 in execute_native_thread_routine () from /lib64/libstdc++.so.6
#7  0x00007eff36ea91ca in start_thread () from /lib64/libpthread.so.0
#8  0x00007eff361d58d3 in clone () from /lib64/libc.so.6
Thread 1 (Thread 0x7eff372e1740 (LWP 1315016)):
#0  0x00007eff36eaa6cd in __pthread_timedjoin_ex () from /lib64/libpthread.so.0
#1  0x00007eff36bceda7 in std::thread::join() () from /lib64/libstdc++.so.6
#2  0x00000000004029d2 in main () at /root/pstack/main.cpp:13
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;確認できるところによると、プロセスのフリーズの原因は無限ループです。メインスレッドが無限ループに入り、サブスレッドが終了できず、結果としてプロセスがフリーズします。&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
