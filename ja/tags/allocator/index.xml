<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Allocator on 向叔の手帳</title>
        <link>https://ttf248.life/ja/tags/allocator/</link>
        <description>Recent content in Allocator on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Sun, 01 Jun 2025 15:10:34 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/tags/allocator/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>標準ライブラリコンテナのメモリ割り当て子：allocator</title>
        <link>https://ttf248.life/ja/p/standard-library-container-memory-allocator/</link>
        <pubDate>Mon, 30 Dec 2019 13:26:19 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/standard-library-container-memory-allocator/</guid>
        <description>&lt;p&gt;カスタムディストリビューターを使用することで、パフォーマンスを向上させ、メモリ使用効率を高め、頻繁な少量のメモリ割り当ての問題を解決できます。&lt;/p&gt;
&lt;h4 id=&#34;前因&#34;&gt;前因
&lt;/h4&gt;&lt;p&gt;近頃、ネットワークパケットの開発に携わり、頻繁に小さなメモリ領域を申請し解放する必要がありました。当初はメモリプールを使用することを検討しましたが、いくつかの既存のメモリプールを確認したところ、この
&lt;a class=&#34;link&#34; href=&#34;https://github.com/cacay/MemoryPool&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/cacay/MemoryPool&lt;/a&gt;
を見つけました。インターフェースを見たとき、このメモリプールの実装が少し奇妙だと疑問に思いました。「MemoryPool」の実装ロジックは、固定サイズのメモリ領域を申請することです。boostのメモリプールインターフェースを見ていたところ、テンプレートを提供し、使用時にインスタンス化することができました。ちょうどこのライブラリには、「allocator」という概念について言及した記事があり、紹介されていました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;#### [wiki](https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_(C%2B%2B))

C++プログラミングにおいて、割り当て子（英語：allocator）はC++標準ライブラリの重要な構成要素です。C++のライブラリには、リスト、集合などのように、共通して「コンテナ」と呼ばれるさまざまなデータ構造が定義されています。これらのコンテナの共通の特徴は、プログラムの実行時にサイズを変更できることです。これを実現するために、動的メモリ割り当てが必要となり、その際に割り当て子が使用されます。つまり、割り当て子は、標準テンプレートライブラリ（STL）コンテナのメモリ管理に関する低レベルの詳細を包摂する役割を果たします。デフォルトでは、C++標準ライブラリは独自の汎用割り当て子を使用しますが、必要に応じて、プログラムでカスタム割り当て子を定義して置き換えることも可能です。
``` - 分配器は、アレクサンドル・ステパノフによってC++標準テンプレートライブラリ（Standard Template Library、以下STL）の一部として発明されました。当初の目的は、「ライブラリをより柔軟にし、低レベルなデータモデルに依存しない方法を実現する」ことであり、プログラマがライブラリ内でカスタムポインタや参照型を利用することを可能にするものでした。しかし、標準テンプレートライブラリをC++標準に組み込む際、C++標準委員会は、データモデルの完全な抽象化処理が不可受容な性能低下をもたらすことを認識し、妥協策として、分配器に対する制限がより厳しくなりました。その結果、ステパノフ当初の構想と比較して、現在の標準で記述されている分配器のカスタマイズ性は大幅に制限されています。

```markdown
#### [wiki](https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_(C%2B%2B))

分配器のカスタマイズには制限があるものの、多くのケースではカスタムの分配器が必要となります。これは、主に異なる種類のメモリ空間（共有メモリと回収済みメモリなど）へのアクセス方法をカプセル化したり、メモリプールを使用したメモリ割り当て時のパフォーマンス向上を目的としたものです。さらに、メモリ使用量と実行時間から見ると、頻繁に少量のメモリを割り当てるプログラムにおいて、専用の分配器を導入することでメリットが得られる場合があります。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;使用要件httpszhwikipediaorgwikie58886e9858de599a8_c2b2b&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_%28C%2B%2B%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;使用要件&lt;/a&gt;
&lt;/h4&gt;&lt;p&gt;カスタムディスペンサーを定義する主な理由は、パフォーマンスの向上です。専用のカスタムディスペンサーを使用することで、プログラムのパフォーマンスを向上させたり、メモリ使用量を削減したり、あるいは両方を実現したりできます[4][8]。デフォルトディスペンサーは&lt;code&gt;new&lt;/code&gt;演算子を使用してストレージスペースを割り当てるため[文 5]、これは通常C言語のヒープ割り当て関数（malloc()）で実装されます[9]。ヒープ割り当て関数は、偶発的な大量メモリ割り当てに対する最適化のために設計されているため、一度に大量のメモリが必要なコンテナ（ベクトル、双端キューなど）にメモリを割り当てる場合は、デフォルトディスペンサーは通常効率的です[8]。ただし、連想コンテナや双方向リストのような、頻繁に少量メモリを割り当てられるコンテナの場合、デフォルトディスペンサーを使用すると、一般的に効率が低くなります[4][9]。&lt;/p&gt;
&lt;h4 id=&#34;利用要請httpszhwikipediaorgwikie58886e9858de599a8_c2b2b&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_%28C%2B%2B%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;利用要請&lt;/a&gt;
&lt;/h4&gt;&lt;p&gt;要するに、このセクション（……）（まるで）は、この標準がディストリビューターに対する「私は夢を持っています」の演説です。夢が実現する前に、移植性を重視するプログラマーは、ステートレスなカスタムディストリビューターに限定されます。
——スコット・メイヤー，《Effective STL》
上記を鑑みて、この状況下では、メモリプールベースのディストリビューターを使用して、頻繁で少量の割り当ての問題[8]を解決することがよくあります。 デフォルトの「オンデマンド」方式とは異なり、メモリプールベースのアロケータを使用する場合、プログラムは事前に大量のメモリ（すなわち「メモリプール」）を割り当てます。その後、メモリを割り当てる必要があるときに、カスタムアロケータは、リクエスト側に対してプール内のメモリへのポインタを返すだけで済みます。オブジェクトが破棄される際には、実際にメモリを解放する必要はなく、代わりにメモリプールのライフサイクルが終了するまで遅延します[注1][8]。&lt;/p&gt;
&lt;h4 id=&#34;使用要件httpszhwikipediaorgwikie58886e9858de599a8_c2b2b-1&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_%28C%2B%2B%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;使用要件&lt;/a&gt;
&lt;/h4&gt;&lt;p&gt;「カスタム分配器」というトピックに関して、多くの C++ 専門家や関連著者の執筆に参加しており、例えばスコット・メイスの『Effective STL』やアンデル・アレクサンドレスクの『Modern C++ Design』で言及されている。メイスは、特定の型 T の分配子のすべてのインスタンスが等しいという要件の場合、移植可能な分配子のインスタンスには状態を含んではならないと洞察している。C++ 標準はライブラリの実装者が状態を含む分配子をサポートするように推奨している[文 4]が、メイスは、この段落は「（見かけ上）素晴らしい視点」であるにもかかわらず、ほぼ空論であり、分配子の制限は「過度に厳格」であると述べている[4]。 例えば、STLのリストはスプラッシュ（splice）メソッドをサポートしており、あるリストオブジェクトAのノードを別のリストオブジェクトBに直接挿入することができます。これは、Aのアルロケーターが確保したメモリを、Bのアルロケーターが解放することを意味し、それによってAとBのアルロケーターインスタンスは等しいと結論付けられます。メイヤーの結論は、アルロケーターは静的メソッドを使用するタイプとして定義されるべきであるということです。例えば、C++標準では、アルロケーターはrebindメソッドを実装したotherクラステンプレートを提供する必要があります。&lt;/p&gt;
&lt;h4 id=&#34;使用要件httpszhwikipediaorgwikie58886e9858de599a8_c2b2b-2&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_%28C%2B%2B%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;使用要件&lt;/a&gt;
&lt;/h4&gt;&lt;p&gt;ヤニー・ストラウストルプが『C++プログラム設計言語』で述べたように、「厳密な割り当て制限を設け、各オブジェクトの情報が異なるのを防ぐ」という点は「問題ない」（大意）とされ、ほとんどの割り当ては状態を必要とせず、あるいは状態がない場合に性能が良いと指摘されています。彼は、メモリプール型、共有メモリ型、そしてガベージコレクション型の3つのカスタム割り当て器の用途を提案し、内部メモリプールを利用して少量のアドレス空間を高速に割り当て/解除する割り当て器の実装を示しました。しかし、この最適化はすでに提供されたサンプル割り当て器で実現されていることも指摘しています[3]。&lt;/p&gt;
&lt;p&gt;カスタム割り当て器のもう一つの用途は、メモリ関連のエラーのデバッグです[10]。 これを実現するには、割り当て時に追加のメモリを割り当て、そこでデバッグ情報を保存するディスパッサーを作成できます。このようなディスパッサーは、同種の割り当て/解放が同一ディスパッサーによって行われるだけでなく、キャッシュオーバーフローからプログラムをある程度保護することも可能です[11]。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
