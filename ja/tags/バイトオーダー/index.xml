<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>バイトオーダー on 向叔の手帳</title>
        <link>https://ttf248.life/ja/tags/%E3%83%90%E3%82%A4%E3%83%88%E3%82%AA%E3%83%BC%E3%83%80%E3%83%BC/</link>
        <description>Recent content in バイトオーダー on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Sun, 25 May 2025 14:10:37 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/tags/%E3%83%90%E3%82%A4%E3%83%88%E3%82%AA%E3%83%BC%E3%83%80%E3%83%BC/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>コンピュータがなぜ一般的にリトルエンディアンを採用しているのか</title>
        <link>https://ttf248.life/ja/p/little-endian-storage-why/</link>
        <pubDate>Wed, 24 Jan 2024 10:43:05 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/little-endian-storage-why/</guid>
        <description>&lt;p&gt;バイトオーダーに関する解説[ホストOS順、ネットワークOS順、デバッガーで直接観察する]({&amp;lt; relref &amp;ldquo;/post/2023/01-10-ホストOS順、ネットワークOS順、デバッガーで直接観察する&amp;rdquo; &amp;gt;}})&lt;/p&gt;
&lt;p&gt;コンピュータ分野で歴史的な経緯から形成されたある種の設計習慣は、おべっか粉の幅がロケット推進器の幅を決める道理と同じで、無理に「利点」「欠点」を分析する必要はなく、単なる慣習です。&lt;/p&gt;
&lt;h2 id=&#34;元のリンク&#34;&gt;元のリンク
&lt;/h2&gt;&lt;p&gt;著者：北極
リンク：&lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/question/637413724/answer/3346032134&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.zhihu.com/question/637413724/answer/3346032134&lt;/a&gt;
出典：知乎
著作権は著者に帰属します。商業目的での転載には、著者に許可を得てください。非商用目的での転載の場合は、出典を明記してください。&lt;/p&gt;
&lt;h2 id=&#34;転載本文&#34;&gt;転載本文
&lt;/h2&gt;&lt;p&gt;現在のビッグエンディアン／リトルエンディアンの状況は、歴史的な慣習と商業化の結果であり、技術そのものとは大きく関係ありません。ARMは、ビッグエンディアンにもリトルエンディアンにも設定できます。TCP/IPヘッダーも現在でもビッグエンディアン（ネットワークバイトオーダー）です。ストレージ分野においても、多くのストレージプロトコル／仕様でデータは大端方式で保存されています。&lt;/p&gt;
&lt;p&gt;ですから、質問者の３つの質問は、今日の視点から見ると：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;コンピュータがなぜ一般的にリトルエンディアンを採用しているのか？→ 誤り。&lt;/li&gt;
&lt;li&gt;効率は必ずしも高くなるわけではありません。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;現代の技術をもってしても、これらの問題を論証するのは、矢を放ってから的に当てるような行為だ。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;しかし、ビッグエンディアンかリトルエンディアンかの選択に関して言えば、コンピュータの発展史の中で、確かに一定の客観的な要因がありました。ホスト・バイトオーダー（リトルエンディアン）の利点：リトルエンディアンの方が加算回路が作りやすいです。8ビット*4の加算器を作る場合、1つの8ビット加算器で十分で、低位から高位へ順に各バイトを足し合わせれば良いのです。キャリー回路は非常にシンプルですが、ビッグエンディアンの場合、一度に32ビットをロードする必要があり、そうしないと計算できません。現在では、一度に8ビットか32ビットかをロードする違いはそれほど大きくありませんが、数十年前のメモリ価格が高かったため、できるだけシンプルな方が良いので、ホスト・バイトオーダーのリトルエンディアンを選択したのはコストを考慮した結果です。ネットワーク・バイトオーダー（ビッグエンディアン）の利点：初期のデバイスのキャッシュは非常に小さく、上位バイトを受信することで、パケット情報を迅速に判断できました。バッファサイズ（どれくらいのキャッシュを用意する必要があるか）、アドレス範囲（IPアドレスは先頭からマッチングされる）です。初期のネットワークデバイスのキャッシュはバイト単位で動作しており、上位バイトを取得すると確かに少し速くなります。そのため、ネットワークデバイスがビッグエンディアンを使用しているのも、コストを考慮した結果です。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;そのため、バイトオーダーの選択は、歴史的に見ると、主にアプリケーションのシナリオやコストを考慮したものでした（例えば、PPC/MIPSはネットワーク機器に適しているなど）。そして、その後の技術発展の中で、互換性のために、リトルエンディアン／ビッグエンディアンの設定が現在まで引き継がれています。&lt;/p&gt;
&lt;p&gt;今日において、これらの利点は完全に消滅しており、単なる慣習となっている。&lt;/p&gt;</description>
        </item>
        <item>
        <title>ホストオーダー、ネットワークオーダー。デバッガーで直接観察。</title>
        <link>https://ttf248.life/ja/p/host-order-network-order-debugger-observation/</link>
        <pubDate>Tue, 10 Jan 2023 14:18:12 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/host-order-network-order-debugger-observation/</guid>
        <description>&lt;p&gt;コンピュータの発展史の中で、データをどのように保存するかという統一された基準はありませんでした。&lt;/p&gt;
&lt;p&gt;バイトの配置には、2つの一般的な規則があります。例えば、多桁数の下位を小さいアドレスに、上位を大きいアドレスに配置する場合をリトルエンディアンと呼び、その逆をビッグエンディアンと呼びます。ネットワークアプリケーションでは、異なるマシンタイプが異なる標準のエンディアンを採用する可能性があるため、バイトオーダーは考慮すべき要素であり、すべてネットワーク標準に変換されます。&lt;/p&gt;
&lt;p&gt;読み方の習慣に則して、ビッグエンディアンのバイトオーダーは左から右への読書順に合致する。&lt;/p&gt;
&lt;h2 id=&#34;プロセッサアーキテクチャ&#34;&gt;プロセッサアーキテクチャ
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;x86、MOS Technology 6502、Z80、VAX、PDP-11などのプロセッサはリトルエンディアンです。&lt;/li&gt;
&lt;li&gt;モトローラ6800、モトローラ68000、PowerPC 970などのプロセッサは大Endianです。&lt;/li&gt;
&lt;li&gt;ARM、PowerPC（PowerPC 970を除く）、DEC Alpha、SPARC V9、MIPS、PA-RISCおよびIA64のバイトオーダーは構成可能です。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ネットワークまえがき&#34;&gt;ネットワークまえがき
&lt;/h2&gt;&lt;p&gt;ネットワーク転送では通常、ビッグエンディアンが採用され、ネットワークバイトオーダーまたはネットワーク順とも呼ばれます。IPプロトコルでは、ビッグエンディアンをネットワークバイトオーダーとして定義しています。
バークレーソケットは、ネットワークバイトオーダーとローカルバイトオーダーの間での16ビットおよび32ビット整数の変換を行うための変換関数群を定義しています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;arpa/inet.h&amp;gt;

uint32_t htonl(uint32_t hostlong); //把uint32_t类型从主机序转换到网络序
uint16_t htons(uint16_t hostshort); //把uint16_t类型从主机序转换到网络序
uint32_t ntohl(uint32_t netlong); //把uint32_t类型从网络序转换到主机序
uint16_t ntohs(uint16_t netshort); //把uint16_t类型从网络序转换到主机序
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;もし&lt;code&gt;asio&lt;/code&gt;をネットワークライブラリとして選択した場合、組み込みのネームスペースにはクロスプラットフォーム対応の関数名が存在します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;boost::asio::detail::socket_ops::network_to_host_long&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::network_to_host_short&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::host_to_network_long&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::host_to_network_short&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ビジュアルスタジオ-デバッガー&#34;&gt;ビジュアルスタジオ デバッガー
&lt;/h2&gt;&lt;p&gt;デバッグモードで、デバッグメニューのウィンドウを選択し、メモリウィンドウにチェックを入れます。&lt;/p&gt;
&lt;p&gt;Visual Studio では、デバッガー内でメモリ内のデータを確認できます。以下のような図を参照してください。&lt;/p&gt;
&lt;p&gt;デバッグメニュー&lt;/p&gt;
&lt;h3 id=&#34;メモリの確認方法&#34;&gt;メモリの確認方法
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ウィンドウで変数名を直接出力し、対応する変数のアドレスにジャンプします。&lt;/li&gt;
&lt;li&gt;もし変数が元々ポインタであれば、変数を選択し、メモリウィンドウにドラッグすると、そのアドレスの内容が表示されます。&lt;/li&gt;
&lt;li&gt;もし変数がポインタでない場合、計算ウィンドウに追加し、アドレスを取得後、手動でメモリウィンドウにコピーする。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例えば&#34;&gt;例えば
&lt;/h3&gt;&lt;p&gt;データを受信し、&lt;code&gt;buffer&lt;/code&gt;オブジェクトに格納しました。ネットワークバイト順からホストバイト順に変換し、&lt;code&gt;body_length&lt;/code&gt;を30としました。サーバー側では、このデータを送信するために4バイトが割り当てられています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool NetworkMessage::decode_header()
{
    // 网络序转成主机序
    body_length_ = boost::asio::detail::socket_ops::network_to_host_long(*(int *)buffer_.data());
    return auto_reserve(body_length_);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;ビッグエンディアン：メモリウィンドウで &lt;code&gt;buffer_&lt;/code&gt; の内容を観察する。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/host-order-network-order-debugger-observation/buffer_.png&#34;
	width=&#34;603&#34;
	height=&#34;318&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;buffer_&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;189&#34;
		data-flex-basis=&#34;455px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;リトルエンディアン：メモリウィンドウで &lt;code&gt;body_length_&lt;/code&gt; の内容を確認してください。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/host-order-network-order-debugger-observation/body_length_.png&#34;
	width=&#34;581&#34;
	height=&#34;333&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;body_length_&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;174&#34;
		data-flex-basis=&#34;418px&#34;
	
&gt;&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
