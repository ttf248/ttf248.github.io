<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>ネットワーク通信 on 向叔の手帳</title>
        <link>https://ttf248.life/ja/tags/%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E9%80%9A%E4%BF%A1/</link>
        <description>Recent content in ネットワーク通信 on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Mon, 02 Jun 2025 07:41:32 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/tags/%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E9%80%9A%E4%BF%A1/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>バックエンドサービス TCP 通信異常トラブルシューティング</title>
        <link>https://ttf248.life/ja/p/backend-service-tcp-communication-troubleshooting/</link>
        <pubDate>Fri, 14 Feb 2025 22:54:13 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/backend-service-tcp-communication-troubleshooting/</guid>
        <description>&lt;p&gt;ビジネスモデル：バックエンドサービスがTCPを通じてグループの行情ゲートウェイと接続します。接続ごとに、最初に権限リクエストを送信し、その後継続的にハニーポットパケットを送信して接続状態を維持します。&lt;/p&gt;
&lt;p&gt;しかし、ある日、サービス切断警告の情報を受け取りました。詳細なログ調査の結果、バックエンドサービスが継続的にハニーポットパケットを送信していたにもかかわらず、相手からの応答はなく、接続は依然として切断されませんでした。&lt;/p&gt;
&lt;h2 id=&#34;現場要約&#34;&gt;現場要約
&lt;/h2&gt;&lt;p&gt;原本在会社でプロジェクトの進捗を推進していたところ、業務チャットに警報情報がポップアップされました。初めは、以前からのトラブルだと思っていましたが、おそらくネットワークタイムアウトによって心跳信号が送信に失敗し、サービスが切断されたのだと推測しました。しかし、ログの詳細な調査の結果、実際にはそうではありませんでした。バックエンドから認証ログインメッセージを送信しましたが、応答を受信しませんでした。同時に、心跳パケットは継続的に送信され続けていましたが、相手側からは決して応答がありませんでした。ログの徹底的な分析により、以下の重要な問題が明らかになりました：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;認証メッセージへの応答なし：おそらく相手側のシステムが再起動しており、認証メッセージが適切に処理されていない可能性があります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;認証失敗中に心跳データ送信：調査の結果、これはプログラムロジック上の脆弱性であることが判明しました。 心拍送信関数の判断ロジックに欠陥があり、接続状態のみを検証するだけで、権限状態の検証が抜け落ちていました。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;サービス未断開接続：サービスが断開可能であれば、再接続メカニズムをトリガーして、改めて認証メッセージを送信できます。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;現在、解決すべき最後の課題は、なぜサービスが断開できないのかという点です。この問題の解決には、より詳細かつ綿密な調査が必要です。&lt;/p&gt;
&lt;h2 id=&#34;ネットワークパケットの分析&#34;&gt;ネットワークパケットの分析
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;tcpdump&lt;/code&gt; は非常に強力なネットワークパケットキャプチャツールであり、ネットワークパケットを捕捉するために使用できます。ネットワークパケットを分析することで、通信の詳細をより直感的に理解することができます。ここでは、&lt;code&gt;tcpdump&lt;/code&gt; を使用してネットワークパケットをキャプチャし、さらに分析します。
&lt;img src=&#34;https://ttf248.life/p/backend-service-tcp-communication-troubleshooting/20250220151952.png&#34;
	width=&#34;1126&#34;
	height=&#34;202&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;tcpdump&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;557&#34;
		data-flex-basis=&#34;1337px&#34;
	
&gt;
分析図のデータから、心拍は正常に送信され続けており、相手側のサーバーからはデータが返ってきていませんが、&lt;code&gt;ACK&lt;/code&gt; が送られていたため、接続は積極的に切断されませんでした。&lt;/p&gt;
&lt;h2 id=&#34;共通フラグの説明&#34;&gt;共通フラグの説明
&lt;/h2&gt;&lt;p&gt;TCP プロトコルにおいて、&lt;code&gt;PSH&lt;/code&gt; (Push) と &lt;code&gt;ACK&lt;/code&gt; (Acknowledgment) は重要なフラグであり、それぞれデータ転送の制御とフロー制御に使用されます。その機能は以下のとおりです。&lt;/p&gt;
&lt;h3 id=&#34;1-pshpush-flag&#34;&gt;&lt;strong&gt;1. PSH（Push Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;機能:&lt;/strong&gt;
&lt;code&gt;PSH&lt;/code&gt; フラグは、受信側がバッファ内のデータを上位のアプリケーションに&lt;strong&gt;即時送信するよう要求する&lt;/strong&gt;ものです。（バッファが満杯で待つのではなく）。 つまり、&lt;code&gt;PSH&lt;/code&gt; フラグが付いたデータ段を受信すると、受信側はできるだけ早く処理してアプリケーションに渡すのではなく、バッファー内に一時的に保存することなく送信します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;典型的なシナリオ:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTTP/HTTPS リクエスト:&lt;/strong&gt; クライアントがリクエストを送信する際（例: &lt;code&gt;GET /index.html&lt;/code&gt;）には &lt;code&gt;PSH&lt;/code&gt; が設定され、サーバーから即時の応答を希望します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SSH プロトコル:&lt;/strong&gt; キーボード入力のたびに &lt;code&gt;PSH&lt;/code&gt; がトリガーされ、入力された文字をリアルタイムで送信することを保証します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;リアルタイム通信:&lt;/strong&gt; ビデオストリームやオンラインゲームなど、低遅延が必要なシナリオでは &lt;code&gt;PSH&lt;/code&gt; を使用して遅延を減らすことがあります。 - &lt;strong&gt;注意&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PSH&lt;/code&gt; は必須ではありません。受信側はフラグを無視することもできます（ただし、データは正常に処理する必要があります）。&lt;/li&gt;
&lt;li&gt;送信側が &lt;code&gt;PSH&lt;/code&gt; を設定しない場合、受信側は自身のバッファリングポリシーに基づいてデータの送信タイミングを決定します。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-ackacknowledgment-flag&#34;&gt;&lt;strong&gt;2. ACK（Acknowledgment Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;機能&lt;/strong&gt;: &lt;br&gt;
&lt;code&gt;ACK&lt;/code&gt; 标志位は、&lt;strong&gt;前序データ段が正しく受信されたことを示す&lt;/strong&gt;。各 &lt;code&gt;ACK&lt;/code&gt; には確認番号（&lt;code&gt;Acknowledgment Number&lt;/code&gt;）が含まれており、これは期待される次のバイトのシーケンス番号を表します。TCP の信頼性のある転送の中核メカニズムです。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;動作原理&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;送信側がデータ段を送信する際、期待される受信側の &lt;code&gt;ACK&lt;/code&gt; 値（例えば &lt;code&gt;ACK = シーケンス番号 + データ長&lt;/code&gt;）を付与します。&lt;/li&gt;
&lt;li&gt;受信側がデータを受信すると、受信したデータのシーケンス番号を確認するための &lt;code&gt;ACK&lt;/code&gt; 報文段を生成します。&lt;/li&gt;
&lt;li&gt;送信側は、対応する &lt;code&gt;ACK&lt;/code&gt; を受信するまで、データ再送を行いません。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;例&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;送信側がシリアル番号 &lt;code&gt;100~199&lt;/code&gt; のデータ段を送信した場合、期待される受信側の &lt;code&gt;ACK&lt;/code&gt; は &lt;code&gt;200&lt;/code&gt; になります。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-psh-と-ack-の組み合わせ&#34;&gt;&lt;strong&gt;3. PSH と ACK の組み合わせ&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;TCP 報文において、&lt;code&gt;PSH&lt;/code&gt; (Push) と &lt;code&gt;ACK&lt;/code&gt; (確認応答) は同時に出現することがあり、以下のような状況でよく見られます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTTP リクエスト応答&lt;/strong&gt;：&lt;br&gt;
クライアントが &lt;code&gt;POST&lt;/code&gt; リクエスト（データを含む）を送信する際、&lt;code&gt;PSH&lt;/code&gt; と &lt;code&gt;ACK&lt;/code&gt; を設定し、前の応答の確認を行います。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SSH ハンドシェイク後のコマンド転送&lt;/strong&gt;：&lt;br&gt;
クライアントがコマンドを入力した後、&lt;code&gt;PSH&lt;/code&gt; と &lt;code&gt;ACK&lt;/code&gt; が付いたデータ段を送信することで、コマンドが即座にサーバーで処理されるようにします。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-その他の関連を示すフラグ&#34;&gt;&lt;strong&gt;4. その他の関連を示すフラグ&lt;/strong&gt;
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;フラグ&lt;/th&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;概要&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SYN&lt;/td&gt;
&lt;td&gt;シーケンス&lt;/td&gt;
&lt;td&gt;接続の初期化 (3ウェイハンドシェイク)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;4-その他の重要な関連&#34;&gt;&lt;strong&gt;4. その他の重要な関連&lt;/strong&gt;
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;標識&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;概要&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;FIN&lt;/td&gt;
&lt;td&gt;終了&lt;/td&gt;
&lt;td&gt;エレガントな接続のクローズ&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;4-その他の関連を示すフラグ-1&#34;&gt;&lt;strong&gt;4. その他の関連を示すフラグ&lt;/strong&gt;
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;フラグ&lt;/th&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;概要&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;RST&lt;/td&gt;
&lt;td&gt;リセット&lt;/td&gt;
&lt;td&gt;接続の強制終了 (異常状況)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;4-その他の重要な関連-1&#34;&gt;&lt;strong&gt;4. その他の重要な関連&lt;/strong&gt;
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;標識&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;概要&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;URG&lt;/td&gt;
&lt;td&gt;緊急&lt;/td&gt;
&lt;td&gt;緊急ポインタのマーク (ほとんど使用されない)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;4-その他の関連要素&#34;&gt;&lt;strong&gt;4. その他の関連要素&lt;/strong&gt;
&lt;/h3&gt;&lt;h3 id=&#34;まとめ&#34;&gt;&lt;strong&gt;まとめ&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;PSH&lt;/strong&gt; は、&lt;strong&gt;データのアプリケーション層への迅速な到達&lt;/strong&gt; と低遅延に焦点を当てています。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ACK&lt;/strong&gt; は、&lt;strong&gt;データの信頼性の高い伝送&lt;/strong&gt; を重視し、パケットロスや乱数（乱順）を防ぎます。
両者は連携して、TCP プロトコルの効率性と信頼性をバランスさせます。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
