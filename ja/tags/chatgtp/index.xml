<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Chatgtp on 向叔の手帳</title>
        <link>https://blog.ttf248.life/ja/tags/chatgtp/</link>
        <description>Recent content in Chatgtp on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Wed, 28 May 2025 09:47:38 +0800</lastBuildDate><atom:link href="https://blog.ttf248.life/ja/tags/chatgtp/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>プロンプトエンジニア</title>
        <link>https://blog.ttf248.life/ja/p/prompt-engineer/</link>
        <pubDate>Sun, 26 Mar 2023 20:46:53 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ja/p/prompt-engineer/</guid>
        <description>&lt;p&gt;まるで昔に検索エンジンのテクニックを学ぶように、私たちも&lt;code&gt;AI&lt;/code&gt;とのコミュニケーションのコツを学び、合理的かつ十分な条件を設定し、必要な答えを効率的に得る必要がある。&lt;/p&gt;
&lt;p&gt;もし別の視点から考えてみたら、現在の強調表示は期待通りの結果を生むでしょう。&lt;/p&gt;
&lt;h2 id=&#34;科学解説&#34;&gt;科学解説
&lt;/h2&gt;&lt;p&gt;火出天际的&lt;code&gt;AI&lt;/code&gt;BOLD_2&lt;code&gt;Generative Pre-Training&lt;/code&gt;とは、直訳すると生成事前学習です。これは、インターネットで利用可能なデータで訓練されたテキスト生成深層学習モデルであり、質問応答、テキスト要約の生成、機械翻訳、分類、コード生成、対話AIなどのタスクに使用されます。現在ではGPT-1、GPT-2、GPT-3、GPT-4など、さまざまなバージョンのモデルが存在し、各バージョンは前のバージョンよりも大きく、強力です。&lt;/p&gt;
&lt;h2 id=&#34;結局知能は存在するのか&#34;&gt;結局、知能は存在するのか。
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;類似度が十分高いほど、精度も上がる。&lt;/li&gt;
&lt;li&gt;基本的な、反復作業は、特定の訓練を経れば、これ以上の人的介入は不要となる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;生成AIとは、既存のテキスト、音声、画像などのデータを利用して新しいコンテンツを生成する技術です。テキスト生成、音声合成、画像生成、対話システムなど、様々なタスクに利用できます。生成AIの論理性は、学習データとモデル構造に依存します。一般的に、生成AIは文法、論理、常識をある程度遵守できますが、誤りや偏見、虚偽の内容を生み出す可能性もあります。そのため、生成AIの出力には人間の判断と検証が必要であり、盲目的に信じたり使用したりすることはできません。&lt;/p&gt;
&lt;h2 id=&#34;プロンプトエンジニア&#34;&gt;プロンプトエンジニア
&lt;/h2&gt;&lt;p&gt;時間が流れ去ることはないから、人は時代の流れに適応する必要がある。あなたはそれを__INLINE_CODE_0__を非論理的だと考えられるかもしれないし、役に立たないコードを生成することがよくある。&lt;/p&gt;
&lt;p&gt;もし別の視点から考えてみたら、現在の強調表示は期待通りの結果を生むでしょう。&lt;/p&gt;
&lt;h2 id=&#34;会話モード&#34;&gt;会話モード
&lt;/h2&gt;&lt;p&gt;2年前に、大胆に登場し、人類は大規模言語モデルの能力を認識した。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于注释的编程&lt;/strong&gt;と&lt;strong&gt;基于对话的编程&lt;/strong&gt;に基づき、インタラクションの論理は完全に異なり、会話のパターンも、初心者ユーザーにとって使いやすい体験を提供します。ここに必ず&lt;code&gt;NewBing&lt;/code&gt;在每个问题之后，给出的追问提示，微软在尝试引导用户，获取&lt;code&gt;AI&lt;/code&gt;知識ベース内の、より多くのコンテンツについて言及する必要があります。&lt;/p&gt;
&lt;h2 id=&#34;例えば&#34;&gt;例えば
&lt;/h2&gt;&lt;p&gt;高速鉄道の移動時間は長く、コーディングは良い選択だ。データ通信量が限られているので、画像を数枚処理し、画像素材を入手したが、ソフトウェアをダウンロードして画像を処理するのは少し贅沢すぎるし、ネットワーク環境もそれを許さない。&lt;/p&gt;
&lt;p&gt;画像素材がいくつかあり、それらは透明な背景の画像で、ミニプログラムのナビゲーションバーに使用されます。選択された状態はカラー、未選択の状態は白黒です。素材自体はカラーなので、前処理が必要です。&lt;/p&gt;
&lt;p&gt;フォルダ内のすべての画像を読み込み、モノクロに変換し、透明な背景を維持した上で、品質を最適化してファイルサイズを縮小した画像を保存するPythonコードを作成してください。また、コンソールには変換前のファイルサイズと変換後のファイルサイズの比較を表示してください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 导入必要的库
import os
import PIL
from PIL import Image

# 定义一个函数，将图片转换成黑白，维持透明背景，保存图片，并返回文件体积
def convert_and_save(image_file):
    # 打开图片
    image = Image.open(image_file)
    # 获取图片的模式，如果是 RGBA 模式，说明有透明背景
    mode = image.mode
    if mode == &amp;quot;RGBA&amp;quot;:
        # 创建一个和图片大小一致的白色背景图片
        background = Image.new(&amp;quot;RGB&amp;quot;, image.size, (255, 255, 255))
        # 将原图片粘贴到白色背景上，忽略透明像素
        background.paste(image, mask=image.split()[3])
        # 将合成的图片转换成灰度模式
        gray_image = background.convert(&amp;quot;L&amp;quot;)
        # 将灰度图片再转换成 RGBA 模式，以便保留透明背景
        final_image = gray_image.convert(&amp;quot;RGBA&amp;quot;)
    else:
        # 如果不是 RGBA 模式，直接将图片转换成灰度模式
        final_image = image.convert(&amp;quot;L&amp;quot;)
    # 获取原图片的文件名和扩展名
    file_name, file_ext = os.path.splitext(image_file)
    # 定义新图片的文件名，添加 _bw 后缀表示黑白
    new_file_name = file_name + &amp;quot;_bw&amp;quot; + file_ext
    # 保存新图片，并优化质量，减少文件体积
    final_image.save(new_file_name, optimize=True)
    # 获取原图片和新图片的文件体积，并返回
    old_size = os.path.getsize(image_file)
    new_size = os.path.getsize(new_file_name)
    return old_size, new_size

# 定义一个文件夹路径，存放所有的图片
folder_path = &amp;quot;images&amp;quot;
# 遍历文件夹中的所有文件
for file in os.listdir(folder_path):
    # 拼接完整的文件路径
    file_path = os.path.join(folder_path, file)
    # 判断是否是图片文件，根据扩展名判断，可以根据需要添加或修改扩展名
    if file_path.endswith((&amp;quot;.png&amp;quot;, &amp;quot;.jpg&amp;quot;, &amp;quot;.jpeg&amp;quot;, &amp;quot;.gif&amp;quot;)):
        # 调用函数，转换并保存图片，并获取文件体积
        old_size, new_size = convert_and_save(file_path)
        # 在控制台展示优化前后的文件体积大小对比
        print(f&amp;quot;{file}: {old_size} bytes -&amp;gt; {new_size} bytes&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;すぐに回答しましたが、見た目は良く、問題なく動作します。経験豊富なプログラマーなら、下記のコードが汎用的ではなく、本番環境には向かないと感じるでしょう。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;パラメータが固定されました。&lt;/li&gt;
&lt;li&gt;ログファイルはなく、情報はコンソールに出力されています。&lt;/li&gt;
&lt;li&gt;画像処理のタスクは、マルチスレッドモデルに適しています。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このコードの改善点はありますか？&lt;/p&gt;
&lt;p&gt;今回提示された回答は、正直言って期待を遥かに上回っています。一般的なプログラマーが思いつくような最適化策についても、それぞれ対応する提案が示されています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;这段代码可能还有一些可以改进的地方，比如：

可以使用 argparse 库，让用户可以通过命令行参数指定文件夹路径和扩展名，而不是写死在代码里。
可以使用 logging 库，记录程序的运行情况，而不是直接打印到控制台。
可以使用 try-except 语句，捕获可能出现的异常，比如文件打开失败，图片转换失败等，并做相应的处理。
可以使用 multiprocessing 库，利用多核处理器，加速图片的转换和保存过程。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非常にフレンドリーな対応で、デプロイ環境の違いを考慮し、マルチプロセス非対応を許可しています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;当然，我很乐意帮你修改一下代码。我尝试添加了 argparse, logging 和 try-except 语句，但没有添加 multiprocessing 库，因为我不确定你的电脑是否支持多核处理。修改后的代码如下：
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 导入必要的库
import argparse
import logging
import multiprocessing
import os

from PIL import Image


# 定义一个函数，将图片转换成黑白，维持透明背景，保存图片，并返回文件体积
def convert_and_save(image_file):
    # 打开图片
    try:
        image = Image.open(image_file)
    except Exception as e:
        logging.error(f&amp;quot;Failed to open {image_file}: {e}&amp;quot;)
        return None, None
    # 获取图片的模式，如果是 RGBA 模式，说明有透明背景
    mode = image.mode
    if mode == &amp;quot;RGBA&amp;quot;:
        # 创建一个和图片大小一致的白色背景图片
        background = Image.new(&amp;quot;RGB&amp;quot;, image.size, (255, 255, 255))
        # 将原图片粘贴到白色背景上，忽略透明像素
        background.paste(image, mask=image.split()[3])
        # 将合成的图片转换成灰度模式
        gray_image = background.convert(&amp;quot;L&amp;quot;)
        # 将灰度图片再转换成 RGBA 模式，以便保留透明背景
        final_image = gray_image.convert(&amp;quot;RGBA&amp;quot;)
    else:
        # 如果不是 RGBA 模式，直接将图片转换成灰度模式
        final_image = image.convert(&amp;quot;L&amp;quot;)
    # 获取原图片的文件名和扩展名
    file_name, file_ext = os.path.splitext(image_file)
    # 定义新图片的文件名，添加 _bw 后缀表示黑白
    new_file_name = file_name + &amp;quot;_bw&amp;quot; + file_ext
    # 保存新图片，并优化质量，减少文件体积
    try:
        final_image.save(new_file_name, optimize=True)
    except Exception as e:
        logging.error(f&amp;quot;Failed to save {new_file_name}: {e}&amp;quot;)
        return None, None
    # 获取原图片和新图片的文件体积，并返回
    old_size = os.path.getsize(image_file)
    new_size = os.path.getsize(new_file_name)
    return file_name, old_size, new_size

# 定义一个函数，解析命令行参数，并返回文件夹路径和扩展名列表
def parse_args():
    # 创建一个解析器对象
    parser = argparse.ArgumentParser(description=&amp;quot;Convert images to black and white and optimize quality.&amp;quot;)
    # 添加一个必选的位置参数，表示文件夹路径
    parser.add_argument(&amp;quot;folder_path&amp;quot;, help=&amp;quot;The path of the folder that contains the images.&amp;quot;)
    # 添加一个可选的参数，表示扩展名列表，默认为 png, jpg, jpeg 和 gif
    parser.add_argument(&amp;quot;-e&amp;quot;, &amp;quot;--extensions&amp;quot;, nargs=&amp;quot;+&amp;quot;, default=[&amp;quot;.png&amp;quot;, &amp;quot;.jpg&amp;quot;, &amp;quot;.jpeg&amp;quot;, &amp;quot;.gif&amp;quot;], help=&amp;quot;The extensions of the image files.&amp;quot;)
    # 解析命令行参数，并返回结果对象
    args = parser.parse_args()
    return args.folder_path, args.extensions

# 定义一个函数，打印优化前后的文件体积大小对比
def print_result(result):
    # 如果结果不为空，说明转换和保存成功
    if result:
        # 解包结果为文件名和文件体积元组
        if len(result) == 3:
            file, old_size, new_size = result
            # 在控制台展示优化前后的文件体积大小对比
            logging.info(f&amp;quot;{file}: {old_size} bytes -&amp;gt; {new_size} bytes&amp;quot;)
        else:
            logging.info(f&amp;quot;{result}&amp;quot;)

# 配置日志记录器，将日志输出到控制台和文件中，设置日志等级为 INFO
logging.basicConfig(level=logging.INFO,
                    format=&amp;quot;%(asctime)s %(levelname)s %(message)s&amp;quot;,
                    handlers=[logging.StreamHandler(),
                              logging.FileHandler(&amp;quot;log.txt&amp;quot;)])

# 调用函数，获取文件夹路径和扩展名列表
folder_path, extensions = parse_args()

if __name__ == &amp;quot;__main__&amp;quot;:
    # Windows 需要这个函数的原因是 Windows 缺乏 fork() 函数（这不完全正确）。
    # 因此，在 Windows 上，fork() 是通过创建一个新的进程来模拟的，这个新的进程中运行的代码，在 Linux 上是在子进程中运行的。
    # 由于这些代码要在技术上无关的进程中运行，所以它必须在运行之前被传递到那里。
    # 传递的方式是先将它们序列化，然后通过管道从原始进程发送到新的进程。
    # 另外，这个新的进程被通知它必须运行通过管道传递的代码，通过向它传递 --multiprocessing-fork 命令行参数。
    # 如果你看一下 freeze_support() 函数的实现，它的任务是检查它运行在哪个进程中，是否应该运行通过管道传递的代码
    multiprocessing.freeze_support()

    # 创建一个进程池，根据电脑的核心数自动分配进程
    pool = multiprocessing.Pool()
    # 创建一个空列表，用于存放异步任务的结果对象
    results = []
    # 遍历文件夹中的所有文件
    for file in os.listdir(folder_path):
        # 拼接完整的文件路径
        file_path = os.path.join(folder_path, file)
        # 判断是否是图片文件，根据扩展名判断，可以根据需要修改扩展名列表
        if any(file_path.endswith(ext) for ext in extensions):
            # 调用函数，转换并保存图片，并获取文件体积，使用异步方式，不阻塞主进程
            result = pool.apply_async(convert_and_save, args=(file_path,), callback=print_result)
            # 将结果对象添加到列表中
            results.append((file, result))
    # 关闭进程池，不再接受新的任务
    pool.close()
    # 等待所有的任务完成
    pool.join()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;追記&#34;&gt;追記
&lt;/h2&gt;&lt;p&gt;ローカル開発で__BOLD_4&lt;code&gt;windows&lt;/code&gt;第一次给出的答案，并没有加上&lt;code&gt;AI&lt;/code&gt;BOLD_6&lt;code&gt;main&lt;/code&gt;第一次给出的答案，并没有加上&lt;code&gt;multiprocessing.freeze_support&lt;/code&gt;が発生し、エラー追跡によりコードを修正しました。&lt;/p&gt;
&lt;p&gt;まるで昔に検索エンジンのテクニックを学ぶように、私たちも__INLINE_CODE_0__とのコミュニケーションのコツを学び、合理的かつ十分な条件を設定し、必要な答えを効率的に得る必要がある。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
