<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Chatgtp on 向叔の手帳</title>
        <link>https://ttf248.life/ja/tags/chatgtp/</link>
        <description>Recent content in Chatgtp on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Mon, 02 Jun 2025 19:00:25 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/tags/chatgtp/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>プロンプトエンジニア</title>
        <link>https://ttf248.life/ja/p/prompt-engineer/</link>
        <pubDate>Sun, 26 Mar 2023 20:46:53 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/prompt-engineer/</guid>
        <description>&lt;p&gt;例として、かつて検索エンジンのテクニックを学んだように、私たちはまた &lt;code&gt;AI&lt;/code&gt; とコミュニケーションするためのテクニックも習得する必要がある。合理的な制約条件を与え、効率的に必要な答えを得る方法を学ぶのだ。&lt;/p&gt;
&lt;p&gt;もし角度を変えて考えると、現在の &lt;code&gt;AI&lt;/code&gt; は記憶力に優れた小さな子供であり、完璧に暗記し、宿題をコピーできる能力を持っている。私たちがやるべきことは、&lt;code&gt;AI&lt;/code&gt; と正確かつ効果的にコミュニケーションする方法を学び、要求を正確に記述し、&lt;code&gt;AI&lt;/code&gt; が期待される結果を生み出すのを助けることだ。&lt;/p&gt;
&lt;h2 id=&#34;科学普及&#34;&gt;科学普及
&lt;/h2&gt;&lt;p&gt;話題となっている&lt;code&gt;AI&lt;/code&gt;（人工知能）を具体的に言うと&lt;code&gt;Generative Pre-Training&lt;/code&gt;（生成事前学習）です。これは、インターネットで利用可能なデータを用いて訓練されたテキスト生成のための深層学習モデルであり、質問応答、テキスト要約生成、機械翻訳、分類、コード生成、対話型AIなど様々なタスクに使用されます。現在、GPT-1、GPT-2、GPT-3、GPT-4といった異なるバージョンのモデルが存在し、それぞれが前バージョンよりも規模が大きく、性能も向上しています。&lt;/p&gt;
&lt;h2 id=&#34;到底有没有智能&#34;&gt;到底有没有智能
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;類似度が高ければ高いほど、精度も高くなる&lt;/li&gt;
&lt;li&gt;基本的な、反復性の仕事は、特定の訓練を受けることで、人工の介入が不要になる
生成式AIとは、既存のテキスト、音声、画像などのデータを活用して新しいコンテンツを作成する技術である。テキスト生成、音声合成、画像生成、対話システムなど、様々なタスクに使用できる。生成式AIの論理性は、その学習データとモデル構造に依存する。一般的に、生成式AIは一定程度、文法、論理、常識に従うことができるが、誤りや偏見、または不真実を含むコンテンツを生成することもある。そのため、生成式AIの出力は人間の判断と検証が必要であり、盲目的に信頼したり使用したりすることはできない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;プロンプトエンジニア&#34;&gt;プロンプトエンジニア
&lt;/h2&gt;&lt;p&gt;時間は流れようと逆らえない。人は潮流に適応することを学ぶ必要がある。AIを無駄なものだと考え、論理性がないと考えてしまうことがあるだろう。実際には、現在のAIは記憶力に優れた幼い子供であり、丸わかり能力、つまりコピー能力を持っている。私たちがやるべきことは、AIとどのように正しく、効果的に、そしてうまくコミュニケーションをとるか、正確な要求を記述し、AIが期待される結果を生み出すのを助けることだ。&lt;/p&gt;
&lt;h2 id=&#34;対話モデル&#34;&gt;対話モデル
&lt;/h2&gt;&lt;p&gt;2年前、GitHub Copilotの発表は誰も予想していませんでした。その結果、OpenAIが横空に出現し、人類は大規模言語モデルの能力を認識するに至りました。&lt;/p&gt;
&lt;p&gt;コメントベースのプログラミングと対話ベースのプログラミングというインターフェースの違いにより、インタラクティブなロジックは完全に異なり、対話モデルは初心者ユーザーにとって親しみやすいインタラクション体験を提供します。ここでNewBingが各質問の後に提示するフォローアップのヒントを必ず言及する必要があります。Microsoftは、AI知識ベースからより多くのコンテンツを取得するために、ユーザーに誘導しようと試みています。&lt;/p&gt;
&lt;h2 id=&#34;例え話&#34;&gt;例え話
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;シナリオ:&lt;/strong&gt; 高速鉄道の旅は長く、コーディングは良い選択肢です。データ容量が限られている場合、いくつかの画像を処理し、画像素材を入手しました。ソフトウェアで画像を処理するのは少し贅沢で、ネットワーク条件も許容されていません。
&lt;strong&gt;要件:&lt;/strong&gt; 画像素材のコレクションがあり、透明背景付きで、小アプリのナビゲーションバーで使用します。選択された状態はカラフルで、未選択の状態は白黒です。素材はすべてカラフルであり、事前に処理する必要があります。
&lt;strong&gt;プロンプト:&lt;/strong&gt; Pythonコードを記述して、フォルダからすべての画像を読み取り、画像を白黒に変換し、透明背景を維持し、画像を保存するときに画像の品質を最適化し、ファイルサイズを削減し、同時にコンソールで表示し、前後のファイルサイズの比較を行います。&lt;/p&gt;
&lt;h2 id=&#34;例を挙げる&#34;&gt;例を挙げる
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 必要なライブラリをインポートする
import os
import PIL
from PIL import Image
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;例え話-1&#34;&gt;例え話
&lt;/h2&gt;&lt;h1 id=&#34;画像を白黒に変換し透明背景を維持し画像を保存しファイルサイズを返す関数を定義します&#34;&gt;画像を白黒に変換し、透明背景を維持し、画像を保存し、ファイルサイズを返す関数を定義します。
&lt;/h1&gt;&lt;p&gt;def convert_and_save(image_file):
# 画像を開く
image = Image.open(image_file)
# 画像のモードを取得し、RGBA モードの場合、透明背景があることを意味する
mode = image.mode
if mode == &amp;ldquo;RGBA&amp;rdquo;:
# 画像と同じサイズの白い背景画像を作成する
background = Image.new(&amp;ldquo;RGB&amp;rdquo;, image.size, (255, 255, 255))
# 元の画像を白い背景に貼り付け、透明ピクセルを無視する
background.paste(image, mask=image.split()[3])
# 合成された画像をグレースケールモードに変換する
gray_image = background.convert(&amp;ldquo;L&amp;rdquo;)
# グレースケール画像をRGBAモードに戻し、透明背景を保持する&lt;/p&gt;
&lt;h2 id=&#34;例えを挙げる&#34;&gt;例えを挙げる
&lt;/h2&gt;&lt;p&gt;gray_image = background.convert(&amp;ldquo;L&amp;rdquo;)
# 背景画像をグレースケールに変換し、透明背景を保持するためにRGBAモードに変換する
final_image = gray_image.convert(&amp;ldquo;RGBA&amp;rdquo;)
else:
# RGBAモードでない場合は、直接画像をグレースケールに変換する
final_image = image.convert(&amp;ldquo;L&amp;rdquo;)
# 元の画像のファイル名と拡張子を取得する
file_name, file_ext = os.path.splitext(image_file)
# 新しい画像のファイル名を定義し、&amp;quot;_bw&amp;quot;サフィックスを追加して白黒であることを示す
new_file_name = file_name + &amp;ldquo;_bw&amp;rdquo; + file_ext
# 新しい画像を保存し、品質を最適化してファイルサイズを削減する
final_image.save(new_file_name, optimize=True)
# 元の画像と新しい画像のファイルサイズを取得し、返す&lt;/p&gt;
&lt;h2 id=&#34;例を挙げる例を示す&#34;&gt;例を挙げる（例を示す）
&lt;/h2&gt;&lt;h1 id=&#34;新しい画像を保存し品質を最適化してファイルサイズを削減する&#34;&gt;新しい画像を保存し、品質を最適化してファイルサイズを削減する
&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;final_image.save(new_file_name, optimize=True)
# 元の画像と新しい画像のファイルサイズを取得し、返す
old_size = os.path.getsize(image_file)
new_size = os.path.getsize(new_file_name)
return old_size, new_size
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;例え話-2&#34;&gt;例え話
&lt;/h2&gt;&lt;h1 id=&#34;画像を保存するすべてのフォルダのパスを定義します&#34;&gt;画像を保存するすべてのフォルダのパスを定義します。
&lt;/h1&gt;&lt;p&gt;folder_path = &amp;ldquo;images&amp;rdquo;&lt;/p&gt;
&lt;h1 id=&#34;フォルダ内のすべてのファイルを確認します&#34;&gt;フォルダ内のすべてのファイルを確認します。
&lt;/h1&gt;&lt;p&gt;for file in os.listdir(folder_path):
# ファイルへの完全なパスを結合します。
file_path = os.path.join(folder_path, file)
# 画像ファイルの拡張子に基づいて、画像ファイルを判断します（必要に応じて拡張子を追加または変更できます）。
if file_path.endswith((&amp;quot;.png&amp;quot;, &amp;ldquo;.jpg&amp;rdquo;, &amp;ldquo;.jpeg&amp;rdquo;, &amp;ldquo;.gif&amp;rdquo;)):
# 画像を変換して保存し、ファイルサイズを取得する関数を呼び出します。
old_size, new_size = convert_and_save(file_path)
# 変換前のファイルと変換後のファイルサイズの比較をコンソールに出力します。
print(f&amp;quot;{file}: {old_size} bytes -&amp;gt; {new_size} bytes&amp;quot;)&lt;/p&gt;
&lt;h2 id=&#34;例え話-3&#34;&gt;例え話
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;AI&lt;/code&gt;は迅速に答えを提示し、見た目も美しく、使い勝手も問題ありませんでした。経験豊富なプログラムソースとしては、以下のコードが汎用性に欠け、本番環境へのデプロイも困難だと感じました：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;パラメータが固定されている&lt;/li&gt;
&lt;li&gt;ログファイルがなく、すべての情報がコンソールに出力されている&lt;/li&gt;
&lt;li&gt;画像処理タスクにはマルチスレッドモデルが適している&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;NewBing&lt;/code&gt;が登場し、プロンプトに基づいて問題を選択しました：「&lt;strong&gt;このコードの改善点はありますか？&lt;/strong&gt;」&lt;/p&gt;
&lt;p&gt;今回提示された回答は、正直に言って、予想を大幅に上回るものでした。一般的なプログラマが思いつくような最適化策を&lt;code&gt;AI&lt;/code&gt;が提案しました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;このコードには、以下のような改善点がある可能性があります：

`argparse`ライブラリを使用して、コマンドライン引数からフォルダーパスと拡張子を指定できるようにすることで、コードにハードコーディングされたままでは無くなります。 ログ記録ライブラリを使用し、プログラムの実行状況をコンソールへの直接出力ではなく記録することが可能です。
try-except文を使用して、ファイルオープン失敗や画像変換失敗などの例外を捕捉し、適切な処理を行うことができます。
multiprocessingライブラリを使用して、複数のCPUコアを活用することで、画像の変換と保存プロセスを高速化できます。

（環境の違いを考慮し、マルチプロセッシングのサポートがない場合に備えて記述されています。）

## 例を挙げてみましょう

```shell
もちろん、コードの修正をお手伝いさせていただきます。argparse、logging、try-except文を追加しましたが、マルチプロセッシングライブラリは、あなたのコンピュータがマルチコア処理に対応しているかどうか不明なため追加していません。修正後のコードは以下のとおりです：
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;例を挙げる-1&#34;&gt;例を挙げる
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 必要なライブラリのインポート
import argparse
import logging
import multiprocessing
import os

from PIL import Image
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;例え話-4&#34;&gt;例え話
&lt;/h2&gt;&lt;h1 id=&#34;画像を白黒に変換し透明背景を維持し画像を保存しファイルサイズを返す関数を定義します-1&#34;&gt;画像を白黒に変換し、透明背景を維持し、画像を保存し、ファイルサイズを返す関数を定義します。
&lt;/h1&gt;&lt;p&gt;def convert_and_save(image_file):
# 画像を開く
try:
image = Image.open(image_file)
except Exception as e:
logging.error(f&amp;quot;&amp;rsquo;{image_file}&amp;rsquo; のオープンに失敗しました：{e}&amp;quot;)
return None, None
# 画像のモードを取得し、RGBA モードの場合、透明背景があることを意味します。
mode = image.mode
if mode == &amp;ldquo;RGBA&amp;rdquo;:
# 画像と同じサイズの白い背景画像を作成します。
background = Image.new(&amp;ldquo;RGB&amp;rdquo;, image.size, (255, 255, 255))
# 元の画像を白い背景に貼り付け、透明ピクセルを無視します。
background.paste(image, mask=image.split()[3])&lt;/p&gt;
&lt;h2 id=&#34;例えを挙げる-1&#34;&gt;例えを挙げる
&lt;/h2&gt;&lt;h1 id=&#34;元の画像を白色背景に貼り付け透明ピクセルを無視する&#34;&gt;元の画像を白色背景に貼り付け、透明ピクセルを無視する
&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;    background.paste(image, mask=image.split()[3])
    # 合成された画像にグレースケールモードに変換する
    gray_image = background.convert(&amp;quot;L&amp;quot;)
    # グレースケール画像をRGBAモードに戻し、透明背景を保持する
    final_image = gray_image.convert(&amp;quot;RGBA&amp;quot;)
else:
    # RGBA モードでない場合は、直接画像にグレースケールモードで変換する
    final_image = image.convert(&amp;quot;L&amp;quot;)
# 元の画像のファイル名と拡張子を取得する
file_name, file_ext = os.path.splitext(image_file)
# 新しい画像のファイル名を定義し、_bw サフィックスを追加してモノクロであることを示す
new_file_name = file_name + &amp;quot;_bw&amp;quot; + file_ext
# 新しい画像を保存し、品質を最適化してファイルサイズを削減する
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;例を挙げる-2&#34;&gt;例を挙げる
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;new_file_name = file_name + &amp;quot;_bw&amp;quot; + file_ext
    # 新しい画像を保存し、品質を最適化してファイルサイズを削減する
    try:
        final_image.save(new_file_name, optimize=True)
    except Exception as e:
        logging.error(f&amp;quot; {new_file_name} の保存に失敗しました：{e}&amp;quot;)
        return None, None
    # 元の画像と新しい画像のファイルサイズを取得し、返す
    old_size = os.path.getsize(image_file)
    new_size = os.path.getsize(new_file_name)
    return file_name, old_size, new_size
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;例を挙げる例を示す-1&#34;&gt;例を挙げる（例を示す）
&lt;/h2&gt;&lt;h1 id=&#34;コマンドライン引数を解析しフォルダパスと拡張子リストを返す関数を定義する&#34;&gt;コマンドライン引数を解析し、フォルダパスと拡張子リストを返す関数を定義する
&lt;/h1&gt;&lt;p&gt;def parse_args():
# パーサーオブジェクトを作成する
parser = argparse.ArgumentParser(description=&amp;ldquo;画像を白黒に変換し、品質を最適化する。&amp;rdquo;)
# 必須の位置引数として、フォルダパスを追加する
parser.add_argument(&amp;ldquo;folder_path&amp;rdquo;, help=&amp;ldquo;画像が含まれるフォルダのパス。&amp;rdquo;)
# オプションの引数として、拡張子リストを追加する（デフォルトは png, jpg, jpeg, gif）
parser.add_argument(&amp;quot;-e&amp;quot;, &amp;ldquo;&amp;ndash;extensions&amp;rdquo;, nargs=&amp;quot;+&amp;quot;, default=[&amp;quot;.png&amp;quot;, &amp;ldquo;.jpg&amp;rdquo;, &amp;ldquo;.jpeg&amp;rdquo;, &amp;ldquo;.gif&amp;rdquo;], help=&amp;ldquo;画像ファイルの拡張子。&amp;rdquo;)
# コマンドライン引数を解析し、結果オブジェクトを返す&lt;/p&gt;
&lt;h2 id=&#34;例を挙げる-3&#34;&gt;例を挙げる
&lt;/h2&gt;&lt;h1 id=&#34;コマンドライン引数を解析し結果オブジェクトを返す&#34;&gt;コマンドライン引数を解析し、結果オブジェクトを返す
&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;args = parser.parse_args()
return args.folder_path, args.extensions
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;例を挙げる-4&#34;&gt;例を挙げる
&lt;/h2&gt;&lt;h1 id=&#34;実行前に後のファイルサイズと実行後にファイルサイズを比較する関数を定義します&#34;&gt;実行前に後のファイルサイズと実行後にファイルサイズを比較する関数を定義します。
&lt;/h1&gt;&lt;p&gt;def print_result(result):
# 結果が空でない場合、変換と保存が成功したことを意味します。
if result:
# 結果をファイル名とファイルサイズのタプルにアンパックします。
if len(result) == 3:
file, old_size, new_size = result
# コンソールで最適化前のファイルサイズと実行後のファイルサイズを比較を表示します。
logging.info(f&amp;quot;{file}: {old_size} bytes -&amp;gt; {new_size} bytes&amp;quot;)
else:
logging.info(f&amp;quot;{result}&amp;quot;)&lt;/p&gt;
&lt;h2 id=&#34;例を挙げる-5&#34;&gt;例を挙げる
&lt;/h2&gt;&lt;h1 id=&#34;ロギングモジュールを設定しログをコンソールとファイルに出力しログレベルをinfoに設定する&#34;&gt;ロギングモジュールを設定し、ログをコンソールとファイルに出力し、ログレベルをINFOに設定する。
&lt;/h1&gt;&lt;p&gt;logging.basicConfig(level=logging.INFO,
format=&amp;quot;%(asctime)s %(levelname)s %(message)s&amp;quot;,
handlers=[logging.StreamHandler(),
logging.FileHandler(&amp;ldquo;log.txt&amp;rdquo;)])&lt;/p&gt;
&lt;h1 id=&#34;関数を呼び出してフォルダパスと拡張子リストを取得する&#34;&gt;関数を呼び出して、フォルダパスと拡張子リストを取得する。
&lt;/h1&gt;&lt;p&gt;folder_path, extensions = parse_args()&lt;/p&gt;
&lt;h2 id=&#34;例え話-5&#34;&gt;例え話
&lt;/h2&gt;&lt;h1 id=&#34;関数を呼び出してフォルダパスと拡張子のリストを取得する&#34;&gt;関数を呼び出して、フォルダパスと拡張子のリストを取得する
&lt;/h1&gt;&lt;p&gt;folder_path, extensions = parse_args()&lt;/p&gt;
&lt;p&gt;if &lt;strong&gt;name&lt;/strong&gt; == &amp;ldquo;&lt;strong&gt;main&lt;/strong&gt;&amp;rdquo;:
# Windows でこの関数が必要な理由は、Windows には fork() 関数がないため (これは完全に正確ではありません)。
# したがって、Windows では、fork() は新しいプロセスを作成することでシミュレートされます。
# この新しいプロセスで実行されるコードは、Linux 上では子プロセスで実行されるものです。
# これらのコードが技術的に無関係なプロセスで実行されるため、実行前にそこに渡す必要があります。
# その方法は、まずそれらをシリアライズし、元のプロセスからパイプを介して新しいプロセスに送信することです。
# また、この新しいプロセスはパイプを介して送信されたコードを実行するように通知され、&amp;ndash;multiprocessing-fork コマンドラインパラメータを渡すことで行われます。&lt;/p&gt;
&lt;h2 id=&#34;例えのために&#34;&gt;例えのために
&lt;/h2&gt;&lt;h1 id=&#34;複数のプロセスプールを作成しpcのコア数に基づいてプロセスを自動的に割り当てる&#34;&gt;複数のプロセスプールを作成し、PCのコア数に基づいてプロセスを自動的に割り当てる
&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;pool = multiprocessing.Pool()
# 空のリストを作成し、非同期タスクの結果オブジェクトを格納する
results = []
# フォルダー内のすべてのファイルに対して反復処理を行う
for file in os.listdir(folder_path):
    # ファイルパスを結合する
    file_path = os.path.join(folder_path, file)
    # 画像ファイルの拡張子を確認し、必要に応じて拡張子リストを変更する
    if any(file_path.endswith(ext) for ext in extensions):
        # 関数を呼び出して画像を変換および保存し、ファイルサイズを取得する。非同期モードで、メインプロセスをブロックしない
        result = pool.apply_async(convert_and_save, args=(file_path,), callback=print_result)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;例を挙げる-6&#34;&gt;例を挙げる
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;result = pool.apply_async(convert_and_save, args=(file_path,), callback=print_result)
            # 結果オブジェクトをリストに追加
            results.append((file, result))
    # 処理プールを閉じる（新しいタスクの受付を停止）
    pool.close()
    # すべてのタスクが完了するまで待機
    pool.join()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;終わりに&#34;&gt;終わりに
&lt;/h2&gt;&lt;p&gt;ローカル開発が &lt;code&gt;windows&lt;/code&gt; システムであるため、AI が最初に提示した回答には &lt;code&gt;main&lt;/code&gt; 関数も &lt;code&gt;multiprocessing.freeze_support&lt;/code&gt; も含まれておらず、エラーが発生しました。質問を重ねることでエラーの原因を特定し、コードを修正しました。&lt;/p&gt;
&lt;p&gt;かつて検索エンジンの技術を学ぶように、AI とコミュニケーションする上でも、適切な制約条件を与え、効率的に必要な回答を得るためのスキルを習得する必要があります。&lt;/p&gt;
&lt;p&gt;注意：&lt;strong&gt;もしあなたがプログラミング初心者であれば、提示されたコメントと合わせて理解できない点がある場合は、引き続き関連コードについて質問してください。&lt;/strong&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
