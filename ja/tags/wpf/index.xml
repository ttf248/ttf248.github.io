<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Wpf on 向叔の手帳</title>
        <link>https://ttf248.life/ja/tags/wpf/</link>
        <description>Recent content in Wpf on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Sun, 25 May 2025 14:10:37 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/tags/wpf/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>WPFのUIスレッドと、その応答性の問題とその解決策</title>
        <link>https://ttf248.life/ja/p/wpf-ui-thread-and-freezing-issues-solutions/</link>
        <pubDate>Tue, 12 Mar 2024 07:12:21 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/wpf-ui-thread-and-freezing-issues-solutions/</guid>
        <description>&lt;p&gt;デスクトップアプリケーションを開発する際、特にWindows Presentation Foundation (WPF) フレームワークを使用してリッチクライアントアプリケーションを構築する場合、ユーザーインターフェース（UI）スレッドを正しく処理することは、アプリケーションの滑らかさと応答性を保証するために非常に重要です。UIスレッドは、メインスレッドとも呼ばれ、ウィンドウやコントロールイベントの処理、レイアウト計算、およびインターフェースの描画を担当するコアスレッドです。UI要素とのインタラクションに関わる操作はすべて、UIスレッド上で実行されるべきであり、これはWPFをはじめとする多くのGUIフレームワークが遵守する基本的な原則です。&lt;/p&gt;
&lt;h2 id=&#34;uiスレッドとは何ですか&#34;&gt;UIスレッドとは何ですか？
&lt;/h2&gt;&lt;p&gt;WPFアプリケーションの起動時に、OSによってUIスレッドが作成され、アプリケーションのメインウィンドウが初期化されます。これは、アプリケーション内で直接UIコンポーネントの状態にアクセスおよび変更できる唯一のスレッドです。つまり、ボタンクリック、テキストボックスへの入力、ウィンドウサイズの変更など、すべてのユーザーインタラクションによって発生するイベントは、このスレッドのコンテキストで処理されます。同時に、WPFの依存プロパティシステム、データバインディングメカニズム、およびレイアウトロジックもUIスレッド上で同期的に実行されます。&lt;/p&gt;
&lt;h2 id=&#34;カクつき現象とその原因&#34;&gt;カクつき現象とその原因
&lt;/h2&gt;&lt;p&gt;UIスレッドが長時間占有またはブロックされると、例えば時間のかかる計算や大量のデータ読み込み、データベースクエリなどのI/O集約型のタスクを実行すると、UIスレッドはユーザーからのインタラクションリクエストにタイムリーに応答できなくなり、結果として画面がフリーズ（応答なし）したように見える、「カドゥン」と呼ばれる状態になります。このような状況下では、ユーザーはアプリケーションの遅延や不具合を強く感じることがあり、深刻な場合には「Application Not Responding」（ANR）警告が表示されることもあります。&lt;/p&gt;
&lt;h2 id=&#34;uiスレッドの2つの基本的なルール&#34;&gt;UIスレッドの2つの基本的なルール
&lt;/h2&gt;&lt;p&gt;上記のような状況を避けるために、WPF開発者は以下の2つの重要なルールに従うべきです。&lt;/p&gt;
&lt;p&gt;UIスレッドで時間のかかる処理を実行しないでください。UIスレッドがユーザーの入力にタイムリーに応答し、画面の変化をレンダリングできるように、可能な限り時間のかかる操作はバックグラウンドスレッドで実行するようにしてください。
UIスレッド以外のスレッドで直接UI要素を更新しないでください。WPFのセキュリティ機構により、UI要素の変更はUIスレッドのみが許可されています。他のスレッドから直接UIの状態を変更しようとすると例外が発生します。したがって、バックグラウンドスレッドで計算やデータ準備が完了した場合でも、適切なクロススレッド通信メカニズムを通じて結果をUIに表示する必要があります。&lt;/p&gt;
&lt;h2 id=&#34;解決策非同期プログラミングとスレッドセーフな更新&#34;&gt;解決策：非同期プログラミングとスレッドセーフな更新
&lt;/h2&gt;&lt;p&gt;UI のスムーズさを維持しながら、時間のかかるタスクを実行するために、WPF は開発者がこの目標を達成するのを支援するためのさまざまな非同期プログラミングモデルとツールを提供します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ディスパッチャオブジェクト：WPFのDispatcherクラスを使用すると、作業項目をUIスレッドのタスクキューに配置して実行できます。&lt;code&gt;Dispatcher.Invoke&lt;/code&gt;または&lt;code&gt;Dispatcher.BeginInvoke&lt;/code&gt;メソッドを使用して、バックグラウンドスレッドから安全にUIを更新できます。&lt;/li&gt;
&lt;li&gt;C#言語の非同期機能を利用することで、非同期メソッドを記述し、その中で&lt;code&gt;await&lt;/code&gt;キーワードを使用してバックグラウンドタスク完了を待機し、完了後に自動的にUIスレッドで実行して、後続のUI更新コードを実行できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;事例&#34;&gt;事例
&lt;/h2&gt;&lt;h3 id=&#34;dispatcherinvokeメソッドを使用してuiを更新する&#34;&gt;&lt;code&gt;Dispatcher.Invoke&lt;/code&gt;メソッドを使用してUIを更新する。
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private void Button_Click(object sender, RoutedEventArgs e)
{
    // 假设这是一个耗时操作
    Task.Run(() =&amp;gt;
    {
        var result = LongRunningOperation(); // 这里是模拟一个耗时计算的方法
        
        // 当耗时操作完成后，在UI线程上更新UI
        Application.Current.Dispatcher.Invoke(() =&amp;gt;
        {
            LabelStatus.Text = $&amp;quot;计算结果: {result}&amp;quot;;
        });
    });
}

private string LongRunningOperation()
{
    // 模拟耗时操作
    Thread.Sleep(5000);
    return &amp;quot;已完成&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;asyncawaitキーワードとtaskrunを組み合わせる&#34;&gt;&lt;code&gt;async/await&lt;/code&gt;キーワードと&lt;code&gt;Task.Run&lt;/code&gt;を組み合わせる。
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private async void Button_ClickAsync(object sender, RoutedEventArgs e)
{
    Button button = sender as Button;
    button.IsEnabled = false; // 防止用户重复点击

    try
    {
        // 开启后台任务
        var result = await Task.Run(() =&amp;gt; LongRunningOperation());

        // 在后台任务完成后，自动切换回UI线程更新UI
        LabelStatus.Text = $&amp;quot;计算结果: {result}&amp;quot;;
    }
    catch (Exception ex)
    {
        MessageBox.Show($&amp;quot;发生错误: {ex.Message}&amp;quot;);
    }
    finally
    {
        button.IsEnabled = true; // 重新启用按钮
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>WPF学習資料</title>
        <link>https://ttf248.life/ja/p/wpf-learning-resources/</link>
        <pubDate>Tue, 17 Oct 2023 10:49:24 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/wpf-learning-resources/</guid>
        <description>&lt;p&gt;小程序的開発設計の穴はまだ埋まっていないのに、新たに&lt;strong&gt;WPF&lt;/strong&gt;を掘り起こし、最近会社も動揺しているので、遠隔での共同作業やコミュニケーションは効率があまり良くないため、思い切ってクライアント側のインターフェースの開発を引き受けた。&lt;/p&gt;
&lt;h2 id=&#34;wpf&#34;&gt;WPF
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/dotnet/desktop/wpf/introduction-to-wpf?view=netframeworkdesktop-4.8&amp;amp;preserve-view=true&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF マイクロソフト公式学習資料の推奨&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;WPF基礎まとめ（学習アドバイス）&lt;/li&gt;
&lt;li&gt;WPF中文网&lt;/li&gt;
&lt;li&gt;WPF 個人まとめと学習推奨&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;WPFインターフェース設計で使用される多くのコンセプトは、ウェブフロントエンド設計に似ており、可能な限りUIデザインとビジネスロジックを分離し、UIのデザインを独立させることは、インターネット企業が期待する分工方法です。今年ちょうど小程序を色々試しましたが、多くのコンセプトで共通点があり、比較的簡単に習得できます。これらは現代のUIデザインにおける&lt;strong&gt;道&lt;/strong&gt;であり、基本的なフレームワークの概念を理解していれば、後の道のりは間違えにくくなります。&lt;/p&gt;
&lt;p&gt;以前に&lt;code&gt;Winform&lt;/code&gt;の開発経験がある読者の皆様へ、&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/zh7791/p/11502696.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 基礎まとめ(学習アドバイス)&lt;/a&gt; をおすすめします。内容は短く、経験豊富な読者の方々の学習ルートの計画に役立つでしょう。&lt;/p&gt;
&lt;p&gt;ゼロからの学習者向けに推奨するサイトです。&lt;a class=&#34;link&#34; href=&#34;http://www.wpfsoft.com/introduction&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 中国語サイト&lt;/a&gt; は、基礎概念、発展の歴史、そして基盤となるクラスの理解について、ゼロから解説しています。このサイトは偶然にも今年8月に作者が公開したばかりで、こちらのタイミングとちょうど合致しました。もう少し遅れていたら、おそらく縁はなかったでしょう。&lt;/p&gt;
&lt;p&gt;最も正統な学習資料は、もちろんマイクロソフトの公式サイトにあるものです。少し退屈かもしれませんが、新しい読者は辛抱強く待つ必要があります。&lt;/p&gt;
&lt;p&gt;古典的な電子書籍もたくさんありますが、あまりお勧めできません。日々の仕事が忙しく、じっくりと読書に集中する時間がなかなかありません。一度に読み進めるのは難しいため、プロジェクト演習の方が向いています。&lt;/p&gt;
&lt;h2 id=&#34;c-と-net-のリリース履歴&#34;&gt;C# と .NET のリリース履歴
&lt;/h2&gt;&lt;p&gt;以前学習した言語に比べて、ここ数年で新機能が少し多いのと、文法も毎年バージョンアップされています。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/C_Sharp_%28programming_language%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://en.wikipedia.org/wiki/C_Sharp_(programming_language)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;公式学習資料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/dotnet/csharp/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/dotnet/csharp/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/dotnet/core/tutorials/with-visual-studio?pivots=dotnet-7-0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/dotnet/core/tutorials/with-visual-studio?pivots=dotnet-7-0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        
    </channel>
</rss>
