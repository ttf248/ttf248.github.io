<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Docker on 向叔の手帳</title>
        <link>https://ttf248.life/ja/tags/docker/</link>
        <description>Recent content in Docker on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Sun, 25 May 2025 14:10:37 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/tags/docker/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>AI開発2年：ドッカーがリリースされる前の状態に少し似ている。</title>
        <link>https://ttf248.life/ja/p/ai-development-two-years-docker-pre-release/</link>
        <pubDate>Thu, 20 Feb 2025 18:16:37 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/ai-development-two-years-docker-pre-release/</guid>
        <description>&lt;p&gt;人工知能（AI）は近年、間違いなく技術分野で最も議論されている話題の一つであり、特に過去2年間のAI技術の急速な進歩が目覚ましいです。深層学習、自然言語処理、コンピュータビジョン、自動化された意思決定システムなど、AIの応用範囲は絶え間なく広がっています。しかしながら、技術的なブレークスルーが続いているにもかかわらず、AIはDockerがリリースされる前のボトルネックに似た状況に直面しており、市場を真に爆発させるような画期的なアプリケーションが不足しています。&lt;/p&gt;
&lt;p&gt;AIの発展も2年ほど経ち、Dockerがリリースされる前の状態に似ている。画期的なアプリケーションはまだなく、既存技術を基盤として、完璧な実用化シナリオを生み出す必要がある。Dockerのように、特に新しい技術を使わなくても良いのだが、全体的な方案が非常に合理的で、運用や開発のワークフローを変えるようなものだ。&lt;/p&gt;
&lt;h2 id=&#34;人工知能の開発状況技術は既に成熟しているが応用はまだブレークスルーが必要だ&#34;&gt;人工知能の開発状況：技術は既に成熟しているが、応用はまだブレークスルーが必要だ。
&lt;/h2&gt;&lt;p&gt;技術的な側面から見ると、AIは過去2年間でかなりの進歩を遂げています。OpenAIが発表したGPTシリーズモデルも、GoogleのBERTやDeepMindのAlphaシリーズも、AIの処理能力は以前の予想を大きく上回っています。特に自然言語処理分野においては、GPT-4などのモデルは強力な生成能力に加え、理解と推論においても驚くべきパフォーマンスを示しています。&lt;/p&gt;
&lt;p&gt;しかしながら、技術が日進月歩を遂げているにもかかわらず、AIの実際の応用においては一定の課題に直面している。Dockerがリリースされる前の状況と似ており、AIの潜在能力は大きいものの、現状では広く普及し、産業を変革する真に画期的なアプリケーションはまだ登場していない。多くの人々がAIの将来性について語っているが、革命的な変化をもたらす直接的な応用事例を見つけることは難しい。多くのAIアプリケーションは依然として初期段階にとどまっており、大部分はさらなる統合と最適化が必要である。&lt;/p&gt;
&lt;h2 id=&#34;dockerとaiの類似性技術そのものが革新ではない解決策が重要だ&#34;&gt;DockerとAIの類似性：技術そのものが革新ではない、解決策が重要だ。
&lt;/h2&gt;&lt;p&gt;もしDockerのリリース前の歴史を振り返れば、当時の技術環境とAIの現状には多くの類似点があることが容易にわかるでしょう。Dockerがリリースされる前は、コンテナ技術が新しいものではありませんでした。初期のLXC（Linux Containers）や仮想化技術もすでにコンテナ化の基本的な能力を備えていました。しかし、Dockerは既存技術を巧みに統合・最適化し、よりシンプルで直感的かつ効率的なソリューションを提案しました。このソリューションは画期的な技術を導入したものではありませんが、運用や開発プロセスにおける多くの課題を解決し、ソフトウェアのデプロイ、拡張、管理プロセスを大幅に簡素化しました。&lt;/p&gt;
&lt;p&gt;同様に、AI分野も類似の状況に直面している。現在のAI技術は「目新しさ」から離れたとはいえ、真に大規模な応用を実現するには、Dockerのように既存技術を統合・最適化し、合理的な応用シナリオを構築することが不可欠だ。AIの画期的な応用とは、必ずしも新たな技術革新に依存するものではなく、むしろ既存技術を統合して、実際のビジネスにおける課題やニーズを解決することにあるかもしれない。&lt;/p&gt;
&lt;h2 id=&#34;aiのdocker瞬間を見つけるにはどうすればよいか&#34;&gt;AIの「Docker瞬間」を見つけるにはどうすればよいか？
&lt;/h2&gt;&lt;p&gt;AI技術が真に広く応用されるためには、いくつかの側面から取り組む必要があります。&lt;/p&gt;
&lt;p&gt;現実的なシーンの深掘り
現在、多くのAIの応用事例は依然として実験的な性質が強く、大規模な実用化には至っていません。例えば、AIカスタマーサービスやスマートレコメンデーションといった分野では幅広い応用があるものの、その機能にはまだ多くの制約があり、業界のボトルネックを突破できていません。真のブレークスルーは、従来の方法に悩まされてきた医療、製造業、物流といった業界から生まれるかもしれません。AIは、より効率的なデータ処理や予測分析を通じて、これらの複雑な状況下で企業の効率向上とコスト削減に貢献できるでしょう。&lt;/p&gt;
&lt;p&gt;製品化とユーザビリティ
Dockerのようにコンテナ化プロセスを簡略化することで運用効率を高めるように、AIプロダクトの使いやすさも同様に重要です。AIの普及は技術の普及であると同時に、製品化の普及でもあります。AIを日常業務フローに統合し、ユーザーが深い技術的理解なしにこれらのツールを簡単に使えるようにすることは、AIを実用化するための重要な一歩です。&lt;/p&gt;
&lt;p&gt;生態建設と標準化
いかなる新技術の広範な応用も、エコシステムの構築なしには成り立ちません。Dockerが急速に台頭できたのは、そのオープン性と互換性のおかげで、開発者が様々なクラウドプラットフォーム、ツール、サービスとの連携を容易に行えるようになったからです。同様に、AIの未来もエコシステムの構築にかかっています。AIの標準化、モデルの共有、データの公開、そして技術の統合性は、AIが広範な業界応用を形成できるかどうかを左右するでしょう。&lt;/p&gt;
&lt;h2 id=&#34;結論aiの未来は多くの可能性を秘めているがより完善した着地点が必要である&#34;&gt;結論：AIの未来は多くの可能性を秘めているが、より完善した着地点が必要である。
&lt;/h2&gt;&lt;p&gt;AI技術はここ2年間で目覚ましい進歩を遂げたものの、現状では「決定版のアプリケーション」とは言えない段階です。Dockerがリリースされる前のコンテナ化技術と同様に、AIも合理的な応用シナリオを持ち、既存技術とビジネスニーズを深く融合することで初めて、大規模な導入と普及を実現できます。技術革新は確かに重要ですが、プロセスを簡素化し効率を高めるソリューションの方が、技術の普及と発展をより促進します。&lt;/p&gt;
&lt;p&gt;未来、AIはDockerのように、画期的な技術革新ではなく、既存の技術を統合することで完璧なアプリケーションシーンを作り出し、最終的に私たちの仕事や生活のやり方を変えるかもしれません。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Docker国内镜像代理失効</title>
        <link>https://ttf248.life/ja/p/docker-domestic-mirror-failure/</link>
        <pubDate>Sat, 04 Jan 2025 18:29:25 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/docker-domestic-mirror-failure/</guid>
        <description>&lt;p&gt;国内サーバーにDockerをデプロイし、デプロイ後、もし会社がイメージセンターを提供していない場合、開発者がまず行うべきことは、国内のイメージ加速アドレスを設定することです。ちょうど今日、一台のサーバーがあり、イメージ加速アドレスを設定しましたが、イメージのプルダウンがずっとできません。&lt;/p&gt;
&lt;p&gt;エラー応答: デーモンからのエラー: &lt;code&gt;https://registry-1.docker.io/v2/&lt;/code&gt; への接続を待機中にタイムアウトが発生しました (&lt;code&gt;net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;二日ぶりのことですが、全てのサーバーが復旧しました。なぜこれが話題にならないのか、国内のすべてのミラープロキシはダウンしています。&lt;/p&gt;
&lt;h2 id=&#34;トラブルシューティングと修理の試み&#34;&gt;トラブルシューティングと修理の試み
&lt;/h2&gt;&lt;p&gt;当初、別のミラーの加速アドレスに切り替えることを試みましたが、期待した効果はなく、問題は依然として解決されませんでした。&lt;/p&gt;
&lt;p&gt;直ちに、ローカルDNSの設定変更に着手し、ネットワーク解析のレベルで突破口を探りましたが、何度かデバッグしても、問題は依然として解決しませんでした。&lt;/p&gt;
&lt;p&gt;現時点では、ローカルネットワークの安定性が疑われているため、思い切って携帯電話のテザリングに切り替え、考えられるローカルネットワークの問題点を回避しようとしましたが、結果は落胆するもので、問題は全く改善されません。&lt;/p&gt;
&lt;h2 id=&#34;問題が拡大&#34;&gt;問題が拡大
&lt;/h2&gt;&lt;p&gt;現在も&lt;strong&gt;国内にいくつかサーバー&lt;/strong&gt;があり、それらはすべて Docker 環境がインストールされています。これらのサーバーでイメージのプルを試みましたが、別の方法を見つけられるのではないかと考えていましたが、例外なくすべて失敗し、エラーメッセージは全く同じでした。これは問題が特定のデバイスに限られたものではないことを示しています。&lt;/p&gt;
&lt;p&gt;さらに調査したところ、ミラープロキシが一時的に機能しなくなったようです。この緊急事態において、すぐに海外のサーバーに切り替えて試みると、幸いなことに、ここでミラーの取得は正常に戻り、問題はおおむね国内のネットワーク経路または関連設定にある可能性が高いことを意味します。&lt;/p&gt;
&lt;h2 id=&#34;戦術調整間接解決&#34;&gt;戦術調整：間接解決
&lt;/h2&gt;&lt;p&gt;国内の直接リソースミラーリングが様々な妨害を受けている現状と、海外ミラーは正常にアクセスできる状況を踏まえ、プロジェクトを迅速に進めるため、回り道をすることに決定しました。まず海外サーバーへ切り替え、必要なリソースミラーを問題なく取得した後、国内のリソースミラー倉庫へプッシュし、「データブリッジ」を構築します。&lt;/p&gt;
&lt;p&gt;同時に、Dockerfile ファイルも修正し、イメージのアドレスを国内環境に適合したアドレスに置き換えた後、再度イメージを構築し、最終的に正常にデプロイすることができた。&lt;/p&gt;</description>
        </item>
        <item>
        <title>オフィス移転のため、サーバーにアクセスできません。</title>
        <link>https://ttf248.life/ja/p/office-migration-server-unavailable/</link>
        <pubDate>Sat, 11 Mar 2023 01:42:05 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/office-migration-server-unavailable/</guid>
        <description>&lt;p&gt;周知いたします。オフィスが変更になり、元の2階から15階へ移転します。これは通常の席の移動です。&lt;/p&gt;
&lt;h2 id=&#34;デザイン性&#34;&gt;デザイン性
&lt;/h2&gt;&lt;p&gt;オフィスビル&lt;/p&gt;
&lt;h2 id=&#34;移動&#34;&gt;移動
&lt;/h2&gt;&lt;p&gt;退社して荷物をまとめて、慣れた手つきで新しい席へ。パソコンの配線を整えて、楽な姿勢で作業開始。&lt;/p&gt;
&lt;p&gt;（´д`||）！、ネットケーブルを繋いでみたけど、チームでよく使うサーバーにアクセスできない。無線ネットワークに切り替えたら、またアクセスできるようになった。&lt;/p&gt;
&lt;p&gt;当初はサーバーのネットワークセグメント設定の問題かと思った。新しい作業場所の有線ネットワークが、ファイアウォールの設定リストに登録されていないだけだろうと。IT担当者に連絡して調整すれば良いはずだ。しかし、このネットワークセグメントには一台のサーバーだけでなく、他のサーバーにもアクセスしてみると正常だったため、徐々に疑問が生じた。専門的なことは専門の人に任せることにし、最終的に運用部門の担当者が調査した結果、このサーバーが&lt;code&gt;docker&lt;/code&gt;をデプロイしていたために、サービスのデフォルトネットワーク&lt;code&gt;docker0&lt;/code&gt;とオフィス有線ネットワークの設定セグメントが衝突しており、送信されたデータパケットが応答を受け取れずに&lt;code&gt;docker&lt;/code&gt;サービスにルーティングされてしまっていたことが判明した。&lt;/p&gt;
&lt;p&gt;他のサーバーには&lt;code&gt;docker&lt;/code&gt;サービスはデプロイされていないので、この台だけが利用できており、よく使う。時々コンテナでテストサービスをデプロイすることもあるが、まさかこんな状況に遭遇するとは思いもよらなかった。後で考えると、グループ全体が同じオフィスビルに入っているため、IT部門の同僚がネットワークセグメントを分けて&lt;code&gt;172&lt;/code&gt;から始まるアドレスを使っているのも不思議ではない。&lt;/p&gt;
&lt;h2 id=&#34;docker0&#34;&gt;docker0
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# vim /etc/docker/daemon.json
{
    &amp;quot;bip&amp;quot;:&amp;quot;172.200.0.1/24&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;サービスを再起動し、新しいネットワークに切り替えると、サーバーは通常通りアクセスできるようになります。&lt;/p&gt;
&lt;h2 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h2&gt;&lt;p&gt;Docker 入門から実践 - docker0&lt;/p&gt;</description>
        </item>
        <item>
        <title>Dockerの豆知識</title>
        <link>https://ttf248.life/ja/p/docker-two-three-things/</link>
        <pubDate>Thu, 21 Jan 2021 09:26:07 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/docker-two-three-things/</guid>
        <description>&lt;p&gt;長年作業で触れてきたのは&lt;code&gt;CentOS&lt;/code&gt;オペレーティングシステムばかりなので、もし&lt;code&gt;Mac&lt;/code&gt;ユーザーや&lt;code&gt;Ubuntu&lt;/code&gt;ユーザーであれば、一部の内容が適用できない場合があります。&lt;/p&gt;
&lt;p&gt;インストール手順については、清華大学のマニュアルを参照してください：[https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/]&lt;/p&gt;
&lt;h2 id=&#34;設置&#34;&gt;設置
&lt;/h2&gt;&lt;p&gt;未知な神秘的な力により、ローカルにDockerをインストールする際は、クラウドプロバイダーが提供するリポジトリのアドレスを設定することを推奨します。ここでは&lt;strong&gt;アリババクラウド&lt;/strong&gt;の使用をお勧めします。&lt;/p&gt;
&lt;h3 id=&#34;倉庫ソースアドレスを設定する&#34;&gt;倉庫ソースアドレスを設定する
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install yum-utils device-mapper-persistent-data lvm2 &amp;amp;&amp;amp; \
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;部署最新バージョン&#34;&gt;部署最新バージョン
&lt;/h3&gt;&lt;p&gt;Dockerはよく使用されるバックグラウンドサービスなので、推奨としては起動時に自動的に開始するように設定し、現在のコマンドはCentOS 7に適用されます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum install -y docker-ce docker-ce-cli containerd.io &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;部門指定バージョン&#34;&gt;部門指定バージョン
&lt;/h3&gt;&lt;p&gt;KubernetesとDockerのリリースは完全に同期していないため、次にKubernetesをデプロイする場合は、Kubernetesのデプロイ手順を参照し、指定されたバージョンのDockerをインストールしてください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum list docker-ce --showduplicates | sort -r
sudo yum install -y docker-ce-18.09.2-3.el7 docker-ce-cli-18.09.2-3.el7 containerd.io-18.09.2-3.el7 &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;通常ユーザーにdocker権限を追加する&#34;&gt;通常ユーザーにDocker権限を追加する
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo usermod -aG docker ${USER}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;アンインストール&#34;&gt;アンインストール
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum erase -y docker-ce docker-ce-cli containerd.io
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;日常利用&#34;&gt;日常利用
&lt;/h2&gt;&lt;h3 id=&#34;ミラーアクセラレーション&#34;&gt;ミラーアクセラレーション
&lt;/h3&gt;&lt;p&gt;依然未知な神秘的な力が存在するせいで、イメージの引き出しがうまくいかないことがあります。そこで、国内のクラウドベンダーが多くのアクセラレーションサービスを提供してくれました。やはり&lt;strong&gt;阿里云&lt;/strong&gt;をおすすめします。&lt;/p&gt;
&lt;p&gt;加速されたアドレスは、ご自身でアカウントを登録してAliyun（アリババクラウド）から入手してください。このサービスは無料で、Aliyunは無料のイメージ構築サービスも提供しています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt; /etc/docker/daemon.json &amp;lt;&amp;lt;EOF
{
  &amp;quot;registry-mirrors&amp;quot;: [
    &amp;quot;https://docker.nju.edu.cn&amp;quot;,
    &amp;quot;https://mirror.baidubce.com&amp;quot;,
    &amp;quot;https://docker.m.daocloud.io&amp;quot;,
    &amp;quot;https://docker.mirrors.sjtug.sjtu.edu.cn&amp;quot;
  ]
}
EOF
systemctl daemon-reload &amp;amp;&amp;amp; \
systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;強く推奨されるコントロールパネル&#34;&gt;強く推奨されるコントロールパネル
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker volume create portainer_data &amp;amp;&amp;amp; \
docker run -d --name=portainer --restart=always -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:2.20.3-alpine
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;よく使うミラーの引き出しまとめ&#34;&gt;よく使うミラーの引き出しまとめ
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker pull rancher/rancher:stable &amp;amp;&amp;amp; docker pull  portainer/portainer-ce:2.0.1 &amp;amp;&amp;amp; \
docker pull centos:7 &amp;amp;&amp;amp; docker pull ubuntu:20.04 &amp;amp;&amp;amp; docker pull ubuntu:18.04 &amp;amp;&amp;amp; \
docker pull redis:5 &amp;amp;&amp;amp; docker pull redis:6 &amp;amp;&amp;amp; \
docker pull alpine:3.11 &amp;amp;&amp;amp; docker pull busybox:1.32 &amp;amp;&amp;amp; \
docker pull rabbitmq:3.7-management &amp;amp;&amp;amp; \
docker pull mariadb:10.2 &amp;amp;&amp;amp; \
docker pull nginx:1.18 &amp;amp;&amp;amp; docker pull nginx:1.19 &amp;amp;&amp;amp; \
docker pull mysql:5.6 &amp;amp;&amp;amp; docker pull mysql:8 &amp;amp;&amp;amp; \
docker pull elasticsearch:6.8.11 &amp;amp;&amp;amp; docker pull logstash:6.8.11 &amp;amp;&amp;amp; docker pull kibana:6.8.11 &amp;amp;&amp;amp; \
docker pull zookeeper:3.4 &amp;amp;&amp;amp; \
docker pull influxdb:1.7 &amp;amp;&amp;amp; docker pull grafana/grafana:7.3.1 &amp;amp;&amp;amp; \
docker pull percona:8 &amp;amp;&amp;amp; docker pull percona:5.6 &amp;amp;&amp;amp; \
docker pull cloverzrg/frps-docker:0.34.3 &amp;amp;&amp;amp; docker pull cloverzrg/frpc-docker:0.34.3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;よく使うコマンドの組み合わせ&#34;&gt;よく使うコマンドの組み合わせ
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/engine/reference/commandline/docker/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.docker.com/engine/reference/commandline/docker/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;コンテナの実行状態を確認し、&lt;code&gt;format&lt;/code&gt;パラメータを追加して詳細なコンテナ情報を確認します。この際、イメージ情報は気にしません。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker ps --format &amp;quot;{{.Names}}: {{.Ports}}: {{.Size}}&amp;quot;
#portainer: 0.0.0.0:8000-&amp;gt;8000/tcp, 0.0.0.0:9000-&amp;gt;9000/tcp: 0B (virtual 172MB)
#influxdb: 0.0.0.0:8086-&amp;gt;8086/tcp: 183B (virtual 311MB)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;全コンテナを停止&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker stop $(docker ps -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ワンクリックですべてのイメージを削除します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dokcer rmi $(docker images -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;イメージエクスポート&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; &amp;gt; -o XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;イメージをエクスポートして圧縮する&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; | gzip &amp;gt; XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;イメージのインポート&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker load -i XXX.tar
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>LinuxでJMeterテスト環境を構築する</title>
        <link>https://ttf248.life/ja/p/linux-setup-jmeter-testing-environment/</link>
        <pubDate>Tue, 22 Dec 2020 10:12:50 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-setup-jmeter-testing-environment/</guid>
        <description>&lt;p&gt;著者はハードウェアに強い興味を持ち、Jmeterを用いて負荷テストを実施し、CentOS 7上にJmeter、InfluxDB、Grafanaをデプロイした過程を記録した。Jmeterのインストールとコマンドの使用方法、InfluxDBの特徴とDockerのインストール方法、そしてGrafanaの簡単なデプロイと設定について共有している。高性能プログラムのパターンに関する経験と参考文献をまとめた。&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景
&lt;/h2&gt;&lt;p&gt;周知の通り、私はハードウェアに強い興味があります。たまたまテストチームがJmeterでパフォーマンステストを行っているところを見かけ、性能が上がらないというので、好奇心旺盛な私が早速乗り出し、会社のパフォーマンステストを試してみることにしました。 ここでちょっとしたエピソードがあります。ある昔のことですが、OSC（开源中国）で記事を拝見し、より高尚に見えるパフォーマンステストのグラフを描く方法について学んだことがあります。Windows版のテストを実行しているところを見学し、TPSデータを可視化するまで来ています。それに加えてWebパネルを設定することにどのようなメリットがあるのでしょうか？&lt;/p&gt;
&lt;p&gt;考えたことがすべて思い込みで、試してみないとわからない。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Don&amp;rsquo;t use GUI mode for load testing! only for Test creation and Test debuggin.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;公式的には、コマンドラインで結果を取得し、GUIで表示する方法ではデータの誤差が生じる可能性があるとのことです。JMeterについてはあまり詳しくないのですが、せめてLinux版のコンソールパネルを試してみる理由にはなります。&lt;/p&gt;
&lt;p&gt;オープンソース中国のフォーラムでの投稿ですが、主要コンポーネントのデプロイメントは友好的ではありません。必要なファイルも公众号をフォローしないとダウンロードできないので、新しい世代として当然Dockerで代替しました。結局のところ、自分のサーバーが国内にあること、そしてクロスボーダーのソースアドレスへのアクセス速度が非常に遅いことが原因です。少なくともイメージサービスに関しては、アリババクラウドには無料のアクセラレーションがあります。&lt;/p&gt;
&lt;p&gt;Dockerのインストールとデプロイについては、ここでは詳細を述べません。以前の記事をご参照ください。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;今後の内容は大きく分けて二つです。基本的なテスト環境コンポーネントの構築と、各コンポーネントの簡単な説明。&lt;/p&gt;
&lt;h2 id=&#34;jmeter&#34;&gt;Jmeter
&lt;/h2&gt;&lt;p&gt;Apache JMeterは、Apache Foundationが開発したJavaベースの負荷テストツールです。ソフトウェアの負荷テストに用いられ、当初はWebアプリケーションのテスト用に設計されましたが、その後他のテスト分野にも拡張されています。静的なリソースや動的なリソースなど、さまざまなものをテストできます。例えば、静的ファイル、Javaマイクロサービス、CGIスクリプト、Javaオブジェクト、データベース、FTPサーバーなどです。JMeterは、サーバー、ネットワーク、またはオブジェクトに対して巨大な負荷をシミュレートし、さまざまなプレッシャーカテゴリー下での強度をテストし、全体的なパフォーマンスを分析するために使用できます。また、アサーションを含むスクリプトを作成することで、アプリケーションの機能/回帰テストを行い、プログラムが期待される結果を返すことを検証できます。最大限の柔軟性を実現するため、JMeterは正規表現を使用してアサーションを作成することを許可しています。&lt;/p&gt;
&lt;p&gt;Apache JMeterは、静的なリソースと動的なリソース（ファイル、サーブレット、Perlスクリプト、Javaオブジェクト、データベースおよびクエリ、FTPサーバーなど）のパフォーマンスをテストするために使用できます。サーバー、ネットワーク、またはオブジェクトに過剰な負荷をかけて強度をテストしたり、さまざまな種類のプレッシャー下での全体的なパフォーマンスを分析したりすることができます。パフォーマンスのグラフ解析や、高並行負荷テストでサーバー/スクリプト/オブジェクトを使用することも可能です。&lt;/p&gt;
&lt;h3 id=&#34;jmeter-部署-centos7&#34;&gt;JMeter 部署 CentOS7
&lt;/h3&gt;&lt;p&gt;JDKランタイム環境をインストールし、Jmeterのインストーラパッケージをダウンロードする。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install java-1.8.0-openjdk -y &amp;amp;&amp;amp; \
wget https://mirrors.bfsu.edu.cn/apache//jmeter/binaries/apache-jmeter-5.4.tgz &amp;amp;&amp;amp; tar -xf apache-jmeter-5.4.tgz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;環境変数を設定する&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export JMETER_HOME=$HOME/jmeter/apache-jmeter-5.4
export PATH=$JMETER_HOME/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;jmeter-コマンド&#34;&gt;JMeter コマンド
&lt;/h3&gt;&lt;p&gt;最後に&lt;code&gt;Grafana&lt;/code&gt;コントロールパネルと接続し、&lt;code&gt;-l&lt;/code&gt;パラメータを入力せずに&lt;code&gt;web&lt;/code&gt;コンソールでデータを観察できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;jmeter -n -t /tmp/order-500-10s.jmx -l /tmp/jmeter-order-report-20200109/order-500-10s.jtl
# 一般不用测试结果和测试报告，简化命令
jmeter -n -t /tmp/order-500-10s.jmx
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;influxdb&#34;&gt;InfluxDB
&lt;/h2&gt;&lt;p&gt;InfluxDBは、外部依存関係なしにGo言語で記述されたオープンソースの分散型時系列、イベント、および指標データベースです。現在、このデータベースは主に、DevOpsモニタリングデータ、APPメトリクス、IoTセンサーデータ、リアルタイム解析データなど、大量の時間スタンプデータを保存するために使用されています。&lt;/p&gt;
&lt;h3 id=&#34;influxdbの特徴&#34;&gt;InfluxDBの特徴
&lt;/h3&gt;&lt;p&gt;InfluxDBの特徴は、以下の9つの側面からまとめられます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;構造（パターン）なし：任意の数の列が可能です。&lt;/li&gt;
&lt;li&gt;メトリクスの保存期間を設定できます。&lt;/li&gt;
&lt;li&gt;時間に関連する関数（最小値、最大値、合計、カウント、平均、中央値など）をサポートし、統計処理に便利です。&lt;/li&gt;
&lt;li&gt;サポートされているストレージポリシー：データの削除と変更に使用できます。（InfluxDBはデータの削除および変更の方法を提供していません。）&lt;/li&gt;
&lt;li&gt;継続クエリのサポート：データベース内で自動的にスケジュールされた一連の文であり、ストレージポリシーと組み合わせることでInfluxDBのシステムリソース使用量を削減できます。&lt;/li&gt;
&lt;li&gt;ネイティブなHTTPサポート、組み込みHTTP API。&lt;/li&gt;
&lt;li&gt;SQLに類似した構文をサポートします。&lt;/li&gt;
&lt;li&gt;クラスタ内のデータレプリカ数を設定する機能をサポートします。&lt;/li&gt;
&lt;li&gt;定期サンプリングデータをサポートし、別のmeasurementに書き込むことで、細分化されたデータストレージを容易にする。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;influxdb-docker-インストール&#34;&gt;InfluxDB Docker インストール
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir influxdb &amp;amp;&amp;amp; cd influxdb &amp;amp;&amp;amp; \
docker run -p 8086:8086 -d --name influxdb -v $PWD:/var/lib/influxdb influxdb:1.7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;コンテナに入り、コマンドを実行して、手動でデータベースを作成します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;root@bce0a55bbc72:/# influx
Connected to http://localhost:8086 version 1.7.10
InfluxDB shell version: 1.7.10
&amp;gt; 交互面板执行命令
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;influxdb-データベースとユーザーの作成&#34;&gt;InfluxDB データベースとユーザーの作成
&lt;/h3&gt;&lt;p&gt;データベースを作成します：create database jmeter_t2
データベースを確認する：show databases
データベースを切り替えます：use jmeter_t2
ユーザーを作成：パスワード&amp;rsquo;admin&amp;rsquo;でユーザー&amp;quot;admin&amp;quot;を全権限で作成する
ユーザーを表示&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; show users
user  admin
----  -----
admin true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ユーザー権限&lt;code&gt;admin&lt;/code&gt;が&lt;code&gt;true&lt;/code&gt;に表示されれば、データベースの準備は完了です。&lt;/p&gt;
&lt;h2 id=&#34;grafana&#34;&gt;Grafana
&lt;/h2&gt;&lt;p&gt;テストケースを作成していると、グラフ表示はそれほど必須ではないことがわかった。インターフェースの&lt;code&gt;tps&lt;/code&gt;データはコマンドラインで実行すれば確認できるし、むしろプログラム内部の処理時間を知りたいだけだ。&lt;/p&gt;
&lt;p&gt;シンプルな&lt;code&gt;Grafana&lt;/code&gt;コントロールパネルをデプロイし、設定ファイルをインポートして&lt;code&gt;InfluxDB&lt;/code&gt;に接続する。&lt;/p&gt;
&lt;p&gt;コントロールパネルでは、タグによるテスト結果のフィルタリングが可能で、通常は &lt;code&gt;InfluxDB&lt;/code&gt; データベースを一つ設定するだけで済みます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アプリケーション名&lt;/li&gt;
&lt;li&gt;テストケース名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/linux-setup-jmeter-testing-environment/Snipaste_2021-03-09_19-44-22.png&#34;
	width=&#34;861&#34;
	height=&#34;357&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;grafana&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;241&#34;
		data-flex-basis=&#34;578px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -d --name=grafana -p 3000:3000 grafana/grafana:7.3.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ウェブ版では、サンプラー間隔により計算される&lt;code&gt;TPS&lt;/code&gt;や関連数値が&lt;code&gt;Jmeter&lt;/code&gt;の集約レポートと一致しない場合があります。参考リンク：&lt;a class=&#34;link&#34; href=&#34;https://www.vinsguru.com/jmeter-real-time-results-influxdb-grafana/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.vinsguru.com/jmeter-real-time-results-influxdb-grafana/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;資料には、リスナーをカスタマイズする方法についても説明されています。&lt;/p&gt;
&lt;h2 id=&#34;あとがき&#34;&gt;あとがき
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;高性能なプログラムパターンは必ずしもone loop threadであり、ロック、キューへの入列と退列は不要なパフォーマンス損失を引き起こす。&lt;/li&gt;
&lt;li&gt;コアビジネスロジックの処理時間よりも、他のコードを導入する時間が長くなる場合がある。並行処理によってのみ効率を効果的に向上させることができ、コア処理時間が十分短い場合に限って、他のコードの導入は慎重に行うべきである。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;JMeterシリーズ：JMeter+Grafana+InfluxDBによるリアルタイム監視&lt;/li&gt;
&lt;li&gt;InfluxDB公式イメージ&lt;/li&gt;
&lt;li&gt;Grafana公式イメージ&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://jmeter.apache.org/download_jmeter.cgi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;JMeter公式サイト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@jasonli.studio/to-install-apache-jmeter-in-centos7-294bc72a97ba&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;To install Apache JMeter in CentOS7&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        
    </channel>
</rss>
