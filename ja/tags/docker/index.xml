<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Docker on 向叔の手帳</title>
        <link>https://ttf248.life/ja/tags/docker/</link>
        <description>Recent content in Docker on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Mon, 02 Jun 2025 07:41:32 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/tags/docker/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>AI開発2年：ドッカーのリリース前の状態に似ている</title>
        <link>https://ttf248.life/ja/p/ai-development-two-years-docker-pre-release/</link>
        <pubDate>Thu, 20 Feb 2025 18:16:37 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/ai-development-two-years-docker-pre-release/</guid>
        <description>&lt;p&gt;人工知能（AI）は近年、技術分野で最も議論を呼ぶトピックの一つであり、特に過去2年間でその進歩は目覚ましいものがありました。深層学習、自然言語処理、コンピュータビジョン、自動化意思決定システムなど、AIの応用範囲は多岐にわたっています。しかしながら、技術が着実に進化を続けているにもかかわらず、AIはDockerのリリース前のボトルネックに似た状況にあります——つまり、市場を本格的に引き出す「ゲームチェンジャー」となるような、真に革新的なアプリケーションが存在しないのです。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;プロンプト：記事を作成してください：AIは過去2年間で発展し、Dockerのリリース前のボトルネックのような状態です。既存技術に基づいて、完璧な実用例を構築し、Dockerはあまり新しい技術を使用せず、全体的なソリューションが合理的に、運用および開発ワークフローを変革します。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;aiの現状技術は成熟しているが応用には突破が必要&#34;&gt;AIの現状：技術は成熟しているが、応用には突破が必要
&lt;/h2&gt;&lt;p&gt;技術的な側面から見ると、AIは過去2年間で相当な進歩を遂げました。OpenAIが発表したGPTシリーズモデルや、GoogleのBERT、DeepMindのAlphaシリーズなど、AIの処理能力は以前の予測を大きく上回っています。特に自然言語処理分野では、GPT-4などのモデルが強力な生成能力に加えて、理解と推論においても驚くべきパフォーマンスを発揮しています。&lt;/p&gt;
&lt;p&gt;しかしながら、技術革新は日進月歩であるにもかかわらず、AIの実用的な応用においてはいくつかの課題が残されています。Dockerのリリース前の状況に似ており、AIの潜在力は巨大ですが、現時点では広く普及し、産業を変革するほどの「ゲームチェンジャー」となるアプリケーションはまだ出現していません。人々がAIの将来について語る一方で、実際に革命的な変化をもたらすことができる直接的な応用シナリオを見つけることは難しい状況です。&lt;/p&gt;
&lt;h2 id=&#34;dockerとaiの類似性技術は必ずしも革新ではなく解決策が重要&#34;&gt;DockerとAIの類似性：技術は必ずしも革新ではなく、解決策が重要
&lt;/h2&gt;&lt;p&gt;Dockerリリース前の歴史を振り返ると、技術環境とAIの現状には多くの類似点が見られることに気づきます。Dockerリリース前にコンテナ技術自体が新しいものではありませんでした。初期のLXC（Linux Containers）や仮想化技術もコンテナ化の基本的な能力を持っていました。しかし、Dockerは既存技術の巧みな統合と最適化を通じて、よりシンプルで直感的かつ効率的な解決策を提示しました。この解決策は、画期的な技術を導入したわけではありませんが、運用・開発プロセスにおける多くの課題を解決し、ソフトウェアのデプロイ、拡張、管理プロセスの大幅な簡素化を実現しました。&lt;/p&gt;
&lt;p&gt;同様に、AI分野も類似の状況に直面しています。 現在のAI技術は「新鮮なもの」ではなくなったとはいえ、本格的な大規模展開を実現するには、完璧な実現シナリオが必要であり、Dockerのように既存の技術を統合し最適化して、合理的なアプリケーションソリューションを形成することが求められます。AIの殺手級アプリケーションは、画期的な技術的ブレークスルーに依存するのではなく、既存の技術を組み合わせて、実際のビジネスにおける課題やニーズを解決することにある可能性があります。&lt;/p&gt;
&lt;h2 id=&#34;aiのdocker-momentを見つけるには&#34;&gt;AIの「Docker Moment」を見つけるには？
&lt;/h2&gt;&lt;p&gt;AI技術が広く普及するためには、いくつかの側面から取り組む必要があります。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;実用的なシナリオの深掘り&lt;/strong&gt;
現在、多くのAIアプリケーションは実験的な性質を持ち、大規模な実用化に乏しいです。例えば、AIチャットボットやレコメンデーションシステムなどの分野は広く利用されていますが、その機能にはまだ多くの制約があり、業界のボトルネックを打破していません。真のブレイクスルーは、従来のやり方に困っている業界、たとえば医療、製造業、物流などの分野から来る可能性があります。AIは、より効率的なデータ処理と予測分析を通じて、これらの複雑なシナリオにおいて企業が効率を高め、コストを削減するのを支援できます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;製品化と使いやすさ&lt;/strong&gt;
Dockerのようにコンテナ化プロセスを簡素化し運用効率を向上させるのと同様に、AI製品の使いやすさは非常に重要です。 AIの普及は、技術の普及だけではなく、その製品化の普及でもある。AIを日常業務フローに統合し、ユーザーが技術を深く理解する必要なく、これらのツールを簡単に利用できるようにすることは、AIの実落地における重要な一歩である。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;エコシステムの構築と標準化&lt;/strong&gt;
新しい技術の広範な応用には、エコシステムの構築が不可欠である。Dockerが急速に台頭したのも、そのオープン性と互換性により、開発者がさまざまなクラウドプラットフォーム、ツール、およびサービスと容易に連携できたためである。同様に、AIの未来もエコシステムの構築に依存する。AIの標準化、モデルの共有、データのオープン性、そして技術の統合性は、AIが広範な産業応用を達成できるかどうかを左右するだろう。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;結論aiの未来は可能性に満ちているが更なる実現に向けた具体的な計画が必要&#34;&gt;結論：AIの未来は可能性に満ちているが、更なる実現に向けた具体的な計画が必要
&lt;/h2&gt;&lt;p&gt;過去2年間にわたり、AI技術は目覚ましい進歩を遂げているものの、現状では「殺到するようなアプリケーション」が存在しない段階にある。Dockerがリリース前のコンテナ化技術と同様に、AIには合理的な応用シナリオが必要であり、既存の技術とビジネスニーズを深く融合させることで初めて、大規模な展開と普及を実現できる。技術革新は重要であることはもちろんだが、業務プロセスを簡素化し、効率を高めるソリューションこそが、技術の普及と発展を促進するだろう。&lt;/p&gt;
&lt;p&gt;未来において、AIはDockerのように、画期的な技術的ブレークスルーではなく、既存技術を統合し、完璧な応用シナリオを構築することで、私たちの仕事や生活様式を変革していく可能性がある。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Docker 国内イメージプロキシが失敗しました。</title>
        <link>https://ttf248.life/ja/p/docker-domestic-mirror-failure/</link>
        <pubDate>Sat, 04 Jan 2025 18:29:25 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/docker-domestic-mirror-failure/</guid>
        <description>&lt;p&gt;国内サーバーのDockerデプロイ、デプロイ後に会社がレジストリを提供していない場合、開発者が最初にやるべきことは、国内のレジストリ加速アドレスを設定することです。幸いにも今日、サーバー1台でレジストリ加速アドレスを設定しましたが、イメージの取得中に常に取得できないことがわかりました。
エラーメッセージ：&lt;code&gt;Error response from daemon: Get &amp;quot;https://registry-1.docker.io/v2/&amp;quot;: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)&lt;/code&gt;
&lt;strong&gt;2025年1月6日、2日ぶりにすべてのサーバーが復旧しました。この件は全く話題になりませんでした。国内のすべてのレジストリ代理がダウンしていました&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;障害の切り分けと修復試行&#34;&gt;障害の切り分けと修復試行
&lt;/h2&gt;&lt;p&gt;当初、他のミラー加速アドレスに切り替えて問題を解決することを期待したが、結果は عكسだった。
その後、ローカルDNS設定を修正し、ネットワーク解析レベルで突破口を見つけることを試みたが、結局、デバッグを行った結果、障害は依然として存在した。
この時点で、ローカルネットワークの安定性は疑念を抱くようになり、そこで断行したのは、可能性のあるローカルネットワーク障害点を回避するために携帯電話のテザリングに切り替えることだった。しかし、その結果も落胆させるものであり、問題の改善の兆候は見られなかった。&lt;/p&gt;
&lt;h2 id=&#34;問題の蔓延&#34;&gt;問題の蔓延
&lt;/h2&gt;&lt;p&gt;現在、国内に&lt;strong&gt;数台のサーバーがデプロイされており、すべてDocker環境がインストールされています&lt;/strong&gt;。これらのサーバーからイメージをプルすることを試みましたが、例外なく失敗し、返ってくるエラーメッセージも一様です。これは問題が特定のデバイスに限定されていないことを示唆しています。&lt;/p&gt;
&lt;p&gt;さらに調査したところ、イメージレジストリの代理が瞬く間に機能しなくなっていることが判明しました。この緊迫した状況で、迅速に海外のサーバーを試すと、幸いにもイメージのプルが正常に戻りました。これは問題が国内のネットワークリンクまたは関連設定にある可能性が高いことを意味します。&lt;/p&gt;
&lt;h2 id=&#34;戦略修正迂回戦術&#34;&gt;戦略修正：迂回戦術
&lt;/h2&gt;&lt;p&gt;国内での直接リポジトリ取得の経路が重く制限される中、海外のリポジトリは正常にアクセスできる状況を受けて、プロジェクトを迅速に進めるため、迂回戦術を採用することを決定しました。まず、国外サーバーに切り替えて必要なイメージをスムーズに取得し、その後それを国内イメージレジストリにプッシュすることで、「データブリッジ」を構築します。
同時に、Dockerfileファイルの内容を修正して、イメージのURLを国内環境に適したアドレスに変更し、再度イメージをビルドすることで、最終的に成功裏にデプロイしました。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>オフィスへの引っ越しにより、サーバーにアクセスできなくなりました。</title>
        <link>https://ttf248.life/ja/p/office-migration-server-unavailable/</link>
        <pubDate>Sat, 11 Mar 2023 01:42:05 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/office-migration-server-unavailable/</guid>
        <description>&lt;p&gt;行政通知、オフィス配置の変更（元の2階から15階への移動）、通常の事務室の移転&lt;/p&gt;
&lt;h2 id=&#34;デザインセンス&#34;&gt;デザインセンス
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/office-move-server-inaccessible/20230311014537.png&#34;
	width=&#34;511&#34;
	height=&#34;916&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;オフィスビル&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;55&#34;
		data-flex-basis=&#34;133px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;移住&#34;&gt;移住
&lt;/h2&gt;&lt;p&gt;荷造り、スムーズな進展、新しい作業場所への移動、PCの配線調整、快適な姿勢で仕事を開始
(ÒωÓױ)！、ネットワークケーブルを接続し、チームメンバーがよく使うサーバーにアクセスできなくなりました。無線LANに切り替えてみましたが、正常に戻りました。
当初はサーバーのIPアドレス設定の問題だと思っていましたが、新しい作業場所の有線LANがファイアウォールのリストに含まれていませんでした。IT担当の同僚に調整してもらい解決しました。このIPアドレス範囲は、他のサーバーにも使用されており、正常にアクセスできました。次第に疑問が生じ始めました？専門的なことは専門家に任せるのが一番です。最終的に運用部門の同僚が特定し、このサーバーに&lt;code&gt;docker&lt;/code&gt;がデプロイされており、サービスのデフォルトネットワーク&lt;code&gt;docker0&lt;/code&gt;とオフィスLANのIPアドレス範囲が競合しているため、送信されたデータパケットを受信できず、ルーティングされて&lt;code&gt;docker&lt;/code&gt;サービスに渡ってしまったという問題でした。 他のサーバーではDockerサービスがデプロイされておらず、そのためだけに私がよく使っており、時々コンテナでテスト用のサービスをデプロイすることもありましたが、このような状況に遭遇するとは思っていませんでした。その後、改めて考えると、グループ全体が同じオフィスビル内に存在し、IT部門の同僚がネットワークセグメントを区分けており、&lt;code&gt;172&lt;/code&gt;で始まるアドレスを使用することも不思議ではありませんでした。&lt;/p&gt;
&lt;h2 id=&#34;docker0&#34;&gt;docker0
&lt;/h2&gt;&lt;p&gt;サービスを再起動し、新しいネットワークに切り替えると、サーバーが正常にアクセスできるようになりました。&lt;/p&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://yeasy.gitbook.io/docker_practice/advanced_network/docker0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Docker入門から実践 - docker0&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Dockerの基礎を理解するための３つのポイント (または、Dockerの基本を学ぶための３つの要素)</title>
        <link>https://ttf248.life/ja/p/docker-two-three-things/</link>
        <pubDate>Thu, 21 Jan 2021 09:26:07 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/docker-two-three-things/</guid>
        <description>&lt;p&gt;長年携わってきたのはすべて&lt;code&gt;CentOS&lt;/code&gt;オペレーティングシステムであり、&lt;code&gt;mac&lt;/code&gt;ユーザーや&lt;code&gt;Ubuntu&lt;/code&gt;ユーザーの場合、一部の内容は適用できない。
一部のインストール手順については、清華大学の手順を参照してください：&lt;a class=&#34;link&#34; href=&#34;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;インストール&#34;&gt;インストール
&lt;/h2&gt;&lt;p&gt;未知の神秘的な力により、国内でのDockerのインストールには、クラウドプロバイダーが提供するレジストリのアドレスを設定することを推奨します。ここでは&lt;strong&gt;Alibaba Cloud&lt;/strong&gt;を使用することをお勧めします。&lt;/p&gt;
&lt;h3 id=&#34;リポジトリのソースアドレスを設定&#34;&gt;リポジトリのソースアドレスを設定
&lt;/h3&gt;&lt;h3 id=&#34;最新版をデプロイする&#34;&gt;最新版をデプロイする
&lt;/h3&gt;&lt;p&gt;Dockerは一般的なバックエンドサービスとして、起動時に自動的に開始するように設定することを推奨します。現在のコマンドはCentOS 7に適用されます。&lt;/p&gt;
&lt;h3 id=&#34;バージョン指定&#34;&gt;バージョン指定
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Kubernetes&lt;/code&gt;および&lt;code&gt;Docker&lt;/code&gt;のリリースは完全に同期されておらず、今後&lt;code&gt;Kubernetes&lt;/code&gt;をデプロイする場合は、&lt;code&gt;Kubernetes&lt;/code&gt;のデプロイ手順を参照し、指定バージョンの&lt;code&gt;Docker&lt;/code&gt;をインストールしてください。&lt;/p&gt;
&lt;h3 id=&#34;通常ユーザーのdocker権限の追加&#34;&gt;通常ユーザーのDocker権限の追加
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ダウンロード&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;日常使用-にちじょうしよう&#34;&gt;日常使用 (にちじょうしよう)
&lt;/h2&gt;&lt;h3 id=&#34;镜像加速&#34;&gt;镜像加速
&lt;/h3&gt;&lt;p&gt;依然存在不可知的神秘力量，导致拉取镜像的时候速度不给力。此时国内的云厂商站出来，提供了很多加速服务，依旧推荐一波&lt;strong&gt;阿里云&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;加速的地址请各位自行注册阿里云账号获取，此服务免费。阿里云也提供免费的镜像构建服务。&lt;/p&gt;
&lt;h3 id=&#34;推奨コントロールパネル&#34;&gt;推奨コントロールパネル
&lt;/h3&gt;&lt;h3 id=&#34;よく使われるミラーからの取得集&#34;&gt;よく使われるミラーからの取得集
&lt;/h3&gt;&lt;h3 id=&#34;常用コマンドの組み合わせ&#34;&gt;常用コマンドの組み合わせ
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/engine/reference/commandline/docker/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.docker.com/engine/reference/commandline/docker/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;コンテナの実行状態を確認し、&lt;code&gt;format&lt;/code&gt;パラメータを追加して詳細なコンテナ情報を表示（イメージ情報は無視）。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;すべてのコンテナをワンクリックで停止
すべてのイメージをワンクリックで削除&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;イメージのエクスポート
イメージのエクスポートと圧縮&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;イメージのインポート&lt;/p&gt;</description>
        </item>
        <item>
        <title>LinuxでJMeterの負荷テスト環境を構築する</title>
        <link>https://ttf248.life/ja/p/linux-setup-jmeter-testing-environment/</link>
        <pubDate>Tue, 22 Dec 2020 10:12:50 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-setup-jmeter-testing-environment/</guid>
        <description>&lt;p&gt;著者はハードウェアに強い関心を持ち、JMeterを用いて負荷テストを実施し、CentOS 7上にJMeter、InfluxDB、Grafanaをデプロイするプロセスを記録しました。JMeterのインストールとコマンドの使用方法、InfluxDBの特徴とDockerによるインストール方法、Grafanaの簡易的なデプロイと設定について共有しています。高性能プログラムモードに関する経験や参考資料についてもまとめました。&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;広く知られているように&lt;/code&gt;、私にはハードウェアに対する強い関心が持っており、テストグループが &lt;code&gt;JMeter&lt;/code&gt; を使用して負荷テストを行っている際、パフォーマンスが向上しないことを発見しました。好奇心旺盛な私は、会社の負荷テストの方法を試してみることに決意しました。また、ある頃合いにオープンソース中国で読んだ投稿「より洗練された高性能の負荷テストグラフを作成する方法」があり、&lt;code&gt;Windows&lt;/code&gt; バージョンでのテスト実行時に可視化された &lt;code&gt;TPS&lt;/code&gt; データの表示を実現していました。さらに、Web パネルを構成することでどのようなメリットがあるのでしょうか？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;頭の中で思いついたことは、当然のことばかりです。実際に試してみないとしかたないことを理解します
テスト作成とデバッグには GUI モードを使用しないでください！負荷テストには&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;背景-1&#34;&gt;背景
&lt;/h2&gt;&lt;p&gt;公式推奨されているのは、コマンドラインから負荷テストレポートを取得し、GUIで表示する方法ですが、データに誤差が含まれているという問題があります。JMeterの理解が十分ではないため、少なくとも&lt;code&gt;Linux&lt;/code&gt;版のコンソールパネルを弄り転げる理由を見つけたいと思います。&lt;/p&gt;
&lt;p&gt;開かれた中国（オープンチャイナ）の投稿では、コアコンポーネントのデプロイメント方法があまりにも友好的ではなく、インストールに必要なファイルは公众号を通じてダウンロードする必要があり、現代的な若者として、もちろん&lt;code&gt;Docker&lt;/code&gt;で代替します。要するに、自分のサーバーが国内であり、国境を越えたソースアドレスへのアクセス速度も遅いため、少なくともイメージサービスとしては、阿里云には無料の加速があります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker&lt;/code&gt; のインストールとデプロイメントについては、ここでは詳細な説明は省略し、以前の記事を参照してください。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;次の内容は、主に2つの領域に分かれています：基本的なテスト環境コンポーネントの構築、および各コンポーネントの簡単な認識の説明&lt;/p&gt;
&lt;h2 id=&#34;jmeter&#34;&gt;JMeter
&lt;/h2&gt;&lt;p&gt;Apache JMeter は Apache 組織が開発した Java ベースの負荷テストツールです。ソフトウェアに対して負荷テストを実施するために使用され、当初は Web アプリケーション テスト用に設計されましたが、その後、他のテスト分野にも拡張されました。 静的および動的なリソース（静的ファイル、Java 小サービスプログラム、CGI スクリプト、Java オブジェクト、データベース、FTP サーバーなど）をテストに使用できます。 JMeter は、さまざまなストレスカテゴリからの巨大な負荷をシミュレートして、サーバー、ネットワーク、またはオブジェクトの強度をテストし、全体的なパフォーマンスを分析するために使用できます。 さらに、JMeter はアプリケーションに対して機能/回帰テストを実行し、断言を含むスクリプトを作成することで、プログラムが期待どおりの結果を返すことを検証します。 最大限の柔軟性を実現するため、JMeter は正規表現を使用して断言を作成することを許可しています。 Apache JMeter は、静的なリソース（ファイル、Servlet、Perlスクリプト、Javaオブジェクト、データベースとクエリ、FTPサーバーなど）および動的なリソースのパフォーマンスをテストするために使用できます。 サーバー、ネットワーク、またはオブジェクトに対して、過酷な負荷をシミュレートし、それらの強度をテストしたり、異なる負荷タイプ下での全体的なパフォーマンスを分析したりすることができます。 パフォーマンスのグラフィカル分析や、大規模な同時実行負荷でサーバー/スクリプト/オブジェクトをテストするために使用できます。&lt;/p&gt;
&lt;h3 id=&#34;jmeter-のデプロイ-centos7&#34;&gt;JMeter のデプロイ (CentOS7)
&lt;/h3&gt;&lt;p&gt;JDK 実行環境のインストール、JMeter インストールパッケージのダウンロード
環境変数の設定&lt;/p&gt;
&lt;h3 id=&#34;jmeter-コマンド&#34;&gt;JMeter コマンド
&lt;/h3&gt;&lt;p&gt;最後に &lt;code&gt;Grafana&lt;/code&gt; パネルに接続し、&lt;code&gt;-l&lt;/code&gt; パラメータを入力する必要はありません。&lt;code&gt;web&lt;/code&gt; コンソールでデータを観察できます。&lt;/p&gt;
&lt;h2 id=&#34;influxdb&#34;&gt;InfluxDB
&lt;/h2&gt;&lt;p&gt;InfluxDBは、Go言語で記述されたオープンソースの分散型時系列、イベント、指標データベースです。外部依存なしで動作します。このデータベースは現在、大量の時間スタンプデータ（DevOpsモニタリングデータ、APPメトリクス、IoTセンサーデータ、リアルタイム分析データなど）を保存するために主に利用されています。&lt;/p&gt;
&lt;h3 id=&#34;influxdbの特徴&#34;&gt;InfluxDBの特徴
&lt;/h3&gt;&lt;p&gt;InfluxDBの特徴は、以下の9点にまとめられます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非構造化（非モデリング）：任意の数の列を格納できます。&lt;/li&gt;
&lt;li&gt;メトリクスの保存期間の設定が可能&lt;/li&gt;
&lt;li&gt;時間に関連する関数（min、max、sum、count、mean、medianなど）をサポートし、統計分析が容易です。&lt;/li&gt;
&lt;li&gt;ストアポリシーのサポート：データの更新や削除に使用できます。（InfluxDBはデータの削除や修正方法を提供していません。）&lt;/li&gt;
&lt;li&gt;連続クエリのサポート：データベース内で自動的にスケジュールされたSQL文群であり、ストアポリシーと組み合わせることでInfluxDBのシステム負荷を軽減できます。&lt;/li&gt;
&lt;li&gt;ネイティブなHTTPサポート、組み込みHTTP API&lt;/li&gt;
&lt;li&gt;SQLライクな構文のサポート&lt;/li&gt;
&lt;li&gt;クラスタ内のデータのレプリカ数を設定可能&lt;/li&gt;
&lt;li&gt;定期的なサンプリングによるデータ書き込みをサポートし、別のmeasurementにデータを格納することで、粒度ごとのデータストレージが可能です。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;インフュージョンdb-docker-へのインストール&#34;&gt;インフュージョンDB Docker へのインストール
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;docker exec -it influxdb /bin/bash&lt;/code&gt; でコンテナに入り、コマンドを実行して、手動でデータベースを作成します。&lt;/p&gt;
&lt;h3 id=&#34;influxdbデータベースとユーザーの作成&#34;&gt;InfluxDBデータベースとユーザーの作成
&lt;/h3&gt;&lt;p&gt;データベースの作成: &lt;code&gt;create database jmeter_t2&lt;/code&gt;
データベースの表示: &lt;code&gt;show databases&lt;/code&gt;
データベースへの切り替え: &lt;code&gt;use jmeter_t2&lt;/code&gt;
ユーザーの作成: &lt;code&gt;create user &amp;quot;admin&amp;quot; with password &#39;admin&#39; with all privileges&lt;/code&gt;
ユーザーの表示: &lt;code&gt;show users&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;もしユーザー権限が&lt;code&gt;admin&lt;/code&gt;に&lt;code&gt;true&lt;/code&gt;と表示されれば、データベースの準備は完了です。&lt;/p&gt;
&lt;h2 id=&#34;grafana&#34;&gt;Grafana
&lt;/h2&gt;&lt;p&gt;テストケースの作成時に、グラフによる表現はあまり必要ないことが判明しました。インターフェースの &lt;code&gt;tps&lt;/code&gt; データはコマンドラインで実行するだけで観測できるため、主にプログラム内部の処理時間を確認したいと考えています。&lt;/p&gt;
&lt;p&gt;簡易的に &lt;code&gt;grafana&lt;/code&gt; のコンソールパネルをデプロイし、InfluxDB と連携するための設定ファイルをインポートします。&lt;/p&gt;
&lt;p&gt;コンソールではラベルによるフィルタリングでテスト結果を確認できます。通常は 1 つの InfluxDB データベースを設定するだけで十分です：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アプリケーション名&lt;/li&gt;
&lt;li&gt;テストケース名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/linux-setup-jmeter-testing-environment/Snipaste_2021-03-09_19-44-22.png&#34;
	width=&#34;861&#34;
	height=&#34;357&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;grafana&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;241&#34;
		data-flex-basis=&#34;578px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;ウェブ版ではサンプリング間隔が原因で、計算された &lt;code&gt;TPS&lt;/code&gt; と関連する数値が JMeter の集計レポートと一致しません。参考リンク：&lt;a class=&#34;link&#34; href=&#34;https://www.vinsguru.com/jmeter-real-time-results-influxdb-grafana/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.vinsguru.com/jmeter-real-time-results-influxdb-grafana/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;資料には、リスナーのカスタム設定方法も記載されています。&lt;/p&gt;
&lt;h2 id=&#34;付録&#34;&gt;付録
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;高性能のプログラムパターンは必然的にone loop threadであり、ロック、入隊列、出隊列などのものは不必要なパフォーマンス損失をもたらす。&lt;/li&gt;
&lt;li&gt;核心ビジネスロジックの実行時間が、他のコードを導入する時間よりも大きい場合、並行処理が効率を向上させる効果を発揮し、コアな実行時間が十分に小さい場合は慎重に他のコードを導入すべきである。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考資料&#34;&gt;参考資料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://my.oschina.net/u/4617935/blog/4680856&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;JMeterシリーズのJMeter+Grafana+InfluxDB リアルタイム監視&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/_/influxdb&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;influxdb 公式イメージ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/r/grafana/grafana&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;grafana 公式イメージ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://jmeter.apache.org/download_jmeter.cgi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;JMeter 公式サイト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@jasonli.studio/to-install-apache-jmeter-in-centos7-294bc72a97ba&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CentOS7にApache JMeterをインストールする方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
