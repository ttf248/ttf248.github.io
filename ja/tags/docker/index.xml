<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Docker on 向叔の手帳</title>
        <link>https://ttf248.life/ja/tags/docker/</link>
        <description>Recent content in Docker on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Mon, 02 Jun 2025 20:54:02 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/tags/docker/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>AI開発2年：ドッカーのリリース前の状態に似ている</title>
        <link>https://ttf248.life/ja/p/ai-development-two-years-like-docker-pre-release/</link>
        <pubDate>Thu, 20 Feb 2025 18:16:37 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/ai-development-two-years-like-docker-pre-release/</guid>
        <description>&lt;p&gt;人工知能（AI）は近年、技術分野で最も議論を呼ぶトピックの一つであり、特に過去2年間でその進歩は目覚ましいものがありました。深層学習、自然言語処理、コンピュータビジョン、自動化意思決定システムなど、AIの応用範囲は多岐にわたります。しかしながら、技術が着実に進化を続けているにもかかわらず、AIはDockerのリリース前のボトルネックに似た状況にあります――つまり、市場を本格的に引き出す「ゲームチェンジャー」となるような、決定的なアプリケーションが存在しないのです。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;プロンプト：記事を作成してください：AIは過去2年間で発展し、Dockerのリリース前のボトルネックのような状態になっています。既存技術に基づいて、完璧な実用例を作り出し、Dockerはあまり新しい技術を使用していませんが、全体的なソリューションが合理的に、運用および開発ワークフローを変革します。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;aiの現状技術は成熟しているが応用には突破が必要&#34;&gt;AIの現状：技術は成熟しているが、応用には突破が必要
&lt;/h2&gt;&lt;p&gt;技術的な側面から見ると、AIは過去2年間で相当な進歩を遂げました。OpenAIが発表したGPTシリーズモデルや、GoogleのBERT、DeepMindのAlphaシリーズなど、AIの処理能力は以前の予測を大幅に上回っています。特に自然言語処理分野では、GPT-4などのモデルが強力な生成能力に加え、理解と推論においても驚くべきパフォーマンスを示しています。&lt;/p&gt;
&lt;p&gt;しかしながら、技術革新は日進月歩であるにもかかわらず、AIの実用的な応用においてはいくつかの課題が残されています。Dockerのリリース前の状況に似ており、AIの潜在力は巨大ですが、現状では広く普及し、産業を変革するほどの「破壊的イノベーション」をもたらす主要なアプリケーションが登場していません。人々はAIの将来について議論していますが、必ずしも革命的な変化をもたらす直接的な応用シナリオを見つけるとは限りません。多くのAIアプリケーションはまだ初期段階の試みにとどまり、大部分はさらなる統合と最適化が必要です。&lt;/p&gt;
&lt;h2 id=&#34;dockerとaiの類似性技術は必ずしも革新ではなく解決策が重要&#34;&gt;DockerとAIの類似性：技術は必ずしも革新ではなく、解決策が重要
&lt;/h2&gt;&lt;p&gt;Dockerリリース前の歴史を振り返ると、技術環境とAIの現状には多くの類似点が見られることに気づきます。Dockerリリース前に、コンテナ技術自体が新しいものではありませんでした。初期のLXC（Linux Containers）や仮想化技術も、コンテナ化の基本的な能力を持っていました。しかし、Dockerは既存技術を巧みに統合・最適化することで、よりシンプルで直感的かつ効率的な解決策を提示しました。この解決策は、画期的な技術を導入したわけではありませんが、運用および開発プロセスにおける多くの課題を解決し、ソフトウェアのデプロイ、拡張、管理プロセスの大幅な簡素化を実現しました。&lt;/p&gt;
&lt;p&gt;同様に、AI分野も類似の状況に直面しています。現在のAI技術は、もはや「新鮮なもの」ではありませんが、大規模なアプリケーションを実現するためには、完璧な実行環境が必要であり、Dockerのように既存技術を統合・最適化して、合理的なアプリケーション解決策を形成することが重要です。AIのゲームチェンジャーとなるアプリケーションは、必ずしも新しい技術のブレークスルーに依存するのではなく、既存技術を組み合わせて、実際のビジネスにおける課題やニーズを解決することにある可能性があります。&lt;/p&gt;
&lt;h2 id=&#34;aiのdocker-momentドッカーmomentを見つける方法&#34;&gt;AIの「Docker Moment」（ドッカーMoment）を見つける方法
&lt;/h2&gt;&lt;p&gt;AI技術を広く普及させるためには、いくつかの側面から取り組む必要があります。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;実用シナリオの深掘り&lt;/strong&gt;
現在の多くのAIアプリケーションは実験的な性質が強く、大規模な実用化には至っていません。AI客服やレコメンデーションなどの分野は広く利用されていますが、その機能はまだ多くの場合、業界のボトルネックを突破していません。真のブレイクスルーは、従来のやり方に困っている業界から生まれる可能性があります。例えば、医療、製造業、物流などの分野では、AIがより効率的なデータ処理と予測分析を通じて、企業がこれらの複雑なシナリオで効率を高め、コストを削減するのを支援できます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;製品化と使いやすさ&lt;/strong&gt;
Dockerのようにコンテナ化プロセスを簡素化し運用効率を向上させるのと同様に、AI製品の使いやすさは非常に重要です。AIの普及は技術の普及だけでなく、その製品化の普及でもあります。AIを日常業務フローに統合し、ユーザーが技術的な理解なしにこれらのツールを簡単に利用できるようにすることは、AIの実用化における重要なステップです。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;エコシステムの構築と標準化&lt;/strong&gt;
いかなる新技術も広く普及するためには、エコシステムの構築が不可欠です。Dockerが急速に台頭したのも、そのオープン性と互換性によるものであり、開発者がさまざまなクラウドプラットフォーム、ツール、サービスと簡単に連携できるようになったからです。同様に、AIの未来はエコシステムの構築に依存します。AIの標準化、モデルの共有、データのオープン、技術の統合可能性などが、AIが広範な産業応用を達成する上で重要な要素となります。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;結論aiの未来は可能性に満ちているが更なる完善な落とし所を必要とする&#34;&gt;結論：AIの未来は可能性に満ちているが、更なる完善な落とし所を必要とする
&lt;/h2&gt;&lt;p&gt;過去2年間にわたり、AI技術は目覚ましい進歩を遂げているものの、現状では「決定的な応用例」が存在しない段階にある。Dockerがリリース前のコンテナ化技術と同様に、AIには合理的な適用シナリオが必要であり、既存の技術とビジネスニーズを深く融合させることで初めて、大規模な応用と普及を実現できる。技術革新は確かに重要だが、業務プロセスを簡素化し、効率を高めるソリューションこそが、技術の普及と発展を促進するだろう。&lt;/p&gt;
&lt;p&gt;未来において、AIはDockerのように、画期的な技術的ブレークスルーではなく、既存技術を統合し、完璧な適用シナリオを構築することで、私たちの仕事や生活様式を変革していく可能性がある。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Docker 国内イメージプロキシが失敗しました。</title>
        <link>https://ttf248.life/ja/p/docker-domestic-image-proxy-failure/</link>
        <pubDate>Sat, 04 Jan 2025 18:29:25 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/docker-domestic-image-proxy-failure/</guid>
        <description>&lt;p&gt;国内サーバーへのDockerデプロイで、会社がレジストリを提供していない場合、開発者が最初にやるべきことは、国内のレジストリミラーを設定することです。&lt;/p&gt;
&lt;p&gt;幸いにも今日、サーバー1台にミラー設定を行いましたが、イメージの取得中に常に取得できないという問題が発生しました。&lt;/p&gt;
&lt;p&gt;エラーメッセージ：&lt;code&gt;Error response from daemon: Get &amp;quot;https://registry-1.docker.io/v2/&amp;quot;: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2025年1月6日、隔日のうちにすべてのサーバーが復旧しました。この件は全く話題にならないとは信じられない。国内のすべてのレジストリミラーがダウンしていたのです&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;障害の切り分けと修復試行&#34;&gt;障害の切り分けと修復試行
&lt;/h2&gt;&lt;p&gt;当初、他のミラー加速アドレスに切り替えて問題を解決することを期待したが、予想とは裏腹に問題は依然として発生し続けた。&lt;/p&gt;
&lt;p&gt;次に、ローカルDNS設定を修正して、ネットワーク解析の側面から突破口を探ることを試みたが、結局、ある程度のデバッグを行った結果も、障害は解消されなかった。&lt;/p&gt;
&lt;p&gt;この時点で、ローカルネットワークの安定性が大きく疑われるようになり、そこで断念なく携帯電話のテザリングに切り替えて、潜在的なローカルネットワーク障害を回避することを試みた。しかし、結果は失望であり、問題の改善の兆候は見られなかった。&lt;/p&gt;
&lt;h2 id=&#34;問題の蔓延&#34;&gt;問題の蔓延
&lt;/h2&gt;&lt;p&gt;現在、国内に&lt;strong&gt;数台のサーバーがデプロイされており、すべてDocker環境がインストールされています&lt;/strong&gt;。これらのサーバーからイメージをプルすることを試みましたが、例外なく失敗し、返ってくるエラーメッセージも一様です。これは問題が特定のデバイスに限られたものではなく、広範囲に及んでいることを示唆しています。&lt;/p&gt;
&lt;p&gt;さらに調査した結果、イメージレポジトリのプロキシが瞬く間に停止していることが判明しました。この緊迫した状況下で、迅速に海外のサーバーを使用して試みましたが、幸いにもイメージのプルは正常に戻りました。これは問題が国内のネットワークリンクまたは関連設定にある可能性が高いことを意味します。&lt;/p&gt;
&lt;h2 id=&#34;戦略修正迂回戦術&#34;&gt;戦略修正：迂回戦術
&lt;/h2&gt;&lt;p&gt;国内での直接リポジトリ取得の経路が重く制限される中、海外のリポジトリは正常にアクセスできる状況を鑑み、プロジェクトを迅速に進めるため、迂回戦術を採用することにしました。まず、国外サーバーに切り替えて必要なイメージを取得し、その後、国内イメージレジストリにプッシュすることで、「データブリッジ」を構築します。
同時に、Dockerfileファイルに対しても修正を行い、イメージのURLを国内環境に適したアドレスに変更してから再ビルドを実行し、最終的に成功裏にデプロイしました。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>オフィスへの引っ越しにより、サーバーにアクセスできなくなりました。</title>
        <link>https://ttf248.life/ja/p/office-move-server-inaccessible/</link>
        <pubDate>Sat, 11 Mar 2023 01:42:05 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/office-move-server-inaccessible/</guid>
        <description>&lt;p&gt;行政通知、オフィス配置の変更（元の2階から15階への移動）、通常の事務室の移転&lt;/p&gt;
&lt;h2 id=&#34;デザインセンス&#34;&gt;デザインセンス
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/office-move-server-inaccessible/20230311014537.png&#34;
	width=&#34;511&#34;
	height=&#34;916&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;オフィスビル&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;55&#34;
		data-flex-basis=&#34;133px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;移住&#34;&gt;移住
&lt;/h2&gt;&lt;p&gt;荷造り、スムーズな進路、新しい作業場所でのPCの配線整理、心地よい姿勢で仕事を開始
(ÒωÓױ)！、ネットワークケーブルを接続し、チームメンバーがよく使うサーバーにアクセスできなくなりました。無線LANに切り替えてみましたが、正常に戻りました。
当初はサーバーのIPアドレス設定の問題だと思っていました。新しい作業場所の有線LANは、ファイアウォール設定のリストに含まれていませんでした。IT担当者に連絡して調整したら解決しました。このIPアドレス範囲は、他のサーバーにも使用されており、他のサーバーにアクセスしても正常でした。徐々に疑問が生じ始めました。専門的なことは専門家に任せるべきです。最終的に運用部門の同僚が特定し、このサーバーに&lt;code&gt;docker&lt;/code&gt;がデプロイされているため、サービスのデフォルトネットワーク&lt;code&gt;docker0&lt;/code&gt;とオフィスLANの設定IPアドレス範囲が競合してしまい、送信したデータパケットを受信できなくなり、ルーティングされて&lt;code&gt;docker&lt;/code&gt;サービスに渡りました。
他のサーバーには&lt;code&gt;docker&lt;/code&gt;サービスがデプロイされていないため、このサーバーだけでした。私がよく使うので、時々コンテナを使用してテストサービスをデプロイすることがありましたが、このような状況に遭遇したとは思いませんでした。後から考えると、グループ全体が同じオフィスビル内に存在しているため、IT部門の同僚がIPアドレス範囲を割り当てたことは珍しくありません。&lt;/p&gt;
&lt;h2 id=&#34;docker0&#34;&gt;docker0
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# vim /etc/docker/daemon.json
{
    &amp;quot;bip&amp;quot;:&amp;quot;172.200.0.1/24&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;サービスを再起動し、新しいネットワークに切り替えると、サーバーが正常にアクセスできるようになりました。&lt;/p&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://yeasy.gitbook.io/docker_practice/advanced_network/docker0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Docker入門から実践 - docker0&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Dockerの基礎を理解するための３つのポイント (または、Dockerの基本を理解するための３つのこと)</title>
        <link>https://ttf248.life/ja/p/docker-two-three-things/</link>
        <pubDate>Thu, 21 Jan 2021 09:26:07 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/docker-two-three-things/</guid>
        <description>&lt;p&gt;長年携わってきたのは &lt;code&gt;CentOS&lt;/code&gt; オペレーティングシステムであり、&lt;code&gt;mac&lt;/code&gt; ユーザーや &lt;code&gt;Ubuntu&lt;/code&gt; ユーザーの場合、一部の内容は適用できない。
インストールに関する部分は、清華大学のドキュメントを参照するのが参考になる：&lt;a class=&#34;link&#34; href=&#34;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;インストール&#34;&gt;インストール
&lt;/h2&gt;&lt;p&gt;未知の神秘的な力により、国内でのDockerのインストールには、クラウドプロバイダーが提供するレジストリのアドレスを設定することを推奨します。ここでは&lt;strong&gt;Alibaba Cloud&lt;/strong&gt;を使用することをお勧めします。&lt;/p&gt;
&lt;h3 id=&#34;リポジトリソースの設定&#34;&gt;リポジトリソースの設定
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install yum-utils device-mapper-persistent-data lvm2 &amp;amp;&amp;amp; \
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;最新版のインストール&#34;&gt;最新版のインストール
&lt;/h3&gt;&lt;p&gt;Dockerは一般的なバックエンドサービスとして、起動時に自動で開始されるように設定することを推奨します。以下のコマンドはCentOS 7向けです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum install -y docker-ce docker-ce-cli containerd.io &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;指定バージョン展開&#34;&gt;指定バージョン展開
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;kubernetes&lt;/code&gt;および&lt;code&gt;docker&lt;/code&gt;のリリースは完全に同期されておらず、今後&lt;code&gt;kubernetes&lt;/code&gt;を展開する場合は、&lt;code&gt;kubernetes&lt;/code&gt;展開手順を参照し、指定バージョンの&lt;code&gt;docker&lt;/code&gt;をインストールしてください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum list docker-ce --showduplicates | sort -r
sudo yum install -y docker-ce-18.09.2-3.el7 docker-ce-cli-18.09.2-3.el7 containerd.io-18.09.2-3.el7 &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;通常ユーザーにdocker権限を追加する&#34;&gt;通常ユーザーにDocker権限を追加する
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo usermod -aG docker ${USER}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;卸載&#34;&gt;卸載
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum remove -y docker-ce docker-ce-cli containerd.io
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;日常使用-にちじょうしよう&#34;&gt;日常使用 (にちじょうしよう)
&lt;/h2&gt;&lt;h3 id=&#34;镜像加速&#34;&gt;镜像加速
&lt;/h3&gt;&lt;p&gt;未知の神秘的な力により、イメージの取得時に速度が低下することがあります。この問題を解決するために、国内のクラウドプロバイダーが多くの加速サービスを提供し、引き続き&lt;strong&gt;阿里云&lt;/strong&gt;を推奨します。&lt;/p&gt;
&lt;p&gt;加速用のURLは、ご自身の登録した阿里云アカウントで取得してください。このサービスは無料で利用でき、阿里云からは無料のイメージ構築サービスも提供されています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt; /etc/docker/daemon.json &amp;lt;&amp;lt;EOF
{
  &amp;quot;registry-mirrors&amp;quot;: [
    &amp;quot;https://docker.nju.edu.cn&amp;quot;,
    &amp;quot;https://mirror.baidubce.com&amp;quot;,
    &amp;quot;https://docker.m.daocloud.io&amp;quot;,
    &amp;quot;https://docker.mirrors.sjtug.sjtu.edu.cn&amp;quot;
  ]
}
EOF
systemctl daemon-reload &amp;amp;&amp;amp; \
systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;強く推奨されるコントロールパネル&#34;&gt;強く推奨されるコントロールパネル
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker volume create portainer_data &amp;amp;&amp;amp; \
docker run -d --name=portainer --restart=always -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:2.20.3-alpine
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;常用イメージの取得集&#34;&gt;常用イメージの取得集
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker pull rancher/rancher:stable &amp;amp;&amp;amp; docker pull portainer/portainer-ce:2.0.1 &amp;amp;&amp;amp; \
docker pull centos:7 &amp;amp;&amp;amp; docker pull ubuntu:20.04 &amp;amp;&amp;amp; docker pull ubuntu:18.04 &amp;amp;&amp;amp; \
docker pull redis:5 &amp;amp;&amp;amp; docker pull redis:6 &amp;amp;&amp;amp; \
docker pull alpine:3.11 &amp;amp;&amp;amp; docker pull busybox:1.32 &amp;amp;&amp;amp; \
docker pull rabbitmq:3.7-management &amp;amp;&amp;amp; \
docker pull mariadb:10.2 &amp;amp;&amp;amp; \
docker pull nginx:1.18 &amp;amp;&amp;amp; docker pull nginx:1.19 &amp;amp;&amp;amp; \
docker pull mysql:5.6 &amp;amp;&amp;amp; docker pull mysql:8 &amp;amp;&amp;amp; \
docker pull elasticsearch:6.8.11 &amp;amp;&amp;amp; docker pull logstash:6.8.11 &amp;amp;&amp;amp; docker pull kibana:6.8.11 &amp;amp;&amp;amp; \
docker pull zookeeper:3.4 &amp;amp;&amp;amp; \
docker pull influxdb:1.7 &amp;amp;&amp;amp; docker pull grafana/grafana:7.3.1 &amp;amp;&amp;amp; \
docker pull percona:8 &amp;amp;&amp;amp; docker pull percona:5.6 &amp;amp;&amp;amp; \
docker pull cloverzrg/frps-docker:0.34.3 &amp;amp;&amp;amp; docker pull cloverzrg/frpc-docker:0.34.3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;常用コマンドの組み合わせ&#34;&gt;常用コマンドの組み合わせ
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/engine/reference/commandline/docker/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.docker.com/engine/reference/commandline/docker/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;コンテナの実行状態を確認し、&lt;code&gt;format&lt;/code&gt;パラメータを追加して詳細なコンテナ情報を取得（イメージ情報は無視）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker ps --format &amp;quot;{{.Names}}: {{.Ports}}: {{.Size}}&amp;quot;
#portainer: 0.0.0.0:8000-&amp;gt;8000/tcp, 0.0.0.0:9000-&amp;gt;9000/tcp: 0B (virtual 172MB)
#influxdb: 0.0.0.0:8086-&amp;gt;8086/tcp: 183B (virtual 311MB)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;すべてのコンテナをワンクリックで停止&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker stop $(docker ps -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;すべてのイメージをワンクリックで削除&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dokcer rmi $(docker images -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;イメージのエクスポート&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; &amp;gt; -o XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;イメージをエクスポートして圧縮&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; | gzip &amp;gt; XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;イメージをインポート&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker load -i XXX.tar
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>LinuxでJMeterの負荷テスト環境を構築する</title>
        <link>https://ttf248.life/ja/p/linux-setup-jmeter-testing-environment/</link>
        <pubDate>Tue, 22 Dec 2020 10:12:50 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-setup-jmeter-testing-environment/</guid>
        <description>&lt;p&gt;著者はハードウェアに強い関心を持ち、JMeterを用いて負荷テストを実施し、CentOS 7上にJMeter、InfluxDB、Grafanaをデプロイするプロセスを記録しました。JMeterのインストールとコマンドの使用方法、InfluxDBの特徴とDockerによるインストール方法、Grafanaの簡易的なデプロイと設定について共有しています。高性能プログラムモードに関する経験や参考資料をまとめました。&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;広く知られているように&lt;/code&gt;、私にはハードウェアに対する強い関心が持っており、テストグループが &lt;code&gt;JMeter&lt;/code&gt; を使用して負荷テストを行っている際に、パフォーマンスが向上しないことを発見しました。好奇心旺盛な私は、会社の負荷テストの方法を試してみることに決意しました。また、ある頃合いにオープンソース中国で、より洗練された高性能のパフォーマンス測定グラフを作成する方法に関する投稿を読んだことがあります。&lt;code&gt;Windows&lt;/code&gt;版でのテスト実行時に、可視化された &lt;code&gt;TPS&lt;/code&gt; データの表示を実現しており、Webパネルを設定することでどのような効果があるのか疑問に思っていました。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;頭の中で思いついたのは、当然のことばかりです。実際に試してみないとしかたないことを理解します。
負荷テストには GUI モードを使用しないでください！ テスト作成とデバッグのみに使用してください。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;背景-1&#34;&gt;背景
&lt;/h2&gt;&lt;p&gt;公式推奨は、コマンドラインで負荷テストレポートを取得し、GUIで表示する方法ですが、データに誤差が含まれているという問題があります。JMeterの理解が十分ではないため、少なくとも&lt;code&gt;Linux&lt;/code&gt;版のコンソールパネルを弄り転げる理由を見つけたいと思います。&lt;/p&gt;
&lt;p&gt;開かれた中国（オープンチャイナ）の投稿では、コアコンポーネントのデプロイメント方法があまりにも友好的ではなく、インストールに必要なファイルは公众号を通じてダウンロードする必要があり、現代的な若者として、もちろん&lt;code&gt;Docker&lt;/code&gt;で代替します。要するに、サーバーは国内であり、国境を越えたソースアドレスへのアクセス速度が遅いため、少なくともイメージサービスとしては、阿里云には無料の加速があります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker&lt;/code&gt; のインストールとデプロイメントについては、ここでは詳細な説明を省略し、以前の記事を参照してください。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;次の内容は、2つの主要な領域に分かれています：基本的なテスト環境コンポーネントの構築、および各コンポーネントの簡単な認識の説明&lt;/p&gt;
&lt;h2 id=&#34;jmeter&#34;&gt;JMeter
&lt;/h2&gt;&lt;p&gt;Apache JMeterはApache組織が開発したJavaベースの負荷テストツールです。ソフトウェアに対する負荷テストに使用され、当初はWebアプリケーションのテスト用に設計されましたが、その後、他のテスト分野にも拡張されています。静的および動的なリソース（静的ファイル、Java小型サービスプログラム、CGIスクリプト、Javaオブジェクト、データベース、FTPサーバーなど）をテストするために使用できます。JMeterは、さまざまな負荷カテゴリからの巨大な負荷をシミュレートして、それらの強度をテストし、全体的なパフォーマンスを分析するために使用できます。さらに、JMeterはアプリケーションの機能/回帰テストに使用でき、断言を含むスクリプトを作成することで、プログラムが期待どおりの結果を返していることを検証します。最大限の柔軟性のため、JMeterは正規表現を使用して断言を作成することを許可しています。&lt;/p&gt;
&lt;p&gt;Apache jmeter は、静的および動的なリソース（ファイル、Servlet、Perlスクリプト、Java オブジェクト、データベースとクエリ、FTPサーバーなど）のパフォーマンスをテストするために使用できます。 サーバー、ネットワーク、またはオブジェクトに過剰な負荷をシミュレートして、それらの強度をテストしたり、さまざまなストレスタイプの下での全体的なパフォーマンスを分析したりすることができます。 大規模な同時負荷テストでサーバー/スクリプト/オブジェクトのパフォーマンスを分析したり、グラフィカルなパフォーマンス分析を行ったりするために使用できます。&lt;/p&gt;
&lt;h3 id=&#34;jmeter-導入-centos7&#34;&gt;Jmeter 導入 CentOS7
&lt;/h3&gt;&lt;p&gt;JDK の実行環境をインストールし、JMeter のインストールパッケージをダウンロードします。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install java-1.8.0-openjdk -y &amp;amp;&amp;amp; \
wget https://mirrors.bfsu.edu.cn/apache//jmeter/binaries/apache-jmeter-5.4.tgz &amp;amp;&amp;amp; tar -xf apache-jmeter-5.4.tgz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;環境変数を設定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export JMETER_HOME=$HOME/jmeter/apache-jmeter-5.4
export PATH=$JMETER_HOME/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;jmeter-コマンド&#34;&gt;JMeter コマンド
&lt;/h3&gt;&lt;p&gt;最後に &lt;code&gt;Grafana&lt;/code&gt; ダッシュボードに送信し、&lt;code&gt;-l&lt;/code&gt; パラメータを入力しなくても、&lt;code&gt;web&lt;/code&gt; コンソールでデータを観察できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;jmeter -n -t /tmp/order-500-10s.jmx -l /tmp/jmeter-order-report-20200109/order-500-10s.jtl
# 通常、テスト結果とテストレポートは省略し、コマンドを簡略化します。
jmeter -n -t /tmp/order-500-10s.jmx
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;influxdb&#34;&gt;InfluxDB
&lt;/h2&gt;&lt;p&gt;InfluxDBは、Go言語で記述されたオープンソースの分散型時系列、イベント、指標データベースです。外部依存なしで動作します。このデータベースは現在、大量の時間スタンプデータ（DevOpsモニタリングデータ、APPメトリクス、IoTセンサーデータ、リアルタイム分析データなど）を保存するために主に利用されています。&lt;/p&gt;
&lt;h3 id=&#34;influxdbの特徴&#34;&gt;InfluxDBの特徴
&lt;/h3&gt;&lt;p&gt;InfluxDBの特徴は、以下の9点にまとめられます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非構造化（非モデリング）：任意の数の列を含めることができます。&lt;/li&gt;
&lt;li&gt;メトリクスの保存期間を設定できます。&lt;/li&gt;
&lt;li&gt;時間に関連する関数（min、max、sum、count、mean、medianなど）をサポートし、統計分析が容易です。&lt;/li&gt;
&lt;li&gt;ストアポリシーのサポート：データの削除および変更に使用できます。（InfluxDBはデータの削除と変更の方法を提供していません。）&lt;/li&gt;
&lt;li&gt;連続クエリのサポート：データベース内で自動的にスケジュールされたステートメントのセットであり、ストアポリシーと組み合わせてInfluxDBのシステム使用量を削減できます。&lt;/li&gt;
&lt;li&gt;ネイティブなHTTPサポート、組み込みHTTP API。&lt;/li&gt;
&lt;li&gt;SQLライクな構文をサポート。&lt;/li&gt;
&lt;li&gt;クラスタ内のデータのレプリカ数を設定できます。&lt;/li&gt;
&lt;li&gt;定期的なサンプリングデータによる別の測定項目の書き込みをサポートし、粒度ごとのデータを保存できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;influxdb-docker-インストール&#34;&gt;InfluxDB Docker インストール
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir influxdb &amp;amp;&amp;amp; cd influxdb &amp;amp;&amp;amp; \
docker run -p 8086:8086 -d --name influxdb -v $PWD:/var/lib/influxdb influxdb:1.7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker exec -it influxdb /bin/bash&lt;/code&gt; でコンテナに入り、コマンドを実行し、手動でデータベースを作成&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;root@bce0a55bbc72:/# influx
http://localhost:8086 への接続、バージョン 1.7.10
InfluxDB シェル バージョン：1.7.10
&amp;gt; 対話式パネルでコマンドを実行
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;influxdbデータベースとユーザーの作成&#34;&gt;InfluxDBデータベースとユーザーの作成
&lt;/h3&gt;&lt;p&gt;データベースの作成: &lt;code&gt;create database jmeter_t2&lt;/code&gt;
データベースの表示: &lt;code&gt;show databases&lt;/code&gt;
データベースの切り替え: &lt;code&gt;use jmeter_t2&lt;/code&gt;
ユーザーの作成: &lt;code&gt;create user &amp;quot;admin&amp;quot; with password &#39;admin&#39; with all privileges&lt;/code&gt;
ユーザーの表示: &lt;code&gt;show users&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; show users
user  admin
----  -----
admin true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ユーザー権限が&lt;code&gt;admin&lt;/code&gt;で&lt;code&gt;true&lt;/code&gt;と表示されれば、データベースの準備は完了です。&lt;/p&gt;
&lt;h2 id=&#34;grafana&#34;&gt;Grafana
&lt;/h2&gt;&lt;p&gt;テストケースの作成時に、グラフによる表現はあまり必要ないことがわかりました。インターフェースの &lt;code&gt;tps&lt;/code&gt; データのコマンドライン実行で十分観測できます。むしろ、プログラム内部の処理時間を確認したいと考えています。&lt;/p&gt;
&lt;p&gt;Grafana の簡易的なコンソールパネルをデプロイし、InfluxDB と連携するための設定ファイルをインポートします。&lt;/p&gt;
&lt;p&gt;コンソールはラベルによるフィルタリングをサポートしており、通常は 1 つの InfluxDB データベースを設定するだけで済みます：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アプリケーション名&lt;/li&gt;
&lt;li&gt;テストケース名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/linux-setup-jmeter-testing-environment/Snipaste_2021-03-09_19-44-22.png&#34;
	width=&#34;861&#34;
	height=&#34;357&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;grafana&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;241&#34;
		data-flex-basis=&#34;578px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -d --name=grafana -p 3000:3000 grafana/grafana:7.3.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ブラウザ版ではサンプリング間隔により、計算された &lt;code&gt;TPS&lt;/code&gt; や関連数値が JMeter の集計レポートと一致しないため、参照リンク：&lt;a class=&#34;link&#34; href=&#34;https://www.vinsguru.com/jmeter-real-time-results-influxdb-grafana/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.vinsguru.com/jmeter-real-time-results-influxdb-grafana/&lt;/a&gt; を参考にしています。&lt;/p&gt;
&lt;p&gt;資料には、リスナーのカスタム設定方法も記載されています。&lt;/p&gt;
&lt;h2 id=&#34;付録&#34;&gt;付録
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;高性能のプログラムパターンは、必然的にone loop threadであるべきであり、ロック、入隊列、出隊列などのものは、不必要なパフォーマンス損失を引き起こす&lt;/li&gt;
&lt;li&gt;核心ビジネスロジックの実行時間が、他のコードを導入する時間よりも大きい場合のみ、並行処理が有効に効率を向上させることができ、コアな実行時間が十分に小さい場合は、慎重に他のコードを導入すべき&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考資料&#34;&gt;参考資料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://my.oschina.net/u/4617935/blog/4680856&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;JMeterシリーズのJMeter+Grafana+InfluxDB リアルタイム監視&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/_/influxdb&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;influxdb 公式イメージ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/r/grafana/grafana&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;grafana 公式イメージ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://jmeter.apache.org/download_jmeter.cgi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;JMeter 公式サイト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@jasonli.studio/to-install-apache-jmeter-in-centos7-294bc72a97ba&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CentOS7にApache JMeterをインストールする方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
