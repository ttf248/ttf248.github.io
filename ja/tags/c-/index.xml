<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>C&#43;&#43; on 向叔の手帳</title>
        <link>https://blog.ttf248.life/ja/tags/c-/</link>
        <description>Recent content in C&#43;&#43; on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Wed, 28 May 2025 09:47:38 +0800</lastBuildDate><atom:link href="https://blog.ttf248.life/ja/tags/c-/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>C&#43;&#43; ビット演算の基礎：ビットごとの値の取得とフラグ設定</title>
        <link>https://blog.ttf248.life/ja/p/cpp-bitwise-operations-basics-flags/</link>
        <pubDate>Fri, 17 Jan 2025 02:23:56 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ja/p/cpp-bitwise-operations-basics-flags/</guid>
        <description>&lt;p&gt;実際のC++開発において、ビット演算は一般的な技術であり、特にシステム状態、フラグ、または制御ビットを扱う際には、非常に効率的な解決策を提供します。本稿では、例を通して、ビット演算を使用して特定のフラグを取得および設定する方法について解説します。&lt;/p&gt;
&lt;h3 id=&#34;ビット演算の基本概念&#34;&gt;ビット演算の基本概念
&lt;/h3&gt;&lt;p&gt;コンピュータでは、データは2進数のビット（0と1）で保存されます。ビット演算とは、これらの2進数ビットに対して行う操作のことです。C++にはいくつかの一般的なビット演算子があります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;按位与（&amp;amp;）&lt;/strong&gt;: あるビットが1であるかを確認するためのもの。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按位或（|）&lt;/strong&gt;: あるビットを1に設定する。&lt;/li&gt;
&lt;li&gt;反転操作用。&lt;/li&gt;
&lt;li&gt;すべてのビットを反転する。&lt;/li&gt;
&lt;li&gt;すべての桁をいくつかずらす。&lt;/li&gt;
&lt;li&gt;すべての桁をいくつかずらす。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この例では、一連のビット演算を __ 类型的变量 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; に適用し、異なるフラグによって異なる状態を表します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;flowchart LR
    A[原始数值: 00010000] --&amp;gt; B[左移: 00010000 &amp;lt;&amp;lt; 1]
    B --&amp;gt; C[结果: 00100000]
    C --&amp;gt; D[右移: 00100000 &amp;gt;&amp;gt; 1]
    D --&amp;gt; E[结果: 00010000]

    subgraph 左移操作
        direction LR
        A --&amp;gt; B --&amp;gt; C
    end

    subgraph 右移操作
        direction LR
        C --&amp;gt; D --&amp;gt; E
    end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;要求分析&#34;&gt;要求分析
&lt;/h3&gt;&lt;p&gt;題の説明に基づき、異なる状態を表す16ビットのフラグがあります。これらの状態は、様々な二進数のビットによって示され、各ビットは特定の意味に対応しています。例えば：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;失敗したか&lt;/li&gt;
&lt;li&gt;圧縮されていますか？&lt;/li&gt;
&lt;li&gt;増分は必要ですか？&lt;/li&gt;
&lt;li&gt;続編はありますか？&lt;/li&gt;
&lt;li&gt;通常のリクエストまたはログアウト&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ビット演算を使用する&#34;&gt;ビット演算を使用する
&lt;/h3&gt;&lt;p&gt;これらのフラグは、ビット演算を用いて設定および取得します。具体的には：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;あるビットの値（0または1）を取得する。&lt;/li&gt;
&lt;li&gt;あるビットを1に設定する。&lt;/li&gt;
&lt;li&gt;設定特定のビットを0にする。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;まず、これらのフラグを保存するために、ある__INLINE_CODE_0__ 类型的变量 __INLINE_CODE_1__を定義します。その後、ビット演算を用いて、対応するフラグをチェックし設定します。&lt;/p&gt;
&lt;h3 id=&#34;cサンプルコード&#34;&gt;C++サンプルコード
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;bitset&amp;gt;

// 定义标志位常量
const unsigned short BIT_0_FAIL = 1 &amp;lt;&amp;lt; 0;    // bit0 是否失败
const unsigned short BIT_1_COMPRESSED = 1 &amp;lt;&amp;lt; 1; // bit1 是否压缩
const unsigned short BIT_2_INCREMENT = 1 &amp;lt;&amp;lt; 2;  // bit2 是否增量
const unsigned short BIT_3_HAS_MORE = 1 &amp;lt;&amp;lt; 3;   // bit3 是否有后续包
const unsigned short BIT_5_CANCEL = 1 &amp;lt;&amp;lt; 5;     // bit5 正常请求(0)或注销(1)

// 检查某一位是否为1
bool isBitSet(unsigned short wInfo, unsigned short bitMask) {
    return (wInfo &amp;amp; bitMask) != 0;
}

// 设置某一位为1
void setBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo |= bitMask;
}

// 清除某一位（设置为0）
void clearBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo &amp;amp;= ~bitMask;
}

int main() {
    // 假设wInfo的初始值为0
    unsigned short wInfo = 0;

    // 设置bit0（失败标志）
    setBit(wInfo, BIT_0_FAIL);
    
    // 设置bit1（压缩标志）
    setBit(wInfo, BIT_1_COMPRESSED);
    
    // 打印wInfo的二进制值
    std::cout &amp;lt;&amp;lt; &amp;quot;wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    // 检查各个标志位
    std::cout &amp;lt;&amp;lt; &amp;quot;bit0 (是否失败): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_0_FAIL) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit1 (是否压缩): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_1_COMPRESSED) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit2 (是否增量): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_2_INCREMENT) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit3 (是否有后续包): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_3_HAS_MORE) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit5 (是否注销): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_5_CANCEL) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;

    // 清除bit1（压缩标志）
    clearBit(wInfo, BIT_1_COMPRESSED);
    
    // 打印更新后的wInfo
    std::cout &amp;lt;&amp;lt; &amp;quot;Updated wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;コードを実行し、旧友を推薦します：&lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wInfo (in binary): 0000000000000011
bit0 (是否失败): 是
bit1 (是否压缩): 是
bit2 (是否增量): 否
bit3 (是否有后续包): 否
bit5 (是否注销): 否
Updated wInfo (in binary): 0000000000000001
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;コード解説&#34;&gt;コード解説
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;変位操作（インラインitalic_10、インラインitalic_11、インラインitalic_12、インラインitalic_13、インラインitalic_14など）を使用します。これにより、各フラグビットにユニークな二進数位置を割り当てることができます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;太字_4：斜体_8____太字_5：斜体_9____太字_6：斜体_10____太字_7：斜体_11____。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定されたフラグの位置を1にする。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特定のフラグの位置を0にする。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;まとめ&#34;&gt;まとめ
&lt;/h3&gt;&lt;p&gt;ビット演算を用いることで、複数の状態フラグを効率的に処理できます。特に、組み込み開発やネットワークプロトコル、システムの状態管理など、多くの場面で役立ちます。ビットフラグは、複数の二進数状態を表す際に、省スペースかつ高効率を実現します。&lt;/p&gt;
&lt;p&gt;このブログが、C++ でのビット演算を使ったビット値の取得と設定を理解するのに役立つことを願っています。これらのスキルを習得することは、効率的で保守しやすいコードを書く上で非常に役立ちます！&lt;/p&gt;</description>
        </item>
        <item>
        <title>GCC、GLIBC と C&#43;&#43; プログラムの互換性問題に関する深い理解</title>
        <link>https://blog.ttf248.life/ja/p/deep-understanding-gcc-glibc-cpp-compatibility-issues/</link>
        <pubDate>Mon, 06 Jan 2025 19:51:16 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ja/p/deep-understanding-gcc-glibc-cpp-compatibility-issues/</guid>
        <description>&lt;p&gt;C++開発において、GCCとGLIBCは欠かせない主要な要素であり、プログラム公開後の互換性の問題も開発者を悩ませることがよくある。本稿では、これらの本質を深く分析し、互換性の問題の根本原因とその対策について探求する。&lt;/p&gt;
&lt;h2 id=&#34;一gcc堅固なコンパイラの基礎&#34;&gt;一、GCC：堅固なコンパイラの基礎
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;GCC（GNU コンパイラ コレクション）は、GNUプロジェクトが開発したオープンソースのコンパイラスイートです。C、C++、Objective-C、Fortran、Ada、Goなど、多様な主要言語に対応し、クロス言語開発のためのワンストップソリューションを提供します。&lt;/li&gt;
&lt;li&gt;C++ を例にとると、クラス、テンプレート、関数オーバーロードといった複雑な機能を含むソースファイルを記述した際、GCC は C++ の厳格な文法と意味規則に基づいて、高レベルの C++ コードを、基盤となる機械が理解し実行できる命令シーケンスに変換します。このプロセスには、語彙解析、構文解析、意味解析、最適化、コード生成といった複数の精緻な段階が含まれます。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;GCCはまず、ソースファイルを前処理します。この際、すべての&lt;code&gt;#&lt;/code&gt;、&lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt;、&lt;strong&gt;INLINE_CODE_3&lt;/strong&gt;、&lt;strong&gt;INLINE_CODE_4&lt;/strong&gt;、&lt;strong&gt;INLINE_CODE_5&lt;/strong&gt;、&lt;code&gt;3.14159&lt;/code&gt;を処理し、前処理後、ソースファイルは初期段階で「拡充」されます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编译阶段&lt;/strong&gt;: プリプロセスされたファイルはコンパイル段階に入り、GCC は C++ 言語標準に基づいてソースファイルをアセンブリ言語コードに変換します。クラスの継承、ポリモーフィズムの実装、関数呼び出しパラメータのマッチングなど、コード構造を厳密にチェックし、文法や意味に合致しないエラーが見つかると、速やかにエラーを出力してコンパイルプロセスを停止します。例えば、関数宣言と定義のパラメータリストが不一致の場合、GCC は問題箇所を正確に特定します。&lt;/li&gt;
&lt;li&gt;アセンブラは、前段階で生成されたアセンブリコードを機械語に変換し、__INLINE_CODE_0__という拡張子のオブジェクトファイルを生成します。これらのオブジェクトファイルには、機械が直接実行できるバイナリ命令が含まれていますが、通常、完全なプログラムは複数のモジュールから構成され、関数や変数の参照関係が解決されていないため、単独で実行することはできません。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链接阶段&lt;/strong&gt;：これは実行可能ファイルを生成する最後のスプリント段階です。リンカは、複数のオブジェクトファイルと必要なライブラリファイル（静的ライブラリまたは動的ライブラリ）を統合します。例えば、C++標準テンプレートライブラリのコンテナクラスを使用する場合、リンク時に対応するライブラリの実装コードを見つける必要があり、プログラム実行時に__INLINE_CODE_0__、__INLINE_CODE_1__などのコンテナ機能を正しく呼び出せるようにし、最終的に完全な実行可能プログラムを生成します。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二glibccプログラムを支える舞台裏&#34;&gt;二、GLIBC：C++プログラムを支える舞台裏
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;GLIBCは、GNU C Libraryのことであり、C標準ライブラリのGNUエコシステムにおける具体的な実装です。名前がCを強調していますが、C++プログラムも同様に強く依存しており、なぜならC++はCの基礎部分を受け継いでいるからです。メモリ管理など、膨大な基礎関数を提供し、C++初期の開発や、パフォーマンスを重視し、簡潔さを追求する場面で頻繁に使用されます。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;GLIBCは、OSとアプリケーションをつなぐ重要な橋渡し役です。Linuxシステムにおいて、C++プログラムがファイルを開くといったシステムコールを行う際（例えば、__INLINE_CODE_0__関数を使用し、その基盤としてGLIBCの実装に依存する場合）、GLIBCはプログラムのリクエストをOSカーネルが定める方法でラップしてカーネルに渡し、カーネル処理完了後、結果をアプリケーションに返します。これにより、アプリケーションはOSの複雑なシステムコールインターフェースの詳細を深く理解することなく、ファイルシステム、ネットワーク、プロセス管理などの様々なシステムリソースを容易に使用できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cプログラム公開後の互換性問題の考察&#34;&gt;C++プログラム公開後の互換性問題の考察
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;異なる Linux ディストリビューションは、しばしば異なるバージョンの GLIBC を搭載しています。C++ プログラムが高バージョン GLIBC 環境でコンパイルされると、意図せずしてそのバージョンで新たに追加された関数機能を利用したり、より最適化された関数実装に依存したりすることがあります。例えば、新しい GLIBC バージョンではメモリ割り当てアルゴリズムが改善されており、プログラムはその新アルゴリズムを頻繁に利用することでパフォーマンスを向上させます。しかし、このプログラムを低バージョン GLIBC システムで実行すると、対応する関数が見つからない（低バージョンで導入されていないため）あるいは関数動作が異常になる（旧版の実装ロジックと新版のずれ）といった問題が発生し、プログラムがクラッシュしたり、誤った結果を生み出したりする可能性があります。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;同じGCCコンパイラを使用した場合でも、バージョンによってコード生成、標準ライブラリのサポート、C++機能の実装に差異があります。最新バージョンのGCCは、C++20の新機能（モジュールやコルーチンなど）を完全にサポートしていますが、古いバージョンのGCCでこれらの機能を活用したプログラムをコンパイルすると、構文エラーが発生したり、最適化戦略の違いにより生成される機械語の効率やメモリ使用量が大きく異なり、パフォーマンスが要求される環境下では、異なる環境での挙動に大きな違いが生じる可能性があります。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;C++プログラムは、x86、ARM、PowerPCなどの異なるハードウェアシステムアーキテクチャ上で動作する必要がある場合があります。各アーキテクチャには独自の命令セット、メモリレイアウト、データアライメント要件があります。例えば、データアライメントに関して、x86アーキテクチャで正常に動作する構造体データの格納順序が、ARMアーキテクチャではアライメント規則の違いによりメモリアクセス異常を引き起こし、プログラムエラーにつながる可能性があります。また、GCCは異なるアーキテクチャ向けにコンパイルすると生成される機械語が大きく異なり、プログラム中にハードコードされたアーキテクチャ依存の命令や仮定があれば、クロスアーキテクチャでの動作時に頻繁な障害が発生します。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;互換性の問題への対応策&#34;&gt;互換性の問題への対応策
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;静的にリンクされたライブラリを使用することを検討してください。プログラムが依存する GLIBC などのライブラリコードを直接実行ファイルにパッケージングすることで、プログラムの実行時に特定の GLIBC のバージョンに依存する必要がなくなり、GLIBC のバージョン不一致による問題を効果的に回避できます。ただし、静的リンクは実行ファイルのサイズを大幅に増加させるため、ストレージリソースが限られている場合は、メリットとデメリットを比較検討する必要があります。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Dockerなどのコンテナ化技術を活用し、C++プログラムとその実行環境（特定のバージョンのGCC、GLIBCなど）を独立したコンテナにパッケージングします。これにより、基盤となるOSが異なってもコンテナ内部は開発時の環境を維持し、プログラムの期待通りの動作を保証するとともに、異なる環境へのデプロイメントの複雑さを大幅に軽減できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;包括様々なGLIBCバージョン、GCCバージョン、および一般的なシステムアーキテクチャを網羅した、包括的な互換性テスト体系を構築する。開発プロセスにおいて、継続的インテグレーションツールを用いて、複数の環境で定期的に自動テストを実施し、互換性の問題を早期に発見・修正することで、潜在的なリスクを未然に防ぎ、リリース後の安定性を確保する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上記を総合すると、GCCおよびGLIBCの動作メカニズムを深く理解し、C++プログラムの互換性問題の根本原因を正確に把握し、柔軟な対応策を用いることは、あらゆるC++開発者が堅牢でクロスプラットフォームなアプリケーションを構築するために不可欠なスキルです。そうすることで初めて、私たちのC++作品は多様な技術エコシステムの中で円滑に進むことができるでしょう。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Linuxバックエンドサービスにおける大量の文字列データ処理 - 効率が低い</title>
        <link>https://blog.ttf248.life/ja/p/linux-backend-slow-string-processing/</link>
        <pubDate>Wed, 13 Nov 2024 19:42:59 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ja/p/linux-backend-slow-string-processing/</guid>
        <description>&lt;p&gt;C++開発の過去プロジェクトにおいて、カスタムプロトコルを用いて通信しており、そのプロトコルは二次元配列の形式を採用していました。大量データを処理する際、ログ生成のために配列を走査しシリアライズを行う必要がありましたが、効率が悪く、高負荷時にシステムが顕著にカクつくという問題が発生しました。この件について、ビジネス部門からシステムの動作不良に関するフィードバックがありました。&lt;/p&gt;
&lt;h2 id=&#34;問題特定&#34;&gt;問題特定
&lt;/h2&gt;&lt;p&gt;問題の調査において、まずシステムを性能解析したところ、大量データを処理する際にCPU使用率が顕著に増加し、システム応答時間が長くなっていることが判明しました。システムのログを分析した結果、二次元配列の処理における効率の低いシリアライズ操作が多く存在することがわかり、これがシステムパフォーマンスの低下を引き起こしていると考えられます。&lt;/p&gt;
&lt;p&gt;ツール切り取りサービスの スレッド情報を確認した結果、ログスレッドの大部分の時間文字列の結合処理に費やされていることが判明しました。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ここが今日のポイントです。異なる加算方法によって、効率は大きく異なります。過去のコードでは &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 演算子を使用しており、この方法は頻繁に一時オブジェクトを作成するため、非常に低速です。それが非効率的だと知っていても、どれほど非効率的なのかを理解していないようなものです。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;デモ検証&#34;&gt;デモ検証
&lt;/h2&gt;&lt;p&gt;プロジェクトコードに基づいて、業務ロジックを抽出し、文字列結合の効率問題を検証するための簡単なデモを作成しました。&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 下的 __INLINE_CODE_1__BOLD_6&lt;code&gt;linux&lt;/code&gt; 下的 &lt;strong&gt;INLINE_CODE_3&lt;/strong&gt; 编译器，__INLINE_CODE_4__モードでコンパイル実行し、効率を比較します。&lt;/p&gt;
&lt;h3 id=&#34;主なポイント&#34;&gt;主なポイント
&lt;/h3&gt;&lt;p&gt;プロジェクトでは手法4を使用しており、テストデータを入手する前に、読者はどの方法が最も効率的か、またどれが最も非効率かを考えてみることができます。結果を見たときは、やはり驚きました。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;各フィールドを文字列に連結します。&lt;/li&gt;
&lt;li&gt;流（ストリーム）を使用して各フィールドを結合すると、この方法がより効率的です。特に大量のデータを結合する場合に有効です。&lt;/li&gt;
&lt;li&gt;事前に文字列に十分なメモリを割り当てることで、メモリ再配置のオーバーヘッドを削減し、パフォーマンスが向上します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;太字_1&lt;/strong&gt;インライン&lt;strong&gt;イタリック_3&lt;/strong&gt;、&lt;strong&gt;太字_2&lt;/strong&gt;：文字列を連結するたびに新しい一時的な文字列オブジェクトが作成されるため、特に大規模な連結ではパフォーマンスが低下します。これは、連結ごとに新しいメモリの割り当てとコピーが発生するためです。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参照結果から、プロジェクトは効率が最も悪い方法が選択されたことが分かります。&lt;/p&gt;
&lt;p&gt;さらに、異なるプラットフォームのコンパイラ最適化効率を分析すると、Microsoftの&lt;code&gt;visual studio&lt;/code&gt; 一如既往的优秀，针对字符串的优化效率很高，而 &lt;code&gt;gcc&lt;/code&gt;コンパイラは、この点において若干見劣りする。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;コードを異なるマシンで実行した場合、データの比較は直接的な意味を持たないため、それぞれの結合方法間の差異を比較するのが適切です。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;windows 平台下的 vs2022 编译器

----------------------------------------
Data Generation Time: 0.054 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.053 seconds.
+ ostringstream Data merging took: 0.054 seconds.
+ Pre-reserved Data merging took: 0.045 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 16.108 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;linux 平台下的 gcc8.5 编译器
----------------------------------------
Data Generation Time: 0.108 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.100 seconds.
+ ostringstream Data merging took: 0.083 seconds.
+ Pre-reserved Data merging took: 0.057 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 29.298 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完全コード&#34;&gt;完全コード
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;random&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;iomanip&amp;gt;

typedef std::vector&amp;lt;std::string&amp;gt; DataRow;
typedef std::vector&amp;lt;DataRow&amp;gt; DataGroup;

struct ResponsePackage
{
    std::string ErrorInfo;
    DataRow Head;
    std::string ClientId;
    std::string UUID;
    std::string MsgID;
    std::string SessionID;
    std::string ExtraInfo1;
    std::string ExtraInfo2;
    DataGroup DataBody;
};

// Generate specified length of random string
std::string generateRandomString(size_t length)
{
    const char charset[] = &amp;quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&amp;quot;;
    const size_t max_index = sizeof(charset) - 1;
    std::string random_string;
    random_string.reserve(length);

    std::random_device rd;
    std::mt19937 generator(rd());
    std::uniform_int_distribution&amp;lt;&amp;gt; distribution(0, max_index);

    for (size_t i = 0; i &amp;lt; length; ++i)
    {
        random_string += charset[distribution(generator)];
    }

    return random_string;
}

void create_large_string()
{
    // Example request package with 50 fields
    ResponsePackage requestPackage;

    requestPackage.Head = {
        &amp;quot;Field1&amp;quot;, &amp;quot;Field2&amp;quot;, &amp;quot;Field3&amp;quot;, &amp;quot;Field4&amp;quot;, &amp;quot;Field5&amp;quot;,
        &amp;quot;Field6&amp;quot;, &amp;quot;Field7&amp;quot;, &amp;quot;Field8&amp;quot;, &amp;quot;Field9&amp;quot;, &amp;quot;Field10&amp;quot;,
        &amp;quot;Field11&amp;quot;, &amp;quot;Field12&amp;quot;, &amp;quot;Field13&amp;quot;, &amp;quot;Field14&amp;quot;, &amp;quot;Field15&amp;quot;,
        &amp;quot;Field16&amp;quot;, &amp;quot;Field17&amp;quot;, &amp;quot;Field18&amp;quot;, &amp;quot;Field19&amp;quot;, &amp;quot;Field20&amp;quot;,
        &amp;quot;Field21&amp;quot;, &amp;quot;Field22&amp;quot;, &amp;quot;Field23&amp;quot;, &amp;quot;Field24&amp;quot;, &amp;quot;Field25&amp;quot;,
        &amp;quot;Field26&amp;quot;, &amp;quot;Field27&amp;quot;, &amp;quot;Field28&amp;quot;, &amp;quot;Field29&amp;quot;, &amp;quot;Field30&amp;quot;,
        &amp;quot;Field31&amp;quot;, &amp;quot;Field32&amp;quot;, &amp;quot;Field33&amp;quot;, &amp;quot;Field34&amp;quot;, &amp;quot;Field35&amp;quot;,
        &amp;quot;Field36&amp;quot;, &amp;quot;Field37&amp;quot;, &amp;quot;Field38&amp;quot;, &amp;quot;Field39&amp;quot;, &amp;quot;Field40&amp;quot;,
        &amp;quot;Field41&amp;quot;, &amp;quot;Field42&amp;quot;, &amp;quot;Field43&amp;quot;, &amp;quot;Field44&amp;quot;, &amp;quot;Field45&amp;quot;,
        &amp;quot;Field46&amp;quot;, &amp;quot;Field47&amp;quot;, &amp;quot;Field48&amp;quot;, &amp;quot;Field49&amp;quot;, &amp;quot;Field50&amp;quot;
    };

    requestPackage.ClientId = &amp;quot;ClientID&amp;quot;;
    requestPackage.UUID = &amp;quot;UUID&amp;quot;;
    requestPackage.MsgID = &amp;quot;MsgID&amp;quot;;
    requestPackage.SessionID = &amp;quot;SessionID&amp;quot;;
    requestPackage.ExtraInfo1 = &amp;quot;ExtraInfo1&amp;quot;;
    requestPackage.ExtraInfo2 = &amp;quot;ExtraInfo2&amp;quot;;

    // Start timing for data generation
    auto start_gen = std::chrono::high_resolution_clock::now();

    // Generate 10,000 rows of data, each with 50 fields
    for (size_t i = 0; i &amp;lt; 10000; ++i)
    {
        DataRow dataRow(50, &amp;quot;This is a test string&amp;quot;);
        requestPackage.DataBody.push_back(dataRow);
    }

    // End timing for data generation
    auto end_gen = std::chrono::high_resolution_clock::now();
    std::chrono::duration&amp;lt;double&amp;gt; duration_gen = end_gen - start_gen;

    // Display result generation time
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Generation Time: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_gen.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    // Data merging using different methods
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Performance:\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    {
        // Method 1: Using &#39;+=&#39; string concatenation
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (+=) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 2: Using ostringstream
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::ostringstream bodys;
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::ostringstream body;
            body &amp;lt;&amp;lt; &amp;quot;This is a test string&amp;quot;;
            for (auto&amp;amp; item : vec)
            {
                body &amp;lt;&amp;lt; item &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            }
            bodys &amp;lt;&amp;lt; body.str() &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ ostringstream Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 3: Pre-allocated memory
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys;
        bodys.reserve(1000 * 50 * 20); // Pre-allocate enough memory
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            body.reserve(50 * 20); // Pre-allocate memory for each row
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Pre-reserved Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 4: Using &#39;bodys = bodys + body + &amp;quot;\n&amp;quot;&#39;
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body = body + item + &amp;quot; &amp;quot;; // Note the use of &#39;body = body + item&#39;
            }
            bodys = bodys + body + &amp;quot;\n&amp;quot;; // Again, using &#39;bodys = bodys + body&#39;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (bodys = bodys + body + \&amp;quot;\\n\&amp;quot;) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Complete.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;
}

int main()
{
    try
    {
        create_large_string();
    }
    catch (const std::exception&amp;amp; e)
    {
        std::cerr &amp;lt;&amp;lt; &amp;quot;Caught exception: &amp;quot; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\nProgram finished.\n&amp;quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43;ラムダ式におけるパラメータのライフサイクル</title>
        <link>https://blog.ttf248.life/ja/p/cpp-lambda-parameter-lifetime/</link>
        <pubDate>Wed, 13 Nov 2024 19:23:02 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ja/p/cpp-lambda-parameter-lifetime/</guid>
        <description>&lt;p&gt;C++において、ラムダ式は便利な匿名関数であり、外部変数をキャプチャしてその内部で使用できます。これにより、ラムダは柔軟なプログラミングツールとなります。ただし、ラムダ式のパラメータのライフサイクルは特に注意すべき点であり、特にキャプチャとパラメータの受け渡しにおいて重要です。&lt;/p&gt;
&lt;h3 id=&#34;ラムダ式パラメータのライフサイクル&#34;&gt;ラムダ式パラメータのライフサイクル
&lt;/h3&gt;&lt;p&gt;ラムダ式のパラメータの寿命は、通常、他のC++関数と同様です。関数のパラメータは、関数呼び出し中に存在し、呼び出しが終了すると寿命を終えます。ただし、ラムダ式が外部変数にキャプチャする場合、パラメータの寿命はそのキャプチャ方法の影響を受けます。&lt;/p&gt;
&lt;h3 id=&#34;キャプチャとパラメータのライフサイクルとの関係&#34;&gt;キャプチャとパラメータのライフサイクルとの関係
&lt;/h3&gt;&lt;h4 id=&#34;21-外部変数の捕捉&#34;&gt;2.1 外部変数の捕捉
&lt;/h4&gt;&lt;p&gt;C++のラムダ式は、外部変数を2つの方法でキャプチャできます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;値のキャプチャにより、外部変数の値がラムダ内にコピーされ、そのコピーの寿命はラムダの寿命によって制御されます。&lt;/li&gt;
&lt;li&gt;クローズチャ、外部変数の参照は保持され、ラムダ内の参照は元の外部変数を示し、ライフサイクルは外部変数に依存します。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda_by_value = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };  // 捕获x的副本
auto lambda_by_reference = [&amp;amp;x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };  // 捕获x的引用

lambda_by_value();  // 打印10
lambda_by_reference();  // 打印10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;捕捉された変数のライフサイクルは以下の通りです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;キャプチャされた時点での外部変数の値がラムダにコピーされ、ラムダのライフサイクル終了時にそのコピーが破棄されます。&lt;/li&gt;
&lt;li&gt;ラムダが外部変数の参照を持つこと、&lt;strong&gt;外部变量必须在lambda使用之前有效，否则会导致未定义行为&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ラムダパラメータ&#34;&gt;ラムダパラメータ
&lt;/h4&gt;&lt;p&gt;ラムダのパラメータは通常の関数パラメータと同様で、そのライフサイクルはラムダ関数内に限定されます。つまり、ラムダ呼び出し時にパラメータが作成され、呼び出し終了後にはパラメータのライフサイクルも終了します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto lambda = [](int a, int b) {
    std::cout &amp;lt;&amp;lt; a + b &amp;lt;&amp;lt; std::endl;
};
lambda(5, 10);  // a和b在这里是lambda的参数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この例では、&lt;code&gt;a&lt;/code&gt;BOLD_2&lt;code&gt;b&lt;/code&gt;はラムダ式の引数であり、ラムダ式の呼び出し時に作成され、実行終了後に破棄されます。&lt;/p&gt;
&lt;h3 id=&#34;キャプチャした外部変数のライフサイクル問題&#34;&gt;キャプチャした外部変数のライフサイクル問題
&lt;/h3&gt;&lt;h4 id=&#34;ラムダ関数外でキャプチャされた変数が有効か&#34;&gt;ラムダ関数外でキャプチャされた変数が有効か。
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;ラムダ関数は、呼び出し後も外部変数のコピーを保持するため、外部変数が破棄されても、そのコピー内での利用は安全です。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x 在lambda调用后修改
lambda();  // 打印10，捕获的是x的副本
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;ラムダ関数が外部変数の参照を捕捉する場合、その参照へのアクセスは外部変数のライフサイクルに依存します。外部変数がラムダ関数の実行前に破棄されると、ダングリング参照が発生し、未定義の動作につながる可能性があります。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [&amp;amp;x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x 在lambda调用前修改
lambda();  // 打印20，捕获的是x的引用
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;ラムダの実行順序が確定しない場合、キャプチャされた外部変数がラムダ実行時に有効であることを保証することが重要です。&lt;/p&gt;
&lt;/blockquote&gt;</description>
        </item>
        <item>
        <title>GCCバージョンアップによりプログラムがクラッシュ：非標準コードの潜在的な問題</title>
        <link>https://blog.ttf248.life/ja/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</link>
        <pubDate>Sun, 10 Mar 2024 23:19:06 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ja/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</guid>
        <description>&lt;p&gt;同一のビジネスコードの場合、プログラムは CentOS 7 環境で正常にコンパイルされ実行されたが、CentOS 8 に切り替えて更新版 GCC でコンパイルするとクラッシュした。問題は &lt;strong&gt;Release 模式&lt;/strong&gt; の場合にのみ発生し、&lt;strong&gt;Debug 模式&lt;/strong&gt; では全く問題なかった。今回初めてこのような事態に遭遇したが、3 日間の調査の結果、ようやく原因を突き止めた。&lt;/p&gt;
&lt;h3 id=&#34;問題特定&#34;&gt;問題特定
&lt;/h3&gt;&lt;p&gt;徹底的な調査の結果、問題の根本原因は &lt;strong&gt;函数缺少返回值&lt;/strong&gt; にありました。リリースモードでは、GCC の新バージョンがより多くの最適化を行うため、元々明示的な戻り値を持たない関数が実行中に予期せぬ動作を起こし、クラッシュを引き起こしました。結論として、&lt;strong&gt;编译器的警告不容忽视，尤其是在老项目中，部分警告可能被无视，但也应当避免屏蔽所有警告&lt;/strong&gt; です。&lt;/p&gt;
&lt;h3 id=&#34;環境説明&#34;&gt;環境説明
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39)
Copyright © 2015 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 8.5.0 20210514 (Red Hat 8.5.0-21)
Copyright (C) 2018 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;クラッシュ現象&#34;&gt;クラッシュ現象
&lt;/h3&gt;&lt;p&gt;プログラムクラッシュのスタックを解析した結果、以下のスタック情報が見られました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[New LWP 1385902]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib64/libthread_db.so.1&amp;quot;.
Core was generated by `./pstack_main`.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007ffe894b4420 in ?? ()
(gdb) bt
#0  0x00007ffe894b4420 in ?? ()
#1  0x00000000004008e9 in main ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このスタックは直感的ではなく、クラッシュした関数のスタック情報が &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; と表示されているため、問題の特定がより複雑になっています。&lt;/p&gt;
&lt;h3 id=&#34;コード例&#34;&gt;コード例
&lt;/h3&gt;&lt;p&gt;問題をより良く理解するために、クラッシュを再現する最小限のコード例を以下に示します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int test() {
    std::cout &amp;lt;&amp;lt; &amp;quot;1&amp;quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    test();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;そのコード内の &lt;code&gt;test()&lt;/code&gt; 函数显然没有显式返回一个值，而它的返回类型是 &lt;code&gt;int&lt;/code&gt;。根据 C++ 规范，当一个函数声明为 &lt;strong&gt;INLINE_CODE_2&lt;/strong&gt; 型では、必ず値を返す必要がある。さもなくば、未定義の動作を引き起こす可能性がある。&lt;/p&gt;
&lt;h3 id=&#34;コンパイル警告&#34;&gt;コンパイル警告
&lt;/h3&gt;&lt;p&gt;プロジェクトにおいて、CMakeスクリプトが多くのコンパイル時の警告を抑制しており、その中には以下の警告が含まれています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/root/pstack/main.cpp: In function ‘int test()’:
/root/pstack/main.cpp:7:1: warning: no return statement in function returning non-void [-Wreturn-type]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この警告は、__INLINE_CODE_0__関数が値を返さないことを示しており、これが問題の根本原因です。高バージョンGCC（例えば8.5.0）は、コードを最適化する際に、このような未定義の振る舞いに対して不安定な最適化を行い、プログラムをクラッシュさせる可能性があります。&lt;/p&gt;
&lt;h3 id=&#34;アセンブリコードの差異&#34;&gt;アセンブリコードの差異
&lt;/h3&gt;&lt;p&gt;GCCコンパイラ最適化の差異を説明するため、異なるバージョンのGCCが生成するアセンブリコードを比較しました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;アセンブリコードは冗長であり、標準出力ストリーム（&lt;code&gt;std::cout&lt;/code&gt;）的处理逻辑。这表明编译器进行了更保守的优化，未对 &lt;code&gt;test()&lt;/code&gt;関数における戻り値の欠落問題など）に対する過剰な最適化が含まれているため、クラッシュを回避できた可能性がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新しいGCCでは、より多くの最適化が行われ、コード量が削減されました。しかし、この最適化により、戻り値がない関数の実行時に動作が不安定になり、プログラムがクラッシュする可能性があります。&lt;/p&gt;
&lt;h3 id=&#34;結論&#34;&gt;結論
&lt;/h3&gt;&lt;p&gt;今回の問題の調査を通じて、C++において、&lt;strong&gt;函数返回值必须明确&lt;/strong&gt;（特に__INLINE_CODE_0__ 时，必须提供一个返回值。对于使用较旧版本编译器的项目，升级到新版本的 GCC 时，可能会遇到更多的优化和更严格的警告机制。因此，我们建议在编译时 **関数宣言の場合）、すべての警告を無視するのではなく、選択的に処理することが重要であると深く認識しました。特に、関数戻り値や型の一致など、一般的な問題には注意が必要です。&lt;/p&gt;
&lt;p&gt;最終、&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 関数に返り値を追加することで問題が解決し、プログラムは正常に動作するようになった。&lt;/p&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43;プログラミングの落とし穴：`std::map` の誤った使用によるプログラムクラッシュの詳細解説</title>
        <link>https://blog.ttf248.life/ja/p/cpp-programming-traps-std-map-crash-details/</link>
        <pubDate>Sun, 10 Mar 2024 22:03:06 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ja/p/cpp-programming-traps-std-map-crash-details/</guid>
        <description>&lt;p&gt;C++プログラミングにおける&lt;code&gt;__INLINE_CODE_0__&lt;/code&gt;コンテナの誤った使用が、プログラムのクラッシュを引き起こす可能性があることを明らかにすることを目的としています。角括弧演算子で存在しないキーにアクセスしようとすると、自動的に空要素が追加されます。この誤解を深く分析し、サンプルコードを通じて潜在的なリスクを示します。&lt;/p&gt;
&lt;p&gt;単純な値を格納する分には問題ありませんが、ポインタを格納すると問題が生じます。ポインタはアドレスであり、初期化されていない場合、そのアドレスは未確定となり、プログラムのクラッシュにつながる可能性があります。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;C++標準ライブラリにおいて、``std::map&lt;code&gt;是一种关联容器，它按照键（key）的升序存储元素，并提供了高效的关键字查找功能。然而，新手开发者有时会因为对&lt;/code&gt;std::map&lt;code&gt;BOLD_6&lt;/code&gt;[]&lt;code&gt;BOLD_7&lt;/code&gt;[]&lt;code&gt; 访问一个不存在的键时，__INLINE_CODE_4__&lt;/code&gt;は新しいキーバリューペアを挿入し、デフォルトコンストラクタを用いてキーに対応する値の型を初期化します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int main() {
    std::map&amp;lt;std::string, int&amp;gt; myMap;
    
    // 错误的用法：假设这里试图访问一个不存在的键并认为会得到0
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for &#39;nonexistent_key&#39;: &amp;quot; &amp;lt;&amp;lt; myMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;

    // 实际上，上述行代码创建了一个新的键值对，其中值被默认初始化为int的默认值（通常是0）
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記のコードはプログラムを直接クラッシュさせることはありませんが、このような暗黙的な挿入処理は、リソースリークや予期せぬ状態変化といった副作用を引き起こす可能性があります。さらに悪いことに、マルチスレッド環境で未初期化のメモリ領域に同時にアクセスすると、プログラムがクラッシュする可能性もあります。&lt;/p&gt;
&lt;p&gt;類似の問題を防ぐため、__INLINE_CODE_0__BOLD_3&lt;code&gt;std::map::count()&lt;/code&gt;BOLD_4&lt;code&gt;std::map::insert()&lt;/code&gt;要素を明示的に挿入することを推奨します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::map&amp;lt;std::string, int&amp;gt; safeMap;
if (safeMap.count(&amp;quot;nonexistent_key&amp;quot;) == 0) {
    std::cout &amp;lt;&amp;lt; &amp;quot;Key does not exist.&amp;quot; &amp;lt;&amp;lt; std::endl;
} else {
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for existing key: &amp;quot; &amp;lt;&amp;lt; safeMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;
}

// 或者明确插入一个键值对，指定初始值
safeMap.insert({ &amp;quot;new_key&amp;quot;, 0 });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;もしmapコンテナ内にポインタ型のオブジェクトが格納されている場合、要素の自動挿入は初期化されていないポインタを保持し、そのポインタに対するいかなる操作もプログラムクラッシュを引き起こす可能性があります。&lt;/p&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43;関数呼び出しにかかる時間</title>
        <link>https://blog.ttf248.life/ja/p/cpp-function-call-timing/</link>
        <pubDate>Wed, 24 Jan 2024 14:11:33 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ja/p/cpp-function-call-timing/</guid>
        <description>&lt;p&gt;設計のSDKについて、様々なコールバック関数実装方法で時間のかかるテストを実施しました。最近C++の関数プログラミングを調べていますが、関数がファーストクラスオブジェクトとなり、プログラム内で流通すると、パフォーマンスに違いはありますか？&lt;/p&gt;
&lt;p&gt;先行きのリンク：&lt;a class=&#34;link&#34; href=&#34;https://blog.ttf248.life/ja/p/compiler-callback-function-performance-testing/&#34; &gt;编译器、回调函数、性能测试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大佬も同様のテストをしており、コードを拝借した。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;実行プラットフォームは、引き続き弊社の旧友、&lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt;です。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;cassert&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

int add_one(int input) { return input + 1; }

bool validate_vector_add_one(std::vector&amp;lt;int&amp;gt; const&amp;amp; input_vector,
                             std::vector&amp;lt;int&amp;gt; const&amp;amp; output_vector)
{
    bool is_valid{true};
    for (size_t i{0}; i &amp;lt; input_vector.size(); ++i)
    {
        if (output_vector.at(i) != input_vector.at(i) + 1)
        {
            is_valid = false;
            break;
        }
    }
    return is_valid;
}

void reset_vector(std::vector&amp;lt;int&amp;gt;&amp;amp; input_vector)
{
    for (size_t i{0}; i &amp;lt; input_vector.size(); ++i)
    {
        input_vector.at(i) = 0;
    }
}

template &amp;lt;typename T, typename Func&amp;gt;
void unitary_function_pass_by_lambda_function(T&amp;amp; output, T const&amp;amp; input,
                                              Func const func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_std_function_value(T&amp;amp; output, T const&amp;amp; input,
                                                 std::function&amp;lt;T(T)&amp;gt; const func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_std_function_reference(
    T&amp;amp; output, T const&amp;amp; input, std::function&amp;lt;T(T)&amp;gt; const&amp;amp; func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_function_pointer(T&amp;amp; output, T const&amp;amp; input,
                                               T (*func)(T))
{
    output = func(input);
}

int main()
{
    // Set floating point format std::cout with 3 decimal places.
    std::cout.precision(3);

    size_t const num_elements{10000000};
    std::vector&amp;lt;int&amp;gt; input_vector(num_elements, 0);
    std::vector&amp;lt;int&amp;gt; output_vector(num_elements, 0);

    auto const lambda_function_add_one{[](int const&amp;amp; input) -&amp;gt; int
                                       { return input + 1; }};
    std::function&amp;lt;int(int)&amp;gt; const std_function_add_one{lambda_function_add_one};

    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a function pointer: &amp;quot; &amp;lt;&amp;lt; sizeof(&amp;amp;add_one)
              &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a std::function pointer: &amp;quot;
              &amp;lt;&amp;lt; sizeof(&amp;amp;std_function_add_one) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a std::function: &amp;quot; &amp;lt;&amp;lt; sizeof(std_function_add_one)
              &amp;lt;&amp;lt; std::endl;

    // Call function frequently in a vanilla way.
    // The compiler knows what function to call at compile time and can optimize
    // the code.
    // This is the best performance we could get.
    std::chrono::steady_clock::time_point const time_start_vanilla{
        std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        output_vector.at(i) = add_one(input_vector.at(i));
    }
    std::chrono::steady_clock::time_point const time_end_vanilla{
        std::chrono::steady_clock::now()};
    auto const time_elapsed_vanilla{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(time_end_vanilla -
                                                             time_start_vanilla)
            .count()};
    float const latency_vanilla{time_elapsed_vanilla /
                                static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass Vanilla: &amp;quot; &amp;lt;&amp;lt; latency_vanilla &amp;lt;&amp;lt; &amp;quot; ns&amp;quot;
              &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // Sometimes, we don&#39;t know what function to call at compile time.
    // We can use std::function to pass a function as an argument.
    // In this case, we pass the std::function by value.
    // Because the size of a std::function is 32 bytes, passing by value
    // results in a lot of copying and bad performance.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_std_function_value{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_std_function_value(
            output_vector.at(i), input_vector.at(i), std_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_std_function_value{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_std_function_value{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_std_function_value -
            time_start_pass_by_std_function_value)
            .count()};
    float const latency_pass_by_std_function_value{
        time_elapsed_pass_by_std_function_value /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Std Function Value: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_std_function_value &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // Instead of passing the std::function by value, we can pass it by
    // reference (pointer). In this case, object copying is eliminated. The
    // performance is better than passing the std::function by value. However,
    // the performance is still not as good as the vanilla way.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_std_function_reference{
            std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_std_function_reference(
            output_vector.at(i), input_vector.at(i), std_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_std_function_reference{
            std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_std_function_reference{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_std_function_reference -
            time_start_pass_by_std_function_reference)
            .count()};
    float const latency_pass_by_std_function_reference{
        time_elapsed_pass_by_std_function_reference /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Std Function Reference: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_std_function_reference &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // std::function is a general purpose wrapper for function pointers,
    // callable objects, and lambda functions. Because it&#39;s general purpose,
    // it&#39;s not as efficient as a function pointer. In this case, we pass a
    // function pointer to a function. The performance is better than passing
    // the std::function by reference.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_function_pointer{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_function_pointer(output_vector.at(i),
                                                  input_vector.at(i), &amp;amp;add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_function_pointer{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_function_pointer{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_function_pointer -
            time_start_pass_by_function_pointer)
            .count()};
    float const latency_pass_by_function_pointer{
        time_elapsed_pass_by_function_pointer /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Function Pointer: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_function_pointer &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // We can also pass a lambda function to a function.
    // The compiler knows what function to call at compile time and can optimize
    // the code. The performance is also better than passing the std::function
    // by reference.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_lambda_function{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_lambda_function(
            output_vector.at(i), input_vector.at(i), lambda_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_lambda_function{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_lambda_function{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_lambda_function -
            time_start_pass_by_lambda_function)
            .count()};
    float const latency_pass_by_lambda_function{
        time_elapsed_pass_by_lambda_function /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Lambda Function: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_lambda_function &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 组里常规也就开启 O2 优化，编译选用了 gcc13，不同版本的 gcc 性能耗时略有不同，版本越高 lambda 效果越好
The size of a function pointer: 8
The size of a std::function pointer: 8
The size of a std::function: 32
Latency Pass Vanilla: 0.418 ns
Latency Pass By Std Function Value: 3.47 ns
Latency Pass By Std Function Reference: 1.36 ns
Latency Pass By Function Pointer: 0.396 ns
Latency Pass By Lambda Function: 0.44 ns
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leimao.github.io/blog/CPP-Function-Call-Performance/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://leimao.github.io/blog/CPP-Function-Call-Performance/&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>C11: sleep for vs yield</title>
        <link>https://blog.ttf248.life/ja/p/c11-sleep-for-vs-yield/</link>
        <pubDate>Tue, 20 Sep 2022 20:54:51 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ja/p/c11-sleep-for-vs-yield/</guid>
        <description>&lt;p&gt;コードを見返しているとき、&lt;code&gt;std::this_thread::yield()&lt;/code&gt; 猛的引入眼帘，&lt;code&gt;C11&lt;/code&gt;里面的语法糖，用了不少，__INLINE_CODE_2__里面的语法糖，用了不少，__を初めて見ました。今まで気づいていませんでした。&lt;/p&gt;
&lt;p&gt;マニュアルを確認する前に、最初に考えたのは非同期処理との関連性だった。__INLINE_CODE_0__Boostライブラリのコルーチン実装でこの単語が使われているが、ここではコルーチンとは関係ないだろう。制御ロジックは通常のスレッドに関連している。&lt;/p&gt;
&lt;h2 id=&#34;文書&#34;&gt;文書
&lt;/h2&gt;&lt;h3 id=&#34;yield&#34;&gt;yield
&lt;/h3&gt;&lt;p&gt;この関数の正確性は、実装に依存し、特に使用されているOSスケジューラ機構とシステムの状態に左右されます。例えば、先着順リアルタイムスケジューラ（LinuxのSCHED_FIFO）は、現在のスレッドを中断し、同じ優先度の他のスレッドがなければ、準備完了キューの末尾に配置します（他のスレッドが存在しない場合、yieldの効果はありません）。&lt;/p&gt;
&lt;h3 id=&#34;sleep_for&#34;&gt;sleep_for
&lt;/h3&gt;&lt;p&gt;指定されたsleep_durationの間、現在のスレッドの実行をブロックします。
この関数は、スケジューリングやリソース競合により、sleep_durationよりも長くブロックされる可能性がある。
標準ライブラリでは、安定したクロックで時間を計測することを推奨します。システム時間を用いる実装の場合、待ち時間もクロック調整に影響される可能性があります。&lt;/p&gt;
&lt;h3 id=&#34;分析&#34;&gt;分析
&lt;/h3&gt;&lt;p&gt;二つの関数は、現在のスレッドがスレッドを占有しなくなるようにするもので、効果はプラットフォームによって異なるようですね。ここまでの説明だけではまだよくわからないので、コードを実行して動作を確認してみます。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;シンクパッド ノートPC（Visual Studio Community Edition 2022）、テンセントクラウド S2 スタンダードサーバー（gcc8.5）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;実行プラットフォーム&lt;/th&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;初回/μs&lt;/th&gt;
&lt;th&gt;第2回/μs&lt;/th&gt;
&lt;th&gt;第3回/μs&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;sleep_for&lt;/td&gt;
&lt;td&gt;9872&lt;/td&gt;
&lt;td&gt;1884&lt;/td&gt;
&lt;td&gt;11302&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;yield&lt;/td&gt;
&lt;td&gt;119&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;sleep_for&lt;/td&gt;
&lt;td&gt;171&lt;/td&gt;
&lt;td&gt;168&lt;/td&gt;
&lt;td&gt;167&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;yield&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;td&gt;102&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;動作結果から容易に理解できるように、オペレーティングシステムの実現方法の違いにより、高精度スリープでは、&lt;strong&gt;INLINE_CODE_0__BOLD_2&lt;code&gt;yield&lt;/code&gt;&lt;/strong&gt; の方が適しています。&lt;/p&gt;
&lt;p&gt;時間精度が__INLINE_CODE_0__に向上しても、両者の差はそれほど顕著ではない。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;thread&amp;gt;
 
// 建议其他线程运行一小段时间的“忙睡眠”
void little_sleep(std::chrono::microseconds us)
{
    auto start = std::chrono::high_resolution_clock::now();
    auto end = start + us;
    do {
        std::this_thread::yield();
    } while (std::chrono::high_resolution_clock::now() &amp;lt; end);
}
 
int main()
{
    auto start = std::chrono::high_resolution_clock::now();
 
    little_sleep(std::chrono::microseconds(100));
    std::this_thread::sleep_for(std::chrono::microseconds(100));
 
    auto elapsed = std::chrono::high_resolution_clock::now() - start;
    std::cout &amp;lt;&amp;lt; &amp;quot;waited for &amp;quot;
              &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(elapsed).count()
              &amp;lt;&amp;lt; &amp;quot; microseconds\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/header/thread.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/header/thread.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/thread/sleep_for.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/thread/sleep_for.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>なぜ新しい言語を学ぶ必要があるのか。</title>
        <link>https://blog.ttf248.life/ja/p/why-learn-a-new-language/</link>
        <pubDate>Thu, 04 Aug 2022 11:27:30 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ja/p/why-learn-a-new-language/</guid>
        <description>&lt;p&gt;学期から数えても、&lt;code&gt;C++&lt;/code&gt;に触れてから十年以上経っているのに、他のプログラミング言語を学ぶ必要性がなぜあるのだろうか。&lt;/p&gt;
&lt;p&gt;エレガントなモジュール設計の経験は不足しているが、文法は自由で、他の言語の学習も、よりエレガントなデザインを導くのに役立つ。&lt;/p&gt;
&lt;p&gt;ツールを開発するときによく使う。&lt;/p&gt;
&lt;p&gt;設計の原則は、基盤ライブラリであろう、ビジネスモジュール実装であろう、どちらも同じです。&lt;/p&gt;</description>
        </item>
        <item>
        <title>標準ライブラリコンテナのメモリ割り当て関数：allocator</title>
        <link>https://blog.ttf248.life/ja/p/standard-library-container-memory-allocator/</link>
        <pubDate>Mon, 30 Dec 2019 13:26:19 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ja/p/standard-library-container-memory-allocator/</guid>
        <description>&lt;p&gt;カスタムアロケータは、パフォーマンスの向上、メモリ効率の改善、および頻繁な小規模メモリ割り当ての問題解決に役立ちます。&lt;/p&gt;
&lt;h4 id=&#34;前縁&#34;&gt;前縁
&lt;/h4&gt;&lt;p&gt;最近、ネットワークデータパケットの開発に携わり、頻繁な小さなメモリの割り当てと解放が必要になった。メモリプールを使用しようと考えたが、既存のメモリプールの調査でこれを発見した。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/cacay/MemoryPool&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/cacay/MemoryPool&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;インターフェースを見たときから、少し疑問に思っていた。このメモリプールの実装がなんだか奇妙だ。__INLINE_CODE_0__的实现逻辑，是在申请固定大小的内存空间。看过boost的内存池接口，提供的是一个模板，用的时候进行实例化。正巧这个库已经有文章进行过介绍，提到了__INLINE_CODE_1__という概念。&lt;/p&gt;
&lt;h4 id=&#34;wikihttpszhwikipediaorgwikie58886e9858de599a8_c2b2b&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_%28C%2B%2B%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wiki&lt;/a&gt;
&lt;/h4&gt;&lt;p&gt;C++プログラミングにおいて、アロケータ（allocator）はC++標準ライブラリの重要な構成要素です。コンテナ（container）と呼ばれる様々なデータ構造（例えば、リストや集合など）が定義されており、これらのコンテナには実行時にサイズを変更できるという共通の特徴があります。この実現のために動的なメモリ割り当てが必要となり、アロケータはそのメモリ割り当てと解放のリクエストを処理するために使用されます。つまり、アロケータはSTLコンテナのメモリ管理における低レベルの詳細をカプセル化するものです。デフォルトでは、C++標準ライブラリは独自の汎用アロケータを使用しますが、必要に応じてプログラマはカスタムアロケータを作成して置き換えることも可能です。&lt;/p&gt;
&lt;p&gt;アロケータは当初、アレクサンドル・ステパノフによってC++標準テンプレートライブラリ（STL）の一部として考案され、「ライブラリをより柔軟にし、基盤となるデータモデルに依存しない方法」を提供し、プログラマがカスタムのポインタや参照型を利用できるようにすることを目的としていました。しかし、C++標準に取り込む際、C++標準委員会は完全なデータモデル抽象化による容認できないパフォーマンス損失を認識し、その代替案としてアロケータに対する制限が厳しくなりました。その結果、現在の規格で記述されているアロケータのカスタマイズ性は、ステパノフの当初の構想に比べて大幅に制限されています。&lt;/p&gt;
&lt;p&gt;割り当て方のカスタマイズには制限があるものの、多くの状況でカスタムアロケータが必要となる場合があり、これは主に異なるメモリ空間（共有メモリやリサイクル済みメモリなど）へのアクセス方法をカプセル化するため、あるいはメモリプールを用いたメモリ割り当て時のパフォーマンス向上を目的として行われる。また、頻繁に少量メモリを割り当てるプログラムにおいては、専用のカスタムアロケータを導入することで、メモリ使用量と実行時間の両面で大きな恩恵が得られる場合がある。&lt;/p&gt;
&lt;h4 id=&#34;申し訳ありませんが翻訳する中国語のテキストが提供されていませんテキストを提供していただければ日本語に翻訳します&#34;&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。
&lt;/h4&gt;&lt;p&gt;カスタムアロケータを定義する主な理由の一つは、パフォーマンスの向上です。専用のカスタムアロケータを使用することで、プログラムのパフォーマンスを向上させたり、メモリ使用効率を高めたり、あるいはその両方を実現できます。[4][8] デフォルトのアロケータはnew演算子を使用してメモリ空間を割り当てますが、これはしばしばC言語のヒープ割り当て関数（malloc()）によって実装されます。[9] ヒープ割り当て関数は、大量のメモリを一度に割り当てる場合に最適化されていることが多いため、ベクトルや両端キューなどのメモリを大量に割り当てるコンテナでは、デフォルトのアロケータは一般的に効率的です。[8] しかし、連想コンテナや双方向リストなど、頻繁に少量ずつメモリを割り当てる必要があるコンテナの場合、デフォルトのアロケータを使用すると通常、効率が低下します。[4][9] さらに、malloc()ベースのデフォルトアロケータには、参照局所性の低さ[4]や、メモリ断片化を引き起こす可能性[4][9]などの問題も存在します。&lt;/p&gt;
&lt;p&gt;要するに、この部分（……）は、この規格がディスペンサーに対して行う「私には夢がある」のスピーチのようなものだ。夢が実現するまでは、可搬性を気遣うプログラマーは、ステートレスなカスタムアロケータの使用に縛られることになるだろう。
スコット・メイヤーズ『Effective STL』
この状況を鑑みると、頻繁な少量メモリ割り当ての問題を解決するために、メモリプールベースの割り当て器がよく用いられる[8]。デフォルトの「オンデマンド割り当て」とは異なり、メモリプールベースの割り当て器では、プログラムは事前に大きなメモリブロック（「メモリプール」）を確保し、メモリが必要な際には、カスタム割り当て器は単にプールのメモリへのポインタを要求者に返すだけです。オブジェクトの破棄時には、実際にメモリを解放する代わりに、メモリプールのライフサイクルが終了した時点でまとめて解放されます[注 1][8]。&lt;/p&gt;
&lt;p&gt;「カスタムアロケータ」という話題に関して、すでに多くのC++専門家や関連著者が議論に参加しており、例えばスコット・メイヤーズの『Effective STL』やアンドレイ・アレクサンドレスキューの『Modern C++ Design』にも言及されています。メイヤーズは、ある型Tに対するアロケータのすべてのインスタンスが等しいと要求する場合、可搬性のあるアロケータのインスタンスは状態を含んではならないことに気づきました。C++標準は、ライブラリの実装者がステートフルなアロケータをサポートすることを推奨していますが[文 4]、メイヤーズはこの関連箇所を「（一見）素晴らしい考え」と述べつつも、ほとんどナンセンスであり、アロケータの制限は「あまりにも厳しすぎる」[4]と批判しています。例えば、STLのlistはspliceメソッドを許可しており、これはlistオブジェクトAのノードが直接別のlistオブジェクトBに移動されることを意味します。これにより、Aのアロケータによって割り当てられたメモリが、Bのアロケータによって解放可能である必要があり、それによりAとBのアロケータインスタンスが等しいことが推論されます。メイヤーズの結論は、アロケータを静的方法を使用する型として定義するのが最適であるというものです。例えば、C++標準によると、アロケータはrebindメソッドを実装したotherクラステンプレートを提供する必要があります。&lt;/p&gt;
&lt;p&gt;另外、C++プログラミング言語のビアニ・ストラウスルップは、「各オブジェクトの情報が異なることを防ぐための厳格なアロケータの制限」については「問題ない」（大意）と述べ、ほとんどのアロケータには状態が必要なく、むしろ状態がない方が性能が良い場合もあると指摘しています。彼は、メモリプール型アロケータ、共有メモリ型アロケータ、ガベージコレクション型アロケータという3つのカスタムアロケータの利用例を提示し、内部メモリプールを利用して少量メモリを高速に割り当て/解放するアロケータの実装例を示しました。しかし、彼はそのような最適化は既に彼が提供しているサンプルアロケータで実現されている可能性もあると述べています。[3]&lt;/p&gt;
&lt;p&gt;カスタムアロケータの別の用途は、メモリ関連のエラーをデバッグすることです[10]。そのためには、割り当て時に追加のメモリを割り当ててデバッグ情報を格納するアロケータを作成できます。このようなアロケータは、メモリが同じ種類の割り当て/解放アロケータによって割り当て/解放されることを保証するだけでなく、キャッシュオーバーフローからプログラムをある程度保護することもできます[11]。&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
