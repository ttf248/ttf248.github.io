<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>C&#43;&#43; on 向叔の手帳</title>
        <link>https://ttf248.life/ja/tags/c-/</link>
        <description>Recent content in C&#43;&#43; on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Sun, 25 May 2025 14:10:37 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/tags/c-/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>C&#43;&#43; ビット演算の基礎：ビットごとの値の取得とフラグ設定</title>
        <link>https://ttf248.life/ja/p/cpp-bitwise-operations-basics-flags/</link>
        <pubDate>Fri, 17 Jan 2025 02:23:56 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cpp-bitwise-operations-basics-flags/</guid>
        <description>&lt;p&gt;実際のC++開発において、ビット演算は一般的な技術であり、特にシステム状態、フラグ、または制御ビットを扱う際には、非常に効率的な解決策を提供します。本稿では、例を通して、ビット演算を使用して特定のフラグを取得および設定する方法について解説します。&lt;/p&gt;
&lt;h3 id=&#34;ビット演算の基本概念&#34;&gt;ビット演算の基本概念
&lt;/h3&gt;&lt;p&gt;コンピュータでは、データは2進数のビット（0と1）で格納されます。ビット演算とは、これらの2進数のビットに対して行う操作のことです。C++にはいくつかの一般的なビット演算子があります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ビットごとの論理積(&amp;amp;)：あるビットが1であるかどうかを確認するために使用されます。&lt;/li&gt;
&lt;li&gt;ビットごとに、または（|）を使用します。あるビットを1に設定するために使用されます。&lt;/li&gt;
&lt;li&gt;ビットごとの排他的OR（^）：あるビットを反転するために使用されます。&lt;/li&gt;
&lt;li&gt;各ビットを反転する。&lt;/li&gt;
&lt;li&gt;左シフト（&amp;laquo;）：すべてのビットをいくつか左にずらす。&lt;/li&gt;
&lt;li&gt;右シフト（&amp;raquo;）：すべてのビットをいくつか右に移動します。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この例では、&lt;code&gt;unsigned short&lt;/code&gt; 型の変数 &lt;code&gt;wInfo&lt;/code&gt; に対して一連のビット演算を行い、異なるフラグによって異なる状態を表します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;flowchart LR
    A[原始数值: 00010000] --&amp;gt; B[左移: 00010000 &amp;lt;&amp;lt; 1]
    B --&amp;gt; C[结果: 00100000]
    C --&amp;gt; D[右移: 00100000 &amp;gt;&amp;gt; 1]
    D --&amp;gt; E[结果: 00010000]

    subgraph 左移操作
        direction LR
        A --&amp;gt; B --&amp;gt; C
    end

    subgraph 右移操作
        direction LR
        C --&amp;gt; D --&amp;gt; E
    end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;要求分析&#34;&gt;要求分析
&lt;/h3&gt;&lt;p&gt;題目の説明に基づき、異なる状態を表すために使用される16ビットのフラグがあります。これらの状態は、様々な二進数のビットによって示され、各二進数のビットは特定の意味に対応しています。例えば：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ビット０は失敗したか？&lt;/li&gt;
&lt;li&gt;ビット1は圧縮されていますか？&lt;/li&gt;
&lt;li&gt;bit2は増分されているか&lt;/li&gt;
&lt;li&gt;bit3に後続パッケージはありますか。&lt;/li&gt;
&lt;li&gt;通常リクエストまたはログアウト&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;位演算を使用する&#34;&gt;位演算を使用する
&lt;/h3&gt;&lt;p&gt;これらのフラグビットを設定および取得するには、ビット演算を使用します。具体的には：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ビットごとの値を取得する。&lt;/li&gt;
&lt;li&gt;ビット設定：あるビットを1に設定する。&lt;/li&gt;
&lt;li&gt;ビットクリア：あるビットを0に設定する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;まず、これらのフラグを保持するために &lt;code&gt;unsigned short&lt;/code&gt; 型の変数 &lt;code&gt;wInfo&lt;/code&gt; を定義します。その後、ビット演算を使用して、対応するフラグを確認および設定します。&lt;/p&gt;
&lt;h3 id=&#34;cサンプルコード&#34;&gt;C++サンプルコード
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;bitset&amp;gt;

// 定义标志位常量
const unsigned short BIT_0_FAIL = 1 &amp;lt;&amp;lt; 0;    // bit0 是否失败
const unsigned short BIT_1_COMPRESSED = 1 &amp;lt;&amp;lt; 1; // bit1 是否压缩
const unsigned short BIT_2_INCREMENT = 1 &amp;lt;&amp;lt; 2;  // bit2 是否增量
const unsigned short BIT_3_HAS_MORE = 1 &amp;lt;&amp;lt; 3;   // bit3 是否有后续包
const unsigned short BIT_5_CANCEL = 1 &amp;lt;&amp;lt; 5;     // bit5 正常请求(0)或注销(1)

// 检查某一位是否为1
bool isBitSet(unsigned short wInfo, unsigned short bitMask) {
    return (wInfo &amp;amp; bitMask) != 0;
}

// 设置某一位为1
void setBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo |= bitMask;
}

// 清除某一位（设置为0）
void clearBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo &amp;amp;= ~bitMask;
}

int main() {
    // 假设wInfo的初始值为0
    unsigned short wInfo = 0;

    // 设置bit0（失败标志）
    setBit(wInfo, BIT_0_FAIL);
    
    // 设置bit1（压缩标志）
    setBit(wInfo, BIT_1_COMPRESSED);
    
    // 打印wInfo的二进制值
    std::cout &amp;lt;&amp;lt; &amp;quot;wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    // 检查各个标志位
    std::cout &amp;lt;&amp;lt; &amp;quot;bit0 (是否失败): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_0_FAIL) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit1 (是否压缩): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_1_COMPRESSED) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit2 (是否增量): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_2_INCREMENT) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit3 (是否有后续包): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_3_HAS_MORE) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit5 (是否注销): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_5_CANCEL) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;

    // 清除bit1（压缩标志）
    clearBit(wInfo, BIT_1_COMPRESSED);
    
    // 打印更新后的wInfo
    std::cout &amp;lt;&amp;lt; &amp;quot;Updated wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;コード実行、おすすめは旧友：&lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wInfo (in binary): 0000000000000011
bit0 (是否失败): 是
bit1 (是否压缩): 是
bit2 (是否增量): 否
bit3 (是否有后续包): 否
bit5 (是否注销): 否
Updated wInfo (in binary): 0000000000000001
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;コードの説明&#34;&gt;コードの説明
&lt;/h3&gt;&lt;p&gt;フラグの定義：ビットシフト演算（&lt;code&gt;1 &amp;lt;&amp;lt; n&lt;/code&gt;）を使用して、各フラグを定義します。例えば、&lt;code&gt;1 &amp;lt;&amp;lt; 0&lt;/code&gt;は&lt;code&gt;bit0&lt;/code&gt;に対応し、&lt;code&gt;1 &amp;lt;&amp;lt; 1&lt;/code&gt;は&lt;code&gt;bit1&lt;/code&gt;に対応します。このように、各フラグに一意な二進数の位置を割り当てます。&lt;/p&gt;
&lt;p&gt;特定のビットを確認する：&lt;code&gt;isBitSet&lt;/code&gt;関数は、ビット演算&lt;code&gt;wInfo &amp;amp; bitMask&lt;/code&gt;によって特定のフラグが1であるかどうかを確認します。そのビットが1であれば、関数は&lt;code&gt;true&lt;/code&gt;を返し、そうでなければ&lt;code&gt;false&lt;/code&gt;を返します。&lt;/p&gt;
&lt;p&gt;設定ビット：&lt;code&gt;setBit&lt;/code&gt;関数は、ビット単位のOR演算&lt;code&gt;wInfo |= bitMask&lt;/code&gt;によって特定のフラグを1に設定します。&lt;/p&gt;
&lt;p&gt;特定のビットをクリアする：&lt;code&gt;clearBit&lt;/code&gt;関数は、ビットAND演算&lt;code&gt;wInfo &amp;amp;= ~bitMask&lt;/code&gt;によって特定フラグを0に設定します。&lt;/p&gt;
&lt;h3 id=&#34;まとめ&#34;&gt;まとめ
&lt;/h3&gt;&lt;p&gt;ビット演算を用いることで、複数の状態フラグを効率的に処理できます。特に開発現場では、この技術は非常に役立ちます。例えば、組み込み開発、ネットワークプロトコル、システムの状態管理など、多くの場面でビットフラグを用いて複数の二進数状態を表し、スペースの節約と効率向上を図ることがあります。&lt;/p&gt;
&lt;p&gt;このブログが、C++でビット演算を使用してビット単位での値の取得と設定をどのように行うかを理解するのに役立つことを願っています。これらのスキルを習得することは、効率的で保守しやすいコードを作成する上で非常に役立ちます！&lt;/p&gt;</description>
        </item>
        <item>
        <title>GCC、GLIBC と C&#43;&#43; プログラムの互換性問題に関する深い理解</title>
        <link>https://ttf248.life/ja/p/deep-understanding-gcc-glibc-cpp-compatibility-issues/</link>
        <pubDate>Mon, 06 Jan 2025 19:51:16 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/deep-understanding-gcc-glibc-cpp-compatibility-issues/</guid>
        <description>&lt;p&gt;C++の開発分野において、GCCとGLIBCは避けて通れない重要な要素であり、プログラムのリリース後の互換性の問題も開発者を悩ませることがよくあります。本稿では、これらの本質を深く分析し、互換性の問題の根本原因とその対策について探求します。&lt;/p&gt;
&lt;h2 id=&#34;一gcc堅固なコンパイラ基盤&#34;&gt;一、GCC：堅固なコンパイラ基盤
&lt;/h2&gt;&lt;p&gt;定義と機能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC（GNU コンパイラ コレクション）は、GNUプロジェクトが開発したオープンソースのコンパイラスイートです。これは単なるコンパイラではなく、C、C++、Objective-C、Fortran、Ada、Goなど、多様な主要言語をサポートし、クロス言語開発のためのワンストップソリューションを提供します。&lt;/li&gt;
&lt;li&gt;C++ を例にとると、クラス、テンプレート、関数オーバーロードなどの複雑な機能を備えたソースファイルを記述する際、GCC は C++ の厳格な文法と意味規則に基づいて、高度な C++ コードを、基盤となる機械が理解し実行できる命令シーケンスに変換することができます。このプロセスには、語彙解析、構文解析、意味解析、最適化、コード生成など、複数の精緻な段階が含まれます。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;コンパイルプロセス詳解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;前処理段階&lt;/strong&gt;: GCCはまず、ソースファイルを前処理します。この間、 &lt;code&gt;#&lt;/code&gt;で始まるすべてのプリプロセッサディレクティブを処理します。例えば、&lt;code&gt;#include&lt;/code&gt;ディレクティブは、指定されたヘッダファイル（C++の入出力ストリーム操作に使用される&lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt;など）の内容全体をソースファイルの対応する位置に埋め込み、プログラムがヘッダファイルで宣言されている関数やクラスなどのリソースを使用できるようにします。また、&lt;code&gt;#define&lt;/code&gt;ディレクティブで定義されたマクロもこの段階で展開置換されます。例えば、&lt;code&gt;#define PI 3.14159&lt;/code&gt;の場合、ソースファイル内のすべての&lt;code&gt;PI&lt;/code&gt;の箇所が&lt;code&gt;3.14159&lt;/code&gt;に置き換えられます。前処理後、ソースファイルは初期「拡充」されます。&lt;/li&gt;
&lt;li&gt;コンパイル段階：前処理されたファイルはコンパイルの段階に入り、GCC は C++ 言語標準に基づいてソースファイルをアセンブリ言語コードに変換します。クラスの継承、ポリモーフィズムの実装、関数呼び出しパラメータのマッチングなど、コード構造を厳密にチェックし、文法や意味に合致しないエラーが見つかった場合は、速やかにエラーを出力してコンパイルプロセスを終了します。例えば、関数宣言と定義のパラメータリストが一致しない場合、GCC は問題箇所を正確に指摘します。&lt;/li&gt;
&lt;li&gt;アセンブリ段階：アセンブラは前段階で生成されたアセンブリコードを機械語に変換し、&lt;code&gt;.o&lt;/code&gt;という拡張子のオブジェクトファイルを生成します。これらのオブジェクトファイルには、機械が直接実行できるバイナリ命令が含まれていますが、通常、完全なプログラムは複数のモジュールから構成され、各モジュール間の関数や変数の参照関係が解決されていないため、単独で実行することはできません。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;リンク段階&lt;/strong&gt;：これは実行可能ファイルを生成する最後のスパートです。リンカは複数のオブジェクトファイルと必要なライブラリファイル（静的ライブラリまたは動的ライブラリ）を統合します。例えば、C++標準テンプレートライブラリのコンテナクラスを使用する場合、リンク時には対応するライブラリの実装コードを見つける必要があります。プログラム実行時に&lt;code&gt;vector&lt;/code&gt;や&lt;code&gt;list&lt;/code&gt;などのコンテナ機能を正しく呼び出せるようにし、最終的に完全な実行可能プログラムを生成します。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二glibccプログラムを支える舞台裏&#34;&gt;二、GLIBC：C++プログラムを支える舞台裏
&lt;/h2&gt;&lt;p&gt;本質と役割&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GLIBC（GNU C Library）は、C標準ライブラリのGNUエコシステムにおける具体的な実装です。名前がCを強調していますが、C++プログラムもそれに強く依存しており、なぜならC++はCの基礎部分を受け継いでいるからです。メモリ管理のための&lt;code&gt;malloc&lt;/code&gt;（動的メモリ割り当て）、&lt;code&gt;free&lt;/code&gt;（メモリ解放）のような膨大な基本関数を提供し、これらはC++で動的な配列やオブジェクトを作成する際に不可欠です。また、&lt;code&gt;strcpy&lt;/code&gt;（文字列コピー）、&lt;code&gt;strcat&lt;/code&gt;（文字列連結）といった文字列処理関数も、C++に&lt;code&gt;string&lt;/code&gt;クラスがあるにも関わらず、Cコードとの連携や最高のパフォーマンスを追求する場合に利用されます。さらに、&lt;code&gt;printf&lt;/code&gt;、&lt;code&gt;scanf&lt;/code&gt;などの標準入出力関数も、C++の初期開発段階や、性能に敏感で簡潔さを追求する場面で頻繁に見られます。
システムとの連携&lt;/li&gt;
&lt;li&gt;GLIBCは、オペレーティングシステムとアプリケーションの間の重要な橋渡し役を果たします。Linuxシステムにおいて、C++プログラムがシステムコールを発行する際、例えばファイルを開く（&lt;code&gt;open&lt;/code&gt;関数を使用し、その基盤としてGLIBCの実装に依存）場合、GLIBCはそのプログラムのリクエストをオペレーティングシステムのカーネルが定める方法でカプセル化し、カーネルに渡します。カーネルの処理が完了すると、GLIBCは結果をアプリケーションに戻します。これにより、アプリケーションはオペレーティングシステムの複雑なシステムコールインターフェースの詳細を深く理解することなく、ファイルシステム、ネットワーク、プロセス管理などの様々なシステムリソースを簡単に利用できるようになります。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cプログラム公開後の互換性の問題分析&#34;&gt;C++プログラム公開後の互換性の問題分析
&lt;/h2&gt;&lt;p&gt;GLIBCバージョンの違いによる互換性の問題&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;異なる Linux ディストリビューションは、しばしば異なるバージョンの GLIBC を搭載しています。C++ プログラムが高バージョン GLIBC 環境でコンパイルされると、意図せずしてそのバージョンで新たに追加された関数機能を利用したり、より最適化された関数実装に依存したりすることがあります。例えば、新しい GLIBC バージョンではメモリ割り当てアルゴリズムが改善されており、プログラムは実行時にこの新アルゴリズムを頻繁に利用することでパフォーマンスを向上させます。しかし、このプログラムを低バージョン GLIBC システム上で動作させると、対応する関数が見つからない（低バージョンで導入されていないため）あるいは関数の挙動が異常になる（旧版の関数実装ロジックと新版にずれがある）といった問題が発生し、プログラムがクラッシュしたり、結果が誤ったものになったりする可能性があります。
コンパイラの違いによる互換性の問題&lt;/li&gt;
&lt;li&gt;たとえ同じGCCコンパイラを使用した場合でも、異なるバージョンのGCCでは、コード生成、標準ライブラリのサポート、およびC++機能の実装の詳細に違いがあります。新しいバージョンのGCCは、C++20の新機能（モジュールやコルーチンなど）を完全にサポートしている可能性がありますが、これらの最先端機能を活用したプログラムを古いバージョンのGCCでコンパイルすると、コンパイラが新しい構文構造を認識できないためにエラーが発生します。また、構文エラーがない場合でも、異なるGCCバージョン間の最適化戦略の違いにより、生成される機械語の実行効率やメモリ使用量が大きく異なり、パフォーマンスが重要なシナリオでは、プログラムの動作が異なる環境で大きく異なる結果になる可能性があります。
システムアーキテクチャの差異がもたらす課題&lt;/li&gt;
&lt;li&gt;C++プログラムは、x86、ARM、PowerPCなどの異なるハードウェアシステムアーキテクチャ上で動作する必要がある場合があります。各アーキテクチャには、独自の命令セット、メモリレイアウト、データアライメント要件があります。例えば、データアライメントに関して言えば、x86アーキテクチャで正常に動作する構造体データの格納レイアウトが、ARMアーキテクチャではアライメント規則の違いによりメモリアクセス異常を引き起こし、結果としてプログラムのエラーにつながる可能性があります。さらに、GCCは異なるアーキテクチャ向けにコンパイルすると生成される機械語が大きく異なり、プログラム中にハードコードされたアーキテクチャ固有の命令や仮定が存在する場合、クロスアーキテクチャでの実行時に頻繁な障害が発生するでしょう。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四互換性の問題への対応策&#34;&gt;四、互換性の問題への対応策
&lt;/h2&gt;&lt;p&gt;静的リンクライブラリの応用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静的にリンクされたライブラリを使用することを検討してください。プログラムが依存する GLIBC などのライブラリのコードを、実行ファイルに直接パッケージングします。そうすることで、プログラムは実行時にターゲットシステム上の特定の GLIBC のバージョンに依存しなくなり、GLIBC のバージョンの不一致によって引き起こされる問題を効果的に回避できます。ただし、静的リンクは実行ファイルのサイズを大幅に増加させるため、ストレージリソースが限られたシナリオでは、メリットとデメリットを比較検討する必要があります。
コンテナデプロイメント&lt;/li&gt;
&lt;li&gt;Dockerなどのコンテナ化技術を活用し、C++プログラムとその実行環境（特定のバージョンのGCC、GLIBCなど）を独立したコンテナにパッケージングします。これにより、基盤となるオペレーティングシステムが何であれ、コンテナ内部は常にプログラム開発時の環境を維持し、プログラムが期待通りに動作することを保証します。また、異なる環境へのデプロイメントの複雑さを大幅に軽減します。
互換性テストと継続的インテグレーション&lt;/li&gt;
&lt;li&gt;包括さまざまなGLIBCバージョン、GCCバージョン、および一般的なシステムアーキテクチャを網羅した、包括的な互換性テスト体系を構築する。開発プロセス中に、継続的インテグレーションツールを使用して、複数の環境で定期的に自動テストを実施し、互換性の問題が発見された場合は迅速に修正することで、潜在的な問題を初期段階で扼殺し、プログラムのリリース後の安定性を確保する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上記を総合すると、GCCとGLIBCの動作メカニズムを深く理解し、C++プログラムの互換性問題の根本原因を正確に把握し、柔軟に対処戦略を用いることは、すべてのC++開発者が堅牢でクロスプラットフォームなアプリケーションを構築するために不可欠なスキルです。そうすることで初めて、私たちのC++作品は多様な技術エコシステムの中で円滑に進むことができるでしょう。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Linuxバックエンドサービス、大量文字列データの処理が遅い</title>
        <link>https://ttf248.life/ja/p/linux-backend-slow-string-processing/</link>
        <pubDate>Wed, 13 Nov 2024 19:42:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-backend-slow-string-processing/</guid>
        <description>&lt;p&gt;C++開発の過去プロジェクトにおいて、独自のプロトコルを使用して通信しており、そのプロトコルは二次元配列の形式を採用していました。大量のデータを処理する際、プロトコル内で配列を走査し、シリアライズ操作によってログを生成する必要がありましたが、効率が悪かったため、高負荷時にシステムが顕著にカクつき、業務部門からシステムの動作不良に関するフィードバックがありました。&lt;/p&gt;
&lt;h2 id=&#34;問題特定&#34;&gt;問題特定
&lt;/h2&gt;&lt;p&gt;問題の調査 során、まずシステムのパフォーマンス分析を行い、大量のデータを処理する際に CPU 使用率が大幅に増加し、システム応答時間が長くなることを発見しました。システムのログを分析した結果、大量のシリアライズ操作があり、これらの操作は 2 次元配列の処理において効率が悪く、システムパフォーマンスの低下につながっていました。&lt;/p&gt;
&lt;p&gt;pstackツールでサービスの糸処理情報を取得したところ、ログスレッドの大部分の時間文字列の結合処理に費やされていることがわかった。&lt;/p&gt;
&lt;p&gt;今日の焦点は、異なる累積方法による効率の大きな違いです。過去のコードでは「+」演算子を使用しており、この方法は頻繁に一時オブジェクトを作成するため、非常に非効率的です。それが非効率的だと知っていても、どれほど非効率的なのかを理解していないようなものです。&lt;/p&gt;
&lt;h2 id=&#34;デモ検証&#34;&gt;デモ検証
&lt;/h2&gt;&lt;p&gt;プロジェクトコードに基づいて、業務ロジックを分離し、文字列結合の効率に関する検証のために簡単なデモを作成しました。&lt;code&gt;windows&lt;/code&gt; の &lt;code&gt;vs2022&lt;/code&gt; コンパイラ、&lt;code&gt;linux&lt;/code&gt; の &lt;code&gt;gcc8.5&lt;/code&gt; コンパイラで、&lt;code&gt;Release&lt;/code&gt; モードでコンパイル・実行し、効率を比較します。&lt;/p&gt;
&lt;h3 id=&#34;重要なポイント説明&#34;&gt;重要なポイント説明
&lt;/h3&gt;&lt;p&gt;プロジェクトでは手法4を使用しており、テストデータを入手する前に、読者はどの方法が最も効率的か、またどの方法が最も非効率かを考えてみることができます。結果を見たときには、やはり驚きました。&lt;/p&gt;
&lt;p&gt;方法 1（&lt;code&gt;+=&lt;/code&gt; 連結）：各フィールドを &lt;code&gt;+=&lt;/code&gt; を使って文字列に連結します。
方法 2 ( &lt;code&gt;std::ostringstream&lt;/code&gt; による結合) ：ストリーム (&lt;code&gt;std::ostringstream&lt;/code&gt;) を用いて各フィールドを結合する方法です。この方法は特に、大量のデータを結合する場合に効率的です。
方法3（事前にメモリを割り当てた&lt;code&gt;+=&lt;/code&gt;連結）：&lt;code&gt;reserve&lt;/code&gt;を使って文字列に十分なメモリを事前に割り当てることで、メモリの再割り当てにかかるコストを削減し、パフォーマンスが向上します。
方法 4 ( &lt;code&gt;bodys = bodys + body + &amp;quot;\n&amp;quot;&lt;/code&gt; ) : 毎回新しい一時的な文字列オブジェクトを作成するため、パフォーマンスが低下します。特に大規模な結合の場合、結合ごとに新しいメモリ割り当てとコピーが発生するためです。&lt;/p&gt;
&lt;p&gt;参照結果を見ると、プロジェクトは効率が最も悪い方法が選択されたようです。&lt;/p&gt;
&lt;p&gt;さらに踏み込んで、各プラットフォームのコンパイラ最適化効率を分析してみましょう。MicrosoftのVisual Studioは相変わらず優れており、文字列の最適化効率は非常に高いですが、GCCコンパイラはその点では少し劣ります。&lt;/p&gt;
&lt;p&gt;コードを異なる機械で実行すると、2つのデータには直接的な比較の意味がないため、それぞれの結合方法間の差異を別々に比較できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;windows 平台下的 vs2022 编译器

----------------------------------------
Data Generation Time: 0.054 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.053 seconds.
+ ostringstream Data merging took: 0.054 seconds.
+ Pre-reserved Data merging took: 0.045 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 16.108 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;linux 平台下的 gcc8.5 编译器
----------------------------------------
Data Generation Time: 0.108 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.100 seconds.
+ ostringstream Data merging took: 0.083 seconds.
+ Pre-reserved Data merging took: 0.057 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 29.298 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完全コード&#34;&gt;完全コード
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;random&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;iomanip&amp;gt;

typedef std::vector&amp;lt;std::string&amp;gt; DataRow;
typedef std::vector&amp;lt;DataRow&amp;gt; DataGroup;

struct ResponsePackage
{
    std::string ErrorInfo;
    DataRow Head;
    std::string ClientId;
    std::string UUID;
    std::string MsgID;
    std::string SessionID;
    std::string ExtraInfo1;
    std::string ExtraInfo2;
    DataGroup DataBody;
};

// Generate specified length of random string
std::string generateRandomString(size_t length)
{
    const char charset[] = &amp;quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&amp;quot;;
    const size_t max_index = sizeof(charset) - 1;
    std::string random_string;
    random_string.reserve(length);

    std::random_device rd;
    std::mt19937 generator(rd());
    std::uniform_int_distribution&amp;lt;&amp;gt; distribution(0, max_index);

    for (size_t i = 0; i &amp;lt; length; ++i)
    {
        random_string += charset[distribution(generator)];
    }

    return random_string;
}

void create_large_string()
{
    // Example request package with 50 fields
    ResponsePackage requestPackage;

    requestPackage.Head = {
        &amp;quot;Field1&amp;quot;, &amp;quot;Field2&amp;quot;, &amp;quot;Field3&amp;quot;, &amp;quot;Field4&amp;quot;, &amp;quot;Field5&amp;quot;,
        &amp;quot;Field6&amp;quot;, &amp;quot;Field7&amp;quot;, &amp;quot;Field8&amp;quot;, &amp;quot;Field9&amp;quot;, &amp;quot;Field10&amp;quot;,
        &amp;quot;Field11&amp;quot;, &amp;quot;Field12&amp;quot;, &amp;quot;Field13&amp;quot;, &amp;quot;Field14&amp;quot;, &amp;quot;Field15&amp;quot;,
        &amp;quot;Field16&amp;quot;, &amp;quot;Field17&amp;quot;, &amp;quot;Field18&amp;quot;, &amp;quot;Field19&amp;quot;, &amp;quot;Field20&amp;quot;,
        &amp;quot;Field21&amp;quot;, &amp;quot;Field22&amp;quot;, &amp;quot;Field23&amp;quot;, &amp;quot;Field24&amp;quot;, &amp;quot;Field25&amp;quot;,
        &amp;quot;Field26&amp;quot;, &amp;quot;Field27&amp;quot;, &amp;quot;Field28&amp;quot;, &amp;quot;Field29&amp;quot;, &amp;quot;Field30&amp;quot;,
        &amp;quot;Field31&amp;quot;, &amp;quot;Field32&amp;quot;, &amp;quot;Field33&amp;quot;, &amp;quot;Field34&amp;quot;, &amp;quot;Field35&amp;quot;,
        &amp;quot;Field36&amp;quot;, &amp;quot;Field37&amp;quot;, &amp;quot;Field38&amp;quot;, &amp;quot;Field39&amp;quot;, &amp;quot;Field40&amp;quot;,
        &amp;quot;Field41&amp;quot;, &amp;quot;Field42&amp;quot;, &amp;quot;Field43&amp;quot;, &amp;quot;Field44&amp;quot;, &amp;quot;Field45&amp;quot;,
        &amp;quot;Field46&amp;quot;, &amp;quot;Field47&amp;quot;, &amp;quot;Field48&amp;quot;, &amp;quot;Field49&amp;quot;, &amp;quot;Field50&amp;quot;
    };

    requestPackage.ClientId = &amp;quot;ClientID&amp;quot;;
    requestPackage.UUID = &amp;quot;UUID&amp;quot;;
    requestPackage.MsgID = &amp;quot;MsgID&amp;quot;;
    requestPackage.SessionID = &amp;quot;SessionID&amp;quot;;
    requestPackage.ExtraInfo1 = &amp;quot;ExtraInfo1&amp;quot;;
    requestPackage.ExtraInfo2 = &amp;quot;ExtraInfo2&amp;quot;;

    // Start timing for data generation
    auto start_gen = std::chrono::high_resolution_clock::now();

    // Generate 10,000 rows of data, each with 50 fields
    for (size_t i = 0; i &amp;lt; 10000; ++i)
    {
        DataRow dataRow(50, &amp;quot;This is a test string&amp;quot;);
        requestPackage.DataBody.push_back(dataRow);
    }

    // End timing for data generation
    auto end_gen = std::chrono::high_resolution_clock::now();
    std::chrono::duration&amp;lt;double&amp;gt; duration_gen = end_gen - start_gen;

    // Display result generation time
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Generation Time: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_gen.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    // Data merging using different methods
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Performance:\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    {
        // Method 1: Using &#39;+=&#39; string concatenation
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (+=) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 2: Using ostringstream
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::ostringstream bodys;
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::ostringstream body;
            body &amp;lt;&amp;lt; &amp;quot;This is a test string&amp;quot;;
            for (auto&amp;amp; item : vec)
            {
                body &amp;lt;&amp;lt; item &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            }
            bodys &amp;lt;&amp;lt; body.str() &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ ostringstream Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 3: Pre-allocated memory
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys;
        bodys.reserve(1000 * 50 * 20); // Pre-allocate enough memory
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            body.reserve(50 * 20); // Pre-allocate memory for each row
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Pre-reserved Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 4: Using &#39;bodys = bodys + body + &amp;quot;\n&amp;quot;&#39;
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body = body + item + &amp;quot; &amp;quot;; // Note the use of &#39;body = body + item&#39;
            }
            bodys = bodys + body + &amp;quot;\n&amp;quot;; // Again, using &#39;bodys = bodys + body&#39;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (bodys = bodys + body + \&amp;quot;\\n\&amp;quot;) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Complete.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;
}

int main()
{
    try
    {
        create_large_string();
    }
    catch (const std::exception&amp;amp; e)
    {
        std::cerr &amp;lt;&amp;lt; &amp;quot;Caught exception: &amp;quot; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\nProgram finished.\n&amp;quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43;ラムダ式パラメータのライフサイクル</title>
        <link>https://ttf248.life/ja/p/cpp-lambda-parameter-lifetime/</link>
        <pubDate>Wed, 13 Nov 2024 19:23:02 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cpp-lambda-parameter-lifetime/</guid>
        <description>&lt;p&gt;C++において、ラムダ式は便利な匿名関数であり、外部変数をキャプチャしてその内部で使用できます。これにより、ラムダ式は柔軟なプログラミングツールとなります。ただし、ラムダ式のパラメータのライフサイクルは特に注意すべき点であり、特にキャプチャおよびパラメータの伝送時にはそうです。&lt;/p&gt;
&lt;h3 id=&#34;ラムダ式のパラメータのライフサイクル&#34;&gt;ラムダ式のパラメータのライフサイクル
&lt;/h3&gt;&lt;p&gt;ラムダ式のパラメータの寿命は、通常、他のC++関数と同様です。関数のパラメータは、関数呼び出し中に存在し、関数呼び出しが終了すると、パラメータの寿命は終了します。しかしながら、ラムダ式が外部変数にキャプチャする場合、パラメータの寿命はキャプチャ方法の影響も受けます。&lt;/p&gt;
&lt;h3 id=&#34;キャプチャとパラメータのライフサイクルとの関係&#34;&gt;キャプチャとパラメータのライフサイクルとの関係
&lt;/h3&gt;&lt;h4 id=&#34;21-外部変数の捕捉&#34;&gt;2.1 外部変数の捕捉
&lt;/h4&gt;&lt;p&gt;C++のラムダ式は、外部変数を2つの方法でキャプチャできます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;値キャプチャ：値キャプチャによって、外部変数の値がラムダ関数内にコピーされ、そのコピーのライフサイクルはラムダ関数のライフサイクルによって制御されます。&lt;/li&gt;
&lt;li&gt;参照獲得：参照獲得により、外部変数の参照は保持され、ラムダ内の参照は元の外部変数を示し、寿命はその外部変数に依存します。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda_by_value = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };  // 捕获x的副本
auto lambda_by_reference = [&amp;amp;x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };  // 捕获x的引用

lambda_by_value();  // 打印10
lambda_by_reference();  // 打印10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;捕捉された変数のライフサイクルは以下の通りです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;値によるキャプチャ：キャプチャされたとき、外部変数の値がラムダにコピーされます。そして、ラムダのライフサイクルが終わると、そのコピーが破棄されます。&lt;/li&gt;
&lt;li&gt;参照によるキャプチャ：ラムダが外部変数への参照を持つ場合、&lt;strong&gt;外部変数はラムダの使用前に有効である必要があり、そうでないと未定義の動作が発生する可能性がある&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ラムダパラメータ&#34;&gt;ラムダパラメータ
&lt;/h4&gt;&lt;p&gt;ラムダのパラメータは通常の関数パラメータと同様で、そのライフサイクルはラムダ関数内に限定されます。つまり、ラムダパラメータはラムダ呼び出し時に作成され、ラムダ呼び出しが終了すると、パラメータのライフサイクルも終了します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto lambda = [](int a, int b) {
    std::cout &amp;lt;&amp;lt; a + b &amp;lt;&amp;lt; std::endl;
};
lambda(5, 10);  // a和b在这里是lambda的参数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この例では、&lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; はラムダ式のパラメータであり、ラムダ式の呼び出し時に作成され、実行終了後に破棄されます。&lt;/p&gt;
&lt;h3 id=&#34;キャプチャした外部変数のライフサイクルに関する問題&#34;&gt;キャプチャした外部変数のライフサイクルに関する問題
&lt;/h3&gt;&lt;h4 id=&#34;キャプチャされた変数はラムダ関数外で有効に利用できるか&#34;&gt;キャプチャされた変数は、ラムダ関数外で有効に利用できるか。
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;値によるキャプチャ：ラムダ呼び出し後に外部変数が破棄されても、ラムダ内部は外部変数のコピーを保持します。したがって、外部変数はもう存在しなくても、ラムダ内部のコピーは安全に使用できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x 在lambda调用后修改
lambda();  // 打印10，捕获的是x的副本
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;参照によるキャプチャ：ラムダが外部変数の参照をキャプチャする場合、ラムダ内部でのその参照へのアクセスは外部変数のライフサイクルに依存します。外部変数がラムダの実行前に破棄されると、ハングリング参照の問題が発生し、未定義の動作につながる可能性があります。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [&amp;amp;x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x 在lambda调用前修改
lambda();  // 打印20，捕获的是x的引用
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ラムダの実行順序が確定しない場合、ラムダが実行される際にキャプチャされた外部変数が有効であることを保証することが非常に重要です。&lt;/p&gt;</description>
        </item>
        <item>
        <title>GCCバージョンアップによりプログラムがクラッシュ：非標準コードの潜在的な問題</title>
        <link>https://ttf248.life/ja/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</link>
        <pubDate>Sun, 10 Mar 2024 23:19:06 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</guid>
        <description>&lt;p&gt;同一のビジネスコードの場合、プログラムは CentOS 7 環境で正常にコンパイルされ実行されたが、CentOS 8 に切り替えて更新版 GCC でコンパイルするとクラッシュした。問題が発生するのは &lt;strong&gt;Release モード&lt;/strong&gt; のみであり、&lt;strong&gt;Debug モード&lt;/strong&gt; では全く問題がない点が重要である。我々はこのような状況を初めて遭遇し、3 日間の調査の結果、ようやく問題の根本原因を見つけ出した。&lt;/p&gt;
&lt;h3 id=&#34;問題特定&#34;&gt;問題特定
&lt;/h3&gt;&lt;p&gt;一連の調査の結果、問題の根本原因は &lt;strong&gt;関数に返り値がないこと&lt;/strong&gt;です。Release モードでは GCC の新バージョンがより多くの最適化を行うため、元々明示的な返り値のない関数が実行中に予期せぬ動作を起こし、クラッシュを引き起こしています。結論として、&lt;strong&gt;コンパイラの警告を無視することは許されません。特に古いプロジェクトにおいては、一部の警告が無視されている可能性もありますが、すべての警告を遮断することは避けるべきです&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;環境説明&#34;&gt;環境説明
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CentOS 7 GCCバージョン：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39)
Copyright © 2015 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CentOS 8 GCCバージョン：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 8.5.0 20210514 (Red Hat 8.5.0-21)
Copyright (C) 2018 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;クラッシュ現象&#34;&gt;クラッシュ現象
&lt;/h3&gt;&lt;p&gt;プログラムクラッシュのスタックを解析した結果、以下のスタック情報が見られました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[New LWP 1385902]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib64/libthread_db.so.1&amp;quot;.
Core was generated by `./pstack_main`.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007ffe894b4420 in ?? ()
(gdb) bt
#0  0x00007ffe894b4420 in ?? ()
#1  0x00000000004008e9 in main ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このスタックは直感的ではなく、クラッシュした関数のスタック情報が「??」として表示されているため、問題の特定がより複雑になっています。&lt;/p&gt;
&lt;h3 id=&#34;コード例&#34;&gt;コード例
&lt;/h3&gt;&lt;p&gt;問題をより良く理解するために、クラッシュを再現する最小限のコード例を以下に示します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int test() {
    std::cout &amp;lt;&amp;lt; &amp;quot;1&amp;quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    test();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;そのコードの &lt;code&gt;test()&lt;/code&gt; 関数は明らかに値を明示的に返していませんが、戻り値の型は &lt;code&gt;int&lt;/code&gt; です。C++ の仕様によると、関数が &lt;code&gt;int&lt;/code&gt; 型として宣言されている場合、必ず値を返す必要があり、そうしないと未定義の動作を引き起こす可能性があります。&lt;/p&gt;
&lt;h3 id=&#34;コンパイル警告&#34;&gt;コンパイル警告
&lt;/h3&gt;&lt;p&gt;私たちのプロジェクトでは、CMakeスクリプトによって多くのコンパイル時の警告が抑制されており、その中には以下の警告メッセージが含まれています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/root/pstack/main.cpp: In function ‘int test()’:
/root/pstack/main.cpp:7:1: warning: no return statement in function returning non-void [-Wreturn-type]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この警告は、&lt;code&gt;test()&lt;/code&gt;関数が値を返していないことを示しており、これが問題の根本原因です。高度なバージョンのGCC（例えば8.5.0）は、コードを最適化する際に、このような未定義の振る舞いに不安定な最適化を行い、プログラムがクラッシュする可能性があります。&lt;/p&gt;
&lt;h3 id=&#34;アセンブリコードの差異&#34;&gt;アセンブリコードの差異
&lt;/h3&gt;&lt;p&gt;GCCコンパイラ最適化の動作の違いを説明するために、異なるバージョンのGCCが生成するアセンブリコードを比較しました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;GCC 4.8.5 が生成したアセンブリコード：&lt;/p&gt;
&lt;p&gt;アセンブリコードは比較的冗長であり、標準出力ストリーム（例えば &lt;code&gt;std::cout&lt;/code&gt;）の処理ロジックも含まれています。これはコンパイラがより保守的な最適化を行ったことを示しており、&lt;code&gt;test()&lt;/code&gt; 関数における戻り値がない問題に対して過度な最適化を行わず、その結果、クラッシュを回避できた可能性があります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GCC 8.5.0 が生成したアセンブリコード：&lt;/p&gt;
&lt;p&gt;新しいバージョンのGCCでは、より多くの最適化が行われ、コード量が削減されました。しかし、この最適化により、戻り値がない関数の実行時に動作が不安定になり、プログラムがクラッシュする可能性があります。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;結論&#34;&gt;結論
&lt;/h3&gt;&lt;p&gt;今回の問題の調査を通じて、C++ においては&lt;strong&gt;関数の戻り値が明確に定義されている必要がある&lt;/strong&gt;ということを深く認識しました。特に、関数を &lt;code&gt;int&lt;/code&gt; として宣言した場合、必ず戻り値を返す必要があります。古いバージョンのコンパイラを使用しているプロジェクトでは、新しいバージョンの GCC にアップグレードすると、より多くの最適化や厳格な警告メカニズムが発生する可能性があります。したがって、コンパイル時に&lt;strong&gt;すべての警告を無視するのではなく&lt;/strong&gt;、関数からの戻り値や型の一致など、一般的な問題を中心に選択的に処理することをお勧めします。&lt;/p&gt;
&lt;p&gt;最終、&lt;code&gt;test()&lt;/code&gt;関数に返り値を加えることで問題が解決し、プログラムは正常に動作するようになりました。&lt;/p&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43;プログラミングの落とし穴：`std::map` の誤った使用によるプログラムクラッシュの詳細解説</title>
        <link>https://ttf248.life/ja/p/cpp-programming-traps-std-map-crash-details/</link>
        <pubDate>Sun, 10 Mar 2024 22:03:06 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cpp-programming-traps-std-map-crash-details/</guid>
        <description>&lt;p&gt;C++プログラミングにおいて、&lt;code&gt;std::map&lt;/code&gt;コンテナの誤った使用がプログラムをクラッシュさせる可能性があることを明らかにすることを目的としています。角括弧演算子で存在しないキーにアクセスしようとすると、自動的に空要素が追加されます。この誤解について深く分析し、サンプルコードを通じて潜在的なリスクを示します。&lt;/p&gt;
&lt;p&gt;単純な値を格納する分には問題ありませんが、ポインタを格納すると問題が発生します。ポインタはアドレスであり、初期化されていない場合、そのアドレスは未確定となり、プログラムのクラッシュにつながる可能性があります。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;C++標準ライブラリにおいて、&lt;code&gt;std::map&lt;/code&gt;は関連コンテナであり、キーによる昇順に要素を格納し、効率的なキーワード検索機能を提供します。しかし、初心者開発者は、&lt;code&gt;std::map&lt;/code&gt;の角括弧演算子 &lt;code&gt;[]&lt;/code&gt; の動作に関する理解違いから苦労することがあります。実際には、&lt;code&gt;[]&lt;/code&gt;を使って存在しないキーにアクセスすると、&lt;code&gt;std::map&lt;/code&gt;は新しいキーと値のペアを挿入し、デフォルトコンストラクタを使用してそのキーに対応する値の型を初期化します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int main() {
    std::map&amp;lt;std::string, int&amp;gt; myMap;
    
    // 错误的用法：假设这里试图访问一个不存在的键并认为会得到0
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for &#39;nonexistent_key&#39;: &amp;quot; &amp;lt;&amp;lt; myMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;

    // 实际上，上述行代码创建了一个新的键值对，其中值被默认初始化为int的默认值（通常是0）
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記のコードはプログラムを直接クラッシュさせることはありませんが、このような暗黙的な挿入処理は、リソースリークや予期しない状態変化といった副作用を引き起こす可能性があります。さらに悪いことに、マルチスレッド環境で未初期化のメモリ領域に同時にアクセスすると、プログラムがクラッシュする可能性もあります。&lt;/p&gt;
&lt;p&gt;そのような問題を防ぐために、&lt;code&gt;std::map::find()&lt;/code&gt;または&lt;code&gt;std::map::count()&lt;/code&gt;メソッドを使用してキーの存在を確認するか、&lt;code&gt;std::map::insert()&lt;/code&gt;メソッドを用いて明示的に要素を挿入することを推奨します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::map&amp;lt;std::string, int&amp;gt; safeMap;
if (safeMap.count(&amp;quot;nonexistent_key&amp;quot;) == 0) {
    std::cout &amp;lt;&amp;lt; &amp;quot;Key does not exist.&amp;quot; &amp;lt;&amp;lt; std::endl;
} else {
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for existing key: &amp;quot; &amp;lt;&amp;lt; safeMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;
}

// 或者明确插入一个键值对，指定初始值
safeMap.insert({ &amp;quot;new_key&amp;quot;, 0 });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;もしmapコンテナ内にポインタ型のオブジェクトが格納されている場合、要素を自動的に挿入すると初期化されていないポインタが保存され、そのポインタに対するいかなる操作もプログラムのクラッシュにつながる可能性があります。&lt;/p&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43;関数呼び出しにかかる時間</title>
        <link>https://ttf248.life/ja/p/cpp-function-call-timing/</link>
        <pubDate>Wed, 24 Jan 2024 14:11:33 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cpp-function-call-timing/</guid>
        <description>&lt;p&gt;設計のSDKについて、様々なコールバック関数の実装方法で、時間のかかるテストを実施しました。最近はC++の関数プログラミングを見ており、関数がファーストクラスオブジェクトとなり、プログラム内で流通すると、パフォーマンスに違いはありますか？&lt;/p&gt;
&lt;p&gt;先行記事へのリンク：[コンパイラ、コールバック関数、パフォーマンステスト]({&amp;lt; relref &amp;ldquo;/post/2023/02-15-コンパイラ、コールバック関数、パフォーマンステスト&amp;rdquo; &amp;gt;}})&lt;/p&gt;
&lt;p&gt;雷冒大佬正好也做了类似测试，借了代码来用。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;実行プラットフォームは、引き続き弊社の旧友である &lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt; です。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;cassert&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

int add_one(int input) { return input + 1; }

bool validate_vector_add_one(std::vector&amp;lt;int&amp;gt; const&amp;amp; input_vector,
                             std::vector&amp;lt;int&amp;gt; const&amp;amp; output_vector)
{
    bool is_valid{true};
    for (size_t i{0}; i &amp;lt; input_vector.size(); ++i)
    {
        if (output_vector.at(i) != input_vector.at(i) + 1)
        {
            is_valid = false;
            break;
        }
    }
    return is_valid;
}

void reset_vector(std::vector&amp;lt;int&amp;gt;&amp;amp; input_vector)
{
    for (size_t i{0}; i &amp;lt; input_vector.size(); ++i)
    {
        input_vector.at(i) = 0;
    }
}

template &amp;lt;typename T, typename Func&amp;gt;
void unitary_function_pass_by_lambda_function(T&amp;amp; output, T const&amp;amp; input,
                                              Func const func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_std_function_value(T&amp;amp; output, T const&amp;amp; input,
                                                 std::function&amp;lt;T(T)&amp;gt; const func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_std_function_reference(
    T&amp;amp; output, T const&amp;amp; input, std::function&amp;lt;T(T)&amp;gt; const&amp;amp; func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_function_pointer(T&amp;amp; output, T const&amp;amp; input,
                                               T (*func)(T))
{
    output = func(input);
}

int main()
{
    // Set floating point format std::cout with 3 decimal places.
    std::cout.precision(3);

    size_t const num_elements{10000000};
    std::vector&amp;lt;int&amp;gt; input_vector(num_elements, 0);
    std::vector&amp;lt;int&amp;gt; output_vector(num_elements, 0);

    auto const lambda_function_add_one{[](int const&amp;amp; input) -&amp;gt; int
                                       { return input + 1; }};
    std::function&amp;lt;int(int)&amp;gt; const std_function_add_one{lambda_function_add_one};

    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a function pointer: &amp;quot; &amp;lt;&amp;lt; sizeof(&amp;amp;add_one)
              &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a std::function pointer: &amp;quot;
              &amp;lt;&amp;lt; sizeof(&amp;amp;std_function_add_one) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a std::function: &amp;quot; &amp;lt;&amp;lt; sizeof(std_function_add_one)
              &amp;lt;&amp;lt; std::endl;

    // Call function frequently in a vanilla way.
    // The compiler knows what function to call at compile time and can optimize
    // the code.
    // This is the best performance we could get.
    std::chrono::steady_clock::time_point const time_start_vanilla{
        std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        output_vector.at(i) = add_one(input_vector.at(i));
    }
    std::chrono::steady_clock::time_point const time_end_vanilla{
        std::chrono::steady_clock::now()};
    auto const time_elapsed_vanilla{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(time_end_vanilla -
                                                             time_start_vanilla)
            .count()};
    float const latency_vanilla{time_elapsed_vanilla /
                                static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass Vanilla: &amp;quot; &amp;lt;&amp;lt; latency_vanilla &amp;lt;&amp;lt; &amp;quot; ns&amp;quot;
              &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // Sometimes, we don&#39;t know what function to call at compile time.
    // We can use std::function to pass a function as an argument.
    // In this case, we pass the std::function by value.
    // Because the size of a std::function is 32 bytes, passing by value
    // results in a lot of copying and bad performance.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_std_function_value{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_std_function_value(
            output_vector.at(i), input_vector.at(i), std_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_std_function_value{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_std_function_value{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_std_function_value -
            time_start_pass_by_std_function_value)
            .count()};
    float const latency_pass_by_std_function_value{
        time_elapsed_pass_by_std_function_value /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Std Function Value: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_std_function_value &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // Instead of passing the std::function by value, we can pass it by
    // reference (pointer). In this case, object copying is eliminated. The
    // performance is better than passing the std::function by value. However,
    // the performance is still not as good as the vanilla way.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_std_function_reference{
            std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_std_function_reference(
            output_vector.at(i), input_vector.at(i), std_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_std_function_reference{
            std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_std_function_reference{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_std_function_reference -
            time_start_pass_by_std_function_reference)
            .count()};
    float const latency_pass_by_std_function_reference{
        time_elapsed_pass_by_std_function_reference /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Std Function Reference: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_std_function_reference &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // std::function is a general purpose wrapper for function pointers,
    // callable objects, and lambda functions. Because it&#39;s general purpose,
    // it&#39;s not as efficient as a function pointer. In this case, we pass a
    // function pointer to a function. The performance is better than passing
    // the std::function by reference.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_function_pointer{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_function_pointer(output_vector.at(i),
                                                  input_vector.at(i), &amp;amp;add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_function_pointer{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_function_pointer{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_function_pointer -
            time_start_pass_by_function_pointer)
            .count()};
    float const latency_pass_by_function_pointer{
        time_elapsed_pass_by_function_pointer /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Function Pointer: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_function_pointer &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // We can also pass a lambda function to a function.
    // The compiler knows what function to call at compile time and can optimize
    // the code. The performance is also better than passing the std::function
    // by reference.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_lambda_function{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_lambda_function(
            output_vector.at(i), input_vector.at(i), lambda_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_lambda_function{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_lambda_function{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_lambda_function -
            time_start_pass_by_lambda_function)
            .count()};
    float const latency_pass_by_lambda_function{
        time_elapsed_pass_by_lambda_function /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Lambda Function: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_lambda_function &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 组里常规也就开启 O2 优化，编译选用了 gcc13，不同版本的 gcc 性能耗时略有不同，版本越高 lambda 效果越好
The size of a function pointer: 8
The size of a std::function pointer: 8
The size of a std::function: 32
Latency Pass Vanilla: 0.418 ns
Latency Pass By Std Function Value: 3.47 ns
Latency Pass By Std Function Reference: 1.36 ns
Latency Pass By Function Pointer: 0.396 ns
Latency Pass By Lambda Function: 0.44 ns
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leimao.github.io/blog/CPP-Function-Call-Performance/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://leimao.github.io/blog/CPP-Function-Call-Performance/&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>C11: sleep for vs yield</title>
        <link>https://ttf248.life/ja/p/c11-sleep-for-vs-yield/</link>
        <pubDate>Tue, 20 Sep 2022 20:54:51 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/c11-sleep-for-vs-yield/</guid>
        <description>&lt;p&gt;コードを見返しているとき、&lt;code&gt;std::this_thread::yield()&lt;/code&gt;が突然目に飛び込んできた。&lt;code&gt;C11&lt;/code&gt;の文法糖化は結構使われているけど、&lt;code&gt;yield&lt;/code&gt;自体は初めて見かける。今まで気にしてなかった。&lt;/p&gt;
&lt;p&gt;マニュアルを確認する前に、最初に考えたのは非同期処理との関連性だった。「yield」がBoostライブラリのコルーチンの実装で使用されているため、ここではコルーチンとは関係ないだろう。制御ロジックは通常のスレッドに関連している。&lt;/p&gt;
&lt;h2 id=&#34;文書&#34;&gt;文書
&lt;/h2&gt;&lt;h3 id=&#34;yield&#34;&gt;yield
&lt;/h3&gt;&lt;p&gt;この関数の正確性は、実装に依存し、特に使用されているOSスケジューラメカニズムとシステムの状態に左右されます。例えば、先着順のリアルタイムスケジューラ（Linux の SCHED_FIFO ）は、現在のスレッドを中断し、同じ優先度のスレッドが実行可能になるキューの末尾に配置します（他のスレッドがない場合、yield は効果がありません）。&lt;/p&gt;
&lt;h3 id=&#34;sleep_for&#34;&gt;sleep_for
&lt;/h3&gt;&lt;p&gt;スレッドの実行をブロックし、指定されたsleep_duration時間だけ待機します。
この関数は、スケジューリングやリソースの競合が遅延させるため、sleep_durationよりも長い時間ブロックされる可能性があります。
標準ライブラリでは、安定したクロックで時間を計測することを推奨します。実装がシステム時間を使用する場合、待ち時間もクロック調整に影響される可能性があります。&lt;/p&gt;
&lt;h3 id=&#34;分析&#34;&gt;分析
&lt;/h3&gt;&lt;p&gt;二つの関数は、現在のスレッドがスレッドを占有しなくなるようにするもので、効果はプラットフォームによって異なるようですね。ここまでの説明だけではまだよく分からないので、コードを実行して実行結果を確認してみます。&lt;/p&gt;
&lt;p&gt;シンパッド ノートPC（Visual Studio Community Edition 2022）、テンセントクラウド S2 スタンダードサーバー（gcc8.5）&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;実行プラットフォーム&lt;/th&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;初回/μs&lt;/th&gt;
&lt;th&gt;第2回/μs&lt;/th&gt;
&lt;th&gt;第3回/μs&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;sleep_for&lt;/td&gt;
&lt;td&gt;9872&lt;/td&gt;
&lt;td&gt;1884&lt;/td&gt;
&lt;td&gt;11302&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;yield&lt;/td&gt;
&lt;td&gt;119&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;sleep_for&lt;/td&gt;
&lt;td&gt;171&lt;/td&gt;
&lt;td&gt;168&lt;/td&gt;
&lt;td&gt;167&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;yield&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;td&gt;102&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;実行結果から容易に理解できるように、オペレーティングシステムの実現方法によって、高精度スリープの &lt;code&gt;sleep_for&lt;/code&gt; の安定性は大きく異なります。高精度なスリープが必要な場合は、 &lt;code&gt;yield&lt;/code&gt; の使用がより適切です。&lt;/p&gt;
&lt;p&gt;時間精度が&lt;code&gt;ms&lt;/code&gt;に向上しても、両者の差はそれほど顕著ではない。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;thread&amp;gt;
 
// 建议其他线程运行一小段时间的“忙睡眠”
void little_sleep(std::chrono::microseconds us)
{
    auto start = std::chrono::high_resolution_clock::now();
    auto end = start + us;
    do {
        std::this_thread::yield();
    } while (std::chrono::high_resolution_clock::now() &amp;lt; end);
}
 
int main()
{
    auto start = std::chrono::high_resolution_clock::now();
 
    little_sleep(std::chrono::microseconds(100));
    std::this_thread::sleep_for(std::chrono::microseconds(100));
 
    auto elapsed = std::chrono::high_resolution_clock::now() - start;
    std::cout &amp;lt;&amp;lt; &amp;quot;waited for &amp;quot;
              &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(elapsed).count()
              &amp;lt;&amp;lt; &amp;quot; microseconds\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参照&#34;&gt;参照
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/header/thread.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/header/thread.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/thread/sleep_for.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/thread/sleep_for.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>新しい言語を学ぶ必要があるのはなぜか。</title>
        <link>https://ttf248.life/ja/p/why-learn-a-new-language/</link>
        <pubDate>Thu, 04 Aug 2022 11:27:30 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/why-learn-a-new-language/</guid>
        <description>&lt;p&gt;学校時代から数えても、すでに10年以上前からC++に触れているのに、他のプログラミング言語を学ぶ必要性がどこにあるのだろうか。&lt;/p&gt;
&lt;p&gt;仕事経験：エレガントなモジュール設計の経験は乏しいが、&lt;code&gt;C++&lt;/code&gt; の文法は自由度が高く、他の言語を学ぶことでよりエレガントな設計を書けるようになる。&lt;/p&gt;
&lt;p&gt;ツールを開発するときに、よく使う。&lt;/p&gt;
&lt;p&gt;基盤ライブラリの設計も、ビジネスモジュールの実装も、設計の原則は同じです。&lt;/p&gt;</description>
        </item>
        <item>
        <title>標準ライブラリコンテナのメモリ割り当て器：allocator</title>
        <link>https://ttf248.life/ja/p/standard-library-container-memory-allocator/</link>
        <pubDate>Mon, 30 Dec 2019 13:26:19 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/standard-library-container-memory-allocator/</guid>
        <description>&lt;p&gt;カスタムアロケータは、パフォーマンスの向上、メモリ効率の改善、および頻繁な小規模メモリ割り当ての問題解決に役立ちます。&lt;/p&gt;
&lt;h4 id=&#34;前の原因&#34;&gt;前の原因
&lt;/h4&gt;&lt;p&gt;最近、ネットワークデータパケットの開発に携わり、頻繁に小さなメモリ領域を確保・解放する必要がある。元々メモリプールを使用しようと考えていたが、既存のメモリプールをいくつか調べてみたところ、これを発見した&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/cacay/MemoryPool&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/cacay/MemoryPool&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;インターフェースを見たときから、ちょっと違和感がある。このメモリプールの実装がどうも奇妙だ。&lt;code&gt;MemoryPool&lt;/code&gt;の実装ロジックは、固定サイズのメモリ空間を確保している。Boostのメモリプールインターフェースを見ると、テンプレートで、使用時にインスタンス化される。ちょうどこのライブラリについてはすでに記事があり、&lt;code&gt;allocator&lt;/code&gt;という概念が言及されている。&lt;/p&gt;
&lt;h4 id=&#34;wikihttpszhwikipediaorgwikie58886e9858de599a8_c2b2b&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_%28C%2B%2B%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wiki&lt;/a&gt;
&lt;/h4&gt;&lt;p&gt;C++プログラミングにおいて、アロケータ（allocator, 英語）はC++標準ライブラリの重要な構成要素です。C++ライブラリには、連結リストや集合など、さまざまな「コンテナ」と呼ばれるデータ構造が定義されており、これらのコンテナに共通する特徴の一つとして、そのサイズをプログラム実行時に変更できることが挙げられます。この実現のためには、動的なメモリ割り当てが不可欠であり、アロケータはそのメモリの割り当てと解放のリクエストを処理するために使用されます。言い換えれば、アロケータは標準テンプレートライブラリ（STL）コンテナにおけるメモリ管理の低レベルの詳細をカプセル化するものです。デフォルトでは、C++標準ライブラリは独自の汎用アロケータを使用しますが、必要に応じて、プログラマは独自のカスタムアロケータを作成して置き換えることもできます。&lt;/p&gt;
&lt;p&gt;アロケータは当初、アレクサンドル・ステパノフによってC++標準テンプレートライブラリ（STL）の一部として考案され、その目的は「ライブラリをより柔軟にし、基になるデータモデルに依存しない方法」を提供し、プログラマがカスタムのポインタや参照型をライブラリで利用できるようにすることであった。しかし、C++標準委員会が標準テンプレートライブラリをC++規格に組み込む際に、データモデルの完全な抽象化は許容できないパフォーマンス損失をもたらす可能性があることに気づき、その折衷案として、規格におけるアロケータの制限が厳しくなった。そして、これに鑑みて、現在の規格で記述されているアロケータのカスタマイズ性は、ステパノフの当初の構想と比較して大幅に制限されている。&lt;/p&gt;
&lt;p&gt;割り当てのカスタマイズには制限があるものの、多くの状況ではカスタムアロケータが必要となる場合があり、これは通常、共有メモリや回収済みメモリなどの異なる種類のメモリ空間へのアクセス方法をカプセル化するため、あるいはメモリプールを使用したメモリ割り当て時のパフォーマンス向上を目的として行われる。さらに、メモリ使用量と実行時間の観点からは、頻繁に少量ずつメモリを割り当てるプログラムにおいて、そのために特化したアロケータを導入することで大きな恩恵を得られる場合がある。&lt;/p&gt;
&lt;h4 id=&#34;利用要件&#34;&gt;利用要件
&lt;/h4&gt;&lt;p&gt;定義カスタムアロケータの主な理由の一つは、パフォーマンスの向上です。専用のカスタムアロケータを使用することで、プログラムのパフォーマンスを向上させたり、メモリ使用効率を高めたり、あるいはその両方を実現できます[4][8]。デフォルトのアロケータはnew演算子を使用してストレージ空間を割り当てますが、これはしばしばC言語のヒープ割り当て関数（malloc()）によって実装されます[9]。ヒープ割り当て関数は、頻繁に大量のメモリを割り当てるために最適化されていることが多いため、一度に大量のメモリを割り当てるコンテナ（ベクトルや双方向キューなど）の場合、デフォルトのアロケータは一般的に効率的です[8]。しかし、連想コンテナや双方向リンク付きリストなどの、頻繁に少量ずつメモリを割り当てる必要があるコンテナの場合、デフォルトのアロケータを使用すると通常、効率が非常に低くなります[4][9]。さらに、malloc()ベースのデフォルトアロケータには、参照局所性の低下[4]や、メモリ断片化を引き起こす可能性[4][9]などの問題も存在します。&lt;/p&gt;
&lt;p&gt;簡単に言うと、この部分（……）は、まるでこの規格がディスペンサーに対して行う「私には夢がある」という演説のようです。夢が実現するまでは、可搬性を気遣うプログラマーは、（使用に）ステートレスなカスタムディスペンサーに自分を限定してしまうでしょう。
——スコット・メイヤーズ『Effective STL』
この状況を鑑みると、頻繁な少量メモリ割り当ての問題を解決するために、メモリプールベースの割り当て器がよく用いられる[8]。デフォルトの「オンデマンド割り当て」とは異なり、メモリプールベースの割り当て器を使用する場合、プログラムは事前に大きなメモリブロック（「メモリプール」）を割り当てておき、メモリが必要な際には、カスタム割り当て器は単にプールのメモリへのポインタを要求者に返すだけです。オブジェクトが破棄される際にも、実際にメモリを解放する必要はなく、メモリプールのライフサイクルが終了した時点で初めてメモリを解放します[注 1][8]。&lt;/p&gt;
&lt;p&gt;「カスタムアロケータ」という話題に関して、すでに多くのC++専門家や関連著者が議論に参加しており、例えばスコット・メイヤーズの『Effective STL』やアンドレイ・アレクサンドレスクの『Modern C++ Design』にも言及されています。メイヤーズは、ある型Tに対するアロケータのすべてのインスタンスが等しいと要求する場合、可搬性のためのアロケータのインスタンスには状態が含まれてはならないことに気づきました。C++標準は、ライブラリの実装者がステートフルなアロケータをサポートすることを推奨していますが[文 4]、メイヤーズは関連する段落が「（一見）素晴らしい考え」であるものの、ほとんどナンセンスであり、アロケータの制限は「あまりにも厳しすぎる」と述べています[4]。例えば、STLのlistはspliceメソッドを許可しており、これはlistオブジェクトAのノードが直接別のlistオブジェクトBに移動できることを意味します。これにより、Aのアロケータによって割り当てられたメモリが、Bのアロケータによって解放される必要があり、それによりAとBのアロケータインスタンスが等しいことが推論されます。メイヤーズの結論は、アロケータを静的方法を使用する型として定義するのが最適であるということです。例えば、C++標準によると、アロケータはrebindメソッドを実装したotherクラステンプレートを提供する必要があります。&lt;/p&gt;
&lt;p&gt;另外、C++プログラミング言語の著者であるビヤニ・ストロストループは、「各オブジェクトの情報が異なることを防ぐための厳格なアロケータの制限」については「問題ない」（大意）と述べ、ほとんどのアロケータには状態が必要なく、むしろ状態がない方が性能が向上することさえあると指摘しています。彼は、メモリプール型アロケータ、共有メモリ型アロケータ、ガベージコレクション型アロケータという3つのカスタムアロケータの利用例を提示し、内部メモリプールを利用して少量メモリを迅速に割り当て/解放するアロケータの実装を示しました。しかし、彼はそのような最適化は既に彼が提供しているサンプルアロケータで実現されている可能性があると述べています[3]。&lt;/p&gt;
&lt;p&gt;カスタムアロケータの別の用途は、メモリ関連のエラーをデバッグすることです[10]。これを実現するには、割り当て時に追加のメモリを割り当てて、そこにデバッグ情報を格納するアロケータを作成できます。このようなアロケータは、メモリが同じ種類の割り当て/解放アロケータによって割り当て/解放されることを保証するだけでなく、ある程度プログラムをバッファオーバーフローから保護することもできます[11]。&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
