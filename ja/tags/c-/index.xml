<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>C&#43;&#43; on 向叔の手帳</title>
        <link>https://ttf248.life/ja/tags/c-/</link>
        <description>Recent content in C&#43;&#43; on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Mon, 02 Jun 2025 19:00:25 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/tags/c-/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>C&#43;&#43; ビット演算の基礎：ビットごとのANDとフラグ設定</title>
        <link>https://ttf248.life/ja/p/cpp-bitwise-operations-flags/</link>
        <pubDate>Fri, 17 Jan 2025 02:23:56 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cpp-bitwise-operations-flags/</guid>
        <description>&lt;p&gt;実際のC++開発において、ビット演算は一般的な技術であり、特にシステムの状態、フラグビット、または制御ビットを扱う際に、非常に効率的な解決策を提供します。本稿では、例を通して、ビット演算を使用して特定のフラグビットを取得および設定する方法について解説します。&lt;/p&gt;
&lt;h3 id=&#34;ビット演算の基礎概念&#34;&gt;ビット演算の基礎概念
&lt;/h3&gt;&lt;p&gt;コンピュータでは、データは2進数（0と1）のビットで格納されます。ビット演算とは、これらのビットに対して操作を行うことです。C++には、いくつかの一般的なビット演算演算子が用意されています：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;論理積（&amp;amp;）&lt;/strong&gt;：特定のビットが1かどうかを確認します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;論理和（|）&lt;/strong&gt;：特定のビットを1に設定します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;排他的論理和（^）&lt;/strong&gt;：特定のビットを反転させます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ビット反転（~）&lt;/strong&gt;：すべてのビットを反転させます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;左シフト（&amp;laquo;）&lt;/strong&gt;：すべてのビットを左に指定した数だけシフトします。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;右シフト（&amp;raquo;）&lt;/strong&gt;：すべてのビットを右に指定した数だけシフトします。
本例では、&lt;code&gt;unsigned short&lt;/code&gt; 型の変数 &lt;code&gt;wInfo&lt;/code&gt; に対して、さまざまなビット演算を実行し、異なるフラグを使用して状態を表す必要があります。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ビット演算の基礎概念-1&#34;&gt;ビット演算の基礎概念
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;flowchart LR
    A[元の数値: 00010000] --&amp;gt; B[左シフト: 00010000 &amp;lt;&amp;lt; 1]
    B --&amp;gt; C[結果: 00100000]
    C --&amp;gt; D[右シフト: 00100000 &amp;gt;&amp;gt; 1]
    D --&amp;gt; E[結果: 00010000]

    subgraph 左シフト操作
        direction LR
        A --&amp;gt; B --&amp;gt; C
    end

    subgraph 右シフト操作
        direction LR
        C --&amp;gt; D --&amp;gt; E
    end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;要求分析&#34;&gt;要求分析
&lt;/h3&gt;&lt;p&gt;問題文の記述に基づき、16ビットのフラグビットがあり、これを用いて様々な状態を表します。これらの状態は、個々のバイナリビットによって表現され、各バイナリビットは特定の意味に対応しています。例えば：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;bit0&lt;/strong&gt; が失敗かどうか&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit1&lt;/strong&gt; が圧縮されているかどうか&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit2&lt;/strong&gt; が増量であるかどうか&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit3&lt;/strong&gt; が後続のパケットがあるかどうか&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit5&lt;/strong&gt; が正常なリクエストまたは注销かどうか&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;位演算による実装&#34;&gt;位演算による実装
&lt;/h3&gt;&lt;p&gt;ビット演算を用いてこれらのフラグを設定および取得します。具体的には：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ビットごとの抽出 (Bitwise Extraction)&lt;/strong&gt;: 特定のビットの値（0または1）を取得します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ビットごとの設定 (Bitwise Setting)&lt;/strong&gt;: 特定のビットを1に設定します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ビットごとのクリア (Bitwise Clearing)&lt;/strong&gt;: 特定のビットを0に設定します。
最初に &lt;code&gt;unsigned short&lt;/code&gt; 型の変数 &lt;code&gt;wInfo&lt;/code&gt; を定義し、これらのフラグを保存するために使用します。その後、ビット演算を用いて対応するフラグを確認および設定します。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;c-のサンプルコード&#34;&gt;C++ のサンプルコード
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;bitset&amp;gt;

// フラグ位定数定義
const unsigned short BIT_0_FAIL = 1 &amp;lt;&amp;lt; 0;    // bit0 が失敗したかどうか
const unsigned short BIT_1_COMPRESSED = 1 &amp;lt;&amp;lt; 1; // bit1 が圧縮されたかどうか
const unsigned short BIT_2_INCREMENT = 1 &amp;lt;&amp;lt; 2;  // bit2 が増量されたかどうか
const unsigned short BIT_3_HAS_MORE = 1 &amp;lt;&amp;lt; 3;   // bit3 に後続のパケットがあるかどうか
const unsigned short BIT_5_CANCEL = 1 &amp;lt;&amp;lt; 5;     // bit5 は正常なリクエスト(0)か、注销(1)か

// あるビットがセットされているか確認する
bool isBitSet(unsigned short wInfo, unsigned short bitMask) {
    return (wInfo &amp;amp; bitMask) != 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;### C++ のサンプルコード
// ビットを設定する
void setBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo |= bitMask;
}

// ビットをクリアする（0に設定）
void clearBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo &amp;amp;= ~bitMask;
}

int main() {
    // wInfo の初期値を 0 と仮定
    unsigned short wInfo = 0;

    // ビット 0 (失敗フラグ) を設定
    setBit(wInfo, BIT_0_FAIL);

    // ビット 1 (圧縮フラグ) を設定
    setBit(wInfo, BIT_1_COMPRESSED);

    // wInfo の二進数値を表示
    std::cout &amp;lt;&amp;lt; &amp;quot;wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// 各ビットフラグの確認
    std::cout &amp;lt;&amp;lt; &amp;quot;bit0 (失敗フラグ): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_0_FAIL) ? &amp;quot;はい&amp;quot; : &amp;quot;いいえ&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit1 (圧縮フラグ): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_1_COMPRESSED) ? &amp;quot;はい&amp;quot; : &amp;quot;いいえ&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit2 (インクリメントフラグ): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_2_INCREMENT) ? &amp;quot;はい&amp;quot; : &amp;quot;いいえ&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit3 (続き包フラグ): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_3_HAS_MORE) ? &amp;quot;はい&amp;quot; : &amp;quot;いいえ&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit5 (キャンセルフラグ): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_5_CANCEL) ? &amp;quot;はい&amp;quot; : &amp;quot;いいえ&amp;quot;) &amp;lt;&amp;lt; std::endl;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;### C++ のサンプルコード
// ビット1（圧縮フラグ）をクリアする
    clearBit(wInfo, BIT_1_COMPRESSED);

    // 更新された wInfo を出力
    std::cout &amp;lt;&amp;lt; &amp;quot;Updated wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;c-サンプルコード&#34;&gt;C++ サンプルコード
&lt;/h3&gt;&lt;p&gt;コードを実行するには、旧友を推奨：&lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wInfo (バイナリ): 0000000000000011
bit0 (エラーか): はい
bit1 (圧縮するか): はい
bit2 (増分か): いいえ
bit3 (後続包があるか): いいえ
bit5 (注销するか): いいえ
Updated wInfo (バイナリ): 0000000000000001
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;コード解説&#34;&gt;コード解説
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;フラグの定義&lt;/strong&gt;: ビットシフト演算 (&lt;code&gt;1 &amp;lt;&amp;lt; n&lt;/code&gt;) を使用して、各フラグを定義します。例えば、&lt;code&gt;1 &amp;lt;&amp;lt; 0&lt;/code&gt; は &lt;code&gt;bit0&lt;/code&gt; に対応し、&lt;code&gt;1 &amp;lt;&amp;lt; 1&lt;/code&gt; は &lt;code&gt;bit1&lt;/code&gt; に対応するなど、同様に推測されます。このようにして、各フラグには一意のバイナリ位置が割り当てられます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特定のビットの確認&lt;/strong&gt;: &lt;code&gt;isBitSet&lt;/code&gt; 関数は、指定されたフラグが1になっているかどうかを確認するために、ビットマスクとのAND演算 (&lt;code&gt;wInfo &amp;amp; bitMask&lt;/code&gt;) を使用します。もしそのビットが1であれば、関数は &lt;code&gt;true&lt;/code&gt; を返し、そうでなければ &lt;code&gt;false&lt;/code&gt; を返します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特定のビットの設定&lt;/strong&gt;: &lt;code&gt;setBit&lt;/code&gt; 関数は、指定されたフラグを1にするために、ビットマスクとのOR演算 (&lt;code&gt;wInfo |= bitMask&lt;/code&gt;) を使用します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特定のビットのクリア&lt;/strong&gt;: &lt;code&gt;clearBit&lt;/code&gt; 関数は、指定されたフラグを0にするために、ビットマスクとのAND演算 (&lt;code&gt;wInfo &amp;amp;= ~bitMask&lt;/code&gt;) を使用します。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;まとめ&#34;&gt;まとめ
&lt;/h3&gt;&lt;p&gt;ビット演算（ビット操作）を用いることで、複数の状態フラグを効率的に処理できます。実際の開発においては、この技術が特に有用です。例えば、組み込み開発、ネットワークプロトコル、システムステート管理などの場面で、複数のバイナリ状態を表すためにビットフラグが頻繁に使用されます。スペースの節約と効率の向上が両立します。
この記事が、C++ でビット演算を用いてビットごとの取得と設定を行う方法を理解するのに役立つことを願っています。これらのスキルを習得することは、効率的で保守しやすいコードを書く上で非常に役立ちます！&lt;/p&gt;
</description>
        </item>
        <item>
        <title>GCC、GLIBC および C&#43;&#43; プログラムの互換性に関する深い理解</title>
        <link>https://ttf248.life/ja/p/gcc-glibc-cpp-compatibility/</link>
        <pubDate>Mon, 06 Jan 2025 19:51:16 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/gcc-glibc-cpp-compatibility/</guid>
        <description>&lt;p&gt;C++の開発分野において、GCCとGLIBCは避けて通れない重要な要素であり、プログラムのリリース後の互換性問題も開発者を悩ませる常 occurrenceである。本稿では、その本質を深く分析し、互換性問題の原因と対策を探求する。&lt;/p&gt;
&lt;h2 id=&#34;一gcc強力なコンパイラ基盤&#34;&gt;一、GCC：強力なコンパイラ基盤
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;定義と機能&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;GCC（GNU Compiler Collection）は、GNUプロジェクトが開発したオープンソースのコンパイラセットです。単なるコンパイラではありません。C、C++、Objective - C、Fortran、Ada、Goなど、主要な言語を幅広くサポートしており、複数の言語を使用したクロスプログラミングのためのワンストップソリューションを提供します。&lt;/li&gt;
&lt;li&gt;C++ を例にとると、クラス、テンプレート、関数オーバーロードなど、複雑な特性を持つソースファイルを記述した際に、GCC は C++ の厳格な構文と意味規則に基づいて、高度な C++ コードを低レベルの機械が理解し実行できる命令列に変換します。このプロセスには、トークン解析、構文解析、意味解析、最適化、コード生成など、複数の詳細な段階が含まれます。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;一gcc強力なコンパイラ基盤-1&#34;&gt;一、GCC：強力なコンパイラ基盤
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;コンパイル処理の詳細&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;前処理段階&lt;/strong&gt;: GCC はまずソースファイルを前処理操作を行います。この過程で、すべての &lt;code&gt;#&lt;/code&gt; で始まるプレフィックスコマンドを処理します。例えば、&lt;code&gt;#include&lt;/code&gt; コマンドは指定されたヘッダーファイル（例：C++ の &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; は入力出力ストリーム操作用）の内容をソースファイルの対応する位置に埋め込みます。これにより、プログラムはヘッダーファイルで宣言されている関数やクラスなどのリソースを使用できるようになります。また、&lt;code&gt;#define&lt;/code&gt; コマンドで定義されたマクロもこの段階で展開して置換されます（例：&lt;code&gt;#define PI 3.14159&lt;/code&gt;）。ソースファイル内のすべての &lt;code&gt;PI&lt;/code&gt; の箇所が &lt;code&gt;3.14159&lt;/code&gt; に置き換えられます。前処理後、ソースファイルは初期的に「拡張」されます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;コンパイル段階&lt;/strong&gt;: 前処理されたファイルをコンパイル段階に入れます。GCC はこの段階で C++ 言語標準に基づいて、ソースコードをアセンブリ言語コードに変換します。 コード構造を注意深く検査し、クラスの継承、ポリモーフィズムの実装が正しく行われているか、関数呼び出しの引数パラメータが一致しているかなどを確認します。構文の意味的な誤りを発見すると、直ちにエラーを報告し、コンパイルプロセスを停止します。例えば、関数宣言と定義された引数のリストが一致しない場合、GCC は問題箇所を正確に特定します。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;一gcc強力なコンパイラ基盤-2&#34;&gt;一、GCC：強力なコンパイラ基盤
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;アセンブル段階&lt;/strong&gt;：アセンブラは、前工程で生成されたアセンブリコードを機械語に変換し、&lt;code&gt;.o&lt;/code&gt;という拡張子を持つオブジェクトファイルを作成します。これらのオブジェクトファイルには、マシンが直接実行できるバイナリ命令が含まれていますが、それらは独立して動作するものではなく、通常、完全なプログラムは複数のモジュールで構成され、各モジュール間の関数や変数への参照関係が解決されていないためです。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;リンク段階&lt;/strong&gt;：これは、実行可能ファイルを作成するための最終的なフェーズです。リンカは、複数のオブジェクトファイルと必要なライブラリ（静的ライブラリまたは動的ライブラリ）を統合します。たとえば、C++標準テンプレートライブラリのコンテナクラスを使用する場合、リンク時には対応するライブラリの実装コードを見つけて、&lt;code&gt;vector&lt;/code&gt;、&lt;code&gt;list&lt;/code&gt;などのコンテナの機能を正しく呼び出せるようにする必要があります。これにより、プログラムが実行時に完全な実行可能ファイルが生成されます。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二glibccプログラム実行の幕後ろ支柱&#34;&gt;二、GLIBC：C++プログラム実行の幕後ろ支柱
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;本質と作用&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;GLIBC（GNU C Library）は、C標準ライブラリのGNUエコシステムにおける具体的な実装です。名前がCを強調していますが、C++プログラムも高度に依存しており、これはC++がCの基礎部分を受け継いでいるためです。大量の基本的な関数を提供し、動的メモリ管理のための&lt;code&gt;malloc&lt;/code&gt;（動的メモリ割り当て）、&lt;code&gt;free&lt;/code&gt;（メモリ解放）といった関数は、C++で動的な配列やオブジェクトを作成する際に不可欠です。また、文字列処理関数である&lt;code&gt;strcpy&lt;/code&gt;（文字列コピー）、&lt;code&gt;strcat&lt;/code&gt;（文字列連結）も、C++にはより高度な&lt;code&gt;string&lt;/code&gt;クラスが存在しても、低レベルでのCコードとのインタフェースや、最大限のパフォーマンスを追求する場合に頻繁に使用されます。さらに、標準入出力関数である&lt;code&gt;printf&lt;/code&gt;、&lt;code&gt;scanf&lt;/code&gt;なども、C++初期の開発や、パフォーマンスに敏感で簡潔さを重視する場面でよく見られます。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;二glibccプログラム実行の裏側を支える基盤&#34;&gt;二、GLIBC：C++プログラム実行の裏側を支える基盤
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;オペレーティングシステムとの連携&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;GLIBCは、オペレーティングシステムとアプリケーション間の重要な橋渡し役を果たします。Linuxシステムにおいて、C++プログラムがシステムコールを発行する（例えば、ファイルを開く&lt;code&gt;open&lt;/code&gt;関数を使用し、その裏側でGLIBCの実装に依存する場合）、GLIBCはプログラムの要求を、オペレーティングシステムカーネルが定めた方法でラッピングし、カーネルに渡します。カーネルが処理を完了すると、GLIBCは結果をアプリケーションに戻します。これにより、アプリケーションはオペレーティングシステムの低レベルな複雑なシステムコールインターフェースの詳細を理解する必要なく、ファイルシステム、ネットワーク、プロセス管理などのさまざまなシステムリソースを簡単に利用できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3cプログラム公開後の互換性問題の分析&#34;&gt;3、C++プログラム公開後の互換性問題の分析
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;GLIBCバージョンの差異が引き起こす互換性の苦境&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;様々なLinuxディストリビューションは、それぞれ異なるバージョンのGLIBCを搭載しています。 C++プログラムが高バージョンGLIBC環境下でコンパイルされた場合、無意識にそのバージョンで新しく追加された関数特性を利用したり、より最適化された関数実装に依存したりすることがあります。例えば、新しいGLIBCバージョンではメモリ割り当てアルゴリズムが改善されており、プログラムが実行時に頻繁にこの新しいアルゴリズムを活用して性能を向上させているとします。このようなプログラムを低バージョンGLIBCシステムに移植した場合、対応する関数が見つからなくなる（低バージョンでその関数が導入されていないため）か、関数の動作が異常になる（古いバージョンの関数実装のロジックと新しいバージョンでずれがあるため）、といった問題が発生し、プログラムがクラッシュしたり、結果が誤ったりすることがあります。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;iii-c-プログラム公開後の互換性問題の分析&#34;&gt;III. C++ プログラム公開後の互換性問題の分析
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;コンパイラの違いによる互換性の脆弱性&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;同じ GCC コンパイラを使用しても、異なるバージョンの GCC はコード生成、標準ライブラリのサポート、C++ 特性の実装の詳細において差異があります。より新しい GCC バージョンは C++ 最新規格（例：C++20 の新機能モジュール、コルーチンなど）を完全にサポートし、プログラムがこれらの最先端特性を使用し、古いバージョンの GCC でコンパイルすると、コンパイラはこれらの新構文構造を認識できずエラーが発生します。構文エラーがない場合でも、異なる GCC バージョン間の最適化戦略の違いにより、生成される機械コードの実行効率やメモリ使用量において大きな違いが生じることがあり、特にパフォーマンスが重要な環境では、プログラムが異なる環境で異なった動作をする可能性があります。 - &lt;strong&gt;システムアーキテクチャの違いがもたらす課題&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;C++プログラムは、x86、ARM、PowerPCなどの異なるハードウェアシステムアーキテクチャ上で実行する必要がある可能性がある。異なるアーキテクチャにはそれぞれ独自の命令セット、メモリレイアウト、およびデータアライメント要件が存在する。データアライメントの例を挙げると、x86アーキテクチャで正常に動作する構造体データのストレージレイアウトは、ARMアーキテクチャでは、アライメント規則の違いによりメモリアクセス例外が発生し、プログラムエラーにつながる可能性がある。さらに、GCCが異なるアーキテクチャ向けにコンパイルを行う際に生成される機械コードの差異が大きく、プログラム中にハードコーディングされたアーキテクチャ固有の命令や仮定がある場合、クロスアーキテクチャ実行時に故障が頻発する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四互換性問題への対処戦略&#34;&gt;四、互換性問題への対処戦略
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;静的リンクライブラリの活用&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;GLIBCなどのプログラムが依存するライブラリコードを、実行ファイルに直接組み込む静的リンクライブラリの使用を検討してください。これにより、プログラムは実行時に特定のターゲットシステムのGLIBCバージョンに依存しなくなり、GLIBCバージョンの不一致による問題を効果的に回避できます。ただし、静的リンクは実行ファイルのサイズを大幅に増加させるため、ストレージリソースが限られた環境では利点と欠点を比較検討する必要があります。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;コンテナ化デプロイメント&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Dockerなどのコンテナ技術を利用して、C++プログラムとその必要な実行環境（特定のバージョンのGCC、GLIBCなど）を独立したコンテナ内にカプセル化します。どのようなベースOSにデプロイする場合でも、コンテナ内部の環境はプログラム開発時の一貫性を維持し、プログラムが期待どおりに動作することを保証することで、クロス環境デプロイの複雑さを大幅に軽減します。 - &lt;strong&gt;互換性テストと継続的統合&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;包括の互換性テスト体系を構築し、GLIBC の異なるバージョン、GCC の異なるバージョン、および一般的なシステムアーキテクチャを網羅する。開発プロセスにおいて、継続的統合ツールを用いて定期的に複数の環境で自動テストを実施し、互換性の問題が発見された場合は迅速に修正することで、潜在的な問題をその発生初期段階で排除し、プログラムのリリース後の安定性を保証する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四互換性問題への対処戦略-1&#34;&gt;四、互換性問題への対処戦略
&lt;/h2&gt;&lt;p&gt;上記をまとめると、GCC と GLIBC の仕組みを深く理解し、C++ プログラムの互換性問題の本質を見抜き、柔軟な対応策を用いることは、すべての C++ 開発者が堅牢かつクロスプラットフォームなアプリケーションを構築するための必須スキルです。そうすることで、私たちの C++ 作品が多様な技術環境において無障害に展開されます。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linuxバックエンドサービスの大量文字列データの処理 - 効率が悪い</title>
        <link>https://ttf248.life/ja/p/linux-backend-slow-string-processing/</link>
        <pubDate>Wed, 13 Nov 2024 19:42:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-backend-slow-string-processing/</guid>
        <description>&lt;p&gt;C++開発の歴史的なプロジェクトにおいて、カスタムプロトコルを使用して通信を行っており、そのプロトコルは2次元配列のパターンを採用していました。大量データを処理する際に、プロトコル内部では配列を遍历し、シリアライズ操作を実行してログを生成しており、このため効率が低く、システムが高負荷時に顕著なフレーム落ち（カドゥ）を引き起こしました。事業部門からは、システムのフレーム落ちに関するフィードバックがありました。&lt;/p&gt;
&lt;h2 id=&#34;問題の特定&#34;&gt;問題の特定
&lt;/h2&gt;&lt;p&gt;問題のトラブルシューティングにおいて、まずシステムに対してパフォーマンス分析を実施し、大量データを処理する際にCPU使用率が著しく増加し、システムの応答時間が長くなっていることを発見しました。ログを分析した結果、多数のシリアライズ操作が見られ、これらの操作は2次元配列を処理する際の効率が低いことが原因でシステムのパフォーマンス低下につながっていました。
&lt;code&gt;pstack&lt;/code&gt;ツールを使用してサービスのスレッド情報を取得し、ログスレッドが文字列の連結に大部分の時間を使用していることを特定しました。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;今日は重点的に取り組むべき点です。異なる累積方式では、その効率の違いは非常に大きいです。過去のコードでは &amp;lsquo;+&amp;rsquo; 演算子を使用しており、この方法は頻繁に一時オブジェクトを作成するため、非常に非効率的でした。それは、その非効率がどの程度であるかを知らない状況にあるようなものです。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;デモ検証&#34;&gt;デモ検証
&lt;/h2&gt;&lt;p&gt;プロジェクトコードに基づいて、ビジネスロジックを抽出し、文字列連結の効率に関する問題を検証するためのシンプルなデモを作成しました。Windows環境ではVisual Studio 2022コンパイラ、Linux環境ではgcc8.5コンパイラを使用し、Releaseモードでビルドして実行し、効率を比較します。&lt;/p&gt;
&lt;h3 id=&#34;主要ポイント&#34;&gt;主要ポイント
&lt;/h3&gt;&lt;p&gt;このプロジェクトでは、方法四を使用し、テストデータを入手する前に、どの方法が最も効率的で、最も非効率かを読者に考えてもらうようにしました。結果を見たときは、自分でも驚きました。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;方法 1 (&lt;code&gt;+=&lt;/code&gt; 連結)&lt;/strong&gt;：各フィールドを &lt;code&gt;+=&lt;/code&gt; を使って文字列に直接連結します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法 2 (&lt;code&gt;std::ostringstream&lt;/code&gt; 連結)&lt;/strong&gt;：ストリーム（&lt;code&gt;std::ostringstream&lt;/code&gt;）を使用して各フィールドを連結する方法で、特に大量のデータを連結する場合に効率的です。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法 3（事前割り当てメモリの &lt;code&gt;+=&lt;/code&gt; 連結）&lt;/strong&gt;：&lt;code&gt;reserve&lt;/code&gt; を使って文字列に十分なメモリを事前に割り当てることで、メモリ再割り当てのオーバーヘッドを減らし、パフォーマンスを向上させます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法4 (&lt;code&gt;bodys = bodys + body + &amp;quot;\n&amp;quot;&lt;/code&gt;)&lt;/strong&gt;: 各回の連結で新しい一時的な文字列オブジェクトが作成されるため、大規模な連結においてはパフォーマンスの低下を引き起こします。これは、各連結において新たなメモリ割り当てとコピーが必要となるためです。
参照結果から、この方法が最も効率の悪いものとして選ばれていることがわかります。
さらに詳しく分析すると、異なるプラットフォームコンパイラの最適化効率に違いが見られます。Microsoft の &lt;code&gt;Visual Studio&lt;/code&gt; は一如既往に優れており、文字列の最適化効率は非常に高い一方、&lt;code&gt;gcc&lt;/code&gt; コンパイラはその最適化効率がやや劣ります。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;主要ポイント-1&#34;&gt;主要ポイント
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;コードを異なるマシンで実行した場合、2つのデータ間で直接的な比較の意味がないため、異なるパッチング方法間の差分を比較することができます。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;主要ポイント-2&#34;&gt;主要ポイント
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Windowsプラットフォーム下でのVisual Studio 2022コンパイラ

----------------------------------------
データ生成時間: 0.054秒
----------------------------------------

----------------------------------------
データマージパフォーマンス:
----------------------------------------
+ データマージ (+=) にかかった時間: 0.053秒
+ ostringstream データマージにかかった時間: 0.054秒
+ 事前予約済みデータマージにかかった時間: 0.045秒
+ データマージ (bodys = bodys + body + &amp;quot;\n&amp;quot;) にかかった時間: 16.108秒

----------------------------------------
データマージ完了。
----------------------------------------

プログラム終了。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;主要ポイント-3&#34;&gt;主要ポイント
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Linuxプラットフォーム下 GCC8.5コンパイラ
----------------------------------------
データ生成時間：0.108秒。
----------------------------------------

----------------------------------------
データマージパフォーマンス：
----------------------------------------
+ データマージ (+=) にかかった時間：0.100秒。
+ ostringstream データマージにかかった時間：0.083秒。
+ 事前予約済みデータマージにかかった時間：0.057秒。
+ データマージ (bodys = bodys + body + &amp;quot;\n&amp;quot;) にかかった時間：29.298秒。

----------------------------------------
データマージ完了。
----------------------------------------

プログラム終了。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完全なコード&#34;&gt;完全なコード
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;random&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;iomanip&amp;gt;

typedef std::vector&amp;lt;std::string&amp;gt; DataRow;
typedef std::vector&amp;lt;DataRow&amp;gt; DataGroup;

struct ResponsePackage
{
    std::string ErrorInfo;
    DataRow Head;
    std::string ClientId;
    std::string UUID;
    std::string MsgID;
    std::string SessionID;
    std::string ExtraInfo1;
    std::string ExtraInfo2;
    DataGroup DataBody;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;## 完整コード
// 指定された長さのランダム文字列を生成する
std::string generateRandomString(size_t length)
{
    const char charset[] = &amp;quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&amp;quot;;
    const size_t max_index = sizeof(charset) - 1;
    std::string random_string;
    random_string.reserve(length);

    std::random_device rd;
    std::mt19937 generator(rd());
    std::uniform_int_distribution&amp;lt;&amp;gt; distribution(0, max_index);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;// ランダム文字列を生成します。
// 文字列の文字セットは、小文字と大文字のアルファベット、数字です。
// 指定された長さのランダムな文字列を生成するために、乱数ジェネレータを使用して、文字セットからランダムに文字を選択します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
**注釈:**

*   上記は日本語での完全な翻訳です。
*   コードコメントも日本語で記述されています。
*   Markdown形式を維持しています。

## 完全なコード
for (size_t i = 0; i &amp;lt; length; ++i)
{
    random_string += charset[distribution(generator)];
}

return random_string;
}

void create_large_string()
{
    // 例：50フィールドを含むリクエストパッケージ
    ResponsePackage requestPackage;

## 完整コード
requestPackage.Head = {
    &amp;quot;Field1&amp;quot;, &amp;quot;Field2&amp;quot;, &amp;quot;Field3&amp;quot;, &amp;quot;Field4&amp;quot;, &amp;quot;Field5&amp;quot;,
    &amp;quot;Field6&amp;quot;, &amp;quot;Field7&amp;quot;, &amp;quot;Field8&amp;quot;, &amp;quot;Field9&amp;quot;, &amp;quot;Field10&amp;quot;,
    &amp;quot;Field11&amp;quot;, &amp;quot;Field12&amp;quot;, &amp;quot;Field13&amp;quot;, &amp;quot;Field14&amp;quot;, &amp;quot;Field15&amp;quot;,
    &amp;quot;Field16&amp;quot;, &amp;quot;Field17&amp;quot;, &amp;quot;Field18&amp;quot;, &amp;quot;Field19&amp;quot;, &amp;quot;Field20&amp;quot;,
    &amp;quot;Field21&amp;quot;, &amp;quot;Field22&amp;quot;, &amp;quot;Field23&amp;quot;, &amp;quot;Field24&amp;quot;, &amp;quot;Field25&amp;quot;,
    &amp;quot;Field26&amp;quot;, &amp;quot;Field27&amp;quot;, &amp;quot;Field28&amp;quot;, &amp;quot;Field29&amp;quot;, &amp;quot;Field30&amp;quot;,
    &amp;quot;Field31&amp;quot;, &amp;quot;Field32&amp;quot;, &amp;quot;Field33&amp;quot;, &amp;quot;Field34&amp;quot;, &amp;quot;Field35&amp;quot;
};

## 完整コード
```json
{
  &amp;quot;Field31&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field32&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field33&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field34&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field35&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field36&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field37&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field38&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field39&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field40&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field41&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field42&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field43&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field44&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field45&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field46&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field47&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field48&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field49&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field50&amp;quot;: &amp;quot;&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完全なコード-1&#34;&gt;完全なコード
&lt;/h2&gt;&lt;p&gt;requestPackage.ClientId = &amp;ldquo;ClientID&amp;rdquo;;
requestPackage.UUID = &amp;ldquo;UUID&amp;rdquo;;
requestPackage.MsgID = &amp;ldquo;MsgID&amp;rdquo;;
requestPackage.SessionID = &amp;ldquo;SessionID&amp;rdquo;;
requestPackage.ExtraInfo1 = &amp;ldquo;ExtraInfo1&amp;rdquo;;
requestPackage.ExtraInfo2 = &amp;ldquo;ExtraInfo2&amp;rdquo;;&lt;/p&gt;
&lt;p&gt;// データ生成の開始タイミングを記録
auto start_gen = std::chrono::high_resolution_clock::now();&lt;/p&gt;
&lt;h2 id=&#34;完全なコード-2&#34;&gt;完全なコード
&lt;/h2&gt;&lt;p&gt;// 50フィールドを持つ1万行のデータを生成する
for (size_t i = 0; i &amp;lt; 10000; ++i)
{
DataRow dataRow(50, &amp;ldquo;This is a test string&amp;rdquo;);
requestPackage.DataBody.push_back(dataRow);
}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// データ生成のタイミング終了
auto end_gen = std::chrono::high_resolution_clock::now();
std::chrono::duration&amp;lt;double&amp;gt; duration_gen = end_gen - start_gen;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完整コード&#34;&gt;完整コード
&lt;/h2&gt;&lt;p&gt;// 結果生成時間表示
std::cout &amp;laquo; &amp;ldquo;\n&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-\n&amp;rdquo;;
std::cout &amp;laquo; &amp;ldquo;データ生成時間: &amp;quot; &amp;laquo; std::fixed &amp;laquo; std::setprecision(3) &amp;laquo; duration_gen.count() &amp;laquo; &amp;quot; 秒.\n&amp;rdquo;;
std::cout &amp;laquo; &amp;ldquo;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-\n&amp;rdquo;;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 異なる方法でデータマージのパフォーマンス
std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
std::cout &amp;lt;&amp;lt; &amp;quot;データマージ性能:\n&amp;quot;;
std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完整コード-1&#34;&gt;完整コード
&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;// Method 1: Using &#39;+=&#39; string concatenation
auto start_merge = std::chrono::high_resolution_clock::now();
std::string bodys(&amp;quot;&amp;quot;);
for (auto&amp;amp; vec : requestPackage.DataBody)
{
    std::string body(&amp;quot;This is a test string&amp;quot;);
    for (auto&amp;amp; item : vec)
    {
        body += item + &amp;quot; &amp;quot;;
    }
    bodys += body + &amp;quot;\n&amp;quot;;
}
auto end_merge = std::chrono::high_resolution_clock::now();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;// 方法1：使用&amp;rsquo;+=&amp;lsquo;文字列連結
auto start_merge = std::chrono::high_resolution_clock::now();
std::string bodys(&amp;quot;&amp;quot;);
for (auto&amp;amp; vec : requestPackage.DataBody)
{
std::string body(&amp;ldquo;This is a test string&amp;rdquo;);
for (auto&amp;amp; item : vec)
{
body += item + &amp;quot; &amp;ldquo;;
}
bodys += body + &amp;ldquo;\n&amp;rdquo;;
}
auto end_merge = std::chrono::high_resolution_clock::now();&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
```markdown
## 完整コード
}
    auto end_merge = std::chrono::high_resolution_clock::now();
    std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
    std::cout &amp;lt;&amp;lt; &amp;quot;+ データマージ (+=) にかかりました: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; 秒。&amp;quot; &amp;lt;&amp;lt; std::endl;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完整コード-2&#34;&gt;完整コード
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Method 2: Using ostringstream
auto start_merge = std::chrono::high_resolution_clock::now();
std::ostringstream bodys;
for (auto&amp;amp; vec : requestPackage.DataBody)
{
    std::ostringstream body;
    body &amp;lt;&amp;lt; &amp;quot;This is a test string&amp;quot;;
    for (auto&amp;amp; item : vec)
    {
        body &amp;lt;&amp;lt; item &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
    }
    bodys &amp;lt;&amp;lt; body.str() &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
}
auto end_merge = std::chrono::high_resolution_clock::now();
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;## 完整コード
}
    auto end_merge = std::chrono::high_resolution_clock::now();
    std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
    std::cout &amp;lt;&amp;lt; &amp;quot;+ ostringstream Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完整コード-3&#34;&gt;完整コード
&lt;/h2&gt;&lt;p&gt;}
auto end_merge = std::chrono::high_resolution_clock::now();
std::chrono::duration&lt;double&gt; duration_merge = end_merge - start_merge;
std::cout &amp;laquo; &amp;ldquo;+ ostringstream データマージに要した時間: &amp;quot; &amp;laquo; std::fixed &amp;laquo; std::setprecision(3) &amp;laquo; duration_merge.count() &amp;laquo; &amp;quot; 秒。&amp;rdquo; &amp;laquo; std::endl;&lt;/p&gt;
&lt;h2 id=&#34;完全なコード-3&#34;&gt;完全なコード
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Method 3: Pre-allocated memory
auto start_merge = std::chrono::high_resolution_clock::now();
std::string bodys;
bodys.reserve(1000 * 50 * 20); // Pre-allocate enough memory
for (auto&amp;amp; vec : requestPackage.DataBody)
{
    std::string body(&amp;quot;This is a test string&amp;quot;);
    body.reserve(50 * 20); // Pre-allocate memory for each row
    for (auto&amp;amp; item : vec)
    {
        body += item + &amp;quot; &amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完全なコード-4&#34;&gt;完全なコード
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;for (auto&amp;amp; item : vec)
{
    body += item + &amp;quot; &amp;quot;;
}
bodys += body + &amp;quot;\n&amp;quot;;
}
auto end_merge = std::chrono::high_resolution_clock::now();
std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
std::cout &amp;lt;&amp;lt; &amp;quot;+ Pre-reserved Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完整コード-4&#34;&gt;完整コード
&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;        // Method 4: Using &#39;bodys = bodys + body + &amp;quot;\n&amp;quot;&#39;
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body = body + item + &amp;quot; &amp;quot;; // Note the use of &#39;body = body + item&#39;
            }
            bodys = bodys + body + &amp;quot;\n&amp;quot;; // Again, using &#39;bodys = bodys + body&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;## 完整コード
}
            bodys = bodys + body + &amp;quot;\n&amp;quot;; // Again, using &#39;bodys = bodys + body&#39;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ データマージ (bodys = bodys + body + \&amp;quot;\\n\&amp;quot;) にかかりました: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; 秒。&amp;quot; &amp;lt;&amp;lt; std::endl;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完全なコード-5&#34;&gt;完全なコード
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

void create_large_string() {
  std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
  std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Complete.\n&amp;quot;;
  std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;
}

int main()
{
    try
    {
        create_large_string();
    }
    catch (const std::exception&amp;amp; e)
    {
        std::cerr &amp;lt;&amp;lt; &amp;quot;Caught exception: &amp;quot; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\nProgram finished.\n&amp;quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>C&#43;&#43;におけるラムダ式のパラメータのライフタイムについて</title>
        <link>https://ttf248.life/ja/p/cpp-lambda-parameter-lifetime/</link>
        <pubDate>Wed, 13 Nov 2024 19:23:02 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cpp-lambda-parameter-lifetime/</guid>
        <description>&lt;p&gt;C++において、ラムダ式は便利な匿名関数であり、外部変数をキャプチャして内部で使用することができます。これにより、ラムダ式は柔軟なプログラミングツールとなります。しかし、ラムダ式のパラメータのライフサイクルは特に注意すべき点であり、特にキャプチャおよびパラメータを渡す際に重要です。&lt;/p&gt;
&lt;h3 id=&#34;1-ラムダ式のパラメータのライフサイクル&#34;&gt;1. ラムダ式のパラメータのライフサイクル
&lt;/h3&gt;&lt;p&gt;ラムダ式のパラメータのライフサイクルは、通常他のC++関数と同様です。関数の引数は関数呼び出し時に存在し、関数呼び出しが終了すると引数のライフサイクルも終了します。ただし、ラムダ式が外部変数をキャプチャする場合、そのキャプチャ方法によって引数のライフサイクルに影響を受ける可能性があります。&lt;/p&gt;
&lt;h3 id=&#34;2-パラメータのライフサイクルとの関係を捉える&#34;&gt;2. パラメータのライフサイクルとの関係を捉える
&lt;/h3&gt;&lt;h4 id=&#34;21-外部変数のキャプチャ&#34;&gt;2.1 外部変数のキャプチャ
&lt;/h4&gt;&lt;p&gt;C++のラムダ式では、以下の2つの方法で外部変数 キャプチャできます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;値によるキャプチャ:&lt;/strong&gt; 値によるキャプチャでは、外部変数の値がラムダ内部にコピーされます。ラムダ内のコピーのライフサイクルは、ラムダ自身のライフサイクルによって制御されます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参照によるキャプチャ:&lt;/strong&gt; 参照によるキャプチャでは、外部変数の参照が保持され、ラムダ内の参照は元の外部変数に指向します。ライフサイクルは外部変数のライフサイクルに依存します。 ```cpp
int x = 10;
auto lambda_by_value = &lt;a class=&#34;link&#34; href=&#34;&#34; &gt;x&lt;/a&gt; { std::cout &amp;laquo; x &amp;laquo; std::endl; };  // x のコピーをキャプチャ
auto lambda_by_reference = &lt;a class=&#34;link&#34; href=&#34;&#34; &gt;&amp;amp;x&lt;/a&gt; { std::cout &amp;laquo; x &amp;laquo; std::endl; };  // x を参照でキャプチャ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;lambda_by_value();  // 10 と出力
lambda_by_reference();  // 10 と出力&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
**捕獲された変数について、ライフサイクルは以下のとおりです。**
- **値によるキャプチャ:** lambda が生きている間、外部変数の値をコピーして lambda 内で保持します。lambda のライフサイクルが終了すると、このコピーが破棄されます。

#### 2.1 外部変数の捕捉
- **参照による捕捉**: lambdaは外部変数の参照を保持し、**外部変数はlambdaの使用前に有効でなければならない。そうでない場合、未定義の動作を引き起こす可能性があります**。

#### 2.2 ラムダパラメータ

ラムダのパラメータは、通常の関数パラメータと同様に、そのライフサイクルはラムダ関数体内のみに限られます。つまり、ラムダパラメータはラムダが呼び出されたときに作成され、ラムダが呼び出された後にパラメータのライフサイクルも終了します。

```cpp
auto lambda = [](int a, int b) {
    std::cout &amp;lt;&amp;lt; a + b &amp;lt;&amp;lt; std::endl;
};
lambda(5, 10); // ここでaとbはラムダのパラメータ
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この例では、&lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; はラムダ式（ラムダ表現）のパラメータであり、ラムダが呼び出されたときに作成され、ラムダが実行後に破棄されます。&lt;/p&gt;
&lt;h3 id=&#34;3-外部変数を捕捉する際のライフサイクルに関する問題&#34;&gt;3. 外部変数を捕捉する際のライフサイクルに関する問題
&lt;/h3&gt;&lt;h4 id=&#34;31-捕捉した変数が-lambda-外部で有効か&#34;&gt;3.1 捕捉した変数が lambda 外部で有効か
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;値によるキャプチャ&lt;/strong&gt;: 外部変数（lambda が呼び出された後に破棄されても）が lambda 内部で参照されるコピーを保持するため、lambda 内部で安全に使用できます。外部変数が存在しなくなっても問題ありません。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x は lambda が呼び出された後に変更される
lambda();  // 10 を出力する。これは x のコピーを参照しているため
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;参照によるキャプチャ&lt;/strong&gt;: 外部変数の参照をキャプチャする場合、lambda 内部で参照が使用される場合、外部変数のライフサイクルに依存します。外部変数が lambda が実行される前に破棄された場合、 dangling reference (空の参照) の問題が発生し、未定義動作を引き起こります。 ```cpp
int x = 10;
auto lambda = &lt;a class=&#34;link&#34; href=&#34;&#34; &gt;&amp;amp;x&lt;/a&gt; { std::cout &amp;laquo; x &amp;laquo; std::endl; };
x = 20;  // x 在 lambda 调用前修改
lambda();  // 打印 20，捕获的是 x 的引用&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
&amp;gt; ラムダ関数の実行順序が不定である場合、キャプチャされた外部変数がラムダ関数実行時に有効であることを保証することが非常に重要です。&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>GCCバージョンをアップグレードした結果、プログラムがクラッシュしました。コードの記述ルールの欠如による問題点です。</title>
        <link>https://ttf248.life/ja/p/gcc-upgrade-causes-program-crash-code-irregularities/</link>
        <pubDate>Sun, 10 Mar 2024 23:19:06 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/gcc-upgrade-causes-program-crash-code-irregularities/</guid>
        <description>&lt;p&gt;同一段業務コードにおいて、プログラムは CentOS 7 環境下で正常にコンパイルおよび実行されていたが、CentOS 8 に切り替えて更新版の GCC でコンパイルを行った際に、プログラムがクラッシュするようになった。注目すべき点は、問題が &lt;strong&gt;Release モード&lt;/strong&gt; 下でのみ発生し、&lt;strong&gt;Debug モード&lt;/strong&gt; では完全に問題が発生しない点である。これは初めて遭遇するケースであり、3日間の調査を経て、問題の原因を特定することができた。&lt;/p&gt;
&lt;h3 id=&#34;問題の特定&#34;&gt;問題の特定
&lt;/h3&gt;&lt;p&gt;一番の原因究明の結果、問題の本質は &lt;strong&gt;関数に返り値がないこと&lt;/strong&gt; にあります。リリースモードにおいて、GCCの新バージョンではより多くの最適化が行われるため、本来返り値のない関数が実行中に未知のロジックが発生し、クラッシュを引き起こしました。結論として、&lt;strong&gt;コンパイラの警告を無視することは許されません。特に、古いプロジェクトにおいては、一部の警告が無視される可能性がありますが、すべての警告を無効にすることは避けるべきです&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;環境説明&#34;&gt;環境説明
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CentOS 7 GCCバージョン:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CentOS 8 GCCバージョン:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;クラッシュ現象&#34;&gt;クラッシュ現象
&lt;/h3&gt;&lt;p&gt;プログラムのクラッシュに関するスタックを分析した結果、以下のスタック情報が得られました：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[New LWP 1385902]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib64/libthread_db.so.1&amp;quot;.
Core was generated by `./pstack_main`.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007ffe894b4420 in ?? ()
(gdb) bt
#0  0x00007ffe894b4420 in ?? ()
#1  0x00000000004008e9 in main ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このスタックは直感的ではありません。クラッシュ関数のスタック情報が &lt;code&gt;??&lt;/code&gt; と表示されるため、問題の特定がさらに複雑になります。&lt;/p&gt;
&lt;h3 id=&#34;コード例&#34;&gt;コード例
&lt;/h3&gt;&lt;p&gt;問題をより良く理解するために、クラッシュを再現するための最小コード例を示します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int test() {
    std::cout &amp;lt;&amp;lt; &amp;quot;1&amp;quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    test();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このコード内の &lt;code&gt;test()&lt;/code&gt; 関数は明らかに値を明示的に返していません。また、その戻り値の型は &lt;code&gt;int&lt;/code&gt; です。C++ 仕様によると、関数が &lt;code&gt;int&lt;/code&gt; 型で宣言されている場合、必ず戻り値を持つ必要があります。そうしないと、未定義動作を引き起こす可能性があります。&lt;/p&gt;
&lt;h3 id=&#34;コンパイル警告&#34;&gt;コンパイル警告
&lt;/h3&gt;&lt;p&gt;当方のプロジェクトにおいて、CMake スクリプトが多くのコンパイル時の警告を抑制しており、その中に以下の警告情報が含まれています：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/root/pstack/main.cpp: In function ‘int test()’:
/root/pstack/main.cpp:7:1: warning: no return statement in function returning non-void [-Wreturn-type]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この警告は、&lt;code&gt;test()&lt;/code&gt; 関数が戻り値を持たないことを示しており、これがまさに問題の原因です。GCC の高バージョン（例：8.5.0）では、コードを最適化する際にこのような未定義の動作に対して不安定な最適化を行う可能性があり、プログラムがクラッシュする原因となる可能性があります。&lt;/p&gt;
&lt;h3 id=&#34;어셈블리-코드-차이점&#34;&gt;어셈블리 코드 차이점
&lt;/h3&gt;&lt;p&gt;GCC 컴파일러 최적화 동작의 차이를 설명하기 위해, 서로 다른 버전의 GCC가 생성한 어셈블리 코드를 비교했습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GCC 4.8.5 생성된 어셈블리 코드:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;어셈블리 코드가 다소 길고 표준 출력 스트림(예: &lt;code&gt;std::cout&lt;/code&gt;) 처리 로직을 포함하고 있습니다. 이는 컴파일러가 &lt;code&gt;test()&lt;/code&gt; 함수에서 누락된 반환 값 문제에 대해 과도하게 최적화하지 않았음을 나타내며, 이로 인해 잠재적으로 충돌을 피했을 수 있음을 시사합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GCC 8.5.0 생성된 어셈블리 코드:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;새로운 버전의 GCC는 더 많은 최적화를 수행하여 코드 양을 줄였습니다. 그러나 이러한 최적화가 누락된 반환 값을 갖는 함수의 실행 동작이 불확실하게 만들 수 있으며, 이는 프로그램 충돌로 이어질 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;結論&#34;&gt;結論
&lt;/h3&gt;&lt;p&gt;今回の問題解決を通して、C++において&lt;strong&gt;関数が返す値は明確に定義されるべきである&lt;/strong&gt;という点を深く認識しました。特に、関数を&lt;code&gt;int&lt;/code&gt;型として宣言する場合、必ず戻り値を提示する必要があります。旧バージョンのコンパイラを使用しているプロジェクトでGCCの新しいバージョンにアップグレードした場合、より多くの最適化や厳格な警告メカニズムが導入される可能性があります。そのため、コンパイル時に&lt;strong&gt;すべての警告を無効化しない&lt;/strong&gt;ことを推奨します。代わりに、関数が返す値、型の一致など、一般的な問題に対して選択的に対処する必要があります。
最終的に、&lt;code&gt;test()&lt;/code&gt;関数に戻り値を付与することで問題は解決し、プログラムは正常に動作するようになりました。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>C&#43;&#43;プログラミングにおける罠：`std::map`の誤用がプログラムをクラッシュさせることの詳細な解説</title>
        <link>https://ttf248.life/ja/p/cpp-programming-traps-std-map-crash-details/</link>
        <pubDate>Sun, 10 Mar 2024 22:03:06 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cpp-programming-traps-std-map-crash-details/</guid>
        <description>e&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;C++標準ライブラリにおいて、&lt;code&gt;std::map&lt;/code&gt;は連想コンテナであり、キー（key）の昇順に要素を格納し、効率的なキーワード検索機能を提供します。しかし、初心者開発者は、&lt;code&gt;std::map&lt;/code&gt;における角括弧演算子 &lt;code&gt;[]&lt;/code&gt; の動作について理解不足なために苦慮することがあります。実際には、&lt;code&gt;[]&lt;/code&gt; を使用して存在しないキーにアクセスした場合、&lt;code&gt;std::map&lt;/code&gt; は新しいキー値ペアを挿入し、デフォルトコンストラクタを使用してそのキーに対応する値の型を初期化します。 ```cpp
#include &lt;iostream&gt;
#include &lt;map&gt;&lt;/p&gt;
&lt;p&gt;int main() {
std::map&amp;lt;std::string, int&amp;gt; myMap;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 誤った使い方：キーが存在しないと仮定し、値が0になることを期待する
std::cout &amp;lt;&amp;lt; &amp;quot;Value for &#39;nonexistent_key&#39;: &amp;quot; &amp;lt;&amp;lt; myMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;

// 実際には、上記の行のコードは新しいキーと値のペアを作成し、その値はintのデフォルト値（通常は0）で初期化される
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-##&#34;&gt;C++標準ライブラリにおいて、`std::map`は連想コンテナであり、キー（key）の昇順に要素を格納し、効率的なキーワード検索機能を提供します。しかし、初心者開発者は、`std::map`における角括弧演算子 `[]` の動作について理解不足なために、困惑することがあります。実際には、`[]` を使用して存在しないキーにアクセスした場合、`std::map` は新しいキー値ペアを挿入し、デフォルトコンストラクタを使用してそのキーに対応するの値タイプが初期化されます。

## 本文
上記のコードは直接プログラムをクラッシュさせるわけではありませんが、このような暗黙的な挿入行為は、特定の状況下で予期せぬ副作用を引き起こす可能性があります。例えば、リソースリークや想定外の状態変化などが挙げられます。さらに悪化する場合には、マルチスレッド環境において初期化されていないメモリ領域への同時アクセスにより、プログラムがクラッシュすることさえあります。

上記のような問題を防止するためには、`std::map::find()` または `std::map::count()` メソッドを使用してキーの存在を確認するか、`std::map::insert()` を使用して明示的に要素を挿入することを推奨します：

```cpp
std::map&amp;lt;std::string, int&amp;gt; safeMap;
if (safeMap.count(&amp;quot;nonexistent_key&amp;quot;) == 0) {
    std::cout &amp;lt;&amp;lt; &amp;quot;Key does not exist.&amp;quot; &amp;lt;&amp;lt; std::endl;
} else {
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for existing key: &amp;quot; &amp;lt;&amp;lt; safeMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;
}

// または、キーと値のペアを明示的に挿入し、初期値を指定する
safeMap.insert(std::make_pair(&amp;quot;nonexistent_key&amp;quot;, 0));
``` ## 本文
上記のコードは直接プログラムをクラッシュさせるわけではありませんが、このような暗黙的な挿入行為は、特定の状況下で予期せぬ副作用を引き起こす可能性があります。例えば、リソースリークや想定外の状態変化などが挙げられます。さらに悪化する場合には、マルチスレッド環境において初期化されていないメモリ領域への同時アクセスにより、プログラムがクラッシュすることさえあります。

上記のような問題を回避するために、`std::map::find()` または `std::map::count()` メソッドを使用してキーの存在を確認するか、`std::map::insert()` を使用して明示的に要素を挿入することを推奨します：

```cpp
std::map&amp;lt;std::string, int&amp;gt; safeMap;
if (safeMap.count(&amp;quot;nonexistent_key&amp;quot;) == 0) {
    std::cout &amp;lt;&amp;lt; &amp;quot;Key does not exist.&amp;quot; &amp;lt;&amp;lt; std::endl;
} else {
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for existing key: &amp;quot; &amp;lt;&amp;lt; safeMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;
}

// または、キーと値のペアを明示的に挿入し、初期値を指定する
safeMap.insert(std::make_pair(&amp;quot;nonexistent_key&amp;quot;, 0));
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;本文&#34;&gt;本文
&lt;/h2&gt;&lt;p&gt;マップコンテナ内のオブジェクトがポインタ型の場合、自動挿入の動作は初期化されていないポインタを保存し、そのポインタへの呼び出しはプログラムのクラッシュを引き起こします。&lt;/p&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43;関数呼び出しのオーバーヘッド時間 / 関数呼び出し時のパフォーマンスに関する問題</title>
        <link>https://ttf248.life/ja/p/cpp-function-call-timing/</link>
        <pubDate>Wed, 24 Jan 2024 14:11:33 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cpp-function-call-timing/</guid>
        <description>&lt;p&gt;設計行情 SDK、針對不同的回呼函數實現方式，進行了一次耗時的測試。近期在看 C++ 函數編程，當函數變成了一等公民，在程式內部流轉，耗時有什么不同？&lt;/p&gt;
&lt;p&gt;前文連結：&lt;a class=&#34;link&#34; href=&#34;https://ttf248.life/ja/p/compiler-callback-performance-testing/&#34; &gt;编译器、回调函数、性能测试&lt;/a&gt;
&lt;code&gt;leimao&lt;/code&gt; 大佬刚好也做了类似的測試，借代码一用。&lt;/p&gt;
&lt;h2 id=&#34;本文&#34;&gt;本文
&lt;/h2&gt;&lt;p&gt;実行プラットフォームは引き続き、当社の旧友である &lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt; です。&lt;/p&gt;
&lt;h2 id=&#34;本文-1&#34;&gt;本文
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;cassert&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

int add_one(int input) { return input + 1; }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;本文-2&#34;&gt;本文
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int add_one(int input) { return input + 1; }

bool validate_vector_add_one(std::vector&amp;lt;int&amp;gt; const&amp;amp; input_vector,
                             std::vector&amp;lt;int&amp;gt; const&amp;amp; output_vector)
{
    bool is_valid{true};
    for (size_t i{0}; i &amp;lt; input_vector.size(); ++i)
    {
        if (output_vector.at(i) != input_vector.at(i) + 1)
        {
            is_valid = false;
            break;
        }
    }
    return is_valid;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;検証関数 validate_vector_add_one の説明:&lt;/p&gt;
&lt;p&gt;この関数は、入力ベクトルと出力ベクトルの両方を引数として受け取り、入力ベクトルの各要素に1を加算したものが、出力ベクトルに対応する要素と等しいかどうかを検証します。  もし等しくない場合は &lt;code&gt;false&lt;/code&gt; を返し、そうでなければ &lt;code&gt;true&lt;/code&gt; を返します。&lt;/p&gt;
&lt;p&gt;入力ベクトル: 整数値のベクタ
出力ベクトル: 整数値のベクタ&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void reset_vector(std::vector&amp;lt;int&amp;gt;&amp;amp; input_vector)
{
    for (size_t i{0}; i &amp;lt; input_vector.size(); ++i)
    {
        input_vector.at(i) = 0;
    }
}

template &amp;lt;typename T, typename Func&amp;gt;
void unitary_function_pass_by_lambda_function(T&amp;amp; output, T const&amp;amp; input,
                                              Func const func)
{
    output = func(input);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;関数 reset_vector(std::vector&lt;int&gt;&amp;amp; input_vector)
{
for (size_t i{0}; i &amp;lt; input_vector.size(); ++i)
{
input_vector.at(i) = 0;
}
}&lt;/p&gt;
&lt;p&gt;テンプレート&amp;lt;typename T, typename Func&amp;gt;
void unitary_function_pass_by_lambda_function(T&amp;amp; output, T const&amp;amp; input,
Func const func)
{
output = func(input);
}&lt;/p&gt;
&lt;h2 id=&#34;本文-3&#34;&gt;本文
&lt;/h2&gt;&lt;p&gt;template &lt;typename T&gt;
void unitary_function_pass_by_std_function_value(T&amp;amp; output, T const&amp;amp; input,
std::function&amp;lt;T(T)&amp;gt; const func)
{
output = func(input);
}&lt;/p&gt;
&lt;p&gt;template &lt;typename T&gt;
void unitary_function_pass_by_std_function_reference(
T&amp;amp; output, T const&amp;amp; input, std::function&amp;lt;T(T)&amp;gt; const&amp;amp; func)
{
output = func(input);
}&lt;/p&gt;
&lt;h2 id=&#34;本文-4&#34;&gt;本文
&lt;/h2&gt;&lt;p&gt;template &lt;typename T&gt;
void unitary_function_pass_by_function_pointer(T&amp;amp; output, T const&amp;amp; input,
T (*func)(T))
{
output = func(input);
}&lt;/p&gt;
&lt;p&gt;int main()
{
// 浮動小数点形式 std::cout を 3 桁の精度で設定します。
std::cout.precision(3);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;size_t const num_elements{10000000};
std::vector&amp;lt;int&amp;gt; input_vector(num_elements, 0);
std::vector&amp;lt;int&amp;gt; output_vector(num_elements, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h2 id=&#34;本文-5&#34;&gt;本文
&lt;/h2&gt;&lt;p&gt;auto lambda_function_add_one = [](int const&amp;amp; input) -&amp;gt; int
{
return input + 1;
};
std::function&amp;lt;int(int)&amp;gt; const std_function_add_one(lambda_function_add_one);&lt;/p&gt;
&lt;h2 id=&#34;正文-1&#34;&gt;正文
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::cout &amp;lt;&amp;lt; &amp;quot;関数ポインタのサイズ: &amp;quot; &amp;lt;&amp;lt; sizeof(&amp;amp;add_one)
              &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;std::functionポインタのサイズ: &amp;quot;
              &amp;lt;&amp;lt; sizeof(&amp;amp;std_function_add_one) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;std::functionオブジェクトのサイズ: &amp;quot; &amp;lt;&amp;lt; sizeof(std_function_add_one)
              &amp;lt;&amp;lt; std::endl;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;正文-2&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;// 関数を頻繁に簡単に呼び出す。
// コンパイラはコンパイル時にどの関数を呼び出せばよいかを知っており、
// コードを最適化できる。
// これが最も良いパフォーマンスである。
std::chrono::steady_clock::time_point const time_start_vanilla{
std::chrono::steady_clock::now()};
for (size_t i{0}; i &amp;lt; num_elements; ++i)
{
output_vector.at(i) = add_one(input_vector.at(i));
}
std::chrono::steady_clock::time_point const time_end_vanilla{&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;## 正文
}
    std::chrono::steady_clock::time_point const time_end_vanilla{
        std::chrono::steady_clock::now()};
    auto const time_elapsed_vanilla{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(time_end_vanilla -
                                                             time_start_vanilla)
            .count()};
    float const latency_vanilla{time_elapsed_vanilla /
                                static_cast&amp;lt;float&amp;gt;(num_elements)};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;機械学習&lt;/p&gt;
&lt;h2 id=&#34;本文-6&#34;&gt;本文
&lt;/h2&gt;&lt;p&gt;static_cast&lt;float&gt;(num_elements)};
std::cout &amp;laquo; &amp;ldquo;Latency Pass Vanilla: &amp;quot; &amp;laquo; latency_vanilla &amp;laquo; &amp;quot; ns&amp;rdquo;
&amp;laquo; std::endl;
assert(validate_vector_add_one(input_vector, output_vector));
reset_vector(output_vector);&lt;/p&gt;
&lt;h2 id=&#34;正文-3&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;// 時々、コンパイル時に呼び出す関数を知らないことがあります。
// std::function を使用して、関数を引数として渡すことができます。
// この場合は、std::function を値で渡します。
// std::function のサイズが 32 バイトであるため、値で渡すと
// 多くのコピーが発生し、パフォーマンスが悪くなります。
std::chrono::steady_clock::time_point const
time_start_pass_by_std_function_value{std::chrono::steady_clock::now()};
for (size_t i{0}; i &amp;lt; num_elements; ++i)&lt;/p&gt;
&lt;h2 id=&#34;本文-7&#34;&gt;本文
&lt;/h2&gt;&lt;p&gt;for (size_t i{0}; i &amp;lt; num_elements; ++i)
{
unitary_function_pass_by_std_function_value(
output_vector.at(i), input_vector.at(i), std_function_add_one);
}
std::chrono::steady_clock::time_point const
time_end_pass_by_std_function_value{std::chrono::steady_clock::now()};
auto const time_elapsed_pass_by_std_function_value{
std::chrono::duration_cast&lt;a class=&#34;link&#34; href=&#34;std::chrono::nanoseconds&#34; &gt;std::chrono::nanoseconds&lt;/a&gt;(
time_end_pass_by_std_function_value -&lt;/p&gt;
&lt;h2 id=&#34;正文-4&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;time_end_pass_by_std_function_value - time_start_pass_by_std_function_value)
.count()};
float const latency_pass_by_std_function_value{
time_elapsed_pass_by_std_function_value /
static_cast&lt;float&gt;(num_elements)};
std::cout &amp;laquo; &amp;ldquo;Latency Pass By Std Function Value: &amp;quot;
&amp;laquo; latency_pass_by_std_function_value &amp;laquo; &amp;quot; ns&amp;rdquo; &amp;laquo; std::endl;
assert(validate_vector_add_one(input_vector, output_vector));
reset_vector(output_vector);&lt;/p&gt;
&lt;h2 id=&#34;本文-8&#34;&gt;本文
&lt;/h2&gt;&lt;p&gt;// std::function を値渡しする代わりに、参照（ポインタ）で渡すことができます。この場合、オブジェクトのコピーは排除されます。 値渡しする std::function よりもパフォーマンスが優れています。ただし、依然として通常のやり方ほど高速ではありません。
std::chrono::steady_clock::time_point const
time_start_pass_by_std_function_reference{
std::chrono::steady_clock::now()};
for (size_t i{0}; i &amp;lt; num_elements; ++i)&lt;/p&gt;
&lt;h2 id=&#34;正文-5&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;std::chrono::steady_clock::now()&lt;/code&gt;};
for (size_t i{0}; i &amp;lt; num_elements; ++i)
{
unitary_function_pass_by_std_function_reference(
output_vector.at(i), input_vector.at(i), std_function_add_one);
}
std::chrono::steady_clock::time_point const
time_end_pass_by_std_function_reference{
std::chrono::steady_clock::now()};
auto const time_elapsed_pass_by_std_function_reference{
std::chrono::duration_cast&lt;a class=&#34;link&#34; href=&#34;std::chrono::nanoseconds&#34; &gt;std::chrono::nanoseconds&lt;/a&gt;(&lt;/p&gt;
&lt;h2 id=&#34;正文-6&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;( time_end_pass_by_std_function_reference - time_start_pass_by_std_function_reference)&lt;/code&gt;
.count()};
float const latency_pass_by_std_function_reference{
time_elapsed_pass_by_std_function_reference /
static_cast&lt;float&gt;(num_elements)};
std::cout &amp;laquo; &amp;ldquo;Latency Pass By Std Function Reference: &amp;quot;
&amp;laquo; latency_pass_by_std_function_reference &amp;laquo; &amp;quot; ns&amp;rdquo; &amp;laquo; std::endl;&lt;/p&gt;
&lt;h2 id=&#34;本文-9&#34;&gt;本文
&lt;/h2&gt;&lt;p&gt;&amp;laquo; latency_pass_by_std_function_reference &amp;laquo; &amp;quot; ns&amp;quot; &amp;laquo; std::endl;
assert(validate_vector_add_one(input_vector, output_vector));
reset_vector(output_vector);&lt;/p&gt;
&lt;h2 id=&#34;正文-7&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;// &lt;code&gt;std::function&lt;/code&gt; は、関数ポインタ、呼び出し可能オブジェクト、ラムダ関数をラップするための汎用的なものです。
// 汎用性があるため、関数ポインタほど効率的ではありません。この場合は、関数ポインタを関数に渡します。
// &lt;code&gt;std::function&lt;/code&gt; を参照で渡すよりもパフォーマンスが向上します。
std::chrono::steady_clock::time_point const
time_start_pass_by_function_pointer{std::chrono::steady_clock::now()};&lt;/p&gt;
&lt;h2 id=&#34;本文-10&#34;&gt;本文
&lt;/h2&gt;&lt;p&gt;time_start_pass_by_function_pointer{std::chrono::steady_clock::now()};
for (size_t i{0}; i &amp;lt; num_elements; ++i)
{
unitary_function_pass_by_function_pointer(output_vector.at(i),
input_vector.at(i), &amp;amp;add_one);
}
std::chrono::steady_clock::time_point const
time_end_pass_by_function_pointer{std::chrono::steady_clock::now()};
auto const time_elapsed_pass_by_function_pointer{&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;## 正文
auto const time_elapsed_pass_by_function_pointer{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_function_pointer -
            time_start_pass_by_function_pointer)
            .count()}；
    float const latency_pass_by_function_pointer{
        time_elapsed_pass_by_function_pointer /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Function Pointer: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_function_pointer &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;本文-11&#34;&gt;本文
&lt;/h2&gt;&lt;p&gt;&amp;laquo; latency_pass_by_function_pointer &amp;laquo; &amp;quot; ns&amp;quot; &amp;laquo; std::endl;
assert(validate_vector_add_one(input_vector, output_vector));
reset_vector(output_vector);&lt;/p&gt;
&lt;h2 id=&#34;本文-12&#34;&gt;本文
&lt;/h2&gt;&lt;p&gt;// ラムダ関数を関数に渡すことも可能です。
// コンパイラはコンパイル時に呼び出す関数を知り、
// コードを最適化できます。std::functionを参照渡しするよりもパフォーマンスも優れています。
std::chrono::steady_clock::time_point const
time_start_pass_by_lambda_function{std::chrono::steady_clock::now()};
for (size_t i{0}; i &amp;lt; num_elements; ++i)
{
unitary_function_pass_by_lambda_function(&lt;/p&gt;
&lt;h2 id=&#34;本文-13&#34;&gt;本文
&lt;/h2&gt;&lt;p&gt;for (size_t i{0}; i &amp;lt; num_elements; ++i)
{
unitary_function_pass_by_lambda_function(
output_vector.at(i), input_vector.at(i), lambda_function_add_one);
}
std::chrono::steady_clock::time_point const
time_end_pass_by_lambda_function{std::chrono::steady_clock::now()};
auto const time_elapsed_pass_by_lambda_function{
std::chrono::duration_cast&lt;a class=&#34;link&#34; href=&#34;std::chrono::nanoseconds&#34; &gt;std::chrono::nanoseconds&lt;/a&gt;(
time_end_pass_by_lambda_function -&lt;/p&gt;
&lt;h2 id=&#34;正文-8&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;time_end_pass_by_lambda_function - time_start_pass_by_lambda_function)
.count()};
float const latency_pass_by_lambda_function{
time_elapsed_pass_by_lambda_function /
static_cast&lt;float&gt;(num_elements)};
std::cout &amp;laquo; &amp;ldquo;Latency Pass By Lambda Function: &amp;quot;
&amp;laquo; latency_pass_by_lambda_function &amp;laquo; &amp;quot; ns&amp;rdquo; &amp;laquo; std::endl;
assert(validate_vector_add_one(input_vector, output_vector));
reset_vector(output_vector);&lt;/p&gt;
&lt;h2 id=&#34;本文-14&#34;&gt;本文
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# チーム全体の最適化 (O2) を有効にし、コンパイルには gcc13 を選択しました。gcc のバージョンが異なる場合、性能と時間の違いはわずかに異なりますが、バージョンが高いほど lambda の効果が良いです。
関数のポインタのサイズ: 8 バイト
std::function ポインタのサイズ: 8 バイト
std::function オブジェクトのサイズ: 32 バイト
Vanilla パスのレイテンシ: 0.418 ns
std::function 値でパスするレイテンシ: 3.47 ns
std::function リファレンスでパスするレイテンシ: 1.36 ns
ポインタで関数をパスするレイテンシ: 0.396 ns
ラムダ関数でパスするレイテンシ: 0.44 ns
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leimao.github.io/blog/CPP-Function-Call-Performance/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://leimao.github.io/blog/CPP-Function-Call-Performance/&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>C11: sleep for vs yield</title>
        <link>https://ttf248.life/ja/p/c11-sleep-for-vs-yield/</link>
        <pubDate>Tue, 20 Sep 2022 20:54:51 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/c11-sleep-for-vs-yield/</guid>
        <description>&lt;p&gt;コードを眺めていると、&lt;code&gt;std::this_thread::yield()&lt;/code&gt; が突然視線を集めました。C11 の構文糖で、よく使われていたのに、&lt;code&gt;yield&lt;/code&gt; は初めて見かけます。以前は気付いていませんでした。&lt;/p&gt;
&lt;p&gt;マニュアルを調べずに、まず思い浮かべたのは、それが非同期処理と関連があるのではないかということです。&lt;code&gt;yield&lt;/code&gt; は boost 協程の実装の中に見られる単語で、ここでは非同期処理とは関係なく、制御ロジックが通常のスレッドに関連しているはずです。&lt;/p&gt;
&lt;h2 id=&#34;ドキュメント&#34;&gt;ドキュメント
&lt;/h2&gt;&lt;h3 id=&#34;yield&#34;&gt;yield
&lt;/h3&gt;&lt;p&gt;この関数の正確性は、実装に依存し、特に使用されている OS のスケジューラメカニズムとシステムの状態に依存します。例えば、先入れ先出しリアルタイムスケジューラ（Linux の SCHED_FIFO）が現在のスレッドをサスペンドし、それを実行可能な同優先度のスレッドのキューの末尾に置く（同優先度のスレッドがない場合、yield は効果がない）といった具合です。&lt;/p&gt;
&lt;h3 id=&#34;sleep_for&#34;&gt;sleep_for
&lt;/h3&gt;&lt;p&gt;現在のスレッドの実行をブロックし、指定された &lt;code&gt;sleep_duration&lt;/code&gt; 分間少なくとも停止します。
この関数は、スケジューリングやリソース競合による遅延のため、&lt;code&gt;sleep_duration&lt;/code&gt; より長くブロックされる可能性があります。
標準ライブラリでは、安定したクロックを使用して時間を測定することをお勧めします。システム時間で実装する場合は、待機時間がクロック調整に敏感になる可能性があることに注意してください。&lt;/p&gt;
&lt;h3 id=&#34;分析&#34;&gt;分析
&lt;/h3&gt;&lt;p&gt;両方の関数は、現在のスレッドがスレッドを占有しないようにし、実行効果はプラットフォームによって異なる可能性があります。ここまでの内容でまだ少し理解が曖昧ですが、コードを実行して結果を確認してみましょう。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ThinkPad ノートパソコン（Visual Studio Community 2022）、腾讯云 S2 標準サーバー（gcc8.5）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;分析-1&#34;&gt;分析
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;実行プラットフォーム&lt;/th&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;初回/us&lt;/th&gt;
&lt;th&gt;二次/us&lt;/th&gt;
&lt;th&gt;三次/us&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;sleep_for&lt;/td&gt;
&lt;td&gt;9872&lt;/td&gt;
&lt;td&gt;1884&lt;/td&gt;
&lt;td&gt;11302&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;分析-2&#34;&gt;分析
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;実行プラットフォーム&lt;/th&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;初回/us&lt;/th&gt;
&lt;th&gt;二次/us&lt;/th&gt;
&lt;th&gt;三次/us&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;h3 id=&#34;分析-3&#34;&gt;分析
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;実行プラットフォーム&lt;/th&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;初回/us&lt;/th&gt;
&lt;th&gt;二回/us&lt;/th&gt;
&lt;th&gt;三回/us&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;sleep_for&lt;/td&gt;
&lt;td&gt;171&lt;/td&gt;
&lt;td&gt;168&lt;/td&gt;
&lt;td&gt;167&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;分析-4&#34;&gt;分析
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;実行プラットフォーム&lt;/th&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;初回/us&lt;/th&gt;
&lt;th&gt;二次/us&lt;/th&gt;
&lt;th&gt;三次/us&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;yield&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;td&gt;102&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;分析-5&#34;&gt;分析
&lt;/h3&gt;&lt;p&gt;実行結果から判断すると、オペレーティングシステムの差異により、高精度なスリープ時の &lt;code&gt;sleep_for&lt;/code&gt; の安定性が大きく異なり、高精度なスリープを実現するためには &lt;code&gt;yield&lt;/code&gt; を使用する方が適しています。
時間精度を &lt;code&gt;ms&lt;/code&gt; に向上させた場合、両者の差はほとんど見られません。&lt;/p&gt;
&lt;h3 id=&#34;分析-6&#34;&gt;分析
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;thread&amp;gt;

// 短時間の「忙しい睡眠」を推奨
void little_sleep(std::chrono::microseconds us)
{
    auto start = std::chrono::high_resolution_clock::now();
    auto end = start + us;
    do {
        std::this_thread::yield();
    } while (std::chrono::high_resolution_clock::now() &amp;lt; end);
}

int main()
{
    auto start = std::chrono::high_resolution_clock::now();

    little_sleep(std::chrono::microseconds(100));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;### 分析
little_sleep(std::chrono::microseconds(100));
    std::this_thread::sleep_for(std::chrono::microseconds(100));

    auto elapsed = std::chrono::high_resolution_clock::now() - start;
    std::cout &amp;lt;&amp;lt; &amp;quot;待ち時間: &amp;quot;
              &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(elapsed).count()
              &amp;lt;&amp;lt; &amp;quot; マイクロ秒\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参照&#34;&gt;参照
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/header/thread.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/header/thread.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/thread/sleep_for.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/thread/sleep_for.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>新しい言語を学ぶべき理由は何ですか？</title>
        <link>https://ttf248.life/ja/p/why-learn-a-new-language/</link>
        <pubDate>Thu, 04 Aug 2022 11:27:30 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/why-learn-a-new-language/</guid>
        <description>&lt;p&gt;学歴から算じると、C++に触れるのは10年以上になる。他のプログラミング言語を学ぶ必要がなぜあるのか？&lt;/p&gt;
&lt;p&gt;職務経験：エレガントなモジュール設計の経験が不足しており、C++の構文は自由度が高いため、他の言語を学習することで、よりエレガントな設計を書くことができるように導かれている。&lt;/p&gt;
&lt;p&gt;いくつかのツールを作成する際に、頻繁に利用される。
低レベルライブラリのデザインやビジネスモジュールの実装など、デザインの原則もすべて理解できている。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>標準ライブラリコンテナのメモリ割り当て子：allocator</title>
        <link>https://ttf248.life/ja/p/standard-library-container-memory-allocator/</link>
        <pubDate>Mon, 30 Dec 2019 13:26:19 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/standard-library-container-memory-allocator/</guid>
        <description>&lt;p&gt;カスタムディストリビューターは、パフォーマンスを向上させ、メモリ使用効率を高め、頻繁な少量のメモリ割り当ての問題を解決できます。&lt;/p&gt;
&lt;h4 id=&#34;前因&#34;&gt;前因
&lt;/h4&gt;&lt;p&gt;近頃、ネットワークパケットの開発に携わり、頻繁に小さなメモリ領域を申請し解放する必要があり、当初はメモリプールを使用することを検討していました。いくつかの既存のメモリプールを確認したところ、この
&lt;a class=&#34;link&#34; href=&#34;https://github.com/cacay/MemoryPool&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/cacay/MemoryPool&lt;/a&gt;
を見つけました。インターフェースを見たとき、このメモリプールの実装が少し奇妙だと疑問に思いました。「MemoryPool」の実装ロジックは、固定サイズのメモリ領域を申請することです。boostのメモリプールインターフェースを見てみると、テンプレートを提供し、使用時にインスタンス化します。ちょうどこのライブラリには、&lt;code&gt;allocator&lt;/code&gt;という概念について言及した記事があり、紹介されていました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;#### [wiki](https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_(C%2B%2B))

C++プログラミングにおいて、割り当て子（英語：allocator）はC++標準ライブラリの重要な構成要素です。C++のライブラリには、リスト、集合などのように、共通して「コンテナ」と呼ばれるさまざまなデータ構造が定義されています。これらのコンテナの共通の特徴は、プログラムの実行時にサイズを変更できることです。この機能を実装するために、動的メモリ割り当てが必要となり、その際に割り当て子が使用されます。具体的には、割り当て子は、標準テンプレートライブラリ（STL）コンテナのメモリ管理に関する低レベルの詳細を包摂します。デフォルトでは、C++標準ライブラリは独自の汎用割り当て子を使用しますが、必要に応じてプログラマは独自の割り当て子をカスタマイズして代替することも可能です。
``` - 分配器は、アレクサンドル・ステパノフによってC++標準テンプレートライブラリ（Standard Template Library、以下STL）の一部として発明されました。当初の目的は、「ライブラリをより柔軟にし、低レベルなデータモデルに依存しない方法を用いる」ことでした。また、プログラマがライブラリ内でカスタムポインタや参照型を利用することを可能にするものでした。しかし、標準テンプレートライブラリをC++標準に組み込む際、C++標準委員会は、データモデルの完全な抽象化処理が不可受容な性能低下をもたらすことを認識し、妥協策として、分配器に対する制限がより厳しくなりました。その結果、ステパノフ当初の構想と比較して、現在の標準で記述されている分配器のカスタマイズ性は大幅に制限されています。

#### [wiki](https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_(C%2B%2B))
ディストリビュータのカスタマイズには制限があるものの、多くのケースではカスタムディストリビュータの使用が必要であり、これは通常、異なる種類のメモリ空間（共有メモリと回収済みメモリなど）へのアクセス方法をカプセル化したり、メモリプールを使用したメモリ割り当て時のパフォーマンス向上を目的に行われます。さらに、メモリ使用量と実行時間という観点から見ると、頻繁に少量のメモリを割り当てるプログラムでは、専用のディストリビュータを導入することで大きなメリットが得られます。

#### [使用要件](https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_(C%2B%2B))
カスタムディスペンサーを定義する主な理由は、パフォーマンスの向上です。専用のカスタムディスペンサーを使用することで、プログラムのパフォーマンスを向上させたり、メモリ使用量を削減したり、あるいは両方を組み合わせることも可能です[4][8]。デフォルトディスペンサーは`new`演算子を使用してストレージ空間を割り当てるため[文 5]、これは通常C言語のヒープ割り当て関数（malloc()）によって実装されます[9]。ヒープ割り当て関数は、偶発的な大量メモリ割り当てに最適化されているため、ベクトルや双端キューのような、一度に大量のメモリを必要とするコンテナにメモリを割り当てる場合は、デフォルトディスペンサーは通常効率的です[8]。しかし、連想コンテナと双方向リストのような、頻繁に少量メモリを割り当てる必要があるコンテナを使用する場合、デフォルトディスペンサーを使用すると、通常パフォーマンスが低下します[4][9]。

#### [利用要請](https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_(C%2B%2B))
要するに、このセクション（……）（まるで）は、この標準がディストリビューターに対する「私は夢を見る」の演説です。夢が実現する前に、移植性を重視するプログラマーは、ステートレスなカスタムディストリビューターに限定されます。
——スコット・メイヤー，《Effective STL》
上記を鑑みて、この状況下では、メモリプールベースのディストリビューターを使用して、頻繁で少量の割り当ての問題を解決することが一般的です[8]。 デフォルトの「オンデマンド」方式とは異なり、メモリプールベースのアロケータを使用する場合、プログラムは事前に大量のメモリ（すなわち「メモリプール」）を割り当てます。その後、メモリを割り当てる必要があるときに、カスタムアロケータは、リクエスト側に対してプール内のメモリへのポインタを返すだけで済みます。オブジェクトが破棄される際には、実際にメモリを解放する必要はなく、代わりにメモリプールのライフサイクル終了時まで遅延させ、その時点で真正に解放されます[注 1][8]。

#### [使用要件](https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_(C%2B%2B))

「カスタム分配器」というテーマに関して、多くの C++ 専門家や関連著者の議論に参加しており、例えばスコット・メイスの『Effective STL』やアンデル・アレクサンドレスクの『Modern C++ Design』で言及されている。メイスは、特定の型 T の分配子のすべてのインスタンスが等しいとすれば、移植可能な分配子のインスタンスには状態を含んではならないと洞察している。C++ 標準はライブラリの実装者が状態付きの分配子をサポートするように推奨している[文 4]が、メイスは「この段落は、（まるで）素晴らしい見解だが、ほぼ空論であり」、分配子の制限は「過度に厳格」であると称している[4]。 例えば、STLのリストはスプラッシュ（splice）メソッドをサポートしており、あるリストオブジェクトAのノードを別のリストオブジェクトBに直接挿入することができます。これは、Aのアルロケーター（allocator）が確保したメモリを、Bのアルロケーターが解放することを意味し、そこからAとBのアルロケーターインスタンスは等しいという結論を導き出されます。メイヤーの結論は、アルロケーターは静的メソッドを使用する型として定義するのが最適であるということです。例えば、C++標準では、アルロケーターはrebindメソッドを実装したotherクラステンプレートを提供する必要があります。

#### [使用要件](https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_(C%2B%2B))

ヤニー・ストラウストルプが『C++プログラム設計言語』で述べたように、「厳密な割り当て制限により、各オブジェクトの情報が異なることを防ぐ」という点は「問題ない」（大意）とされ、ほとんどの割り当て器は状態を必要とせず、あるいは状態がない場合に性能が良いと指摘されている。彼は、メモリプール型、共有メモリ型、そしてガベージコレクション型の3つのカスタム割り当て器のユースケースを提案し、内部メモリプールを使用して少量のメモリを迅速に割り当て/解除する割り当て器の実装を示した。しかし、このような最適化は、彼が提供したサンプル割り当て器にもすでに実装されていることを認めている[3]。

カスタム割り当て器のもう一つの用途は、メモリ関連のエラーのデバッグである[10]。 これを実現するには、割り当て時に追加のメモリを割り当て、そこでデバッグ情報を保存するディスパッサーを作成できます。このようなディスパッサーは、同種の割り当て/解放が同一ディスパッサーによって行われるだけでなく、キャッシュオーバフローからプログラムをある程度保護することも可能です[11]。&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
    </channel>
</rss>
