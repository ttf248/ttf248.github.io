<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Github Copilot on 向叔の手帳</title>
        <link>https://ttf248.life/ja/tags/github-copilot/</link>
        <description>Recent content in Github Copilot on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Mon, 02 Jun 2025 19:00:25 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/tags/github-copilot/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>AIによるプログラミング支援、生産性の進化</title>
        <link>https://ttf248.life/ja/p/ai-assisted-programming-productivity-evolution/</link>
        <pubDate>Tue, 28 Feb 2023 17:05:17 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/ai-assisted-programming-productivity-evolution/</guid>
        <description>&lt;p&gt;GitHub Copilot のリリースからわずか 2 年しか経っていないのに、ChatGPT が登場し、裏にある原理をよく理解していない状態で、しばらく使ってみた。2 つのツールのサポートレベルは全く異なりだが、どちらも生産性を大幅に向上させた。
あまりにも複雑なことについては、AI ではまだできないだろう。なぜなら、彼らは論理がなく、パターンや形式固定されたもの、あるいは范式を確立しているものがだからだ。学習データは十分で、AI の効果は 9 分満点になる。&lt;/p&gt;
&lt;h2 id=&#34;github-copilot&#34;&gt;GitHub Copilot
&lt;/h2&gt;&lt;p&gt;リリース時に、公式サイトの紹介の &lt;code&gt;demo&lt;/code&gt; を見ると、あまり賢くなく、試用してみましたが、使い勝手が良くありませんでしたので、諦めました。
2022年以前に、暇つぶしで切り替えて新バージョンを体験したところ、かなり良くなっており、ただ国内の速度が少し遅いのは、ネットワークの問題である可能性が高いです。&lt;code&gt;Python&lt;/code&gt;のような言語では、コメントに基づいて書かれたコードもそれなりによくできており、自分で資料を探して書いていたよりもはるかに速かったです。&lt;/p&gt;
&lt;h2 id=&#34;chatgpt&#34;&gt;ChatGPT
&lt;/h2&gt;&lt;p&gt;GitHub Copilot は、プログラマー、つまり開発者の視点から製品を設計しており、プログラミングを知っている必要がある。徐々にコメントを通じて AI を活用したプログラミングを支援してもらう。&lt;/p&gt;
&lt;p&gt;ChatGPT は次の段階に進み、&lt;strong&gt;専門知識のない人でもすぐに使いこなせるように&lt;/strong&gt;なった。対話形式でのチャットインターフェースであり、完全に質問や要求事項を提示し、理解できない場合はさらに質問することができる。 簡単な例を挙げます。品詞分割の概念は理解しているものの、どのようにエンコードするか分からないため、文字列の類似度を計算したいと考えています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Python 品詞分割を用いて、「維天運通 LOGORY 和 合肥維天運通信息科技股份有限公司」という2つの文字列の類似度を計算します。比較する前に、文字列を統一的に処理し、英文は小文字に変換します。2番目の文字列の中に、1番目の文字列の先頭文字が見つかれば、2番目の文字列を1番目の文字列の長さ分切り捨てます。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;こんにちは、これはBingです。😊&lt;/p&gt;
&lt;p&gt;オンラインの情報123に基づくと、Python の品詞分割には jieba などのライブラリを使用できます。jieba ライブラリは、精密モード、全模式、検索エンジンモードの3種類の品詞分割をサポートしています。要件に応じて適切なモードを選択してください。 2つの文字列の類似度を比較するためには、まずそれらをトークン化し、その後、単語ベクトルや編集距離などの指標を計算する必要があります。NumPyまたはSciPyなどのライブラリを使用して、これらの数値演算を実行できます。&lt;/p&gt;
&lt;h2 id=&#34;chatgpt-1&#34;&gt;ChatGPT
&lt;/h2&gt;&lt;p&gt;文字列の統一的な処理、および英語を小文字に変換するには、Python の組み込み関数 &lt;code&gt;lower()&lt;/code&gt; を使用できます。
2 番目の文字列を抽出するには、Python のスライス演算子 &lt;code&gt;[ ]&lt;/code&gt; を使用します。
以下は 1 つの可能なコード例です：&lt;/p&gt;
&lt;h2 id=&#34;chatgpt-2&#34;&gt;ChatGPT
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import jieba
import numpy as np
from scipy.spatial.distance import cosine

# 定义两个字符串
str1 = &amp;quot;維天運通 LOGORY&amp;quot;
str2 = &amp;quot;合肥維天運通信息科技股份有限公司&amp;quot;

# 统一处理字符串，英文转换为小写
str1 = str1.lower()
str2 = str2.lower()

# 找到第二个字符串中第一个字符的位置
index = str2.find(str1[0])

# 如果找到了，截取第二个字符串
if index != -1:
    str2 = str2[index:index+len(str1)]

# 使用 jieba 库进行分词
words1 = list(jieba.cut(str1))
words2 = list(jieba.cut(str2))

# 计算两个字符串的词向量（以词频作为权重）
vector1 = np.zeros(len(words1))
vector2 = np.zeros(len(words1))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;chatgpt-3&#34;&gt;ChatGPT
&lt;/h2&gt;&lt;h1 id=&#34;2つの文字列の単語ベクトルを計算する-頻度を重みとして使用&#34;&gt;2つの文字列の単語ベクトルを計算する (頻度を重みとして使用)
&lt;/h1&gt;&lt;p&gt;vector1 = np.zeros(len(words1))
vector2 = np.zeros(len(words1))&lt;/p&gt;
&lt;p&gt;for i, word in enumerate(words1):
vector1[i] += 1  # 最初の文字列内の各単語の出現回数をカウント
if word in words2:
vector2[i] += 1  # 2番目の文字列内の各単語の出現回数をカウント&lt;/p&gt;
&lt;h1 id=&#34;2つの文字列の類似度を計算する-コサイン距離を指標として使用&#34;&gt;2つの文字列の類似度を計算する (コサイン距離を指標として使用)
&lt;/h1&gt;&lt;p&gt;similarity = 1 - cosine(vector1, vector2)&lt;/p&gt;
&lt;p&gt;print(&amp;ldquo;2つの文字列の類似度は：&amp;rdquo;, similarity)&lt;/p&gt;
&lt;h2 id=&#34;chatgpt-4&#34;&gt;ChatGPT
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;さらに踏み込んで、実行結果の問い合わせ、おめでとうございます。問題が見つかりました。結果はハッタリ（作り話）、コードを実行していません。しかし、素晴らしい結果を提供してくれます。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;栗子&#34;&gt;栗子
&lt;/h3&gt;&lt;p&gt;質問：SQL文で、製品コードテーブルから、製品コードが80000-89999のレコードを抽出するには&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;こんにちは、これはBingです。😊

検索結果12によると、BETWEEN演算子を使用して、指定された範囲内の値を選択できます。BETWEEN演算子は、開始値と終了値を両方含みます。

まず、クエリするテーブル名と列名を指定し、WHERE句でBETWEEN演算子と範囲値を指定する必要があります。

たとえば、製品コードテーブルから、製品コードが80000から89999のレコードを抽出するには、次のステートメントを使用できます。

SELECT * FROM product_code
WHERE code BETWEEN 80000 AND 89999;
ここで、*はすべての列を選択することを意味します3。
``` 製品コードは文字列であり、あなたのコードは間違っています。

### 栗子

```markdown
申し訳ありませんが、製品コードが文字列であることに気づいていませんでした。もしそうであれば、区間値の両側にシングルクォートを追加する必要があります。例：

SELECT * FROM product_code
WHERE code BETWEEN &#39;80000&#39; AND &#39;89999&#39;;
私の誤りをお許しください。🙏
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;おめでとうございます、それは間違えるでしょう。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
