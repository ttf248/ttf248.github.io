<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>バイアンス順序 on 向叔の手帳</title>
        <link>https://ttf248.life/ja/tags/%E3%83%90%E3%82%A4%E3%82%A2%E3%83%B3%E3%82%B9%E9%A0%86%E5%BA%8F/</link>
        <description>Recent content in バイアンス順序 on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Mon, 02 Jun 2025 06:00:45 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/tags/%E3%83%90%E3%82%A4%E3%82%A2%E3%83%B3%E3%82%B9%E9%A0%86%E5%BA%8F/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>コンピュータがなぜ一般的にlittle-endian形式のストレージを採用するのか？</title>
        <link>https://ttf248.life/ja/p/little-endian-storage-why/</link>
        <pubDate>Wed, 24 Jan 2024 10:43:05 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/little-endian-storage-why/</guid>
        <description>&lt;p&gt;バイアスの解説 &lt;a class=&#34;link&#34; href=&#34;https://ttf248.life/ja/p/host-order-network-order-debugger-observation/&#34; &gt;ホスト序、ネットワーク序、デバッガで直接観察&lt;/a&gt;
コンピュータ分野の歴史的経緯から生まれた特定の設計習慣は、お尻の幅がロケットエンジンの幅を決定するように、詳細な分析や「利点」「欠点」の検討をする必要はありません。単なる歴史的な習慣です。&lt;/p&gt;
&lt;h2 id=&#34;元のリンク&#34;&gt;元のリンク
&lt;/h2&gt;&lt;p&gt;著者：北極
リンク：&lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/question/637413724/answer/3346032134&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.zhihu.com/question/637413724/answer/3346032134&lt;/a&gt;
出典：知乎
著作権は著作者に帰属します。商業的な転載をご希望の場合は、著者にご連絡して許可を得てください。非営利の転載の場合は、出所を明記してください。&lt;/p&gt;
&lt;h2 id=&#34;転載文&#34;&gt;転載文
&lt;/h2&gt;&lt;p&gt;現代における様々なデバイスの状況は、歴史的慣習と商業化の結果であり、技術そのものではなく、その要因が大きく影響しています。ARM は大端でも小端でも設定できます。TCP/IP ヘッダも現在もビッグエンディアン（ネットワークバイトオーダー）です。ストレージ分野にも、多くのストレージプロトコル／仕様が大端方式でデータを保存しています。&lt;/p&gt;
&lt;p&gt;したがって、質問者の3つの問題は、今日の視点から見ると：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;なぜコンピュータは普遍的に小端形式での保存を採用するのか？ → 間違いです。&lt;/li&gt;
&lt;li&gt;低バイトデータが低アドレスの小端形式よりも大端形式で効率的である理由は何なのか？ → 効率は向上しません。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;現在の技術を用いてこれらの問題を論証するものは、すべて矢を放ち、その後でターゲットを描くような行為です。&lt;/p&gt;
&lt;h2 id=&#34;正文转载&#34;&gt;正文转载
&lt;/h2&gt;&lt;p&gt;しかし、大端または小端の選択について言えば、コンピュータ開発史において、客観的な要因も存在したことは事実です。ホストバイトオーダー（小端）の利点としては、小端の加算器が比較的容易に作れること、8ビット×4の加算器であれば、単一の8ビット加算器で順番にすべてのバイトを加算すれば良いという点が挙げられます。また、進み方の回路も非常にシンプルであり、大端を採用すると、一度32ビットをロードする必要があり、それ以外の場合は計算ができなくなるためです。現在では、1回のロードが8ビットか32ビットの差は小さいですが、数十年前にはメモリ価格が高価であったため、よりシンプルな方が有利であり、ホストバイトオーダーを選択した背景にはコスト的な考慮があったのです。 ネットワークバイトオーダー（大端）の利点：初期デバイスのキャッシュは非常に小さく、最初に高バイトを受信することで、メッセージ情報を迅速に判断することができました。パケット長（どの程度のキャッシュを準備するか）、アドレス範囲（IPアドレスは前から後ろでマッチングされる）といった要素が考慮されていました。初期のネットワークデバイスのキャッシュはバイト単位であり、高バイトから取得することは確かに若干速い場合がありました。したがって、ネットワークデバイスが大端を使用したのは、コストに関する考慮が主な理由でした。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;そのため、バイトオーダーの選択は、歴史的にはアプリケーションシナリオとコストをより重視するものでした（例えば、PPC/MIPSはネットワークデバイスに適していました）。その後、技術発展に伴い、互換性のために大端小端の設定が現在も引き継がれているという状況になりました。今日から見れば、これらの利点は完全に存在しなくなっており、単なる歴史的習慣に過ぎません。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>ホストモード、ネットワークモード、デバッガを使用して直接観察する</title>
        <link>https://ttf248.life/ja/p/host-order-network-order-debugger-observation/</link>
        <pubDate>Tue, 10 Jan 2023 14:18:12 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/host-order-network-order-debugger-observation/</guid>
        <description>&lt;p&gt;コンピュータの発展の歴史において、データの保存方法には統一された標準は存在しませんでした。
バイトの並び方は2つの一般的なルールに従っていました。例えば、ある多桁数の低いバイトを小さなアドレスに、高いバイトを大きなアドレスに配置する場合、これを小端序と呼びました。その逆の場合、大端序と呼びました。ネットワークアプリケーションにおいては、バイトオーダーは考慮すべき重要な要素であり、異なる種類のコンピュータが異なる標準のバイトオーダーを採用している可能性があるため、すべてネットワーク標準に変換されます。
読解習慣に従うと、大端バイトオーダーは左から右への読み込み順序に合致します。&lt;/p&gt;
&lt;h2 id=&#34;プロセッサアーキテクチャhttpszhwikipediaorgwikie5ad97e88a82e5ba8f&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;プロセッサアーキテクチャ&lt;/a&gt;
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;x86、MOS Technology 6502、Z80、VAX、PDP-11などのプロセッサは小端序を採用&lt;/li&gt;
&lt;li&gt;Motorola 6800、Motorola 68000、PowerPC 970などのプロセッサは大端序を採用&lt;/li&gt;
&lt;li&gt;ARM、PowerPC（PowerPC 970を除く）、DEC Alpha、SPARC V9、MIPS、PA-RISCおよびIA64のバイトオーダーは可変式&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;网络序&#34;&gt;网络序
&lt;/h2&gt;&lt;p&gt;ネットワーク転送では、大端序が一般的に採用されており、ネットワークバイト序またはネットワーク序とも呼ばれます。IPプロトコルにおいて、大端序はネットワークバイト序として定義されています。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Berkeley&lt;/code&gt;ソケットは、16ビットおよび32ビット整数をネットワーク序とホストバイト序間で変換するための変換関数群を定義しています。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;asio&lt;/code&gt;を使用する場合、組み込みの命名空間には、クロスプラットフォームに対応した関数名が含まれています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;boost::asio::detail::socket_ops::network_to_host_long&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::network_to_host_short&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::host_to_network_long&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::host_to_network_short&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;visual-studio-デバッガー&#34;&gt;Visual Studio デバッガー
&lt;/h2&gt;&lt;p&gt;デバッグモードでは、デバッグメニューを選択し、ウィンドウからメモリウィンドウにチェックを入れます。
Visual Studio では、デバッガー内で直接メモリ内のデータを表示できます（下記画像参照）。
&lt;img src=&#34;https://ttf248.life/p/host-network-byte-order-debugger/Snipaste_2023-01-10_14-44-00.png&#34;
	width=&#34;535&#34;
	height=&#34;147&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;デバッガーメニュー&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;363&#34;
		data-flex-basis=&#34;873px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;メモリの確認方法&#34;&gt;メモリの確認方法
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ウィンドウから直接変数名を表示し、対応する変数のアドレスにジャンプ&lt;/li&gt;
&lt;li&gt;変数が元のポインタ型の場合、ウィンドウで変数をダブルクリックして選択し、メモリウィンドウにドラッグすることで、対応する内容を表示&lt;/li&gt;
&lt;li&gt;変数がポインタ型でない場合は、計算ウィンドウに追加し、アドレスを取得してから手動でメモリウィンドウにコピー&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例を挙げる&#34;&gt;例を挙げる
&lt;/h3&gt;&lt;p&gt;データを受け取り、&lt;code&gt;buffer&lt;/code&gt;オブジェクトに保存し、ネットワークバイトオーダーをホストバイトオーダーに変換して、&lt;code&gt;body_length&lt;/code&gt;が30になるようにします。サーバー側では、このデータを送信するために4バイトを使用します。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;大端バイトオーダー&lt;/strong&gt;: メモリウィンドウ内で &lt;code&gt;buffer_&lt;/code&gt; の内容を観察する
&lt;img src=&#34;https://ttf248.life/p/host-network-byte-order-debugger/buffer_.png&#34;
	width=&#34;603&#34;
	height=&#34;318&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;buffer_&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;189&#34;
		data-flex-basis=&#34;455px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;小端バイトオーダー&lt;/strong&gt;: メモリウィンドウ内で &lt;code&gt;body_length_&lt;/code&gt; の内容を観察する
&lt;img src=&#34;https://ttf248.life/p/host-network-byte-order-debugger/body_length_.png&#34;
	width=&#34;581&#34;
	height=&#34;333&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;body_length_&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;174&#34;
		data-flex-basis=&#34;418px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
