<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>バイアンス順序 on 向叔の手帳</title>
        <link>https://ttf248.life/ja/tags/%E3%83%90%E3%82%A4%E3%82%A2%E3%83%B3%E3%82%B9%E9%A0%86%E5%BA%8F/</link>
        <description>Recent content in バイアンス順序 on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Mon, 02 Jun 2025 19:00:25 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/tags/%E3%83%90%E3%82%A4%E3%82%A2%E3%83%B3%E3%82%B9%E9%A0%86%E5%BA%8F/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>コンピュータがなぜ一般的にlittle-endian形式のストレージを採用するのか？</title>
        <link>https://ttf248.life/ja/p/little-endian-storage-why/</link>
        <pubDate>Wed, 24 Jan 2024 10:43:05 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/little-endian-storage-why/</guid>
        <description>&lt;p&gt;バイアスの解説 &lt;a class=&#34;link&#34; href=&#34;https://ttf248.life/ja/p/host-network-byte-order-debugger/&#34; &gt;ホスト序、ネットワーク序、デバッガで直接観察&lt;/a&gt;
コンピュータ分野における歴史的な理由による特定の設計習慣は、お尻の幅がロケットエンジンの幅を決定する道理と同じです。中身の「利点」や「欠点」を分析する必要はなく、単なる歴史的習慣に過ぎません。&lt;/p&gt;
&lt;h2 id=&#34;元文章リンク&#34;&gt;元文章リンク
&lt;/h2&gt;&lt;p&gt;著: 北極
リンク: &lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/question/637413724/answer/3346032134&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.zhihu.com/question/637413724/answer/3346032134&lt;/a&gt;
出典: 知乎
著作権は著作者に帰属します。商業目的での複製をご希望の場合は、著者にご連絡ください。非営利目的の複製の場合は、出所を明記してください。&lt;/p&gt;
&lt;h2 id=&#34;正文转载&#34;&gt;正文转载
&lt;/h2&gt;&lt;p&gt;現代における様々なデバイスの状況は、歴史的慣習と商業化の結果であり、技術そのものではなく、大きな要因です。ARM は大端でも小端でも設定できます。TCP/IP ヘッダも現在もビッグエンディアン（ネットワークバイトオーダー）に固定されています。ストレージ分野にも、多くのストレージプロトコル／仕様が大端方式でデータを保存しています。&lt;/p&gt;
&lt;p&gt;したがって、質問者の3つの問題は、今日の視点から見ると：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;コンピュータが一般的に小端形式での保存を採用するのはなぜ？ → 間違いです。&lt;/li&gt;
&lt;li&gt;低バイトデータが低アドレスの小端形式で大端形式よりも効率が良いのはなぜですか？ → 効率は向上しません。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;現在の技術を用いてこれらの問題を論証するものは、すべて「矢を射ってから的を描く」行為に過ぎません。&lt;/p&gt;
&lt;h2 id=&#34;正文转载-1&#34;&gt;正文转载
&lt;/h2&gt;&lt;p&gt;しかし、大端または小端の選択について言えば、コンピュータ開発史において、客観的な要因も存在したことは事実です。ホストバイトオーダー（小端）の利点として、小端の加算器が比較的容易に作れること、8ビット×4の加算器であれば、1つの8ビット加算器で順番にすべてのバイトを加算すれば良いからです。また、進み方の回路も非常にシンプルであり、大端では一度32ビットをロードする必要があるため、計算ができなくなってしまいます。現在では、1回のロードが8ビットか32ビットの差は小さいですが、数十年前にはメモリ価格が高価であったため、よりシンプルな方が有利でした。そのため、ホストバイトオーダーを選択したのは、コストを考慮した結果です。 ネットワークバイトオーダー（ビッグエンディアン）の利点：初期デバイスのキャッシュは小さく、最初に高バイトを受信することで、メッセージ情報を迅速に判断できる：パケット長（どの程度のキャッシュを準備するか）、アドレス範囲（IPアドレスは前から後ろでマッチングされる）。初期のネットワークデバイスのキャッシュはバイト単位であり、高バイトを先に取得することは実際に少し速い。したがって、ネットワークデバイスがビッグエンディアンを使用することも、コストを考慮した結果である。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;そのため、バイトオーダーの選択は、歴史的に見て、アプリケーションシナリオとコストをより重視していた（例えば、PPC/MIPSはネットワークデバイスに適している）。その後、技術発展の中で、互換性のために、エンディアンの設定が現在も引き継がれている。今日の視点で見れば、これらの利点は完全に存在しないだけであり、単なる歴史的習慣に過ぎない。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>ホストモード、ネットワークモード、デバッガを使用して直接観察する</title>
        <link>https://ttf248.life/ja/p/host-network-byte-order-debugger/</link>
        <pubDate>Tue, 10 Jan 2023 14:18:12 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/host-network-byte-order-debugger/</guid>
        <description>&lt;p&gt;コンピュータの発展の歴史において、データの保存方法には統一された標準は存在しませんでした。
バイトの並び方は2つの一般的なルールに従っていました。例えば、ある多桁数の低いバイトを小さいアドレスに、高いバイトを大きいアドレスに配置する場合、これを小端序と呼びます。その逆の場合、大端序と呼びます。ネットワークアプリケーションにおいては、バイトオーダーは考慮すべき重要な要素であり、異なる種類のコンピュータが異なる標準のバイトオーダーを採用しているため、すべてネットワーク標準に変換されます。
読解習慣に従うと、大端バイトオーダーの方が左から右への読み込み順序に合致します。&lt;/p&gt;
&lt;h2 id=&#34;プロセッサアーキテクチャhttpszhwikipediaorgwikie5ad97e88a82e5ba8f&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;プロセッサアーキテクチャ&lt;/a&gt;
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;x86、MOS Technology 6502、Z80、VAX、PDP-11などのプロセッサは小端序を採用&lt;/li&gt;
&lt;li&gt;Motorola 6800、Motorola 68000、PowerPC 970などのプロセッサは大端序を採用&lt;/li&gt;
&lt;li&gt;ARM、PowerPC（PowerPC 970を除く）、DEC Alpha、SPARC V9、MIPS、PA-RISCおよびIA64のバイトオーダーは可変式&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;网络序&#34;&gt;网络序
&lt;/h2&gt;&lt;p&gt;ネットワーク転送では一般的に大端序が用いられ、ネットワークバイト序とも呼ばれ、ネットワーク序とも言います。IPプロトコルにおいて大端序はネットワークバイト序として定義されています。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Berkeley&lt;/code&gt;ソケットは、16ビットおよび32ビット整数をネットワーク序とホストバイト序間で変換するための変換関数群を定義しています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;arpa/inet.h&amp;gt;

uint32_t htonl(uint32_t hostlong); // uint32_t をネットワーク序に変換
uint16_t htons(uint16_t hostshort); // uint16_t をネットワーク序に変換
uint32_t ntohl(uint32_t netlong); // uint32_t をネットワーク序からホスト序へ変換
uint16_t ntohs(uint16_t netshort); // uint16_t をネットワーク序からホスト序へ変換
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;asio&lt;/code&gt; をネットワークライブラリとして使用する場合、組み込みの命名空間には、クロスプラットフォームに対応した関数名が用意されています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;boost::asio::detail::socket_ops::network_to_host_long&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ネットワーク序&#34;&gt;ネットワーク序
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;boost::asio::detail::socket_ops::network_to_host_short&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::host_to_network_long&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::host_to_network_short&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;visual-studio-デバッガー&#34;&gt;Visual Studio デバッガー
&lt;/h2&gt;&lt;p&gt;デバッグモードでは、デバッグメニューを選択し、ウィンドウからメモリウィンドウにチェックを入れます。
Visual Studio では、デバッガー内で直接メモリ内のデータを表示できます（下記画像参照）。
&lt;img src=&#34;https://ttf248.life/p/host-network-byte-order-debugger/Snipaste_2023-01-10_14-44-00.png&#34;
	width=&#34;535&#34;
	height=&#34;147&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;デバッガーメニュー&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;363&#34;
		data-flex-basis=&#34;873px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;メモリの確認方法&#34;&gt;メモリの確認方法
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ウィンドウから直接変数名を表示し、対応する変数のアドレスにジャンプします。&lt;/li&gt;
&lt;li&gt;変数が元の場合はポインタである場合、ウィンドウで変数をダブルクリックして選択し、メモリウィンドウにドラッグすると、対応する内容が表示されます。&lt;/li&gt;
&lt;li&gt;変数がポインタでない場合は、計算ウィンドウに追加し、アドレスを取得してから、手動でメモリウィンドウにコピーします。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例を挙げて説明します&#34;&gt;例を挙げて説明します
&lt;/h3&gt;&lt;p&gt;データを受信し、&lt;code&gt;buffer&lt;/code&gt;オブジェクトに格納します。ネットワークバイトオーダーをホストバイトオーダーに変換し、&lt;code&gt;body_length&lt;/code&gt;が30になります。サーバー側では、このデータを送信するために4バイトを使用します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool NetworkMessage::decode_header()
{
    // ネットワークバイトオーダーをホストバイトオーダーに変換
    body_length_ = boost::asio::detail::socket_ops::network_to_host_long(*(int *)buffer_.data());
    return auto_reserve(body_length_);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;大端型バイトオーダー&lt;/strong&gt;: メモリウィンドウ内の&lt;code&gt;buffer_&lt;/code&gt;の内容を観察します。
&lt;img src=&#34;https://ttf248.life/p/host-network-byte-order-debugger/buffer_.png&#34;
	width=&#34;603&#34;
	height=&#34;318&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;buffer_&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;189&#34;
		data-flex-basis=&#34;455px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;小端型バイトオーダー&lt;/strong&gt;: メモリウィンドウ内の&lt;code&gt;body_length_&lt;/code&gt;の内容を観察します。
&lt;img src=&#34;https://ttf248.life/p/host-network-byte-order-debugger/body_length_.png&#34;
	width=&#34;581&#34;
	height=&#34;333&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;body_length_&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;174&#34;
		data-flex-basis=&#34;418px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
