<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>ビット演算 on 向叔の手帳</title>
        <link>https://ttf248.life/ja/tags/%E3%83%93%E3%83%83%E3%83%88%E6%BC%94%E7%AE%97/</link>
        <description>Recent content in ビット演算 on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Sun, 25 May 2025 14:10:37 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/tags/%E3%83%93%E3%83%83%E3%83%88%E6%BC%94%E7%AE%97/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>C&#43;&#43; ビット演算の基礎：ビットごとの値の取得とフラグ設定</title>
        <link>https://ttf248.life/ja/p/cpp-bitwise-operations-basics-flags/</link>
        <pubDate>Fri, 17 Jan 2025 02:23:56 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/cpp-bitwise-operations-basics-flags/</guid>
        <description>&lt;p&gt;実際のC++開発において、ビット演算は一般的な技術であり、特にシステム状態、フラグ、または制御ビットを扱う際には、非常に効率的な解決策を提供します。本稿では、例を通して、ビット演算を使用して特定のフラグを取得および設定する方法について解説します。&lt;/p&gt;
&lt;h3 id=&#34;ビット演算の基本概念&#34;&gt;ビット演算の基本概念
&lt;/h3&gt;&lt;p&gt;コンピュータでは、データは2進数のビット（0と1）で格納されます。ビット演算とは、これらの2進数のビットに対して行う操作のことです。C++にはいくつかの一般的なビット演算子があります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ビットごとの論理積(&amp;amp;)：あるビットが1であるかどうかを確認するために使用されます。&lt;/li&gt;
&lt;li&gt;ビットごとに、または（|）を使用します。あるビットを1に設定するために使用されます。&lt;/li&gt;
&lt;li&gt;ビットごとの排他的OR（^）：あるビットを反転するために使用されます。&lt;/li&gt;
&lt;li&gt;各ビットを反転する。&lt;/li&gt;
&lt;li&gt;左シフト（&amp;laquo;）：すべてのビットをいくつか左にずらす。&lt;/li&gt;
&lt;li&gt;右シフト（&amp;raquo;）：すべてのビットをいくつか右に移動します。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この例では、&lt;code&gt;unsigned short&lt;/code&gt; 型の変数 &lt;code&gt;wInfo&lt;/code&gt; に対して一連のビット演算を行い、異なるフラグによって異なる状態を表します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;flowchart LR
    A[原始数值: 00010000] --&amp;gt; B[左移: 00010000 &amp;lt;&amp;lt; 1]
    B --&amp;gt; C[结果: 00100000]
    C --&amp;gt; D[右移: 00100000 &amp;gt;&amp;gt; 1]
    D --&amp;gt; E[结果: 00010000]

    subgraph 左移操作
        direction LR
        A --&amp;gt; B --&amp;gt; C
    end

    subgraph 右移操作
        direction LR
        C --&amp;gt; D --&amp;gt; E
    end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;要求分析&#34;&gt;要求分析
&lt;/h3&gt;&lt;p&gt;題目の説明に基づき、異なる状態を表すために使用される16ビットのフラグがあります。これらの状態は、様々な二進数のビットによって示され、各二進数のビットは特定の意味に対応しています。例えば：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ビット０は失敗したか？&lt;/li&gt;
&lt;li&gt;ビット1は圧縮されていますか？&lt;/li&gt;
&lt;li&gt;bit2は増分されているか&lt;/li&gt;
&lt;li&gt;bit3に後続パッケージはありますか。&lt;/li&gt;
&lt;li&gt;通常リクエストまたはログアウト&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;位演算を使用する&#34;&gt;位演算を使用する
&lt;/h3&gt;&lt;p&gt;これらのフラグビットを設定および取得するには、ビット演算を使用します。具体的には：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ビットごとの値を取得する。&lt;/li&gt;
&lt;li&gt;ビット設定：あるビットを1に設定する。&lt;/li&gt;
&lt;li&gt;ビットクリア：あるビットを0に設定する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;まず、これらのフラグを保持するために &lt;code&gt;unsigned short&lt;/code&gt; 型の変数 &lt;code&gt;wInfo&lt;/code&gt; を定義します。その後、ビット演算を使用して、対応するフラグを確認および設定します。&lt;/p&gt;
&lt;h3 id=&#34;cサンプルコード&#34;&gt;C++サンプルコード
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;bitset&amp;gt;

// 定义标志位常量
const unsigned short BIT_0_FAIL = 1 &amp;lt;&amp;lt; 0;    // bit0 是否失败
const unsigned short BIT_1_COMPRESSED = 1 &amp;lt;&amp;lt; 1; // bit1 是否压缩
const unsigned short BIT_2_INCREMENT = 1 &amp;lt;&amp;lt; 2;  // bit2 是否增量
const unsigned short BIT_3_HAS_MORE = 1 &amp;lt;&amp;lt; 3;   // bit3 是否有后续包
const unsigned short BIT_5_CANCEL = 1 &amp;lt;&amp;lt; 5;     // bit5 正常请求(0)或注销(1)

// 检查某一位是否为1
bool isBitSet(unsigned short wInfo, unsigned short bitMask) {
    return (wInfo &amp;amp; bitMask) != 0;
}

// 设置某一位为1
void setBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo |= bitMask;
}

// 清除某一位（设置为0）
void clearBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo &amp;amp;= ~bitMask;
}

int main() {
    // 假设wInfo的初始值为0
    unsigned short wInfo = 0;

    // 设置bit0（失败标志）
    setBit(wInfo, BIT_0_FAIL);
    
    // 设置bit1（压缩标志）
    setBit(wInfo, BIT_1_COMPRESSED);
    
    // 打印wInfo的二进制值
    std::cout &amp;lt;&amp;lt; &amp;quot;wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    // 检查各个标志位
    std::cout &amp;lt;&amp;lt; &amp;quot;bit0 (是否失败): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_0_FAIL) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit1 (是否压缩): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_1_COMPRESSED) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit2 (是否增量): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_2_INCREMENT) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit3 (是否有后续包): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_3_HAS_MORE) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit5 (是否注销): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_5_CANCEL) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;

    // 清除bit1（压缩标志）
    clearBit(wInfo, BIT_1_COMPRESSED);
    
    // 打印更新后的wInfo
    std::cout &amp;lt;&amp;lt; &amp;quot;Updated wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;コード実行、おすすめは旧友：&lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wInfo (in binary): 0000000000000011
bit0 (是否失败): 是
bit1 (是否压缩): 是
bit2 (是否增量): 否
bit3 (是否有后续包): 否
bit5 (是否注销): 否
Updated wInfo (in binary): 0000000000000001
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;コードの説明&#34;&gt;コードの説明
&lt;/h3&gt;&lt;p&gt;フラグの定義：ビットシフト演算（&lt;code&gt;1 &amp;lt;&amp;lt; n&lt;/code&gt;）を使用して、各フラグを定義します。例えば、&lt;code&gt;1 &amp;lt;&amp;lt; 0&lt;/code&gt;は&lt;code&gt;bit0&lt;/code&gt;に対応し、&lt;code&gt;1 &amp;lt;&amp;lt; 1&lt;/code&gt;は&lt;code&gt;bit1&lt;/code&gt;に対応します。このように、各フラグに一意な二進数の位置を割り当てます。&lt;/p&gt;
&lt;p&gt;特定のビットを確認する：&lt;code&gt;isBitSet&lt;/code&gt;関数は、ビット演算&lt;code&gt;wInfo &amp;amp; bitMask&lt;/code&gt;によって特定のフラグが1であるかどうかを確認します。そのビットが1であれば、関数は&lt;code&gt;true&lt;/code&gt;を返し、そうでなければ&lt;code&gt;false&lt;/code&gt;を返します。&lt;/p&gt;
&lt;p&gt;設定ビット：&lt;code&gt;setBit&lt;/code&gt;関数は、ビット単位のOR演算&lt;code&gt;wInfo |= bitMask&lt;/code&gt;によって特定のフラグを1に設定します。&lt;/p&gt;
&lt;p&gt;特定のビットをクリアする：&lt;code&gt;clearBit&lt;/code&gt;関数は、ビットAND演算&lt;code&gt;wInfo &amp;amp;= ~bitMask&lt;/code&gt;によって特定フラグを0に設定します。&lt;/p&gt;
&lt;h3 id=&#34;まとめ&#34;&gt;まとめ
&lt;/h3&gt;&lt;p&gt;ビット演算を用いることで、複数の状態フラグを効率的に処理できます。特に開発現場では、この技術は非常に役立ちます。例えば、組み込み開発、ネットワークプロトコル、システムの状態管理など、多くの場面でビットフラグを用いて複数の二進数状態を表し、スペースの節約と効率向上を図ることがあります。&lt;/p&gt;
&lt;p&gt;このブログが、C++でビット演算を使用してビット単位での値の取得と設定をどのように行うかを理解するのに役立つことを願っています。これらのスキルを習得することは、効率的で保守しやすいコードを作成する上で非常に役立ちます！&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
