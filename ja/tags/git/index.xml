<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Git on 向叔の手帳</title>
        <link>https://ttf248.life/ja/tags/git/</link>
        <description>Recent content in Git on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Mon, 02 Jun 2025 19:00:25 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/tags/git/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Git 子モジュール提交記録の消失</title>
        <link>https://ttf248.life/ja/p/git-submodule-merge-history-lost/</link>
        <pubDate>Mon, 02 Jun 2025 16:44:58 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/git-submodule-merge-history-lost/</guid>
        <description>&lt;p&gt;ローカルにGitリポジトリがあり、そのサブモジュールがプル時に一時ブランチになっている。私はその一時ブランチでいくつかのコードをコミットし、その後サブモジュールを&lt;code&gt;main&lt;/code&gt;ブランチに戻した。しかし、これらのコミットされたコードが見つからず、&lt;code&gt;main&lt;/code&gt;ブランチで見つけることができない。また、その一時ブランチの履歴も見つけられない。&lt;/p&gt;
&lt;h2 id=&#34;ソリューション&#34;&gt;ソリューション
&lt;/h2&gt;&lt;p&gt;Git サブモジュールで一時的なブランチにコミットし、&lt;code&gt;main&lt;/code&gt; ブランチに戻った後にこれらのコミットが見つからない場合。この状況を解決するには、以下の手順を実行してください。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;コミット履歴の確認&lt;/strong&gt;: サブモジュールディレクトリに移動し、reflog を使用して失われたコミットを見つけます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;新しいブランチを作成してコミットを保存&lt;/strong&gt;: 失われたコミットに基づいて新しいブランチを作成します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;main&lt;/code&gt; ブランチへのマージまたは cherry-pick&lt;/strong&gt;: コードをメインブランチに統合します。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下は具体的な操作手順です：&lt;/p&gt;
&lt;h2 id=&#34;ソリューション-1&#34;&gt;ソリューション
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# サブモジュールディレクトリに移動
cd path/to/your/submodule

# HEADの変更履歴を確認 (未マージされたブランチのコミットも含む)
git reflog
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ソリューション-2&#34;&gt;ソリューション
&lt;/h2&gt;&lt;p&gt;PS F:\dev\notebook\scripts\hugo-content-suite&amp;gt; git reflog
de05175 (HEAD -&amp;gt; main, origin/main, origin/HEAD) HEAD@{0}: checkout: c8d070651310e90d283cb64d98da088c5fe05e73 から main へ移動
c8d0706 HEAD@{1}: commit: feat: Markdown記法の使用方法ドキュメントを追加、詳細な構文例と効果のデモンストレーションを提供
48250f5 HEAD@{2}: commit: feat: 記事翻訳プレビュー機能を削除し、翻訳プロセスを簡素化
b8280b6 HEAD@{3}: commit: feat: 絶対パスを取得する機能を追加し、相対パスを絶対パスに変換することをサポート
92c354b HEAD@{4}: commit: fix: 記事スキャンロジックの修正、絶対パスでのスキャンを保証&lt;/p&gt;
&lt;h2 id=&#34;解決策&#34;&gt;解決策
&lt;/h2&gt;&lt;p&gt;92c354b HEAD@{4}: commit: fix: 文章スキャンロジックの修正、絶対パスでのスキャンを保証
de05175 (HEAD -&amp;gt; main, origin/main, origin/HEAD) HEAD@{5}: checkout: main から de05175d4ec0828e3ae95d726b09dfff18f67a23 に移動
de05175 (HEAD -&amp;gt; main, origin/main, origin/HEAD) HEAD@{6}: clone: &lt;a class=&#34;link&#34; href=&#34;https://cnb.cool/ttf248/hugo-content-suite.git&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cnb.cool/ttf248/hugo-content-suite.git&lt;/a&gt; から&lt;/p&gt;
&lt;h2 id=&#34;ソリューション-3&#34;&gt;ソリューション
&lt;/h2&gt;&lt;h1 id=&#34;破損したコミットからの新しいブランチの作成例456defを使用&#34;&gt;破損したコミットからの新しいブランチの作成（例：456defを使用）
&lt;/h1&gt;&lt;p&gt;git checkout -b saved-work 456def&lt;/p&gt;
&lt;h1 id=&#34;メインブランチに戻る&#34;&gt;メインブランチに戻る
&lt;/h1&gt;&lt;p&gt;git checkout main&lt;/p&gt;
&lt;h1 id=&#34;保存された作業をメインにマージするまたはcherry-pickを使用して特定のコミットを選択&#34;&gt;保存された作業をメインにマージする（またはcherry-pickを使用して特定のコミットを選択）
&lt;/h1&gt;&lt;p&gt;git merge saved-work&lt;/p&gt;
&lt;h1 id=&#34;または&#34;&gt;または
&lt;/h1&gt;&lt;p&gt;git cherry-pick 456def&lt;/p&gt;
&lt;h1 id=&#34;プロジェクトのルートディレクトリに戻りサブモジュールの更新をコミットする&#34;&gt;プロジェクトのルートディレクトリに戻り、サブモジュールの更新をコミットする
&lt;/h1&gt;&lt;p&gt;cd ..
git add path/to/your/submodule
git commit -m &amp;ldquo;Update submodule to include new changes&amp;rdquo;&lt;/p&gt;
&lt;h2 id=&#34;主要操作手順&#34;&gt;主要操作手順
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;git reflog&lt;/strong&gt;: HEADのすべての履歴を表示し、ブランチに関連付けられていないコミットも含む&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;git checkout -b&lt;/strong&gt;: 任意のコミットから新しいブランチを作成し、作業を保存する&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;git merge/cherry-pick&lt;/strong&gt;: 保存されたコミットをターゲットブランチに統合する
reflogで記録が見つからない場合は、&lt;code&gt;git fsck --lost-found&lt;/code&gt;を使用して孤立したコミットを探す必要があるかもしれませんが、これは非常にまれなケースです。&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>Git での履歴記録におけるコミット情報 (または、コミットメッセージ)</title>
        <link>https://ttf248.life/ja/p/git-modify-commit-message/</link>
        <pubDate>Wed, 07 May 2025 18:38:31 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/git-modify-commit-message/</guid>
        <description>&lt;p&gt;スクリプトは、Git の履歴コミットの作者情報をまとめて変更し、&lt;code&gt;git filter-branch&lt;/code&gt; を使用して履歴コミット記録を書き換えます。&lt;/p&gt;
&lt;p&gt;ご提供いただいたスクリプトは、Git リポジトリの履歴コミット中の作者情報をまとめて修正するものであり、全体的な考え方は正しいですが、&lt;code&gt;git filter-branch&lt;/code&gt; の &lt;code&gt;--env-filter&lt;/code&gt; に配列（例：&lt;code&gt;OLD_EMAILS=(&amp;quot;...&amp;quot;)&lt;/code&gt;）を使用すると、互換性の問題が発生する可能性があります。これは、一部のシェル環境（例：&lt;code&gt;/bin/sh&lt;/code&gt;）が配列構文をサポートしていないためです。
互換性を高めるために、配列をスペースで区切られた文字列に置き換え、&lt;code&gt;for&lt;/code&gt; ループを使用して各古いメールアドレスを反復処理することを推奨します。以下は修正後のスクリプトの例です：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh

git filter-branch --env-filter &#39;
OLD_EMAILS=&amp;quot;TianlongXiang51@gmail.com nick@qq.com tianlongxiang51@gmail.com&amp;quot;
CORRECT_NAME=&amp;quot;tianlong.xiang&amp;quot;
CORRECT_EMAIL=&amp;quot;tianlong.xiang@foxmail.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;git filter-branch &amp;ndash;env-filter &#39;
OLD_EMAILS=&amp;ldquo;&lt;a class=&#34;link&#34; href=&#34;mailto:TianlongXiang51@gmail.com&#34; &gt;TianlongXiang51@gmail.com&lt;/a&gt; &lt;a class=&#34;link&#34; href=&#34;mailto:nick@qq.com&#34; &gt;nick@qq.com&lt;/a&gt; &lt;a class=&#34;link&#34; href=&#34;mailto:tianlongxiang51@gmail.com&#34; &gt;tianlongxiang51@gmail.com&lt;/a&gt;&amp;rdquo;
CORRECT_NAME=&amp;ldquo;tianlong.xiang&amp;rdquo;
CORRECT_EMAIL=&amp;ldquo;&lt;a class=&#34;link&#34; href=&#34;mailto:tianlong.xiang@foxmail.com&#34; &gt;tianlong.xiang@foxmail.com&lt;/a&gt;&amp;rdquo;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;for OLD_EMAIL in $OLD_EMAILS
do
  if [ &amp;quot;$GIT_COMMITTER_EMAIL&amp;quot; = &amp;quot;$OLD_EMAIL&amp;quot; ]
  then
    export GIT_COMMITTER_NAME=&amp;quot;$CORRECT_NAME&amp;quot;
    export GIT_COMMITTER_EMAIL=&amp;quot;$CORRECT_EMAIL&amp;quot;
  fi
  if [ &amp;quot;$GIT_AUTHOR_EMAIL&amp;quot; = &amp;quot;$OLD_EMAIL&amp;quot; ]
  then
    export GIT_AUTHOR_NAME=&amp;quot;$CORRECT_NAME&amp;quot;
    export GIT_AUTHOR_EMAIL=&amp;quot;$CORRECT_EMAIL&amp;quot;
  fi
done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;このスクリプトを実行する前に、予期せぬ事態を防ぐため、必ずリポジトリをバックアップしてください。&lt;/li&gt;
&lt;li&gt;この操作はGitの履歴を書き換えるため、コミットの作成者情報を変更し、ハッシュ値が変化する可能性があります。&lt;/li&gt;
&lt;li&gt;既に変更をリモートリポジトリにプッシュしている場合は、強制プッシュが必要です。
強制プッシュの使用には十分注意し、特に複数人での共同開発プロジェクトでは、他者に影響を与えないようにしてください。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;リポジトリ内のすべてのユニークな作成者メールアドレスの統計&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git log --format=&#39;%an &amp;lt;%ae&amp;gt;&#39; | sort -u
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Git で HTTP リポジトリを無効にする</title>
        <link>https://ttf248.life/ja/p/git-disable-http-repositories/</link>
        <pubDate>Mon, 08 Jan 2024 21:22:04 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/git-disable-http-repositories/</guid>
        <description>&lt;p&gt;習慣更新ソフトウェアバージョンです。Gitのどのバージョンの場合にHTTPリポジトリからのコード取得が許可されないか不明ですが、以下のエラーが表示されるため、HTTPSを使用するようにリポジトリリモートURLを確認してください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;fatal: Unencrypted HTTP is not supported for GitLab. Ensure the repository remote URL is using HTTPS
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;背景説明&#34;&gt;背景説明
&lt;/h2&gt;&lt;p&gt;環境：Windows 平台、これまで小烏龟を使ってgitを操作しており、鍵の認証も小烏龜で処理していました。以前、ローカルリポジトリを一括更新するスクリプトを作成したこともあります。&lt;/p&gt;
&lt;p&gt;前回の記事へのリンク：[ローカルGitリポジトリの一括更新](&amp;lt;{{ relref &amp;ldquo;/post/2023/10-19-批量更新本地git仓库&amp;rdquo; &amp;gt;})&lt;/p&gt;
&lt;p&gt;今日、帰宅してコードの更新を実行しようとしたところ、上記のエラーが発生し、リポジトリが正常に更新されなくなりました。&lt;code&gt;Git&lt;/code&gt;には設定があるのだろうかと思い、&lt;code&gt;http&lt;/code&gt;プロトコルを使った更新を試みましたが、対応する設定項目は見つかりませんでした。&lt;/p&gt;
&lt;p&gt;最も簡単な解決策は、&lt;code&gt;ssh&lt;/code&gt;プロトコルに変更してリポジトリを更新することです。会社で設定されている&lt;code&gt;gitlab&lt;/code&gt;は短期的に&lt;code&gt;https&lt;/code&gt;プロトコルを提供しません。&lt;/p&gt;
&lt;h2 id=&#34;既存の問題&#34;&gt;既存の問題
&lt;/h2&gt;&lt;p&gt;以前、ローカルリポジトリをまとめて更新するスクリプトを作成する際に、&lt;code&gt;ssh&lt;/code&gt; を使ってリポジトリを取得することを検討していたが、詳細を確認しなかった。小烏龜（TortoiseGit）で設定した &lt;code&gt;git&lt;/code&gt; の設定情報を config に同期していないため、コマンドラインから &lt;code&gt;git pull&lt;/code&gt; を実行したところ&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git pull # 権限がない旨が表示され、正常にリポジトリを更新できない
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;コマンドで鍵の構成を確認しても正しい：&lt;code&gt;ssh -T git@gitlab.yintech.net&lt;/code&gt;
Git小烏龜（TortoiseGit）でコードを正常に取得できるが、コマンドラインで &lt;code&gt;git pull&lt;/code&gt; コマンドを使用すると、鍵が正しくない旨が表示される場合、Git小烏龜は PuTTY の SSH 鍵を使用しているのに対し、コマンドラインは OpenSSH の SSH 鍵を使用している可能性がある。
小烏亀の鍵構成はシステム . から同期されない。 SSH フォルダの読み込みで秘密鍵ファイルの情報を使用するのではなく、インターフェースのレポジトリ設定時に個別に秘密鍵ファイルのパスを設定する方法について：最初のレポジトリをクローンし、その設定で秘密鍵を設定すれば、他のレポジトリも同じ秘密鍵ファイルを再利用できます。PuTTY が秘密鍵をロードした後、すぐに終了せず、代理サービスを開始します。&lt;/p&gt;
&lt;h2 id=&#34;既存の問題-1&#34;&gt;既存の問題
&lt;/h2&gt;&lt;p&gt;グローバル設定を調整することで、システムデフォルトの &lt;code&gt;ssh&lt;/code&gt; 設定を使用せず、TortoisePlink を使用して SSH 操作を行うように構成します。この設定は、TortoiseGit に含まれる PuTTY ツールを使用する場合に適しています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global core.sshCommand &amp;quot;&#39;C:/Program Files/TortoiseGit/bin/TortoisePlink.exe&#39; -batch -ssh&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記の実行ファイルのパスを、ご自身の TortoiseGit のパスに合わせて変更してください。設定の完全なパスを使用するため、システム環境変数にパスを追加する必要はありません。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>ローカルのGitリポジトリと履歴上の遺留権限の問題の一括更新</title>
        <link>https://ttf248.life/ja/p/bulk-update-local-git-and-legacy-permissions/</link>
        <pubDate>Thu, 19 Oct 2023 14:16:22 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/bulk-update-local-git-and-legacy-permissions/</guid>
        <description>&lt;p&gt;チームのプロジェクト間に依存関係が存在し、歴史的な理由により &lt;code&gt;submodule&lt;/code&gt; を使用せずにプロジェクトの依存を管理していたため、日常の開発ではリポジトリコードを順番に更新する必要があり、そうでないと様々な奇妙な問題が発生する可能性がある。&lt;/p&gt;
&lt;p&gt;オンラインの情報源を参照して、構造は基本的に同じである。ローカルで git_list.txt というディレクトリを維持し、スクリプトを使用してディレクトリを反復処理し、一度に更新を実行し、その後始業前にこのスクリプトを実行する。&lt;/p&gt;
&lt;h2 id=&#34;linux&#34;&gt;Linux
&lt;/h2&gt;&lt;p&gt;新しいファイルを作成：batch_pull.sh&lt;/p&gt;
&lt;h2 id=&#34;linux-1&#34;&gt;Linux
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash

echo &amp;quot;============ リポジトリの更新 ===================&amp;quot;

# git_list.txt ファイルが存在するか確認
if [ ! -f &amp;quot;git_list.txt&amp;quot; ]; then
  echo &amp;quot;git_list.txt が存在しません！ git を取得したいリポジトリ URL を作成し、追加してください。&amp;quot;
  exit 1
else
  echo &amp;quot;============ git リポジトリリストを検出しました ====&amp;quot;
fi

# git_list.txt から URL を一行ずつ読み込み、pull 操作を実行
while read -r url; do
  if [ -d &amp;quot;$url&amp;quot; ]; then
    cd &amp;quot;$url&amp;quot; || continue
    git pull
    cd ..
    echo &amp;quot;Pull $url が完了しました！&amp;quot;
    echo &amp;quot;========================================&amp;quot;
  else
    echo &amp;quot;ディレクトリ $url は存在しません。スキップします。&amp;quot;
  fi
done &amp;lt; &amp;quot;git_list.txt&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;windows&#34;&gt;Windows
&lt;/h2&gt;&lt;p&gt;新しいファイルを作成する：batch_pull.bat&lt;/p&gt;
&lt;h2 id=&#34;windows-1&#34;&gt;Windows
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-bat&#34;&gt;@echo off
chcp 65001 &amp;gt; nul
rem スクリプトの存在するディレクトリへ移動
cd /d &amp;quot;%~dp0&amp;quot;

rem git_list.txt が存在するか確認
if not exist &amp;quot;git_list.txt&amp;quot; (
  echo git_list.txt ファイルが見つかりません！ git 仓库 URL を作成し、追加してください。
  exit /b 1
) else (
  echo ============ git 仓库リストファイルが検出されました =========
)

rem git_list.txt 内の URL を一行ずつ読み込み、pull 操作を実行
for /f %%i in (git_list.txt) do (
  if exist &amp;quot;%%i&amp;quot; (
    pushd &amp;quot;%%i&amp;quot;
    git pull
    popd
    echo %%i の Pull が完了しました！
    echo ========================================
  ) else (
    echo ディレクトリ %%i は存在しません。スキップします。
  )
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;過去の遺留問題&#34;&gt;過去の遺留問題
&lt;/h3&gt;&lt;p&gt;再装システム後に発生した &lt;code&gt;git&lt;/code&gt; フォルダの権限ファイルに関する問題を解消します：&lt;strong&gt;致命的なエラー「unsafe repository (&amp;rsquo;/home/repon&amp;rsquo; is owned by someone else)」&lt;/strong&gt;
オンライン上の推奨される解決策は、主に &lt;code&gt;stack overflow&lt;/code&gt; から提供されています。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;リポジトリディレクトリに信頼を追加: &lt;code&gt;git config --global --add safe.directory /home/repon&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.gitconfig&lt;/code&gt; ファイルを手動で修正し、ディレクトリへの信頼を指定&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[safe]
    directory = /home/repon
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記の方法により、リポジトリの更新は正常になりましたが、毎回 &lt;code&gt;git pull&lt;/code&gt; を実行する際にコンソールに多数の警告メッセージが表示され、所有者に関するエラーを示唆しています。&lt;/p&gt;
&lt;h3 id=&#34;デスクトップ環境のシステム再インストール&#34;&gt;デスクトップ環境のシステム再インストール
&lt;/h3&gt;&lt;p&gt;長らくシステムを再インストールしていなかったマシンで、システムイメージ内のゴミファイルが爆発的に増加し、手動で再インストールせざるを得なくなった。空き時間を利用してシステムを再構築し、再びこの権限の問題に遭遇した。以前のスクリプトは動作せず、修正した権限が不完全だった。&lt;/p&gt;
&lt;p&gt;新しい解決策を採用し、&lt;code&gt;*&lt;/code&gt;を追加することで &lt;code&gt;git&lt;/code&gt; がすべてのディレクトリを自動的に信頼するように設定した。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global --add safe.directory &amp;quot;*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;これはユーザー権限の問題なのか、それとも皆さんが Windows 平台に慣れていないのかは不明である。Windows には &lt;code&gt;chown&lt;/code&gt; のようなコマンドが存在し、フォルダの所有者を変更できる。もちろん、ディレクトリが少ない場合は手動で所有者も変更可能だが、このワークステーションにはドメイン情報が付加されており、会社によってデプロイされたドメインに異常があるか、あるいはローカルシステム設定に異常があるのか、ユーザーリスト内でログインに使用するユーザーが見つからないという問題が発生した。最終的にはコマンドラインから問題を解決した。&lt;/p&gt;
&lt;h3 id=&#34;デスクトップ再インストールシステム&#34;&gt;デスクトップ再インストールシステム
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;# 現在のユーザー名を取得
$currentUserName = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name

# PowerShell の文字エンコーディングを UTF-8 に設定
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8

# 所有者のルートディレクトリパスを変更する
$rootDirectory = &amp;quot;G:\workspace&amp;quot;  # 実際のパスに置き換えてください

# ディレクトリを再帰的にトラバースし、ファイルとフォルダの所有者を変更
Get-ChildItem -Path $rootDirectory -Recurse | ForEach-Object {
    $itemPath = $_.FullName
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;### デスクトップのシステム再インストール

# ファイルまたはフォルダを確認する
    if ($_ -is [System.IO.DirectoryInfo]) {
        # フォルダの場合、icacls を使用して所有権を変更する
        $icaclsResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            Write-Host &amp;quot;フォルダ $itemPath の所有者を $currentUserName に変更しました&amp;quot;
        } else {
            Write-Host &amp;quot;フォルダ $itemPath の所有者変更に失敗しました。エラー情報: $icaclsResult&amp;quot;
        }
    } else {
        # ファイルの場合、icacls を使用して所有権を変更する
        $takeownResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;### システムの再インストール（デスクトップ）
$takeownResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
if ($LASTEXITCODE -eq 0) {
    # Write-Host &amp;quot;ファイル $itemPath の所有者を $currentUserName に変更しました&amp;quot;
} else {
    Write-Host &amp;quot;ファイル $itemPath の所有者の変更に失敗しました。エラー情報: $takeownResult&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;デスクトップosの再インストール&#34;&gt;デスクトップOSの再インストール
&lt;/h3&gt;&lt;p&gt;予想外の問題が発生し、スクリプト実行時の出力された中国語の情報が乱れていました。コンソール文字エンコーディングの設定やスクリプトエンコーディングの調整を試みましたが、すべて文字化けしました。おそらく頭がおかしくなっているのでしょう。コントロールパネル - 領域 - 言語設定のベータ機能を有効にし、グローバルにUnicodeエンコーディングを有効にしたところ、スクリプト実行は正常になりました。しかし、いくつかの開発ソフトウェアが正常に動作しませんでした。後で資料を見直したところ、スクリプトファイルのエンコードを&lt;code&gt;gbk&lt;/code&gt;に変更する必要があることがわかりました。&lt;/p&gt;
&lt;h2 id=&#34;资料&#34;&gt;资料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://ganzhixiong.com/p/f1b9f4fc/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ganzhixiong.com/p/f1b9f4fc/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/71901632/fatal-error-unsafe-repository-home-repon-is-owned-by-someone-else&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stackoverflow.com/questions/71901632/fatal-error-unsafe-repository-home-repon-is-owned-by-someone-else&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>いくつかのGitコマンドのまとめ</title>
        <link>https://ttf248.life/ja/p/less-common-git-commands-summary/</link>
        <pubDate>Fri, 17 Feb 2023 10:08:57 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/less-common-git-commands-summary/</guid>
        <description>&lt;p&gt;あまり使わないけれど非常に便利な &lt;code&gt;git&lt;/code&gt; コマンド&lt;/p&gt;
&lt;h3 id=&#34;システムを再インストールした結果windows上のフォルダーの所有権が変更されました&#34;&gt;システムを再インストールした結果、Windows上のフォルダーの所有権が変更されました。
&lt;/h3&gt;&lt;p&gt;新しいバージョンのGitにはセキュリティチェックが追加され、不安全であると警告が表示されるため、操作できなくなりました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global --add safe.directory
git config --global --add safe.directory &amp;quot;*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;ユーザーの新しいコンピューターにアカウントとパスワード情報を保存する&#34;&gt;ユーザーの新しいコンピューターにアカウントとパスワード情報を保存する
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global credential.helper store
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;保存された情報が更新が必要な場合は、まず古い認証情報を削除してください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --system --unset credential.helper
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
    </channel>
</rss>
