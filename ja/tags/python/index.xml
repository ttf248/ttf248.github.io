<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Python on 向叔の手帳</title>
        <link>https://ttf248.life/ja/tags/python/</link>
        <description>Recent content in Python on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Sun, 25 May 2025 14:10:37 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/tags/python/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Python辞書にカスタムオブジェクトを格納する際の参照とdeepcopyの重要性</title>
        <link>https://ttf248.life/ja/p/python-dictionary-custom-objects-reference-vs-deepcopy/</link>
        <pubDate>Fri, 22 Mar 2024 01:08:05 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/python-dictionary-custom-objects-reference-vs-deepcopy/</guid>
        <description>&lt;p&gt;Pythonプログラミングにおいて、辞書は非常に強力なデータ構造であり、キーと値を関連付けて、これらのデータを効率的に検索および操作できます。辞書にカスタムオブジェクトを格納しようとするとき、重要な概念に出くわします。Pythonにおけるオブジェクトの代入は実際には参照による代入であり、オブジェクト自体の深いコピーではありません。つまり、カスタムオブジェクトを辞書に格納すると、辞書に格納されるのはオブジェクトへの参照であり、オブジェクトの新しいコピーではありません。&lt;/p&gt;
&lt;h2 id=&#34;カスタムオブジェクトの保存に関する基本的な例&#34;&gt;カスタムオブジェクトの保存に関する基本的な例
&lt;/h2&gt;&lt;p&gt;仮に、単純な &lt;code&gt;Person&lt;/code&gt; クラスがあるとします。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

# 创建一个 Person 对象
p1 = Person(&amp;quot;Alice&amp;quot;, 30)

# 将对象存储到字典中
people_dict = {}
people_dict[&amp;quot;alice&amp;quot;] = p1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この例では、&lt;code&gt;people_dict&lt;/code&gt; ディクショナリはキーが &lt;code&gt;&amp;quot;alice&amp;quot;&lt;/code&gt; の項目を含み、その値は &lt;code&gt;Person&lt;/code&gt; 型の &lt;code&gt;p1&lt;/code&gt; オブジェクトへの参照です。もし &lt;code&gt;p1&lt;/code&gt; の属性を修正すると:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;p1.age = 31
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;そうすると、辞書を通してこのオブジェクトにアクセスしたとき、その年齢も更新されていることがわかります。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(people_dict[&amp;quot;alice&amp;quot;].age)  # 输出：31
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;辞書に格納されているのは、&lt;code&gt;Person&lt;/code&gt;オブジェクトの独立したコピーではなく、同じメモリのアドレスを指す参照です。&lt;/p&gt;
&lt;h2 id=&#34;深いコピーと浅いコピーの違い&#34;&gt;深いコピーと浅いコピーの違い
&lt;/h2&gt;&lt;p&gt;ネストされたデータ構造やカスタムオブジェクトを扱う場合、この参照動作は予期せぬ結果を引き起こす可能性があります。例えば、カスタムオブジェクトに可変型の属性（リストや別のカスタムオブジェクトなど）が含まれている場合、そのようなオブジェクトを直接辞書に格納し、それを変更すると、辞書を通して取得したオブジェクトに影響が及ぶことがあります。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Address:
    def __init__(self, street, city):
        self.street = street
        self.city = city

class Person:
    def __init__(self, name, age, address):
        self.name = name
        self.age = age
        self.address = address

address = Address(&amp;quot;Main St.&amp;quot;, &amp;quot;Springfield&amp;quot;)
p1 = Person(&amp;quot;Bob&amp;quot;, 40, address)
people_dict[&amp;quot;bob&amp;quot;] = p1

# 修改原始地址对象
address.city = &amp;quot;Shelbyville&amp;quot;

# 字典中的人的地址也变了
print(people_dict[&amp;quot;bob&amp;quot;].address.city)  # 输出：Shelbyville
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解決策：ディープコピー&lt;/p&gt;
&lt;p&gt;このような共有状態がもたらす問題を避けるために、辞書にオブジェクトの完全なコピーを格納し、参照ではなく、というようにすることが必要な場合があります。Python の &lt;code&gt;copy&lt;/code&gt; モジュールにある &lt;code&gt;deepcopy&lt;/code&gt; 関数は、この目的を達成するために使用できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import copy

# 使用深拷贝存储对象
people_dict[&amp;quot;bob_deepcopy&amp;quot;] = copy.deepcopy(p1)

# 此时即使修改原始地址对象，深拷贝的对象不会受影响
address.city = &amp;quot;Capital City&amp;quot;
print(people_dict[&amp;quot;bob&amp;quot;].address.city)  # 输出：Capital City
print(people_dict[&amp;quot;bob_deepcopy&amp;quot;].address.city)  # 输出：Shelbyville
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要するに、Pythonで辞書を使ってカスタムオブジェクトを保存する場合、デフォルトではオブジェクトへの参照が格納されることに注意してください。独立した状態を維持する必要がある場合は、共有による予期せぬデータ変更を防ぐために&lt;code&gt;deepcopy&lt;/code&gt;を使用して深いコピーを作成してください。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Stable Diffusion - ゼロからのインストールにおける愛憎劇</title>
        <link>https://ttf248.life/ja/p/stable-diffusion-zero-install-saga/</link>
        <pubDate>Thu, 13 Apr 2023 00:23:54 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/stable-diffusion-zero-install-saga/</guid>
        <description>&lt;p&gt;国内の資料は、基本的に&lt;strong&gt;秋葉&lt;/strong&gt;大佬の一括デプロイパッケージを推奨している。&lt;code&gt;Python&lt;/code&gt;ベースのオープンソースプロジェクトなので、デプロイもそれほど複雑ではないはずだ。ゼロからやってみるか。&lt;/p&gt;
&lt;p&gt;AI生成画像の作成に手間取って、わざとグラフィックカードを交換した。エントリーモデルの&lt;code&gt;3060 12g&lt;/code&gt;です。7年間活躍してきた&lt;code&gt;960&lt;/code&gt;は退役しました。&lt;/p&gt;
&lt;p&gt;コアの&lt;code&gt;pytorch cuda&lt;/code&gt;インストールですが、以前Pythonゲームアシスタントスクリプトを書く際にローカルにインストールしたことがありますが、やはり問題が発生し、&lt;code&gt;cuda&lt;/code&gt;のライセンス認証がどうしてもできません。&lt;/p&gt;
&lt;h2 id=&#34;保留&#34;&gt;保留
&lt;/h2&gt;&lt;p&gt;記事の構成を再計画し、まずpytorchについて、バージョン対応関係、そしてバージョン確認方法を紹介する。
ローカル環境で仮想環境を新たに作成し、PyTorch をデプロイするにはどうすればよいか。
翻訳資料、ゼロから始めるStable Diffusion &lt;a class=&#34;link&#34; href=&#34;https://stable-diffusion-art.com/install-windows/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stable-diffusion-art.com/install-windows/&lt;/a&gt;
資料を整理する&lt;/p&gt;
&lt;h2 id=&#34;手順&#34;&gt;手順
&lt;/h2&gt;&lt;p&gt;中国語で検索しても、ステップバイステップのインストールチュートリアルが見つからないかもしれません。Googleで英語で検索すると、最初から始めるチュートリアルがたくさんあります。必要なものを説明した後、gitをインストールし、pythonをインストールする必要があることが説明されています。それから、リポジトリをダウンロードして、スクリプトをダブルクリックするだけで終わりました。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/AUTOMATIC1111/stable-diffusion-webui&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;詳細な使い方とFAQについては、&lt;code&gt;issues&lt;/code&gt; を参照し、&lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki&lt;/a&gt; をご確認ください。&lt;/p&gt;
&lt;p&gt;なぜか誰もこの倉庫が何のためにあるのか説明してくれない。実は名前からでもわかるように、これはインターフェースコンソールで、使う私たちをより便利にするものだ。実際、インストール時に公式の倉庫の内容をダウンロードし、実際の&lt;code&gt;SD&lt;/code&gt;コードを入手する。&lt;/p&gt;
&lt;p&gt;倉庫でも、インストール起動スクリプトを作成しました。現在のフォルダに &lt;code&gt;Python&lt;/code&gt; 仮想環境があるかどうかを自動的に認識し、もしあれば、そのパスの &lt;code&gt;python&lt;/code&gt; をデフォルトで使用します。&lt;/p&gt;
&lt;p&gt;もし完全に初心者の方でしたら、こちらをご覧ください。&lt;a class=&#34;link&#34; href=&#34;https://stable-diffusion-art.com/install-windows/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stable-diffusion-art.com/install-windows/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;pytorch&#34;&gt;pytorch
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://pytorch.org/get-started/locally/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pytorch.org/get-started/locally/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;こここそが今日私が言いたかったことです。まず、彼らの手順に従ってスクリプトを直接起動しないでください。Pythonはrequirementファイルで依存ライブラリをインストールします。これは些細な問題です。重要なのは、グラフィックカードのドライバーバージョンとPyTorchが対応していること。これについても多くの人が説明していますので、ネットで検索すればすぐに見つかります。&lt;/p&gt;
&lt;p&gt;参照：&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/weixin_40660408/article/details/129896700&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/weixin_40660408/article/details/129896700&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;仮想環境を作成し、空の仮想環境にして、そこで直接公式サイトでスクリプトを実行して、PyTorchをインストールします。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python -c &amp;quot;import torch; print(torch.version.cuda)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python -c &amp;quot;import torch; print(torch.__version__, torch.cuda.is_available())&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記の2つのスクリプトは、インストールする必要があるCUDAのバージョンを確認したり、インストールが成功したかどうかを確認したりできます。&lt;/p&gt;
&lt;p&gt;ここでは、ごちゃごちゃした操作は推奨しません。まずは公式ページのロジックに従ってコピーしてきて、そのままインストールしてください。pipでインストールしようとすると、うまくいかないか、CUDAが有効にならない可能性が高いです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重要：フォルダのパスに余計なものが含まれていると、PyTorchが正常に使えない可能性があります。&lt;/p&gt;
&lt;p&gt;何度も中間でやり直しを重ね、公式のインストールファイルをダウンロードして手動でインストールすることも試しました。2.0版にアップデートしようとしたのですが、公式ドキュメントには2.0の方が速度が速いと書いてあったからです。ただ、以前からあまり使っていなかったので、Pythonのバージョンやこれが影響しているのかもわかりません。その間、公式のマニュアルも確認し、3.8のバージョンを使うことを推奨していました。そこで少し競合が発生しました。以前はワンクリックインストールパッケージを使っていて、そこには3.10のバージョンが入っていました。最終的には、最初からすべてやり直しで、まず新しいフォルダを作成し、仮想環境を作成して、torchが正常にインストールされていることを確認しました。&lt;/p&gt;
&lt;p&gt;インストールした仮想環境を、Web UIのフォルダの中に移動してください。その後でスクリプトのインストールを開始すれば、他の依存関係の問題はほとんどなくなります。&lt;/p&gt;
&lt;p&gt;移動後に、実行する必要があります：python -m pip install &amp;ndash;upgrade &amp;ndash;force-reinstall pip で、pip を修正してください。&lt;/p&gt;
&lt;p&gt;見た目はなんだかよくわからないかもしれませんが、この場所でかなり色々試しました。私のtorchが正しく認識されなかったからです。すべての干渉要因を排除するために、まずこれをインストールしてから、他の依存関係ライブラリをインストールすることにしました。&lt;/p&gt;
&lt;h2 id=&#34;xformers&#34;&gt;Xformers
&lt;/h2&gt;&lt;p&gt;推奨します。画像生成を高速化し、既存の占有量を減らすことができます。副作用は、同じパラメータグループを使用した場合、&lt;strong&gt;生成される画像の安定性がそれほど高くない&lt;/strong&gt;ことです。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Xformers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;stable-diffusion-webui:Xformers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://huggingface.co/docs/diffusers/optimization/xformers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;huggingface optimization&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Optimization Ratio&lt;/th&gt;
&lt;th&gt;Time taken&lt;/th&gt;
&lt;th&gt;Torch active/reserved&lt;/th&gt;
&lt;th&gt;Sys VRAM&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;100.00%&lt;/td&gt;
&lt;td&gt;2m 57.03s&lt;/td&gt;
&lt;td&gt;7440/10058 MiB&lt;/td&gt;
&lt;td&gt;12288/12288 MiB (100.0%)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;51.02%&lt;/td&gt;
&lt;td&gt;1m 29.21s&lt;/td&gt;
&lt;td&gt;4547/7164 MiB&lt;/td&gt;
&lt;td&gt;9298/12288 MiB (75.67%)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;((masterpiece)),((best quality)),((high detial)),((realistic,))
Industrial age city, deep canyons in the middle,chinese architectural streets,bazaars, Bridges, (rainy days:1.2), (steampunk:0.8), chinese architecture
Negative prompt: nsfw,((cowboy)),(((pubic))), ((((pubic_hair))))sketch, duplicate, ugly, huge eyes, text, logo, monochrome, worst face, (bad and mutated hands:1.3), (worst quality:2.0), (low quality:2.0), (blurry:2.0), horror, geometry, bad_prompt, (bad hands), (missing fingers), multiple limbs, bad anatomy, (interlocked fingers:1.2), Ugly Fingers, (extra digit and hands and fingers and legs and arms:1.4), crown braid, ((2girl)), (deformed fingers:1.2), (long fingers:1.2),succubus wings,horn,succubus horn,succubus hairstyle, (bad-artist-anime), bad-artist, bad hand, borrowed character, text focus, watermark, sample watermark, character watermark, lofter username, photo date watermark, movie poster, magazine cover, journal, cover, cover page, doujin cover, album cover, manga cover, brand name imitation, EasyNegative,Tights, silk stockings,shorts
Steps: 35, Sampler: DPM adaptive, CFG scale: 5.5, Seed: 2223996555, Size: 1088x1088, Model hash: 543bcbc212, Model: base_Anything-V3.0-pruned, Clip skip: 2, ENSD: 31337
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;あとがき&#34;&gt;あとがき
&lt;/h2&gt;&lt;p&gt;なぜ、あのワンクリックデプロイパッケージをおすすめしないかというと、そのパッケージには作者が独自にカスタマイズした設定が含まれており、公式のものをそのままコピーしたものではないからです。もしあなたが初心者であれば、なぜパラメータを設定する必要があるのか理解できないかもしれませんが、まずは公式のものから使い始めるのが一番です。使用時間が長くなるにつれて、公式のマニュアルをよく読んでみれば、どのパラメータを調整すれば良いか分かるようになるでしょう。&lt;/p&gt;
&lt;h2 id=&#34;グラフィックカードの選択&#34;&gt;グラフィックカードの選択
&lt;/h2&gt;&lt;p&gt;データマイニングが終わった後は、グラフィックカードの価格は以前ほど高くはないので、初心者の方は3060と3060tiの間で迷うことが多いですが、一般的には大容量12GB版の3060が推奨されます。なぜなら、より高解像度の画像を作成できるからです。高い解像度が必要なのは、生成時に解像度を高く設定することで、より鮮明で繊細な画像を生成できるからです。もし小さな画像を作成したいのであれば、8GBのVRAMでも十分です。&lt;/p&gt;
&lt;p&gt;まだ一点、&lt;strong&gt;高精細拡大&lt;/strong&gt;オプションは、ディテールを具体化し、映像のディテールをより豊かにしますが、より多くのビデオメモリも必要となります。&lt;/p&gt;
&lt;p&gt;以下はNVIDIA GeForce GTX 970、GeForce RTX 3060 Ti、GeForce RTX 3060、GeForce RTX 3080およびGeForce RTX 3080 Tiの単精度（FP32）、半精度（FP16）および倍精度（FP64）浮動小数点演算能力の仕様概要表です。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;GPUモデル&lt;/th&gt;
&lt;th&gt;リリース年&lt;/th&gt;
&lt;th&gt;単精度浮動小数点演算性能 (TFLOPS)&lt;/th&gt;
&lt;th&gt;複精度浮動小数点演算性能 (TFLOPS)&lt;/th&gt;
&lt;th&gt;倍精度浮動小数点演算性能 (TFLOPS)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GeForce GTX 970&lt;/td&gt;
&lt;td&gt;2014&lt;/td&gt;
&lt;td&gt;3.49&lt;/td&gt;
&lt;td&gt;87.2&lt;/td&gt;
&lt;td&gt;0.109&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3060 Ti&lt;/td&gt;
&lt;td&gt;2020&lt;/td&gt;
&lt;td&gt;16.2&lt;/td&gt;
&lt;td&gt;32.4&lt;/td&gt;
&lt;td&gt;0.51&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3060&lt;/td&gt;
&lt;td&gt;2021&lt;/td&gt;
&lt;td&gt;12.7&lt;/td&gt;
&lt;td&gt;25.4&lt;/td&gt;
&lt;td&gt;0.39&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3080&lt;/td&gt;
&lt;td&gt;2020&lt;/td&gt;
&lt;td&gt;29.8&lt;/td&gt;
&lt;td&gt;58.9&lt;/td&gt;
&lt;td&gt;0.93&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3080 Ti&lt;/td&gt;
&lt;td&gt;2021&lt;/td&gt;
&lt;td&gt;34.8&lt;/td&gt;
&lt;td&gt;68.7&lt;/td&gt;
&lt;td&gt;1.36&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;引用した、&lt;a class=&#34;link&#34; href=&#34;https://docs.google.com/spreadsheets/d/1Zlv4UFiciSgmJZncCujuXKHwc4BcxbjbSBg71-SdeNk/edit#gid=0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;様々なグラフィックカードの性能テストデータ&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;アップデート&#34;&gt;アップデート
&lt;/h2&gt;&lt;p&gt;半年の間が空いたので、本来ならインストール手順を整理したり、もっと基本的な概念を紹介したかったのですが、結果として、一般の人々がAIで絵を描くというのは、結局のところ、大佬が提供する画像パラメータに基づいて調整したり、既存の画像を元にフォーマットされたリレンダリングを行うだけなのだということが分かりました。&lt;/p&gt;
&lt;p&gt;途中でプロジェクトがあり、AIを使ってミニプログラムのUI素材を描くことを試みましたが、色々手間取った結果、効果は期待通りではありませんでした。むしろ、公式のミニプログラムからリソース画像を引き出した方が良いでしょう。&lt;/p&gt;</description>
        </item>
        <item>
        <title>新しい言語を学ぶ必要があるのはなぜか。</title>
        <link>https://ttf248.life/ja/p/why-learn-a-new-language/</link>
        <pubDate>Thu, 04 Aug 2022 11:27:30 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/why-learn-a-new-language/</guid>
        <description>&lt;p&gt;学校時代から数えても、すでに10年以上前からC++に触れているのに、他のプログラミング言語を学ぶ必要性がどこにあるのだろうか。&lt;/p&gt;
&lt;p&gt;仕事経験：エレガントなモジュール設計の経験は乏しいが、&lt;code&gt;C++&lt;/code&gt; の文法は自由度が高く、他の言語を学ぶことでよりエレガントな設計を書けるようになる。&lt;/p&gt;
&lt;p&gt;ツールを開発するときに、よく使う。&lt;/p&gt;
&lt;p&gt;基盤ライブラリの設計も、ビジネスモジュールの実装も、設計の原則は同じです。&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
