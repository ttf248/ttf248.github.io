<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Python on 向叔の手帳</title>
        <link>https://ttf248.life/ja/tags/python/</link>
        <description>Recent content in Python on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Mon, 02 Jun 2025 19:00:25 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/tags/python/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Python辞書におけるカスタムオブジェクトの保存：参照と深いコピーの重要性</title>
        <link>https://ttf248.life/ja/p/python-dictionary-custom-objects-reference-vs-deepcopy/</link>
        <pubDate>Fri, 22 Mar 2024 01:08:05 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/python-dictionary-custom-objects-reference-vs-deepcopy/</guid>
        <description>&lt;p&gt;Python プログラミングにおいて、辞書は非常に強力なデータ構造であり、キーと値のペアを関連付け、効率的にデータを検索および操作することを可能にします。カスタムオブジェクトを辞書に格納しようとすると、通常、重要な概念である「Python におけるオブジェクトの代入は参照代入であり、オブジェクト自体の深いコピーではない」という点が重要になります。つまり、カスタムオブジェクトを辞書に入れる場合、辞書が格納しているのはそのオブジェクトへの参照であり、オブジェクトの新しいコピーではありません。&lt;/p&gt;
&lt;h2 id=&#34;カスタムオブジェクトの基本的な例&#34;&gt;カスタムオブジェクトの基本的な例
&lt;/h2&gt;&lt;p&gt;以下の簡単な &lt;code&gt;Person&lt;/code&gt; クラスを想定してください:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

# Person オブジェクトを作成
p1 = Person(&amp;quot;Alice&amp;quot;, 30)

# オブジェクトを辞書に保存
people_dict = {}
people_dict[&amp;quot;alice&amp;quot;] = p1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この例では、&lt;code&gt;people_dict&lt;/code&gt; 辞書が &lt;code&gt;&amp;quot;alice&amp;quot;&lt;/code&gt; というキーを持つ項目を含み、その値は &lt;code&gt;Person&lt;/code&gt; 型の &lt;code&gt;p1&lt;/code&gt; オブジェクトへの参照です。  &lt;code&gt;p1&lt;/code&gt; の属性を変更すると:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;p1.age = 31
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;辞書からオブジェクトにアクセスする際に、その年齢も更新されていることに気づきます:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(people_dict[&amp;quot;alice&amp;quot;].age)  # 出力: 31
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これは、辞書が &lt;code&gt;Person&lt;/code&gt; オブジェクトの独立したコピーを保存するのではなく、同じメモリ位置への参照を保持しているためです。&lt;/p&gt;
&lt;h2 id=&#34;深拷贝と浅拷贝の違い&#34;&gt;深拷贝と浅拷贝の違い
&lt;/h2&gt;&lt;p&gt;ネストされたデータ構造やカスタムオブジェクトを扱う場合、このような参照挙動は予期せぬ結果を引き起こす可能性があります。例えば、カスタムオブジェクトが可変型の属性（リストや別のカスタムオブジェクトなど）を含む場合、辞書に直接格納し変更すると、辞書から取得したオブジェクトにも影響が及ぶことがあります。&lt;/p&gt;
&lt;h2 id=&#34;深復元と浅復元の違い&#34;&gt;深復元と浅復元の違い
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Address:
    def __init__(self, street, city):
        self.street = street
        self.city = city

class Person:
    def __init__(self, name, age, address):
        self.name = name
        self.age = age
        self.address = address

address = Address(&amp;quot;Main St.&amp;quot;, &amp;quot;Springfield&amp;quot;)
p1 = Person(&amp;quot;Bob&amp;quot;, 40, address)
people_dict[&amp;quot;bob&amp;quot;] = p1

# 原始アドレスオブジェクトを修正
address.city = &amp;quot;Shelbyville&amp;quot;

# 辞書内の人のアドレスも変更される
print(people_dict[&amp;quot;bob&amp;quot;].address.city)  # 出力：Shelbyville
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解決策：深復元&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;深復元と浅復元の違い-1&#34;&gt;深復元と浅復元の違い
&lt;/h2&gt;&lt;p&gt;共有状態の問題を回避するために、辞書がオブジェクトの完全なコピーを格納するようにする必要がある場合があります（参照ではなく）。Python は &lt;code&gt;copy&lt;/code&gt; モジュール内の &lt;code&gt;deepcopy&lt;/code&gt; 関数を使用してこれを実現します：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import copy

# オブジェクトを深復元で保存
people_dict[&amp;quot;bob_deepcopy&amp;quot;] = copy.deepcopy(p1)

# すると、元のアドレスオブジェクトを変更しても、深復元されたオブジェクトには影響しません
address.city = &amp;quot;Capital City&amp;quot;
print(people_dict[&amp;quot;bob&amp;quot;].address.city)  # 出力：Capital City
print(people_dict[&amp;quot;bob_deepcopy&amp;quot;].address.city)  # 出力：Shelbyville
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要するに、Python で辞書を使用してカスタムオブジェクトを保存する場合は、デフォルトでオブジェクト参照が格納されることに注意してください。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Stable-diffusion - そのインストールにおける喜びと苦しみ (安定拡散 - そのインストールにおける喜びと苦しみ)</title>
        <link>https://ttf248.life/ja/p/stable-diffusion-zero-install-story/</link>
        <pubDate>Thu, 13 Apr 2023 00:23:54 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/stable-diffusion-zero-install-story/</guid>
        <description>&lt;p&gt;国内の資料は、基本的には&lt;strong&gt;秋葉&lt;/strong&gt;さんのワンクリックデプロイパッケージが推奨されています。Pythonをベースにしたオープンソースプロジェクトなので、デプロイもそれほど複雑ではないだろうと考え、ゼロから試してみることにしました。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;AI生成画像に苦労したため、意図的にグラフィックカードを変更し、3060 12GBの入門版を使用しました。7年間の勤務の後、960は名誉な退役を遂げました。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;コアの &lt;code&gt;pytorch cuda&lt;/code&gt; のインストールですが、以前 &lt;code&gt;python&lt;/code&gt; ゲーム補助スクリプトを書いた際にローカルにインストールしたことがありましたが、やはり問題が発生しました。&lt;code&gt;cuda&lt;/code&gt; の暗号化が常に有効にならないという問題です。&lt;/p&gt;
&lt;h2 id=&#34;待処理&#34;&gt;待処理
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;文章構造を再計画し、まず PyTorch を紹介する。バージョン対応関係とバージョン確認方法&lt;/li&gt;
&lt;li&gt;ローカル環境から PyTorch をゼロから新規に作成・デプロイする方法&lt;/li&gt;
&lt;li&gt;翻訳稿を作成する。Stable Diffusion のインストール手順（Windows版）: &lt;a class=&#34;link&#34; href=&#34;https://stable-diffusion-art.com/install-windows/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stable-diffusion-art.com/install-windows/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;参考資料の整理&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ステップ&#34;&gt;ステップ
&lt;/h2&gt;&lt;p&gt;中国語で検索すると、手順を追ったインストール方法が見つかりにくい可能性があります。&lt;code&gt;Google&lt;/code&gt; で英語で検索すると、多くの類似の手順が掲載されています。ゼロから解説されているものもあります。まず、&lt;code&gt;git&lt;/code&gt; のインストールについて説明し、次に &lt;code&gt;python&lt;/code&gt; のインストールについても説明します。その後、リポジトリをダウンロードして、直接スクリプトを実行すれば完了です。
&lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/AUTOMATIC1111/stable-diffusion-webui&lt;/a&gt;
詳細な使用方法や疑問点については、&lt;code&gt;issues&lt;/code&gt; を参照してください。
&lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki&lt;/a&gt;
このリポジトリが何をするものなのかも、なぜか誰も説明していないように思います。名前からして、これはインターフェース制御台であり、より簡単に使えるように設計されていることがわかります。&lt;/p&gt;
&lt;h2 id=&#34;ステップ-1&#34;&gt;ステップ
&lt;/h2&gt;&lt;p&gt;リポジトリでは、同時にインストール・起動スクリプトも作成しています。これにより、現在のフォルダが自動的に認識され、&lt;code&gt;Python&lt;/code&gt;仮想環境が存在するかどうかを確認します。存在する場合は、現在のパスの&lt;code&gt;python&lt;/code&gt;を使用します。&lt;/p&gt;
&lt;p&gt;初心者の方については、&lt;a class=&#34;link&#34; href=&#34;https://stable-diffusion-art.com/install-windows/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stable-diffusion-art.com/install-windows/&lt;/a&gt; を参照してください。&lt;/p&gt;
&lt;h2 id=&#34;pytorch&#34;&gt;PyTorch
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://pytorch.org/get-started/locally/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pytorch.org/get-started/locally/&lt;/a&gt;
ここでは今日私が話したい内容です。まず、彼らの手順をそのまま実行しないでください。Pythonはrequirementファイルを使って依存ライブラリをインストールします。これは小さな問題です。重要なのはあなたのGPUのバージョンとドライバーのバージョンがPyTorchに対応していることです。これは多くの人が関連性について説明していますが、インターネットで検索するとわかります。
参考：&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/weixin_40660408/article/details/129896700&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/weixin_40660408/article/details/129896700&lt;/a&gt;
仮想環境を作成することは、空の仮想環境を作成し、その中で最初に公式のスクリプトを実行してPyTorchをインストールすることです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python -c &amp;quot;import torch; print(torch.version.cuda)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python -c &amp;quot;import torch; print(torch.__version__, torch.cuda.is_available())&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pytorch-1&#34;&gt;PyTorch
&lt;/h2&gt;&lt;p&gt;上記の2つのスクリプトで、必要なCUDAのバージョンを確認したり、インストールが成功したかどうかを確認したりできます。
ここでは、派手な操作は推奨しません。まずは公式ページのロジックに従ってコピーし、そのままインストールするのがおすすめです。直接pipでインストールすると、PyTorchが失敗する可能性や、CUDAがアクティブにならない可能性があります。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; フォルダのパスに不要な文字が含まれていると、PyTorchが使用できない場合がありますのでご注意ください。
インストールを何度も試みたり、公式のインストールファイルをダウンロードして手動でインストールしたりしましたが、2.0バージョンへのアップグレードを試みました。公式ドキュメントでは、2.0は速度が速いと記載されています。 しかし、それまであまり使っていなかったため、Pythonのバージョンやそれが影響するかどうか分からなかった。中には公式のマニュアルも確認し、3.8版を使用することを推奨されていると書かれていた。そこで若干の衝突が発生し、以前はワンクリックインストールパッケージを使っており、その中に3.10版が含まれていた。最終的には、最初から新しいフォルダを作成し、仮想環境を構築して、torchが正しくインストールされていることを確認した。&lt;/p&gt;
&lt;h2 id=&#34;pytorch-2&#34;&gt;PyTorch
&lt;/h2&gt;&lt;p&gt;そして、この仮想環境をWeb UIのフォルダ内に移動します。その状態でスクリプトを実行して依存関係をインストールすると、他の依存関係の問題は解消されるでしょう。
移動後には、&lt;code&gt;python -m pip install --upgrade --force-reinstall pip&lt;/code&gt; を実行し、pipを修復する必要があります。
少し奇妙に見えるかもしれませんが、この場所でかなり時間をかけて試行錯誤しました。なぜなら、常にPyTorchを正しく認識できなかったからです。すべての干渉要因を除外するために、まずPyTorchをインストールしてから、他の依存ライブラリをインストールするという方法に思いついたのです。&lt;/p&gt;
&lt;h2 id=&#34;xformers&#34;&gt;Xformers
&lt;/h2&gt;&lt;p&gt;有効化することを推奨します。画像生成を高速化し、既存の占有量を削減できますが、副作用として、同じパラメータセットで&lt;strong&gt;生成される画像は比較的安定しません&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Xformers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;stable-diffusion-webui:Xformers&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://huggingface.co/docs/diffusers/optimization/xformers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;huggingface optimization&lt;/a&gt;
| 100.00% | 2分57秒33 | 7440MiB / 10058MiB | 12288MiB / 12288MiB (100.0%) |&lt;/p&gt;
&lt;h2 id=&#34;xformers-1&#34;&gt;Xformers
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;最適化比率&lt;/th&gt;
&lt;th&gt;時間&lt;/th&gt;
&lt;th&gt;Torch 活性/予約メモリ&lt;/th&gt;
&lt;th&gt;システムVRAM&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;51.02%&lt;/td&gt;
&lt;td&gt;1分29秒21&lt;/td&gt;
&lt;td&gt;4547/7164 MiB&lt;/td&gt;
&lt;td&gt;9298/12288 MiB (75.67%)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;xformers-2&#34;&gt;Xformers
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;(傑作),(最佳品質),(高詳細),(寫實,)
工業時代城市，中部的深邃峽谷，中國建築風格的街道、集市、橋樑、(雨天:1.2)、(蒸汽龐克:0.8)、中國建築

## Xformers
ネガティブプロンプト: nsfw,((カウボーイ)),(((陰毛))), ((((陰毛の髪の毛))))スケッチ、重複、醜い、大きな目、テキスト、ロゴ、モノクローム、最悪の顔、(悪いおよび変異した手:1.3)、(最悪の品質:2.0)、(低品質:2.0)、(ぼやけ:2.0)、ホラー、ジオメトリ、bad_prompt、(悪い手)、(指が足りない)、複数の肢体、悪い解剖学、(絡み合った指:1.2)、醜い指、(追加の指と手が足と腕:1.4)、王冠の編み込み、((2girl)), (変形した指:1.2)、(長い指:1.2)、魔女の翼、角、魔女

## Xformers
冠髪、((2人娘))、(変形した指:1.2)、(長い指:1.2)、悪魔の翼、角、悪魔の角、悪魔のような髪型、(下手なアニメ風)、下手な絵手、下手な手、借りたキャラクター、テキスト fokus、ウォーターマーク、サンプルウォーターマーク、キャラクターウォーターマーク、Lofterユーザー名、写真の日付ウォーターマーク、映画ポスター、雑誌表紙、ジャーナル、表紙、表紙ページ、同人表紙、アルバム表紙、漫画表紙、ブランド名の模倣、EasyNegative、タイツ、シルクストッキング、ショートパンツ

## Xformers
ステップ数：35、サンプラー：DPM adaptive、CFGスケール：5.5、シード：2223996555、サイズ：1088x1088、モデルハッシュ：543bcbc212、モデル：base_Anything-V3.0-pruned、Clipスキップ：2、ENSD：31337

## 終わりに

なぜデプロイメントパッケージを推奨しなかったのかというと、そのパッケージには作者が個人的にカスタマイズした設定が含まれており、公式のオリジナルのものとは異なっているためです。もしあなたが初心者であれば、なぜそれらのパラメータが最適なのか分からないかもしれません。しかし、使用していくうちに公式のマニュアルを参照することで、どのパラメータを調整する必要があるかを知ることができます。

## グラフィックボードの選択

データ通貨鉱難の後、グラフィックボード（GPU）の価格は相対的に高くなりません。一般的なエントリーレベルのプレイヤーが `3060` と `3060Ti` の間を選ぶ場合、一般的には大容量版である `12G` 以上の `3060` が推奨されます。なぜなら、より高い解像度の画像を生成できるからです。なぜ高解像度が必要なのでしょうか？それは、生成時に解像度を上げることによって、生成される画像がより鮮明で繊細になるためです。もしあなたが小さな画像を生成したいのであれば、`8G` の VRAM でも十分です。

さらに、**超解像（ハイレゾアップスケーリング）** オプションも存在します。これは詳細を強調し、画面のディテールを豊かにすることで、より多くの VRAM が必要になります。 以下は、NVIDIA GeForce GTX 970、GeForce RTX 3060 Ti、GeForce RTX 3060、GeForce RTX 3080およびGeForce RTX 3080 Ti の単精度（FP32）、半精度（FP16）および双精度（FP64）浮動小数点演算能力の仕様集計表です。

| GeForce GTX 970 | 2014 | 3.49 | 87.2 | 0.109 |

## グラフィックボードの選択

| グラフィックボードモデル | リリース年 | 単精度浮動小数点演算能力 (TFLOPS) | 半精度浮動小数点演算能力 (TFLOPS) | 双精度浮動小数点演算能力 (TFLOPS) |
| --- | --- | --- | --- | --- |
| GeForce RTX 3060 Ti | 2020 | 16.2 | 32.4 | 0.51 |

## グラフィックボードの選択

| グラフィックボードモデル | リリース年 | 単精度浮動小数点演算能力 (TFLOPS) | 半精度浮動小数点演算能力 (TFLOPS) | 双精度浮動小数点演算能力 (TFLOPS) |
| --- | --- | --- | --- | --- |
| GeForce RTX 3060 | 2021 | 12.7 | 25.4 | 0.39 |

## グラフィックボードの選択

| グラフィックボードモデル | リリース年 | 単精度浮動小数点演算能力 (TFLOPS) | 半精度浮動小数点演算能力 (TFLOPS) | 双精度浮動小数点演算能力 (TFLOPS) |
| --- | --- | --- | --- | --- |
| GeForce RTX 3080 | 2020 | 29.8 | 58.9 | 0.93 |

## グラフィックボードの選択

| グラフィックボードモデル | リリース年 | 単精度浮動小数点演算能力 (TFLOPS) | 半精度浮動小数点演算能力 (TFLOPS) | 双精度浮動小数点演算能力 (TFLOPS) |
| --- | --- | --- | --- | --- |
| GeForce RTX 3080 Ti | 2021 | 34.8 | 68.7 | 1.36 |

## グラフィックボードの選択
[各種グラフィックボード性能テストデータ](https://docs.google.com/spreadsheets/d/1Zlv4UFiciSgmJZncCujuXKHwc4BcxbjbSBg71-SdeNk/edit#gid=0)

## 更新
半年ごとに、改めてインストール手順を整理したり、基礎概念を解説したりする予定でしたが、一般的にAIイラストを生成する場合、結局はベテランユーザーが提供した画像パラメータを調整したり、既存の画像をフォーマットして再レンダリングしたりすることになるという事実に気づきました。

以前、AIを使ってミニプログラムのUI素材を描画するというプロジェクトがありましたが、半日かけても期待通りの結果が得られず、結局公式のミニプログラムからリソース画像を直接ダウンロードする方が良いという結論に至りました。&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>新しい言語を学ぶべき理由は何ですか？</title>
        <link>https://ttf248.life/ja/p/why-learn-a-new-language/</link>
        <pubDate>Thu, 04 Aug 2022 11:27:30 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/why-learn-a-new-language/</guid>
        <description>&lt;p&gt;学歴から算じると、C++に触れるのは10年以上になる。他のプログラミング言語を学ぶ必要がなぜあるのか？&lt;/p&gt;
&lt;p&gt;職務経験：エレガントなモジュール設計の経験が不足しており、C++の構文は自由度が高いため、他の言語を学習することで、よりエレガントな設計を書くことができるように導かれている。&lt;/p&gt;
&lt;p&gt;いくつかのツールを作成する際に、頻繁に利用される。
低レベルライブラリのデザインやビジネスモジュールの実装など、デザインの原則もすべて理解できている。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
