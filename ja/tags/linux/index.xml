<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Linux on 向叔の手帳</title>
        <link>https://ttf248.life/ja/tags/linux/</link>
        <description>Recent content in Linux on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Wed, 28 May 2025 09:47:38 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/tags/linux/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>atopツールによるLinuxシステム指標の監視：インストール、設定と利用完全ガイド</title>
        <link>https://ttf248.life/ja/p/using-atop-to-monitor-linux-system-metrics-installation-configuration-and-usage-guide/</link>
        <pubDate>Thu, 06 Feb 2025 22:48:55 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/using-atop-to-monitor-linux-system-metrics-installation-configuration-and-usage-guide/</guid>
        <description>&lt;p&gt;Linuxシステム運用において、システムリソースとプロセス状態をリアルタイムかつ包括的に監視することは非常に重要です。atopは強力な監視ツールであり、この目標を容易に達成するのに役立ちます。本稿では、Linuxインスタンスにおけるatop監視ツールのインストール、設定、使用方法について詳細に説明します。&lt;/p&gt;
&lt;h2 id=&#34;一atopツール紹介&#34;&gt;一、atopツール紹介
&lt;/h2&gt;&lt;p&gt;atopは、Linuxシステムのリソースとプロセスを監視するためのツールです。システムおよびプロセスの活動を記録し、すべてのプロセスの実行状況を報告します。CPU、メモリ、ディスク、ネットワークなどのリソース使用状況やプロセス状態に関するデータを収集し、ログファイルとして保存できます。各プロセスについて、CPU使用率、メモリ増加量、ディスク使用率、優先度、ユーザー名、状態、終了コードなどの主要な情報を取得可能です。さらに、atopの設定ファイルを通じて、ログの収集頻度、ログファイルの保存パス、ローテーションポリシーなどのパラメータをカスタマイズできます。&lt;/p&gt;
&lt;h2 id=&#34;二atopツールのインストール&#34;&gt;二、atopツールのインストール
&lt;/h2&gt;&lt;p&gt;様々なLinuxディストリビューションでのatopのインストール方法は若干異なります。以下では、一般的なOSを例として説明します。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Alibaba Cloud Linux 3/2、CentOS 7/8、Fedora、Rocky Linux 9&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;実行インストールコマンド：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;atopサービスを開始します。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;Ubuntu / Debian&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ソフトウェアリポジトリの更新：&lt;/li&gt;
&lt;li&gt;実行インストールコマンド：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;atopサービスを開始します。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;CentOS Stream 9&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ダウンロードしてインストール：&lt;/li&gt;
&lt;li&gt;atopサービスを開始します。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;openSUSE&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;実行インストールコマンド：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;atopサービスを開始します。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;もし上記に挙げられているオペレーティングシステムに利用しているディストリビューションが含まれていない場合は、atop公式サイトでインストール情報を確認してください。&lt;/p&gt;
&lt;h2 id=&#34;監視期間とログ保持期間の設定&#34;&gt;監視期間とログ保持期間の設定
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Alibaba Cloud Linux 3/2、CentOS 7/8およびFedoraシステムでは、atopの構成ファイルは*&lt;strong&gt;；在Ubuntu、Debian和openSUSE系统中，配置文件是&lt;/strong&gt;*です。&lt;/li&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ログファイル記録オプションを制御します。デフォルトは空です。&lt;/li&gt;
&lt;li&gt;監視期間はデフォルトで600秒です。過去のログを追跡する場合は、必要に応じてこの頻度を調整することをお勧めします。&lt;/li&gt;
&lt;li&gt;ログ保持期間、デフォルト28日。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;斜体&lt;/em&gt;&lt;strong&gt;太字&lt;/strong&gt;&lt;em&gt;斜体&lt;/em&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;コマンドを実行して設定ファイルを開きます。&lt;/li&gt;
&lt;li&gt;Alibaba Cloud Linux 3/2、CentOS 7/8、Fedoraシステムにおいて：&lt;/li&gt;
&lt;li&gt;Ubuntu、Debian、openSUSE、CentOS Stream 9、Rocky Linux 9 システムにおいて：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;__INLINE_CODE_0__を選択して編集モードに入り、必要に応じて設定パラメータを調整します。例えば、監視サイクルを30秒に修正し、ログ保持期間を7日に設定し、ログパスはデフォルトのままにします。&lt;/li&gt;
&lt;li&gt;押して、保存して終了します。&lt;/li&gt;
&lt;li&gt;サービスを再起動して設定を有効にする：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;LOGOPTS=&amp;quot;&amp;quot;
LOGINTERVAL=30
LOGGENERATIONS=7
LOGPATH=/var/log/atop 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;四atopツールを使用する&#34;&gt;四、atopツールを使用する
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;対話型コマンドモードでは、以下のよく使用されるコマンドがあります。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;デフォルトの統合出力ビューに戻ります。&lt;/li&gt;
&lt;li&gt;プロセスの一覧を完全なコマンドラインと共に表示します。&lt;/li&gt;
&lt;li&gt;プロセスメモリ使用率で降順にフィルタリングします。&lt;/li&gt;
&lt;li&gt;プロセスディスク使用率で降順にフィルタリングします。&lt;/li&gt;
&lt;li&gt;プロセス資源の総合利用率で降順にフィルタリングします。&lt;/li&gt;
&lt;li&gt;プロセスネットワーク利用率で降順にフィルタリングします。&lt;/li&gt;
&lt;li&gt;次の監視収集ポイントへ移動します。&lt;/li&gt;
&lt;li&gt;前の監視ポイントへ移動します。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;斜体&lt;/em&gt;&lt;strong&gt;太字&lt;/strong&gt;&lt;em&gt;斜体&lt;/em&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ホスト名、情報サンプリングの日付と時刻。&lt;/li&gt;
&lt;li&gt;プロセス全体の実行状況。カーネルモードおよびユーザーモードの実行時間、プロセスの総数、各種状態のプロセス数などを含む。&lt;/li&gt;
&lt;li&gt;CPU全体の利用状況で、各フィールドの数値の合計は__INLINE_CODE_0__（NはCPUコア数）です。カーネルモード、ユーザーモード、割り込み、アイドル、ディスクI/O待ちなどの時間割合を含みます。&lt;/li&gt;
&lt;li&gt;CPU負荷状況：過去1分間、5分間、15分間の実行キューの平均プロセス数、コンテキストスイッチ回数、割り込み発生回数。&lt;/li&gt;
&lt;li&gt;メモリ使用状況。物理メモリ合計、空きメモリ、ページキャッシュメモリ、ファイルキャッシュメモリ、カーネル使用メモリなどを含む。&lt;/li&gt;
&lt;li&gt;スワップ領域の使用状況を示します。割り当てられた合計サイズと利用可能なスワップ領域のサイズが含まれます。&lt;/li&gt;
&lt;li&gt;仮想メモリのページング状況、例えばスワップインおよびスワップアウトされたページ数。&lt;/li&gt;
&lt;li&gt;ディスクの使用状況。各ディスクデバイスごとに1行で、デバイス識別子、ビジー状態の時間割合、読み書きリクエスト数を示します。&lt;/li&gt;
&lt;li&gt;ネットワーク状況を表示し、転送層のTCPとUDP、IP層、および各アクティブポートでの受信・送信パケットサイズを示します。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;5秒ごとにシステム指標を確認する。&lt;/li&gt;
&lt;li&gt;現在時刻の5分後（合計30回、10秒間隔）にシステム指標を確認します。&lt;/li&gt;
&lt;li&gt;現在時刻の10分後のシステム指標を確認し（10回、60秒間隔で）、結果をファイルに書き込む：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;起動後、データはデフォルトで__INLINE_CODE_0__ディレクトリに保存されます。確認する際は、指定した日付のログファイルが存在することを確認してください。存在しない場合、エラーが発生します。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;当日の履歴指標ログを確認：&lt;/li&gt;
&lt;li&gt;昨日のヒストリ指標ログを見る：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;指定日の過去の指標ログを確認します。例：2024年11月06日&lt;/li&gt;
&lt;li&gt;指定された日付から指定時間以降の履歴指標ログを表示します。例：2024年11月06日14:00以降：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;指定された日付範囲内の過去の指標ログを表示します。例えば、2024年11月5日の00:04～00:08：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;現在のシステムにおけるCPU使用率レポートを1分間（12回、5秒間隔で）：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当日指定時間帯のメモリ指標レポートを確認します。例：18:00～18:01。&lt;/li&gt;
&lt;li&gt;指定された日付の指定時間帯におけるメモリ指標レポートを確認します。例えば、2024年11月5日18:00～18:01：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;その他操作&#34;&gt;その他操作
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;毎日atop指標ログファイルを生成したい場合は、以下の手順を実行してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;必要に応じて、監視期間、ログ保持時間、およびログ保存パスを調整できます。&lt;/li&gt;
&lt;li&gt;コマンド実行で、毎日ログローテーション関連サービスの起動設定を行い、サービスを開始します。&lt;/li&gt;
&lt;li&gt;ビジネスがログ処理に複雑な要件を持つ場合、logrotateやカスタムスクリプトを組み合わせてログ管理を実現できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;加载可选的netatop内核模块&lt;/strong&gt;: ネットワーク利用率の監視が必要な場合は、netatopモジュール（atopではデフォルトでインストールされていません）をインストールします。例として、Alibaba Cloud Linux 3システムの場合：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;カーネル開発パッケージのインストールとコンパイルに必要なソフトウェア環境：&lt;code&gt;sudo yum install -y kernel-devel dkms elfutils-libelf-devel&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最新バージョンのnetatopソースコードを、指定のディレクトリにダウンロードします。&lt;/li&gt;
&lt;li&gt;ソースコードを解凍し、ソースディレクトリへ移動します。&lt;/li&gt;
&lt;li&gt;ソースコードからモジュールとデーモンを構築・インストール：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;netatopサービスを開始します。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;atopツールは機能が強力で柔軟性があり、適切なインストール、設定、利用によって、Linuxシステムの稼働状況をより深く理解し、潜在的な問題を早期に発見・解決できます。本稿が皆様のLinuxシステム監視スキル向上の一助となれば幸いです。&lt;/p&gt;
&lt;h2 id=&#34;参考リンク&#34;&gt;参考リンク
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Linuxバックエンドサービスにおける大量の文字列データ処理 - 効率が低い</title>
        <link>https://ttf248.life/ja/p/linux-backend-slow-string-processing/</link>
        <pubDate>Wed, 13 Nov 2024 19:42:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-backend-slow-string-processing/</guid>
        <description>&lt;p&gt;C++開発の過去プロジェクトにおいて、カスタムプロトコルを用いて通信しており、そのプロトコルは二次元配列の形式を採用していました。大量データを処理する際、ログ生成のために配列を走査しシリアライズを行う必要がありましたが、効率が悪く、高負荷時にシステムが顕著にカクつくという問題が発生しました。この件について、ビジネス部門からシステムの動作不良に関するフィードバックがありました。&lt;/p&gt;
&lt;h2 id=&#34;問題特定&#34;&gt;問題特定
&lt;/h2&gt;&lt;p&gt;問題の調査において、まずシステムを性能解析したところ、大量データを処理する際にCPU使用率が顕著に増加し、システム応答時間が長くなっていることが判明しました。システムのログを分析した結果、二次元配列の処理における効率の低いシリアライズ操作が多く存在することがわかり、これがシステムパフォーマンスの低下を引き起こしていると考えられます。&lt;/p&gt;
&lt;p&gt;ツール切り取りサービスの スレッド情報を確認した結果、ログスレッドの大部分の時間文字列の結合処理に費やされていることが判明しました。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ここが今日のポイントです。異なる加算方法によって、効率は大きく異なります。過去のコードでは &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 演算子を使用しており、この方法は頻繁に一時オブジェクトを作成するため、非常に低速です。それが非効率的だと知っていても、どれほど非効率的なのかを理解していないようなものです。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;デモ検証&#34;&gt;デモ検証
&lt;/h2&gt;&lt;p&gt;プロジェクトコードに基づいて、業務ロジックを抽出し、文字列結合の効率問題を検証するための簡単なデモを作成しました。&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 下的 __INLINE_CODE_1__BOLD_6&lt;code&gt;linux&lt;/code&gt; 下的 &lt;strong&gt;INLINE_CODE_3&lt;/strong&gt; 编译器，__INLINE_CODE_4__モードでコンパイル実行し、効率を比較します。&lt;/p&gt;
&lt;h3 id=&#34;主なポイント&#34;&gt;主なポイント
&lt;/h3&gt;&lt;p&gt;プロジェクトでは手法4を使用しており、テストデータを入手する前に、読者はどの方法が最も効率的か、またどれが最も非効率かを考えてみることができます。結果を見たときは、やはり驚きました。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;各フィールドを文字列に連結します。&lt;/li&gt;
&lt;li&gt;流（ストリーム）を使用して各フィールドを結合すると、この方法がより効率的です。特に大量のデータを結合する場合に有効です。&lt;/li&gt;
&lt;li&gt;事前に文字列に十分なメモリを割り当てることで、メモリ再配置のオーバーヘッドを削減し、パフォーマンスが向上します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;太字_1&lt;/strong&gt;インライン&lt;strong&gt;イタリック_3&lt;/strong&gt;、&lt;strong&gt;太字_2&lt;/strong&gt;：文字列を連結するたびに新しい一時的な文字列オブジェクトが作成されるため、特に大規模な連結ではパフォーマンスが低下します。これは、連結ごとに新しいメモリの割り当てとコピーが発生するためです。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参照結果から、プロジェクトは効率が最も悪い方法が選択されたことが分かります。&lt;/p&gt;
&lt;p&gt;さらに、異なるプラットフォームのコンパイラ最適化効率を分析すると、Microsoftの&lt;code&gt;visual studio&lt;/code&gt; 一如既往的优秀，针对字符串的优化效率很高，而 &lt;code&gt;gcc&lt;/code&gt;コンパイラは、この点において若干見劣りする。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;コードを異なるマシンで実行した場合、データの比較は直接的な意味を持たないため、それぞれの結合方法間の差異を比較するのが適切です。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;windows 平台下的 vs2022 编译器

----------------------------------------
Data Generation Time: 0.054 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.053 seconds.
+ ostringstream Data merging took: 0.054 seconds.
+ Pre-reserved Data merging took: 0.045 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 16.108 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;linux 平台下的 gcc8.5 编译器
----------------------------------------
Data Generation Time: 0.108 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.100 seconds.
+ ostringstream Data merging took: 0.083 seconds.
+ Pre-reserved Data merging took: 0.057 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 29.298 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完全コード&#34;&gt;完全コード
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;random&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;iomanip&amp;gt;

typedef std::vector&amp;lt;std::string&amp;gt; DataRow;
typedef std::vector&amp;lt;DataRow&amp;gt; DataGroup;

struct ResponsePackage
{
    std::string ErrorInfo;
    DataRow Head;
    std::string ClientId;
    std::string UUID;
    std::string MsgID;
    std::string SessionID;
    std::string ExtraInfo1;
    std::string ExtraInfo2;
    DataGroup DataBody;
};

// Generate specified length of random string
std::string generateRandomString(size_t length)
{
    const char charset[] = &amp;quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&amp;quot;;
    const size_t max_index = sizeof(charset) - 1;
    std::string random_string;
    random_string.reserve(length);

    std::random_device rd;
    std::mt19937 generator(rd());
    std::uniform_int_distribution&amp;lt;&amp;gt; distribution(0, max_index);

    for (size_t i = 0; i &amp;lt; length; ++i)
    {
        random_string += charset[distribution(generator)];
    }

    return random_string;
}

void create_large_string()
{
    // Example request package with 50 fields
    ResponsePackage requestPackage;

    requestPackage.Head = {
        &amp;quot;Field1&amp;quot;, &amp;quot;Field2&amp;quot;, &amp;quot;Field3&amp;quot;, &amp;quot;Field4&amp;quot;, &amp;quot;Field5&amp;quot;,
        &amp;quot;Field6&amp;quot;, &amp;quot;Field7&amp;quot;, &amp;quot;Field8&amp;quot;, &amp;quot;Field9&amp;quot;, &amp;quot;Field10&amp;quot;,
        &amp;quot;Field11&amp;quot;, &amp;quot;Field12&amp;quot;, &amp;quot;Field13&amp;quot;, &amp;quot;Field14&amp;quot;, &amp;quot;Field15&amp;quot;,
        &amp;quot;Field16&amp;quot;, &amp;quot;Field17&amp;quot;, &amp;quot;Field18&amp;quot;, &amp;quot;Field19&amp;quot;, &amp;quot;Field20&amp;quot;,
        &amp;quot;Field21&amp;quot;, &amp;quot;Field22&amp;quot;, &amp;quot;Field23&amp;quot;, &amp;quot;Field24&amp;quot;, &amp;quot;Field25&amp;quot;,
        &amp;quot;Field26&amp;quot;, &amp;quot;Field27&amp;quot;, &amp;quot;Field28&amp;quot;, &amp;quot;Field29&amp;quot;, &amp;quot;Field30&amp;quot;,
        &amp;quot;Field31&amp;quot;, &amp;quot;Field32&amp;quot;, &amp;quot;Field33&amp;quot;, &amp;quot;Field34&amp;quot;, &amp;quot;Field35&amp;quot;,
        &amp;quot;Field36&amp;quot;, &amp;quot;Field37&amp;quot;, &amp;quot;Field38&amp;quot;, &amp;quot;Field39&amp;quot;, &amp;quot;Field40&amp;quot;,
        &amp;quot;Field41&amp;quot;, &amp;quot;Field42&amp;quot;, &amp;quot;Field43&amp;quot;, &amp;quot;Field44&amp;quot;, &amp;quot;Field45&amp;quot;,
        &amp;quot;Field46&amp;quot;, &amp;quot;Field47&amp;quot;, &amp;quot;Field48&amp;quot;, &amp;quot;Field49&amp;quot;, &amp;quot;Field50&amp;quot;
    };

    requestPackage.ClientId = &amp;quot;ClientID&amp;quot;;
    requestPackage.UUID = &amp;quot;UUID&amp;quot;;
    requestPackage.MsgID = &amp;quot;MsgID&amp;quot;;
    requestPackage.SessionID = &amp;quot;SessionID&amp;quot;;
    requestPackage.ExtraInfo1 = &amp;quot;ExtraInfo1&amp;quot;;
    requestPackage.ExtraInfo2 = &amp;quot;ExtraInfo2&amp;quot;;

    // Start timing for data generation
    auto start_gen = std::chrono::high_resolution_clock::now();

    // Generate 10,000 rows of data, each with 50 fields
    for (size_t i = 0; i &amp;lt; 10000; ++i)
    {
        DataRow dataRow(50, &amp;quot;This is a test string&amp;quot;);
        requestPackage.DataBody.push_back(dataRow);
    }

    // End timing for data generation
    auto end_gen = std::chrono::high_resolution_clock::now();
    std::chrono::duration&amp;lt;double&amp;gt; duration_gen = end_gen - start_gen;

    // Display result generation time
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Generation Time: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_gen.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    // Data merging using different methods
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Performance:\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    {
        // Method 1: Using &#39;+=&#39; string concatenation
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (+=) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 2: Using ostringstream
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::ostringstream bodys;
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::ostringstream body;
            body &amp;lt;&amp;lt; &amp;quot;This is a test string&amp;quot;;
            for (auto&amp;amp; item : vec)
            {
                body &amp;lt;&amp;lt; item &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            }
            bodys &amp;lt;&amp;lt; body.str() &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ ostringstream Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 3: Pre-allocated memory
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys;
        bodys.reserve(1000 * 50 * 20); // Pre-allocate enough memory
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            body.reserve(50 * 20); // Pre-allocate memory for each row
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Pre-reserved Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 4: Using &#39;bodys = bodys + body + &amp;quot;\n&amp;quot;&#39;
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body = body + item + &amp;quot; &amp;quot;; // Note the use of &#39;body = body + item&#39;
            }
            bodys = bodys + body + &amp;quot;\n&amp;quot;; // Again, using &#39;bodys = bodys + body&#39;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (bodys = bodys + body + \&amp;quot;\\n\&amp;quot;) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Complete.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;
}

int main()
{
    try
    {
        create_large_string();
    }
    catch (const std::exception&amp;amp; e)
    {
        std::cerr &amp;lt;&amp;lt; &amp;quot;Caught exception: &amp;quot; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\nProgram finished.\n&amp;quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>GCCバージョンアップによりプログラムがクラッシュ：非標準コードの潜在的な問題</title>
        <link>https://ttf248.life/ja/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</link>
        <pubDate>Sun, 10 Mar 2024 23:19:06 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</guid>
        <description>&lt;p&gt;同一のビジネスコードの場合、プログラムは CentOS 7 環境で正常にコンパイルされ実行されたが、CentOS 8 に切り替えて更新版 GCC でコンパイルするとクラッシュした。問題は &lt;strong&gt;Release 模式&lt;/strong&gt; の場合にのみ発生し、&lt;strong&gt;Debug 模式&lt;/strong&gt; では全く問題なかった。今回初めてこのような事態に遭遇したが、3 日間の調査の結果、ようやく原因を突き止めた。&lt;/p&gt;
&lt;h3 id=&#34;問題特定&#34;&gt;問題特定
&lt;/h3&gt;&lt;p&gt;徹底的な調査の結果、問題の根本原因は &lt;strong&gt;函数缺少返回值&lt;/strong&gt; にありました。リリースモードでは、GCC の新バージョンがより多くの最適化を行うため、元々明示的な戻り値を持たない関数が実行中に予期せぬ動作を起こし、クラッシュを引き起こしました。結論として、&lt;strong&gt;编译器的警告不容忽视，尤其是在老项目中，部分警告可能被无视，但也应当避免屏蔽所有警告&lt;/strong&gt; です。&lt;/p&gt;
&lt;h3 id=&#34;環境説明&#34;&gt;環境説明
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39)
Copyright © 2015 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 8.5.0 20210514 (Red Hat 8.5.0-21)
Copyright (C) 2018 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;クラッシュ現象&#34;&gt;クラッシュ現象
&lt;/h3&gt;&lt;p&gt;プログラムクラッシュのスタックを解析した結果、以下のスタック情報が見られました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[New LWP 1385902]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib64/libthread_db.so.1&amp;quot;.
Core was generated by `./pstack_main`.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007ffe894b4420 in ?? ()
(gdb) bt
#0  0x00007ffe894b4420 in ?? ()
#1  0x00000000004008e9 in main ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このスタックは直感的ではなく、クラッシュした関数のスタック情報が &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; と表示されているため、問題の特定がより複雑になっています。&lt;/p&gt;
&lt;h3 id=&#34;コード例&#34;&gt;コード例
&lt;/h3&gt;&lt;p&gt;問題をより良く理解するために、クラッシュを再現する最小限のコード例を以下に示します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int test() {
    std::cout &amp;lt;&amp;lt; &amp;quot;1&amp;quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    test();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;そのコード内の &lt;code&gt;test()&lt;/code&gt; 函数显然没有显式返回一个值，而它的返回类型是 &lt;code&gt;int&lt;/code&gt;。根据 C++ 规范，当一个函数声明为 &lt;strong&gt;INLINE_CODE_2&lt;/strong&gt; 型では、必ず値を返す必要がある。さもなくば、未定義の動作を引き起こす可能性がある。&lt;/p&gt;
&lt;h3 id=&#34;コンパイル警告&#34;&gt;コンパイル警告
&lt;/h3&gt;&lt;p&gt;プロジェクトにおいて、CMakeスクリプトが多くのコンパイル時の警告を抑制しており、その中には以下の警告が含まれています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/root/pstack/main.cpp: In function ‘int test()’:
/root/pstack/main.cpp:7:1: warning: no return statement in function returning non-void [-Wreturn-type]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この警告は、__INLINE_CODE_0__関数が値を返さないことを示しており、これが問題の根本原因です。高バージョンGCC（例えば8.5.0）は、コードを最適化する際に、このような未定義の振る舞いに対して不安定な最適化を行い、プログラムをクラッシュさせる可能性があります。&lt;/p&gt;
&lt;h3 id=&#34;アセンブリコードの差異&#34;&gt;アセンブリコードの差異
&lt;/h3&gt;&lt;p&gt;GCCコンパイラ最適化の差異を説明するため、異なるバージョンのGCCが生成するアセンブリコードを比較しました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;アセンブリコードは冗長であり、標準出力ストリーム（&lt;code&gt;std::cout&lt;/code&gt;）的处理逻辑。这表明编译器进行了更保守的优化，未对 &lt;code&gt;test()&lt;/code&gt;関数における戻り値の欠落問題など）に対する過剰な最適化が含まれているため、クラッシュを回避できた可能性がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供してください。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新しいGCCでは、より多くの最適化が行われ、コード量が削減されました。しかし、この最適化により、戻り値がない関数の実行時に動作が不安定になり、プログラムがクラッシュする可能性があります。&lt;/p&gt;
&lt;h3 id=&#34;結論&#34;&gt;結論
&lt;/h3&gt;&lt;p&gt;今回の問題の調査を通じて、C++において、&lt;strong&gt;函数返回值必须明确&lt;/strong&gt;（特に__INLINE_CODE_0__ 时，必须提供一个返回值。对于使用较旧版本编译器的项目，升级到新版本的 GCC 时，可能会遇到更多的优化和更严格的警告机制。因此，我们建议在编译时 **関数宣言の場合）、すべての警告を無視するのではなく、選択的に処理することが重要であると深く認識しました。特に、関数戻り値や型の一致など、一般的な問題には注意が必要です。&lt;/p&gt;
&lt;p&gt;最終、&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 関数に返り値を追加することで問題が解決し、プログラムは正常に動作するようになった。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Linuxシステムベンチマークテスト</title>
        <link>https://ttf248.life/ja/p/linux-system-benchmark-test/</link>
        <pubDate>Tue, 09 Jan 2024 10:56:23 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-system-benchmark-test/</guid>
        <description>&lt;p&gt;Windows プラットフォームには魯大师（ユーエンターマスター）というベンチマークソフトがあり、データが正確とは言えないまでも、ある程度の参考になる。もちろん他のプロフェッショナルなベンチマークソフトもあるが、Linux システムでは特によく合うものがなかなか見つからない。&lt;/p&gt;
&lt;p&gt;Sysbenchは、CPU、メモリ、ファイルI/O、スレッドパフォーマンスなどをテストできる多機能なベンチマークツールです。様々なパフォーマンステストタスクにsysbenchを使用できます。&lt;/p&gt;
&lt;p&gt;テスト用にちょうど3台の機械があります：メカニストミニローカルホスト、アリババクラウド開発雲サーバー、ファーウェイクラウド開発サーバー。&lt;/p&gt;
&lt;h2 id=&#34;sysbenchのインストール&#34;&gt;Sysbenchのインストール
&lt;/h2&gt;&lt;p&gt;ほとんどのLinuxディストリビューションでは、パッケージマネージャーを使用してSysbenchをインストールできます。例えば、CentOS 8では、以下のコマンドでインストールできます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo dnf install sysbench
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sysbench-の使用例&#34;&gt;Sysbench の使用例
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CPU性能テスト：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;メモリ読み出し性能テスト：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;テストファイルI/O性能：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysbench --test=fileio --file-test-mode=rndrw prepare
sysbench --test=fileio --file-test-mode=rndrw run
sysbench --test=fileio --file-test-mode=rndrw cleanup
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;マルチスレッドパフォーマンスのテスト: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;MySQLデータベースのパフォーマンスをテストする（データベースの最大接続数を調整する必要があります）。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword --oltp-table-size=1000000 prepare
sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword --max-time=60 --oltp-read-only=off --oltp-test-mode=complex --max-requests=0 run
sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword cleanup
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;データレポートパオフェン&#34;&gt;データレポート（パオフェン）
&lt;/h2&gt;&lt;meta http-equiv=&#34;Content-Type&#34; content=&#34;text/html; charset=utf-8&#34;&gt;&lt;link type=&#34;text/css&#34; rel=&#34;stylesheet&#34; href=&#34;resources/sheet.css&#34; &gt;
&lt;style type=&#34;text/css&#34;&gt;.ritz .waffle a { color: inherit; }.ritz .waffle .s0{background-color:#ffffff;text-align:left;color:#000000;font-family:&#39;Arial&#39;;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}&lt;/style&gt;&lt;div class=&#34;ritz grid-container&#34; dir=&#34;ltr&#34;&gt;&lt;table class=&#34;waffle&#34; cellspacing=&#34;0&#34; cellpadding=&#34;0&#34;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th class=&#34;row-header freezebar-origin-ltr&#34;&gt;&lt;/th&gt;&lt;th id=&#34;0C0&#34; style=&#34;width:100px;&#34; class=&#34;column-headers-background&#34;&gt;A&lt;/th&gt;&lt;th id=&#34;0C1&#34; style=&#34;width:421px;&#34; class=&#34;column-headers-background&#34;&gt;B&lt;/th&gt;&lt;th id=&#34;0C2&#34; style=&#34;width:398px;&#34; class=&#34;column-headers-background&#34;&gt;C&lt;/th&gt;&lt;th id=&#34;0C3&#34; style=&#34;width:422px;&#34; class=&#34;column-headers-background&#34;&gt;D&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R0&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;1&lt;/div&gt;&lt;/th&gt;&lt;td&gt;&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;本地机械师&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;阿里云&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;华为云&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R1&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;2&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;系统配置&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;System Information&lt;br&gt;  Operating System              Ubuntu 23.04&lt;br&gt;  Kernel                        Linux 6.2.0-36-generic x86_64&lt;br&gt;  Model                         Machenike Machenike DT Computer&lt;br&gt;  Motherboard                   Machenike Machenike DT Computer&lt;br&gt;  BIOS                          American Megatrends International, LLC.&lt;br&gt;DB19V012&lt;br&gt;&lt;br&gt;CPU Information&lt;br&gt;  Name                          Intel Core i7-12650H&lt;br&gt;  Topology                      1 Processor, 10 Cores, 16 Threads&lt;br&gt;  Identifier                    GenuineIntel Family 6 Model 154 Stepping 3&lt;br&gt;  Base Frequency                4.60 GHz&lt;br&gt;  L1 Instruction Cache          32.0 KB x 8&lt;br&gt;  L1 Data Cache                 48.0 KB x 8&lt;br&gt;  L2 Cache                      1.25 MB x 2&lt;br&gt;  L3 Cache                      24.0 MB&lt;br&gt;&lt;br&gt;Memory Information&lt;br&gt;  Size                          62.6 GB&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;System Information&lt;br&gt;  Operating System              CentOS Stream 8&lt;br&gt;  Kernel                        Linux 4.18.0-513.el8.x86_64 x86_64&lt;br&gt;  Model                         Alibaba Cloud Alibaba Cloud ECS&lt;br&gt;  Motherboard                   N/A&lt;br&gt;  BIOS                          SeaBIOS 449e491&lt;br&gt;&lt;br&gt;CPU Information&lt;br&gt;  Name                          Intel(R) Xeon(R) Platinum&lt;br&gt;  Topology                      1 Processor, 1 Core, 2 Threads&lt;br&gt;  Identifier                    GenuineIntel Family 6 Model 85 Stepping 4&lt;br&gt;  Base Frequency                2.50 GHz&lt;br&gt;  L1 Instruction Cache          32.0 KB&lt;br&gt;  L1 Data Cache                 32.0 KB&lt;br&gt;  L2 Cache                      1.00 MB&lt;br&gt;  L3 Cache                      33.0 MB&lt;br&gt;&lt;br&gt;Memory Information&lt;br&gt;  Size                          1.65 GB&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;System Information&lt;br&gt;  Operating System              Ubuntu 22.04.1 LTS&lt;br&gt;  Kernel                        Linux 5.15.0-60-generic x86_64&lt;br&gt;  Model                         OpenStack Foundation OpenStack Nova&lt;br&gt;  Motherboard                   N/A&lt;br&gt;  BIOS                          SeaBIOS&lt;br&gt;rel-1.10.2-0-g5f4c7b1-20181220_000000-szxrtosci10000&lt;br&gt;&lt;br&gt;CPU Information&lt;br&gt;  Name                          Intel(R) Xeon(R) Gold 6278C CPU @ 2.60GHz&lt;br&gt;  Topology                      1 Processor, 1 Core, 2 Threads&lt;br&gt;  Identifier                    GenuineIntel Family 6 Model 85 Stepping 7&lt;br&gt;  Base Frequency                2.60 GHz&lt;br&gt;  L1 Instruction Cache          32.0 KB&lt;br&gt;  L1 Data Cache                 32.0 KB&lt;br&gt;  L2 Cache                      1.00 MB&lt;br&gt;  L3 Cache                      35.8 MB&lt;br&gt;&lt;br&gt;Memory Information&lt;br&gt;  Size                          3.64 GB&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R2&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;3&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;CPU&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Prime numbers limit: 10000&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;CPU speed:&lt;br&gt;    events per second:  4032.48&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0004s&lt;br&gt;    total number of events:              40330&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.25&lt;br&gt;         avg:                                    0.25&lt;br&gt;         max:                                    0.73&lt;br&gt;         95th percentile:                        0.25&lt;br&gt;         sum:                                 9997.55&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           40330.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9975/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Prime numbers limit: 10000&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;CPU speed:&lt;br&gt;    events per second:  1062.51&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0008s&lt;br&gt;    total number of events:              10628&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.91&lt;br&gt;         avg:                                    0.94&lt;br&gt;         max:                                   22.84&lt;br&gt;         95th percentile:                        1.06&lt;br&gt;         sum:                                 9993.46&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           10628.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9935/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Prime numbers limit: 10000&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;CPU speed:&lt;br&gt;    events per second:  1125.56&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0005s&lt;br&gt;    total number of events:              11258&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.86&lt;br&gt;         avg:                                    0.89&lt;br&gt;         max:                                    1.70&lt;br&gt;         95th percentile:                        0.99&lt;br&gt;         sum:                                 9995.40&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           11258.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9954/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R3&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;4&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;内存&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Running memory speed test with the following options:&lt;br&gt;  block size: 1KiB&lt;br&gt;  total size: 102400MiB&lt;br&gt;  operation: write&lt;br&gt;  scope: global&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;Total operations: 101993199 (10198146.52 per second)&lt;br&gt;&lt;br&gt;99602.73 MiB transferred (9959.13 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0001s&lt;br&gt;    total number of events:              101993199&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.00&lt;br&gt;         max:                                    0.03&lt;br&gt;         95th percentile:                        0.00&lt;br&gt;         sum:                                 4059.50&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           101993199.0000/0.00&lt;br&gt;    execution time (avg/stddev):   4.0595/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Running memory speed test with the following options:&lt;br&gt;  block size: 1KiB&lt;br&gt;  total size: 102400MiB&lt;br&gt;  operation: write&lt;br&gt;  scope: global&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;Total operations: 48418803 (4841004.79 per second)&lt;br&gt;&lt;br&gt;47283.99 MiB transferred (4727.54 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0001s&lt;br&gt;    total number of events:              48418803&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.00&lt;br&gt;         max:                                   25.26&lt;br&gt;         95th percentile:                        0.00&lt;br&gt;         sum:                                 4578.95&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           48418803.0000/0.00&lt;br&gt;    execution time (avg/stddev):   4.5789/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Running memory speed test with the following options:&lt;br&gt;  block size: 1KiB&lt;br&gt;  total size: 102400MiB&lt;br&gt;  operation: write&lt;br&gt;  scope: global&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;Total operations: 57056904 (5704765.11 per second)&lt;br&gt;&lt;br&gt;55719.63 MiB transferred (5571.06 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0001s&lt;br&gt;    total number of events:              57056904&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.00&lt;br&gt;         max:                                    0.06&lt;br&gt;         95th percentile:                        0.00&lt;br&gt;         sum:                                 4556.06&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           57056904.0000/0.00&lt;br&gt;    execution time (avg/stddev):   4.5561/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R4&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;5&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;硬盘&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;2147483648 bytes written in 1.81 seconds (1129.59 MiB/sec).&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Extra file open flags: (none)&lt;br&gt;128 files, 16MiB each&lt;br&gt;2GiB total file size&lt;br&gt;Block size 16KiB&lt;br&gt;Number of IO requests: 0&lt;br&gt;Read/Write ratio for combined random IO test: 1.50&lt;br&gt;Periodic FSYNC enabled, calling fsync() each 100 requests.&lt;br&gt;Calling fsync() at the end of test, Enabled.&lt;br&gt;Using synchronous I/O mode&lt;br&gt;Doing random r/w test&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;File operations:&lt;br&gt;    reads/s:                      3373.41&lt;br&gt;    writes/s:                     2248.94&lt;br&gt;    fsyncs/s:                     7201.80&lt;br&gt;&lt;br&gt;Throughput:&lt;br&gt;    read, MiB/s:                  52.71&lt;br&gt;    written, MiB/s:               35.14&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0127s&lt;br&gt;    total number of events:              128288&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.08&lt;br&gt;         max:                                    5.14&lt;br&gt;         95th percentile:                        0.34&lt;br&gt;         sum:                                 9977.78&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           128288.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9778/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;2147483648 bytes written in 19.29 seconds (106.16 MiB/sec).&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Extra file open flags: (none)&lt;br&gt;128 files, 16MiB each&lt;br&gt;2GiB total file size&lt;br&gt;Block size 16KiB&lt;br&gt;Number of IO requests: 0&lt;br&gt;Read/Write ratio for combined random IO test: 1.50&lt;br&gt;Periodic FSYNC enabled, calling fsync() each 100 requests.&lt;br&gt;Calling fsync() at the end of test, Enabled.&lt;br&gt;Using synchronous I/O mode&lt;br&gt;Doing random r/w test&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;File operations:&lt;br&gt;    reads/s:                      1593.12&lt;br&gt;    writes/s:                     1062.08&lt;br&gt;    fsyncs/s:                     3406.64&lt;br&gt;&lt;br&gt;Throughput:&lt;br&gt;    read, MiB/s:                  24.89&lt;br&gt;    written, MiB/s:               16.60&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0164s&lt;br&gt;    total number of events:              60600&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.16&lt;br&gt;         max:                                   31.32&lt;br&gt;         95th percentile:                        0.54&lt;br&gt;         sum:                                 9956.30&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           60600.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9563/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;2147483648 bytes written in 18.29 seconds (111.98 MiB/sec).&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Extra file open flags: (none)&lt;br&gt;128 files, 16MiB each&lt;br&gt;2GiB total file size&lt;br&gt;Block size 16KiB&lt;br&gt;Number of IO requests: 0&lt;br&gt;Read/Write ratio for combined random IO test: 1.50&lt;br&gt;Periodic FSYNC enabled, calling fsync() each 100 requests.&lt;br&gt;Calling fsync() at the end of test, Enabled.&lt;br&gt;Using synchronous I/O mode&lt;br&gt;Doing random r/w test&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;File operations:&lt;br&gt;    reads/s:                      1665.88&lt;br&gt;    writes/s:                     1110.59&lt;br&gt;    fsyncs/s:                     3563.77&lt;br&gt;&lt;br&gt;Throughput:&lt;br&gt;    read, MiB/s:                  26.03&lt;br&gt;    written, MiB/s:               17.35&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0112s&lt;br&gt;    total number of events:              63355&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.16&lt;br&gt;         max:                                  205.01&lt;br&gt;         95th percentile:                        0.78&lt;br&gt;         sum:                                 9972.64&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           63355.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9726/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R5&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;6&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;多线程&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 4&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0002s&lt;br&gt;    total number of events:              197956&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.16&lt;br&gt;         avg:                                    0.20&lt;br&gt;         max:                                    0.34&lt;br&gt;         95th percentile:                        0.21&lt;br&gt;         sum:                                39970.47&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           49489.0000/5.70&lt;br&gt;    execution time (avg/stddev):   9.9926/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 4&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0174s&lt;br&gt;    total number of events:              18360&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.57&lt;br&gt;         avg:                                    2.18&lt;br&gt;         max:                                   32.77&lt;br&gt;         95th percentile:                        2.61&lt;br&gt;         sum:                                40050.41&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           4590.0000/94.36&lt;br&gt;    execution time (avg/stddev):   10.0126/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 4&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0004s&lt;br&gt;    total number of events:              28536&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.23&lt;br&gt;         avg:                                    1.40&lt;br&gt;         max:                                    3.56&lt;br&gt;         95th percentile:                        1.47&lt;br&gt;         sum:                                39975.16&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           7134.0000/39.87&lt;br&gt;    execution time (avg/stddev):   9.9938/0.01&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;h2 id=&#34;追記&#34;&gt;追記
&lt;/h2&gt;&lt;p&gt;完全にレイアウトできず、表形式にできない場合、表示効果が著しく悪くなる。カスタムテーマによるページ幅の制限があり、ページの構成を調整し、幅をパーセント指定に変更した。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;シンプルな方法としては、TablesGeneratorのようなオンラインツールでHTMLテーブルを生成する（複雑な内容は向いていない）。&lt;/li&gt;
&lt;li&gt;またはGoogleドキュメントで作成し、HTMLとしてダウンロードしてブログにコピーする。（簡単で最終的に採用）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;設定でunsafeオプションが有効になっていることを確認し、ページごとに幅を設定してください。&lt;/p&gt;
&lt;p&gt;Hugoにおいて、ページごとに幅を設定できます。これは、ページのFront Matterにカスタムパラメータを追加することで実現可能です。以下はその例です。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Markdown ページの前マター（通常はファイルの先頭部分）に、例えば &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; のようなカスタムパラメータを追加してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;---
title: &amp;quot;我的页面&amp;quot;
date: 2024-01-09
custom_width: &amp;quot;800px&amp;quot;  # 设置宽度为 800 像素
---

正文内容...
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;あなたのHugoテーマで、対応するシングルページテンプレートファイルを見つけてください（例：&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;シングルページテンプレートにおいて、Front Matterに &lt;code&gt;custom_width&lt;/code&gt;BOLD_2&lt;code&gt;div&lt;/code&gt; が存在するか確認してください。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{{ define &amp;quot;main&amp;quot; }}
  &amp;lt;div style=&amp;quot;max-width: {{ with .Params.custom_width }}{{ . }}{{ else }}100%{{ end }}; margin: 0 auto;&amp;quot;&amp;gt;
    {{ .Content }}
  &amp;lt;/div&amp;gt;
{{ end }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この例では、インラインスタイル（__INLINE_CODE_0__属性）为 __INLINE_CODE_1__BOLD_7&lt;code&gt;max-width&lt;/code&gt;BOLD_8&lt;code&gt;custom_width&lt;/code&gt; 参数时，宽度默认为100%。&lt;code&gt;margin: 0 auto;&lt;/code&gt; 用于将 &lt;strong&gt;INLINE_CODE_5&lt;/strong&gt;）の要素を中心に配置しています。&lt;/p&gt;
&lt;p&gt;実際の応用では、テーマ構造やCSSスタイルの詳細に応じて、上記の例を調整する必要があるかもしれません。スタイルを調整する際は、テーマの一貫性と可読性を保つようにしてください。&lt;/p&gt;
&lt;p&gt;有効化されたテーマが若干異なるため、サイトのカスタム設定の&lt;code&gt;CSS&lt;/code&gt;構成を最終調整しました。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Dockerに関するいくつかのこと</title>
        <link>https://ttf248.life/ja/p/docker-two-three-things/</link>
        <pubDate>Thu, 21 Jan 2021 09:26:07 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/docker-two-three-things/</guid>
        <description>&lt;p&gt;長年業務で接したのが、一部内容が適用できない__操作系统，如果是E_CODE_0ユーザーばかりです。&lt;/p&gt;
&lt;p&gt;設置部分は、清華大学の手册を参照してください：&lt;a class=&#34;link&#34; href=&#34;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;設置&#34;&gt;設置
&lt;/h2&gt;&lt;p&gt;不明な力により、国内にDockerをインストールする際は、クラウドプロバイダーが提供するリポジトリを使用することを推奨します。ここでは、&lt;strong&gt;阿里云&lt;/strong&gt; を推奨します。&lt;/p&gt;
&lt;h3 id=&#34;倉庫ソースアドレス設定&#34;&gt;倉庫ソースアドレス設定
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install yum-utils device-mapper-persistent-data lvm2 &amp;amp;&amp;amp; \
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;最新バージョン&#34;&gt;最新バージョン
&lt;/h3&gt;&lt;p&gt;Dockerはよく使用されるバックグラウンドサービスなので、起動時に自動的に開始するように設定することを推奨します。このコマンドはCentOS 7に適用されます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum install -y docker-ce docker-ce-cli containerd.io &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;部署指定バージョン&#34;&gt;部署指定バージョン
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;斜体_9&lt;/strong&gt;&lt;strong&gt;太字_5&lt;/strong&gt;&lt;strong&gt;斜体_10&lt;/strong&gt;&lt;strong&gt;太字_6&lt;/strong&gt;&lt;strong&gt;斜体_11&lt;/strong&gt;&lt;strong&gt;太字_7&lt;/strong&gt;&lt;strong&gt;斜体_12&lt;/strong&gt;&lt;strong&gt;太字_8&lt;/strong&gt;&lt;strong&gt;斜体_13&lt;/strong&gt;**&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum list docker-ce --showduplicates | sort -r
sudo yum install -y docker-ce-18.09.2-3.el7 docker-ce-cli-18.09.2-3.el7 containerd.io-18.09.2-3.el7 &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;通常ユーザーへのdocker権限追加&#34;&gt;通常ユーザーへのDocker権限追加
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo usermod -aG docker ${USER}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;アンインストール&#34;&gt;アンインストール
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum erase -y docker-ce docker-ce-cli containerd.io
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;日常利用&#34;&gt;日常利用
&lt;/h2&gt;&lt;h3 id=&#34;ミラーキャッシュ&#34;&gt;ミラーキャッシュ
&lt;/h3&gt;&lt;p&gt;依然未知な神秘的な力が存在し、イメージのダウンロード速度が遅いという問題がある。この状況下で、国内のクラウドベンダーが多くの加速サービスを提供してきたため、引き続き&lt;strong&gt;阿里云&lt;/strong&gt;をおすすめする。&lt;/p&gt;
&lt;p&gt;加速されたアドレスは、ご自身でアカウントを登録してAliyunから入手してください。このサービスは無料で、Aliyunは無料のイメージ構築サービスも提供しています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt; /etc/docker/daemon.json &amp;lt;&amp;lt;EOF
{
  &amp;quot;registry-mirrors&amp;quot;: [
    &amp;quot;https://docker.nju.edu.cn&amp;quot;,
    &amp;quot;https://mirror.baidubce.com&amp;quot;,
    &amp;quot;https://docker.m.daocloud.io&amp;quot;,
    &amp;quot;https://docker.mirrors.sjtug.sjtu.edu.cn&amp;quot;
  ]
}
EOF
systemctl daemon-reload &amp;amp;&amp;amp; \
systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;強く推奨のコントロールパネル&#34;&gt;強く推奨のコントロールパネル
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker volume create portainer_data &amp;amp;&amp;amp; \
docker run -d --name=portainer --restart=always -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:2.20.3-alpine
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;よく使うイメージプルコレクション&#34;&gt;よく使うイメージプルコレクション
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker pull rancher/rancher:stable &amp;amp;&amp;amp; docker pull  portainer/portainer-ce:2.0.1 &amp;amp;&amp;amp; \
docker pull centos:7 &amp;amp;&amp;amp; docker pull ubuntu:20.04 &amp;amp;&amp;amp; docker pull ubuntu:18.04 &amp;amp;&amp;amp; \
docker pull redis:5 &amp;amp;&amp;amp; docker pull redis:6 &amp;amp;&amp;amp; \
docker pull alpine:3.11 &amp;amp;&amp;amp; docker pull busybox:1.32 &amp;amp;&amp;amp; \
docker pull rabbitmq:3.7-management &amp;amp;&amp;amp; \
docker pull mariadb:10.2 &amp;amp;&amp;amp; \
docker pull nginx:1.18 &amp;amp;&amp;amp; docker pull nginx:1.19 &amp;amp;&amp;amp; \
docker pull mysql:5.6 &amp;amp;&amp;amp; docker pull mysql:8 &amp;amp;&amp;amp; \
docker pull elasticsearch:6.8.11 &amp;amp;&amp;amp; docker pull logstash:6.8.11 &amp;amp;&amp;amp; docker pull kibana:6.8.11 &amp;amp;&amp;amp; \
docker pull zookeeper:3.4 &amp;amp;&amp;amp; \
docker pull influxdb:1.7 &amp;amp;&amp;amp; docker pull grafana/grafana:7.3.1 &amp;amp;&amp;amp; \
docker pull percona:8 &amp;amp;&amp;amp; docker pull percona:5.6 &amp;amp;&amp;amp; \
docker pull cloverzrg/frps-docker:0.34.3 &amp;amp;&amp;amp; docker pull cloverzrg/frpc-docker:0.34.3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;よく使うコマンドの組み合わせ&#34;&gt;よく使うコマンドの組み合わせ
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/engine/reference/commandline/docker/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.docker.com/engine/reference/commandline/docker/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;コンテナの実行状態を確認し、__INLINE_CODE_0__パラメータを追加して詳細なコンテナ情報を確認します。この際、イメージ情報は無視します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker ps --format &amp;quot;{{.Names}}: {{.Ports}}: {{.Size}}&amp;quot;
#portainer: 0.0.0.0:8000-&amp;gt;8000/tcp, 0.0.0.0:9000-&amp;gt;9000/tcp: 0B (virtual 172MB)
#influxdb: 0.0.0.0:8086-&amp;gt;8086/tcp: 183B (virtual 311MB)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;全コンテナを停止&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker stop $(docker ps -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全イメージを一括削除&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dokcer rmi $(docker images -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;イメージエクスポート&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; &amp;gt; -o XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;イメージのエクスポートと圧縮&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; | gzip &amp;gt; XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;イメージのインポート&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker load -i XXX.tar
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Linux上にJMeterテスト環境を構築する</title>
        <link>https://ttf248.life/ja/p/linux-setup-jmeter-testing-environment/</link>
        <pubDate>Tue, 22 Dec 2020 10:12:50 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-setup-jmeter-testing-environment/</guid>
        <description>&lt;p&gt;著者はハードウェアに強い興味を持ち、Jmeterを用いて負荷テストを実施。CentOS 7上にJmeter、InfluxDB、Grafanaをデプロイした過程を記録。Jmeterのインストールとコマンド使用方法、InfluxDBの特徴とDockerインストール方法、そしてGrafanaの簡単なデプロイと設定について解説。高性能プログラムのパターンに関する経験と参考文献もまとめた。&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景
&lt;/h2&gt;&lt;p&gt;データ表示に加えて、Webパネルを別途用意するメリットは何か？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;考えたことが全て思い込みで、試してみないと分からない。
Don&amp;rsquo;t use GUI mode for load testing! only for Test creation and Test debuggin.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;公式的にはコマンドラインでレポートを取得し、GUIで表示する方法にはデータの誤差があるとのことです。JMeterの理解は深くないですが、せめてバージョン__INLINE_CODE_0__のコンソールパネルを試してみる理由が少なくとも見つかりました。&lt;/p&gt;
&lt;p&gt;オープンソース中国の投稿ですが、主要コンポーネントのデプロイは友好的ではありません。必要なファイルも公众号でフォローしないとダウンロードできないため、次世代として当然__INLIN_ITALIC_1____に置き換えました。結局のところ、自分のサーバーが国内にあること、クロスボーダーのソースアドレスへのアクセス速度が遅いことが問題です。少なくともミラーサービスは、アリババクラウドに無料のアクセラレーションがあります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker&lt;/code&gt;のインストールについては、ここでは詳述しません。以前の記事を参照してください。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;今後の内容は大きく分けて、基本的なテスト環境構築と、各コンポーネントの簡単な説明です。&lt;/p&gt;
&lt;h2 id=&#34;jmeter&#34;&gt;Jmeter
&lt;/h2&gt;&lt;p&gt;Apache JMeterは、Apache Software Foundationが開発したJavaベースの負荷テストツールです。ソフトウェアに負荷をかけるために使用され、当初はWebアプリケーションのテスト用に設計されましたが、その後他のテスト分野にも拡張されています。静的なリソースや動的なリソースなど、さまざまなものをテストできます。例えば、静的ファイル、Javaマイクロサービス、CGIスクリプト、Javaオブジェクト、データベース、FTPサーバーなどです。JMeterを使用すると、サーバー、ネットワーク、またはオブジェクトに巨大な負荷をシミュレートし、さまざまなプレッシャーカテゴリー下での強度をテストし、全体的なパフォーマンスを分析できます。また、アサーションを含むスクリプトを作成することで、アプリケーションの機能/回帰テストを行い、プログラムが期待される結果を返すことを検証できます。最大限の柔軟性を実現するため、JMeterは正規表現を使用してアサーションを作成できます。&lt;/p&gt;
&lt;p&gt;Apache JMeterは、静的なリソースと動的なリソース（ファイル、サーブレット、Perlスクリプト、Javaオブジェクト、データベースおよびクエリ、FTPサーバーなど）のパフォーマンスをテストするために使用できます。サーバー、ネットワーク、またはオブジェクトに過剰な負荷をかけて強度をテストしたり、さまざまなプレッシャーの種類下での全体的なパフォーマンスを分析したりすることができます。パフォーマンスのグラフ解析や、高並行負荷テストを行うことも可能です。&lt;/p&gt;
&lt;h3 id=&#34;jmeter-centos7&#34;&gt;JMeter CentOS7
&lt;/h3&gt;&lt;p&gt;インストールパッケージ&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install java-1.8.0-openjdk -y &amp;amp;&amp;amp; \
wget https://mirrors.bfsu.edu.cn/apache//jmeter/binaries/apache-jmeter-5.4.tgz &amp;amp;&amp;amp; tar -xf apache-jmeter-5.4.tgz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;環境変数を設定する&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export JMETER_HOME=$HOME/jmeter/apache-jmeter-5.4
export PATH=$JMETER_HOME/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;jmeter-コマンド&#34;&gt;JMeter コマンド
&lt;/h3&gt;&lt;p&gt;最終、&lt;code&gt;Grafana&lt;/code&gt;控制面板，可以不输入&lt;code&gt;-l&lt;/code&gt;参数，在__INLINE_CODE_2__コントロール台のデータを確認&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;jmeter -n -t /tmp/order-500-10s.jmx -l /tmp/jmeter-order-report-20200109/order-500-10s.jtl
# 一般不用测试结果和测试报告，简化命令
jmeter -n -t /tmp/order-500-10s.jmx
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;influxdb&#34;&gt;InfluxDB
&lt;/h2&gt;&lt;p&gt;InfluxDBは、外部依存なしでGo言語で記述されたオープンソースの分散型時系列データベースです。現在では、主にDevOpsモニタリングデータ、アプリMetrics、IoTセンサーデータ、リアルタイム解析データなど、大量のタイムスタンプデータを保存するために使用されています。&lt;/p&gt;
&lt;h3 id=&#34;influxdbの特徴&#34;&gt;InfluxDBの特徴
&lt;/h3&gt;&lt;p&gt;InfluxDBの特徴は、以下の9点に集約できます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;構造（パターン）なし：任意の数の列が可能です。&lt;/li&gt;
&lt;li&gt;メトリクスの保存期間を設定できます。&lt;/li&gt;
&lt;li&gt;統計を支援するため、時間に関連する関数（最小値、最大値、合計、件数、平均、中央値など）に対応。&lt;/li&gt;
&lt;li&gt;サポートするストレージポリシー：データの削除・変更に利用可能。（InfluxDBはデータ削除・変更の方法を提供していません。）&lt;/li&gt;
&lt;li&gt;継続クエリのサポート：データベース内で自動的にスケジュールされた一連の文であり、ストレージポリシーと組み合わせることでInfluxDBのシステムリソース使用量を削減できます。&lt;/li&gt;
&lt;li&gt;ネイティブなHTTPサポート、内蔵HTTP API。&lt;/li&gt;
&lt;li&gt;SQLに類似した構文をサポート。&lt;/li&gt;
&lt;li&gt;クラスタ内のデータレプリカ数を設定可能。&lt;/li&gt;
&lt;li&gt;定期サンプリングデータをサポートし、別のmeasurementに書き込むことで、細分化されたデータストレージを可能にする。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;influxdb-docker-インストール&#34;&gt;InfluxDB Docker インストール
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir influxdb &amp;amp;&amp;amp; cd influxdb &amp;amp;&amp;amp; \
docker run -p 8086:8086 -d --name influxdb -v $PWD:/var/lib/influxdb influxdb:1.7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;コンテナに入り、コマンドを実行し、手動でデータベースを作成する。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;root@bce0a55bbc72:/# influx
Connected to http://localhost:8086 version 1.7.10
InfluxDB shell version: 1.7.10
&amp;gt; 交互面板执行命令
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;influxdb-データベースとユーザーの作成&#34;&gt;InfluxDB データベースとユーザーの作成
&lt;/h3&gt;&lt;p&gt;データベース作成：create database jmeter_t2
データベース表示：
データベースを切り替えます：use jmeter_t2
ユーザーを作成：パスワード&amp;rsquo;admin&amp;rsquo;でユーザー&amp;quot;admin&amp;quot;を全権限で作成
ユーザー表示&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; show users
user  admin
----  -----
admin true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ユーザー権限が表示されれば、データベースの準備は完了です。&lt;/p&gt;
&lt;h2 id=&#34;grafana&#34;&gt;Grafana
&lt;/h2&gt;&lt;p&gt;テストケース作成中に、グラフ表示はそれほど必須ではないことがわかった。インターフェースの__INLINE_CODE_0__データはコマンドライン実行で確認できるし、主にプログラム内部の処理時間を把握したいだけだ。&lt;/p&gt;
&lt;p&gt;簡単な展開&lt;/p&gt;
&lt;p&gt;コンソールはタグによるテスト結果のフィルタリングをサポートしており、通常は &lt;code&gt;InfluxDB&lt;/code&gt;データベースの設定だけで済みます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アプリケーション名&lt;/li&gt;
&lt;li&gt;テストケース名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/linux-setup-jmeter-testing-environment/Snipaste_2021-03-09_19-44-22.png&#34;
	width=&#34;861&#34;
	height=&#34;357&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;grafana&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;241&#34;
		data-flex-basis=&#34;578px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -d --name=grafana -p 3000:3000 grafana/grafana:7.3.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ウェブ版では、サンプラー間隔により計算の**&lt;em&gt;強調&lt;/em&gt;** &lt;strong&gt;太字&lt;/strong&gt; &lt;em&gt;斜体&lt;/em&gt; &lt;strong&gt;リンク&lt;/strong&gt; が発生します。&lt;/p&gt;
&lt;p&gt;資料には、__INLINE_CODE_0__をカスタマイズする方法も記載されています。&lt;/p&gt;
&lt;h2 id=&#34;追記&#34;&gt;追記
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;高性能なプログラムパターンは必ずしもone loop threadであり、ロック、キューへの入出力は不要なパフォーマンス損失を引き起こす。&lt;/li&gt;
&lt;li&gt;コアビジネスロジックの処理時間が、他のコードの導入にかかる時間よりも長い。効率を効果的に高めるには並行処理が不可欠であり、コア処理時間が十分短い場合にのみ、他のコードの導入は慎重に行うべきである。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@jasonli.studio/to-install-apache-jmeter-in-centos7-294bc72a97ba&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;To install Apache JMeter in CentOS7&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Red Hat と CentOS のライフサイクル</title>
        <link>https://ttf248.life/ja/p/redhat-centos-lifecycle/</link>
        <pubDate>Tue, 21 Jul 2020 20:02:35 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/redhat-centos-lifecycle/</guid>
        <description>&lt;p&gt;オンライン生産環境のオペレーティングシステムとしては、Red HatとCentOSが主流です。両システムのライフサイクルに関する公式ウェブサイトへのリンクを記録し、CentOS 8からCentOS 8 Streamへの移行経験を共有しています。&lt;/p&gt;
&lt;h2 id=&#34;まえがき&#34;&gt;まえがき
&lt;/h2&gt;&lt;p&gt;オンライン生産環境のオペレーティングシステムとして、現在国内ではRed HatとCentOSが主流です。数年前にはRed Hat 6のサポート終了がありましたが、この2つのシステムのライフサイクルに関する公式サイトへのリンクを記録しておきます。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://access.redhat.com/support/policy/updates/errata&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Red Hat Enterprise Linux Life Cycle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;申し訳ありませんが、翻訳する中国語のテキストが提供されていません。テキストを提供していただければ、日本語に翻訳します。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Red Hat Enterprise Linux（RHEL）とCentOSは、エンタープライズサーバーオペレーティングシステムの主要な選択肢です。RHELは安定したサポートとアップデートサイクルを提供し、企業向けアプリケーションに適しています。CentOSはRHELのコミュニティ版であり、同様の機能と安定性を提供しますが、公式サポートはありません。&lt;/p&gt;
&lt;h2 id=&#34;追い続き&#34;&gt;追い続き
&lt;/h2&gt;&lt;p&gt;この記事を公開した時、2年後にアップデートすることになるとは思ってもみませんでした。先日、普段使っている仮想マシンをCentOS 8からCentOS 8 Streamにアップグレードしました。本番環境での選択については言及を控えたいのですが、ローカル環境では最新バージョンを追求しています。&lt;/p&gt;
&lt;p&gt;CentOS 8 Streamは、ローリングリリース版であり、従来のCentOSよりも速いアップデートと新機能を提供するため、開発およびテスト環境に適しています。&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
