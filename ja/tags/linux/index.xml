<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Linux on 向叔の手帳</title>
        <link>https://ttf248.life/ja/tags/linux/</link>
        <description>Recent content in Linux on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Mon, 02 Jun 2025 19:00:25 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/tags/linux/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>atopツールでLinuxシステム指標を監視する：インストール、設定、および使用方法の完全ガイド</title>
        <link>https://ttf248.life/ja/p/atop-linux-system-monitoring-guide/</link>
        <pubDate>Thu, 06 Feb 2025 22:48:55 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/atop-linux-system-monitoring-guide/</guid>
        <description>&lt;p&gt;Linuxシステム運用において、リアルタイムかつ包括的にシステムリソースとプロセス状態を監視することは非常に重要です。atopは強力なモニタリングツールとして、この目標を簡単に達成するのに役立ちます。本稿では、Linuxインスタンスでatopモニタリングツールをインストール、設定、使用する方法について詳細に説明します。&lt;/p&gt;
&lt;h2 id=&#34;一atopツールの紹介&#34;&gt;一、atopツールの紹介
&lt;/h2&gt;&lt;p&gt;atopは、Linuxシステムの資源とプロセスを監視するために専門的に設計されたツールです。システムおよびプロセスの活動を記録し、すべてのプロセスの実行状況を報告します。このツールが収集するデータには、CPU、メモリ、ディスク、ネットワークなどのリソース使用量、およびプロセス状態が含まれます。さらに、データをログファイル形式でディスクに保存することも可能です。各プロセスについて、CPU使用率、メモリ増加量、ディスク使用量、優先度、ユーザー名、ステータス、および終了コードなど、重要な情報を取得できます。加えて、atopの設定ファイルを通じて、ログ収集頻度、ログファイル保存パス、ローテーションポリシーなどのパラメータをカスタマイズすることも可能です。&lt;/p&gt;
&lt;h2 id=&#34;二atopツールのインストール&#34;&gt;二、atopツールのインストール
&lt;/h2&gt;&lt;p&gt;異なるLinuxディストリビューションでのatopのインストール方法は若干異なります。以下に一般的なオペレーティングシステムを例としてご紹介します。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Alibaba Cloud Linux 3/2、CentOS 7/8、Fedora、Rocky Linux 9&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;インストールコマンドを実行: &lt;code&gt;sudo yum install -y atop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;atopサービスを開始: &lt;code&gt;sudo systemctl start atop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ubuntu / Debian&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;パッケージリストを更新: &lt;code&gt;sudo apt update&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;インストールコマンドを実行: &lt;code&gt;sudo apt install -y atop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;atopサービスを開始: &lt;code&gt;sudo systemctl start atop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CentOS Stream 9&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;ダウンロードしてインストール: &lt;code&gt;sudo wget https://www.atoptool.nl/download/atop-2.11.0-1.el9.x86_64.rpm &amp;amp;&amp;amp; sudo rpm -i atop-2.11.0-1.el9.x86_64.rpm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;atopサービスを開始: &lt;code&gt;sudo systemctl start atop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二atopツールのインストール-1&#34;&gt;二、atopツールのインストール
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;openSUSE&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;インストールコマンドを実行: &lt;code&gt;sudo zypper install -y atop atop-daemon&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;atopサービスを起動: &lt;code&gt;sudo systemctl start atop&lt;/code&gt;
もし上記で挙げたディストリビューションに含まれない場合は、atop公式ウェブサイトでインストール情報を参照してください。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-モニタリング周期とログ保持期間の設定&#34;&gt;3. モニタリング周期とログ保持期間の設定
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;設定ファイル位置:&lt;/strong&gt; Alibaba Cloud Linux 3/2、CentOS 7/8 および Fedora システムでは、atop の設定ファイルは &lt;code&gt;/etc/sysconfig/atop&lt;/code&gt; にあります。Ubuntu、Debian および openSUSE システムでは、設定ファイルは &lt;code&gt;/etc/default/atop&lt;/code&gt; にあります。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;デフォルト設定パラメータの説明&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LOGOPTS&lt;/code&gt;: 日志ファイルの記録オプションを制御するために使用され、デフォルトでは空です。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LOGINTERVAL&lt;/code&gt;: モニタリング周期で、デフォルトは 600 秒です。過去のログ追跡の問題を解決するためには、実際の要件に応じて調整することをお勧めします。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LOGGENERATIONS&lt;/code&gt;: ログ保持期間で、デフォルトは 28 日です。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LOGPATH&lt;/code&gt;: 日志ファイルの保存パスで、デフォルトは &lt;code&gt;/var/log/atop&lt;/code&gt; です。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;iii-モニタリング周期の設定とログ保持期間&#34;&gt;III. モニタリング周期の設定とログ保持期間
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;設定手順&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;コマンドを実行して構成ファイルを開きます：
&lt;ul&gt;
&lt;li&gt;Alibaba Cloud Linux 3/2、CentOS 7/8、Fedora システムの場合: &lt;code&gt;sudo vim /etc/sysconfig/atop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Ubuntu、Debian、openSUSE、CentOS Stream 9、Rocky Linux 9 システムの場合: &lt;code&gt;sudo vim /etc/default/atop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt; キーを押して編集モードに入り、必要に応じて設定パラメータを調整します。例えば、モニタリング周期を30秒に、ログ保持期間を7日間、ログパスをデフォルトのまま変更するなど。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Esc&lt;/code&gt; キーを押して &lt;code&gt;:wq&lt;/code&gt; と入力し、保存して編集モードから退出します。&lt;/li&gt;
&lt;li&gt;atop サービスを再起動して設定を有効にします: &lt;code&gt;sudo systemctl restart atop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;LOGOPTS=&amp;quot;&amp;quot;
LOGINTERVAL=30
LOGGENERATIONS=7
LOGPATH=/var/log/atop
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;四atopツールの使用&#34;&gt;四、atopツールの使用
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;常用コマンドの紹介&lt;/strong&gt;: インタラクティブコマンドモード下では、以下のコマンドがよく使われます。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g&lt;/code&gt;: デフォルトの総合出力ビューに戻ります。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c&lt;/code&gt;: プロセスの完全なコマンドラインを表示します。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m&lt;/code&gt;: メモリ使用率でプロセスを降順にソートします。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d&lt;/code&gt;: ディスク使用率でプロセスを降順にソートします。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt;: 総合的なリソース使用率でプロセスを降順にソートします。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt;: ネットワーク使用率でプロセスを降順にソートします。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt;: 次のモニタリング収集点へジャンプします。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt;: 前のモニタリング収集点へジャンプします。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt;: 時間点を指定します（形式: YYYYMMDDhhmm）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四atop-ツールを使用&#34;&gt;四、atop ツールを使用
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;リソース監視フィールドの意味解説&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ATOP&lt;/strong&gt;: ホスト名、情報サンプリングの日時。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PRC&lt;/strong&gt;: プロセスの全体的な実行状況（カーネルモードとユーザモードの実行時間、プロセス総数、異なる状態のプロセスの数など）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPU&lt;/strong&gt;: CPU全体の利用状況。各フィールドの数字を合計した結果が &lt;code&gt;N*100%&lt;/code&gt; (NはCPUコア数) であり、カーネルモード、ユーザモード、割り込み、アイドル、ディスクI/O待ちなどの時間比例を含みます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPL&lt;/strong&gt;: CPU負荷状況。過去1分、5分、および15分間の実行キュー内の平均プロセス数、コンテキストスイッチ回数、割り込み発生回数など。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MEM&lt;/strong&gt;: メモリの使用状況。物理メモリ総量、空きメモリ、ページキャッシュメモリ、ファイルキャッシュメモリ、カーネル占有メモリなどを含みます。 - &lt;strong&gt;SWP:&lt;/strong&gt; 交换領域の使用状況（交換区の総量と空き交換領域のサイズを含む）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PAG:&lt;/strong&gt; 仮想メモリのページング状況（入ったページ数と出たページ数）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DSK:&lt;/strong&gt; ディスクの使用状況。各ディスクデバイスに対応する列があり、デバイス識別子、繁忙状態の時間比例、読み書きリクエストの数を表示します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NET:&lt;/strong&gt; ネットワークの状態。TCPおよびUDPのトランスポート層、IP層、および各アクティブなネットワークインターフェースでの受信および送信パケットサイズを表示します。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四atopツールの使用-1&#34;&gt;四、atopツールの使用
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;リアルタイムシステム指標の確認&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;5秒ごとにシステム指標を確認：&lt;code&gt;atop 5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;現在時刻から5分間（合計30回、10秒間隔）のシステム指標を確認：&lt;code&gt;atop -M 10 30&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;現在時刻から10分間（10回、60秒間隔）のシステム指標を収集し、結果をファイルに書き出す：&lt;code&gt;atop -M 60 10 &amp;gt; /log/atop.mem&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;履歴指標ログの確認&lt;/strong&gt;：atop起動後、記録された内容はデフォルトで&lt;code&gt;/var/log/atop&lt;/code&gt;ディレクトリに保存されます。確認する際は、日付を指定したログファイルが存在することを確認してください。存在しない場合、エラーが発生します。 - その日の履歴指標ログの確認: &lt;code&gt;atop -r&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前日の履歴指標ログの確認: &lt;code&gt;atop -r y&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定日内の履歴指標ログの確認 (例: 2024年11月6日): &lt;code&gt;atop -r 20241106&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定日から指定時間までの履歴指標ログの確認 (例: 2024年11月6日14:00から): &lt;code&gt;atop -r 20241106 -b 14:00&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定日期間と指定時間の履歴指標ログの確認 (例: 2024年11月5日00:04から00:08まで): &lt;code&gt;atop -r 20241105 -b 00:04 -e 00:08&lt;/code&gt; ## 四、atopツールの使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;リアルタイムシステム指標の確認&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;5秒ごとにシステム指標を確認：&lt;code&gt;atop 5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;現在時刻から5分間（合計30回、10秒間隔）のシステム指標を確認：&lt;code&gt;atop -M 10 30&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;現在時刻から10分間（10回、60秒間隔）のシステム指標を収集し、結果をファイルに書き出す：&lt;code&gt;atop -M 60 10 &amp;gt; /log/atop.mem&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;履歴指標ログの確認&lt;/strong&gt;：atop起動後、記録された内容はデフォルトで&lt;code&gt;/var/log/atop&lt;/code&gt;ディレクトリに保存されます。確認する際は、日付を指定したログファイルが存在することを確認してください。存在しない場合、エラーが発生します。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四atopツールの使用-2&#34;&gt;四、atopツールの使用
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;システムアクティビティレポートの確認&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;現在のシステムにおける1分間（12回、5秒間隔）のCPU利用率レポートを確認：&lt;code&gt;atopsar -c 5 12&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指定した時間帯（例：18:00～18:01）のメモリ指標レポートを当日確認：&lt;code&gt;atopsar -m -b 18:00 -e 18:01&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指定した日付の時間帯（例：2024年11月5日18:00～18:01）のメモリ指標レポートを確認：&lt;code&gt;atopsar -m -r 20241105 -b 18:00 -e 18:01&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5その他の操作&#34;&gt;5．その他の操作
&lt;/h2&gt;&lt;p&gt;1．&lt;strong&gt;天级别ログローテーションポリシーの設定&lt;/strong&gt;：毎日atop指標ログファイルを作成したい場合は、以下の手順を実行してください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;（オプション）必要に応じて監視周期、ログ保持時間、およびログ保存パスを調整します。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo systemctl enable --now atop atopacct atop-rotate.timer&lt;/code&gt;コマンドを実行して、日次ログローテーション関連サービスを起動時に自動起動し、サービスを開始します。&lt;/li&gt;
&lt;li&gt;ビジネスがログ処理に対してより複雑な要件を持つ場合は、logrotateやカスタムスクリプトと組み合わせてログ管理を実現できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;五その他の操作&#34;&gt;五、その他の操作
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;オプションのnetatopカーネルモジュールをロードする&lt;/strong&gt;: 网络使用率を監視する必要がある場合は、atopにはデフォルトでインストールされていないため、netatopモジュールをインストールします（Alibaba Cloud Linux 3システムの場合）。
&lt;ul&gt;
&lt;li&gt;カーネル開発パッケージおよびコンパイルに必要なソフトウェア環境をインストール: &lt;code&gt;sudo yum install -y kernel-devel dkms elfutils-libelf-devel&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最新バージョンのnetatopソースコードを指定ディレクトリにダウンロード: &lt;code&gt;cd /usr/src/ &amp;amp;&amp;amp; sudo wget https://www.atoptool.nl/download/netatop-3.2.2.tar.gz --no-check-certificate&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ソースコードを解凍し、ソースコードディレクトリに移動: &lt;code&gt;sudo tar -zxvf netatop-3.2.2.tar.gz &amp;amp;&amp;amp; cd netatop-3.2.2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ソースコードに基づいてモジュールとデーモンをビルドおよびインストール: &lt;code&gt;sudo make &amp;amp;&amp;amp; sudo make install&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;netatopサービスを開始: &lt;code&gt;sudo systemctl start netatop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-その他の操作&#34;&gt;5. その他の操作
&lt;/h2&gt;&lt;p&gt;atopツールは強力で柔軟な機能を持っており、適切にインストール、設定、および使用することで、Linuxシステムの稼働状況をより深く理解し、潜在的な問題を迅速に発見して解決することができます。この記事が皆さんのLinuxシステム監視のレベルアップに役立つことを願っています。&lt;/p&gt;
&lt;h2 id=&#34;6参考链接&#34;&gt;6．参考链接
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.atoptool.nl/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;atop公式サイト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://help.aliyun.com/zh/ecs/use-cases/use-the-atop-tool-to-monitor-linux-system-metrics#99e53d0198euu&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;atopモニタリングツールのインストール、設定、および使用方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Linuxバックエンドサービスの大量文字列データの処理 - 効率が悪い</title>
        <link>https://ttf248.life/ja/p/linux-backend-slow-string-processing/</link>
        <pubDate>Wed, 13 Nov 2024 19:42:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-backend-slow-string-processing/</guid>
        <description>&lt;p&gt;C++開発の歴史的なプロジェクトにおいて、カスタムプロトコルを使用して通信を行っており、そのプロトコルは2次元配列のパターンを採用していました。大量データを処理する際に、プロトコル内部では配列を遍历し、シリアライズ操作を実行してログを生成しており、このため効率が低く、システムが高負荷時に顕著なフレーム落ち（カドゥ）を引き起こしました。事業部門からは、システムのフレーム落ちに関するフィードバックがありました。&lt;/p&gt;
&lt;h2 id=&#34;問題の特定&#34;&gt;問題の特定
&lt;/h2&gt;&lt;p&gt;問題のトラブルシューティングにおいて、まずシステムに対してパフォーマンス分析を実施し、大量データを処理する際にCPU使用率が著しく増加し、システムの応答時間が長くなっていることを発見しました。ログを分析した結果、多数のシリアライズ操作が見られ、これらの操作は2次元配列を処理する際の効率が低いことが原因でシステムのパフォーマンス低下につながっていました。
&lt;code&gt;pstack&lt;/code&gt;ツールを使用してサービスのスレッド情報を取得し、ログスレッドが文字列の連結に大部分の時間を使用していることを特定しました。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;今日は重点的に取り組むべき点です。異なる累積方式では、その効率の違いは非常に大きいです。過去のコードでは &amp;lsquo;+&amp;rsquo; 演算子を使用しており、この方法は頻繁に一時オブジェクトを作成するため、非常に非効率的でした。それは、その非効率がどの程度であるかを知らない状況にあるようなものです。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;デモ検証&#34;&gt;デモ検証
&lt;/h2&gt;&lt;p&gt;プロジェクトコードに基づいて、ビジネスロジックを抽出し、文字列連結の効率に関する問題を検証するためのシンプルなデモを作成しました。Windows環境ではVisual Studio 2022コンパイラ、Linux環境ではgcc8.5コンパイラを使用し、Releaseモードでビルドして実行し、効率を比較します。&lt;/p&gt;
&lt;h3 id=&#34;主要ポイント&#34;&gt;主要ポイント
&lt;/h3&gt;&lt;p&gt;このプロジェクトでは、方法四を使用し、テストデータを入手する前に、どの方法が最も効率的で、最も非効率かを読者に考えてもらうようにしました。結果を見たときは、自分でも驚きました。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;方法 1 (&lt;code&gt;+=&lt;/code&gt; 連結)&lt;/strong&gt;：各フィールドを &lt;code&gt;+=&lt;/code&gt; を使って文字列に直接連結します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法 2 (&lt;code&gt;std::ostringstream&lt;/code&gt; 連結)&lt;/strong&gt;：ストリーム（&lt;code&gt;std::ostringstream&lt;/code&gt;）を使用して各フィールドを連結する方法で、特に大量のデータを連結する場合に効率的です。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法 3（事前割り当てメモリの &lt;code&gt;+=&lt;/code&gt; 連結）&lt;/strong&gt;：&lt;code&gt;reserve&lt;/code&gt; を使って文字列に十分なメモリを事前に割り当てることで、メモリ再割り当てのオーバーヘッドを減らし、パフォーマンスを向上させます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法4 (&lt;code&gt;bodys = bodys + body + &amp;quot;\n&amp;quot;&lt;/code&gt;)&lt;/strong&gt;: 各回の連結で新しい一時的な文字列オブジェクトが作成されるため、大規模な連結においてはパフォーマンスの低下を引き起こします。これは、各連結において新たなメモリ割り当てとコピーが必要となるためです。
参照結果から、この方法が最も効率の悪いものとして選ばれていることがわかります。
さらに詳しく分析すると、異なるプラットフォームコンパイラの最適化効率に違いが見られます。Microsoft の &lt;code&gt;Visual Studio&lt;/code&gt; は一如既往に優れており、文字列の最適化効率は非常に高い一方、&lt;code&gt;gcc&lt;/code&gt; コンパイラはその最適化効率がやや劣ります。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;主要ポイント-1&#34;&gt;主要ポイント
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;コードを異なるマシンで実行した場合、2つのデータ間で直接的な比較の意味がないため、異なるパッチング方法間の差分を比較することができます。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;主要ポイント-2&#34;&gt;主要ポイント
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Windowsプラットフォーム下でのVisual Studio 2022コンパイラ

----------------------------------------
データ生成時間: 0.054秒
----------------------------------------

----------------------------------------
データマージパフォーマンス:
----------------------------------------
+ データマージ (+=) にかかった時間: 0.053秒
+ ostringstream データマージにかかった時間: 0.054秒
+ 事前予約済みデータマージにかかった時間: 0.045秒
+ データマージ (bodys = bodys + body + &amp;quot;\n&amp;quot;) にかかった時間: 16.108秒

----------------------------------------
データマージ完了。
----------------------------------------

プログラム終了。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;主要ポイント-3&#34;&gt;主要ポイント
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Linuxプラットフォーム下 GCC8.5コンパイラ
----------------------------------------
データ生成時間：0.108秒。
----------------------------------------

----------------------------------------
データマージパフォーマンス：
----------------------------------------
+ データマージ (+=) にかかった時間：0.100秒。
+ ostringstream データマージにかかった時間：0.083秒。
+ 事前予約済みデータマージにかかった時間：0.057秒。
+ データマージ (bodys = bodys + body + &amp;quot;\n&amp;quot;) にかかった時間：29.298秒。

----------------------------------------
データマージ完了。
----------------------------------------

プログラム終了。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完全なコード&#34;&gt;完全なコード
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;random&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;iomanip&amp;gt;

typedef std::vector&amp;lt;std::string&amp;gt; DataRow;
typedef std::vector&amp;lt;DataRow&amp;gt; DataGroup;

struct ResponsePackage
{
    std::string ErrorInfo;
    DataRow Head;
    std::string ClientId;
    std::string UUID;
    std::string MsgID;
    std::string SessionID;
    std::string ExtraInfo1;
    std::string ExtraInfo2;
    DataGroup DataBody;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;## 完整コード
// 指定された長さのランダム文字列を生成する
std::string generateRandomString(size_t length)
{
    const char charset[] = &amp;quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&amp;quot;;
    const size_t max_index = sizeof(charset) - 1;
    std::string random_string;
    random_string.reserve(length);

    std::random_device rd;
    std::mt19937 generator(rd());
    std::uniform_int_distribution&amp;lt;&amp;gt; distribution(0, max_index);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;// ランダム文字列を生成します。
// 文字列の文字セットは、小文字と大文字のアルファベット、数字です。
// 指定された長さのランダムな文字列を生成するために、乱数ジェネレータを使用して、文字セットからランダムに文字を選択します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
**注釈:**

*   上記は日本語での完全な翻訳です。
*   コードコメントも日本語で記述されています。
*   Markdown形式を維持しています。

## 完全なコード
for (size_t i = 0; i &amp;lt; length; ++i)
{
    random_string += charset[distribution(generator)];
}

return random_string;
}

void create_large_string()
{
    // 例：50フィールドを含むリクエストパッケージ
    ResponsePackage requestPackage;

## 完整コード
requestPackage.Head = {
    &amp;quot;Field1&amp;quot;, &amp;quot;Field2&amp;quot;, &amp;quot;Field3&amp;quot;, &amp;quot;Field4&amp;quot;, &amp;quot;Field5&amp;quot;,
    &amp;quot;Field6&amp;quot;, &amp;quot;Field7&amp;quot;, &amp;quot;Field8&amp;quot;, &amp;quot;Field9&amp;quot;, &amp;quot;Field10&amp;quot;,
    &amp;quot;Field11&amp;quot;, &amp;quot;Field12&amp;quot;, &amp;quot;Field13&amp;quot;, &amp;quot;Field14&amp;quot;, &amp;quot;Field15&amp;quot;,
    &amp;quot;Field16&amp;quot;, &amp;quot;Field17&amp;quot;, &amp;quot;Field18&amp;quot;, &amp;quot;Field19&amp;quot;, &amp;quot;Field20&amp;quot;,
    &amp;quot;Field21&amp;quot;, &amp;quot;Field22&amp;quot;, &amp;quot;Field23&amp;quot;, &amp;quot;Field24&amp;quot;, &amp;quot;Field25&amp;quot;,
    &amp;quot;Field26&amp;quot;, &amp;quot;Field27&amp;quot;, &amp;quot;Field28&amp;quot;, &amp;quot;Field29&amp;quot;, &amp;quot;Field30&amp;quot;,
    &amp;quot;Field31&amp;quot;, &amp;quot;Field32&amp;quot;, &amp;quot;Field33&amp;quot;, &amp;quot;Field34&amp;quot;, &amp;quot;Field35&amp;quot;
};

## 完整コード
```json
{
  &amp;quot;Field31&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field32&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field33&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field34&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field35&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field36&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field37&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field38&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field39&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field40&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field41&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field42&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field43&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field44&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field45&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field46&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field47&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field48&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field49&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;Field50&amp;quot;: &amp;quot;&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完全なコード-1&#34;&gt;完全なコード
&lt;/h2&gt;&lt;p&gt;requestPackage.ClientId = &amp;ldquo;ClientID&amp;rdquo;;
requestPackage.UUID = &amp;ldquo;UUID&amp;rdquo;;
requestPackage.MsgID = &amp;ldquo;MsgID&amp;rdquo;;
requestPackage.SessionID = &amp;ldquo;SessionID&amp;rdquo;;
requestPackage.ExtraInfo1 = &amp;ldquo;ExtraInfo1&amp;rdquo;;
requestPackage.ExtraInfo2 = &amp;ldquo;ExtraInfo2&amp;rdquo;;&lt;/p&gt;
&lt;p&gt;// データ生成の開始タイミングを記録
auto start_gen = std::chrono::high_resolution_clock::now();&lt;/p&gt;
&lt;h2 id=&#34;完全なコード-2&#34;&gt;完全なコード
&lt;/h2&gt;&lt;p&gt;// 50フィールドを持つ1万行のデータを生成する
for (size_t i = 0; i &amp;lt; 10000; ++i)
{
DataRow dataRow(50, &amp;ldquo;This is a test string&amp;rdquo;);
requestPackage.DataBody.push_back(dataRow);
}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// データ生成のタイミング終了
auto end_gen = std::chrono::high_resolution_clock::now();
std::chrono::duration&amp;lt;double&amp;gt; duration_gen = end_gen - start_gen;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完整コード&#34;&gt;完整コード
&lt;/h2&gt;&lt;p&gt;// 結果生成時間表示
std::cout &amp;laquo; &amp;ldquo;\n&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-\n&amp;rdquo;;
std::cout &amp;laquo; &amp;ldquo;データ生成時間: &amp;quot; &amp;laquo; std::fixed &amp;laquo; std::setprecision(3) &amp;laquo; duration_gen.count() &amp;laquo; &amp;quot; 秒.\n&amp;rdquo;;
std::cout &amp;laquo; &amp;ldquo;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-\n&amp;rdquo;;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 異なる方法でデータマージのパフォーマンス
std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
std::cout &amp;lt;&amp;lt; &amp;quot;データマージ性能:\n&amp;quot;;
std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完整コード-1&#34;&gt;完整コード
&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;// Method 1: Using &#39;+=&#39; string concatenation
auto start_merge = std::chrono::high_resolution_clock::now();
std::string bodys(&amp;quot;&amp;quot;);
for (auto&amp;amp; vec : requestPackage.DataBody)
{
    std::string body(&amp;quot;This is a test string&amp;quot;);
    for (auto&amp;amp; item : vec)
    {
        body += item + &amp;quot; &amp;quot;;
    }
    bodys += body + &amp;quot;\n&amp;quot;;
}
auto end_merge = std::chrono::high_resolution_clock::now();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;// 方法1：使用&amp;rsquo;+=&amp;lsquo;文字列連結
auto start_merge = std::chrono::high_resolution_clock::now();
std::string bodys(&amp;quot;&amp;quot;);
for (auto&amp;amp; vec : requestPackage.DataBody)
{
std::string body(&amp;ldquo;This is a test string&amp;rdquo;);
for (auto&amp;amp; item : vec)
{
body += item + &amp;quot; &amp;ldquo;;
}
bodys += body + &amp;ldquo;\n&amp;rdquo;;
}
auto end_merge = std::chrono::high_resolution_clock::now();&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
```markdown
## 完整コード
}
    auto end_merge = std::chrono::high_resolution_clock::now();
    std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
    std::cout &amp;lt;&amp;lt; &amp;quot;+ データマージ (+=) にかかりました: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; 秒。&amp;quot; &amp;lt;&amp;lt; std::endl;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完整コード-2&#34;&gt;完整コード
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Method 2: Using ostringstream
auto start_merge = std::chrono::high_resolution_clock::now();
std::ostringstream bodys;
for (auto&amp;amp; vec : requestPackage.DataBody)
{
    std::ostringstream body;
    body &amp;lt;&amp;lt; &amp;quot;This is a test string&amp;quot;;
    for (auto&amp;amp; item : vec)
    {
        body &amp;lt;&amp;lt; item &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
    }
    bodys &amp;lt;&amp;lt; body.str() &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
}
auto end_merge = std::chrono::high_resolution_clock::now();
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;## 完整コード
}
    auto end_merge = std::chrono::high_resolution_clock::now();
    std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
    std::cout &amp;lt;&amp;lt; &amp;quot;+ ostringstream Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完整コード-3&#34;&gt;完整コード
&lt;/h2&gt;&lt;p&gt;}
auto end_merge = std::chrono::high_resolution_clock::now();
std::chrono::duration&lt;double&gt; duration_merge = end_merge - start_merge;
std::cout &amp;laquo; &amp;ldquo;+ ostringstream データマージに要した時間: &amp;quot; &amp;laquo; std::fixed &amp;laquo; std::setprecision(3) &amp;laquo; duration_merge.count() &amp;laquo; &amp;quot; 秒。&amp;rdquo; &amp;laquo; std::endl;&lt;/p&gt;
&lt;h2 id=&#34;完全なコード-3&#34;&gt;完全なコード
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Method 3: Pre-allocated memory
auto start_merge = std::chrono::high_resolution_clock::now();
std::string bodys;
bodys.reserve(1000 * 50 * 20); // Pre-allocate enough memory
for (auto&amp;amp; vec : requestPackage.DataBody)
{
    std::string body(&amp;quot;This is a test string&amp;quot;);
    body.reserve(50 * 20); // Pre-allocate memory for each row
    for (auto&amp;amp; item : vec)
    {
        body += item + &amp;quot; &amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完全なコード-4&#34;&gt;完全なコード
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;for (auto&amp;amp; item : vec)
{
    body += item + &amp;quot; &amp;quot;;
}
bodys += body + &amp;quot;\n&amp;quot;;
}
auto end_merge = std::chrono::high_resolution_clock::now();
std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
std::cout &amp;lt;&amp;lt; &amp;quot;+ Pre-reserved Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完整コード-4&#34;&gt;完整コード
&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;        // Method 4: Using &#39;bodys = bodys + body + &amp;quot;\n&amp;quot;&#39;
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body = body + item + &amp;quot; &amp;quot;; // Note the use of &#39;body = body + item&#39;
            }
            bodys = bodys + body + &amp;quot;\n&amp;quot;; // Again, using &#39;bodys = bodys + body&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;## 完整コード
}
            bodys = bodys + body + &amp;quot;\n&amp;quot;; // Again, using &#39;bodys = bodys + body&#39;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ データマージ (bodys = bodys + body + \&amp;quot;\\n\&amp;quot;) にかかりました: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; 秒。&amp;quot; &amp;lt;&amp;lt; std::endl;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完全なコード-5&#34;&gt;完全なコード
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

void create_large_string() {
  std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
  std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Complete.\n&amp;quot;;
  std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;
}

int main()
{
    try
    {
        create_large_string();
    }
    catch (const std::exception&amp;amp; e)
    {
        std::cerr &amp;lt;&amp;lt; &amp;quot;Caught exception: &amp;quot; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\nProgram finished.\n&amp;quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>GCCバージョンをアップグレードした結果、プログラムがクラッシュしました。コードの記述ルールの欠如による問題点です。</title>
        <link>https://ttf248.life/ja/p/gcc-upgrade-causes-program-crash-code-irregularities/</link>
        <pubDate>Sun, 10 Mar 2024 23:19:06 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/gcc-upgrade-causes-program-crash-code-irregularities/</guid>
        <description>&lt;p&gt;同一段業務コードにおいて、プログラムは CentOS 7 環境下で正常にコンパイルおよび実行されていたが、CentOS 8 に切り替えて更新版の GCC でコンパイルを行った際に、プログラムがクラッシュするようになった。注目すべき点は、問題が &lt;strong&gt;Release モード&lt;/strong&gt; 下でのみ発生し、&lt;strong&gt;Debug モード&lt;/strong&gt; では完全に問題が発生しない点である。これは初めて遭遇するケースであり、3日間の調査を経て、問題の原因を特定することができた。&lt;/p&gt;
&lt;h3 id=&#34;問題の特定&#34;&gt;問題の特定
&lt;/h3&gt;&lt;p&gt;一番の原因究明の結果、問題の本質は &lt;strong&gt;関数に返り値がないこと&lt;/strong&gt; にあります。リリースモードにおいて、GCCの新バージョンではより多くの最適化が行われるため、本来返り値のない関数が実行中に未知のロジックが発生し、クラッシュを引き起こしました。結論として、&lt;strong&gt;コンパイラの警告を無視することは許されません。特に、古いプロジェクトにおいては、一部の警告が無視される可能性がありますが、すべての警告を無効にすることは避けるべきです&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;環境説明&#34;&gt;環境説明
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CentOS 7 GCCバージョン:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CentOS 8 GCCバージョン:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;クラッシュ現象&#34;&gt;クラッシュ現象
&lt;/h3&gt;&lt;p&gt;プログラムのクラッシュに関するスタックを分析した結果、以下のスタック情報が得られました：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[New LWP 1385902]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib64/libthread_db.so.1&amp;quot;.
Core was generated by `./pstack_main`.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007ffe894b4420 in ?? ()
(gdb) bt
#0  0x00007ffe894b4420 in ?? ()
#1  0x00000000004008e9 in main ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このスタックは直感的ではありません。クラッシュ関数のスタック情報が &lt;code&gt;??&lt;/code&gt; と表示されるため、問題の特定がさらに複雑になります。&lt;/p&gt;
&lt;h3 id=&#34;コード例&#34;&gt;コード例
&lt;/h3&gt;&lt;p&gt;問題をより良く理解するために、クラッシュを再現するための最小コード例を示します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int test() {
    std::cout &amp;lt;&amp;lt; &amp;quot;1&amp;quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    test();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このコード内の &lt;code&gt;test()&lt;/code&gt; 関数は明らかに値を明示的に返していません。また、その戻り値の型は &lt;code&gt;int&lt;/code&gt; です。C++ 仕様によると、関数が &lt;code&gt;int&lt;/code&gt; 型で宣言されている場合、必ず戻り値を持つ必要があります。そうしないと、未定義動作を引き起こす可能性があります。&lt;/p&gt;
&lt;h3 id=&#34;コンパイル警告&#34;&gt;コンパイル警告
&lt;/h3&gt;&lt;p&gt;当方のプロジェクトにおいて、CMake スクリプトが多くのコンパイル時の警告を抑制しており、その中に以下の警告情報が含まれています：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/root/pstack/main.cpp: In function ‘int test()’:
/root/pstack/main.cpp:7:1: warning: no return statement in function returning non-void [-Wreturn-type]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この警告は、&lt;code&gt;test()&lt;/code&gt; 関数が戻り値を持たないことを示しており、これがまさに問題の原因です。GCC の高バージョン（例：8.5.0）では、コードを最適化する際にこのような未定義の動作に対して不安定な最適化を行う可能性があり、プログラムがクラッシュする原因となる可能性があります。&lt;/p&gt;
&lt;h3 id=&#34;어셈블리-코드-차이점&#34;&gt;어셈블리 코드 차이점
&lt;/h3&gt;&lt;p&gt;GCC 컴파일러 최적화 동작의 차이를 설명하기 위해, 서로 다른 버전의 GCC가 생성한 어셈블리 코드를 비교했습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GCC 4.8.5 생성된 어셈블리 코드:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;어셈블리 코드가 다소 길고 표준 출력 스트림(예: &lt;code&gt;std::cout&lt;/code&gt;) 처리 로직을 포함하고 있습니다. 이는 컴파일러가 &lt;code&gt;test()&lt;/code&gt; 함수에서 누락된 반환 값 문제에 대해 과도하게 최적화하지 않았음을 나타내며, 이로 인해 잠재적으로 충돌을 피했을 수 있음을 시사합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GCC 8.5.0 생성된 어셈블리 코드:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;새로운 버전의 GCC는 더 많은 최적화를 수행하여 코드 양을 줄였습니다. 그러나 이러한 최적화가 누락된 반환 값을 갖는 함수의 실행 동작이 불확실하게 만들 수 있으며, 이는 프로그램 충돌로 이어질 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;結論&#34;&gt;結論
&lt;/h3&gt;&lt;p&gt;今回の問題解決を通して、C++において&lt;strong&gt;関数が返す値は明確に定義されるべきである&lt;/strong&gt;という点を深く認識しました。特に、関数を&lt;code&gt;int&lt;/code&gt;型として宣言する場合、必ず戻り値を提示する必要があります。旧バージョンのコンパイラを使用しているプロジェクトでGCCの新しいバージョンにアップグレードした場合、より多くの最適化や厳格な警告メカニズムが導入される可能性があります。そのため、コンパイル時に&lt;strong&gt;すべての警告を無効化しない&lt;/strong&gt;ことを推奨します。代わりに、関数が返す値、型の一致など、一般的な問題に対して選択的に対処する必要があります。
最終的に、&lt;code&gt;test()&lt;/code&gt;関数に戻り値を付与することで問題は解決し、プログラムは正常に動作するようになりました。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linuxシステムベンチマークテスト</title>
        <link>https://ttf248.life/ja/p/linux-system-benchmark-test/</link>
        <pubDate>Tue, 09 Jan 2024 10:56:23 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-system-benchmark-test/</guid>
        <description>&lt;p&gt;Windows 平台上有鲁大师（娱乐大师），不能说数据很准，但总归有个参考，当然也有其他的专业跑分软件。到了 Linux 系统，好像一直没遇到特别合适的跑分软件。&lt;/p&gt;
&lt;p&gt;Sysbench 是一款多功能的基准测试工具，可用于测试 CPU、内存、文件 I/O、线程性能等。您可以使用 Sysbench 来执行各种性能测试任务。&lt;/p&gt;
&lt;p&gt;手头上刚好有三台机器用于测试：机械师 mini 本地小主机、阿里云 dev 开发云服务器、华为云开发服务器。&lt;/p&gt;
&lt;h2 id=&#34;sysbench-のインストール&#34;&gt;Sysbench のインストール
&lt;/h2&gt;&lt;p&gt;ほとんどの Linux ディストリビューションでは、パッケージマネージャを使用して Sysbench をインストールできます。例えば、CentOS 8 では、次のコマンドを使用します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo dnf install sysbench
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sysbenchの使用例&#34;&gt;Sysbenchの使用例
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CPU性能のテスト：&lt;code&gt;sysbench --test=cpu run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;メモリ読み込み性能のテスト：&lt;code&gt;sysbench --test=memory run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ファイルI/O性能のテスト：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysbench --test=fileio --file-test-mode=rndrw prepare
sysbench --test=fileio --file-test-mode=rndrw run
sysbench --test=fileio --file-test-mode=rndrw cleanup
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;マルチスレッド性能のテスト：&lt;code&gt;sysbench --test=threads --num-threads=4 run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;MySQLデータベース性能のテスト（最大接続数を調整する必要あり）：&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sysbenchの使用例-1&#34;&gt;Sysbenchの使用例
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword --oltp-table-size=1000000 prepare
sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword --max-time=60 --oltp-read-only=off --oltp-test-mode=complex --max-requests=0 run
sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword cleanup
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ランニングデータレポート&#34;&gt;ランニングデータレポート
&lt;/h2&gt;&lt;meta http-equiv=&#34;Content-Type&#34; content=&#34;text/html; charset=utf-8&#34;&gt;&lt;link type=&#34;text/css&#34; rel=&#34;stylesheet&#34; href=&#34;resources/sheet.css&#34; &gt;
&lt;h2 id=&#34;採点データレポート&#34;&gt;採点データレポート
&lt;/h2&gt;&lt;style type=&#34;text/css&#34;&gt;.ritz .waffle a { color: inherit; }.ritz .waffle .s0{background-color:#ffffff;text-align:left;color:#000000;font-family:&#39;Arial&#39;;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}&lt;/style&gt;&lt;div class=&#34;ritz grid-container&#34; dir=&#34;ltr&#34;&gt;&lt;table class=&#34;waffle&#34; cellspacing=&#34;0&#34; cellpadding=&#34;0&#34;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th class=&#34;row-header freezebar-origin-ltr&#34;&gt;&lt;/th&gt;&lt;th id=&#34;0C0&#34; style=&#34;width:100px;&#34; class=&#34;column-headers-background&#34;&gt;A&lt;/th&gt;&lt;th id=&#34;0C1&#34;
&lt;h2 id=&#34;ランニングスコアレポート&#34;&gt;ランニングスコアレポート
&lt;/h2&gt;&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;A&lt;/th&gt;
      &lt;th&gt;B&lt;/th&gt;
      &lt;th&gt;C&lt;/th&gt;
      &lt;th&gt;D&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;&lt;/td&gt;
      &lt;td class=&#34;s0&#34;&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ランニングデータレポート-1&#34;&gt;ランニングデータレポート
&lt;/h2&gt;&lt;p&gt;class=&amp;ldquo;row-header-wrapper&amp;rdquo; style=&amp;ldquo;line-height: 20px&amp;rdquo;&amp;gt;1&lt;/div&gt;&lt;/th&gt;&lt;td&gt;&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;ローカルメカニスト&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;阿里云&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;ファーウェイクラウド&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R1&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;2&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;システム構成&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;System Information&lt;br&gt;  オペレーティングシステム              Ubuntu 23.04&lt;br&gt;  カーネル                        Linux&lt;/p&gt;
&lt;h2 id=&#34;ランダムアクセスメモリramレポート&#34;&gt;ランダムアクセスメモリ（RAM）レポート
&lt;/h2&gt;&lt;p&gt;情報
オペレーティングシステム Ubuntu 23.04
カーネル Linux 6.2.0-36-generic x86_64
モデル Machenike Machenike DT Computer
マザーボード Machenike Machenike DT Computer
BIOS American Megatrends International, LLC.
DB19V012&lt;/p&gt;
&lt;p&gt;CPU情報
名前 Intel Core i7-12650H
トポロジー 1 プロセッサ、10 コア、16 スレッド
識別子&lt;/p&gt;
&lt;h2 id=&#34;ランダムアクセスデータレポート&#34;&gt;ランダムアクセスデータレポート
&lt;/h2&gt;&lt;p&gt;i7-12650H
Topology                      1 プロセッサ、10 コア、16 スレッド
Identifier                    GenuineIntel Family 6 Model 154 Stepping 3
Base Frequency                4.60 GHz
L1 Instruction Cache          32.0 KB x 8
L1 Data Cache                 48.0 KB x 8
L2 Cache                      1.25 MB x 2
L3 Cache                      24.0 MB&lt;/p&gt;
&lt;p&gt;メモリ情報
サイズ                          62.6 GB&lt;/p&gt;
&lt;h2 id=&#34;ランニングデータレポート-2&#34;&gt;ランニングデータレポート
&lt;/h2&gt;&lt;p&gt;サイズ                         62.6 GB&lt;/p&gt;
&lt;p&gt;システム情報
オペレーティングシステム      CentOS Stream 8
カーネル                    Linux 4.18.0-513.el8.x86_64 x86_64
モデル                       Alibaba Cloud Alibaba Cloud ECS
マザーボード                 N/A
BIOS                        SeaBIOS 449e491&lt;/p&gt;
&lt;p&gt;CPU情報
名前                          Intel(R) Xeon(R) Platinum
トポロジー                    1 プロセッサ、1 コア、2&lt;/p&gt;
&lt;h2 id=&#34;実行成績データレポート&#34;&gt;実行成績データレポート
&lt;/h2&gt;&lt;p&gt;Intel(R) Xeon(R) Platinum
Topology                      1 Processor, 1 Core, 2 Threads
Identifier                    GenuineIntel Family 6 Model 85 Stepping 4
Base Frequency                2.50 GHz
L1 Instruction Cache          32.0 KB
L1 Data Cache                 32.0 KB
L2 Cache                      1.00 MB
L3 Cache                      33.0 MB&lt;/p&gt;
&lt;p&gt;メモリ情報
Size                          1.65 GB&lt;/p&gt;
&lt;h2 id=&#34;実行結果データレポート&#34;&gt;実行結果データレポート
&lt;/h2&gt;&lt;p&gt;情報
サイズ　1.65 GB&lt;/p&gt;
&lt;p&gt;システム情報
オペレーティングシステム Ubuntu 22.04.1 LTS
カーネル Linux 5.15.0-60-generic x86_64
モデル OpenStack Foundation OpenStack Nova
マザーボード N/A
BIOS SeaBIOS
rel-1.10.2-0-g5f4c7b1-20181220_000000-szxrtosci10000&lt;/p&gt;
&lt;p&gt;CPU情報
名前 Intel(R) Xeon(R) Gold&lt;/p&gt;
&lt;h2 id=&#34;実行結果データレポート-1&#34;&gt;実行結果データレポート
&lt;/h2&gt;&lt;p&gt;情報
名前                          Intel(R) Xeon(R) Gold 6278C CPU @ 2.60GHz
Topology                      1 Processor, 1 Core, 2 Threads
識別子                    GenuineIntel Family 6 Model 85 Stepping 7
ベース周波数                2.60 GHz
L1 命令キャッシュ          32.0 KB
L1 データキャッシュ         32.0 KB
L2 キャッシュ              1.00 MB
L3 キャッシュ              35.8 MB&lt;/p&gt;
&lt;p&gt;メモリ情報
サイズ&lt;/p&gt;
&lt;h2 id=&#34;ランダムデータレポート&#34;&gt;ランダムデータレポート
&lt;/h2&gt;&lt;p&gt;L3 キャッシュ                      35.8 MB&lt;br&gt;&lt;br&gt; メモリ情報&lt;br&gt; サイズ                          3.64 GB&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R2&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;3&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;CPU&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;以下のオプションでテストを実行:&lt;br&gt;スレッド数: 1&lt;br&gt;乱数生成器の初期化:&lt;/p&gt;
&lt;h2 id=&#34;実行結果レポート&#34;&gt;実行結果レポート
&lt;/h2&gt;&lt;p&gt;スレッド数: 1
現在の時刻から乱数生成器を初期化
素数上限: 10000
ワーカースレッドの初期化&amp;hellip;
スレッド起動！
CPU速度:
イベント数/秒: 4032.48
総統計:
合計時間: 10.0004s
合計イベント数: 40330
レイテンシ (ms):
最小: 0.25
平均:&lt;/p&gt;
&lt;h2 id=&#34;ランニング結果データレポート&#34;&gt;ランニング結果データレポート
&lt;/h2&gt;&lt;p&gt;min:                                    0.25&lt;br&gt;         avg:                                    0.25&lt;br&gt;         max:                                    0.73&lt;br&gt;         95th percentile:                        0.25&lt;br&gt;         sum:                                 9997.55&lt;br&gt;&lt;br&gt;スレッド公平性:&lt;br&gt;    イベント (平均/標準偏差):           40330.0000/0.00&lt;br&gt;    実行時間 (平均/標準偏差):   9.9975/0.00&lt;/p&gt;
&lt;p&gt;sysbench 1.0.20 (system LuaJIT 2.1.0-beta3) を使用
テスト実行中&lt;/p&gt;
&lt;h2 id=&#34;実行結果データレポート-2&#34;&gt;実行結果データレポート
&lt;/h2&gt;&lt;p&gt;class=&amp;ldquo;s0&amp;rdquo; dir=&amp;ldquo;ltr&amp;rdquo;&amp;gt;sysbench 1.0.20 (system LuaJIT 2.1.0-beta3) を使用してテストを実行し、以下のオプションを指定しました：&lt;br&gt;&lt;br&gt;スレッド数: 1&lt;br&gt;乱数生成器を現在の時刻から初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;素数上限: 10000&lt;br&gt;&lt;br&gt;ワーカースレッドの初期化中&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドが開始されました!&lt;br&gt;&lt;br&gt;CPU速度:&lt;br&gt;    イベント数/秒: 1062.51&lt;br&gt;&lt;br&gt;全体統計:&lt;br&gt;    合計時間: 10.0008s&lt;br&gt;    合計イベント数: 10628&lt;br&gt;&lt;br&gt;レイテンシ (ms):&lt;/p&gt;
&lt;h2 id=&#34;実行測定データレポート&#34;&gt;実行測定データレポート
&lt;/h2&gt;&lt;p&gt;10.0008s &lt;br&gt;
イベント総数:              10628 &lt;br&gt;&lt;br&gt;
レイテンシー (ms):&lt;br&gt;
最小:                                    0.91&lt;br&gt;
平均:                                    0.94&lt;br&gt;
最大:                                   22.84&lt;br&gt;
95パーセンタイル:                        1.06&lt;br&gt;
合計:                                 9993.46&lt;br&gt;&lt;br&gt;
スレッド公平性:&lt;br&gt;
イベント (平均/標準偏差):           10628.0000/0.00 &lt;br&gt;
実行時間 (平均/標準偏差):&lt;/p&gt;
&lt;h2 id=&#34;ランニングデータレポート-3&#34;&gt;ランニングデータレポート
&lt;/h2&gt;&lt;p&gt;イベント（平均/標準偏差）： 10628.0000 / 0.00&lt;br&gt;実行時間（平均/標準偏差）： 9.9935 / 0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;以下のオプションでテストを実行中:&lt;br&gt;スレッド数： 1&lt;br&gt;乱数生成器を現在の時間から初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;素数の制限： 10000&lt;br&gt;&lt;br&gt;ワーカースレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドが開始されました!&lt;br&gt;&lt;br&gt;CPU速度:&lt;br&gt;    毎秒イベント数： 1125.56&lt;br&gt;&lt;br&gt;一般的な統計情報:&lt;br&gt;    合計時間：&lt;/p&gt;
&lt;h2 id=&#34;実行速度レポート&#34;&gt;実行速度レポート
&lt;/h2&gt;&lt;p&gt;速度：
イベント数/秒：1125.56
一般統計：
合計時間：10.0005s
総イベント数：11258
遅延（ms）：
最小：0.86
平均：0.89
最大：1.70
95パーセンタイル：0.99
合計：9995.40
スレッド公平性：&lt;/p&gt;
&lt;h2 id=&#34;ランニングデータレポート-4&#34;&gt;ランニングデータレポート
&lt;/h2&gt;&lt;p&gt;0.99&lt;br&gt;         合計:                                 9995.40&lt;br&gt;&lt;br&gt;スレッド公平性:&lt;br&gt;    イベント (平均/標準偏差):           11258.0000/0.00&lt;br&gt;    実行時間 (平均/標準偏差):   9.9954/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R3&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;4&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;メモリ&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;以下のオプションでテストを実行:&lt;br&gt;スレッド数: 1&lt;br&gt;乱数初期化&lt;/p&gt;
&lt;h2 id=&#34;実行データレポート&#34;&gt;実行データレポート
&lt;/h2&gt;&lt;p&gt;dir=&amp;ldquo;ltr&amp;rdquo;&amp;gt;以下のオプションでテストを実行しました：&lt;br&gt;スレッド数：1&lt;br&gt;現在の時刻から乱数生成器を初期化する&lt;br&gt;&lt;br&gt;&lt;br&gt;以下のオプションでメモリ速度テストを実行します：&lt;br&gt;  ブロックサイズ：1KiB&lt;br&gt;  合計サイズ：102400MiB&lt;br&gt;  操作：書き込み&lt;br&gt;  範囲：グローバル&lt;br&gt;&lt;br&gt;ワーカースレッドの初期化中&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドが開始されました！&lt;br&gt;&lt;br&gt;総操作数：101993199 (10198146.52/秒)&lt;br&gt;&lt;br&gt;99602.73 MiB転送 (9959.13 MiB/秒)&lt;br&gt;&lt;br&gt;&lt;br&gt;一般統計：&lt;br&gt;    合計時間：&lt;/p&gt;
&lt;h2 id=&#34;実行データレポート-1&#34;&gt;実行データレポート
&lt;/h2&gt;&lt;p&gt;転送されたMiB数 (9959.13 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;全体統計:&lt;br&gt;    合計時間:                          10.0001秒&lt;br&gt;    イベント総数:              1,019,931,99件&lt;br&gt;&lt;br&gt;レイテンシ (ms):&lt;br&gt;         最小値:                                    0.00&lt;br&gt;         平均値:                                    0.00&lt;br&gt;         最大値:                                    0.03&lt;br&gt;         95パーセンタイル:                        0.00&lt;br&gt;         合計:                                 4059.50&lt;br&gt;&lt;br&gt;スレッド公平性:&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;ランニングデータレポート-5&#34;&gt;ランニングデータレポート
&lt;/h2&gt;&lt;p&gt;0.00&lt;br&gt;         合計:                                 4059.50&lt;br&gt;&lt;br&gt;スレッド公平性:&lt;br&gt;    イベント (平均/標準偏差):           101993199.0000/0.00&lt;br&gt;    実行時間 (平均/標準偏差):   4.0595/0.00&lt;/p&gt;
&lt;p&gt;テストを以下のオプションで実行しました：
スレッド数: 1
現在の時刻から乱数ジェネレータを初期化
&lt;br&gt;&lt;br&gt;&lt;br&gt;メモリ速度テストを実行し、以下のオプションを使用しました：
ブロックサイズ: 1KiB
合計サイズ: 102400MiB
操作: 書き込み
範囲:&lt;/p&gt;
&lt;h2 id=&#34;実行データレポート-2&#34;&gt;実行データレポート
&lt;/h2&gt;&lt;p&gt;オプション：
ブロックサイズ：1KiB
合計サイズ：102400MiB
操作：書き込み
範囲：グローバル&lt;/p&gt;
&lt;p&gt;ワーカースレッドの初期化中&amp;hellip;
スレッド開始！
総操作数：48418803 (秒あたり4841004.79)
転送されたデータ量：47283.99 MiB (秒あたり4727.54 MiB)&lt;/p&gt;
&lt;p&gt;一般統計：
合計時間：10.0001s
総イベント数：48418803&lt;/p&gt;
&lt;p&gt;レイテンシ（ms）：
最小：0.00
平均：&lt;/p&gt;
&lt;h2 id=&#34;実行結果データレポート-3&#34;&gt;実行結果データレポート
&lt;/h2&gt;&lt;p&gt;(ms):&lt;br&gt;         最小値:                                    0.00&lt;br&gt;         平均値:                                    0.00&lt;br&gt;         最大値:                                   25.26&lt;br&gt;         95パーセンタイル:                        0.00&lt;br&gt;         合計:                                 4578.95&lt;br&gt;&lt;br&gt;スレッド公平性:&lt;br&gt;    イベント数 (平均/標準偏差):           48418803.0000/0.00&lt;br&gt;    実行時間 (平均/標準偏差):   4.5789/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;以下のオプションでテストを実行:&lt;br&gt;数&lt;/p&gt;
&lt;h2 id=&#34;ランニングデータレポート-6&#34;&gt;ランニングデータレポート
&lt;/h2&gt;&lt;p&gt;4.5789/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;以下のオプションでテストを実行:&lt;br&gt;スレッド数: 1&lt;br&gt;現在の時刻から乱数ジェネレータを初期化する&lt;br&gt;&lt;br&gt;&lt;br&gt;以下のオプションでメモリ速度テストを実行:&lt;br&gt;  ブロックサイズ: 1KiB&lt;br&gt;  合計サイズ: 102400MiB&lt;br&gt;  操作: 書き込み&lt;br&gt;  範囲: グローバル&lt;br&gt;&lt;br&gt;ワーカースレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドを開始!&lt;br&gt;&lt;br&gt;総演算数: 57056904 (5704765.11 per second)&lt;br&gt;&lt;br&gt;55719.63 MiB転送 (5571.06 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;一般&lt;/p&gt;
&lt;h2 id=&#34;実行測定データレポート-1&#34;&gt;実行測定データレポート
&lt;/h2&gt;&lt;p&gt;(5704765.11 per second)&lt;br&gt;&lt;br&gt;
55719.63 MiB転送 (5571.06 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;
一般統計：&lt;br&gt;
合計時間:                                10.0001s&lt;br&gt;
イベント総数:                             57056904&lt;br&gt;&lt;br&gt;
レイテンシ (ms):&lt;br&gt;
最小:                                    0.00&lt;br&gt;
平均:                                    0.00&lt;br&gt;
最大:                                    0.06&lt;br&gt;
95パーセンタイル:                        0.00&lt;br&gt;
合計:&lt;/p&gt;
&lt;h2 id=&#34;ランニングデータレポート-7&#34;&gt;ランニングデータレポート
&lt;/h2&gt;&lt;p&gt;95パーセンタイル:                        0.00&lt;br&gt;         合計:                                 4556.06&lt;br&gt;&lt;br&gt;スレッド公平性:&lt;br&gt;    イベント (平均/標準偏差):           57056904.0000/0.00&lt;br&gt;    実行時間 (平均/標準偏差):   4.5561/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R4&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;5&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;ハードディスク&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;2147483648 バイトを 1.81 秒で書き込み&lt;/p&gt;
&lt;h2 id=&#34;実行結果レポート-1&#34;&gt;実行結果レポート
&lt;/h2&gt;&lt;p&gt;class=&amp;ldquo;s0&amp;rdquo; dir=&amp;ldquo;ltr&amp;rdquo;&amp;gt;ハードディスク&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;2147483648 バイトを 1.81 秒で書き込みました (1129.59 MiB/秒)。&lt;br&gt;&lt;br&gt;以下のオプションでテストを実行しました:&lt;br&gt;スレッド数: 1&lt;br&gt;現在の時刻から乱数生成器を初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;追加ファイルオープンフラグ: (なし)&lt;br&gt;128 ファイル、各 16MiB&lt;br&gt;合計ファイルサイズ 2GiB&lt;br&gt;ブロックサイズ 16KiB&lt;br&gt;IO リクエスト数: 0&lt;br&gt;組み合わせてランダム IO テストの読み取り/書き込み比率: 1.50&lt;br&gt;定期的な FSYNC を有効にし、各 100 リクエストごとに fsync() を呼び出します。&lt;/p&gt;
&lt;h2 id=&#34;実行結果レポート-2&#34;&gt;実行結果レポート
&lt;/h2&gt;&lt;p&gt;ランダムIOテスト: 1.50&lt;br&gt;定期的なFSYNCを有効化、各100リクエストごとにfsync()を呼び出す。&lt;br&gt;テストの終了時にfsync()を呼び出し、有効化。&lt;br&gt;同期I/Oモードを使用中&lt;br&gt;ランダムな読み書きテストを実施中&lt;br&gt;ワーカースレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドが開始!&lt;br&gt;&lt;br&gt;&lt;br&gt;ファイル操作:&lt;br&gt;    読み込み/秒:                      3373.41&lt;br&gt;    書き込み/秒:                     2248.94&lt;br&gt;    fsync/秒:                     7201.80&lt;br&gt;&lt;br&gt;スループット:&lt;br&gt;    読み込み, MiB/s:                  52.71&lt;br&gt;    書き込み, MiB/s:&lt;/p&gt;
&lt;h2 id=&#34;実行測定データレポート-2&#34;&gt;実行測定データレポート
&lt;/h2&gt;&lt;p&gt;read, MiB/s:                  52.71&lt;br&gt;    written, MiB/s:               35.14&lt;br&gt;&lt;br&gt;全体統計:&lt;br&gt;    合計時間:                          10.0127秒&lt;br&gt;    イベント総数:              128288&lt;br&gt;&lt;br&gt;レイテンシ (ms):&lt;br&gt;         最小値:                                    0.00&lt;br&gt;         平均値:                                    0.08&lt;br&gt;         最大値:                                    5.14&lt;br&gt;         95パーセンタイル:                        0.34&lt;br&gt;         合計:&lt;/p&gt;
&lt;h2 id=&#34;ランニングデータレポート-8&#34;&gt;ランニングデータレポート
&lt;/h2&gt;&lt;p&gt;95パーセンタイル:                        0.34&lt;br&gt;         合計:                                 9977.78&lt;br&gt;&lt;br&gt;スレッド公平性:&lt;br&gt;    イベント（平均/標準偏差）:           128288.0000/0.00&lt;br&gt;    実行時間（平均/標準偏差）:   9.9778/0.00&lt;/p&gt;
&lt;p&gt;2147483648 バイトを 19.29 秒で書き込みました (106.16 MiB/秒)。&lt;br&gt;&lt;br&gt;次のオプションでテストを実行しました:&lt;br&gt;スレッド数: 1&lt;br&gt;現在の時刻から乱数ジェネレータを初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;追加ファイルオープンフラグ: (なし)&lt;br&gt;128 ファイル、&lt;/p&gt;
&lt;h2 id=&#34;ランダム実行データレポート&#34;&gt;ランダム実行データレポート
&lt;/h2&gt;&lt;p&gt;現在の時刻からの乱数生成器&lt;br&gt;&lt;br&gt;&lt;br&gt;追加ファイルオープンフラグ：(なし)&lt;br&gt;128ファイル、各16MiB&lt;br&gt;合計ファイルサイズ 2GiB&lt;br&gt;ブロックサイズ 16KiB&lt;br&gt;IOリクエスト数: 0&lt;br&gt;組み合わせての乱数IOテストの読み書き比率: 1.50&lt;br&gt;定期的なFSYNCを有効化、各100リクエストごとにfsync()を呼び出す。&lt;br&gt;テストの最後にfsync()を呼び出し、有効化。&lt;br&gt;同期I/Oモードを使用&lt;br&gt;乱数読み書きテストを実行中&lt;br&gt;ワーカースレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドを開始!&lt;br&gt;&lt;br&gt;&lt;br&gt;ファイル操作:&lt;br&gt;    読み込み/秒:&lt;/p&gt;
&lt;h2 id=&#34;実行測定データレポート-3&#34;&gt;実行測定データレポート
&lt;/h2&gt;&lt;p&gt;ワーカースレッド&amp;hellip;&lt;br&gt;&lt;br&gt;スレッド開始!&lt;br&gt;&lt;br&gt;&lt;br&gt;ファイル操作:&lt;br&gt;    読み込み/秒:                      1593.12&lt;br&gt;    書き込み/秒:                     1062.08&lt;br&gt;    fsync/秒:                       3406.64&lt;br&gt;&lt;br&gt;スループット:&lt;br&gt;    読み込み, MiB/秒:                  24.89&lt;br&gt;    書き込み, MiB/秒:               16.60&lt;br&gt;&lt;br&gt;全体統計:&lt;br&gt;    合計時間:                          10.0164秒&lt;br&gt;    イベント総数:                      60600&lt;br&gt;&lt;br&gt;レイテンシ (ms):&lt;br&gt;         最小:&lt;/p&gt;
&lt;h2 id=&#34;ランニングデータレポート-9&#34;&gt;ランニングデータレポート
&lt;/h2&gt;&lt;p&gt;イベント: 60600&lt;br&gt;&lt;br&gt;レイテンシ (ms):&lt;br&gt;         最小: 0.00&lt;br&gt;         平均: 0.16&lt;br&gt;         最大: 31.32&lt;br&gt;         95パーセンタイル: 0.54&lt;br&gt;         合計: 9956.30&lt;br&gt;&lt;br&gt;スレッド公平性:&lt;br&gt;    イベント (平均/標準偏差): 60600.0000/0.00&lt;br&gt;    実行時間 (平均/標準偏差): 9.9563/0.00&lt;/p&gt;
&lt;td&gt;2147483648 バイト
&lt;h2 id=&#34;実行結果レポート-3&#34;&gt;実行結果レポート
&lt;/h2&gt;&lt;p&gt;平均実行時間 (stddev): 9.9563 / 0.00&lt;/p&gt;
&lt;p&gt;2147483648 バイトが 18.29 秒で書き出されました (111.98 MiB/sec)。&lt;br&gt;&lt;br&gt;以下のオプションでテストを実行しました:&lt;br&gt;スレッド数: 1&lt;br&gt;現在の時刻から乱数ジェネレータを初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;追加ファイルオープンフラグ: (なし)&lt;br&gt;128 ファイル、各 16MiB&lt;br&gt;合計ファイルサイズ: 2GiB&lt;br&gt;ブロックサイズ: 16KiB&lt;br&gt;IO リクエスト数: 0&lt;br&gt;組み合わせてランダム IO テストの読み取り/書き込み比率: 1.50&lt;br&gt;定期的な FSYNC を有効にし、各 100 で fsync() を呼び出しました&lt;/p&gt;
&lt;h2 id=&#34;実行結果レポート-4&#34;&gt;実行結果レポート
&lt;/h2&gt;&lt;p&gt;結合ランダムIOテストの比率：1.50&lt;br&gt;
定期的なFSYNCを有効化、各100リクエストごとにfsync()を呼び出し。&lt;br&gt;
テスト終了時にfsync()を呼び出す。有効化。&lt;br&gt;
同期I/Oモードを使用中&lt;br&gt;
ランダムR/Wテストを実行中&lt;br&gt;
ワーカースレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;
スレッドを開始!&lt;br&gt;&lt;br&gt;&lt;br&gt;ファイル操作:&lt;br&gt;
読み込み/秒:                      1665.88&lt;br&gt;
書き込み/秒:                     1110.59&lt;br&gt;
fsync/秒:                     3563.77&lt;br&gt;&lt;br&gt;帯域幅:&lt;br&gt;
読み込み、MiB/s:                  26.03&lt;br&gt;
書き込み、MiB/s:&lt;/p&gt;
&lt;h2 id=&#34;実行速度レポート-1&#34;&gt;実行速度レポート
&lt;/h2&gt;&lt;p&gt;3563.77&lt;/p&gt;
&lt;p&gt;スループット：
読み込み: MiB/s:                  26.03
書き込み: MiB/s:               17.35&lt;/p&gt;
&lt;p&gt;全体統計：
合計時間:                          10.0112秒
イベント総数:              63355&lt;/p&gt;
&lt;p&gt;レイテンシ (ms):
最小:                                    0.00
平均:                                    0.16
最大:                                  205.01
95パーセンタイル:                        0.78&lt;/p&gt;
&lt;h2 id=&#34;ランニングデータレポート-10&#34;&gt;ランニングデータレポート
&lt;/h2&gt;&lt;p&gt;205.01&lt;br&gt;         パーセンタイル95：                        0.78&lt;br&gt;         合計：                                 9972.64&lt;br&gt;&lt;br&gt;スレッド公平性:&lt;br&gt;    イベント（平均/標準偏差）：           63355.0000/0.00&lt;br&gt;    実行時間（平均/標準偏差）：   9.9726/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R5&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;6&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;マルチスレッド&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;実行中&lt;/td&gt;&lt;/tr&gt;&lt;/p&gt;
&lt;h2 id=&#34;実行結果レポート-5&#34;&gt;実行結果レポート
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div&amp;gt;&amp;lt;span style=&amp;quot;font-size: 20px&amp;quot;&amp;gt;6&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/th&amp;gt;&amp;lt;td class=&amp;quot;s0&amp;quot; dir=&amp;quot;ltr&amp;quot;&amp;gt;マルチスレッド&amp;lt;/td&amp;gt;&amp;lt;td class=&amp;quot;s0&amp;quot; dir=&amp;quot;ltr&amp;quot;&amp;gt;以下のオプションでテストを実行:&amp;lt;br&amp;gt;スレッド数: 4&amp;lt;br&amp;gt;現在の時刻から乱数ジェネレータを初期化する&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;ワーカースレッドの初期化...&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;スレッドが開始されました!&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;一般統計:&amp;lt;br&amp;gt;    合計時間:                          10.0002秒&amp;lt;br&amp;gt;    総イベント数:              197956件&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;レイテンシ (ms):&amp;lt;br&amp;gt;         最小:                                    0.16&amp;lt;br&amp;gt;         平均:
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;実行結果レポート-6&#34;&gt;実行結果レポート
&lt;/h2&gt;&lt;p&gt;以下のオプションでテストを実行しました：
スレッド数：4
現在の時刻から乱数ジェネレータを初期化
ワーカースレッドの初期化&amp;hellip;
スレッドが開始されました！
一般統計：
合計時間：10.0002秒
総イベント数：197956件
レイテンシ（ms）：
最小：0.16
平均：&lt;/p&gt;
&lt;h2 id=&#34;走査データレポート&#34;&gt;走査データレポート
&lt;/h2&gt;&lt;p&gt;(ms):&lt;br&gt;         最小値:                                    0.16&lt;br&gt;         平均値:                                    0.20&lt;br&gt;         最大値:                                    0.34&lt;br&gt;         95パーセンタイル:                        0.21&lt;br&gt;         合計:                                39970.47&lt;br&gt;&lt;br&gt;スレッド公平性:&lt;br&gt;    イベント (平均/標準偏差):           49489.0000/5.70&lt;br&gt;    実行時間 (平均/標準偏差):   9.9926/0.00&lt;/p&gt;
&lt;p&gt;テストを実行したオプション:
スレッド数:&lt;/p&gt;
&lt;h2 id=&#34;実行データレポート-3&#34;&gt;実行データレポート
&lt;/h2&gt;&lt;p&gt;class=&amp;ldquo;s0&amp;rdquo; dir=&amp;ldquo;ltr&amp;rdquo;&amp;gt;以下のオプションでテストを実行します:&lt;br&gt;スレッド数: 4&lt;br&gt;現在の時刻から乱数生成器を初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;ワーカースレッドの初期化中&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドが開始されました!&lt;br&gt;&lt;br&gt;&lt;br&gt;一般統計:&lt;br&gt;    合計時間:                          10.0174秒&lt;br&gt;    総イベント数:              18360件&lt;br&gt;&lt;br&gt;レイテンシ (ms):&lt;br&gt;         最小:                                    0.57&lt;br&gt;         平均:                                    2.18&lt;br&gt;         最大:&lt;/p&gt;
&lt;h2 id=&#34;ランニングデータレポート-11&#34;&gt;ランニングデータレポート
&lt;/h2&gt;&lt;p&gt;0.57&lt;br&gt;         avg:                                    2.18&lt;br&gt;         max:                                   32.77&lt;br&gt;         95th percentile:                        2.61&lt;br&gt;         sum:                                40050.41&lt;br&gt;&lt;br&gt;スレッド公平性:&lt;br&gt;    イベント (avg/stddev):           4590.0000/94.36&lt;br&gt;    実行時間 (avg/stddev):   10.0126/0.00&lt;/p&gt;
&lt;p&gt;テストを以下のオプションで実行しました：&lt;br&gt;スレッド数: 4&lt;br&gt;乱数ジェネレータの初期化&lt;/p&gt;
&lt;h2 id=&#34;実行結果レポート-7&#34;&gt;実行結果レポート
&lt;/h2&gt;&lt;p&gt;以下のオプションでテストを実行:&lt;br&gt;スレッド数: 4&lt;br&gt;乱数生成器を現在時刻から初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;ワーカースレッドの初期化中&amp;hellip;&lt;br&gt;&lt;br&gt;スレッド起動!&lt;br&gt;&lt;br&gt;&lt;br&gt;総合統計:&lt;br&gt;    合計時間:                          10.0004秒&lt;br&gt;    総イベント数:              28536件&lt;br&gt;&lt;br&gt;レイテンシ (ms):&lt;br&gt;         最小:                                    0.23&lt;br&gt;         平均:                                    1.40&lt;br&gt;         最大:                                    3.56&lt;/p&gt;
&lt;h2 id=&#34;走行データレポート&#34;&gt;走行データレポート
&lt;/h2&gt;&lt;p&gt;1.40 &lt;br&gt;
最大値:                                    3.56 &lt;br&gt;
パーセンタイル95:                        1.47 &lt;br&gt;
合計:                                39975.16 &lt;br&gt;&lt;br&gt;
スレッド公平性:&lt;br&gt;
イベント (平均/標準偏差):           7134.0000/39.87 &lt;br&gt;
実行時間 (平均/標準偏差):   9.9938/0.01&lt;/p&gt;
&lt;h2 id=&#34;付録&#34;&gt;付録
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ChatGPT&lt;/code&gt; は依然として優れたものですが、以前習得していた &lt;code&gt;Markdown&lt;/code&gt; で完全にテーブルを作成できず、表示効果が著しく低下します。カスタムテーマによってページの最大幅が制限されるため、幅をパーセンテージ制に調整しました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;簡単な方法としては、TablesGeneratorなどのオンラインツールを使用してHTMLテーブルを生成（内容が複雑だと不向き）&lt;/li&gt;
&lt;li&gt;または、Googleドキュメントで作成し、HTML形式でダウンロードして保存し、ブログに直接コピーする（シンプルかつ直接的で、最終的に採用）
config設定でunsafeオプションを有効にする。ページごとの幅の設定を個別に指定する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Hugoでは、ページごとに幅を設定できます。これは、ページのFront Matterにカスタムパラメータを追加することで実現できます。以下はその例です： あなたの Markdown の Front Matter セクション（通常はファイルの冒頭部分）に、カスタムパラメータを追加してください。例えば &lt;code&gt;custom_width&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;---
title: &amp;quot;私のページ&amp;quot;
date: 2024-01-09
custom_width: &amp;quot;800px&amp;quot;  # 幅を 800 ピクセルに設定
---

本文内容...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;付録-1&#34;&gt;付録
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;あなたの Hugo テーマで、対応するシングルページテンプレートファイル（例：&lt;code&gt;layouts/_default/single.html&lt;/code&gt;）を見つけてください。&lt;/li&gt;
&lt;li&gt;シングルページテンプレート内で、ページの Front Matter に &lt;code&gt;custom_width&lt;/code&gt; パラメータが存在するか確認し、それを該当する HTML 要素（例：&lt;code&gt;div&lt;/code&gt;）に適用してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{{ define &amp;quot;main&amp;quot; }}
  &amp;lt;div style=&amp;quot;max-width: {{ with .Params.custom_width }}{{ . }}{{ else }}100%{{ end }}; margin: 0 auto;&amp;quot;&amp;gt;
    {{ .Content }}
  &amp;lt;/div&amp;gt;
{{ end }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この例では、内联スタイル（&lt;code&gt;style&lt;/code&gt;属性）を使用して &lt;code&gt;div&lt;/code&gt; 要素の &lt;code&gt;max-width&lt;/code&gt; 属性を設定し、&lt;code&gt;custom_width&lt;/code&gt; パラメータが指定されていない場合に幅をデフォルトで100%にしています。&lt;code&gt;margin: 0 auto;&lt;/code&gt; は &lt;code&gt;div&lt;/code&gt; 要素を中央揃えにします。&lt;/p&gt;
&lt;h2 id=&#34;付録-2&#34;&gt;付録
&lt;/h2&gt;&lt;p&gt;上記はあくまで例であり、実際のアプリケーションでは、テーマの構造とCSSスタイルの詳細に合わせて調整が必要となる場合があります。スタイルを調整する際は、テーマの一貫性と可読性を維持するようにしてください。
また、有効化されたテーマが若干異なるため、最後にサイトカスタムの&lt;code&gt;CSS&lt;/code&gt;設定を調整しました。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Dockerの基礎を理解するための３つのポイント</title>
        <link>https://ttf248.life/ja/p/docker-two-three-things/</link>
        <pubDate>Thu, 21 Jan 2021 09:26:07 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/docker-two-three-things/</guid>
        <description>&lt;p&gt;長年携わってきたのは &lt;code&gt;CentOS&lt;/code&gt; オペレーティングシステムであり、&lt;code&gt;mac&lt;/code&gt; ユーザーや &lt;code&gt;Ubuntu&lt;/code&gt; ユーザーの場合、一部の内容は適用できない。
インストールに関する部分は、清華大学のドキュメントを参照するのが参考になる：&lt;a class=&#34;link&#34; href=&#34;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;インストール&#34;&gt;インストール
&lt;/h2&gt;&lt;p&gt;未知の神秘的な力により、国内でのDockerのインストールには、クラウドプロバイダーが提供するレジストリのアドレスを設定することを推奨します。ここでは&lt;strong&gt;Alibaba Cloud&lt;/strong&gt;を使用することをお勧めします。&lt;/p&gt;
&lt;h3 id=&#34;リポジトリソースの設定&#34;&gt;リポジトリソースの設定
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install yum-utils device-mapper-persistent-data lvm2 &amp;amp;&amp;amp; \
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;最新版のインストール&#34;&gt;最新版のインストール
&lt;/h3&gt;&lt;p&gt;Dockerは一般的なバックエンドサービスとして、起動時に自動で開始されるように設定することを推奨します。以下のコマンドはCentOS 7向けです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum install -y docker-ce docker-ce-cli containerd.io &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;指定バージョン展開&#34;&gt;指定バージョン展開
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;kubernetes&lt;/code&gt;および&lt;code&gt;docker&lt;/code&gt;のリリースは完全に同期されておらず、今後&lt;code&gt;kubernetes&lt;/code&gt;を展開する場合は、&lt;code&gt;kubernetes&lt;/code&gt;展開手順を参照し、指定バージョンの&lt;code&gt;docker&lt;/code&gt;をインストールしてください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum list docker-ce --showduplicates | sort -r
sudo yum install -y docker-ce-18.09.2-3.el7 docker-ce-cli-18.09.2-3.el7 containerd.io-18.09.2-3.el7 &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;通常ユーザーにdocker権限を追加する&#34;&gt;通常ユーザーにDocker権限を追加する
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo usermod -aG docker ${USER}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;卸載&#34;&gt;卸載
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum remove -y docker-ce docker-ce-cli containerd.io
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;日常使用-にちじょうしよう&#34;&gt;日常使用 (にちじょうしよう)
&lt;/h2&gt;&lt;h3 id=&#34;镜像加速&#34;&gt;镜像加速
&lt;/h3&gt;&lt;p&gt;未知の神秘的な力により、イメージの取得時に速度が低下することがあります。この問題を解決するために、国内のクラウドプロバイダーが多くの加速サービスを提供し、引き続き&lt;strong&gt;阿里云&lt;/strong&gt;を推奨します。&lt;/p&gt;
&lt;p&gt;加速用のURLは、ご自身で阿里云アカウントを登録して取得してください。このサービスは無料で利用でき、阿里云からは無料のイメージ構築サービスも提供されています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt; /etc/docker/daemon.json &amp;lt;&amp;lt;EOF
{
  &amp;quot;registry-mirrors&amp;quot;: [
    &amp;quot;https://docker.nju.edu.cn&amp;quot;,
    &amp;quot;https://mirror.baidubce.com&amp;quot;,
    &amp;quot;https://docker.m.daocloud.io&amp;quot;,
    &amp;quot;https://docker.mirrors.sjtug.sjtu.edu.cn&amp;quot;
  ]
}
EOF
systemctl daemon-reload &amp;amp;&amp;amp; \
systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;強く推奨されるコントロールパネル&#34;&gt;強く推奨されるコントロールパネル
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker volume create portainer_data &amp;amp;&amp;amp; \
docker run -d --name=portainer --restart=always -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:2.20.3-alpine
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;常用イメージのプル集&#34;&gt;常用イメージのプル集
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker pull rancher/rancher:stable &amp;amp;&amp;amp; docker pull portainer/portainer-ce:2.0.1 &amp;amp;&amp;amp; \
docker pull centos:7 &amp;amp;&amp;amp; docker pull ubuntu:20.04 &amp;amp;&amp;amp; docker pull ubuntu:18.04 &amp;amp;&amp;amp; \
docker pull redis:5 &amp;amp;&amp;amp; docker pull redis:6 &amp;amp;&amp;amp; \
docker pull alpine:3.11 &amp;amp;&amp;amp; docker pull busybox:1.32 &amp;amp;&amp;amp; \
docker pull rabbitmq:3.7-management &amp;amp;&amp;amp; \
docker pull mariadb:10.2 &amp;amp;&amp;amp; \
docker pull nginx:1.18 &amp;amp;&amp;amp; docker pull nginx:1.19 &amp;amp;&amp;amp; \
docker pull mysql:5.6 &amp;amp;&amp;amp; docker pull mysql:8 &amp;amp;&amp;amp; \
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;常用イメージのプル集-1&#34;&gt;常用イメージのプル集
&lt;/h3&gt;&lt;p&gt;docker pull mysql:5.6 &amp;amp;&amp;amp; docker pull mysql:8 &amp;amp;&amp;amp; &lt;br&gt;
docker pull elasticsearch:6.8.11 &amp;amp;&amp;amp; docker pull logstash:6.8.11 &amp;amp;&amp;amp; docker pull kibana:6.8.11 &amp;amp;&amp;amp; &lt;br&gt;
docker pull zookeeper:3.4 &amp;amp;&amp;amp; &lt;br&gt;
docker pull influxdb:1.7 &amp;amp;&amp;amp; docker pull grafana/grafana:7.3.1 &amp;amp;&amp;amp; &lt;br&gt;
docker pull percona:8 &amp;amp;&amp;amp; docker pull percona:5.6 &amp;amp;&amp;amp; &lt;br&gt;
docker pull cloverzrg/frps-docker:0.34.3 &amp;amp;&amp;amp; docker pull cloverzrg/frpc-docker:0.34.3&lt;/p&gt;
&lt;h3 id=&#34;常用コマンド&#34;&gt;常用コマンド
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/engine/reference/commandline/docker/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.docker.com/engine/reference/commandline/docker/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;コンテナの実行状態を確認し、&lt;code&gt;format&lt;/code&gt;パラメータを追加して詳細なコンテナ情報を表示（イメージ情報は無視）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker ps --format &amp;quot;{{.Names}}: {{.Ports}}: {{.Size}}&amp;quot;
#portainer: 0.0.0.0:8000-&amp;gt;8000/tcp, 0.0.0.0:9000-&amp;gt;9000/tcp: 0B (virtual 172MB)
#influxdb: 0.0.0.0:8086-&amp;gt;8086/tcp: 183B (virtual 311MB)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;すべてのコンテナを一度に停止&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker stop $(docker ps -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;すべてのイメージを一度に削除&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dokcer rmi $(docker images -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;イメージのエクスポート&lt;/p&gt;
&lt;h3 id=&#34;常用コンマンド&#34;&gt;常用コンマンド
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; &amp;gt; -o XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;イメージを保存して圧縮する&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; | gzip &amp;gt; XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;イメージをインポートする&lt;/p&gt;
</description>
        </item>
        <item>
        <title>LinuxでJMeterの負荷テスト環境を構築する</title>
        <link>https://ttf248.life/ja/p/linux-setup-jmeter-testing-environment/</link>
        <pubDate>Tue, 22 Dec 2020 10:12:50 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-setup-jmeter-testing-environment/</guid>
        <description>&lt;p&gt;著者はハードウェアに強い関心を持ち、JMeterを用いて負荷テストを実施し、CentOS 7上にJMeter、InfluxDB、Grafanaをデプロイするプロセスを記録しました。JMeterのインストールとコマンドの使用方法、InfluxDBの特徴とDockerによるインストール方法、Grafanaの簡易的なデプロイと設定について共有しています。高性能プログラムモードに関する経験や参考資料もまとめました。&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;広く知られているように&lt;/code&gt;、私にはハードウェアに対する強い関心が持っており、テストグループが &lt;code&gt;JMeter&lt;/code&gt; を使用して負荷テストを行っている際、パフォーマンスが向上しないことを発見しました。好奇心旺盛な私は、会社の負荷テストの方法を試してみることに決意しました。また、ある頃合いにオープンソース中国で読んだ投稿「より洗練された高性能の負荷テストグラフを作成する方法」があり、&lt;code&gt;Windows&lt;/code&gt; バージョンでのテスト実行時に可視化された &lt;code&gt;TPS&lt;/code&gt; データの表示を実現していました。さらに、Web パネルを構成することでどのようなメリットがあるのでしょうか？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;頭の中で思いついたのは、当然のことばかりです。実際に試してみないとしかたないことを理解します
テスト作成およびデバッグには GUI モードを使用しないでください！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;背景-1&#34;&gt;背景
&lt;/h2&gt;&lt;p&gt;公式推奨は、コマンドラインで負荷テストレポートを取得し、GUIで表示する方法ですが、データに誤差が含まれているという問題があります。JMeterの理解が十分ではないため、少なくとも&lt;code&gt;Linux&lt;/code&gt;版のコンソールパネルを弄り転げる理由を見つけたいと思います。&lt;/p&gt;
&lt;p&gt;開かれた中国（オープンチャイナ）の投稿では、コアコンポーネントのデプロイメント方法があまりにも友好的ではなく、インストールに必要なファイルは公众号を通じてダウンロードする必要があり、現代的な若者として、もちろん&lt;code&gt;Docker&lt;/code&gt;で代替します。要するに、サーバーは国内であり、国境を越えたソースアドレスへのアクセス速度が遅いため、少なくともイメージサービスとしては、阿里云には無料の高速化があります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker&lt;/code&gt; のインストールとデプロイメントについては、ここでは詳細な説明を省略し、以前の記事を参照してください。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;次の内容は、2つの主要な領域に分かれています：基本的なテスト環境コンポーネントの構築、および各コンポーネントの簡単な認識の説明&lt;/p&gt;
&lt;h2 id=&#34;jmeter&#34;&gt;JMeter
&lt;/h2&gt;&lt;p&gt;Apache JMeter は Apache 組織が開発した Java ベースの負荷テストツールです。ソフトウェアに対して負荷テストを実施するために使用され、当初は Web アプリケーション テスト用に設計されましたが、その後、他のテスト分野にも拡張されました。 静的および動的なリソース（静的ファイル、Java 小サービスプログラム、CGI スクリプト、Java オブジェクト、データベース、FTP サーバーなど）をテストに使用できます。 JMeter は、さまざまなストレスカテゴリからの巨大な負荷をシミュレートして、サーバー、ネットワーク、またはオブジェクトの強度をテストし、全体的なパフォーマンスを分析するために使用できます。 さらに、JMeter はアプリケーションに対して機能/回帰テストを実行し、断言を含むスクリプトを作成することで、プログラムが期待どおりの結果を返すことを検証します。 最大限の柔軟性を実現するため、JMeter は正規表現を使用して断言を作成することを許可しています。 Apache JMeter は、静的なリソース（ファイル、Servlet、Perlスクリプト、Javaオブジェクト、データベースとクエリ、FTPサーバーなど）および動的なリソースのパフォーマンスをテストするために使用できます。 サーバー、ネットワーク、またはオブジェクトに対して、過酷な負荷や異なる種類のストレス下での全体的なパフォーマンスを分析するために、高負荷をシミュレートすることができます。 パフォーマンスのグラフィカル分析や、大規模な同時実行負荷でサーバー/スクリプト/オブジェクトをテストするのに使用できます。&lt;/p&gt;
&lt;h3 id=&#34;jmeter-導入-centos7&#34;&gt;Jmeter 導入 CentOS7
&lt;/h3&gt;&lt;p&gt;JDK の実行環境をインストールし、JMeter のインストールパッケージをダウンロードします。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install java-1.8.0-openjdk -y &amp;amp;&amp;amp; \
wget https://mirrors.bfsu.edu.cn/apache//jmeter/binaries/apache-jmeter-5.4.tgz &amp;amp;&amp;amp; tar -xf apache-jmeter-5.4.tgz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;環境変数を設定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export JMETER_HOME=$HOME/jmeter/apache-jmeter-5.4
export PATH=$JMETER_HOME/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;jmeter-コマンド&#34;&gt;JMeter コマンド
&lt;/h3&gt;&lt;p&gt;最後に &lt;code&gt;Grafana&lt;/code&gt; ダッシュボードに送信し、&lt;code&gt;-l&lt;/code&gt; パラメータを入力しなくても、&lt;code&gt;web&lt;/code&gt; コンソールでデータを観察できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;jmeter -n -t /tmp/order-500-10s.jmx -l /tmp/jmeter-order-report-20200109/order-500-10s.jtl
# 通常、テスト結果とテストレポートは省略し、コマンドを簡略化します。
jmeter -n -t /tmp/order-500-10s.jmx
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;influxdb&#34;&gt;InfluxDB
&lt;/h2&gt;&lt;p&gt;InfluxDBは、Go言語で記述されたオープンソースの分散型時系列、イベント、指標データベースです。外部依存なしで動作します。このデータベースは現在、大量の時間スタンプデータ（DevOpsモニタリングデータ、APPメトリクス、IoTセンサーデータ、リアルタイム分析データなど）を保存するために主に利用されています。&lt;/p&gt;
&lt;h3 id=&#34;influxdbの特徴&#34;&gt;InfluxDBの特徴
&lt;/h3&gt;&lt;p&gt;InfluxDBの特徴は、以下の9点にまとめられます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非構造化（非モデリング）：任意の数の列を格納できます。&lt;/li&gt;
&lt;li&gt;メトリクスの保存期間の設定が可能&lt;/li&gt;
&lt;li&gt;時間に関連する関数（min、max、sum、count、mean、medianなど）をサポートし、統計分析が容易です。&lt;/li&gt;
&lt;li&gt;ストアポリシーのサポート：データの更新や削除に使用できます。（InfluxDBはデータの削除や変更方法を提供していません。）&lt;/li&gt;
&lt;li&gt;連続クエリのサポート：データベース内で自動的にスケジュールされたクエリのセットで、ストアポリシーと組み合わせてInfluxDBのシステム負荷を軽減します。&lt;/li&gt;
&lt;li&gt;ネイティブなHTTPサポート、組み込みHTTP API&lt;/li&gt;
&lt;li&gt;SQLライクな構文のサポート&lt;/li&gt;
&lt;li&gt;クラスタ内のデータのレプリカ数を設定可能&lt;/li&gt;
&lt;li&gt;定期的なサンプリングによるデータ書き込みをサポートし、別のmeasurementにデータを分割して保存することで、粒度に応じたデータストレージが可能です。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;influxdb-docker-インストール&#34;&gt;InfluxDB Docker インストール
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir influxdb &amp;amp;&amp;amp; cd influxdb &amp;amp;&amp;amp; \
docker run -p 8086:8086 -d --name influxdb -v $PWD:/var/lib/influxdb influxdb:1.7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker exec -it influxdb /bin/bash&lt;/code&gt; でコンテナに入り、コマンドを実行し、手動でデータベースを作成&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;root@bce0a55bbc72:/# influx
http://localhost:8086 への接続、バージョン 1.7.10
InfluxDB シェル バージョン: 1.7.10
&amp;gt; 対話式パネルでコマンドを実行
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;influxdbデータベースとユーザーの作成&#34;&gt;InfluxDBデータベースとユーザーの作成
&lt;/h3&gt;&lt;p&gt;データベースの作成: &lt;code&gt;create database jmeter_t2&lt;/code&gt;
データベースの表示: &lt;code&gt;show databases&lt;/code&gt;
データベースの切り替え: &lt;code&gt;use jmeter_t2&lt;/code&gt;
ユーザーの作成: &lt;code&gt;create user &amp;quot;admin&amp;quot; with password &#39;admin&#39; with all privileges&lt;/code&gt;
ユーザーの表示: &lt;code&gt;show users&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; show users
user  admin
----  -----
admin true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ユーザー権限が&lt;code&gt;admin&lt;/code&gt;で&lt;code&gt;true&lt;/code&gt;と表示されれば、データベースの準備は完了です。&lt;/p&gt;
&lt;h2 id=&#34;grafana&#34;&gt;Grafana
&lt;/h2&gt;&lt;p&gt;テストケースの作成時に、グラフによる表現はあまり必要ないことがわかりました。インターフェースの&lt;code&gt;tps&lt;/code&gt;データはコマンドラインで実行する際にすでに観測できるため、主にプログラム内部の処理時間を知りたいと考えています。&lt;/p&gt;
&lt;p&gt;Grafanaのコンソールパネルを簡単にデプロイし、InfluxDBと連携するための設定ファイルをインポートします。&lt;/p&gt;
&lt;p&gt;コンソールではラベルによるフィルタリングがサポートされており、通常は1つの&lt;code&gt;InfluxDB&lt;/code&gt;データベースを設定するだけで済みます：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アプリケーション名&lt;/li&gt;
&lt;li&gt;テストケース名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/linux-setup-jmeter-testing-environment/Snipaste_2021-03-09_19-44-22.png&#34;
	width=&#34;861&#34;
	height=&#34;357&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;grafana&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;241&#34;
		data-flex-basis=&#34;578px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -d --name=grafana -p 3000:3000 grafana/grafana:7.3.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ブラウザ版ではサンプリング間隔により&lt;code&gt;TPS&lt;/code&gt;や関連数値がJMeterの集計レポートと一致しないため、参考リンクを参照してください：[https://www.vinsguru.com/jmeter-real-time-results-influxdb-grafana/](&lt;a class=&#34;link&#34; href=&#34;https://www.vinsguru&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.vinsguru&lt;/a&gt;. ## Grafana&lt;/p&gt;
&lt;p&gt;テストケースの作成時に、グラフによる表現はあまり必要ないことがわかりました。インターフェースの&lt;code&gt;tps&lt;/code&gt;データはコマンドラインで実行する際にすでに観測できるため、プログラム内部の処理時間を確認することが主な目的です。&lt;/p&gt;
&lt;p&gt;Grafanaのコンソールパネルを簡単にデプロイし、InfluxDBと連携するための設定ファイルをインポートしました。&lt;/p&gt;
&lt;p&gt;コンソールではラベルによるフィルタリングがサポートされており、通常は1つの&lt;code&gt;InfluxDB&lt;/code&gt;データベースを設定するだけで済みます：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アプリケーション名&lt;/li&gt;
&lt;li&gt;テストケース名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/linux-setup-jmeter-testing-environment/Snipaste_2021-03-09_19-44-22.png&#34;
	width=&#34;861&#34;
	height=&#34;357&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;grafana&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;241&#34;
		data-flex-basis=&#34;578px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -d --name=grafana -p 3000:3000 grafana/grafana:7.3.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ブラウザ版ではサンプリング間隔により、計算された&lt;code&gt;TPS&lt;/code&gt;や関連数値がJMeterの集計レポートと一致しないため、参考リンクを参照してください：[https://www.vinsguru.com/jmeter-real-time-results-influxdb-grafana/](&lt;a class=&#34;link&#34; href=&#34;https://www.vinsguru&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.vinsguru&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;付録&#34;&gt;付録
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;高性能のプログラムパターンは、必然的にone loop threadであるべきであり、ロック、入隊列、出隊列などのものは、不必要なパフォーマンス低下を引き起こす&lt;/li&gt;
&lt;li&gt;核心ビジネスロジックの実行時間が、他のコードを導入する時間よりも大きい場合のみ、並行処理が有効に効率を向上させることができ、コアな実行時間が十分に小さい場合は、慎重に他のコードを導入すべき&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考資料&#34;&gt;参考資料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://my.oschina.net/u/4617935/blog/4680856&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;JMeterシリーズのJMeter+Grafana+InfluxDB リアルタイム監視&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/_/influxdb&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;influxdb 公式イメージ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/r/grafana/grafana&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;grafana 公式イメージ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://jmeter.apache.org/download_jmeter.cgi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;JMeter 公式サイト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@jasonli.studio/to-install-apache-jmeter-in-centos7-294bc72a97ba&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CentOS7にApache JMeterをインストールする方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Red Hat と CentOS のライフサイクル</title>
        <link>https://ttf248.life/ja/p/redhat-centos-lifecycle/</link>
        <pubDate>Tue, 21 Jul 2020 20:02:35 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/redhat-centos-lifecycle/</guid>
        <description>&lt;p&gt;オンラインプロ덕ション環境のオペレーティングシステムとして、Red HatとCentOSが主流の選択肢です。2つのシステムのライフサイクルに関する公式サイトへのリンクを記録し、CentOS 8からCentOS 8 Streamへのアップグレード経験を共有しています。&lt;/p&gt;
&lt;h2 id=&#34;はじめに&#34;&gt;はじめに
&lt;/h2&gt;&lt;p&gt;オンプレミス（本番環境）のオペレーティングシステムですが、現在の国内環境においては、Red HatとCentOSが主流の選択肢です。2年前にはRed Hat 6のEOL（End of Life）を迎えたため、両システムのライフサイクルに関する公式ウェブサイトリンクを記録します。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://access.redhat.com/support/policy/updates/errata&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Red Hat Enterprise Linux 生命周期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://wiki.centos.org/zh/About/Product&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CentOS 产品规范&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Red Hat Enterprise Linux（RHEL）および CentOS は、エンタープライズ向けのサーバーオペレーティングシステムとして主流の選択肢です。RHEL は安定したサポートと更新サイクルを提供し、エンタープライズアプリケーションに適しています。CentOS は RHEL のコミュニティ版であり、同様の機能と安定性を提供しますが、公式なサポートはありません。&lt;/p&gt;
&lt;h2 id=&#34;追記&#34;&gt;追記
&lt;/h2&gt;&lt;p&gt;この記事を執筆した時点では、2年後に自分が更新することなど想像もしていませんでした。先日、普段使っている仮想マシンをCentOS 8からCentOS 8 Streamにアップグレードしました。本番環境で何を選ぶかは、話す必要がないので詳しくは述べませんが、ローカル環境では最新版を追求したいと考えています。&lt;/p&gt;
&lt;p&gt;CentOS 8 Streamは、従来のCentOSよりも迅速なアップデートと新機能を提供するロールフィード版であり、開発やテスト環境での利用に適しています。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
