<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Linux on 向叔の手帳</title>
        <link>https://ttf248.life/ja/tags/linux/</link>
        <description>Recent content in Linux on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Mon, 02 Jun 2025 20:54:02 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/tags/linux/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Linuxバックエンドサービスの大量文字列データの処理 - 効率が悪い</title>
        <link>https://ttf248.life/ja/p/linux-backend-slow-string-processing/</link>
        <pubDate>Wed, 13 Nov 2024 19:42:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-backend-slow-string-processing/</guid>
        <description>&lt;p&gt;C++開発の歴史的なプロジェクトにおいて、カスタムプロトコルを使用して通信を行っており、そのプロトコルは2次元配列のパターンを採用していました。大量データを処理する際に、プロトコル内部では配列を遍历し、シリアライズ操作を実行してログを生成しており、このため効率が低く、システムが高負荷時に顕著なフレーム落ち（カドゥ）を引き起こしました。事業部門からは、システムのフレーム落ちに関するフィードバックがありました。&lt;/p&gt;
&lt;h2 id=&#34;問題の特定&#34;&gt;問題の特定
&lt;/h2&gt;&lt;p&gt;問題のトラブルシューティングにおいて、まずシステムに対してパフォーマンス分析を実施し、大量データを処理する際にCPU使用率が著しく増加し、システムの応答時間が長くなっていることを発見しました。ログを分析した結果、多数のシリアライズ操作が見られ、これらの操作は2次元配列を処理する際の効率が低いことが原因でシステム性能が低下していました。
&lt;code&gt;pstack&lt;/code&gt;ツールを使用してサービスのスレッド情報を取得し、ログスレッドが文字列の連結に大部分の時間を使用していることを特定しました。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;今日は重点的に取り組むべき点です。異なる累積方式では、その効率の違いは非常に大きいです。過去のコードでは &amp;lsquo;+&amp;rsquo; 演算子を使用しており、この方法は頻繁に一時オブジェクトを作成するため、非常に非効率的でした。それは、その非効率さがどの程度であるかを知らない状況にあるようなものです。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;デモ検証&#34;&gt;デモ検証
&lt;/h2&gt;&lt;p&gt;プロジェクトコードに基づいて、ビジネスロジックを抽出し、文字列連結の効率に関する問題を検証するためのシンプルなデモを作成しました。Windows環境ではVisual Studio 2022コンパイラ、Linux環境ではgcc8.5コンパイラを使用し、Releaseモードでビルドして実行することで、効率を比較します。&lt;/p&gt;
&lt;h3 id=&#34;キーポイントの説明&#34;&gt;キーポイントの説明
&lt;/h3&gt;&lt;p&gt;本プロジェクトで使用されたのは方法四であり、テストデータを入手する前に、どの方法が最も効率が良いか、最も効率が悪いかを読者が最初に考えてみるべきです。結果を見たときは、自分自身にとても驚きました。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;方法 1 (&lt;code&gt;+=&lt;/code&gt; による連結)&lt;/strong&gt;：各フィールドを &lt;code&gt;+=&lt;/code&gt; を使って文字列に直接連結します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法 2 (&lt;code&gt;std::ostringstream&lt;/code&gt; による連結)&lt;/strong&gt;：ストリーム（&lt;code&gt;std::ostringstream&lt;/code&gt;）を使用して各フィールドを連結する方法で、特に大量のデータを連結する場合に効率的です。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法 3 (事前にメモリを割り当てる &lt;code&gt;+=&lt;/code&gt; による連結)&lt;/strong&gt;：&lt;code&gt;reserve&lt;/code&gt; を使用して文字列に必要な十分なメモリを事前に割り当て、メモリ再割り当てのオーバーヘッドを削減することでパフォーマンスを向上させます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法 4 (&lt;code&gt;bodys = bodys + body + &amp;quot;\n&amp;quot;&lt;/code&gt;)&lt;/strong&gt;: 各連結で新しい一時的な文字列オブジェクトを作成するため、パフォーマンスが低下します。特に大規模な連結の場合、各連結において新しいメモリ割り当てとコピーが発生するためです。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参照結果から、プロジェクトはちょうど最も効率の悪い方法を選択していました。&lt;/p&gt;
&lt;p&gt;さらに詳しく分析すると、異なるプラットフォームコンパイラによる最適化効率を分析できます。Microsoft の &lt;code&gt;visual studio&lt;/code&gt; は従来通り優れており、文字列の最適化効率は非常に高いですが、&lt;code&gt;gcc&lt;/code&gt; コンパイラの最適化効率は少し劣ります。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;異なるマシンでコードを実行した場合、2つのデータセット間で直接比較する意味はありません。異なる連結方法間の差を比較できます。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;主要ポイント&#34;&gt;主要ポイント
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Windowsプラットフォーム下でのVisual Studio 2022コンパイラ

----------------------------------------
データ生成時間: 0.054秒。
----------------------------------------

----------------------------------------
データマージパフォーマンス:
----------------------------------------
+ データマージ (+=) にかかった時間: 0.053秒。
+ ostringstream データマージにかかった時間: 0.054秒。
+ 事前予約済みデータマージにかかった時間: 0.045秒。
+ データマージ (bodys = bodys + body + &amp;quot;\n&amp;quot;) にかかった時間: 16.108秒。

----------------------------------------
データマージ完了。
----------------------------------------

プログラム終了。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Linuxプラットフォーム下でのgcc8.5コンパイラ
----------------------------------------
データ生成時間: 0.108秒。
----------------------------------------

----------------------------------------
データマージパフォーマンス:
----------------------------------------
+ データマージ (+=) にかかった時間: 0.100秒。
+ ostringstream データマージにかかった時間: 0.083秒。
+ 事前予約済みデータマージにかかった時間: 0.057秒。
+ データマージ (bodys = bodys + body + &amp;quot;\n&amp;quot;) にかかった時間: 29.298秒。

----------------------------------------
データマージ完了。
----------------------------------------

プログラム終了。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完整コード&#34;&gt;完整コード
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;random&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;iomanip&amp;gt;

typedef std::vector&amp;lt;std::string&amp;gt; DataRow;
typedef std::vector&amp;lt;DataRow&amp;gt; DataGroup;

struct ResponsePackage
{
    std::string ErrorInfo;
    DataRow Head;
    std::string ClientId;
    std::string UUID;
    std::string MsgID;
    std::string SessionID;
    std::string ExtraInfo1;
    std::string ExtraInfo2;
    DataGroup DataBody;
};

// Generate specified length of random string
std::string generateRandomString(size_t length)
{
    const char charset[] = &amp;quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&amp;quot;;
    const size_t max_index = sizeof(charset) - 1;
    std::string random_string;
    random_string.reserve(length);

    std::random_device rd;
    std::mt19937 generator(rd());
    std::uniform_int_distribution&amp;lt;&amp;gt; distribution(0, max_index);

    for (size_t i = 0; i &amp;lt; length; ++i)
    {
        random_string += charset[distribution(generator)];
    }

    return random_string;
}

void create_large_string()
{
    // Example request package with 50 fields
    ResponsePackage requestPackage;

    requestPackage.Head = {
        &amp;quot;Field1&amp;quot;, &amp;quot;Field2&amp;quot;, &amp;quot;Field3&amp;quot;, &amp;quot;Field4&amp;quot;, &amp;quot;Field5&amp;quot;,
        &amp;quot;Field6&amp;quot;, &amp;quot;Field7&amp;quot;, &amp;quot;Field8&amp;quot;, &amp;quot;Field9&amp;quot;, &amp;quot;Field10&amp;quot;,
        &amp;quot;Field11&amp;quot;, &amp;quot;Field12&amp;quot;, &amp;quot;Field13&amp;quot;, &amp;quot;Field14&amp;quot;, &amp;quot;Field15&amp;quot;,
        &amp;quot;Field16&amp;quot;, &amp;quot;Field17&amp;quot;, &amp;quot;Field18&amp;quot;, &amp;quot;Field19&amp;quot;, &amp;quot;Field20&amp;quot;,
        &amp;quot;Field21&amp;quot;, &amp;quot;Field22&amp;quot;, &amp;quot;Field23&amp;quot;, &amp;quot;Field24&amp;quot;, &amp;quot;Field25&amp;quot;,
        &amp;quot;Field26&amp;quot;, &amp;quot;Field27&amp;quot;, &amp;quot;Field28&amp;quot;, &amp;quot;Field29&amp;quot;, &amp;quot;Field30&amp;quot;,
        &amp;quot;Field31&amp;quot;, &amp;quot;Field32&amp;quot;, &amp;quot;Field33&amp;quot;, &amp;quot;Field34&amp;quot;, &amp;quot;Field35&amp;quot;,
        &amp;quot;Field36&amp;quot;, &amp;quot;Field37&amp;quot;, &amp;quot;Field38&amp;quot;, &amp;quot;Field39&amp;quot;, &amp;quot;Field40&amp;quot;,
        &amp;quot;Field41&amp;quot;, &amp;quot;Field42&amp;quot;, &amp;quot;Field43&amp;quot;, &amp;quot;Field44&amp;quot;, &amp;quot;Field45&amp;quot;,
        &amp;quot;Field46&amp;quot;, &amp;quot;Field47&amp;quot;, &amp;quot;Field48&amp;quot;, &amp;quot;Field49&amp;quot;, &amp;quot;Field50&amp;quot;
    };

    requestPackage.ClientId = &amp;quot;ClientID&amp;quot;;
    requestPackage.UUID = &amp;quot;UUID&amp;quot;;
    requestPackage.MsgID = &amp;quot;MsgID&amp;quot;;
    requestPackage.SessionID = &amp;quot;SessionID&amp;quot;;
    requestPackage.ExtraInfo1 = &amp;quot;ExtraInfo1&amp;quot;;
    requestPackage.ExtraInfo2 = &amp;quot;ExtraInfo2&amp;quot;;

    // Start timing for data generation
    auto start_gen = std::chrono::high_resolution_clock::now();

    // Generate 10,000 rows of data, each with 50 fields
    for (size_t i = 0; i &amp;lt; 10000; ++i)
    {
        DataRow dataRow(50, &amp;quot;This is a test string&amp;quot;);
        requestPackage.DataBody.push_back(dataRow);
    }

    // End timing for data generation
    auto end_gen = std::chrono::high_resolution_clock::now();
    std::chrono::duration&amp;lt;double&amp;gt; duration_gen = end_gen - start_gen;

    // Display result generation time
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Generation Time: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_gen.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    // Data merging using different methods
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Performance:\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    {
        // Method 1: Using &#39;+=&#39; string concatenation
        auto start_merge = std::chrono

## 完全なコード
```json
{
        // Method 2: Using ostringstream
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::ostringstream bodys;
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::ostringstream body;
            body &amp;lt;&amp;lt; &amp;quot;This is a test string&amp;quot;;
            for (auto&amp;amp; item : vec)
            {
                body &amp;lt;&amp;lt; item &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            }
            bodys &amp;lt;&amp;lt; body.str() &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ ostringstream Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 3: Pre-allocated memory
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys;
        bodys.reserve(1000 * 50 * 20); // Pre-allocate enough memory
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            body.reserve(50 * 20); // Pre-allocate memory for each row
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Pre-reserved Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 4: Using &#39;bodys = bodys + body + &amp;quot;\n&amp;quot;&#39;
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body = body + item + &amp;quot; &amp;quot;; // Note the use of &#39;body = body + item&#39;
            }
            bodys = bodys + body + &amp;quot;\n&amp;quot;; // Again, using &#39;bodys = bodys + body&#39;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (bodys = bodys + body + \&amp;quot;\\n\&amp;quot;) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Complete.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;
}

int main()
{
    try
    {
        create_large_string();
    }
    catch (const std::exception&amp;amp; e)
    {
        std::cerr &amp;lt;&amp;lt; &amp;quot;Caught exception: &amp;quot; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\nProgram finished.\n&amp;quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>GCCバージョンをアップグレードした結果、プログラムがクラッシュしました：コードの非規整性による問題点</title>
        <link>https://ttf248.life/ja/p/gcc-upgrade-causes-program-crash-code-irregularities/</link>
        <pubDate>Sun, 10 Mar 2024 23:19:06 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/gcc-upgrade-causes-program-crash-code-irregularities/</guid>
        <description>&lt;p&gt;同一段業務コードにおいて、プログラムが CentOS 7 環境下で正常にコンパイルおよび実行されていたが、CentOS 8 に切り替えて GCC の最新版を使用してコンパイルを行った際に、プログラムがクラッシュが発生した。注目すべきは、問題が &lt;strong&gt;Release モード&lt;/strong&gt; 下でのみ発生し、&lt;strong&gt;Debug モード&lt;/strong&gt; では完全に問題がない点である。これは初めての事例であり、3日間の調査を経て、問題の原因を特定することができた。&lt;/p&gt;
&lt;h3 id=&#34;問題の特定&#34;&gt;問題の特定
&lt;/h3&gt;&lt;p&gt;一番の原因究明の結果、問題の本質は &lt;strong&gt;関数に返り値がないこと&lt;/strong&gt; にあります。リリースモードにおいて、GCCの新バージョンではより多くの最適化が行われるため、本来返り値のない関数が実行中に未知の論理が発生し、それがクラッシュを引き起こしました。結論として、&lt;strong&gt;コンパイラの警告を無視することは許されません。特に、古いプロジェクトにおいては、一部の警告が無視される可能性がありますが、すべての警告を無効にすることは避けるべきです&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;環境説明&#34;&gt;環境説明
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CentOS 7 GCCバージョン:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CentOS 8 GCCバージョン:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;クラッシュ現象&#34;&gt;クラッシュ現象
&lt;/h3&gt;&lt;p&gt;プログラムのクラッシュに関するスタックを分析した結果、以下のスタック情報が得られました：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[New LWP 1385902]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib64/libthread_db.so.1&amp;quot;.
Core was generated by `./pstack_main`.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007ffe894b4420 in ?? ()
(gdb) bt
#0  0x00007ffe894b4420 in ?? ()
#1  0x00000000004008e9 in main ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このスタックは直感的ではありません。クラッシュ関数のスタック情報が &lt;code&gt;??&lt;/code&gt; と表示されるため、問題の特定がさらに複雑になります。&lt;/p&gt;
&lt;h3 id=&#34;コード例&#34;&gt;コード例
&lt;/h3&gt;&lt;p&gt;問題をより良く理解するために、クラッシュを再現するための最小コード例を示します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int test() {
    std::cout &amp;lt;&amp;lt; &amp;quot;1&amp;quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    test();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このコード内の &lt;code&gt;test()&lt;/code&gt; 関数は明らかに値を明示的に返していません。また、その戻り値の型は &lt;code&gt;int&lt;/code&gt; です。C++ 仕様によると、関数が &lt;code&gt;int&lt;/code&gt; 型で宣言されている場合、必ず戻り値を持つ必要があり、そうでない場合は未定義動作を引き起こす可能性があります。&lt;/p&gt;
&lt;h3 id=&#34;コンパイル警告&#34;&gt;コンパイル警告
&lt;/h3&gt;&lt;p&gt;当方のプロジェクトにおいて、CMake スクリプトが多くのコンパイル時の警告を抑制しており、その中に以下の警告情報が含まれています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/root/pstack/main.cpp: In function ‘int test()’:
/root/pstack/main.cpp:7:1: warning: no return statement in function returning non-void [-Wreturn-type]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この警告は、&lt;code&gt;test()&lt;/code&gt; 関数が戻り値を持たないことを示しており、これがまさに問題の原因です。GCC の高バージョン（例：8.5.0）では、コードを最適化する際にこのような未定義の動作に対して不安定な最適化を行う可能性があり、プログラムがクラッシュする原因となることがあります。&lt;/p&gt;
&lt;h3 id=&#34;어셈블리-코드-차이점&#34;&gt;어셈블리 코드 차이점
&lt;/h3&gt;&lt;p&gt;GCC 컴파일러 최적화 동작의 차이를 설명하기 위해, 서로 다른 버전의 GCC가 생성한 어셈블리 코드를 비교했습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GCC 4.8.5 생성된 어셈블리 코드:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;어셈블리 코드가 다소 길고 표준 출력 스트림(예: &lt;code&gt;std::cout&lt;/code&gt;) 처리에 대한 로직을 포함하고 있습니다. 이는 컴파일러가 &lt;code&gt;test()&lt;/code&gt; 함수에서 누락된 반환 값 문제에 대해 과도하게 최적화하지 않았음을 나타내며, 이로 인해 잠재적으로 충돌을 피했을 수 있음을 시사합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GCC 8.5.0 생성된 어셈블리 코드:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;새로운 버전의 GCC는 더 많은 최적화를 수행하여 코드 양을 줄였습니다. 그러나 이러한 최적화가 누락된 반환 값을 갖는 함수의 실행 시 동작이 불확실하게 되어 프로그램 충돌을 유발할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;結論&#34;&gt;結論
&lt;/h3&gt;&lt;p&gt;今回の問題解決を通して、C++において&lt;strong&gt;関数が返す値は明確に定義されるべきである&lt;/strong&gt;という点を深く認識しました。特に、関数を&lt;code&gt;int&lt;/code&gt;型として宣言する場合、必ず戻り値を提示する必要があります。古いコンパイラ版を使用しているプロジェクトでGCCの新しいバージョンにアップグレードした場合、より多くの最適化や厳格な警告メカニズムが導入される可能性があります。そのため、コンパイル時に&lt;strong&gt;すべての警告を無効化しない&lt;/strong&gt;ことを推奨します。代わりに、関数が返す値、型の一致など、一般的な問題に対して選択的に対処する必要があります。
最終的に、&lt;code&gt;test()&lt;/code&gt;関数に戻り値を付与することで問題は解決し、プログラムは正常に動作するようになりました。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Linuxシステムベンチマークテスト</title>
        <link>https://ttf248.life/ja/p/linux-system-benchmark-test/</link>
        <pubDate>Tue, 09 Jan 2024 10:56:23 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-system-benchmark-test/</guid>
        <description>&lt;p&gt;Windows 平台上有鲁大师（娱乐大师），不能说数据很准，但总归有个参考，当然也有其他的专业跑分软件。到了 Linux 系统，好像一直没遇到特别合适的跑分软件。&lt;/p&gt;
&lt;p&gt;Sysbench 是一款多功能的基准测试工具，可用于测试 CPU、内存、文件 I/O、线程性能等。您可以使用 Sysbench 来执行各种性能测试任务。&lt;/p&gt;
&lt;p&gt;手头上刚好有三台机器用于测试：机械师 mini 本地小主机、阿里云 dev 开发云服务器、华为云开发服务器。&lt;/p&gt;
&lt;h2 id=&#34;sysbench-のインストール&#34;&gt;Sysbench のインストール
&lt;/h2&gt;&lt;p&gt;ほとんどの Linux ディストリビューションでは、パッケージマネージャを使用して Sysbench をインストールできます。例えば、CentOS 8 では、次のコマンドを使用します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo dnf install sysbench
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sysbenchの使用例&#34;&gt;Sysbenchの使用例
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CPU性能のテスト: &lt;code&gt;sysbench --test=cpu run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;メモリ読み取り性能のテスト: &lt;code&gt;sysbench --test=memory run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ファイルI/O性能のテスト:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysbench --test=fileio --file-test-mode=rndrw prepare
sysbench --test=fileio --file-test-mode=rndrw run
sysbench --test=fileio --file-test-mode=rndrw cleanup
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;マルチスレッド性能のテスト: &lt;code&gt;sysbench --test=threads --num-threads=4 run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;MySQLデータベース性能のテスト（最大接続数を調整する必要あり）：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword --oltp-table-size=1000000 prepare
sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword --max-time=60 --oltp-read-only=off --oltp-test-mode=complex --max-requests=0 run
sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword cleanup
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ランニングデータレポート&#34;&gt;ランニングデータレポート
&lt;/h2&gt;&lt;meta http-equiv=&#34;Content-Type&#34; content=&#34;text/html; charset=utf-8&#34;&gt;&lt;link type=&#34;text/css&#34; rel=&#34;stylesheet&#34; href=&#34;resources/sheet.css&#34; &gt;
&lt;h2 id=&#34;実行データレポート&#34;&gt;実行データレポート
&lt;/h2&gt;&lt;style type=&#34;text/css&#34;&gt;.ritz .waffle a { color: inherit; }.ritz .waffle .s0{background-color:#ffffff;text-align:left;color:#000000;font-family:&#39;Arial&#39;;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}&lt;/style&gt;&lt;div class=&#34;ritz grid-container&#34; dir=&#34;ltr&#34;&gt;&lt;table class=&#34;waffle&#34; cellspacing=&#34;0&#34; cellpadding=&#34;0&#34;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th class=&#34;row-header freezebar-origin-ltr&#34;&gt;&lt;/th&gt;&lt;th id=&#34;0C0&#34; style=&#34;width:100px;&#34; class=&#34;column-headers-background&#34;&gt;A&lt;/th&gt;&lt;th id=&#34;0C1&#34; style=&#34;width:421px;&#34; class=&#34;column-headers-background&#34;&gt;B&lt;/th&gt;&lt;th id=&#34;0C2&#34; style=&#34;width:398px;&#34; class=&#34;column-headers-background&#34;&gt;C&lt;/th&gt;&lt;th id=&#34;0C3&#34; style=&#34;width:422px;&#34; class=&#34;column-headers-background&#34;&gt;D&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R0&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;1&lt;/div&gt;&lt;/th&gt;&lt;td&gt;&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;ローカル機械師&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;阿里云&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;华为云&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R1&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;2&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;システム構成&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;システム情報&lt;br&gt;  オペレーティングシステム              Ubuntu 23.04&lt;br&gt;  カーネル                        Linux 6.2.0-36-generic x86_64&lt;br&gt;  モデル                         Machenike Machenike DT Computer&lt;br&gt;  マザーボード                   Machenike Machenike DT Computer&lt;br&gt;  BIOS                          American Megatrends International, LLC.&lt;br&gt;DB19V012&lt;br&gt;&lt;br&gt;CPU情報&lt;br&gt;  名前                          Intel Core i7-12650H&lt;br&gt;  トポロジー                      1 プロセッサ、10 コア、16 スレッド&lt;br&gt;  識別子                    GenuineIntel Family 6 Model 154 Stepping 3&lt;br&gt;  ベース周波数                4.60 GHz&lt;br&gt;  L1 命令キャッシュ          32.0 KB x 8&lt;br&gt;  L1 データキャッシュ                 48.0 KB x 8&lt;br&gt;  L2 キャッシュ                      1.25 MB x 2&lt;br&gt;  L3 キャッシュ                      24.0 MB&lt;br&gt;&lt;br&gt;メモリ情報&lt;br&gt;  サイズ                          62.6 GB&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;システム情報&lt;br&gt;  オペレーティングシステム              CentOS Stream 8&lt;br&gt;  カーネル                        Linux 4.18.0-513.el8.x86_64 x86_64&lt;br&gt;  モデル                         Alibaba Cloud Alibaba Cloud ECS&lt;br&gt;  マザーボード                   N/A&lt;br&gt;  BIOS                          SeaBIOS 449e491&lt;br&gt;&lt;br&gt;CPU情報&lt;br&gt;  名前                          Intel(R) Xeon(R) Platinum&lt;br&gt;  トポロジー                      1 プロセッサ、1 コア、2 スレッド&lt;br&gt;  識別子                    GenuineIntel Family 6 Model 85 Stepping 4&lt;br&gt;  ベース周波数                2.50 GHz&lt;br&gt;  L1 命令キャッシュ          32.0 KB&lt;br&gt;  L1 データキャッシュ                 32.0 KB&lt;br&gt;  L2 キャッシュ                      1.00 MB&lt;br&gt;  L3 キャッシュ                      33.0 MB&lt;br&gt;&lt;br&gt;メモリ情報&lt;br&gt;  サイズ                          1.65 GB&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;システム情報&lt;br&gt;  オペレーティングシステム              Ubuntu 22.04.1 LTS&lt;br&gt;  カーネル                        Linux 5. - 64 GB
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;実行データレポート
system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;テストの実行方法：指定されたオプションで&lt;br&gt;スレッド数: 1&lt;br&gt;乱数ジェネレーターを現在の時間から初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;素数の制限: 10000&lt;br&gt;&lt;br&gt;ワーカーのスレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドが開始されました!&lt;br&gt;&lt;br&gt;CPU速度:&lt;br&gt;    毎秒イベント数: 4032.48&lt;br&gt;&lt;br&gt;一般的な統計情報:&lt;br&gt;    合計時間: 10.0004秒&lt;br&gt;    イベントの総数: 40330&lt;br&gt;&lt;br&gt;遅延 (ms):&lt;br&gt;         最小値: 0.25&lt;br&gt;         平均値: 0.25&lt;br&gt;         最大値: 0.73&lt;br&gt;         95パーセンタイル: 0.25&lt;br&gt;         合計: 9997.55&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント (平均/標準偏差): 40330.0000/0.00&lt;br&gt;    実行時間 (平均/標準偏差): 9.9975/0.00&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;データマイニング&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ディープラーニング&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ニューラルネットワーク - 実行データレポート
system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;テストの実行方法：指定されたオプションで&lt;br&gt;スレッド数: 1&lt;br&gt;乱数ジェネレーターを現在の時間から初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;素数の制限: 10000&lt;br&gt;&lt;br&gt;ワーカーのスレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドが開始されました!&lt;br&gt;&lt;br&gt;CPU速度:&lt;br&gt;    毎秒イベント数: 4032.48&lt;br&gt;&lt;br&gt;一般的な統計情報:&lt;br&gt;    合計時間: 10.0004秒&lt;br&gt;    合計イベント数: 40330&lt;br&gt;&lt;br&gt;遅延 (ms):&lt;br&gt;         最小: 0.25&lt;br&gt;         平均: 0.25&lt;br&gt;         最大: 0.73&lt;br&gt;         95パーセンタイル: 0.25&lt;br&gt;         合計: 9997.55&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント (平均/標準偏差): 40330.0000/0.00&lt;br&gt;    実行時間 (平均/標準偏差): 9.9975/0.00&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sysbench 1.0.20 (system LuaJIT 2.1.0-beta3を使用)&lt;br&gt;&lt;br&gt;テストの実行方法：指定されたオプションで&lt;br&gt;スレッド数: 1&lt;br&gt;乱数ジェネレーターを現在の時間から初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;素数の制限: 10000&lt;br&gt;&lt;br&gt;ワーカーのスレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドが開始されました!&lt;br&gt;&lt;br&gt;CPU速度:&lt;br&gt;    毎秒イベント数: 1062.51&lt;br&gt;&lt;br&gt;一般的な統計情報:&lt;br&gt;    合計時間: 10.0008秒&lt;br&gt;    合計イベント数: 10628&lt;br&gt;&lt;br&gt;遅延 (ms):&lt;br&gt;         最小: 0.91&lt;br&gt;         平均: 0.94&lt;br&gt;         最大: 22.84&lt;br&gt;         95パーセンタイル: 1.06&lt;br&gt;         合計: 9993.46&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント (平均/標準偏差): 10628.0000/0.00&lt;br&gt;    実行時間 (平均/標準偏差): 9.9935/0.00&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sysbench 1.0.20 (system LuaJIT 2.1.0-beta3を使用)&lt;br&gt;&lt;br&gt;テストの実行方法：指定されたオプションで&lt;br&gt;スレッド数: 1&lt;br&gt;乱数ジェネレーターを現在の時間から初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;素数の制限: 10000&lt;br&gt;&lt;br&gt;ワーカーのスレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドが開始されました!&lt;br&gt;&lt;br&gt;CPU速度:&lt;br&gt;    毎秒イベント数: 1125.56&lt;br&gt;&lt;br&gt;一般的な統計情報:&lt;br&gt;    合計時間: 10.0005秒&lt;br&gt;    合計イベント数: 11258&lt;br&gt;&lt;br&gt;遅延 (ms):&lt;br&gt;         最小: 0.86&lt;br&gt;         平均: 0.89&lt;br&gt;         最大: 1.70&lt;br&gt;         95パーセンタイル: 0.99&lt;br&gt;         合計: 9995.40&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント (平均/標準偏差): 11258.0000/0.00&lt;br&gt;    実行時間 (平均/標準偏差): 9.9954/0.00&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;メモリテストを実行するオプション：指定されたオプションで&lt;br&gt;ブロックサイズ: 1KiB&lt;br&gt;合計サイズ: 102400MiB&lt;br&gt;操作: 書き込み&lt;br&gt;範囲: グローバル&lt;br&gt;&lt;br&gt;ワーカーのスレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドが開始されました!&lt;br&gt;&lt;br&gt;総イベント数: 101993199 (10198146.52/秒)&lt;br&gt;&amp;lt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ランダム数生成レポート&#34;&gt;ランダム数生成レポート
&lt;/h2&gt;&lt;p&gt;現在の時刻からの乱数ジェネレーター&lt;br&gt;&lt;br&gt;&lt;br&gt;次のオプションでメモリ速度テストを実行中:&lt;br&gt;  ブロックサイズ：1KiB&lt;br&gt;  合計サイズ：102400MiB&lt;br&gt;  操作：書き込み&lt;br&gt;  範囲：グローバル&lt;br&gt;&lt;br&gt;ワーカースレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッド開始!&lt;br&gt;&lt;br&gt;総操作数：48418803 (1秒あたり4841004.79)&lt;br&gt;&lt;br&gt;転送されたデータ：47283.99 MiB (1秒あたり4727.54 MiB)&lt;br&gt;&lt;br&gt;&lt;br&gt;一般的な統計:&lt;br&gt;    合計時間：                          10.0001s&lt;br&gt;    イベント総数：              48418803&lt;br&gt;&lt;br&gt;レイテンシ（ms）：&lt;br&gt;         最小：                                    0.00&lt;br&gt;         平均：                                    0.00&lt;br&gt;         最大：                                   25.26&lt;br&gt;         95パーセンタイル：                        0.00&lt;br&gt;         合計：                                 4578.95&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント（平均/標準偏差）：           48418803.0000/0.00&lt;br&gt;    実行時間（平均/標準偏差）：   4.5789/0.00&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;ランニングテストで次のオプションを使用中：&lt;br&gt;スレッド数：1&lt;br&gt;現在の時刻からの乱数ジェネレーターの初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;追加ファイルオープンフラグ：（なし）&lt;br&gt;128ファイル、各16MiB&lt;br&gt;2GiBの合計ファイルサイズ&lt;br&gt;ブロックサイズ 16KiB&lt;br&gt;IOリクエスト数：0&lt;br&gt;組み合わせてランダムIOテストの読み取り/書き込み比率：1.50&lt;br&gt;定期的なFSYNCが有効になっており、各100リクエストごとにfsync()を呼び出しています。&lt;br&gt;テストの最後にfsync()を呼び出すことが有効になっています。&lt;br&gt;同期I/Oモードを使用&lt;br&gt;ランダムな読み取り/書き込みテストを実行中&lt;br&gt;ワーカースレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッド開始!&lt;br&gt;&lt;br&gt;&lt;br&gt;ファイル操作：&lt;br&gt;    読み取り/秒：                      3373.41&lt;br&gt;    書き込み/秒：                     2248.94&lt;br&gt;    fsync/秒：                     7201.80&lt;br&gt;&lt;br&gt;スループット：&lt;br&gt;    読み取り、MiB/s：                  52.71&lt;br&gt;    書き込み、MiB/s：               35.14&lt;br&gt;&lt;br&gt;一般的な統計：&lt;br&gt;    合計時間：                          10.0127s&lt;br&gt;    イベント総数：              128288&lt;br&gt;&lt;br&gt;レイテンシ（ms）：&lt;br&gt;         最小：                                    0.00&lt;br&gt;         平均：                                    0.08&lt;br&gt;         最大：                                    5.14&lt;br&gt;         95パーセンタイル：                        0.34&lt;br&gt;         合計：                                 9977.78&lt;br&gt;&lt;br&gt;スレッドの公平性：&lt;br&gt;    イベント（平均/標準偏差）：           128288.0000/0.00&lt;br&gt;    実行時間（平均/標準偏差）：   9.9778/0.00&lt;/p&gt;
&lt;p&gt;スループット：&lt;br&gt;    読み取り、MiB/s：                  52.71&lt;br&gt;    書き込み、MiB/s：               35.14&lt;br&gt;&lt;br&gt;一般的な統計：&lt;br&gt;    合計時間：                          10.0127s&lt;br&gt;    イベント総数：              128288&lt;br&gt;&lt;br&gt;レイテンシ（ms）：&lt;br&gt;         最小：                                    0.00&lt;br&gt;         平均：                                    0.08&lt;br&gt;         最大：                                    5.14&lt;br&gt;         95パーセンタイル：                        0.34&lt;br&gt;         合計：                                 9977.78&lt;br&gt;&lt;br&gt;スレッドの公平性：&lt;br&gt;    イベント（平均/標準 ## ランダム数生成データレポート
現在の時刻からの乱数ジェネレーター&lt;br&gt;&lt;br&gt;&lt;br&gt;次のオプションでメモリ速度テストを実行中:&lt;br&gt;  ブロックサイズ：1KiB&lt;br&gt;  合計サイズ：102400MiB&lt;br&gt;  操作：書き込み&lt;br&gt;  範囲：グローバル&lt;br&gt;&lt;br&gt;ワーカースレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッド開始!&lt;br&gt;&lt;br&gt;総操作数：48418803 (1秒あたり4841004.79)&lt;br&gt;&lt;br&gt;転送されたデータ：47283.99 MiB (1秒あたり4727.54 MiB)&lt;br&gt;&lt;br&gt;&lt;br&gt;一般的な統計:&lt;br&gt;    合計時間：                          10.0001s&lt;br&gt;    イベント総数：              48418803&lt;br&gt;&lt;br&gt;遅延（ms）：&lt;br&gt;         最小：                                    0.00&lt;br&gt;         平均：                                    0.00&lt;br&gt;         最大：                                   25.26&lt;br&gt;         95パーセンタイル：                        0.00&lt;br&gt;         合計：                                 4578.95&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント（平均/標準偏差）：           48418803.0000/0.00&lt;br&gt;    実行時間（平均/標準偏差）：   4.5789/0.00&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;テストオプションで実行中:&lt;br&gt;スレッド数：1&lt;br&gt;現在の時刻からの乱数ジェネレーターの初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;追加ファイルオープンフラグ：（なし）&lt;br&gt;128ファイル、各16MiB&lt;br&gt;2GiBの合計ファイルサイズ&lt;br&gt;ブロックサイズ 16KiB&lt;br&gt;IOリクエスト数：0&lt;br&gt;組み合わせてランダムIOテストの読み取り/書き込み比率：1.50&lt;br&gt;定期的なFSYNCが有効になり、各100リクエストごとにfsync()が呼び出されます。&lt;br&gt;テストの終了時にfsync()を呼び出す。有効になっています。&lt;br&gt;同期I/Oモードを使用&lt;br&gt;ランダムな読み取り/書き込みテストを実行中&lt;br&gt;ワーカースレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッド開始!&lt;br&gt;&lt;br&gt;&lt;br&gt;ファイル操作:&lt;br&gt;    読み取り/秒：                      3373.41&lt;br&gt;    書き込み/秒：                     2248.94&lt;br&gt;    fsync/秒：                     7201.80&lt;br&gt;&lt;br&gt;スループット:&lt;br&gt;    読み取り、MiB/s：                  52.71&lt;br&gt;    書き込み、MiB/s：               35.14&lt;br&gt;&lt;br&gt;一般的な統計:&lt;br&gt;    合計時間：                          10.0127s&lt;br&gt;    イベント総数：              128288&lt;br&gt;&lt;br&gt;遅延（ms）：&lt;br&gt;         最小：                                    0.00&lt;br&gt;         平均：                                    0.08&lt;br&gt;         最大：                                    5.14&lt;br&gt;         95パーセンタイル：                        0.34&lt;br&gt;         合計：                                 9977.78&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント（平均/標準偏差）：           128288.0000/0.00&lt;br&gt;    実行時間（平均/標準偏差）：   9.9778/0.00&lt;/p&gt;
&lt;p&gt;スループット：
読み取り、MiB/s： 52.71
書き込み、MiB/s： 35.14&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;ディスク: 2147483648 バイトを 1.81 秒で書き込みました (1129.59 MiB/秒)。&lt;br&gt;&lt;br&gt;テストオプションで実行中:&lt;br&gt;スレッド数：1&lt;br&gt;現在の時刻からの乱数ジェネレーターの初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;追加ファイルオープンフラグ：（なし）&lt;br&gt;128ファイル、各16MiB&lt;br&gt;2GiBの合計ファイルサイズ&lt;br&gt;ブロックサイズ 16KiB&lt;br&gt;IOリクエスト数：0&lt;br&gt;組み合わせてランダムIOテストの読み取り/書き込み比率：1.&lt;/p&gt;
&lt;h2 id=&#34;実行データレポート-1&#34;&gt;実行データレポート
&lt;/h2&gt;&lt;p&gt;enabled, 各100リクエストごとにfsync()を呼び出す。&lt;br&gt;テストの終了時にfsync()を呼び出し、有効化。&lt;br&gt;同期I/Oモードを使用中&lt;br&gt;ランダムなr/wテストを実行中&lt;br&gt;ワーカースレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドが開始されました!&lt;br&gt;&lt;br&gt;&lt;br&gt;ファイル操作:&lt;br&gt;    読み込み/秒:                      1593.12&lt;br&gt;    書き込み/秒:                     1062.08&lt;br&gt;    fsync/秒:                     3406.64&lt;br&gt;&lt;br&gt;帯域幅:&lt;br&gt;    読み取り (MiB/s):                  24.89&lt;br&gt;    書き込み (MiB/s):               16.60&lt;br&gt;&lt;br&gt;一般的な統計:&lt;br&gt;    合計時間:                          10.0164秒&lt;br&gt;    イベント総数:              60600&lt;br&gt;&lt;br&gt;レイテンシ (ms):&lt;br&gt;         最小:                                    0.00&lt;br&gt;         平均:                                    0.16&lt;br&gt;         最大:                                   31.32&lt;br&gt;         95パーセンタイル:                        0.54&lt;br&gt;         合計:                                 9956.30&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント (平均/標準偏差):           60600.0000/0.00&lt;br&gt;    実行時間 (平均/標準偏差):   9.9563/0.00&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;2147483648 バイトを 18.29 秒で書き込みました (111.98 MiB/秒)。&lt;br&gt;&lt;br&gt;以下のオプションでテストを実行中:&lt;br&gt;スレッド数: 1&lt;br&gt;現在の時刻から乱数ジェネレーターを初期化&lt;br&gt;&lt;br&gt;&lt;br&gt;追加のファイルオープンフラグ:(なし)&lt;br&gt;128 ファイル、各 16MiB&lt;br&gt;2GiB の合計ファイルサイズ&lt;br&gt;ブロックサイズ 16KiB&lt;br&gt;IO リクエスト数: 0&lt;br&gt;ランダムな IO テストの読み取り/書き込み比率: 1.50&lt;br&gt;定期的な FS INC を有効にし、各 100 リクエストごとに fsync() を呼び出す。&lt;br&gt;テストの終了時に fsync() を呼び出し、有効化。&lt;br&gt;同期 I/O モードを使用中&lt;br&gt;ランダムな r/w テストを実行中&lt;br&gt;ワーカースレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;スレッドが開始されました!&lt;br&gt;&lt;br&gt;&lt;br&gt;ファイル操作:&lt;br&gt;    読み込み/秒:                      1665.88&lt;br&gt;    書き込み/秒:                     1110.59&lt;br&gt;    fsync/秒:                     3563.77&lt;br&gt;&lt;br&gt;帯域幅:&lt;br&gt;    読み取り (MiB/s):                  26.03&lt;br&gt;    書き込み (MiB/s):               17.35&lt;br&gt;&lt;br&gt;一般的な統計:&lt;br&gt;    合計時間:                          10.0112秒&lt;br&gt;    イベント総数:              63355&lt;br&gt;&lt;br&gt;レイテンシ (ms):&lt;br&gt;         最小:                                    0.00&lt;br&gt;         平均:                                    0.16&lt;br&gt;         最大:                                  205.01&lt;br&gt;         95パーセンタイル:                        0.78&lt;br&gt;         合計:                                 9972.64&lt;br&gt;&lt;br&gt;スレッドの公平性:&lt;br&gt;    イベント (平均/標準偏差):           63355.0000/0.00&lt;br&gt;    実行時間 (平均/標準偏差):   9.9726/0.00&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;スレッド数: 4
初期化されたランダムな数値ジェネレーターから現在の時刻を初期化&amp;hellip;&lt;br&gt;&lt;br&gt;ワーカースレッドが開始されました!&lt;br&gt;&lt;br&gt;&lt;br&gt;一般的な統計:&lt;br&gt;    合計時間:                          10.0002秒&lt;br&gt;    イベント総数:              197956&lt;br&gt;&lt;br&gt;レイテンシ (ms):&lt;br&gt;         最小:                                    0.16&lt;br&gt;         平均:                                    0.20&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;実行結果レポート&#34;&gt;実行結果レポート
&lt;/h2&gt;&lt;p&gt;合計: 40050.41&lt;br&gt;&lt;br&gt;スレッド公平性:&lt;br&gt;  イベント (平均/標準偏差): 4590.0000/94.36&lt;br&gt;  実行時間 (平均/標準偏差): 10.0126/0.00&lt;/p&gt;
&lt;p&gt;テスト実行時のオプション:
スレッド数: 4
現在の時刻から乱数生成器を初期化
&lt;br&gt;&lt;br&gt;&lt;br&gt;ワーカースレッドの初期化&amp;hellip;&lt;br&gt;&lt;br&gt;
スレッド起動!&lt;br&gt;&lt;br&gt;&lt;br&gt;
一般統計:
合計時間: 10.0004秒
合計イベント数: 28536&lt;br&gt;&lt;br&gt;遅延 (ms):
最小: 0.23
平均: 1.40
最大: 3.56
95パーセンタイル: 1.47
合計: 39975.16&lt;br&gt;&lt;br&gt;スレッド公平性:
イベント (平均/標準偏差): 7134.0000/39.87
実行時間 (平均/標準偏差): 9.9938/0.01&lt;/p&gt;
&lt;h2 id=&#34;追記&#34;&gt;追記
&lt;/h2&gt;&lt;p&gt;ChatGPTは依然として優れたものですが、以前習得していたMarkdownで完全にテーブルを作成できず、テーブルとして表示すると効果が著しく低下します。カスタムテーマによってページの最大幅が制限されるため、幅を百分率制に調整しました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;簡単な方法としては、TablesGeneratorのようなオンラインツールを使用してHTMLテーブルを生成する方法がありますが（内容が複雑だと不向きです）。&lt;/li&gt;
&lt;li&gt;または、Googleドキュメントで作成し、HTMLドキュメントとしてダウンロードして保存し、ブログに直接コピーする方法を採用しました（シンプルかつ直接的です）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;configの設定でunsafeな設定項目を有効にし、ページごとの幅設定を個別に指定するようにしてください。Hugoでは、ページごとに個別に幅を設定できます。これは、ページのFront Matterにカスタムパラメータを追加することで実現できます。以下はその例です。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MarkdownファイルのFront Matterセクション（通常はファイルの冒頭部分）にカスタムパラメータ（例えば&lt;code&gt;custom_width&lt;/code&gt;）を追加します：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;---
title: &amp;quot;私のページ&amp;quot;
date: 2024-01-09
custom_width: &amp;quot;800px&amp;quot;  # 幅を800ピクセルに設定
---

本文内容...
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Hugoのテーマで、対応する単一ページテンプレートファイル（例えば&lt;code&gt;layouts/_default/single.html&lt;/code&gt;）を見つけてください。&lt;/li&gt;
&lt;li&gt;単一ページテンプレート内で、Front Matterに&lt;code&gt;custom_width&lt;/code&gt;パラメータが存在するか確認し、それを適切なHTML要素（例えば&lt;code&gt;div&lt;/code&gt;）に適用します：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{{ define &amp;quot;main&amp;quot; }}
  &amp;lt;div style=&amp;quot;max-width: {{ with .Params.custom_width }}{{ . }}{{ else }}100%{{ end }}; margin: 0 auto;&amp;quot;&amp;gt;
    {{ .Content }}
  &amp;lt;/div&amp;gt;
{{ end }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この例では、内联スタイル（&lt;code&gt;style&lt;/code&gt;属性）を使用して&lt;code&gt;div&lt;/code&gt;要素の&lt;code&gt;max-width&lt;/code&gt;属性を設定し、&lt;code&gt;custom_width&lt;/code&gt;パラメータが指定されていない場合、幅をデフォルトで100%にしています。&lt;code&gt;margin: 0 auto;&lt;/code&gt;は&lt;code&gt;div&lt;/code&gt;要素を中央揃えにします。&lt;/p&gt;
&lt;p&gt;実際のアプリケーションでは、テーマの構造やCSSスタイルの詳細に応じて、上記の例を調整する必要がある場合があります。スタイルを調整する際には、テーマの一貫性と可読性を維持するようにしてください。&lt;/p&gt;
&lt;p&gt;最後に、使用しているテーマが若干異なるため、サイト全体でカスタムCSSの設定も調整しました。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Dockerの基礎を理解するための３つのポイント (または、Dockerの基本を理解するための３つのこと)</title>
        <link>https://ttf248.life/ja/p/docker-two-three-things/</link>
        <pubDate>Thu, 21 Jan 2021 09:26:07 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/docker-two-three-things/</guid>
        <description>&lt;p&gt;長年携わってきたのは &lt;code&gt;CentOS&lt;/code&gt; オペレーティングシステムであり、&lt;code&gt;mac&lt;/code&gt; ユーザーや &lt;code&gt;Ubuntu&lt;/code&gt; ユーザーの場合、一部の内容は適用できない。
インストールに関する部分は、清華大学のドキュメントを参照するのが参考になる：&lt;a class=&#34;link&#34; href=&#34;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;インストール&#34;&gt;インストール
&lt;/h2&gt;&lt;p&gt;未知の神秘的な力により、国内でのDockerのインストールには、クラウドプロバイダーが提供するレジストリのアドレスを設定することを推奨します。ここでは&lt;strong&gt;Alibaba Cloud&lt;/strong&gt;を使用することをお勧めします。&lt;/p&gt;
&lt;h3 id=&#34;リポジトリソースの設定&#34;&gt;リポジトリソースの設定
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install yum-utils device-mapper-persistent-data lvm2 &amp;amp;&amp;amp; \
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;最新版のインストール&#34;&gt;最新版のインストール
&lt;/h3&gt;&lt;p&gt;Dockerは一般的なバックエンドサービスとして、起動時に自動で開始されるように設定することを推奨します。以下のコマンドはCentOS 7向けです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum install -y docker-ce docker-ce-cli containerd.io &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;指定バージョン展開&#34;&gt;指定バージョン展開
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;kubernetes&lt;/code&gt;および&lt;code&gt;docker&lt;/code&gt;のリリースは完全に同期されておらず、今後&lt;code&gt;kubernetes&lt;/code&gt;を展開する場合は、&lt;code&gt;kubernetes&lt;/code&gt;展開手順を参照し、指定バージョンの&lt;code&gt;docker&lt;/code&gt;をインストールしてください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum list docker-ce --showduplicates | sort -r
sudo yum install -y docker-ce-18.09.2-3.el7 docker-ce-cli-18.09.2-3.el7 containerd.io-18.09.2-3.el7 &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;通常ユーザーにdocker権限を追加する&#34;&gt;通常ユーザーにDocker権限を追加する
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo usermod -aG docker ${USER}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;卸載&#34;&gt;卸載
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum remove -y docker-ce docker-ce-cli containerd.io
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;日常使用-にちじょうしよう&#34;&gt;日常使用 (にちじょうしよう)
&lt;/h2&gt;&lt;h3 id=&#34;镜像加速&#34;&gt;镜像加速
&lt;/h3&gt;&lt;p&gt;未知の神秘的な力により、イメージの取得時に速度が低下することがあります。この問題を解決するために、国内のクラウドプロバイダーが多くの加速サービスを提供し、引き続き&lt;strong&gt;阿里云&lt;/strong&gt;を推奨します。&lt;/p&gt;
&lt;p&gt;加速用のURLは、ご自身の登録した阿里云アカウントで取得してください。このサービスは無料で利用でき、阿里云からは無料のイメージ構築サービスも提供されています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt; /etc/docker/daemon.json &amp;lt;&amp;lt;EOF
{
  &amp;quot;registry-mirrors&amp;quot;: [
    &amp;quot;https://docker.nju.edu.cn&amp;quot;,
    &amp;quot;https://mirror.baidubce.com&amp;quot;,
    &amp;quot;https://docker.m.daocloud.io&amp;quot;,
    &amp;quot;https://docker.mirrors.sjtug.sjtu.edu.cn&amp;quot;
  ]
}
EOF
systemctl daemon-reload &amp;amp;&amp;amp; \
systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;強く推奨されるコントロールパネル&#34;&gt;強く推奨されるコントロールパネル
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker volume create portainer_data &amp;amp;&amp;amp; \
docker run -d --name=portainer --restart=always -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:2.20.3-alpine
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;常用イメージの取得集&#34;&gt;常用イメージの取得集
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker pull rancher/rancher:stable &amp;amp;&amp;amp; docker pull portainer/portainer-ce:2.0.1 &amp;amp;&amp;amp; \
docker pull centos:7 &amp;amp;&amp;amp; docker pull ubuntu:20.04 &amp;amp;&amp;amp; docker pull ubuntu:18.04 &amp;amp;&amp;amp; \
docker pull redis:5 &amp;amp;&amp;amp; docker pull redis:6 &amp;amp;&amp;amp; \
docker pull alpine:3.11 &amp;amp;&amp;amp; docker pull busybox:1.32 &amp;amp;&amp;amp; \
docker pull rabbitmq:3.7-management &amp;amp;&amp;amp; \
docker pull mariadb:10.2 &amp;amp;&amp;amp; \
docker pull nginx:1.18 &amp;amp;&amp;amp; docker pull nginx:1.19 &amp;amp;&amp;amp; \
docker pull mysql:5.6 &amp;amp;&amp;amp; docker pull mysql:8 &amp;amp;&amp;amp; \
docker pull elasticsearch:6.8.11 &amp;amp;&amp;amp; docker pull logstash:6.8.11 &amp;amp;&amp;amp; docker pull kibana:6.8.11 &amp;amp;&amp;amp; \
docker pull zookeeper:3.4 &amp;amp;&amp;amp; \
docker pull influxdb:1.7 &amp;amp;&amp;amp; docker pull grafana/grafana:7.3.1 &amp;amp;&amp;amp; \
docker pull percona:8 &amp;amp;&amp;amp; docker pull percona:5.6 &amp;amp;&amp;amp; \
docker pull cloverzrg/frps-docker:0.34.3 &amp;amp;&amp;amp; docker pull cloverzrg/frpc-docker:0.34.3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;常用コマンドの組み合わせ&#34;&gt;常用コマンドの組み合わせ
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/engine/reference/commandline/docker/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.docker.com/engine/reference/commandline/docker/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;コンテナの実行状態を確認し、&lt;code&gt;format&lt;/code&gt;パラメータを追加して詳細なコンテナ情報を取得（イメージ情報は無視）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker ps --format &amp;quot;{{.Names}}: {{.Ports}}: {{.Size}}&amp;quot;
#portainer: 0.0.0.0:8000-&amp;gt;8000/tcp, 0.0.0.0:9000-&amp;gt;9000/tcp: 0B (virtual 172MB)
#influxdb: 0.0.0.0:8086-&amp;gt;8086/tcp: 183B (virtual 311MB)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;すべてのコンテナをワンクリックで停止&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker stop $(docker ps -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;すべてのイメージをワンクリックで削除&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dokcer rmi $(docker images -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;イメージのエクスポート&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; &amp;gt; -o XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;イメージをエクスポートして圧縮&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; | gzip &amp;gt; XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;イメージをインポート&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker load -i XXX.tar
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>LinuxでJMeterの負荷テスト環境を構築する</title>
        <link>https://ttf248.life/ja/p/linux-setup-jmeter-testing-environment/</link>
        <pubDate>Tue, 22 Dec 2020 10:12:50 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-setup-jmeter-testing-environment/</guid>
        <description>&lt;p&gt;著者はハードウェアに強い関心を持ち、JMeterを用いて負荷テストを実施し、CentOS 7上にJMeter、InfluxDB、Grafanaをデプロイするプロセスを記録しました。JMeterのインストールとコマンドの使用方法、InfluxDBの特徴とDockerによるインストール方法、Grafanaの簡易的なデプロイと設定について共有しています。高性能プログラムモードに関する経験や参考資料をまとめました。&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;広く知られているように&lt;/code&gt;、私にはハードウェアに対する強い関心が持っており、テストグループが &lt;code&gt;JMeter&lt;/code&gt; を使用して負荷テストを行っている際に、パフォーマンスが向上しないことを発見しました。好奇心旺盛な私は、会社の負荷テストの方法を試してみることに決意しました。また、ある頃合いにオープンソース中国で、より洗練された高性能のパフォーマンス測定グラフを作成する方法に関する投稿を読んだことがあります。&lt;code&gt;Windows&lt;/code&gt;版でのテスト実行時に、可視化された &lt;code&gt;TPS&lt;/code&gt; データの表示を実現しており、Webパネルを設定することでどのような効果があるのか疑問に思っていました。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;頭の中で思いついたのは、当然のことばかりです。実際に試してみないとしかたないことを理解します。
負荷テストには GUI モードを使用しないでください！ テスト作成とデバッグのみに使用してください。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;背景-1&#34;&gt;背景
&lt;/h2&gt;&lt;p&gt;公式推奨は、コマンドラインで負荷テストレポートを取得し、GUIで表示する方法ですが、データに誤差が含まれているという問題があります。JMeterの理解が十分ではないため、少なくとも&lt;code&gt;Linux&lt;/code&gt;版のコンソールパネルを弄り転げる理由を見つけたいと思います。&lt;/p&gt;
&lt;p&gt;開かれた中国（オープンチャイナ）の投稿では、コアコンポーネントのデプロイメント方法があまりにも友好的ではなく、インストールに必要なファイルは公众号を通じてダウンロードする必要があり、現代的な若者として、もちろん&lt;code&gt;Docker&lt;/code&gt;で代替します。要するに、サーバーは国内であり、国境を越えたソースアドレスへのアクセス速度が遅いため、少なくともイメージサービスとしては、阿里云には無料の加速があります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker&lt;/code&gt; のインストールとデプロイメントについては、ここでは詳細な説明を省略し、以前の記事を参照してください。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;次の内容は、2つの主要な領域に分かれています：基本的なテスト環境コンポーネントの構築、および各コンポーネントの簡単な認識の説明&lt;/p&gt;
&lt;h2 id=&#34;jmeter&#34;&gt;JMeter
&lt;/h2&gt;&lt;p&gt;Apache JMeterはApache組織が開発したJavaベースの負荷テストツールです。ソフトウェアに対する負荷テストに使用され、当初はWebアプリケーションのテスト用に設計されましたが、その後、他のテスト分野にも拡張されています。静的および動的なリソース（静的ファイル、Java小型サービスプログラム、CGIスクリプト、Javaオブジェクト、データベース、FTPサーバーなど）をテストするために使用できます。JMeterは、さまざまな負荷カテゴリからの巨大な負荷をシミュレートして、それらの強度をテストし、全体的なパフォーマンスを分析するために使用できます。さらに、JMeterはアプリケーションの機能/回帰テストに使用でき、断言を含むスクリプトを作成することで、プログラムが期待どおりの結果を返していることを検証します。最大限の柔軟性のため、JMeterは正規表現を使用して断言を作成することを許可しています。&lt;/p&gt;
&lt;p&gt;Apache jmeter は、静的および動的なリソース（ファイル、Servlet、Perlスクリプト、Java オブジェクト、データベースとクエリ、FTPサーバーなど）のパフォーマンスをテストするために使用できます。 サーバー、ネットワーク、またはオブジェクトに過剰な負荷をシミュレートして、それらの強度をテストしたり、さまざまなストレスタイプの下での全体的なパフォーマンスを分析したりすることができます。 大規模な同時負荷テストでサーバー/スクリプト/オブジェクトのパフォーマンスを分析したり、グラフィカルなパフォーマンス分析を行ったりするために使用できます。&lt;/p&gt;
&lt;h3 id=&#34;jmeter-導入-centos7&#34;&gt;Jmeter 導入 CentOS7
&lt;/h3&gt;&lt;p&gt;JDK の実行環境をインストールし、JMeter のインストールパッケージをダウンロードします。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install java-1.8.0-openjdk -y &amp;amp;&amp;amp; \
wget https://mirrors.bfsu.edu.cn/apache//jmeter/binaries/apache-jmeter-5.4.tgz &amp;amp;&amp;amp; tar -xf apache-jmeter-5.4.tgz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;環境変数を設定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export JMETER_HOME=$HOME/jmeter/apache-jmeter-5.4
export PATH=$JMETER_HOME/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;jmeter-コマンド&#34;&gt;JMeter コマンド
&lt;/h3&gt;&lt;p&gt;最後に &lt;code&gt;Grafana&lt;/code&gt; ダッシュボードに送信し、&lt;code&gt;-l&lt;/code&gt; パラメータを入力しなくても、&lt;code&gt;web&lt;/code&gt; コンソールでデータを観察できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;jmeter -n -t /tmp/order-500-10s.jmx -l /tmp/jmeter-order-report-20200109/order-500-10s.jtl
# 通常、テスト結果とテストレポートは省略し、コマンドを簡略化します。
jmeter -n -t /tmp/order-500-10s.jmx
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;influxdb&#34;&gt;InfluxDB
&lt;/h2&gt;&lt;p&gt;InfluxDBは、Go言語で記述されたオープンソースの分散型時系列、イベント、指標データベースです。外部依存なしで動作します。このデータベースは現在、大量の時間スタンプデータ（DevOpsモニタリングデータ、APPメトリクス、IoTセンサーデータ、リアルタイム分析データなど）を保存するために主に利用されています。&lt;/p&gt;
&lt;h3 id=&#34;influxdbの特徴&#34;&gt;InfluxDBの特徴
&lt;/h3&gt;&lt;p&gt;InfluxDBの特徴は、以下の9点にまとめられます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非構造化（非モデリング）：任意の数の列を含めることができます。&lt;/li&gt;
&lt;li&gt;メトリクスの保存期間を設定できます。&lt;/li&gt;
&lt;li&gt;時間に関連する関数（min、max、sum、count、mean、medianなど）をサポートし、統計分析が容易です。&lt;/li&gt;
&lt;li&gt;ストアポリシーのサポート：データの削除および変更に使用できます。（InfluxDBはデータの削除と変更の方法を提供していません。）&lt;/li&gt;
&lt;li&gt;連続クエリのサポート：データベース内で自動的にスケジュールされたステートメントのセットであり、ストアポリシーと組み合わせてInfluxDBのシステム使用量を削減できます。&lt;/li&gt;
&lt;li&gt;ネイティブなHTTPサポート、組み込みHTTP API。&lt;/li&gt;
&lt;li&gt;SQLライクな構文をサポート。&lt;/li&gt;
&lt;li&gt;クラスタ内のデータのレプリカ数を設定できます。&lt;/li&gt;
&lt;li&gt;定期的なサンプリングデータによる別の測定項目の書き込みをサポートし、粒度ごとのデータを保存できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;influxdb-docker-インストール&#34;&gt;InfluxDB Docker インストール
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir influxdb &amp;amp;&amp;amp; cd influxdb &amp;amp;&amp;amp; \
docker run -p 8086:8086 -d --name influxdb -v $PWD:/var/lib/influxdb influxdb:1.7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker exec -it influxdb /bin/bash&lt;/code&gt; でコンテナに入り、コマンドを実行し、手動でデータベースを作成&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;root@bce0a55bbc72:/# influx
http://localhost:8086 への接続、バージョン 1.7.10
InfluxDB シェル バージョン：1.7.10
&amp;gt; 対話式パネルでコマンドを実行
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;influxdbデータベースとユーザーの作成&#34;&gt;InfluxDBデータベースとユーザーの作成
&lt;/h3&gt;&lt;p&gt;データベースの作成: &lt;code&gt;create database jmeter_t2&lt;/code&gt;
データベースの表示: &lt;code&gt;show databases&lt;/code&gt;
データベースの切り替え: &lt;code&gt;use jmeter_t2&lt;/code&gt;
ユーザーの作成: &lt;code&gt;create user &amp;quot;admin&amp;quot; with password &#39;admin&#39; with all privileges&lt;/code&gt;
ユーザーの表示: &lt;code&gt;show users&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; show users
user  admin
----  -----
admin true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ユーザー権限が&lt;code&gt;admin&lt;/code&gt;で&lt;code&gt;true&lt;/code&gt;と表示されれば、データベースの準備は完了です。&lt;/p&gt;
&lt;h2 id=&#34;grafana&#34;&gt;Grafana
&lt;/h2&gt;&lt;p&gt;テストケースの作成時に、グラフによる表現はあまり必要ないことがわかりました。インターフェースの &lt;code&gt;tps&lt;/code&gt; データのコマンドライン実行で十分観測できます。むしろ、プログラム内部の処理時間を確認したいと考えています。&lt;/p&gt;
&lt;p&gt;Grafana の簡易的なコンソールパネルをデプロイし、InfluxDB と連携するための設定ファイルをインポートします。&lt;/p&gt;
&lt;p&gt;コンソールはラベルによるフィルタリングをサポートしており、通常は 1 つの InfluxDB データベースを設定するだけで済みます：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アプリケーション名&lt;/li&gt;
&lt;li&gt;テストケース名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/linux-setup-jmeter-testing-environment/Snipaste_2021-03-09_19-44-22.png&#34;
	width=&#34;861&#34;
	height=&#34;357&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;grafana&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;241&#34;
		data-flex-basis=&#34;578px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -d --name=grafana -p 3000:3000 grafana/grafana:7.3.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ブラウザ版ではサンプリング間隔により、計算された &lt;code&gt;TPS&lt;/code&gt; や関連数値が JMeter の集計レポートと一致しないため、参照リンク：&lt;a class=&#34;link&#34; href=&#34;https://www.vinsguru.com/jmeter-real-time-results-influxdb-grafana/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.vinsguru.com/jmeter-real-time-results-influxdb-grafana/&lt;/a&gt; を参考にしています。&lt;/p&gt;
&lt;p&gt;資料には、リスナーのカスタム設定方法も記載されています。&lt;/p&gt;
&lt;h2 id=&#34;付録&#34;&gt;付録
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;高性能のプログラムパターンは、必然的にone loop threadであるべきであり、ロック、入隊列、出隊列などのものは、不必要なパフォーマンス損失を引き起こす&lt;/li&gt;
&lt;li&gt;核心ビジネスロジックの実行時間が、他のコードを導入する時間よりも大きい場合のみ、並行処理が有効に効率を向上させることができ、コアな実行時間が十分に小さい場合は、慎重に他のコードを導入すべき&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考資料&#34;&gt;参考資料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://my.oschina.net/u/4617935/blog/4680856&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;JMeterシリーズのJMeter+Grafana+InfluxDB リアルタイム監視&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/_/influxdb&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;influxdb 公式イメージ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/r/grafana/grafana&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;grafana 公式イメージ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://jmeter.apache.org/download_jmeter.cgi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;JMeter 公式サイト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@jasonli.studio/to-install-apache-jmeter-in-centos7-294bc72a97ba&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CentOS7にApache JMeterをインストールする方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Red Hat と CentOS のライフサイクル</title>
        <link>https://ttf248.life/ja/p/redhat-centos-lifecycle/</link>
        <pubDate>Tue, 21 Jul 2020 20:02:35 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/redhat-centos-lifecycle/</guid>
        <description>&lt;p&gt;オンラインプロ덕ション環境のオペレーティングシステムとして、Red HatとCentOSが主流の選択肢です。2つのシステムのライフサイクルに関する公式サイトへのリンクを記録し、CentOS 8からCentOS 8 Streamへのアップグレード経験を共有しています。&lt;/p&gt;
&lt;h2 id=&#34;はじめに&#34;&gt;はじめに
&lt;/h2&gt;&lt;p&gt;オンプレミス（本番環境）のオペレーティングシステムですが、現在の国内環境においては、Red HatとCentOSが主流の選択肢です。2年前にはRed Hat 6のEOL（End of Life）を迎えたため、両システムのライフサイクルに関する公式ウェブサイトへのリンクを記録します。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://access.redhat.com/support/policy/updates/errata&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Red Hat Enterprise Linux 生命周期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://wiki.centos.org/zh/About/Product&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CentOS 产品规范&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Red Hat Enterprise Linux（RHEL）および CentOS は、エンタープライズ向けの主要なサーバーオペレーティングシステムです。RHEL は安定したサポートと更新サイクルを提供し、エンタープライズアプリケーションに適しています。CentOS は RHEL のコミュニティ版であり、同様の機能と安定性を提供しますが、公式なサポートはありません。&lt;/p&gt;
&lt;h2 id=&#34;追記&#34;&gt;追記
&lt;/h2&gt;&lt;p&gt;この記事を執筆した時点では、2年後に自分が更新することなど想像もしていませんでした。先日、普段使っている仮想マシンをCentOS 8からCentOS 8 Streamにアップグレードしました。本番環境で何を選ぶかは、お話するのが難しいので、ここでは触れません。ローカル環境は最新版を追求します。&lt;/p&gt;
&lt;p&gt;CentOS 8 Streamは、従来のCentOSよりも迅速なアップデートと新機能を提供する、継続的リリース版であり、開発やテスト環境での利用に適しています。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
