<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Linux on 向叔の手帳</title>
        <link>https://ttf248.life/ja/tags/linux/</link>
        <description>Recent content in Linux on 向叔の手帳</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <lastBuildDate>Sun, 25 May 2025 14:10:37 +0800</lastBuildDate><atom:link href="https://ttf248.life/ja/tags/linux/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>atopツールによるLinuxシステム指標の監視：インストール、設定と使用完全ガイド</title>
        <link>https://ttf248.life/ja/p/using-atop-to-monitor-linux-system-metrics-installation-configuration-and-usage-guide/</link>
        <pubDate>Thu, 06 Feb 2025 22:48:55 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/using-atop-to-monitor-linux-system-metrics-installation-configuration-and-usage-guide/</guid>
        <description>&lt;p&gt;Linuxシステム運用において、システムリソースとプロセス状態をリアルタイムかつ包括的に監視することは非常に重要です。atopツールは強力な監視ツールとして、この目標を容易に達成するのに役立ちます。本稿では、Linuxインスタンスにおけるatop監視ツールのインストール、設定、使用方法について詳細に説明します。&lt;/p&gt;
&lt;h2 id=&#34;一atopツール紹介&#34;&gt;一、atopツール紹介
&lt;/h2&gt;&lt;p&gt;atopは、Linuxシステムのリソースとプロセスを監視するために特別に設計されたツールです。システムおよびプロセスの活動を記録し、すべてのプロセスの実行状況を報告します。このツールが収集するデータには、CPU、メモリ、ディスク、ネットワークなどのリソース使用状況やプロセス状態が含まれ、データをログファイル形式でディスクに保存することもできます。各プロセスについて、CPU使用率、メモリ増加量、ディスク使用率、優先度、ユーザー名、状態、および終了コードなど、重要な情報を取得できます。さらに、atopの設定ファイルを介して、ログ収集頻度、ログファイルの保存パス、およびローテーションポリシーなどのパラメータをカスタマイズできます。&lt;/p&gt;
&lt;h2 id=&#34;二atopツールのインストール&#34;&gt;二、atopツールのインストール
&lt;/h2&gt;&lt;p&gt;さまざまなLinuxディストリビューションでのatopのインストール方法は若干異なります。以下では、一般的なオペレーティングシステムを例としてご紹介します。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Alibaba Cloud Linux 3/2、CentOS 7/8、Fedora、Rocky Linux 9&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;実行インストールコマンド：&lt;code&gt;sudo yum install -y atop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;atopサービスを開始します：&lt;code&gt;sudo systemctl start atop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Ubuntu / Debian&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ソフトウェアリポジトリの更新：&lt;code&gt;sudo apt update&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;実行インストールコマンド：&lt;code&gt;sudo apt install -y atop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;atopサービスを開始します：&lt;code&gt;sudo systemctl start atop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CentOS Stream 9&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ダウンロードしてインストール：&lt;code&gt;sudo wget https://www.atoptool.nl/download/atop-2.11.0-1.el9.x86_64.rpm &amp;amp;&amp;amp; sudo rpm -i atop-2.11.0-1.el9.x86_64.rpm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;atopサービスを開始します：&lt;code&gt;sudo systemctl start atop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;openSUSE&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;実行インストールコマンド：&lt;code&gt;sudo zypper install -y atop atop-daemon&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;atopサービスを開始します：&lt;code&gt;sudo systemctl start atop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上記に挙げられているオペレーティングシステムに、ご利用のディストリビューションが含まれていない場合は、atop公式サイトでインストール情報を入手してください。&lt;/p&gt;
&lt;h2 id=&#34;三監視期間とログ保持期間の設定&#34;&gt;三、監視期間とログ保持期間の設定
&lt;/h2&gt;&lt;p&gt;設定ファイルの位置: Alibaba Cloud Linux 3/2、CentOS 7/8およびFedoraシステムでは、atopの設定ファイルは&lt;code&gt;/etc/sysconfig/atop&lt;/code&gt;です。Ubuntu、DebianおよびopenSUSEシステムでは、設定ファイルは&lt;code&gt;/etc/default/atop&lt;/code&gt;です。
デフォルト設定パラメータ説明
- ログオプションは、ログファイル記録のオプションを制御するために使用され、デフォルトでは空です。
- ログ間隔：監視周期、デフォルト600秒。過去のログをトレースして問題解決する場合は、実際のニーズに合わせてこの頻度を調整することをお勧めします。
- ログ保持期間、デフォルトは28日。
- ログファイルが保存されるパスです。デフォルトは &lt;code&gt;/var/log/atop&lt;/code&gt; です。
設定手順
- コマンドを実行して設定ファイルを開きます。
- Alibaba Cloud Linux 3/2、CentOS 7/8、Fedoraシステムでは：&lt;code&gt;sudo vim /etc/sysconfig/atop&lt;/code&gt;
- Ubuntu、Debian、openSUSE、CentOS Stream 9、Rocky Linux 9システムにおいて：&lt;code&gt;sudo vim /etc/default/atop&lt;/code&gt;
- &lt;code&gt;i&lt;/code&gt;キーで編集モードに入り、必要に応じて設定パラメータを調整します。例えば、監視サイクルを30秒に修正し、ログ保持期間を7日に設定し、ログパスはデフォルトのままにします。
- &lt;code&gt;Esc&lt;/code&gt;キーを押し、&lt;code&gt;:wq&lt;/code&gt;と入力して、保存して編集を終了します。
- atopサービスの再起動により設定が有効になります：&lt;code&gt;sudo systemctl restart atop&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;LOGOPTS=&amp;quot;&amp;quot;
LOGINTERVAL=30
LOGGENERATIONS=7
LOGPATH=/var/log/atop 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;四atopツールを使用する&#34;&gt;四、atopツールを使用する
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;よく使用されるコマンドの紹介:&lt;/strong&gt; インタラクティブなコマンドモードでは、以下のよく使用されるコマンドがあります。
- デフォルトの統合出力ビューに戻ります。
- プロセスの一覧の完全なコマンドラインを表示します。
- プロセスごとのメモリ使用率で降順にフィルタリングします。
- プロセスごとのディスク使用率で降順にフィルタリングします。
- プロセス資源の総合利用率に基づいて降順にフィルタリングする。
- プロセスネットワークの使用率で降順にフィルタリングする。
- 次の監視収集ポイントに移動します。
- 前の監視データ収集ポイントへ移動します。
- b：指定日時、形式は&lt;code&gt;YYYYMMDDhhmm&lt;/code&gt;です。&lt;/p&gt;
&lt;p&gt;リソース監視フィールドの説明
- ATOP：ホスト名、情報サンプリングの日付と時刻。
- プロセス全体の実行状況、カーネルモードとユーザーモードの実行時間、プロセスの総数、およびさまざまな状態のプロセス数を含む。
- CPU：CPU全体の利用状況を示し、各フィールドの数値の合計は&lt;code&gt;N*100%&lt;/code&gt;(NはCPUコア数)として表示されます。カーネルモード、ユーザーモード、割り込み、アイドル、ディスクI/O待ちなどの時間割合が含まれます。
- &lt;strong&gt;CPL&lt;/strong&gt;：CPU負荷状況。過去1分間、5分間、15分間の実行キュー内の平均プロセス数、コンテキストスイッチ回数、割り込み発生回数など。
- MEM：メモリ使用状況。物理メモリの総量、空きメモリ、ページキャッシュメモリ、ファイルキャッシュメモリ、カーネル占有メモリなどを含む。
- &lt;strong&gt;SWP&lt;/strong&gt;：スワップスペースの使用状況を示し、スワップ領域の合計サイズと利用可能なスワップスペースのサイズを含みます。
- ページング状況、例えばスワップインおよびスワップアウトされたメモリページの数。
- ディスク使用状況：各ディスクデバイスに対応する行で、デバイス識別子、ビジー状態時間比率、読み書きリクエスト数を示します。
- ネットワーク状況を表示し、転送層のTCPとUDP、IP層、および各アクティブポートの受信・送信パケットサイズを示します。&lt;/p&gt;
&lt;p&gt;リアルタイムシステム指標を確認する
- 5秒ごとにシステム指標を確認する：&lt;code&gt;atop 5&lt;/code&gt;
- 現在の時刻のあと5分間（合計30回、10秒間隔で）のシステム指標を確認します：&lt;code&gt;atop -M 10 30&lt;/code&gt;
- 現在時刻のあと10分間（10回、60秒間隔で）のシステム指標を確認し、結果をファイルに書き込む：&lt;code&gt;atop -M 60 10 &amp;gt; /log/atop.mem&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;atop起動後、収集記録はデフォルトで &lt;code&gt;/var/log/atop&lt;/code&gt; ディレクトリに保存されます。確認する際は、指定した日付のログファイルが存在することを確認してください。存在しない場合はエラーになります。
- 当日の履歴指標ログを確認する：&lt;code&gt;atop -r&lt;/code&gt;
- 昨日履歴指標ログを見る：&lt;code&gt;atop -r y&lt;/code&gt;
- 指定日の履歴指標ログを確認します。例えば、2024年11月06日：&lt;code&gt;atop -r 20241106&lt;/code&gt;
- 指定された日付から指定時間からの過去の指標ログを表示します。例えば、2024年11月06日14:00以降の場合：&lt;code&gt;atop -r 20241106 -b 14:00&lt;/code&gt;
- 指定された日付の特定の期間における履歴指標ログを確認します。例えば、2024年11月5日00時04分から00時08分：&lt;code&gt;atop -r 20241105 -b 00:04 -e 00:08&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;システムアクティビティレポートの確認
- 現在のシステムにおけるCPU使用率レポートを1分間（12回、5秒間隔）で確認します: &lt;code&gt;atopsar -c 5 12&lt;/code&gt;
- 当日指定時間帯のメモリ指標レポートを確認します。例：18:00～18:01 &lt;code&gt;atopsar -m -b 18:00 -e 18:01&lt;/code&gt;
- 指定日付内の指定時間範囲のメモリ指標レポートを確認します。例えば、2024年11月5日18:00から18:01まで：&lt;code&gt;atopsar -m -r 20241105 -b 18:00 -e 18:01&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;その他操作&#34;&gt;その他操作
&lt;/h2&gt;&lt;p&gt;天级别ログローテーションポリシーを設定します。毎日atop指標ログファイルを生成したい場合は、以下の手順を実行してください。
- （オプションで）必要に応じて監視期間、ログ保持時間、およびログ保存パスを調整できます。
- コマンドを実行して、毎日のログローテーションに関連するサービスを起動し、起動時に自動開始するように設定します。&lt;code&gt;sudo systemctl enable --now atop atopacct atop-rotate.timer&lt;/code&gt;
- ビジネスがログ処理に複雑な要件を持つ場合、logrotateやカスタムスクリプトを組み合わせてログ管理を実現することもできます。&lt;/p&gt;
&lt;p&gt;オプションのnetatopカーネルモジュールをロードします。ネットワーク使用状況を監視する必要がある場合は、netatopモジュールをインストールできます（atopではデフォルトでインストールされていません）。例として、Alibaba Cloud Linux 3システムの場合：
- カーネル開発パッケージおよびコンパイルに必要なソフトウェア環境をインストールします。&lt;code&gt;sudo yum install -y kernel-devel dkms elfutils-libelf-devel&lt;/code&gt;
- 最新バージョンのnetatopソースコードを特定のディレクトリにダウンロードします。&lt;code&gt;cd /usr/src/ &amp;amp;&amp;amp; sudo wget https://www.atoptool.nl/download/netatop-3.2.2.tar.gz --no-check-certificate&lt;/code&gt;
- ソースコードを解凍し、ソースディレクトリへ移動します。&lt;code&gt;sudo tar -zxvf netatop-3.2.2.tar.gz &amp;amp;&amp;amp; cd netatop-3.2.2&lt;/code&gt;
- ソースコードからモジュールとデーモンを構築してインストールします。&lt;code&gt;sudo make &amp;amp;&amp;amp; sudo make install&lt;/code&gt;
- netatopサービスを開始します：&lt;code&gt;sudo systemctl start netatop&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;atopツールは機能が強力で使い勝手が良く、適切なインストール、設定、使用によって、Linuxシステムの動作状況をより深く理解し、潜在的な問題を早期に発見・解決することができます。この記事が皆様のLinuxシステム監視スキル向上に役立つことを願っています。&lt;/p&gt;
&lt;h2 id=&#34;六参照リンク&#34;&gt;六、参照リンク
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.atoptool.nl/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;atop公式サイト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;atop監視ツールをインストール、設定し、使用する&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Linuxバックエンドサービス、大量文字列データの処理が遅い</title>
        <link>https://ttf248.life/ja/p/linux-backend-slow-string-processing/</link>
        <pubDate>Wed, 13 Nov 2024 19:42:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-backend-slow-string-processing/</guid>
        <description>&lt;p&gt;C++開発の過去プロジェクトにおいて、独自のプロトコルを使用して通信しており、そのプロトコルは二次元配列の形式を採用していました。大量のデータを処理する際、プロトコル内で配列を走査し、シリアライズ操作によってログを生成する必要がありましたが、効率が悪かったため、高負荷時にシステムが顕著にカクつき、業務部門からシステムの動作不良に関するフィードバックがありました。&lt;/p&gt;
&lt;h2 id=&#34;問題特定&#34;&gt;問題特定
&lt;/h2&gt;&lt;p&gt;問題の調査 során、まずシステムのパフォーマンス分析を行い、大量のデータを処理する際に CPU 使用率が大幅に増加し、システム応答時間が長くなることを発見しました。システムのログを分析した結果、大量のシリアライズ操作があり、これらの操作は 2 次元配列の処理において効率が悪く、システムパフォーマンスの低下につながっていました。&lt;/p&gt;
&lt;p&gt;pstackツールでサービスの糸処理情報を取得したところ、ログスレッドの大部分の時間文字列の結合処理に費やされていることがわかった。&lt;/p&gt;
&lt;p&gt;今日の焦点は、異なる累積方法による効率の大きな違いです。過去のコードでは「+」演算子を使用しており、この方法は頻繁に一時オブジェクトを作成するため、非常に非効率的です。それが非効率的だと知っていても、どれほど非効率的なのかを理解していないようなものです。&lt;/p&gt;
&lt;h2 id=&#34;デモ検証&#34;&gt;デモ検証
&lt;/h2&gt;&lt;p&gt;プロジェクトコードに基づいて、業務ロジックを分離し、文字列結合の効率に関する検証のために簡単なデモを作成しました。&lt;code&gt;windows&lt;/code&gt; の &lt;code&gt;vs2022&lt;/code&gt; コンパイラ、&lt;code&gt;linux&lt;/code&gt; の &lt;code&gt;gcc8.5&lt;/code&gt; コンパイラで、&lt;code&gt;Release&lt;/code&gt; モードでコンパイル・実行し、効率を比較します。&lt;/p&gt;
&lt;h3 id=&#34;重要なポイント説明&#34;&gt;重要なポイント説明
&lt;/h3&gt;&lt;p&gt;プロジェクトでは手法4を使用しており、テストデータを入手する前に、読者はどの方法が最も効率的か、またどの方法が最も非効率かを考えてみることができます。結果を見たときには、やはり驚きました。&lt;/p&gt;
&lt;p&gt;方法 1（&lt;code&gt;+=&lt;/code&gt; 連結）：各フィールドを &lt;code&gt;+=&lt;/code&gt; を使って文字列に連結します。
方法 2 ( &lt;code&gt;std::ostringstream&lt;/code&gt; による結合) ：ストリーム (&lt;code&gt;std::ostringstream&lt;/code&gt;) を用いて各フィールドを結合する方法です。この方法は特に、大量のデータを結合する場合に効率的です。
方法3（事前にメモリを割り当てた&lt;code&gt;+=&lt;/code&gt;連結）：&lt;code&gt;reserve&lt;/code&gt;を使って文字列に十分なメモリを事前に割り当てることで、メモリの再割り当てにかかるコストを削減し、パフォーマンスが向上します。
方法 4 ( &lt;code&gt;bodys = bodys + body + &amp;quot;\n&amp;quot;&lt;/code&gt; ) : 毎回新しい一時的な文字列オブジェクトを作成するため、パフォーマンスが低下します。特に大規模な結合の場合、結合ごとに新しいメモリ割り当てとコピーが発生するためです。&lt;/p&gt;
&lt;p&gt;参照結果を見ると、プロジェクトは効率が最も悪い方法が選択されたようです。&lt;/p&gt;
&lt;p&gt;さらに踏み込んで、各プラットフォームのコンパイラ最適化効率を分析してみましょう。MicrosoftのVisual Studioは相変わらず優れており、文字列の最適化効率は非常に高いですが、GCCコンパイラはその点では少し劣ります。&lt;/p&gt;
&lt;p&gt;コードを異なる機械で実行すると、2つのデータには直接的な比較の意味がないため、それぞれの結合方法間の差異を別々に比較できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;windows 平台下的 vs2022 编译器

----------------------------------------
Data Generation Time: 0.054 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.053 seconds.
+ ostringstream Data merging took: 0.054 seconds.
+ Pre-reserved Data merging took: 0.045 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 16.108 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;linux 平台下的 gcc8.5 编译器
----------------------------------------
Data Generation Time: 0.108 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.100 seconds.
+ ostringstream Data merging took: 0.083 seconds.
+ Pre-reserved Data merging took: 0.057 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 29.298 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完全コード&#34;&gt;完全コード
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;random&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;iomanip&amp;gt;

typedef std::vector&amp;lt;std::string&amp;gt; DataRow;
typedef std::vector&amp;lt;DataRow&amp;gt; DataGroup;

struct ResponsePackage
{
    std::string ErrorInfo;
    DataRow Head;
    std::string ClientId;
    std::string UUID;
    std::string MsgID;
    std::string SessionID;
    std::string ExtraInfo1;
    std::string ExtraInfo2;
    DataGroup DataBody;
};

// Generate specified length of random string
std::string generateRandomString(size_t length)
{
    const char charset[] = &amp;quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&amp;quot;;
    const size_t max_index = sizeof(charset) - 1;
    std::string random_string;
    random_string.reserve(length);

    std::random_device rd;
    std::mt19937 generator(rd());
    std::uniform_int_distribution&amp;lt;&amp;gt; distribution(0, max_index);

    for (size_t i = 0; i &amp;lt; length; ++i)
    {
        random_string += charset[distribution(generator)];
    }

    return random_string;
}

void create_large_string()
{
    // Example request package with 50 fields
    ResponsePackage requestPackage;

    requestPackage.Head = {
        &amp;quot;Field1&amp;quot;, &amp;quot;Field2&amp;quot;, &amp;quot;Field3&amp;quot;, &amp;quot;Field4&amp;quot;, &amp;quot;Field5&amp;quot;,
        &amp;quot;Field6&amp;quot;, &amp;quot;Field7&amp;quot;, &amp;quot;Field8&amp;quot;, &amp;quot;Field9&amp;quot;, &amp;quot;Field10&amp;quot;,
        &amp;quot;Field11&amp;quot;, &amp;quot;Field12&amp;quot;, &amp;quot;Field13&amp;quot;, &amp;quot;Field14&amp;quot;, &amp;quot;Field15&amp;quot;,
        &amp;quot;Field16&amp;quot;, &amp;quot;Field17&amp;quot;, &amp;quot;Field18&amp;quot;, &amp;quot;Field19&amp;quot;, &amp;quot;Field20&amp;quot;,
        &amp;quot;Field21&amp;quot;, &amp;quot;Field22&amp;quot;, &amp;quot;Field23&amp;quot;, &amp;quot;Field24&amp;quot;, &amp;quot;Field25&amp;quot;,
        &amp;quot;Field26&amp;quot;, &amp;quot;Field27&amp;quot;, &amp;quot;Field28&amp;quot;, &amp;quot;Field29&amp;quot;, &amp;quot;Field30&amp;quot;,
        &amp;quot;Field31&amp;quot;, &amp;quot;Field32&amp;quot;, &amp;quot;Field33&amp;quot;, &amp;quot;Field34&amp;quot;, &amp;quot;Field35&amp;quot;,
        &amp;quot;Field36&amp;quot;, &amp;quot;Field37&amp;quot;, &amp;quot;Field38&amp;quot;, &amp;quot;Field39&amp;quot;, &amp;quot;Field40&amp;quot;,
        &amp;quot;Field41&amp;quot;, &amp;quot;Field42&amp;quot;, &amp;quot;Field43&amp;quot;, &amp;quot;Field44&amp;quot;, &amp;quot;Field45&amp;quot;,
        &amp;quot;Field46&amp;quot;, &amp;quot;Field47&amp;quot;, &amp;quot;Field48&amp;quot;, &amp;quot;Field49&amp;quot;, &amp;quot;Field50&amp;quot;
    };

    requestPackage.ClientId = &amp;quot;ClientID&amp;quot;;
    requestPackage.UUID = &amp;quot;UUID&amp;quot;;
    requestPackage.MsgID = &amp;quot;MsgID&amp;quot;;
    requestPackage.SessionID = &amp;quot;SessionID&amp;quot;;
    requestPackage.ExtraInfo1 = &amp;quot;ExtraInfo1&amp;quot;;
    requestPackage.ExtraInfo2 = &amp;quot;ExtraInfo2&amp;quot;;

    // Start timing for data generation
    auto start_gen = std::chrono::high_resolution_clock::now();

    // Generate 10,000 rows of data, each with 50 fields
    for (size_t i = 0; i &amp;lt; 10000; ++i)
    {
        DataRow dataRow(50, &amp;quot;This is a test string&amp;quot;);
        requestPackage.DataBody.push_back(dataRow);
    }

    // End timing for data generation
    auto end_gen = std::chrono::high_resolution_clock::now();
    std::chrono::duration&amp;lt;double&amp;gt; duration_gen = end_gen - start_gen;

    // Display result generation time
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Generation Time: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_gen.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    // Data merging using different methods
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Performance:\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    {
        // Method 1: Using &#39;+=&#39; string concatenation
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (+=) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 2: Using ostringstream
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::ostringstream bodys;
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::ostringstream body;
            body &amp;lt;&amp;lt; &amp;quot;This is a test string&amp;quot;;
            for (auto&amp;amp; item : vec)
            {
                body &amp;lt;&amp;lt; item &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            }
            bodys &amp;lt;&amp;lt; body.str() &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ ostringstream Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 3: Pre-allocated memory
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys;
        bodys.reserve(1000 * 50 * 20); // Pre-allocate enough memory
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            body.reserve(50 * 20); // Pre-allocate memory for each row
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Pre-reserved Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 4: Using &#39;bodys = bodys + body + &amp;quot;\n&amp;quot;&#39;
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body = body + item + &amp;quot; &amp;quot;; // Note the use of &#39;body = body + item&#39;
            }
            bodys = bodys + body + &amp;quot;\n&amp;quot;; // Again, using &#39;bodys = bodys + body&#39;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (bodys = bodys + body + \&amp;quot;\\n\&amp;quot;) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Complete.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;
}

int main()
{
    try
    {
        create_large_string();
    }
    catch (const std::exception&amp;amp; e)
    {
        std::cerr &amp;lt;&amp;lt; &amp;quot;Caught exception: &amp;quot; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\nProgram finished.\n&amp;quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>GCCバージョンアップによりプログラムがクラッシュ：非標準コードの潜在的な問題</title>
        <link>https://ttf248.life/ja/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</link>
        <pubDate>Sun, 10 Mar 2024 23:19:06 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</guid>
        <description>&lt;p&gt;同一のビジネスコードの場合、プログラムは CentOS 7 環境で正常にコンパイルされ実行されたが、CentOS 8 に切り替えて更新版 GCC でコンパイルするとクラッシュした。問題が発生するのは &lt;strong&gt;Release モード&lt;/strong&gt; のみであり、&lt;strong&gt;Debug モード&lt;/strong&gt; では全く問題がない点が重要である。我々はこのような状況を初めて遭遇し、3 日間の調査の結果、ようやく問題の根本原因を見つけ出した。&lt;/p&gt;
&lt;h3 id=&#34;問題特定&#34;&gt;問題特定
&lt;/h3&gt;&lt;p&gt;一連の調査の結果、問題の根本原因は &lt;strong&gt;関数に返り値がないこと&lt;/strong&gt;です。Release モードでは GCC の新バージョンがより多くの最適化を行うため、元々明示的な返り値のない関数が実行中に予期せぬ動作を起こし、クラッシュを引き起こしています。結論として、&lt;strong&gt;コンパイラの警告を無視することは許されません。特に古いプロジェクトにおいては、一部の警告が無視されている可能性もありますが、すべての警告を遮断することは避けるべきです&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;環境説明&#34;&gt;環境説明
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CentOS 7 GCCバージョン：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39)
Copyright © 2015 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CentOS 8 GCCバージョン：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 8.5.0 20210514 (Red Hat 8.5.0-21)
Copyright (C) 2018 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;クラッシュ現象&#34;&gt;クラッシュ現象
&lt;/h3&gt;&lt;p&gt;プログラムクラッシュのスタックを解析した結果、以下のスタック情報が見られました。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[New LWP 1385902]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib64/libthread_db.so.1&amp;quot;.
Core was generated by `./pstack_main`.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007ffe894b4420 in ?? ()
(gdb) bt
#0  0x00007ffe894b4420 in ?? ()
#1  0x00000000004008e9 in main ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このスタックは直感的ではなく、クラッシュした関数のスタック情報が「??」として表示されているため、問題の特定がより複雑になっています。&lt;/p&gt;
&lt;h3 id=&#34;コード例&#34;&gt;コード例
&lt;/h3&gt;&lt;p&gt;問題をより良く理解するために、クラッシュを再現する最小限のコード例を以下に示します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int test() {
    std::cout &amp;lt;&amp;lt; &amp;quot;1&amp;quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    test();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;そのコードの &lt;code&gt;test()&lt;/code&gt; 関数は明らかに値を明示的に返していませんが、戻り値の型は &lt;code&gt;int&lt;/code&gt; です。C++ の仕様によると、関数が &lt;code&gt;int&lt;/code&gt; 型として宣言されている場合、必ず値を返す必要があり、そうしないと未定義の動作を引き起こす可能性があります。&lt;/p&gt;
&lt;h3 id=&#34;コンパイル警告&#34;&gt;コンパイル警告
&lt;/h3&gt;&lt;p&gt;私たちのプロジェクトでは、CMakeスクリプトによって多くのコンパイル時の警告が抑制されており、その中には以下の警告メッセージが含まれています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/root/pstack/main.cpp: In function ‘int test()’:
/root/pstack/main.cpp:7:1: warning: no return statement in function returning non-void [-Wreturn-type]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この警告は、&lt;code&gt;test()&lt;/code&gt;関数が値を返していないことを示しており、これが問題の根本原因です。高度なバージョンのGCC（例えば8.5.0）は、コードを最適化する際に、このような未定義の振る舞いに不安定な最適化を行い、プログラムがクラッシュする可能性があります。&lt;/p&gt;
&lt;h3 id=&#34;アセンブリコードの差異&#34;&gt;アセンブリコードの差異
&lt;/h3&gt;&lt;p&gt;GCCコンパイラ最適化の動作の違いを説明するために、異なるバージョンのGCCが生成するアセンブリコードを比較しました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;GCC 4.8.5 が生成したアセンブリコード：&lt;/p&gt;
&lt;p&gt;アセンブリコードは比較的冗長であり、標準出力ストリーム（例えば &lt;code&gt;std::cout&lt;/code&gt;）の処理ロジックも含まれています。これはコンパイラがより保守的な最適化を行ったことを示しており、&lt;code&gt;test()&lt;/code&gt; 関数における戻り値がない問題に対して過度な最適化を行わず、その結果、クラッシュを回避できた可能性があります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GCC 8.5.0 が生成したアセンブリコード：&lt;/p&gt;
&lt;p&gt;新しいバージョンのGCCでは、より多くの最適化が行われ、コード量が削減されました。しかし、この最適化により、戻り値がない関数の実行時に動作が不安定になり、プログラムがクラッシュする可能性があります。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;結論&#34;&gt;結論
&lt;/h3&gt;&lt;p&gt;今回の問題の調査を通じて、C++ においては&lt;strong&gt;関数の戻り値が明確に定義されている必要がある&lt;/strong&gt;ということを深く認識しました。特に、関数を &lt;code&gt;int&lt;/code&gt; として宣言した場合、必ず戻り値を返す必要があります。古いバージョンのコンパイラを使用しているプロジェクトでは、新しいバージョンの GCC にアップグレードすると、より多くの最適化や厳格な警告メカニズムが発生する可能性があります。したがって、コンパイル時に&lt;strong&gt;すべての警告を無視するのではなく&lt;/strong&gt;、関数からの戻り値や型の一致など、一般的な問題を中心に選択的に処理することをお勧めします。&lt;/p&gt;
&lt;p&gt;最終、&lt;code&gt;test()&lt;/code&gt;関数に返り値を加えることで問題が解決し、プログラムは正常に動作するようになりました。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Linuxシステムベンチマークテスト</title>
        <link>https://ttf248.life/ja/p/linux-system-benchmark-test/</link>
        <pubDate>Tue, 09 Jan 2024 10:56:23 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-system-benchmark-test/</guid>
        <description>&lt;p&gt;ウィンドウズプラットフォームには、魯大师（ユーエンターマスター）というソフトがあります。データが正確とは言えませんが、まあ参考程度にはなるでしょう。もちろん、他のプロフェッショナルなベンチマークソフトもあります。Linuxシステムでは、特によく合うベンチマークソフトにまだ出会っていません。&lt;/p&gt;
&lt;p&gt;Sysbenchは、CPU、メモリ、ファイルI/O、スレッドパフォーマンスなどをテストできる多機能なベンチマークツールです。さまざまなパフォーマンス・テストのタスクを実行するためにsysbenchを使用できます。&lt;/p&gt;
&lt;p&gt;現在、テスト用にちょうど3つの機械があります：メカニストミニローカルホスト、アリババクラウド開発雲サーバー、ファーウェイクラウド開発サーバー。&lt;/p&gt;
&lt;h2 id=&#34;sysbenchのインストール&#34;&gt;Sysbenchのインストール
&lt;/h2&gt;&lt;p&gt;ほとんどのLinuxディストリビューションでは、パッケージマネージャーを使用してSysbenchをインストールできます。例えば、CentOS 8では、以下のコマンドでインストールできます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo dnf install sysbench
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sysbenchの使用例&#34;&gt;Sysbenchの使用例
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CPU性能テスト：&lt;code&gt;sysbench --test=cpu run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;メモリ読み取りパフォーマンスのテスト：&lt;code&gt;sysbench --test=memory run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;テストファイルI/Oパフォーマンス：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysbench --test=fileio --file-test-mode=rndrw prepare
sysbench --test=fileio --file-test-mode=rndrw run
sysbench --test=fileio --file-test-mode=rndrw cleanup
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;マルチスレッドパフォーマンスのテスト: &lt;code&gt;sysbench --test=threads --num-threads=4 run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;MySQLデータベースのパフォーマンスをテストする（データベースの最大接続数を調整する必要があります）。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword --oltp-table-size=1000000 prepare
sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword --max-time=60 --oltp-read-only=off --oltp-test-mode=complex --max-requests=0 run
sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword cleanup
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;データ分散報告&#34;&gt;データ分散報告
&lt;/h2&gt;&lt;meta http-equiv=&#34;Content-Type&#34; content=&#34;text/html; charset=utf-8&#34;&gt;&lt;link type=&#34;text/css&#34; rel=&#34;stylesheet&#34; href=&#34;resources/sheet.css&#34; &gt;
&lt;style type=&#34;text/css&#34;&gt;.ritz .waffle a { color: inherit; }.ritz .waffle .s0{background-color:#ffffff;text-align:left;color:#000000;font-family:&#39;Arial&#39;;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}&lt;/style&gt;&lt;div class=&#34;ritz grid-container&#34; dir=&#34;ltr&#34;&gt;&lt;table class=&#34;waffle&#34; cellspacing=&#34;0&#34; cellpadding=&#34;0&#34;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th class=&#34;row-header freezebar-origin-ltr&#34;&gt;&lt;/th&gt;&lt;th id=&#34;0C0&#34; style=&#34;width:100px;&#34; class=&#34;column-headers-background&#34;&gt;A&lt;/th&gt;&lt;th id=&#34;0C1&#34; style=&#34;width:421px;&#34; class=&#34;column-headers-background&#34;&gt;B&lt;/th&gt;&lt;th id=&#34;0C2&#34; style=&#34;width:398px;&#34; class=&#34;column-headers-background&#34;&gt;C&lt;/th&gt;&lt;th id=&#34;0C3&#34; style=&#34;width:422px;&#34; class=&#34;column-headers-background&#34;&gt;D&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R0&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;1&lt;/div&gt;&lt;/th&gt;&lt;td&gt;&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;本地机械师&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;阿里云&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;华为云&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R1&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;2&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;系统配置&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;System Information&lt;br&gt;  Operating System              Ubuntu 23.04&lt;br&gt;  Kernel                        Linux 6.2.0-36-generic x86_64&lt;br&gt;  Model                         Machenike Machenike DT Computer&lt;br&gt;  Motherboard                   Machenike Machenike DT Computer&lt;br&gt;  BIOS                          American Megatrends International, LLC.&lt;br&gt;DB19V012&lt;br&gt;&lt;br&gt;CPU Information&lt;br&gt;  Name                          Intel Core i7-12650H&lt;br&gt;  Topology                      1 Processor, 10 Cores, 16 Threads&lt;br&gt;  Identifier                    GenuineIntel Family 6 Model 154 Stepping 3&lt;br&gt;  Base Frequency                4.60 GHz&lt;br&gt;  L1 Instruction Cache          32.0 KB x 8&lt;br&gt;  L1 Data Cache                 48.0 KB x 8&lt;br&gt;  L2 Cache                      1.25 MB x 2&lt;br&gt;  L3 Cache                      24.0 MB&lt;br&gt;&lt;br&gt;Memory Information&lt;br&gt;  Size                          62.6 GB&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;System Information&lt;br&gt;  Operating System              CentOS Stream 8&lt;br&gt;  Kernel                        Linux 4.18.0-513.el8.x86_64 x86_64&lt;br&gt;  Model                         Alibaba Cloud Alibaba Cloud ECS&lt;br&gt;  Motherboard                   N/A&lt;br&gt;  BIOS                          SeaBIOS 449e491&lt;br&gt;&lt;br&gt;CPU Information&lt;br&gt;  Name                          Intel(R) Xeon(R) Platinum&lt;br&gt;  Topology                      1 Processor, 1 Core, 2 Threads&lt;br&gt;  Identifier                    GenuineIntel Family 6 Model 85 Stepping 4&lt;br&gt;  Base Frequency                2.50 GHz&lt;br&gt;  L1 Instruction Cache          32.0 KB&lt;br&gt;  L1 Data Cache                 32.0 KB&lt;br&gt;  L2 Cache                      1.00 MB&lt;br&gt;  L3 Cache                      33.0 MB&lt;br&gt;&lt;br&gt;Memory Information&lt;br&gt;  Size                          1.65 GB&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;System Information&lt;br&gt;  Operating System              Ubuntu 22.04.1 LTS&lt;br&gt;  Kernel                        Linux 5.15.0-60-generic x86_64&lt;br&gt;  Model                         OpenStack Foundation OpenStack Nova&lt;br&gt;  Motherboard                   N/A&lt;br&gt;  BIOS                          SeaBIOS&lt;br&gt;rel-1.10.2-0-g5f4c7b1-20181220_000000-szxrtosci10000&lt;br&gt;&lt;br&gt;CPU Information&lt;br&gt;  Name                          Intel(R) Xeon(R) Gold 6278C CPU @ 2.60GHz&lt;br&gt;  Topology                      1 Processor, 1 Core, 2 Threads&lt;br&gt;  Identifier                    GenuineIntel Family 6 Model 85 Stepping 7&lt;br&gt;  Base Frequency                2.60 GHz&lt;br&gt;  L1 Instruction Cache          32.0 KB&lt;br&gt;  L1 Data Cache                 32.0 KB&lt;br&gt;  L2 Cache                      1.00 MB&lt;br&gt;  L3 Cache                      35.8 MB&lt;br&gt;&lt;br&gt;Memory Information&lt;br&gt;  Size                          3.64 GB&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R2&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;3&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;CPU&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Prime numbers limit: 10000&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;CPU speed:&lt;br&gt;    events per second:  4032.48&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0004s&lt;br&gt;    total number of events:              40330&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.25&lt;br&gt;         avg:                                    0.25&lt;br&gt;         max:                                    0.73&lt;br&gt;         95th percentile:                        0.25&lt;br&gt;         sum:                                 9997.55&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           40330.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9975/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Prime numbers limit: 10000&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;CPU speed:&lt;br&gt;    events per second:  1062.51&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0008s&lt;br&gt;    total number of events:              10628&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.91&lt;br&gt;         avg:                                    0.94&lt;br&gt;         max:                                   22.84&lt;br&gt;         95th percentile:                        1.06&lt;br&gt;         sum:                                 9993.46&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           10628.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9935/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Prime numbers limit: 10000&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;CPU speed:&lt;br&gt;    events per second:  1125.56&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0005s&lt;br&gt;    total number of events:              11258&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.86&lt;br&gt;         avg:                                    0.89&lt;br&gt;         max:                                    1.70&lt;br&gt;         95th percentile:                        0.99&lt;br&gt;         sum:                                 9995.40&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           11258.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9954/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R3&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;4&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;内存&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Running memory speed test with the following options:&lt;br&gt;  block size: 1KiB&lt;br&gt;  total size: 102400MiB&lt;br&gt;  operation: write&lt;br&gt;  scope: global&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;Total operations: 101993199 (10198146.52 per second)&lt;br&gt;&lt;br&gt;99602.73 MiB transferred (9959.13 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0001s&lt;br&gt;    total number of events:              101993199&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.00&lt;br&gt;         max:                                    0.03&lt;br&gt;         95th percentile:                        0.00&lt;br&gt;         sum:                                 4059.50&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           101993199.0000/0.00&lt;br&gt;    execution time (avg/stddev):   4.0595/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Running memory speed test with the following options:&lt;br&gt;  block size: 1KiB&lt;br&gt;  total size: 102400MiB&lt;br&gt;  operation: write&lt;br&gt;  scope: global&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;Total operations: 48418803 (4841004.79 per second)&lt;br&gt;&lt;br&gt;47283.99 MiB transferred (4727.54 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0001s&lt;br&gt;    total number of events:              48418803&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.00&lt;br&gt;         max:                                   25.26&lt;br&gt;         95th percentile:                        0.00&lt;br&gt;         sum:                                 4578.95&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           48418803.0000/0.00&lt;br&gt;    execution time (avg/stddev):   4.5789/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Running memory speed test with the following options:&lt;br&gt;  block size: 1KiB&lt;br&gt;  total size: 102400MiB&lt;br&gt;  operation: write&lt;br&gt;  scope: global&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;Total operations: 57056904 (5704765.11 per second)&lt;br&gt;&lt;br&gt;55719.63 MiB transferred (5571.06 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0001s&lt;br&gt;    total number of events:              57056904&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.00&lt;br&gt;         max:                                    0.06&lt;br&gt;         95th percentile:                        0.00&lt;br&gt;         sum:                                 4556.06&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           57056904.0000/0.00&lt;br&gt;    execution time (avg/stddev):   4.5561/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R4&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;5&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;硬盘&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;2147483648 bytes written in 1.81 seconds (1129.59 MiB/sec).&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Extra file open flags: (none)&lt;br&gt;128 files, 16MiB each&lt;br&gt;2GiB total file size&lt;br&gt;Block size 16KiB&lt;br&gt;Number of IO requests: 0&lt;br&gt;Read/Write ratio for combined random IO test: 1.50&lt;br&gt;Periodic FSYNC enabled, calling fsync() each 100 requests.&lt;br&gt;Calling fsync() at the end of test, Enabled.&lt;br&gt;Using synchronous I/O mode&lt;br&gt;Doing random r/w test&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;File operations:&lt;br&gt;    reads/s:                      3373.41&lt;br&gt;    writes/s:                     2248.94&lt;br&gt;    fsyncs/s:                     7201.80&lt;br&gt;&lt;br&gt;Throughput:&lt;br&gt;    read, MiB/s:                  52.71&lt;br&gt;    written, MiB/s:               35.14&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0127s&lt;br&gt;    total number of events:              128288&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.08&lt;br&gt;         max:                                    5.14&lt;br&gt;         95th percentile:                        0.34&lt;br&gt;         sum:                                 9977.78&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           128288.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9778/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;2147483648 bytes written in 19.29 seconds (106.16 MiB/sec).&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Extra file open flags: (none)&lt;br&gt;128 files, 16MiB each&lt;br&gt;2GiB total file size&lt;br&gt;Block size 16KiB&lt;br&gt;Number of IO requests: 0&lt;br&gt;Read/Write ratio for combined random IO test: 1.50&lt;br&gt;Periodic FSYNC enabled, calling fsync() each 100 requests.&lt;br&gt;Calling fsync() at the end of test, Enabled.&lt;br&gt;Using synchronous I/O mode&lt;br&gt;Doing random r/w test&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;File operations:&lt;br&gt;    reads/s:                      1593.12&lt;br&gt;    writes/s:                     1062.08&lt;br&gt;    fsyncs/s:                     3406.64&lt;br&gt;&lt;br&gt;Throughput:&lt;br&gt;    read, MiB/s:                  24.89&lt;br&gt;    written, MiB/s:               16.60&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0164s&lt;br&gt;    total number of events:              60600&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.16&lt;br&gt;         max:                                   31.32&lt;br&gt;         95th percentile:                        0.54&lt;br&gt;         sum:                                 9956.30&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           60600.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9563/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;2147483648 bytes written in 18.29 seconds (111.98 MiB/sec).&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Extra file open flags: (none)&lt;br&gt;128 files, 16MiB each&lt;br&gt;2GiB total file size&lt;br&gt;Block size 16KiB&lt;br&gt;Number of IO requests: 0&lt;br&gt;Read/Write ratio for combined random IO test: 1.50&lt;br&gt;Periodic FSYNC enabled, calling fsync() each 100 requests.&lt;br&gt;Calling fsync() at the end of test, Enabled.&lt;br&gt;Using synchronous I/O mode&lt;br&gt;Doing random r/w test&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;File operations:&lt;br&gt;    reads/s:                      1665.88&lt;br&gt;    writes/s:                     1110.59&lt;br&gt;    fsyncs/s:                     3563.77&lt;br&gt;&lt;br&gt;Throughput:&lt;br&gt;    read, MiB/s:                  26.03&lt;br&gt;    written, MiB/s:               17.35&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0112s&lt;br&gt;    total number of events:              63355&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.16&lt;br&gt;         max:                                  205.01&lt;br&gt;         95th percentile:                        0.78&lt;br&gt;         sum:                                 9972.64&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           63355.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9726/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R5&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;6&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;多线程&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 4&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0002s&lt;br&gt;    total number of events:              197956&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.16&lt;br&gt;         avg:                                    0.20&lt;br&gt;         max:                                    0.34&lt;br&gt;         95th percentile:                        0.21&lt;br&gt;         sum:                                39970.47&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           49489.0000/5.70&lt;br&gt;    execution time (avg/stddev):   9.9926/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 4&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0174s&lt;br&gt;    total number of events:              18360&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.57&lt;br&gt;         avg:                                    2.18&lt;br&gt;         max:                                   32.77&lt;br&gt;         95th percentile:                        2.61&lt;br&gt;         sum:                                40050.41&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           4590.0000/94.36&lt;br&gt;    execution time (avg/stddev):   10.0126/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 4&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0004s&lt;br&gt;    total number of events:              28536&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.23&lt;br&gt;         avg:                                    1.40&lt;br&gt;         max:                                    3.56&lt;br&gt;         95th percentile:                        1.47&lt;br&gt;         sum:                                39975.16&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           7134.0000/39.87&lt;br&gt;    execution time (avg/stddev):   9.9938/0.01&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;h2 id=&#34;あとがき&#34;&gt;あとがき
&lt;/h2&gt;&lt;p&gt;ChatGPTは依然として便利なものだ。上の表は、以前習得したMarkdownだけでは完全にレイアウトできず、表にしないと表示効果が非常に悪くなる。カスタムテーマはページ幅の最大値を制限しており、ページの構成を調整し、幅をパーセント制限に変更した。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;シンプルな方法としては、TablesGeneratorのようなオンラインツールを使ってHTMLテーブルを生成する（複雑なコンテンツには向いていない）。&lt;/li&gt;
&lt;li&gt;またはGoogleドキュメントで作成し、HTML形式でダウンロードして、そのままブログにコピーする。（簡単で直接的、最終的に採用）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;設定でunsafeの設定項目が有効になっていることを確認し、ページごとに幅を設定してください。&lt;/p&gt;
&lt;p&gt;Hugoにおいて、ページごとに幅を設定できます。これは、ページのFront Matterにカスタムパラメータを追加することで実現できます。以下はその例です。&lt;/p&gt;
&lt;p&gt;あなたのMarkdownページのFront Matterセクション（通常ファイルの先頭部分）に、例えば&lt;code&gt;custom_width&lt;/code&gt;のようなカスタムパラメータを追加してください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;---
title: &amp;quot;我的页面&amp;quot;
date: 2024-01-09
custom_width: &amp;quot;800px&amp;quot;  # 设置宽度为 800 像素
---

正文内容...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;あなたのHugoテーマで、対応するシングルページテンプレートファイルを見つけたり作成したりしてください（例：&lt;code&gt;layouts/_default/single.html&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;シングルページテンプレートでは、ページのFront Matterに&lt;code&gt;custom_width&lt;/code&gt;パラメータがあるか確認し、あればそれに応じてHTML要素（例：&lt;code&gt;div&lt;/code&gt;）に適用する。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{{ define &amp;quot;main&amp;quot; }}
  &amp;lt;div style=&amp;quot;max-width: {{ with .Params.custom_width }}{{ . }}{{ else }}100%{{ end }}; margin: 0 auto;&amp;quot;&amp;gt;
    {{ .Content }}
  &amp;lt;/div&amp;gt;
{{ end }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この例では、インラインスタイル（&lt;code&gt;style&lt;/code&gt;属性）を使用して&lt;code&gt;div&lt;/code&gt;要素に&lt;code&gt;max-width&lt;/code&gt;属性を設定し、&lt;code&gt;custom_width&lt;/code&gt;パラメータが指定されていない場合に幅を100%のデフォルト値に設定しています。&lt;code&gt;margin: 0 auto;&lt;/code&gt;は、&lt;code&gt;div&lt;/code&gt;要素を中心に配置するために使用されています。&lt;/p&gt;
&lt;p&gt;実際の応用では、テーマ構造やCSSスタイルの詳細に応じて、上記の例を調整する必要があるかもしれません。スタイルを調整する際は、テーマの一貫性と可読性を保つようにしてください。&lt;/p&gt;
&lt;p&gt;有効にしたテーマが少し異なっていたため、サイトのカスタムCSS設定を最終調整しました。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Dockerの豆知識</title>
        <link>https://ttf248.life/ja/p/docker-two-three-things/</link>
        <pubDate>Thu, 21 Jan 2021 09:26:07 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/docker-two-three-things/</guid>
        <description>&lt;p&gt;長年作業で触れてきたのは&lt;code&gt;CentOS&lt;/code&gt;オペレーティングシステムばかりなので、もし&lt;code&gt;Mac&lt;/code&gt;ユーザーや&lt;code&gt;Ubuntu&lt;/code&gt;ユーザーであれば、一部の内容が適用できない場合があります。&lt;/p&gt;
&lt;p&gt;インストール手順については、清華大学のマニュアルを参照してください：[https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/]&lt;/p&gt;
&lt;h2 id=&#34;設置&#34;&gt;設置
&lt;/h2&gt;&lt;p&gt;未知な神秘的な力により、ローカルにDockerをインストールする際は、クラウドプロバイダーが提供するリポジトリのアドレスを設定することを推奨します。ここでは&lt;strong&gt;アリババクラウド&lt;/strong&gt;の使用をお勧めします。&lt;/p&gt;
&lt;h3 id=&#34;倉庫ソースアドレスを設定する&#34;&gt;倉庫ソースアドレスを設定する
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install yum-utils device-mapper-persistent-data lvm2 &amp;amp;&amp;amp; \
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;部署最新バージョン&#34;&gt;部署最新バージョン
&lt;/h3&gt;&lt;p&gt;Dockerはよく使用されるバックグラウンドサービスなので、推奨としては起動時に自動的に開始するように設定し、現在のコマンドはCentOS 7に適用されます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum install -y docker-ce docker-ce-cli containerd.io &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;部門指定バージョン&#34;&gt;部門指定バージョン
&lt;/h3&gt;&lt;p&gt;KubernetesとDockerのリリースは完全に同期していないため、次にKubernetesをデプロイする場合は、Kubernetesのデプロイ手順を参照し、指定されたバージョンのDockerをインストールしてください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum list docker-ce --showduplicates | sort -r
sudo yum install -y docker-ce-18.09.2-3.el7 docker-ce-cli-18.09.2-3.el7 containerd.io-18.09.2-3.el7 &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;通常ユーザーにdocker権限を追加する&#34;&gt;通常ユーザーにDocker権限を追加する
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo usermod -aG docker ${USER}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;アンインストール&#34;&gt;アンインストール
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum erase -y docker-ce docker-ce-cli containerd.io
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;日常利用&#34;&gt;日常利用
&lt;/h2&gt;&lt;h3 id=&#34;ミラーアクセラレーション&#34;&gt;ミラーアクセラレーション
&lt;/h3&gt;&lt;p&gt;依然未知な神秘的な力が存在するせいで、イメージの引き出しがうまくいかないことがあります。そこで、国内のクラウドベンダーが多くのアクセラレーションサービスを提供してくれました。やはり&lt;strong&gt;阿里云&lt;/strong&gt;をおすすめします。&lt;/p&gt;
&lt;p&gt;加速されたアドレスは、ご自身でアカウントを登録してAliyun（アリババクラウド）から入手してください。このサービスは無料で、Aliyunは無料のイメージ構築サービスも提供しています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt; /etc/docker/daemon.json &amp;lt;&amp;lt;EOF
{
  &amp;quot;registry-mirrors&amp;quot;: [
    &amp;quot;https://docker.nju.edu.cn&amp;quot;,
    &amp;quot;https://mirror.baidubce.com&amp;quot;,
    &amp;quot;https://docker.m.daocloud.io&amp;quot;,
    &amp;quot;https://docker.mirrors.sjtug.sjtu.edu.cn&amp;quot;
  ]
}
EOF
systemctl daemon-reload &amp;amp;&amp;amp; \
systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;強く推奨されるコントロールパネル&#34;&gt;強く推奨されるコントロールパネル
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker volume create portainer_data &amp;amp;&amp;amp; \
docker run -d --name=portainer --restart=always -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:2.20.3-alpine
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;よく使うミラーの引き出しまとめ&#34;&gt;よく使うミラーの引き出しまとめ
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker pull rancher/rancher:stable &amp;amp;&amp;amp; docker pull  portainer/portainer-ce:2.0.1 &amp;amp;&amp;amp; \
docker pull centos:7 &amp;amp;&amp;amp; docker pull ubuntu:20.04 &amp;amp;&amp;amp; docker pull ubuntu:18.04 &amp;amp;&amp;amp; \
docker pull redis:5 &amp;amp;&amp;amp; docker pull redis:6 &amp;amp;&amp;amp; \
docker pull alpine:3.11 &amp;amp;&amp;amp; docker pull busybox:1.32 &amp;amp;&amp;amp; \
docker pull rabbitmq:3.7-management &amp;amp;&amp;amp; \
docker pull mariadb:10.2 &amp;amp;&amp;amp; \
docker pull nginx:1.18 &amp;amp;&amp;amp; docker pull nginx:1.19 &amp;amp;&amp;amp; \
docker pull mysql:5.6 &amp;amp;&amp;amp; docker pull mysql:8 &amp;amp;&amp;amp; \
docker pull elasticsearch:6.8.11 &amp;amp;&amp;amp; docker pull logstash:6.8.11 &amp;amp;&amp;amp; docker pull kibana:6.8.11 &amp;amp;&amp;amp; \
docker pull zookeeper:3.4 &amp;amp;&amp;amp; \
docker pull influxdb:1.7 &amp;amp;&amp;amp; docker pull grafana/grafana:7.3.1 &amp;amp;&amp;amp; \
docker pull percona:8 &amp;amp;&amp;amp; docker pull percona:5.6 &amp;amp;&amp;amp; \
docker pull cloverzrg/frps-docker:0.34.3 &amp;amp;&amp;amp; docker pull cloverzrg/frpc-docker:0.34.3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;よく使うコマンドの組み合わせ&#34;&gt;よく使うコマンドの組み合わせ
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/engine/reference/commandline/docker/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.docker.com/engine/reference/commandline/docker/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;コンテナの実行状態を確認し、&lt;code&gt;format&lt;/code&gt;パラメータを追加して詳細なコンテナ情報を確認します。この際、イメージ情報は気にしません。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker ps --format &amp;quot;{{.Names}}: {{.Ports}}: {{.Size}}&amp;quot;
#portainer: 0.0.0.0:8000-&amp;gt;8000/tcp, 0.0.0.0:9000-&amp;gt;9000/tcp: 0B (virtual 172MB)
#influxdb: 0.0.0.0:8086-&amp;gt;8086/tcp: 183B (virtual 311MB)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;全コンテナを停止&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker stop $(docker ps -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ワンクリックですべてのイメージを削除します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dokcer rmi $(docker images -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;イメージエクスポート&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; &amp;gt; -o XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;イメージをエクスポートして圧縮する&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; | gzip &amp;gt; XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;イメージのインポート&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker load -i XXX.tar
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>LinuxでJMeterテスト環境を構築する</title>
        <link>https://ttf248.life/ja/p/linux-setup-jmeter-testing-environment/</link>
        <pubDate>Tue, 22 Dec 2020 10:12:50 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/linux-setup-jmeter-testing-environment/</guid>
        <description>&lt;p&gt;著者はハードウェアに強い興味を持ち、Jmeterを用いて負荷テストを実施し、CentOS 7上にJmeter、InfluxDB、Grafanaをデプロイした過程を記録した。Jmeterのインストールとコマンドの使用方法、InfluxDBの特徴とDockerのインストール方法、そしてGrafanaの簡単なデプロイと設定について共有している。高性能プログラムのパターンに関する経験と参考文献をまとめた。&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景
&lt;/h2&gt;&lt;p&gt;周知の通り、私はハードウェアに強い興味があります。たまたまテストチームがJmeterでパフォーマンステストを行っているところを見かけ、性能が上がらないというので、好奇心旺盛な私が早速乗り出し、会社のパフォーマンステストを試してみることにしました。 ここでちょっとしたエピソードがあります。ある昔のことですが、OSC（开源中国）で記事を拝見し、より高尚に見えるパフォーマンステストのグラフを描く方法について学んだことがあります。Windows版のテストを実行しているところを見学し、TPSデータを可視化するまで来ています。それに加えてWebパネルを設定することにどのようなメリットがあるのでしょうか？&lt;/p&gt;
&lt;p&gt;考えたことがすべて思い込みで、試してみないとわからない。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Don&amp;rsquo;t use GUI mode for load testing! only for Test creation and Test debuggin.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;公式的には、コマンドラインで結果を取得し、GUIで表示する方法ではデータの誤差が生じる可能性があるとのことです。JMeterについてはあまり詳しくないのですが、せめてLinux版のコンソールパネルを試してみる理由にはなります。&lt;/p&gt;
&lt;p&gt;オープンソース中国のフォーラムでの投稿ですが、主要コンポーネントのデプロイメントは友好的ではありません。必要なファイルも公众号をフォローしないとダウンロードできないので、新しい世代として当然Dockerで代替しました。結局のところ、自分のサーバーが国内にあること、そしてクロスボーダーのソースアドレスへのアクセス速度が非常に遅いことが原因です。少なくともイメージサービスに関しては、アリババクラウドには無料のアクセラレーションがあります。&lt;/p&gt;
&lt;p&gt;Dockerのインストールとデプロイについては、ここでは詳細を述べません。以前の記事をご参照ください。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;今後の内容は大きく分けて二つです。基本的なテスト環境コンポーネントの構築と、各コンポーネントの簡単な説明。&lt;/p&gt;
&lt;h2 id=&#34;jmeter&#34;&gt;Jmeter
&lt;/h2&gt;&lt;p&gt;Apache JMeterは、Apache Foundationが開発したJavaベースの負荷テストツールです。ソフトウェアの負荷テストに用いられ、当初はWebアプリケーションのテスト用に設計されましたが、その後他のテスト分野にも拡張されています。静的なリソースや動的なリソースなど、さまざまなものをテストできます。例えば、静的ファイル、Javaマイクロサービス、CGIスクリプト、Javaオブジェクト、データベース、FTPサーバーなどです。JMeterは、サーバー、ネットワーク、またはオブジェクトに対して巨大な負荷をシミュレートし、さまざまなプレッシャーカテゴリー下での強度をテストし、全体的なパフォーマンスを分析するために使用できます。また、アサーションを含むスクリプトを作成することで、アプリケーションの機能/回帰テストを行い、プログラムが期待される結果を返すことを検証できます。最大限の柔軟性を実現するため、JMeterは正規表現を使用してアサーションを作成することを許可しています。&lt;/p&gt;
&lt;p&gt;Apache JMeterは、静的なリソースと動的なリソース（ファイル、サーブレット、Perlスクリプト、Javaオブジェクト、データベースおよびクエリ、FTPサーバーなど）のパフォーマンスをテストするために使用できます。サーバー、ネットワーク、またはオブジェクトに過剰な負荷をかけて強度をテストしたり、さまざまな種類のプレッシャー下での全体的なパフォーマンスを分析したりすることができます。パフォーマンスのグラフ解析や、高並行負荷テストでサーバー/スクリプト/オブジェクトを使用することも可能です。&lt;/p&gt;
&lt;h3 id=&#34;jmeter-部署-centos7&#34;&gt;JMeter 部署 CentOS7
&lt;/h3&gt;&lt;p&gt;JDKランタイム環境をインストールし、Jmeterのインストーラパッケージをダウンロードする。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install java-1.8.0-openjdk -y &amp;amp;&amp;amp; \
wget https://mirrors.bfsu.edu.cn/apache//jmeter/binaries/apache-jmeter-5.4.tgz &amp;amp;&amp;amp; tar -xf apache-jmeter-5.4.tgz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;環境変数を設定する&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export JMETER_HOME=$HOME/jmeter/apache-jmeter-5.4
export PATH=$JMETER_HOME/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;jmeter-コマンド&#34;&gt;JMeter コマンド
&lt;/h3&gt;&lt;p&gt;最後に&lt;code&gt;Grafana&lt;/code&gt;コントロールパネルと接続し、&lt;code&gt;-l&lt;/code&gt;パラメータを入力せずに&lt;code&gt;web&lt;/code&gt;コンソールでデータを観察できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;jmeter -n -t /tmp/order-500-10s.jmx -l /tmp/jmeter-order-report-20200109/order-500-10s.jtl
# 一般不用测试结果和测试报告，简化命令
jmeter -n -t /tmp/order-500-10s.jmx
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;influxdb&#34;&gt;InfluxDB
&lt;/h2&gt;&lt;p&gt;InfluxDBは、外部依存関係なしにGo言語で記述されたオープンソースの分散型時系列、イベント、および指標データベースです。現在、このデータベースは主に、DevOpsモニタリングデータ、APPメトリクス、IoTセンサーデータ、リアルタイム解析データなど、大量の時間スタンプデータを保存するために使用されています。&lt;/p&gt;
&lt;h3 id=&#34;influxdbの特徴&#34;&gt;InfluxDBの特徴
&lt;/h3&gt;&lt;p&gt;InfluxDBの特徴は、以下の9つの側面からまとめられます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;構造（パターン）なし：任意の数の列が可能です。&lt;/li&gt;
&lt;li&gt;メトリクスの保存期間を設定できます。&lt;/li&gt;
&lt;li&gt;時間に関連する関数（最小値、最大値、合計、カウント、平均、中央値など）をサポートし、統計処理に便利です。&lt;/li&gt;
&lt;li&gt;サポートされているストレージポリシー：データの削除と変更に使用できます。（InfluxDBはデータの削除および変更の方法を提供していません。）&lt;/li&gt;
&lt;li&gt;継続クエリのサポート：データベース内で自動的にスケジュールされた一連の文であり、ストレージポリシーと組み合わせることでInfluxDBのシステムリソース使用量を削減できます。&lt;/li&gt;
&lt;li&gt;ネイティブなHTTPサポート、組み込みHTTP API。&lt;/li&gt;
&lt;li&gt;SQLに類似した構文をサポートします。&lt;/li&gt;
&lt;li&gt;クラスタ内のデータレプリカ数を設定する機能をサポートします。&lt;/li&gt;
&lt;li&gt;定期サンプリングデータをサポートし、別のmeasurementに書き込むことで、細分化されたデータストレージを容易にする。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;influxdb-docker-インストール&#34;&gt;InfluxDB Docker インストール
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir influxdb &amp;amp;&amp;amp; cd influxdb &amp;amp;&amp;amp; \
docker run -p 8086:8086 -d --name influxdb -v $PWD:/var/lib/influxdb influxdb:1.7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;コンテナに入り、コマンドを実行して、手動でデータベースを作成します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;root@bce0a55bbc72:/# influx
Connected to http://localhost:8086 version 1.7.10
InfluxDB shell version: 1.7.10
&amp;gt; 交互面板执行命令
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;influxdb-データベースとユーザーの作成&#34;&gt;InfluxDB データベースとユーザーの作成
&lt;/h3&gt;&lt;p&gt;データベースを作成します：create database jmeter_t2
データベースを確認する：show databases
データベースを切り替えます：use jmeter_t2
ユーザーを作成：パスワード&amp;rsquo;admin&amp;rsquo;でユーザー&amp;quot;admin&amp;quot;を全権限で作成する
ユーザーを表示&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; show users
user  admin
----  -----
admin true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ユーザー権限&lt;code&gt;admin&lt;/code&gt;が&lt;code&gt;true&lt;/code&gt;に表示されれば、データベースの準備は完了です。&lt;/p&gt;
&lt;h2 id=&#34;grafana&#34;&gt;Grafana
&lt;/h2&gt;&lt;p&gt;テストケースを作成していると、グラフ表示はそれほど必須ではないことがわかった。インターフェースの&lt;code&gt;tps&lt;/code&gt;データはコマンドラインで実行すれば確認できるし、むしろプログラム内部の処理時間を知りたいだけだ。&lt;/p&gt;
&lt;p&gt;シンプルな&lt;code&gt;Grafana&lt;/code&gt;コントロールパネルをデプロイし、設定ファイルをインポートして&lt;code&gt;InfluxDB&lt;/code&gt;に接続する。&lt;/p&gt;
&lt;p&gt;コントロールパネルでは、タグによるテスト結果のフィルタリングが可能で、通常は &lt;code&gt;InfluxDB&lt;/code&gt; データベースを一つ設定するだけで済みます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アプリケーション名&lt;/li&gt;
&lt;li&gt;テストケース名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/linux-setup-jmeter-testing-environment/Snipaste_2021-03-09_19-44-22.png&#34;
	width=&#34;861&#34;
	height=&#34;357&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;grafana&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;241&#34;
		data-flex-basis=&#34;578px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -d --name=grafana -p 3000:3000 grafana/grafana:7.3.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ウェブ版では、サンプラー間隔により計算される&lt;code&gt;TPS&lt;/code&gt;や関連数値が&lt;code&gt;Jmeter&lt;/code&gt;の集約レポートと一致しない場合があります。参考リンク：&lt;a class=&#34;link&#34; href=&#34;https://www.vinsguru.com/jmeter-real-time-results-influxdb-grafana/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.vinsguru.com/jmeter-real-time-results-influxdb-grafana/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;資料には、リスナーをカスタマイズする方法についても説明されています。&lt;/p&gt;
&lt;h2 id=&#34;あとがき&#34;&gt;あとがき
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;高性能なプログラムパターンは必ずしもone loop threadであり、ロック、キューへの入列と退列は不要なパフォーマンス損失を引き起こす。&lt;/li&gt;
&lt;li&gt;コアビジネスロジックの処理時間よりも、他のコードを導入する時間が長くなる場合がある。並行処理によってのみ効率を効果的に向上させることができ、コア処理時間が十分短い場合に限って、他のコードの導入は慎重に行うべきである。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参照資料&#34;&gt;参照資料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;JMeterシリーズ：JMeter+Grafana+InfluxDBによるリアルタイム監視&lt;/li&gt;
&lt;li&gt;InfluxDB公式イメージ&lt;/li&gt;
&lt;li&gt;Grafana公式イメージ&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://jmeter.apache.org/download_jmeter.cgi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;JMeter公式サイト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@jasonli.studio/to-install-apache-jmeter-in-centos7-294bc72a97ba&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;To install Apache JMeter in CentOS7&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Red Hat と CentOS のライフサイクル</title>
        <link>https://ttf248.life/ja/p/redhat-centos-lifecycle/</link>
        <pubDate>Tue, 21 Jul 2020 20:02:35 +0800</pubDate>
        
        <guid>https://ttf248.life/ja/p/redhat-centos-lifecycle/</guid>
        <description>&lt;p&gt;オンラインの生産環境オペレーティングシステムでは、Red HatとCentOSが主流な選択肢です。2つのシステムのライフサイクルに関する公式ウェブサイトへのリンクを記録し、CentOS 8からCentOS 8 Streamへのアップグレード経験を共有しています。&lt;/p&gt;
&lt;h2 id=&#34;まえがき&#34;&gt;まえがき
&lt;/h2&gt;&lt;p&gt;オンライン生産環境のオペレーティングシステムですが、現在の中国国内では、Red HatとCentOSが主流です。数年前にはRed Hat 6のEOL（End of Life）がありましたが、この記録として両システムのライフサイクル公式ウェブサイトへのリンクを記載します。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://access.redhat.com/support/policy/updates/errata&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Red Hat Enterprise Linux Life Cycle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;CentOS 製品仕様&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Red Hat Enterprise Linux（RHEL）とCentOSは、エンタープライズサーバーオペレーティングシステムの主要な選択肢です。RHELは安定したサポートとアップデートサイクルを提供し、企業向けアプリケーションに適しています。CentOSはRHELのコミュニティ版であり、同様の機能と安定性を提供しますが、公式サポートはありません。&lt;/p&gt;
&lt;h2 id=&#34;追い続き&#34;&gt;追い続き
&lt;/h2&gt;&lt;p&gt;この記事を公開した時、2年後にアップデートすることになるとは思ってもみませんでした。先日、普段使っている仮想マシンをCentOS 8からCentOS 8 Streamにアップグレードしました。本番環境でどう選ぶかは言及しないことにしますが、ローカル環境では最新バージョンを追求しています。&lt;/p&gt;
&lt;p&gt;CentOS 8 Streamは、ローリングリリース版であり、従来のCentOSよりも速いアップデートと新機能を提供するため、開発およびテスト環境での利用に適しています。&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
