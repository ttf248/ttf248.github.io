<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>计算机 on 向叔记事簿</title>
        <link>https://ttf248.life/categories/computer/</link>
        <description>Recent content in 计算机 on 向叔记事簿</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language><atom:link href="https://ttf248.life/categories/computer/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Win11专业版，远程桌面登录报错：登录失败</title>
        <link>https://ttf248.life/p/win11-pro-professional-remote-desktop-login-error-login-failed/</link>
        <pubDate>Tue, 22 Jul 2025 01:10:10 +0800</pubDate>
        
        <guid>https://ttf248.life/p/win11-pro-professional-remote-desktop-login-error-login-failed/</guid>
        <description>&lt;p&gt;主机莫名奇妙蓝屏无法启动，UEFI格式的引导，系统一直无法正常加载，切换到老的MBR格式的引导后，系统可以正常启动了。&lt;/p&gt;
&lt;p&gt;常规操作，开启系统的远程桌面，另外一台机器测试，网络什么的都是正常。登录和以前一样，用了微软的账户登录系统。&lt;/p&gt;
&lt;p&gt;远程桌面登录的时候，报错：&lt;strong&gt;登录失败&lt;/strong&gt;，没有其他的任何信息。&lt;/p&gt;
&lt;h2 id=&#34;解决方法&#34;&gt;解决方法
&lt;/h2&gt;&lt;p&gt;由于是微软账户登录的系统，远程桌面登录的时候，默认使用的是微软账户的邮箱地址作为用户名，系统推荐开启&lt;strong&gt;PIN&lt;/strong&gt;码登录。&lt;/p&gt;
&lt;p&gt;参考网上查来的资料，第一步先关闭安全设置，也就是登录设置中的&lt;code&gt;为了提高安全性，仅允许对此设备上的 Microsoft 帐户使用 Windows Hello 登录（推荐）&lt;/code&gt;，将其关闭。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/win11-pro-professional-remote-desktop-login-error-login-failed/20250721235800.png&#34;
	width=&#34;470&#34;
	height=&#34;259&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;登录设置&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;181&#34;
		data-flex-basis=&#34;435px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;关键的第二步，重启系统，此时能看到登录的界面除开&lt;code&gt;PIN&lt;/code&gt;码登录外，还多了一个&lt;code&gt;Microsoft 帐户&lt;/code&gt;的选项。选择账户登录，手动输入账号密码，此时再次尝试远程桌面登录，一切正常。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/answers/questions/2191955/question-2191955&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/answers/questions/2191955/question-2191955&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>近期大模型的一些使用经验</title>
        <link>https://ttf248.life/p/recent-usage-experiences-of-large-models/</link>
        <pubDate>Wed, 09 Jul 2025 21:09:01 +0800</pubDate>
        
        <guid>https://ttf248.life/p/recent-usage-experiences-of-large-models/</guid>
        <description>&lt;p&gt;现在用下来并没有哪个大模型特别好，各家都有自己的优势场景。&lt;/p&gt;
&lt;h2 id=&#34;技术文档&#34;&gt;技术文档
&lt;/h2&gt;&lt;p&gt;投喂代码或者咨询IT技术类的问题：ChatGPT 和 Gemini&lt;/p&gt;
&lt;h2 id=&#34;写代码&#34;&gt;写代码
&lt;/h2&gt;&lt;p&gt;整理需求，要求修改代码：Claude&lt;/p&gt;</description>
        </item>
        <item>
        <title>回测数据去哪里找？</title>
        <link>https://ttf248.life/p/where-can-i-find-backtest-data/</link>
        <pubDate>Fri, 27 Jun 2025 19:33:56 +0800</pubDate>
        
        <guid>https://ttf248.life/p/where-can-i-find-backtest-data/</guid>
        <description>&lt;p&gt;回测需要用到：比例法（涨跌幅复权法），通俗的例子解释一下，同样的，用例子解释下，为什么不能用加减法复权，推荐一些能用 pytho 获取历史数据的 比例法 数据源&lt;/p&gt;
&lt;p&gt;好的，我们来用通俗易懂的例子解释一下“比例法（涨跌幅复权法）”以及为什么不能用“加减法复权”，并为您推荐一些获取 Python 历史数据的来源。&lt;/p&gt;
&lt;h2 id=&#34;核心概念为什么需要复权&#34;&gt;核心概念：为什么需要复权？
&lt;/h2&gt;&lt;p&gt;在投资的世界里，股票的价格并不仅仅因为买卖而变动。上市公司的一些行为，比如&lt;strong&gt;分红、送股、配股&lt;/strong&gt;，都会直接影响股价，但这些变动并不反映公司真实的价值增长或下跌。&lt;/p&gt;
&lt;p&gt;想象一下，你持有的股票昨天收盘价是 100 元。今天公司决定每股派发 5 元现金红利，这个过程叫做“除息”。派发红利后，公司的总价值减少了，所以交易所会把股价下调 5 元，开盘价变成 95 元。&lt;/p&gt;
&lt;p&gt;如果你直接用 95 元和昨天的 100 元来计算涨跌幅，会得出 &lt;code&gt;-5%&lt;/code&gt; 的结论。但这显然是错的，因为你的账户里多了 5 元现金，你的总资产并没有损失。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复权（Reinvestment/Adjustment）&lt;/strong&gt; 的目的，就是将这些非市场交易因素（如分红、送股）造成的股价“缺口”填补上，还原股票价格的真实走势，让你能够准确地计算收益率和进行策略回测。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;比例法涨跌幅复权法通俗例子解释&#34;&gt;比例法（涨跌幅复权法）：通俗例子解释
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;核心思想：&lt;/strong&gt; 比例法假设你收到的所有分红或送股，都会在收到它们的那一刻，立刻以当时的股价重新买入该股票。它关注的是 &lt;strong&gt;“总资产的增长比例”&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例子：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设你在 &lt;strong&gt;第一天&lt;/strong&gt; 以 &lt;strong&gt;100 元&lt;/strong&gt; 的价格买了 1 股“神奇公司”的股票。你的总资产是 &lt;strong&gt;100 元&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二天&lt;/strong&gt;，市场没变化，但公司宣布进行“除息”，每股派发现金红利 &lt;strong&gt;2 元&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;除息后，股价会自动从 100 元下调到 &lt;strong&gt;98 元&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;此时，你的持仓变成了：1 股股票（价值 98 元）+ 2 元现金。&lt;/li&gt;
&lt;li&gt;你的&lt;strong&gt;总资产&lt;/strong&gt;仍然是 98 + 2 = &lt;strong&gt;100 元&lt;/strong&gt;，没有变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;第三天&lt;/strong&gt;，市场上涨，神奇公司的股价从 98 元上涨到了 &lt;strong&gt;102.9 元&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;涨幅是多少？是 &lt;code&gt;(102.9 - 98) / 98 = 5%&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;你的总资产现在价值多少？
&lt;ul&gt;
&lt;li&gt;如果你没有把红利再投资：1 股股票（102.9 元）+ 2 元现金 = &lt;strong&gt;104.9 元&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果我们用&lt;strong&gt;比例法&lt;/strong&gt;来计算一个“复权后”的价格，我们会假设那 2 元现金在除息日（第二天）就以 98 元的价格重新买入了股票。但为了简化计算，比例法直接在昨天的价格基础上乘以今天的涨跌幅。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;比例法的计算逻辑：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它认为，第二天的总资产（100元）和第一天的总资产（100元）相比，增长率是 0%。第三天的总资产相较于第二天，增长了 5%。&lt;/p&gt;
&lt;p&gt;所以，它会这样构建一个连续的、复权后的价格序列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第一天复权价：&lt;/strong&gt; 100 元&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二天复权价：&lt;/strong&gt; 由于总资产没变，它会把昨天的收盘价“修正”一下，以反映今天的真实情况。修正方法是 &lt;code&gt;昨天的复权价 * (1 + 今天的真实涨跌幅)&lt;/code&gt;。但除息日当天，真实涨跌幅为 0（因为总资产没变），所以复权价不变，或者说会进行一个技术调整，我们直接看第三天。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第三天复权价：&lt;/strong&gt; &lt;code&gt;第一天的复权价 * (1 + 0%) * (1 + 5%)&lt;/code&gt; 是不准确的。正确的逻辑是，它会把除息前的价格作为基准，然后进行“打折”。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们换个更清晰的&lt;strong&gt;前复权&lt;/strong&gt;角度来理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第三天&lt;/strong&gt;的收盘价是 &lt;strong&gt;102.9 元&lt;/strong&gt;。（基准）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二天&lt;/strong&gt;的收盘价是 &lt;strong&gt;98 元&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第一天&lt;/strong&gt;的收盘价是 100 元，但因为第二天发生了除息（股价从 100 变成 98，相当于打了 &lt;code&gt;98/100 = 0.98&lt;/code&gt; 的折扣），所以我们要把第一天的价格也按这个比例打折，来和后面的价格对齐。
&lt;ul&gt;
&lt;li&gt;修正后的第一天价格 = &lt;code&gt;102.9 / (1 + 5%) / (100/98)&lt;/code&gt; &amp;hellip; 这个计算很复杂。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;最简单的理解方式（涨跌幅复权法）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比例法的核心是保证&lt;strong&gt;任何两天的复权价格之间的涨跌幅，等于你在这段时间内（并将所有分红再投资）所获得的总收益率&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从第一天收盘到第三天收盘，你的真实总收益率是 &lt;code&gt;(104.9 - 100) / 100 = 4.9%&lt;/code&gt;。(这里假设你没再投资)&lt;/li&gt;
&lt;li&gt;如果分红立刻再投资，第三天你的总资产会是 &lt;code&gt;100 * (1 + 5%) = 105&lt;/code&gt; 元（因为你所有的100元都在股票里享受了5%的增长）。&lt;/li&gt;
&lt;li&gt;那么，复权价格序列算出来的涨跌幅就应该是 5%。
&lt;ul&gt;
&lt;li&gt;第三天复权价 / 第一天复权价 - 1 = 5%&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;结论：&lt;/strong&gt; 比例法（涨跌幅复权法）通过调整历史价格，使得任何一段时期内的价格涨跌幅都精确对应了“分红再投资”策略下的总回报率。这是进行量化回测最准确、最标准的方法。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;为什么不能用加减法复权&#34;&gt;为什么不能用“加减法复权”？
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;核心思想：&lt;/strong&gt; 加减法复权试图通过简单的加法，把分红的金额直接加回到除息前的股价上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例子（沿用上文）：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第一天&lt;/strong&gt;收盘价：100 元&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二天&lt;/strong&gt;除息 2 元，收盘价：98 元&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第三天&lt;/strong&gt;上涨 5%，收盘价：102.9 元&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;加减法的错误逻辑：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它会认为，第二天的 98 元是因为少了 2 元分红，所以要把这 2 元“加回去”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它计算出的第二天“复权价” = 98 + 2 = 100 元。&lt;/li&gt;
&lt;li&gt;它计算出的第三天“复权价” = 102.9 + 2 = 104.9 元。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在，我们用这个“复权价”序列来计算第三天的涨跌幅：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;涨幅 = &lt;code&gt;(104.9 - 100) / 100 = 4.9%&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;问题出在哪里？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个 4.9% 的涨幅是错误的！我们前面分析过，股价的实际涨幅是 &lt;code&gt;(102.9 - 98) / 98 = 5%&lt;/code&gt;。加减法得出的 4.9% 低估了股票真实的增长能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么会低估？&lt;/strong&gt;
因为加减法没有考虑到“&lt;strong&gt;复利&lt;/strong&gt;”效应。比例法假设你的 2 元分红也以 5% 的速度在增长，而加减法粗暴地认为这 2 元永远就是 2 元，没有参与到后续的投资增值中。随着时间的推移和分红次数的增加，这种误差会越来越大，导致你的回测结果严重失真，尤其是对于那些高分红的股票。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一句话总结：&lt;/strong&gt; 加减法破坏了价格序列的“增长率”信息，导致收益率计算错误；比例法保留了真实的“收益率”，是回测的正确选择。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;python-获取历史数据的比例法数据源推荐&#34;&gt;Python 获取历史数据的“比例法”数据源推荐
&lt;/h2&gt;&lt;p&gt;在实践中，我们通常不需要自己去计算复权。专业的数据提供商会直接提供已经计算好的复权价格。你只需要在调用 API 时选择正确的价格类型即可。通常，这被称为“&lt;strong&gt;Adjusted Price&lt;/strong&gt;”（调整后价格）。&lt;/p&gt;
&lt;p&gt;以下是一些广受好评且能通过 Python 获取复权后历史数据的数据源：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;yfinance (雅虎财经)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点：&lt;/strong&gt; 完全免费，使用简单，是个人开发者和初学者的首选。它提供的数据默认就是经过比例法复权（前复权）的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 数据可能存在清洗不干净或偶尔延迟的问题，对于非常严谨的商业策略，可能需要更专业的数据源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Python 使用示例：&lt;/strong&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import yfinance as yf

# 下载台积电(2330.TW)的历史数据
# auto_adjust=True 是关键，它会自动获取复权后的价格
tsmc = yf.download(&#39;2330.TW&#39;, start=&#39;2023-01-01&#39;, end=&#39;2024-01-01&#39;, auto_adjust=True)

# tsne.Close 列就是经过比例法(涨跌幅复权法)计算的前复权收盘价
print(tsmc[&#39;Close&#39;].head())
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;TuShare&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点：&lt;/strong&gt; 国内非常流行的财经数据接口，提供丰富的 A 股、港股、美股等数据。数据质量较高，有积分制度，但基础数据免费。提供了明确的复权因子和复权后行情接口。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 需要注册获取 token，部分高级数据或高频率调用需要积分。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Python 使用示例（需要先注册获取 token）：&lt;/strong&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import tushare as ts

# 设置你的 token
ts.set_token(&#39;YOUR_TOKEN_HERE&#39;)
pro = ts.pro_api()

# 获取贵州茅台(600519.SH)的日线行情，adj=&#39;qfq&#39;代表前复权
# &#39;hfq&#39; 代表后复权，两者都属于比例法
df = pro.daily(ts_code=&#39;600519.SH&#39;, start_date=&#39;20230101&#39;, end_date=&#39;20240101&#39;, adj=&#39;qfq&#39;)

print(df.head())
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;baostock&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点：&lt;/strong&gt; 免费、开源的中国 A 股证券数据平台。数据比较稳定和准确，也提供了复权选项。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 主要覆盖 A 股市场。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Python 使用示例：&lt;/strong&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import baostock as bs

# 登录系统
lg = bs.login()

# 获取历史K线数据
# adjustflag=&amp;quot;2&amp;quot; 为前复权, &amp;quot;1&amp;quot; 为后复权
rs = bs.query_history_k_data_plus(&amp;quot;sh.600000&amp;quot;,
    &amp;quot;date,code,open,high,low,close,preclose,volume,amount,adjustflag,turn,tradestatus,pctChg,isST&amp;quot;,
    start_date=&#39;2023-01-01&#39;, end_date=&#39;2024-01-01&#39;,
    frequency=&amp;quot;d&amp;quot;, adjustflag=&amp;quot;2&amp;quot;)

data_list = []
while (rs.error_code == &#39;0&#39;) &amp;amp; rs.next():
    data_list.append(rs.get_row_data())

import pandas as pd
df = pd.DataFrame(data_list, columns=rs.fields)

print(df.head())

# 登出系统
bs.logout()
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;商业级数据源 (Quandl/FactSet, Refinitiv, Bloomberg)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点：&lt;/strong&gt; 数据质量最高、覆盖面最广、更新最及时，提供专业的 API 和技术支持。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 价格昂贵，主要面向金融机构和企业用户。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;给初学者的建议：&lt;/strong&gt; 从 &lt;strong&gt;yfinance&lt;/strong&gt; 或 &lt;strong&gt;TuShare&lt;/strong&gt; 开始。它们完全能满足学习、研究和个人项目回测的需求，并且能让你很好地理解和应用“比例法”复权数据。在调用时，请务必选择“Adjusted”或“复权”选项。&lt;/p&gt;</description>
        </item>
        <item>
        <title>跨机器计算时间差</title>
        <link>https://ttf248.life/p/cross-machine-computation-time-difference/</link>
        <pubDate>Thu, 19 Jun 2025 09:45:36 +0800</pubDate>
        
        <guid>https://ttf248.life/p/cross-machine-computation-time-difference/</guid>
        <description>&lt;p&gt;组内现有通讯协议使用 &lt;code&gt;steady_clock&lt;/code&gt; 作为时间戳，计算单个节点的耗时，某个特殊场景，用到了消息包自带的时间戳，&lt;strong&gt;自带&lt;/strong&gt;的时间戳来自于其他机器，导致计算出来的耗时异常。&lt;/p&gt;
&lt;p&gt;题话外：Gemini2.5 Pro 有希望彻底超越 GPT-4&lt;/p&gt;
&lt;h2 id=&#34;问题排查&#34;&gt;问题排查
&lt;/h2&gt;&lt;p&gt;开始也没注意到底层时间戳计算的问题，就想着停掉所有服务，仅从本地接入，分析下日志。发现有个服务一直停不掉，持续的在发送业务数据，没辙，按照通讯端口抓包定位机器的位置。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo tcpdump -nni any -B 4096 -s 0 -w tmp.pcap port 13100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内部网络情况复杂，消息经过了代理转发，先从服务本机抓包，使用 &lt;code&gt;tcpdump&lt;/code&gt; 抓取端口 13100 的数据包。然后切换到代理服务器上，抓取端口 13100 的数据包。&lt;/p&gt;
&lt;p&gt;分析发现，耗时异常的请求，都来自深圳办公室，排查问题的服务，都部署在上海办公室。&lt;/p&gt;
&lt;h2 id=&#34;steady_clock-和-system_clock-的区别&#34;&gt;steady_clock 和 system_clock 的区别
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;std::steady_clock&lt;/code&gt; 和 &lt;code&gt;std::system_clock&lt;/code&gt; 是 C++ 中用于处理时间的两种主要时钟。它们有以下关键区别：&lt;/p&gt;
&lt;h3 id=&#34;stdsystem_clock&#34;&gt;std::system_clock
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;代表“墙上时间” (Wall Clock Time)&lt;/strong&gt;：它表示的是系统范围内的、现实世界的时间。这个时间与操作系统显示的时间是一致的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可以被调整&lt;/strong&gt;：这个时钟的时间可以被用户或系统服务（如 NTP 网络时间协议）向前或向后调整。例如，如果你手动修改系统时间，或者系统与时间服务器同步，&lt;code&gt;system_clock&lt;/code&gt; 的值会发生跳变。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不适合测量时间间隔&lt;/strong&gt;：由于它可能向后跳变，用它来计算两个时间点之间的时间差可能会得到负数或不准确的结果。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主要用途&lt;/strong&gt;：获取当前的日历时间，用于需要与现实世界时间对应的场景（例如，日志记录时间戳）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;stdsteady_clock&#34;&gt;std::steady_clock
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单调递增时钟 (Monotonic Clock)&lt;/strong&gt;：这个时钟从某个起点开始，只会稳定地向前移动，永远不会减少。它的速率可能是固定的，也可能不是（尽管通常是）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不可被调整&lt;/strong&gt;：&lt;code&gt;steady_clock&lt;/code&gt; 不受系统时间变化的影响。即使用户修改了系统时间，它也会继续稳定地向前走。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最适合测量时间间隔&lt;/strong&gt;：由于其单调性，它是测量代码执行时间、超时等待等场景的最佳选择，可以保证结果的准确性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;起点不确定&lt;/strong&gt;：它的起始时间点（epoch）通常是系统启动时，但这并没有被标准所保证。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;不同机器上的-steady_clock-一样吗&#34;&gt;不同机器上的 &lt;code&gt;steady_clock&lt;/code&gt; 一样吗？
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;不一样。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;steady_clock&lt;/code&gt; 的值在不同机器之间是&lt;strong&gt;没有可比性的&lt;/strong&gt;。甚至在同一台机器的两次不同启动之间，它的值也是不可比的。&lt;/p&gt;
&lt;p&gt;因为它的设计初衷就是为了在&lt;strong&gt;单次程序运行中&lt;/strong&gt;精确地测量时间段，而不是为了表示一个绝对的时间点。它的起点（epoch）是未定义的，并且在不同的系统或不同的启动会话中几乎肯定是不同的。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;特性&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;code&gt;system_clock&lt;/code&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;code&gt;steady_clock&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;类型&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;墙上时钟&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单调时钟&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;是否可调整&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;是，可以向前或向后跳变&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;否，只会向前移动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;主要用途&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;获取当前日历时间&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;测量时间间隔、超时&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;跨机器/重启比较&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可以（同步后）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;不可以&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;简单来说&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要知道“现在几点了？”，用 &lt;code&gt;system_clock&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;需要知道“这段代码运行了多久？”，用 &lt;code&gt;steady_clock&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>面包屑导航</title>
        <link>https://ttf248.life/p/breadcrumb-navigation/</link>
        <pubDate>Sat, 14 Jun 2025 23:34:13 +0800</pubDate>
        
        <guid>https://ttf248.life/p/breadcrumb-navigation/</guid>
        <description>&lt;p&gt;继续AI瞎写，&lt;a class=&#34;link&#34; href=&#34;https://github.com/ttf248/comic-reader&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;本地漫画浏览器&lt;/a&gt;，收尾的时候，发现没有返回首页功能，将问题抽取，扔给AI，解决方案是增加&lt;strong&gt;面包屑导航&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;什么是面包屑导航&#34;&gt;什么是面包屑导航？
&lt;/h2&gt;&lt;p&gt;面包屑导航（Breadcrumb Navigation）是一种常见的用户界面设计模式，通常用于帮助用户了解自己在网站或应用中的位置，并提供快速返回上一级或首页的路径。它的名字来源于童话故事《汉赛尔与格蕾特》中，主人公用面包屑标记回家的路。&lt;/p&gt;
&lt;p&gt;在实际应用中，面包屑导航通常以层级路径的形式呈现，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;首页 &amp;gt; 分类 &amp;gt; 子分类 &amp;gt; 当前页面
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种导航方式不仅提升了用户体验，还能帮助用户快速定位和跳转，尤其是在层级较深的内容结构中。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;除了面包屑还有哪些导航方案&#34;&gt;除了面包屑，还有哪些导航方案？
&lt;/h2&gt;&lt;p&gt;虽然面包屑导航是个不错的选择，但根据不同的应用场景，还有其他几种常见的导航解决方案：&lt;/p&gt;
&lt;h3 id=&#34;返回按钮back-button&#34;&gt;返回按钮（Back Button）
&lt;/h3&gt;&lt;p&gt;最简单直接的方案，通常放在页面顶部或工具栏中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;← 返回  或  ⬅ Back
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：简单明了，用户认知成本低&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：只能返回上一级，无法直接跳转到更高层级&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;导航栏navigation-bar&#34;&gt;导航栏（Navigation Bar）
&lt;/h3&gt;&lt;p&gt;固定在页面顶部或侧边的导航菜单：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;首页 | 分类 | 设置 | 关于
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：始终可见，可以直接跳转到任意主要页面&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：占用屏幕空间，移动端可能需要折叠&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;侧边栏sidebar&#34;&gt;侧边栏（Sidebar）
&lt;/h3&gt;&lt;p&gt;通常在页面左侧或右侧显示层级结构：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;📁 首页
├── 📂 动漫
│   ├── 📖 海贼王
│   └── 📖 火影忍者
└── 📂 设置
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：清晰显示完整结构，支持多层级导航&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：占用较多屏幕空间&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;浮动按钮floating-action-button&#34;&gt;浮动按钮（Floating Action Button）
&lt;/h3&gt;&lt;p&gt;通常是一个圆形的浮动按钮，固定在屏幕某个位置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;🏠 (悬浮在右下角)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：不占用布局空间，随时可达&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：功能单一，可能遮挡内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;手势导航&#34;&gt;手势导航
&lt;/h3&gt;&lt;p&gt;通过滑动手势实现导航：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;向右滑动返回上一级
双击返回首页
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：操作流畅，符合移动端使用习惯&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：学习成本高，可发现性差&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;如何选择合适的导航方案&#34;&gt;如何选择合适的导航方案？
&lt;/h2&gt;&lt;p&gt;选择导航方案时需要考虑以下因素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;应用类型&lt;/strong&gt;：桌面应用、Web应用还是移动应用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户群体&lt;/strong&gt;：技术熟练度、使用习惯&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内容层级&lt;/strong&gt;：层级深度、结构复杂性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;屏幕空间&lt;/strong&gt;：可用空间大小、布局限制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用频率&lt;/strong&gt;：导航功能的使用频次&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于本地漫画浏览器这种场景，建议组合使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主要方案&lt;/strong&gt;：面包屑导航（清晰显示路径）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;辅助方案&lt;/strong&gt;：快捷键（提升效率）+ 浮动首页按钮（快速回到起点）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样既能满足不同用户的习惯，又能在各种场景下提供便捷的导航体验。&lt;/p&gt;</description>
        </item>
        <item>
        <title>微信备份工具局域网识别失败</title>
        <link>https://ttf248.life/p/wechat-backup-tool-local-network-recognition-failed/</link>
        <pubDate>Fri, 13 Jun 2025 23:04:42 +0800</pubDate>
        
        <guid>https://ttf248.life/p/wechat-backup-tool-local-network-recognition-failed/</guid>
        <description>&lt;p&gt;隔段时间就会清理手机上的资料，相册、微信聊天记录都会备份到电脑，手机上仅保留部分需要的聊天记录。&lt;/p&gt;
&lt;p&gt;以前都好好地，能轻松识别到手机和台式机在同一局域网内，直接备份聊天记录到电脑上，今天是各种失败。&lt;/p&gt;
&lt;h2 id=&#34;尝试过的解决方法&#34;&gt;尝试过的解决方法
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;电脑连接WIFI、手机连接WIFI，电脑和手机都在同一局域网内，依然无法识别。&lt;/li&gt;
&lt;li&gt;手机开启热点，电脑连接手机热点，依然无法识别。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;解决方案&#34;&gt;解决方案
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;台式机走的有线网络，手机走的无线网络，微信备份还原的时候，无法识别到这是局域网，我已经测试过了，台式能正常访问手机的IP地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想着是腾讯的东西，问问混元，是不是有思路，给的出来东西，没什么帮助。顺手扔给豆包，&lt;strong&gt;有惊喜&lt;/strong&gt;，提示我本地是不是有很多虚拟网络或者多网卡环境。&lt;/p&gt;
&lt;p&gt;这个倒是没错，台式机上有很多虚拟网卡，VMware、ZeroTier、Hyper-V、Docker Desktop 等等。台式机还有多个物理网卡，连接路由器的主网卡和另外一台机器组成子局域网的2.5G网卡。&lt;/p&gt;
&lt;p&gt;于是我在台式机上禁用了所有虚拟网卡和多余的物理网卡，保留了主网卡，重新尝试备份，果然成功了。&lt;/p&gt;</description>
        </item>
        <item>
        <title>内存布局和二进制兼容性</title>
        <link>https://ttf248.life/p/memory-layout-and-binary-compatibility/</link>
        <pubDate>Tue, 10 Jun 2025 18:53:02 +0800</pubDate>
        
        <guid>https://ttf248.life/p/memory-layout-and-binary-compatibility/</guid>
        <description>&lt;p&gt;C++ Linux 服务发生崩溃。服务依赖于某个静态库进行编译。&lt;/p&gt;
&lt;p&gt;静态库执行了修改，头文件增加了成员变量，重新发布了静态的二进制库文件&lt;/p&gt;
&lt;p&gt;服务依赖新的二进制库文件，能正常编译，运行就会崩溃，崩溃的地方明显没问题，有点类似上次编译器升级的崩溃，未定义行为，崩溃的堆栈不可信。
更新服务编译时依赖的头文件，能正常变异，运行也都正常&lt;/p&gt;
&lt;p&gt;详细解释这是为什么，涉及到什么计算机的知识，我猜测和内存布局相关，举例进行详细说明。&lt;/p&gt;
&lt;p&gt;这是一个典型的由于静态库的头文件和二进制库文件不匹配导致的崩溃问题，确实与内存布局相关。以下是详细解释：&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;问题分析&#34;&gt;问题分析
&lt;/h2&gt;&lt;p&gt;静态库的头文件定义了类的结构（包括成员变量、方法等），而静态库的二进制文件包含了实现代码。在编译服务时，编译器会根据头文件中的类定义来生成代码，包括内存布局和访问方式。如果头文件和静态库的二进制文件不匹配，就可能导致运行时的未定义行为。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;关键知识点&#34;&gt;关键知识点
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内存布局&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C++ 中，类的成员变量在内存中的布局是由编译器根据头文件定义决定的。&lt;/li&gt;
&lt;li&gt;如果头文件增加了成员变量，类的内存布局会发生变化。例如，新增成员变量可能会导致类的大小（&lt;code&gt;sizeof&lt;/code&gt;）增加，或者成员变量的偏移量发生变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;二进制兼容性&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态库的二进制文件是基于头文件生成的。如果服务编译时使用旧的头文件，而运行时链接的是新的静态库二进制文件，服务的代码会按照旧的内存布局访问类的成员变量，而静态库的实现代码则按照新的内存布局操作。这种不一致会导致未定义行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;未定义行为&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未定义行为可能表现为崩溃、错误的堆栈信息、甚至程序运行结果异常。这是因为程序在访问内存时可能访问到错误的地址或未初始化的区域。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;举例说明&#34;&gt;举例说明
&lt;/h2&gt;&lt;p&gt;假设静态库的头文件原来定义了以下类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class MyClass {
public:
    int a;
    void func();
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;静态库的二进制文件是基于上述定义编译的。&lt;/p&gt;
&lt;p&gt;后来头文件被修改为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class MyClass {
public:
    int a;
    int b;  // 新增成员变量
    void func();
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新的静态库二进制文件是基于修改后的头文件编译的。&lt;/p&gt;
&lt;p&gt;如果服务编译时仍然使用旧的头文件，以下问题可能发生：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内存布局不一致&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务认为 &lt;code&gt;MyClass&lt;/code&gt; 的大小是 &lt;code&gt;sizeof(int)&lt;/code&gt;，而静态库认为它是 &lt;code&gt;sizeof(int) * 2&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;服务访问 &lt;code&gt;MyClass&lt;/code&gt; 的成员变量时，可能会访问到错误的内存地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;方法调用问题&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果静态库的实现代码依赖新增的成员变量（如 &lt;code&gt;b&lt;/code&gt;），而服务的代码没有正确初始化 &lt;code&gt;b&lt;/code&gt;，运行时可能会导致崩溃。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;解决方法&#34;&gt;解决方法
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;头文件和二进制文件保持一致&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在服务编译时，确保使用与静态库二进制文件匹配的头文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;避免二进制不兼容修改&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果需要修改类的定义，尽量避免直接增加成员变量，可以通过继承或其他方式实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;重新编译所有依赖项&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当静态库发生修改时，重新编译所有依赖该库的服务，确保头文件和二进制文件一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结
&lt;/h2&gt;&lt;p&gt;这个问题的根本原因是头文件和二进制文件的不一致导致了内存布局的错误。C++ 的编译器在编译时根据头文件生成代码，而运行时的行为依赖于二进制文件。如果两者不匹配，就会导致未定义行为。通过确保头文件和二进制文件的一致性，可以避免类似问题。&lt;/p&gt;</description>
        </item>
        <item>
        <title>10.243.52.68 也属于局域网</title>
        <link>https://ttf248.life/p/102435268-also-belongs-to-the-local-area-network/</link>
        <pubDate>Fri, 06 Jun 2025 18:46:55 +0800</pubDate>
        
        <guid>https://ttf248.life/p/102435268-also-belongs-to-the-local-area-network/</guid>
        <description>&lt;p&gt;紧接上文，今天继续聊聊局域网的 IP 地址。上次为了同步代码，服务器配置了代理，服务器和家里的台式机打通了网络，在一个局域网里面，代理程序部署在台式机上，服务器通过代理访问外网。同步代码很慢，扔那边就没管了，隔了半个月，到服务器验证代码，发现&lt;code&gt;Git&lt;/code&gt;代码同步失败，网络错误，也没太过脑子，细看报错信息。&lt;/p&gt;
&lt;h2 id=&#34;案发现场&#34;&gt;案发现场
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;fatal: unable to access &amp;lsquo;&lt;a class=&#34;link&#34; href=&#34;https://cnb.cool/ttf248/learn/cpp.git/%27&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cnb.cool/ttf248/learn/cpp.git/&#39;&lt;/a&gt;: Failed to connect to 10.243.52.68 port 7897 after 7 ms: Couldn&amp;rsquo;t connect to server&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相当然的以为是不是阿里云服务和腾讯云原生开发平台有网络隔离，导致代码无法同步，报错信息扔到群里，群里有大聪明看到了端口信息，说这个是不是代理的ip，然后马上有人接着说，你这个是局域网，域名解析的都不对，这会脑子还在失忆阶段，完全不记得自己配过代理。&lt;/p&gt;
&lt;p&gt;看到&lt;strong&gt;局域网&lt;/strong&gt;三个字，脑子正常了，马上想起来自己配置过代理的事情，报错的地址是家里台式机的局域网地址。&lt;/p&gt;
&lt;p&gt;惯性思维：192.168.x.x 是局域网地址。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在计算机网络中，&lt;strong&gt;局域网（LAN）IP地址&lt;/strong&gt;是指在本地网络中使用的私有IP地址，这类地址不会直接暴露在公网上，主要用于内部设备通信。你提到的 &lt;code&gt;10.243.52.68&lt;/code&gt; 和 &lt;code&gt;192.168.x.x&lt;/code&gt; 都属于&lt;strong&gt;私有IP地址段&lt;/strong&gt;，但它们属于不同的地址范围，适用场景和规划逻辑也有所不同。以下是详细对比：&lt;/p&gt;
&lt;h2 id=&#34;私有ip地址的分类与范围&#34;&gt;&lt;strong&gt;私有IP地址的分类与范围&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;根据 &lt;a class=&#34;link&#34; href=&#34;https://datatracker.ietf.org/doc/rfc1918/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RFC 1918&lt;/a&gt; 标准，私有IP地址分为三大段，分别适用于不同规模的局域网：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;地址段&lt;/th&gt;
&lt;th&gt;子网掩码&lt;/th&gt;
&lt;th&gt;可用IP数量&lt;/th&gt;
&lt;th&gt;适用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;10.0.0.0/8&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;255.0.0.0&lt;/td&gt;
&lt;td&gt;约1600万个&lt;/td&gt;
&lt;td&gt;大型企业、园区网络&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;172.16.0.0/12&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;255.240.0.0&lt;/td&gt;
&lt;td&gt;约100万个&lt;/td&gt;
&lt;td&gt;中型企业网络&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;192.168.0.0/16&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;255.255.0.0&lt;/td&gt;
&lt;td&gt;约6.5万个&lt;/td&gt;
&lt;td&gt;小型局域网（家庭、办公室）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;你的问题中的ip地址解析&#34;&gt;&lt;strong&gt;你的问题中的IP地址解析：&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;10.243.52.68&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
属于 &lt;strong&gt;&lt;code&gt;10.0.0.0/8&lt;/code&gt; 段&lt;/strong&gt;，是大型私有网络的典型地址，常用于企业级局域网或广域网（如跨多个分支机构的内部网络）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;192.168.x.x&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
属于 &lt;strong&gt;&lt;code&gt;192.168.0.0/16&lt;/code&gt; 段&lt;/strong&gt;，是最常见的小型私有网络地址，广泛用于家庭路由器、小型办公室等场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;两者的核心区别&#34;&gt;&lt;strong&gt;两者的核心区别&lt;/strong&gt;
&lt;/h2&gt;&lt;h3 id=&#34;地址空间大小&#34;&gt;&lt;strong&gt;地址空间大小&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;10.0.0.0/8&lt;/code&gt;&lt;/strong&gt;：&lt;br&gt;
整个网段的地址范围是 &lt;code&gt;10.0.0.0 ~ 10.255.255.255&lt;/code&gt;，包含 &lt;strong&gt;16,777,216 个可用IP地址&lt;/strong&gt;，适合需要大量IP地址的大型网络（如企业、学校、数据中心）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;192.168.0.0/16&lt;/code&gt;&lt;/strong&gt;：&lt;br&gt;
地址范围是 &lt;code&gt;192.168.0.0 ~ 192.168.255.255&lt;/code&gt;，仅包含 &lt;strong&gt;65,536 个可用IP地址&lt;/strong&gt;，适用于设备数量较少的小型网络（如家庭中通常只有几十台设备）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;子网划分灵活性&#34;&gt;&lt;strong&gt;子网划分灵活性&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;10.0.0.0/8&lt;/code&gt;&lt;/strong&gt;：&lt;br&gt;
由于地址空间大，可通过&lt;strong&gt;子网掩码&lt;/strong&gt;进一步划分为多个子网（如 &lt;code&gt;10.1.0.0/16&lt;/code&gt;、&lt;code&gt;10.2.0.0/16&lt;/code&gt; 等），便于大型网络的分层管理和流量隔离。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;192.168.0.0/16&lt;/code&gt;&lt;/strong&gt;：&lt;br&gt;
通常直接使用默认子网掩码 &lt;code&gt;255.255.0.0&lt;/code&gt;，划分子网的需求较少，适合简单的扁平网络结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;常见应用场景&#34;&gt;&lt;strong&gt;常见应用场景&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;10.xxx.xxx.xxx&lt;/code&gt;&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;企业内部网络：如跨国公司的多个分支机构通过VPN连接，每个分支可分配独立的子网（如 &lt;code&gt;10.1.1.0/24&lt;/code&gt;、&lt;code&gt;10.1.2.0/24&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;云服务商内部网络：如AWS、阿里云等私有云环境常使用 &lt;code&gt;10.&lt;/code&gt; 段地址。&lt;/li&gt;
&lt;li&gt;工业控制网络：部分工业设备默认使用 &lt;code&gt;10.&lt;/code&gt; 段地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;192.168.xxx.xxx&lt;/code&gt;&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;家庭/小型办公室：路由器默认分配的地址（如 &lt;code&gt;192.168.1.1&lt;/code&gt; 或 &lt;code&gt;192.168.0.1&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;小型局域网共享：如通过路由器组建的WiFi网络，设备数量通常不超过200台。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;与公网的隔离性&#34;&gt;&lt;strong&gt;与公网的隔离性&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;两者均为私有地址，&lt;strong&gt;无法直接被公网访问&lt;/strong&gt;，需通过 &lt;strong&gt;NAT（网络地址转换）&lt;/strong&gt; 或 &lt;strong&gt;VPN&lt;/strong&gt; 连接到公网。但在实际使用中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;10.&lt;/code&gt; 段常用于需要更复杂网络架构的场景（如多子网、VLAN划分）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;192.168.&lt;/code&gt; 段因地址空间小，更适合即插即用的简单网络。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;为什么你会看到-10-段地址&#34;&gt;&lt;strong&gt;为什么你会看到 &lt;code&gt;10.&lt;/code&gt; 段地址？&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;如果你在本地网络中发现 &lt;code&gt;10.243.52.68&lt;/code&gt; 这样的地址，可能原因包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;企业级网络环境&lt;/strong&gt;：&lt;br&gt;
你所在的公司或机构使用 &lt;code&gt;10.&lt;/code&gt; 段作为内部IP地址，用于区分不同部门或设备（如服务器、办公电脑）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟机或容器网络&lt;/strong&gt;：&lt;br&gt;
云计算平台（如VMware、Docker）常默认使用 &lt;code&gt;10.&lt;/code&gt; 段地址为虚拟机分配IP。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特殊设备默认配置&lt;/strong&gt;：&lt;br&gt;
部分网络设备（如工业交换机、防火墙）出厂时可能预设 &lt;code&gt;10.&lt;/code&gt; 段地址。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;总结如何选择使用&#34;&gt;&lt;strong&gt;总结：如何选择使用？&lt;/strong&gt;
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;小型网络（家庭/办公室）&lt;/strong&gt;：优先选择 &lt;code&gt;192.168.x.x&lt;/code&gt;，配置简单且足够用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中大型网络（企业/园区）&lt;/strong&gt;：使用 &lt;code&gt;10.x.x.x&lt;/code&gt; 或 &lt;code&gt;172.16.x.x&lt;/code&gt;，便于划分子网和管理大量设备。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两者本质上都是局域网地址，区别仅在于地址空间和适用场景，并无技术上的优劣之分，具体取决于网络规划需求。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Git单独配置代理</title>
        <link>https://ttf248.life/p/git-single-configuration-proxy/</link>
        <pubDate>Fri, 06 Jun 2025 18:29:46 +0800</pubDate>
        
        <guid>https://ttf248.life/p/git-single-configuration-proxy/</guid>
        <description>&lt;p&gt;国内访问 GitHub 速度较慢，可以通过配置代理来加速访问。还有个方式，找个国内的托管平台，比如码云、Coding 等。配置对应的构建流水线，将代码同步到 GitHub。&lt;/p&gt;
&lt;p&gt;用了很多年的&lt;code&gt;coding&lt;/code&gt;，界面简洁，近期发布公告，免费版不能继续用了，需要迁移到腾讯的新平台&lt;code&gt;cnb&lt;/code&gt;，顺带吐槽下，阿里的托管平台，整个界面设计，&lt;strong&gt;班味&lt;/strong&gt;很重。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://cnb.cool/ttf248&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cnb.cool/ttf248&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;仓库迁移&#34;&gt;仓库迁移
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;cnb&lt;/code&gt;官网提供了迁移工具，可以批量将代码从&lt;code&gt;github&lt;/code&gt;迁移到&lt;code&gt;cnb&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.cnb.cool/zh/guide/migration-tools.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.cnb.cool/zh/guide/migration-tools.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;git-配置代理&#34;&gt;Git 配置代理
&lt;/h2&gt;&lt;p&gt;不配置加速，工具同步很慢，代码会先同步到本地，然后上传到远程仓库。&lt;/p&gt;
&lt;p&gt;Git 可以通过以下命令单独配置 HTTP 代理，不影响系统全局设置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 设置 HTTP 代理
git config --global http.proxy http://proxy.example.com:8080

# 设置 HTTPS 代理
git config --global https.proxy http://proxy.example.com:8080

# 可选：仅为特定域名设置代理
git config --global http.https://github.com.proxy http://proxy.example.com:8080
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果需要取消代理配置，可以使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git config --global --unset http.proxy
git config --global --unset https.proxy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看当前代理配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git config --global --get http.proxy
git config --global --get https.proxy
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Prometheus监控系统Histogram和Summary</title>
        <link>https://ttf248.life/p/prometheus-monitoring-system-histogram-and-summary/</link>
        <pubDate>Wed, 04 Jun 2025 19:00:28 +0800</pubDate>
        
        <guid>https://ttf248.life/p/prometheus-monitoring-system-histogram-and-summary/</guid>
        <description>&lt;p&gt;业务系统设计了 Summary 类型的监控指标，计算平均耗时：request_duration_milliseconds_sum / request_duration_milliseconds_count。&lt;/p&gt;
&lt;p&gt;查看数据，发现某个接口平均耗时很高，翻看时序图，平均耗时是突然增加的，等于就是某次请求耗时很高，拉高了平均值，想查具体是什么时候发生的请求，由于时段内的请求太少，查出来的数据一直空。&lt;/p&gt;
&lt;h2 id=&#34;答疑&#34;&gt;答疑
&lt;/h2&gt;&lt;h3 id=&#34;-为什么-_sum-和-_count-有数据&#34;&gt;✅ 为什么 &lt;code&gt;_sum&lt;/code&gt; 和 &lt;code&gt;_count&lt;/code&gt; 有数据
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_sum&lt;/code&gt; 和 &lt;code&gt;_count&lt;/code&gt; 是 Summary 类型的&lt;strong&gt;核心指标&lt;/strong&gt;，Prometheus 始终会采集并记录这两个值；&lt;/li&gt;
&lt;li&gt;它们是&lt;strong&gt;累积型的 counter&lt;/strong&gt;，适合用 &lt;code&gt;rate()&lt;/code&gt; 或 &lt;code&gt;increase()&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;无论请求延迟如何变化，只要有请求，就一定会有 &lt;code&gt;_sum&lt;/code&gt; 和 &lt;code&gt;_count&lt;/code&gt; 数据；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;-为什么-quantile099-可能无法在时序图中展示&#34;&gt;❌ 为什么 &lt;code&gt;{quantile=&amp;quot;0.99&amp;quot;}&lt;/code&gt; 可能&lt;strong&gt;无法在时序图中展示&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;哪怕 Summary 配置了 quantile=&amp;ldquo;0.99&amp;rdquo;，这个时间序列也可能不存在或缺失&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;指标肯定是配置了，数据也没有过期，📉 请求量太小，quantile 无法计算，滑动窗口机制，过了这段时间，就不会再纳入统计范围。&lt;/p&gt;
&lt;p&gt;分位数（如 p99）是通过采样统计计算的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果某段时间内请求数太少（如 1~2 个请求），p99 的计算是&lt;strong&gt;不稳定或没有代表意义&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;Prometheus &lt;strong&gt;客户端 SDK 会选择不暴露该 quantile 时间序列&lt;/strong&gt;，以避免误导；&lt;/li&gt;
&lt;li&gt;所以你会看到 &lt;code&gt;_sum&lt;/code&gt;、&lt;code&gt;_count&lt;/code&gt; 正常累加，但 &lt;code&gt;quantile=&amp;quot;0.99&amp;quot;&lt;/code&gt; 没数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;histogram-和-summary-的区别&#34;&gt;Histogram 和 Summary 的区别
&lt;/h2&gt;&lt;h3 id=&#34;histogram&#34;&gt;&lt;strong&gt;Histogram&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;工作原理&lt;/strong&gt;:&lt;br&gt;
Histogram 会将数据分桶（buckets），记录每个桶中落入的样本数量。&lt;br&gt;
例如，定义的桶为 &lt;code&gt;[10ms, 50ms, 100ms, 500ms, 1s]&lt;/code&gt;，每次请求的耗时会被归入对应的桶中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以在 Prometheus 中聚合多个实例的数据（例如多个服务节点的请求耗时分布）。&lt;/li&gt;
&lt;li&gt;适合计算分位数（如 P50、P95、P99）和观察耗时分布。&lt;/li&gt;
&lt;li&gt;提供了灵活的查询能力，支持通过 PromQL 动态计算分位数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要预定义桶的范围，选择不当可能导致数据分布不均（例如，所有请求都落在一个桶中）。&lt;/li&gt;
&lt;li&gt;桶的数量越多，存储和计算的开销越大。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;适用场景&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要聚合多个实例的数据。&lt;/li&gt;
&lt;li&gt;需要动态调整分位数或分析耗时分布。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;summary&#34;&gt;&lt;strong&gt;Summary&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;工作原理&lt;/strong&gt;:&lt;br&gt;
Summary 会在客户端直接计算分位数（如 P50、P95、P99），并将结果上报到 Prometheus。&lt;br&gt;
它还会记录样本的总数和总和，用于计算平均值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不需要预定义桶，直接提供分位数结果。&lt;/li&gt;
&lt;li&gt;适合单实例的精确分位数计算。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分位数的计算是在客户端完成的，无法在 Prometheus 中聚合多个实例的数据。&lt;/li&gt;
&lt;li&gt;如果需要调整分位数（如从 P95 改为 P99），需要修改代码并重新部署。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;适用场景&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单实例监控，且对分位数的精确性要求较高。&lt;/li&gt;
&lt;li&gt;不需要聚合多个实例的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;主要区别对比&#34;&gt;&lt;strong&gt;主要区别对比&lt;/strong&gt;
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;Histogram&lt;/th&gt;
&lt;th&gt;Summary&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;分位数计算&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;在 Prometheus 中动态计算&lt;/td&gt;
&lt;td&gt;在客户端直接计算&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;多实例聚合&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;桶的定义&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;需要预定义&lt;/td&gt;
&lt;td&gt;不需要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;存储开销&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;取决于桶的数量&lt;/td&gt;
&lt;td&gt;固定开销&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;灵活性&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;高（可动态调整分位数）&lt;/td&gt;
&lt;td&gt;低（需修改代码调整分位数）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;总结&#34;&gt;&lt;strong&gt;总结&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;如果需要聚合多个实例的数据，或者需要灵活调整分位数，选择 &lt;strong&gt;Histogram&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果只需要单实例的精确分位数，且分位数固定，选择 &lt;strong&gt;Summary&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在你的场景中，由于服务是分布式的，建议优先使用 &lt;strong&gt;Histogram&lt;/strong&gt;，这样可以在 Prometheus 中聚合所有实例的数据，并动态计算分位数和耗时分布。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;滑动窗口的概念及其与-histogram-和-summary-的关系&#34;&gt;滑动窗口的概念及其与 Histogram 和 Summary 的关系
&lt;/h2&gt;&lt;h3 id=&#34;滑动窗口的概念&#34;&gt;&lt;strong&gt;滑动窗口的概念&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;滑动窗口是一种时间窗口机制，用于统计一段时间内的数据变化。它通过不断移动的时间范围，动态反映系统的实时状态。滑动窗口的特点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;固定时间范围&lt;/strong&gt;：窗口的长度是固定的，例如最近 1 分钟、5 分钟。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实时更新&lt;/strong&gt;：随着时间的推移，窗口会滑动，旧的数据被移出窗口，新数据被加入窗口。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;常见用途&lt;/strong&gt;：用于计算实时指标（如请求速率、平均值、分位数等）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Prometheus 中，滑动窗口通常通过查询函数（如 &lt;code&gt;rate()&lt;/code&gt;、&lt;code&gt;avg_over_time()&lt;/code&gt;）实现。&lt;/p&gt;
&lt;h3 id=&#34;滑动窗口与-histogram-的关系&#34;&gt;&lt;strong&gt;滑动窗口与 Histogram 的关系&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Histogram 的数据结构&lt;/strong&gt;：&lt;br&gt;
Histogram 会将样本数据分桶，并记录每个桶的计数。Prometheus 会周期性地抓取这些计数值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;滑动窗口的实现&lt;/strong&gt;：&lt;br&gt;
在 Prometheus 中，可以通过查询语句对 Histogram 的数据应用滑动窗口。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rate(http_request_duration_seconds_bucket[5m])&lt;/code&gt;：计算过去 5 分钟内每个桶的请求速率。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))&lt;/code&gt;：计算过去 5 分钟内的 P95 分位数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;滑动窗口可以动态反映最近一段时间的请求耗时分布。&lt;/li&gt;
&lt;li&gt;Histogram 的分桶机制与滑动窗口结合，可以高效计算分位数和分布。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;滑动窗口与-summary-的关系&#34;&gt;&lt;strong&gt;滑动窗口与 Summary 的关系&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Summary 的数据结构&lt;/strong&gt;：&lt;br&gt;
Summary 会在客户端直接计算分位数，并上报到 Prometheus。它还会记录样本总数和总和。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;滑动窗口的实现&lt;/strong&gt;：&lt;br&gt;
在 Prometheus 中，可以通过查询语句对 Summary 的数据应用滑动窗口。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rate(http_request_duration_seconds_sum[5m]) / rate(http_request_duration_seconds_count[5m])&lt;/code&gt;：计算过去 5 分钟内的平均请求耗时。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;限制&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Summary 的分位数是客户端计算的，无法在 Prometheus 中重新计算分位数，因此滑动窗口对分位数的支持有限。&lt;/li&gt;
&lt;li&gt;如果需要聚合多个实例的数据，滑动窗口无法直接作用于 Summary 的分位数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;滑动窗口的适用场景&#34;&gt;&lt;strong&gt;滑动窗口的适用场景&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;实时监控&lt;/strong&gt;：滑动窗口适合用于监控系统的实时状态，例如最近 1 分钟的请求速率、耗时分布等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异常检测&lt;/strong&gt;：通过滑动窗口，可以快速发现短时间内的异常情况（如请求耗时突然增加）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态分析&lt;/strong&gt;：滑动窗口可以动态反映系统的变化趋势，而不是静态的全局统计。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;总结-1&#34;&gt;&lt;strong&gt;总结&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Histogram&lt;/strong&gt; 与滑动窗口结合，可以动态计算分位数（如 P95、P99）和请求耗时分布，适合分布式系统的监控。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Summary&lt;/strong&gt; 与滑动窗口结合，可以计算平均值等简单指标，但分位数的灵活性较差，且不支持多实例聚合。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在你的场景中，由于需要监控极端请求耗时（如 P99）和大部分请求的平均值，建议使用 &lt;strong&gt;Histogram&lt;/strong&gt;，并结合滑动窗口查询来动态分析系统的性能表现。&lt;/p&gt;</description>
        </item>
        <item>
        <title>博客翻译项目碎碎念：文化传播、AI编程</title>
        <link>https://ttf248.life/p/blog-translation-project-musings-cultural-transmission-ai-programming/</link>
        <pubDate>Mon, 02 Jun 2025 21:41:00 +0800</pubDate>
        
        <guid>https://ttf248.life/p/blog-translation-project-musings-cultural-transmission-ai-programming/</guid>
        <description>&lt;p&gt;文化传播：意识形态上的影响，潜移默化。
AI编程：不做软件设计，返工很多&lt;/p&gt;
&lt;h2 id=&#34;文化传播&#34;&gt;文化传播
&lt;/h2&gt;&lt;p&gt;起初项目仅仅支持了英语、日语、韩语三种语言，后面想着反正都是AI翻译，何不多支持几种语言呢？于是又增加了法语、俄罗斯语、印度语。此时还没发现问题，程序执行翻译的时候，由于历史的代码存在问题，翻译出来的格式不对，存档的文章需要重新翻译。&lt;/p&gt;
&lt;p&gt;统计耗时提醒，全部翻译完成需要将近20小时，毕竟是本地部署的大模型，那会还是用 12b 参数的大模型。想着干掉几个不常用的语言，减少翻译时间。于是删除了法语、俄罗斯语、印度语。这时候感觉到了不对劲，为什么开始的语言里面，我会选择韩语、日语。&lt;/p&gt;
&lt;p&gt;按照全球人口的分布，这两个语言的受众人群并不多，尤其是韩语，全球使用人数大概只有8000万左右。日语稍微多一点，大概1.2亿人。相比之下，法语、俄罗斯语、印度语的使用人数都在1亿以上。&lt;/p&gt;
&lt;p&gt;这时候才意识到，韩语、日语的受众人群并不是因为语言使用人数多，而是因为文化传播的影响。韩国和日本的文化在全球范围内有着广泛的影响力，尤其是在亚洲地区。K-pop、动漫、影视剧等文化产品吸引了大量粉丝，这些粉丝自然也会对相关语言产生兴趣。&lt;/p&gt;
&lt;p&gt;回顾成长的历程，小时经常看日本的动漫、漫画，长大了看了很多韩国的电影、电视剧。导致我在项目设置初始语言的时候，下意识的选择了这两个熟悉的语言。&lt;/p&gt;
&lt;h3 id=&#34;软件设计与ai编程&#34;&gt;软件设计与AI编程
&lt;/h3&gt;&lt;p&gt;翻译助手最初只是一个简单的小工具，但在体验了 Claude4 的编码能力后，逐渐扩展了功能，增加了文章翻译、标签翻译等模块。随着功能的增加，代码复杂度也随之提升。虽然 AI 重构代码后目录结构显得更清晰，但在扩展新功能或修复缺陷时，AI生成的代码常常存在重复问题。&lt;/p&gt;
&lt;p&gt;AI在生成代码时，缺乏对整体结构和设计理念的理解。它通常基于已有代码进行修改和扩展，却未能有效复用已有模块，导致代码冗余。每次都需要手动清理重复代码，这无形中增加了开发成本。&lt;/p&gt;
&lt;p&gt;此外，AI生成的代码虽然语法正确，但在逻辑和设计上往往存在问题。例如，在另一个项目中稍微调整提示词后，生成的网页结构完全不同，缺乏一致性。这反映了项目初期缺乏合理设计，功能的增加更多是随意堆砌，导致代码结构混乱。&lt;/p&gt;
&lt;p&gt;这也提醒我们，软件工程的核心经验仍然不可忽视。合理的设计不仅能减少返工，还能提升代码的可维护性和扩展性。AI虽然是强大的工具，但它无法替代人类对系统设计的深刻理解和规划。&lt;/p&gt;</description>
        </item>
        <item>
        <title>博客翻译项目碎碎念：历史会话</title>
        <link>https://ttf248.life/p/blog-translation-project-musings-historical-conversations/</link>
        <pubDate>Mon, 02 Jun 2025 21:16:24 +0800</pubDate>
        
        <guid>https://ttf248.life/p/blog-translation-project-musings-historical-conversations/</guid>
        <description>&lt;p&gt;博客翻译项目最初设计过于复杂——先解析 Markdown 格式，再用占位符保护内容，最后送给大模型翻译。其实这完全是多此一举，大模型本身就具备识别 Markdown 语法的能力，可以直接处理原始内容并在翻译时保持格式完整。&lt;/p&gt;
&lt;p&gt;我们的工作就从调试代码，切换到调试大模型的&lt;strong&gt;提示词&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;模型：&lt;code&gt;google/gemma-3-4b&lt;/code&gt;
硬件：&lt;code&gt;Nvdia 3060 12GB&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;没错，选的非思考模型，思考模型在执行翻译任务时，效率不够高，对比了 4b 参数和 12b 参数的效果，针对翻译任务来说 gemma3 的 4b 参数已经足够了，12b 的参数在翻译任务上并没有明显的优势。&lt;/p&gt;
&lt;p&gt;12b 参数的速度：&lt;strong&gt;11.32 tok/sec&lt;/strong&gt;，4b 参数的速度：&lt;strong&gt;75.21 tok/sec&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;背景介绍&#34;&gt;背景介绍
&lt;/h2&gt;&lt;p&gt;尽管在&lt;strong&gt;system&lt;/strong&gt;里面加上了各种条件限制，输出的翻译结果，还是会出现一些问题，比如：格式没有保护，多出来了一些解释的内容。角色定义的时候，已经声明过，记得保护 Markdown 格式、仅输出翻译结果，最终的翻译还是不太稳定。&lt;/p&gt;
&lt;p&gt;此时想起来，以前接触过一个漫画翻译的项目，也用到了大模型的能力，它的翻译效果好像比我的效果更好一些，翻看代码，对比请求的数据，漫画翻译的项目，每次请求都会带上一组上下文，除了当前的翻译内容，还会带上之前的翻译内容。&lt;/p&gt;
&lt;p&gt;好处是什么，不仅能提升前后翻译的连贯性，还剩确保输出格式的稳定性。&lt;/p&gt;
&lt;h2 id=&#34;历史会话的重要性&#34;&gt;历史会话的重要性
&lt;/h2&gt;&lt;p&gt;随着 AI 大模型（如 GPT 系列、Claude、Gemini 等）的普及，越来越多企业和开发者通过 API 接入这些模型，构建智能客服、内容生成、代码助手等应用。然而，许多人在接入初期会遇到一个常见问题：&lt;strong&gt;模型输出不连贯、缺乏上下文理解，甚至答非所问&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;造成这种现象的一个关键原因是——&lt;strong&gt;没有在 API 请求中包含历史对话内容&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;什么是历史对话&#34;&gt;什么是历史对话？
&lt;/h2&gt;&lt;p&gt;历史对话是指在一次对话会话中，模型和用户之间之前的交流记录。在大多数大模型 API（如 OpenAI 的 Chat Completions API）中，开发者需要自己在请求中构建完整的 &lt;code&gt;messages&lt;/code&gt; 数组，将历史对话以轮流的 &lt;code&gt;user&lt;/code&gt; 和 &lt;code&gt;assistant&lt;/code&gt; 消息形式传入。&lt;/p&gt;
&lt;h3 id=&#34;示例&#34;&gt;示例
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;model&amp;quot;: &amp;quot;gpt-4&amp;quot;,
  &amp;quot;messages&amp;quot;: [
    {&amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;帮我写一封辞职信&amp;quot;},
    {&amp;quot;role&amp;quot;: &amp;quot;assistant&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;好的，你希望辞职的原因写些什么？&amp;quot;},
    {&amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;说我想追求个人职业发展&amp;quot;}
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你只发送最后一句话：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;说我想追求个人职业发展&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;模型根本不知道你在说辞职信，它可能完全无法理解上下文，输出质量自然很差。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;为什么历史对话如此重要&#34;&gt;为什么历史对话如此重要？
&lt;/h2&gt;&lt;h3 id=&#34;1-构建上下文提升连贯性&#34;&gt;1. &lt;strong&gt;构建上下文，提升连贯性&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;AI 模型本质上是“上下文驱动”的。它无法记住“之前”发生的任何事情，除非你&lt;strong&gt;显式告诉它&lt;/strong&gt;。通过传入对话历史，模型可以更好地理解你的意图和话题背景，输出更符合预期。&lt;/p&gt;
&lt;h3 id=&#34;2-降低误解率&#34;&gt;2. &lt;strong&gt;降低误解率&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;如果你希望模型完成一个多轮指令，如写作、总结、调试代码，历史记录能让模型逐步积累理解，避免在中途“跑题”或丢失重点。&lt;/p&gt;
&lt;h3 id=&#34;3-模拟真实人类对话行为&#34;&gt;3. &lt;strong&gt;模拟真实人类对话行为&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;在实际应用中，如客服系统、教育助手、健康咨询等，用户的问题往往是逐步展开的，而不是一次性表达清楚。保留对话历史，可以让 AI 更像一个“有记忆力的助理”。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;如何在-api-中正确添加历史对话&#34;&gt;如何在 API 中正确添加历史对话？
&lt;/h2&gt;&lt;p&gt;以 OpenAI 的 API 为例，建议遵循以下结构：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;messages = [
    {&amp;quot;role&amp;quot;: &amp;quot;system&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;你是一个专业的法律助手&amp;quot;},
    {&amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;什么是合同的有效条件？&amp;quot;},
    {&amp;quot;role&amp;quot;: &amp;quot;assistant&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;合同有效需要满足以下几个条件：……&amp;quot;},
    {&amp;quot;role&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;那口头协议算吗？&amp;quot;}
]

response = openai.ChatCompletion.create(
    model=&amp;quot;gpt-4&amp;quot;,
    messages=messages
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;system&lt;/code&gt; 消息设定模型行为和身份。&lt;/li&gt;
&lt;li&gt;保留最近几轮关键对话即可，不需要每次传入全部历史（避免超过 token 限制）。&lt;/li&gt;
&lt;li&gt;在长会话中，可通过截断早期内容，保留核心信息摘要，控制 token 消耗。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;实践建议&#34;&gt;实践建议
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;对话状态管理&lt;/strong&gt;：后端需设计缓存机制，记录每个用户的会话历史（如 Redis、数据库）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;限制长度&lt;/strong&gt;：OpenAI GPT-4 的上下文长度为 128k tokens，Claude 3 可达 200k~1M，需合理裁剪。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态摘要历史&lt;/strong&gt;：当历史内容过长时，使用模型先对旧对话做摘要，再添加进对话上下文。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结
&lt;/h2&gt;&lt;p&gt;AI 大模型的能力强大，但也需要开发者“喂”给它足够的上下文信息。&lt;strong&gt;通过在 API 请求中添加历史对话，不仅能显著提升模型输出的质量和连贯性，也能让用户体验更自然、更贴近真实对话。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无论你是在构建 AI 客服、写作助手、编程帮手，还是教育类应用，这都是一个不可忽视的优化技巧。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Go 项目查找所有没有引用的函数</title>
        <link>https://ttf248.life/p/find-all-functions-not-referenced-in-the-go-project/</link>
        <pubDate>Mon, 02 Jun 2025 21:10:47 +0800</pubDate>
        
        <guid>https://ttf248.life/p/find-all-functions-not-referenced-in-the-go-project/</guid>
        <description>&lt;p&gt;在 Go 语言项目中，使用 &lt;code&gt;staticcheck&lt;/code&gt; 查找未引用的函数是一种高效的静态分析方法。&lt;/p&gt;
&lt;h3 id=&#34;1-安装-staticcheck&#34;&gt;&lt;strong&gt;1. 安装 staticcheck&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;确保已安装 Go（版本 1.16+），然后执行以下命令安装 &lt;code&gt;staticcheck&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go install honnef.co/go/tools/cmd/staticcheck@latest
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-基本用法查找未引用的函数&#34;&gt;&lt;strong&gt;2. 基本用法：查找未引用的函数&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;在项目根目录下执行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;staticcheck ./...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;关键检查规则&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;U1000&lt;/strong&gt;：检测未使用的函数、方法、变量或类型。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;U1001&lt;/strong&gt;：检测未使用的参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-过滤特定检查规则&#34;&gt;&lt;strong&gt;3. 过滤特定检查规则&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;若只需检查未使用的函数，可指定规则：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;staticcheck -checks=U1000 ./...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-输出格式&#34;&gt;&lt;strong&gt;4. 输出格式&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;默认输出格式为 &lt;code&gt;{path}:{line}:{column}: {message}&lt;/code&gt;，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;main.go:10:2: func UnusedFunction is unused (U1000)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-配置文件可选&#34;&gt;&lt;strong&gt;5. 配置文件（可选）&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;在项目根目录创建 &lt;code&gt;.staticcheck.conf&lt;/code&gt; 文件，自定义检查规则：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;checks&amp;quot;: [&amp;quot;U1000&amp;quot;, &amp;quot;-ST1000&amp;quot;]  // 启用 U1000，禁用 ST1000（字符串格式化规则）
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6-集成到-vs-code&#34;&gt;&lt;strong&gt;6. 集成到 VS Code&lt;/strong&gt;
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装 &lt;a class=&#34;link&#34; href=&#34;https://marketplace.visualstudio.com/items?itemName=golang.go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 扩展&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;settings.json&lt;/code&gt; 中添加：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;go.lintTool&amp;quot;: &amp;quot;staticcheck&amp;quot;,
  &amp;quot;go.lintFlags&amp;quot;: [&amp;quot;-checks=U1000&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;7-忽略特定代码&#34;&gt;&lt;strong&gt;7. 忽略特定代码&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;在函数上方添加注释 &lt;code&gt;//lint:ignore U1000 reason&lt;/code&gt; 可忽略检查：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//lint:ignore U1000 Used by generated code
func UnusedButNeeded() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;常见问题解答&#34;&gt;&lt;strong&gt;常见问题解答&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Q：如何处理测试文件中的未使用函数？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：&lt;code&gt;staticcheck&lt;/code&gt; 默认会检查测试文件。若需排除，可使用 &lt;code&gt;-tests=false&lt;/code&gt; 标志。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Q：如何在 CI/CD 中集成？&lt;/strong&gt;&lt;br&gt;
A：在 GitHub Actions 中添加：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;- name: Run staticcheck
  run: staticcheck -checks=U1000 ./...
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;示例输出&#34;&gt;&lt;strong&gt;示例输出&lt;/strong&gt;
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ staticcheck -checks=U1000 ./...
internal/utils/helper.go:15:2: func privateHelper is unused (U1000)
cmd/server/main.go:23:2: func initConfig is unused (U1000)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过 &lt;code&gt;staticcheck&lt;/code&gt; 的 &lt;code&gt;U1000&lt;/code&gt; 规则，你可以快速定位并清理未引用的函数，提高代码质量。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Git子模块递交记录丢失</title>
        <link>https://ttf248.life/p/git-submodule-merge-history-lost/</link>
        <pubDate>Mon, 02 Jun 2025 16:44:58 +0800</pubDate>
        
        <guid>https://ttf248.life/p/git-submodule-merge-history-lost/</guid>
        <description>&lt;p&gt;本地有一个 Git 仓库，其中的子模块在拉取时处于一个临时分支。我在该临时分支上提交了一些代码，随后将子模块切换回了 &lt;code&gt;main&lt;/code&gt; 分支。然而，这些提交的代码似乎丢失了，无法在 &lt;code&gt;main&lt;/code&gt; 分支中找到。我也找不到那个临时分支的记录。&lt;/p&gt;
&lt;h2 id=&#34;解决方案&#34;&gt;解决方案
&lt;/h2&gt;&lt;p&gt;在Git子模块中提交到了临时分支，切换回&lt;code&gt;main&lt;/code&gt;分支后找不到这些提交。这种情况可以通过以下步骤解决：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;确认提交记录&lt;/strong&gt;：进入子模块目录，查看reflog找到丢失的提交&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;创建新分支保存提交&lt;/strong&gt;：基于丢失的提交创建新分支&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;合并或 cherry-pick 提交到 main&lt;/strong&gt;：将代码整合到主分支&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是具体的操作步骤：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 进入子模块目录
cd path/to/your/submodule

# 查看reflog记录所有HEAD变更（包括未关联分支的提交）
git reflog

PS F:\dev\notebook\scripts\hugo-content-suite&amp;gt; git reflog
de05175 (HEAD -&amp;gt; main, origin/main, origin/HEAD) HEAD@{0}: checkout: moving from c8d070651310e90d283cb64d98da088c5fe05e73 to main
c8d0706 HEAD@{1}: commit: feat: 添加Markdown标记符用法文档，提供详细语法示例与效果展示
48250f5 HEAD@{2}: commit: feat: 移除文章翻译预览功能，简化翻译流程
b8280b6 HEAD@{3}: commit: feat: 添加获取绝对路径功能，支持将相对路径转换为绝对路径
92c354b HEAD@{4}: commit: fix: 修复文章扫描逻辑，确保使用绝对路径进行扫描
de05175 (HEAD -&amp;gt; main, origin/main, origin/HEAD) HEAD@{5}: checkout: moving from main to de05175d4ec0828e3ae95d726b09dfff18f67a23
de05175 (HEAD -&amp;gt; main, origin/main, origin/HEAD) HEAD@{6}: clone: from https://cnb.cool/ttf248/hugo-content-suite.git

# 基于丢失的提交创建新分支（例如使用456def提交）
git checkout -b saved-work 456def

# 切换回main分支
git checkout main

# 将保存的工作合并到main（或使用cherry-pick选择特定提交）
git merge saved-work
# 或
git cherry-pick 456def

# 返回主项目目录并提交子模块更新
cd ..
git add path/to/your/submodule
git commit -m &amp;quot;Update submodule to include new changes&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;关键操作说明&#34;&gt;关键操作说明
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;git reflog&lt;/strong&gt;：显示HEAD的所有历史记录，包括未关联到分支的提交&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;git checkout -b&lt;/strong&gt;：从任意提交创建新分支，保存你的工作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;git merge/cherry-pick&lt;/strong&gt;：将保存的提交整合到目标分支&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果reflog中找不到记录，可能需要尝试使用&lt;code&gt;git fsck --lost-found&lt;/code&gt;查找 orphaned commits，但这种情况比较少见。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Github Pages 彩蛋：部署多个 Pages</title>
        <link>https://ttf248.life/p/github-pages-easter-egg-deploy-multiple-sites/</link>
        <pubDate>Wed, 28 May 2025 02:55:54 +0800</pubDate>
        
        <guid>https://ttf248.life/p/github-pages-easter-egg-deploy-multiple-sites/</guid>
        <description>&lt;p&gt;最近生物钟有点错乱，凌晨两点多还在折腾 Github Pages 的部署。&lt;/p&gt;
&lt;p&gt;加完班才去吃饭，鄙人刚好吃完就想睡，吃完回来八点半左右，犯困了，想着眯会，直接就睡着了，醒来已经凌晨两点多了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;还没启动就消亡的分类：AI 研习社&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;打脸&#34;&gt;打脸
&lt;/h2&gt;&lt;p&gt;昨天才说的不折腾前端，好的今天我们折腾的不是前端，而是 UI UX 的体验。&lt;/p&gt;
&lt;h2 id=&#34;项目&#34;&gt;项目
&lt;/h2&gt;&lt;p&gt;有请我们的老朋友，&lt;a class=&#34;link&#34; href=&#34;https://github.com/ttf248/ai-coding-demo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ttf248/ai-coding-demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;没错，就是原来自选股那个项目，重构项目的整体结构，后续 AI 编程相关的内容都会放在这个项目下。&lt;/p&gt;
&lt;h2 id=&#34;部署多个-pages&#34;&gt;部署多个 Pages
&lt;/h2&gt;&lt;p&gt;项目国内托管在 &lt;a class=&#34;link&#34; href=&#34;https://cnb.cool/ttf248/ai-coding-demo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cnb.cool/ttf248/ai-coding-demo&lt;/a&gt;，由于众所周知的原因，国内是不支持发布 pages 的，所以我们需要在国外的 Github 上发布。&lt;/p&gt;
&lt;p&gt;博客就是发布在国外的 Github 上。没试过，多个项目发布 pages，还有就是，当前处理的项目，并不是一个传统的博客站点，里面只是有很多文档，叠加几个静态的 html 设计稿。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/github-pages-easter-egg-deploy-multiple-sites/20250528030230.png&#34;
	width=&#34;798&#34;
	height=&#34;530&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;pages&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;150&#34;
		data-flex-basis=&#34;361px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;没错，这个页面，是我第一次点击，然后就发现了，多个项目部署 pages，并不会影响博客的发布，而是在博客的域名下，增加了一个新的路径。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://ttf248.life/ai-coding-demo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ttf248.life/ai-coding-demo/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看到这里的时候，我直呼完美。&lt;/p&gt;
&lt;h2 id=&#34;ai-研习社&#34;&gt;AI 研习社
&lt;/h2&gt;&lt;p&gt;昨天新建的分类，想着通过 AI 来学习很多计算机的课程，比如说：算法、LeetCode 刷题。&lt;/p&gt;
&lt;p&gt;每次的学习记录，发布到博客上，形成一个知识库。新建了分类：AI 研习社&lt;/p&gt;
&lt;p&gt;现在看来，不同的课程，新建不同项目就行，学习笔记都写到项目的 Readme.md 中。&lt;/p&gt;</description>
        </item>
        <item>
        <title>老毛病，繁花迷人眼</title>
        <link>https://ttf248.life/p/old-ailment-stunning-flowers/</link>
        <pubDate>Mon, 26 May 2025 23:54:12 +0800</pubDate>
        
        <guid>https://ttf248.life/p/old-ailment-stunning-flowers/</guid>
        <description>&lt;p&gt;多年来一直专注于后端开发，最近开始尝试探索 &lt;code&gt;AI&lt;/code&gt; 编程，并涉足了一些前端相关的内容。然而，在这段折腾的过程中，我逐渐意识到自己又陷入了一个老毛病——繁花迷人眼。总想着用 &lt;code&gt;AI&lt;/code&gt; 来实现一个前端界面，但实际上，这样的尝试对于当前的工作并没有太大的实际帮助，反而分散了精力。&lt;/p&gt;
&lt;h2 id=&#34;ai-的适用场景&#34;&gt;AI 的适用场景
&lt;/h2&gt;&lt;p&gt;在小型项目中，AI 工具的确能够发挥巨大的作用，尤其是在编写那些独立性强、与系统耦合度低、业务逻辑简单的函数时更显得得心应手。这类任务通常有明确的输入输出，且上下文依赖较少，非常适合当前 AI 辅助编程的能力范围。&lt;/p&gt;
&lt;p&gt;然而，当面对复杂的系统架构或深度的业务逻辑时，AI 的局限性就会逐渐显现。它可能会生成看似合理但实际上脱离项目真实需求的代码，甚至引入一些难以排查的潜在问题。在这些场景下，AI 更适合作为辅助工具，而非完全依赖的代码生成器。我们需要对生成的代码进行严格的审查和测试，确保其符合实际需求。&lt;/p&gt;
&lt;h2 id=&#34;错误与学习的代价&#34;&gt;错误与学习的代价
&lt;/h2&gt;&lt;p&gt;在尝试用 AI 生成前端代码的过程中，我发现自己面临了许多挑战。由于前端并不是我熟悉的领域，排查问题的过程往往耗时耗力。即使通过调整提示词让 AI 重写代码，也难以避免一些低级错误的出现。这种反复尝试不仅浪费了时间，还让我意识到，当前的精力更应该集中在后端的业务逻辑上，而不是在不熟悉的领域中摸索。&lt;/p&gt;
&lt;p&gt;回想起周末完成的那个项目，我更加确信，专注于后端开发和用户交互逻辑，通过控制台来实现功能，才是当前最有效率的选择。等到有更多的时间和精力时，再系统地学习前端知识，或许会是更好的策略。&lt;/p&gt;
&lt;h2 id=&#34;前端学习的计划&#34;&gt;前端学习的计划
&lt;/h2&gt;&lt;p&gt;前端技术栈繁杂多样，想要快速上手并不现实。我计划先选择一个框架，比如 Vue.js 或 React.js，深入学习其核心概念和使用方法。只有在熟悉了基础知识之后，再尝试用 AI 辅助生成前端代码，才能有效避免因不熟悉而导致的错误和时间浪费。&lt;/p&gt;
&lt;p&gt;总之，当前阶段的重点还是要放在后端开发上，稳扎稳打地提升自己的核心技能。等到时机成熟，再去探索前端和 AI 的结合，或许会有更大的收获。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Claude4发布，尝试开发：hugo标签、超链接翻译助手</title>
        <link>https://ttf248.life/p/claude-4-release-hugo-tags-hyperlink-translation-assistant/</link>
        <pubDate>Sat, 24 May 2025 03:05:31 +0800</pubDate>
        
        <guid>https://ttf248.life/p/claude-4-release-hugo-tags-hyperlink-translation-assistant/</guid>
        <description>&lt;p&gt;本站点基于 hugo 开发，但是笔者一直用的都是中文标题，导致生成的文章超链接不太友好，说人话就是，发出去的时候，看起来不太友好，中文的字符在超链接中会被转义成 %E4%BD%A0%E5%A5%BD 这种形式，虽然可以通过设置 slug 来解决，但是每次都要手动设置，太麻烦了。&lt;/p&gt;
&lt;p&gt;所以，今天尝试用 Claude4 来开发一个翻译助手，自动将中文标题转换为英文 slug，并且在文章中添加超链接。这样就可以避免手动设置了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;claude4 真香，上下文的能力大幅提升，复杂任务的处理效率也大幅提升。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;项目地址&#34;&gt;项目地址
&lt;/h2&gt;&lt;p&gt;国内项目地址：&lt;a class=&#34;link&#34; href=&#34;https://cnb.cool/ttf248/hugo-content-suite&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cnb.cool/ttf248/hugo-content-suite&lt;/a&gt;
国外项目地址：&lt;a class=&#34;link&#34; href=&#34;https://github.com/ttf248/hugo-content-suite&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ttf248/hugo-content-suite&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;代码实现&#34;&gt;代码实现
&lt;/h2&gt;&lt;p&gt;先说一下实现思路：我们需要扫描所有文章，提取标签信息和文章标题，然后调用本地的大模型（如 gemma-3-12b-it）进行翻译。&lt;/p&gt;
&lt;p&gt;在实际开发中，与前代大模型相比，&lt;code&gt;Claude4&lt;/code&gt; 展现了几个显著的亮点。由于功能需求较多，&lt;code&gt;Claude4&lt;/code&gt; 自动设计了交互式菜单，全面考虑了各种使用场景。例如，在标签处理方面，&lt;code&gt;Claude4&lt;/code&gt; 不仅支持标签的统计与分析，还包括分类统计，甚至能够检测&lt;strong&gt;无标签文章&lt;/strong&gt;。此外，它还提供了&lt;strong&gt;预览&lt;/strong&gt;和生成标签页面的功能。&lt;/p&gt;
&lt;p&gt;无论是对接本地大模型、新增翻译缓存，还是进行大范围的代码重构，&lt;code&gt;Claude4&lt;/code&gt; 都一次性完成，几乎没有出现任何问题。尽管项目规模不大，但包含了许多小功能。以往在开发过程中，大模型经常会遗忘前面的内容，而这次的 &lt;code&gt;Claude4&lt;/code&gt; 表现非常出色，&lt;strong&gt;几乎没有出现遗忘上下文的情况&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;简而言之，智能程度提高了，后续准备切换到 &lt;code&gt;Claude4&lt;/code&gt; 进行更多的开发工作，作为日常编码的主力模型。&lt;/p&gt;
&lt;h2 id=&#34;翻译缓存&#34;&gt;翻译缓存
&lt;/h2&gt;&lt;p&gt;这个点单说，除了减少大模型调用次数，实际本地跑 12b 模型，效率挺高，不耽误事，但是如果每次都要调用大模型，还是会有点慢的。其次就是，为了固定文章的连接，如果执行全量更新操作，文章的标题很长，偶尔就会出现，两次翻译出来的结果不一样的情况，导致文章的链接变了，这个就很尴尬了。&lt;/p&gt;
&lt;h2 id=&#34;功能优化&#34;&gt;功能优化
&lt;/h2&gt;&lt;p&gt;整个项目扔给 &lt;code&gt;Claude4&lt;/code&gt;，分析优化的空间，拿到如下的建议：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;配置外置化 - 提高可维护性和灵活性
结构化日志 - 便于问题排查和监控
性能监控 - 了解系统运行状况
用户体验 - 进度条等视觉反馈
错误处理 - 更完善的异常处理机制
代码组织 - 更清晰的模块划分
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;审核了代码，全部都没什么毛病，比如配置文件，知道自己将原来代码中的配置，转换成默认配置，读取配置文件的时候，如果没有对应的配置文件，就会自动生成一个默认的配置文件，避免了用户的操作失误。&lt;/p&gt;
&lt;h3 id=&#34;heading&#34;&gt;
&lt;/h3&gt;&lt;p&gt;需求：翻译正文的时候，动态计算当前翻译的效率，预估剩余的时间，相关信息输出到控制台：现在获取了文章的字符数量，每行进行翻译的时候，当前翻译的字符数量，时间，拟合计算每100字符的翻译时间，同时计算文章剩余的翻译预估时间&lt;/p&gt;
&lt;p&gt;代码搞定了，效果不是很满意，我就让AI提供新的设计方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供多种效率计算方式：实时效率、平均效率、滑动窗口效率&lt;/li&gt;
&lt;li&gt;改进显示方式：进度条、分段统计、动态刷新&lt;/li&gt;
&lt;li&gt;增加更多有用的指标：API调用次数、成功率等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码完成以后，发现了新的惊喜，翻译效率的统计信息实时刷屏，但是没有无脑向下滚动。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;翻译正文到 English (总计 7163 字符)...
检测到 53 行需要翻译
  [1/53] Stage1/6 [░░░░░░░░░░░░░░░░░░░░░░░░░] 1.9% 翻译 354 字符...
    ✅ 完成 (3.1s) | API调用 #1
    ✅ 完成 (1.5s) | API调用 #2
    ✅ 完成 (0.9s) | API调用 #3
    ✅ 完成 (0.2s) | API调用 #4
    ✅ 完成 (1.0s) | API调用 #5
    ✅ 完成 (1.0s) | API调用 #6
    ✅ 完成 (0.2s) | API调用 #7
    📊 进度: 行 13.2% (7/53) | 字符 12.9% (925/7163) 114.6 字符/秒 📊
    ⚡ 效率: 实时76.4 | 平均117.9 | 最近109.0 | 阶段113.6 字符/秒 📊
    🎯 成功率: 100.0% (7/7) | 剩余: 46行7 7s] 9.4% 翻译 110 字符...
    ⏱️  预估剩余: 55s | 预计完成: 00:10:19 8s] 11.3% 翻译 114 字符...
    💾 处理速度: 3211.3 行/分钟 | 总用时: 8s] 13.2% 翻译 16 字符...
  [8/53] Stage1/6 [███░░░░░░░░░░░░░░░░░░░░░░] 15.1% 翻译 166 字符...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以前控制程序写的也不是很多，好奇如何实现的，翻看代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// 清屏并重新显示 (动态刷新效果)
if translationCount &amp;gt; 1 {
   fmt.Print(&amp;quot;\033[6A\033[K&amp;quot;) // 上移6行并清除
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;性能统计菜单&#34;&gt;性能统计菜单
&lt;/h3&gt;&lt;p&gt;新增的&lt;strong&gt;性能统计菜单&lt;/strong&gt;，让我自己设计，都不一定能设计的这么完善&lt;/p&gt;
&lt;p&gt;📊 性能统计:
🔄 翻译次数: 360
⚡ 缓存命中率: 1.4% (5/365)
⏱️  平均翻译时间: 315.927234ms
📁 文件操作: 73
❌ 错误次数: 0&lt;/p&gt;
&lt;h3 id=&#34;进度条显示&#34;&gt;进度条显示
&lt;/h3&gt;&lt;p&gt;新增的&lt;strong&gt;进度条显示&lt;/strong&gt;，详细的进度、已用时间、剩余时间预估&lt;/p&gt;
&lt;p&gt;请选择功能 (0-13): 10
🔍 正在收集翻译目标&amp;hellip;
📄 已加载缓存文件，包含 0 个翻译记录&lt;/p&gt;
&lt;p&gt;📊 翻译缓存统计:
🏷️  标签总数: 229 个
📝 文章总数: 131 篇
✅ 已缓存: 0 个
🔄 需翻译: 360 个&lt;/p&gt;
&lt;p&gt;确认生成全量翻译缓存？(y/n): y
🚀 正在生成全量翻译缓存&amp;hellip;
📄 已加载缓存文件，包含 0 个翻译记录
🔍 检查缓存中的翻译&amp;hellip;
🔄 需要翻译 360 个新标签
[░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 5/360 (1.4%) - 用时: 3s - 预计剩余: 3m8s💾 已保存缓存文件，包含 5 个翻译记录
[█░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 10/360 (2.8%) - 用时: 6s - 预计剩余: 3m28s💾 已保存缓存文件，包含 10 个翻译记录
[██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 15/360 (4.2%) - 用时: 9s - 预计剩余: 3m30s💾 已保存缓存文件，包含 15 个翻译记录
[██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 20/360 (5.6%) - 用时: 13s - 预计剩余: 3m36s💾 已保存缓存文件，包含 20 个翻译记录
[███░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 25/360 (6.9%) - 用时: 16s - 预计剩余: 3m33s💾 已保存缓存文件，包含 25 个翻译记录
[████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 30/360 (8.3%) - 用时: 19s - 预计剩余: 3m30s💾 已保存缓存文件，包含 30 个翻译记录
[████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 35/360 (9.7%) - 用时: 22s - 预计剩余: 3m25s💾 已保存缓存文件，包含 35 个翻译记录&lt;/p&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;=== Hugo 博客管理工具 ===

🚀 核心功能
  1. 一键处理全部 (完整博客处理流程)

📝 内容管理
  2. 生成标签页面
  3. 生成文章Slug
  4. 翻译文章为多语言版本

💾 缓存管理
  5. 查看缓存状态
  6. 生成全量翻译缓存
  7. 清空翻译缓存

  0. 退出程序
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>合并 PullRequest 到 Fork 的仓库</title>
        <link>https://ttf248.life/p/merge-pullrequest-to-forked-repo/</link>
        <pubDate>Wed, 07 May 2025 18:44:03 +0800</pubDate>
        
        <guid>https://ttf248.life/p/merge-pullrequest-to-forked-repo/</guid>
        <description>&lt;p&gt;&lt;code&gt;github-readme-stats&lt;/code&gt; 是一个 GitHub 个人资料的统计信息生成器，允许用户在其 GitHub 个人资料中显示各种统计信息和图表。它提供了多种自定义选项，可以根据用户的需求进行调整。&lt;/p&gt;
&lt;p&gt;笔者管理仓库习惯按照项目分组，github 不支持仓库分组，只能通过拆分不同的组织来实现。&lt;code&gt;github-readme-stats&lt;/code&gt; 最新分支无法支持跨越不同组织的仓库统计，笔者 fork 了一个分支，合并了对应的代码。&lt;/p&gt;
&lt;h2 id=&#34;最终效果&#34;&gt;最终效果
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://github-readme-stats-chi-one-17.vercel.app/api?username=ttf248&amp;amp;hide_title=true&amp;amp;show_icons=true&amp;amp;hide=contribs&amp;amp;line_height=24&amp;amp;include_all_commits=true&amp;amp;count_private=true&amp;amp;bg_color=0000&amp;amp;text_color=8A919F&amp;amp;locale=cn&amp;amp;role=OWNER,COLLABORATOR,ORGANIZATION_MEMBER&amp;amp;timstamp=1746608356&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;GitHub Stats&#34;
	
	
&gt;
&lt;img src=&#34;https://github-readme-stats-chi-one-17.vercel.app/api/top-langs/?username=ttf248&amp;amp;hide_title=true&amp;amp;hide=html,javascript,css&amp;amp;layout=compact&amp;amp;bg_color=0000&amp;amp;text_color=8A919F&amp;amp;locale=cn&amp;amp;role=OWNER,COLLABORATOR,ORGANIZATION_MEMBER&amp;amp;timstamp=1746608356&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Top Languages&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;pull-request-原始地址&#34;&gt;Pull Request 原始地址
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/anuraghazra/github-readme-stats/pull/2459&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Adds the ability to include data from organization repositories&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;合并-pullrequest-到-fork-的仓库&#34;&gt;合并 PullRequest 到 Fork 的仓库
&lt;/h2&gt;&lt;p&gt;要将某个 &lt;strong&gt;Pull Request (PR)&lt;/strong&gt; 合并到你 &lt;strong&gt;fork 的仓库&lt;/strong&gt;，有几种方式可以做到，取决于你是想：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从&lt;strong&gt;上游（upstream）仓库&lt;/strong&gt;合并 PR 到你的 fork，还是&lt;/li&gt;
&lt;li&gt;从其他人的 fork 中合并 PR 到你的 fork，或者&lt;/li&gt;
&lt;li&gt;合并一个开在你 fork 上的 PR（比如别人给你 fork 提了个 PR）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我先给你一个最常见的场景：&lt;strong&gt;你 fork 了一个仓库，想把上游的某个 PR 合并到你的 fork&lt;/strong&gt;。操作流程如下👇：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;-方法一命令行方式最通用&#34;&gt;✅ 方法一：命令行方式（最通用）
&lt;/h3&gt;&lt;h4 id=&#34;步骤-1克隆你自己的-fork&#34;&gt;步骤 1：克隆你自己的 fork
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/你的用户名/仓库名.git
cd 仓库名
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;步骤-2添加-upstream原仓库地址&#34;&gt;步骤 2：添加 upstream（原仓库地址）
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git remote add upstream https://github.com/原作者用户名/仓库名.git
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;步骤-3抓取-upstream-的-pr-分支&#34;&gt;步骤 3：抓取 upstream 的 PR 分支
&lt;/h4&gt;&lt;p&gt;找到你想合并的 PR 编号，例如 PR #123。&lt;/p&gt;
&lt;p&gt;你可以这样拉取该 PR 的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git fetch upstream pull/123/head:pr-123
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;步骤-4切换并合并分支&#34;&gt;步骤 4：切换并合并分支
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git checkout main    # 或者你自己的目标分支
git merge pr-123
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果一切正常，你可以推送到你 fork 上的 GitHub 仓库：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git push origin main
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;-方法二github-网页界面简单但有限&#34;&gt;✅ 方法二：GitHub 网页界面（简单但有限）
&lt;/h3&gt;&lt;p&gt;如果你在 GitHub 网页上看到某个 PR 是对上游仓库的，你可以：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进入该 PR 页面。&lt;/li&gt;
&lt;li&gt;点击右上角 “&lt;strong&gt;Commits&lt;/strong&gt;” 或 “&lt;strong&gt;Files changed&lt;/strong&gt;”，看这个 PR 是基于哪个分支。&lt;/li&gt;
&lt;li&gt;在你的 fork 页面，新建一个分支，然后手动 cherry-pick PR 的 commit（需要点 Git 技术）。&lt;/li&gt;
&lt;li&gt;或者点“&lt;strong&gt;Open in GitHub Desktop&lt;/strong&gt;”，用 GUI 工具来合并。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;-如果别人是对你的-fork-提了-pr&#34;&gt;🚀 如果别人是对你的 fork 提了 PR
&lt;/h3&gt;&lt;p&gt;你就直接进入 PR 页面，点击 “&lt;strong&gt;Merge pull request&lt;/strong&gt;” 按钮即可。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;需要我根据你现在的具体场景（比如 PR 链接、你是用网页还是命令行）来手把手演示吗？也可以给我具体链接，我帮你分析最简单的做法。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Git修改历史记录中的递交信息</title>
        <link>https://ttf248.life/p/git-modify-commit-message/</link>
        <pubDate>Wed, 07 May 2025 18:38:31 +0800</pubDate>
        
        <guid>https://ttf248.life/p/git-modify-commit-message/</guid>
        <description>&lt;p&gt;脚本用于批量修改 Git 历史提交的作者信息，通过 git filter-branch 重写历史提交记录。&lt;/p&gt;
&lt;p&gt;您提供的脚本用于批量修改 Git 仓库历史提交中的作者信息，整体思路是正确的，但在 &lt;code&gt;git filter-branch&lt;/code&gt; 的 &lt;code&gt;--env-filter&lt;/code&gt; 中使用数组（如 &lt;code&gt;OLD_EMAILS=(&amp;quot;...&amp;quot;)&lt;/code&gt;）可能会导致兼容性问题，因为某些 shell 环境（如 &lt;code&gt;/bin/sh&lt;/code&gt;）并不支持数组语法。&lt;/p&gt;
&lt;p&gt;为提高兼容性，建议将数组替换为以空格分隔的字符串，并使用 &lt;code&gt;for&lt;/code&gt; 循环遍历每个旧邮箱地址。以下是修改后的脚本示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh

git filter-branch --env-filter &#39;
OLD_EMAILS=&amp;quot;TianlongXiang51@gmail.com nick@qq.com tianlongxiang51@gmail.com&amp;quot;
CORRECT_NAME=&amp;quot;tianlong.xiang&amp;quot;
CORRECT_EMAIL=&amp;quot;tianlong.xiang@foxmail.com&amp;quot;

for OLD_EMAIL in $OLD_EMAILS
do
    if [ &amp;quot;$GIT_COMMITTER_EMAIL&amp;quot; = &amp;quot;$OLD_EMAIL&amp;quot; ]
    then
        export GIT_COMMITTER_NAME=&amp;quot;$CORRECT_NAME&amp;quot;
        export GIT_COMMITTER_EMAIL=&amp;quot;$CORRECT_EMAIL&amp;quot;
    fi
    if [ &amp;quot;$GIT_AUTHOR_EMAIL&amp;quot; = &amp;quot;$OLD_EMAIL&amp;quot; ]
    then
        export GIT_AUTHOR_NAME=&amp;quot;$CORRECT_NAME&amp;quot;
        export GIT_AUTHOR_EMAIL=&amp;quot;$CORRECT_EMAIL&amp;quot;
    fi
done
&#39; --tag-name-filter cat -- --branches --tags
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在执行此脚本之前，建议备份您的仓库，以防止意外情况发生。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此操作会重写 Git 历史，修改提交的作者信息，可能会导致提交哈希值发生变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果您已经将更改推送到远程仓库，需要使用强制推送：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git push --force --tags origin &#39;refs/heads/*&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请谨慎使用强制推送，尤其是在多人协作的项目中，以避免对他人造成影响。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;统计仓库所有的不重复作者邮箱&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git log --format=&#39;%an &amp;lt;%ae&amp;gt;&#39; | sort -u
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>不写代码，设计开发自选股模块</title>
        <link>https://ttf248.life/p/design-develop-custom-stock-module-no-code/</link>
        <pubDate>Thu, 27 Feb 2025 23:20:39 +0800</pubDate>
        
        <guid>https://ttf248.life/p/design-develop-custom-stock-module-no-code/</guid>
        <description>&lt;p&gt;上个月我们试用了 cursor，但是由于免费额度的限制，并没有做太复杂的功能开发，只是简单的测试了一下。那会就发现，字节也发布了类似的产品，两者底层调用的大模型一样，都是 Claude-3.5。&lt;/p&gt;
&lt;p&gt;字节产品叫做 Trae，先发布的 mac 版本，今年二月份，终于发布了 windows 版本。大厂的东西就是好，能免费白嫖，不用掏钱，无限量使用 Claude-3.5，这个模型的效果还是很不错的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最终卡在了K线图的开发上，由于本人基本不懂 react，所以只能放弃了。想要继续开发，需要笔者补充一些前端的基础知识，将任务拆分的更细，而不是直接给一个大任务：开发K线图。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;发现的问题&#34;&gt;发现的问题
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;由于使用国外的 AI 模型，Vue3 + Element-Plus 的训练数据不足，因此选择了 React 作为前端框架&lt;/li&gt;
&lt;li&gt;可能存在偶发的语法错误，需要人工修复&lt;/li&gt;
&lt;li&gt;部分复杂问题的解决方案需要人工指引&lt;/li&gt;
&lt;li&gt;代码结构优化需要人工指导&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中耗时最多的地方，打包前端代码到容器中，由于笔者零基础 &lt;code&gt;.env.production&lt;/code&gt; &lt;code&gt;tsconfig.json&lt;/code&gt;，完全是没有概念的，这些还是中途求助豆包，才捋顺对应的逻辑。前端开发 dev 模式和 build 模式，对于代码的检查，差异很大。后端数据库和服务的容器脚本，合计五分钟就搞定了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AI 目前更多的提高开发的效率，你有基础是最好的，并不是 AI 会帮你解决所有的问题&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;仓库地址&#34;&gt;仓库地址
&lt;/h2&gt;&lt;p&gt;正如标题说的，我们这次是能不写就不动手，和AI硬聊，设计开发自选股模块。看最终能做出来什么效果。&lt;/p&gt;
&lt;p&gt;仓库地址：&lt;a class=&#34;link&#34; href=&#34;https://github.com/ttf248/trae-demo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ttf248/trae-demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;详细的使用方法，可以看仓库的 README.md 文件。&lt;/p&gt;
&lt;p&gt;仓库包含很多递交记录，大部分都是我和 Trae 的对话记录，以及我对 Trae 的一些功能的测试，备注了是否人工干预来实现对应的功能。&lt;/p&gt;
&lt;h2 id=&#34;prompt&#34;&gt;Prompt
&lt;/h2&gt;&lt;p&gt;项目是从零开始创建，下面是项目的 Prompt：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;基于项目原型图，开发功能：自选股，需要支持合约的新增、删除、修改、查询。自选股界面需要展示基础的行情数据。支持多个不同的市场切换。

前端：react
后端：golang gin gorm
数据库：PostgreSQL

服务端需要支持跨域请求，同时需要考虑数据的校验和错误处理，如果后端服务不可用，前端需要告警提示。

后端需要展示请求和应答的日志；前端也打印通讯的日志，方便排查问题。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ui和交互优化&#34;&gt;UI和交互优化
&lt;/h2&gt;&lt;p&gt;前端界面的设计完全依赖的 Grok，我们首先在 Trae 里面做出来产物的雏形，但是没有审美，由于使用的模型，代码能力很强，但是其他能力比较弱，所以我们需要使用 Grok 来优化前端的 UI。&lt;/p&gt;
&lt;p&gt;通过将当前的界面截图，上传到 Grok 里面，然后让它帮我们优化 UI，可能一次性拿到很多的优化建议，我们人工评估，然后拷贝到 Trae 中执行，观察优化的效果。&lt;/p&gt;
&lt;h3 id=&#34;技术栈&#34;&gt;技术栈
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;前端：React + TypeScript&lt;/li&gt;
&lt;li&gt;后端：Golang + Gin + GORM&lt;/li&gt;
&lt;li&gt;数据库：PostgreSQL 17&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;系统架构&#34;&gt;系统架构
&lt;/h2&gt;&lt;h2 id=&#34;后端架构&#34;&gt;后端架构
&lt;/h2&gt;&lt;p&gt;后端采用 Golang 的 Gin 框架实现 RESTful API，主要模块包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据库模块&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 GORM 作为 ORM 框架&lt;/li&gt;
&lt;li&gt;支持环境变量配置数据库连接&lt;/li&gt;
&lt;li&gt;自动进行数据库表迁移&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;路由模块&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RESTful API 设计&lt;/li&gt;
&lt;li&gt;统一的错误处理机制&lt;/li&gt;
&lt;li&gt;内置请求日志记录&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;跨域处理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持本地开发环境跨域&lt;/li&gt;
&lt;li&gt;可配置的 CORS 策略&lt;/li&gt;
&lt;li&gt;支持 Cookie 跨域&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;前端架构&#34;&gt;前端架构
&lt;/h2&gt;&lt;p&gt;前端使用 React + TypeScript 构建，实现了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;股票列表展示&lt;/li&gt;
&lt;li&gt;自选股管理&lt;/li&gt;
&lt;li&gt;行情数据展示&lt;/li&gt;
&lt;li&gt;错误提示机制&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>枚举值尽量不要从零开始定义</title>
        <link>https://ttf248.life/p/protobuf-zero-value-trap/</link>
        <pubDate>Thu, 20 Feb 2025 15:26:51 +0800</pubDate>
        
        <guid>https://ttf248.life/p/protobuf-zero-value-trap/</guid>
        <description>&lt;p&gt;美股有三个交易时段，分别是：盘前、盘中、盘后；接口推送数据还是数值增量的逻辑（尽可能的节约带宽），仅在第一次发送全量，第二次开始所有字段都是增量推送逻辑。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么不用最优方案？牵扯到不同项目组，有些都已经上线多年。我方属于新对接，所以只能尽量兼容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;一系列问题&#34;&gt;一系列问题
&lt;/h2&gt;&lt;p&gt;单从摘要上看，可能还觉得没什么问题，问题带入组内的系统架构，带出来一系列问题。刚处理上一个问题，又遇到了新的问题，这个问题是由于之前的问题引起的。&lt;/p&gt;
&lt;h3 id=&#34;无法识别交易时段&#34;&gt;无法识别交易时段
&lt;/h3&gt;&lt;p&gt;已知盘中阶段定义为在 &lt;code&gt;protobuf&lt;/code&gt; 中定义为 0，但是在收到数据的时候由于是增量推送，业务方无法有效识别这个&lt;code&gt;零&lt;/code&gt;是默认值，还是真实的业务值。&lt;/p&gt;
&lt;p&gt;通俗理解：每次收到 0，无法判断这个 0 是新行情设置的值，还是 protobuf 的默认值&lt;/p&gt;
&lt;h3 id=&#34;引入-optional&#34;&gt;引入 optional
&lt;/h3&gt;&lt;p&gt;Since protobuf release 3.15, proto3 supports using the optional keyword (just as in proto2) to give a scalar field presence information&lt;/p&gt;
&lt;p&gt;组内的通讯协议是基于 &lt;code&gt;protobuf&lt;/code&gt; 的，但是由于历史原因，选择的版本比较老，并没支持 &lt;code&gt;optional&lt;/code&gt; 关键字。懂的都理解，由于从底层开始引入 &lt;code&gt;protobuf&lt;/code&gt;，项目底层通过静态库的方式发布，导致整个编译链路都需要升级，这个成本是非常高的。&lt;/p&gt;
&lt;h3 id=&#34;gcc-版本问题&#34;&gt;gcc 版本问题
&lt;/h3&gt;&lt;p&gt;好不容易想了方案，底层发布两个不同的版本，尽可能的控制 &lt;code&gt;protobuf&lt;/code&gt; 新版本的编译依赖传播。但是在编译的时候，发现 &lt;code&gt;gcc&lt;/code&gt; 版本太低，不支持 &lt;code&gt;protobuf&lt;/code&gt; 的新特性。&lt;/p&gt;
&lt;p&gt;组内常用的服务器类型：centos7、centos8。centos7 默认的 &lt;code&gt;gcc&lt;/code&gt; 版本是 4.8，centos8 默认的 &lt;code&gt;gcc&lt;/code&gt; 版本是 8.3。由于 &lt;code&gt;protobuf&lt;/code&gt; 的新特性需要 &lt;code&gt;gcc&lt;/code&gt; 版本在 7.4 以上，所以 centos7 无法支持。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=82461&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Bug 82461 - [7 Regression] Temporary required for brace-initializing (non-literal-type) member variable&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;最后折腾一圈，相关服务的部署、编译服务器都挪到 centos8 上，解决了这个问题。&lt;/p&gt;
&lt;h2 id=&#34;合理的枚举&#34;&gt;合理的枚举
&lt;/h2&gt;&lt;p&gt;回顾整个问题，其实有一个更简单、高效的解决方案：调整枚举的定义，从 1 开始编号，而不是从 0 开始。这样就能有效区分默认值和业务值，避免上述一系列麻烦。&lt;/p&gt;
&lt;h3 id=&#34;为什么从-1-开始更合理&#34;&gt;为什么从 1 开始更合理？
&lt;/h3&gt;&lt;p&gt;在 &lt;code&gt;protobuf&lt;/code&gt; 中，枚举类型的默认值固定为 0。如果我们将有意义的业务值定义为 0（比如“盘中”），在增量推送时，业务方无法判断收到的 0 是业务值还是未设置的默认值。而如果将枚举从 1 开始定义，0 可以保留为一个无意义的默认值或“未知”状态，问题迎刃而解。&lt;/p&gt;
&lt;p&gt;建议的实践：&lt;/p&gt;
&lt;p&gt;在设计 protobuf 枚举时，始终将 0 定义为无意义的默认值（如 &lt;code&gt;UNKNOWN&lt;/code&gt; 或 &lt;code&gt;RESERVED&lt;/code&gt;）。
将实际业务值从 1 开始分配，确保与默认值 0 区分开。&lt;/p&gt;
&lt;p&gt;通过这一小调整，我们不仅解决了交易时段识别的问题，还为未来的协议设计提供了一个宝贵的经验教训。&lt;/p&gt;</description>
        </item>
        <item>
        <title>后台服务TCP通讯异常排查</title>
        <link>https://ttf248.life/p/backend-service-tcp-communication-troubleshooting/</link>
        <pubDate>Fri, 14 Feb 2025 22:54:13 +0800</pubDate>
        
        <guid>https://ttf248.life/p/backend-service-tcp-communication-troubleshooting/</guid>
        <description>&lt;p&gt;业务模型：后台服务借助 TCP 与集团的行情网关建立连接。每次连接时，需先行发送一个授权请求，随后持续发送心跳包以维持连接状态。
然而，某一天，收到了服务断开连接的告警信息。通过仔细排查日志后发现，后台服务一直在持续发送心跳包，但对方却毫无回应，可连接却始终未断开。&lt;/p&gt;
&lt;h2 id=&#34;现场简述&#34;&gt;现场简述
&lt;/h2&gt;&lt;p&gt;原本正在公司加班推进项目进度，工作群里突然弹出告警信息。乍一看，我还以为是老毛病，大概率是网络超时致使心跳发送失败，进而导致服务断开连接。可在仔细排查日志后，却发现实际情况并非如此。后台已发送了授权登录消息，然而一直未收到应答，与此同时，心跳包仍在持续不断地发送，对方却始终未回复任何心跳数据。经过对日志的深入分析，暴露出了以下几个关键问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;授权消息无应答：极有可能是对方系统正在重启，使得授权消息未能得到及时处理。&lt;/li&gt;
&lt;li&gt;未成功授权却发送心跳数据：经排查，发现这是程序逻辑上的漏洞。心跳发送函数的判断逻辑存在缺陷，仅仅校验了连接状态，却遗漏了对授权状态的校验。&lt;/li&gt;
&lt;li&gt;服务未断开连接：若服务能够断开连接，便可以触发重连机制，从而重新发送授权消息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前，还剩下最后一个亟待解决的问题——为何服务没有断开连接。这一问题的解决需要开展更为深入细致的排查工作。&lt;/p&gt;
&lt;h2 id=&#34;分析网络数据包&#34;&gt;分析网络数据包
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;tcpdump&lt;/code&gt; 是一个非常强大的网络抓包工具，可以用来捕获网络数据包。通过分析网络数据包，我们可以更加直观地了解网络通信的细节。在这里，我们可以使用 &lt;code&gt;tcpdump&lt;/code&gt; 来捕获网络数据包，以便进一步分析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/backend-service-tcp-communication-troubleshooting/20250220151952.png&#34;
	width=&#34;1126&#34;
	height=&#34;202&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;tcpdump&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;557&#34;
		data-flex-basis=&#34;1337px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;分析图中的数据，我可以看到心跳一直在正常发送，对方服务器并没有回复任何数据，但是给了 &lt;code&gt;ACK&lt;/code&gt;，这就导致连接不会主动断开了。&lt;/p&gt;
&lt;h2 id=&#34;常见标志位说明&#34;&gt;常见标志位说明
&lt;/h2&gt;&lt;p&gt;在 TCP 协议中，&lt;code&gt;PSH&lt;/code&gt;（Push）和 &lt;code&gt;ACK&lt;/code&gt;（Acknowledgment）是两个重要的标志位，分别用于控制数据传输和流量确认。它们的作用如下：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;1-pshpush-flag&#34;&gt;&lt;strong&gt;1. PSH（Push Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：&lt;br&gt;
&lt;code&gt;PSH&lt;/code&gt; 标志位的作用是&lt;strong&gt;请求接收方立即将缓冲区中的数据推送给上层应用&lt;/strong&gt;（而不是等待缓冲区填满）。这意味着一旦收到带有 &lt;code&gt;PSH&lt;/code&gt; 标志的数据段，接收方会尽可能快地处理并传递给应用程序，而非暂存于操作系统缓冲区中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;典型场景&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTTP/HTTPS 请求&lt;/strong&gt;：客户端发送请求时（如 &lt;code&gt;GET /index.html&lt;/code&gt;）会设置 &lt;code&gt;PSH&lt;/code&gt;，希望服务器立即响应。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SSH 协议&lt;/strong&gt;：每次键盘输入都会触发 &lt;code&gt;PSH&lt;/code&gt;，确保输入字符实时传输。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实时通信&lt;/strong&gt;：视频流、在线游戏等低延迟场景可能使用 &lt;code&gt;PSH&lt;/code&gt; 减少延迟。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PSH&lt;/code&gt; 并非强制要求，接收方可以选择忽略该标志位（但仍需正常处理数据）。&lt;/li&gt;
&lt;li&gt;发送方可能不设置 &lt;code&gt;PSH&lt;/code&gt;，此时接收方会根据自身缓冲策略决定何时推送数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2-ackacknowledgment-flag&#34;&gt;&lt;strong&gt;2. ACK（Acknowledgment Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：&lt;br&gt;
&lt;code&gt;ACK&lt;/code&gt; 标志位表示&lt;strong&gt;确认已正确接收前序数据段&lt;/strong&gt;。每个 &lt;code&gt;ACK&lt;/code&gt; 包含一个确认号（&lt;code&gt;Acknowledgment Number&lt;/code&gt;），表示期望接收的下一个字节序号。它是 TCP 可靠传输的核心机制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;工作原理&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送方发送数据段时，会携带期望接收方的 &lt;code&gt;ACK&lt;/code&gt; 值（例如 &lt;code&gt;ACK = 序列号 + 数据长度&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;接收方收到数据后，会生成一个 &lt;code&gt;ACK&lt;/code&gt; 报文段，确认已接收的数据序号。&lt;/li&gt;
&lt;li&gt;发送方只有在收到对应的 &lt;code&gt;ACK&lt;/code&gt; 后，才会重传未被确认的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若发送方发送了序号为 &lt;code&gt;100~199&lt;/code&gt; 的数据段，则期望接收方的 &lt;code&gt;ACK&lt;/code&gt; 应为 &lt;code&gt;200&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;若接收方未收到 &lt;code&gt;100~199&lt;/code&gt; 中的某些数据，会通过 &lt;code&gt;ACK=150&lt;/code&gt; 告知发送方重传。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;3-psh-和-ack-的组合&#34;&gt;&lt;strong&gt;3. PSH 和 ACK 的组合&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;在 TCP 报文中，&lt;code&gt;PSH&lt;/code&gt; 和 &lt;code&gt;ACK&lt;/code&gt; 可以同时出现，常见于以下场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;HTTP 请求响应&lt;/strong&gt;：&lt;br&gt;
客户端发送 &lt;code&gt;POST&lt;/code&gt; 请求时（含数据），会设置 &lt;code&gt;PSH&lt;/code&gt; 和 &lt;code&gt;ACK&lt;/code&gt;（确认之前的响应）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Client → Server: SYN, ACK=1 → 建立连接
Client → Server: PSH, ACK=1, 数据 → 发送请求数据
Server → Client: PSH, ACK=数据长度+1 → 返回响应
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SSH 握手后传输命令&lt;/strong&gt;：&lt;br&gt;
客户端输入命令后，发送带有 &lt;code&gt;PSH&lt;/code&gt; 和 &lt;code&gt;ACK&lt;/code&gt; 的数据段，确保命令立即传输并被服务器处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;4-其他标志位的关联&#34;&gt;&lt;strong&gt;4. 其他标志位的关联&lt;/strong&gt;
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标志位&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;简要说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SYN&lt;/td&gt;
&lt;td&gt;同步&lt;/td&gt;
&lt;td&gt;初始化连接（三次握手）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FIN&lt;/td&gt;
&lt;td&gt;结束&lt;/td&gt;
&lt;td&gt;优雅关闭连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RST&lt;/td&gt;
&lt;td&gt;复位&lt;/td&gt;
&lt;td&gt;强制终止连接（异常情况）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;URG&lt;/td&gt;
&lt;td&gt;紧急&lt;/td&gt;
&lt;td&gt;标记紧急指针（极少使用）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h3 id=&#34;总结&#34;&gt;&lt;strong&gt;总结&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;PSH&lt;/strong&gt; 关注的是&lt;strong&gt;数据尽快到达应用层&lt;/strong&gt;，降低延迟。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ACK&lt;/strong&gt; 关注的是&lt;strong&gt;数据的可靠传输&lt;/strong&gt;，避免丢包或乱序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两者协同工作，平衡了 TCP 协议的效率和可靠性。&lt;/p&gt;</description>
        </item>
        <item>
        <title>ollama 本地部署 deepseek-R1</title>
        <link>https://ttf248.life/p/ollama-local-deployment-deepseek-r1/</link>
        <pubDate>Fri, 07 Feb 2025 22:41:02 +0800</pubDate>
        
        <guid>https://ttf248.life/p/ollama-local-deployment-deepseek-r1/</guid>
        <description>&lt;p&gt;Ollama 是一个开源的 AI 工具，旨在使用户能够本地运行和部署大型语言模型（LLM）。它的目标是提供一个方便且高效的方式，让开发者可以在本地机器上使用像 GPT 这样的模型，而不需要依赖云端服务。Ollama 支持多种模型，并且专注于优化性能，使得即使是资源有限的设备也能顺畅运行这些模型。&lt;/p&gt;
&lt;p&gt;通过 Ollama，用户可以使用基于文本的 AI 应用程序，并能够与本地部署的模型进行交互，而无需担心数据隐私或是高昂的 API 使用费用。你可以通过命令行界面（CLI）调用不同的模型，进行自然语言处理、问答等任务。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ollama 适合不同模型尝鲜，windows 版本测试下来，无法充分发挥硬件的性能，可能是因为 windows 版本的原因，linux 版本可能会更好。部署32b参数的模型，内存、显卡负载都有不高的情况下，回复速度很慢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;硬件概述&#34;&gt;硬件概述
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;操作系统：win11&lt;/li&gt;
&lt;li&gt;CPU：i7-10700K&lt;/li&gt;
&lt;li&gt;内存：40GB&lt;/li&gt;
&lt;li&gt;显卡：RTX 3060 12GB&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;环境准备&#34;&gt;环境准备
&lt;/h2&gt;&lt;p&gt;新增系统环境变量，方便后续使用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;set OLLAMA_MODELS=E:\ollama&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
这个变量指定了 Ollama 模型的存放路径。&lt;code&gt;E:\ollama&lt;/code&gt; 是一个文件夹路径，表示所有本地模型文件都存储在该目录下。Ollama 会根据这个路径加载和使用你下载或部署的语言模型。你可以将模型文件存放在其他位置，只需要更改这个路径。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;set OLLAMA_HOST=127.0.0.1:8000&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
这个环境变量设置了 Ollama 服务的主机和端口。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;127.0.0.1&lt;/code&gt; 是本地地址（localhost），意味着 Ollama 服务会只监听来自本机的请求。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;8000&lt;/code&gt; 是指定的端口号，表示 Ollama 服务将在 8000 端口上等待和处理请求。你可以根据需要更改端口号，但需要确保该端口没有被其他应用占用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;set OLLAMA_ORIGINS=*&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
这个环境变量控制允许哪些来源的请求访问 Ollama 服务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; 表示允许任何来源（即所有域名和 IP 地址）都可以访问 Ollama 服务。这通常用于开发和调试环境，在生产环境中，通常会指定更严格的来源控制，限制只有特定的域或 IP 才能访问你的服务，以提高安全性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;deepseek-r1-模型部署&#34;&gt;deepseek-R1 模型部署
&lt;/h2&gt;&lt;p&gt;ollama 安装属于傻瓜式，此处不在赘述。&lt;/p&gt;
&lt;p&gt;安装后的校验：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\core&amp;gt;ollama -v
ollama version is 0.5.11
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;模型部署，参考官网模型页面，选择对应参数的模型：&lt;code&gt;ollama run deepseek-r1:14b&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;14b 参数能有效的记住会话上下文，更小的参数版本，无法记住会话上下文。32b 参数版本，本机部署很卡顿，没有再深入进行测试。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.ollama.com/library/deepseek-r1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.ollama.com/library/deepseek-r1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://mp.weixin.qq.com/s/SPEvYTmTBxhoEkJqm1yPmw&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mp.weixin.qq.com/s/SPEvYTmTBxhoEkJqm1yPmw&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/x18990027/article/details/145368094&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/x18990027/article/details/145368094&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>PowerShell 7 与持久化设置命令行预测视图</title>
        <link>https://ttf248.life/p/powershell-7-persisting-settings-commandline-prediction-view/</link>
        <pubDate>Fri, 07 Feb 2025 22:19:12 +0800</pubDate>
        
        <guid>https://ttf248.life/p/powershell-7-persisting-settings-commandline-prediction-view/</guid>
        <description>&lt;p&gt;用习惯了 Linux 上面的 zsh，前两天写博客的时候，突然发现 PowerShell 7 也支持持久化设置命令行预测视图，于是就试了一下，发现还是挺好用的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;也不知道是做了什么操作，开启了这个功能，反正就是有了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在当今多样化的操作系统环境下，系统管理员和开发者们一直在寻找一款能够跨平台、高效且功能强大的工具，以满足他们在系统管理和自动化任务方面的需求。PowerShell 7正是这样一款备受瞩目的工具，它不仅提供了强大的脚本编写能力，还实现了跨Windows、Linux和macOS等操作系统的运行，为用户带来了前所未有的便利。&lt;/p&gt;
&lt;h2 id=&#34;powershell-7跨平台的强大工具&#34;&gt;PowerShell 7：跨平台的强大工具
&lt;/h2&gt;&lt;h3 id=&#34;跨平台特性&#34;&gt;跨平台特性
&lt;/h3&gt;&lt;p&gt;PowerShell 7打破了平台的限制，无论是在Windows系统上进行企业级的服务器管理，还是在Linux环境下进行系统运维，亦或是在macOS上进行日常开发任务，用户都可以使用统一的PowerShell 7工具。这极大地提高了工作效率，减少了因平台差异而带来的学习成本和操作复杂性。&lt;/p&gt;
&lt;h3 id=&#34;强大的功能&#34;&gt;强大的功能
&lt;/h3&gt;&lt;p&gt;它具备强大的脚本编写能力，支持面向对象编程、函数、模块等高级编程特性。通过PowerShell 7，用户可以轻松地操作文件系统，对文件和文件夹进行创建、删除、复制、移动等操作；可以访问和修改注册表，对系统的配置进行深度调整；能够管理进程和服务，实现对系统运行状态的有效监控和控制。此外，PowerShell 7还能与各种Windows和非Windows技术进行交互，例如在Active Directory中进行用户和权限管理，在Azure云平台上进行资源调配和管理等。&lt;/p&gt;
&lt;h3 id=&#34;开源生态&#34;&gt;开源生态
&lt;/h3&gt;&lt;p&gt;PowerShell 7是开源的，这一特性使得全球的开发者和爱好者能够积极参与到它的开发和改进中来。大量的开源模块和工具不断涌现，丰富了PowerShell 7的功能和应用场景。用户可以根据自己的需求，在开源社区中找到合适的模块来扩展PowerShell 7的功能，或者贡献自己的代码，推动整个社区的发展。&lt;/p&gt;
&lt;h3 id=&#34;兼容性与稳定性&#34;&gt;兼容性与稳定性
&lt;/h3&gt;&lt;p&gt;PowerShell 7在保持对旧版本PowerShell一定兼容性的同时，引入了许多新的功能和改进。这些改进不仅提升了性能，还增强了稳定性，使得用户在使用过程中能够更加流畅地完成各种任务，减少了因软件故障而导致的工作中断。&lt;/p&gt;
&lt;h2 id=&#34;开启命令行预测视图&#34;&gt;开启命令行预测视图
&lt;/h2&gt;&lt;p&gt;在PowerShell 7的众多实用功能中，&lt;code&gt;Set-PSReadLineOption -PredictionViewStyle ListView&lt;/code&gt; 命令是一个能够提升用户命令行输入体验的实用工具。&lt;/p&gt;
&lt;p&gt;不开启命令，也能实现自动补全，但是仅仅是行内的补全，开启后，可以实现预测视图，以列表的形式展示所有可能的补全选项，用户可以通过上下键选择需要的选项，从而提高了命令输入的准确性和效率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/powershell-7-persisting-settings-commandline-prediction-view/20250207222546.png&#34;
	width=&#34;814&#34;
	height=&#34;205&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;powershell7&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;397&#34;
		data-flex-basis=&#34;952px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;让命令持久生效的方法&#34;&gt;让命令持久生效的方法
&lt;/h2&gt;&lt;p&gt;为了让 &lt;code&gt;Set-PSReadLineOption -PredictionViewStyle ListView&lt;/code&gt; 命令在每次启动PowerShell时都能生效，我们可以将其添加到PowerShell的配置文件中。PowerShell的配置文件是一个特殊的脚本，在PowerShell启动时会自动执行其中的命令。&lt;/p&gt;
&lt;h3 id=&#34;确定配置文件路径&#34;&gt;确定配置文件路径
&lt;/h3&gt;&lt;p&gt;在PowerShell中，我们可以使用 &lt;code&gt;$PROFILE&lt;/code&gt; 变量来查看配置文件的路径。如果该路径下的文件不存在，用户可以手动创建一个。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo $PROFILE
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;打开配置文件&#34;&gt;打开配置文件
&lt;/h3&gt;&lt;p&gt;使用文本编辑器，如功能强大的Notepad++或者轻量级的Visual Studio Code，打开通过 &lt;code&gt;$PROFILE&lt;/code&gt; 变量获取到的配置文件路径对应的文件。&lt;/p&gt;
&lt;h3 id=&#34;添加命令&#34;&gt;添加命令
&lt;/h3&gt;&lt;p&gt;在打开的配置文件中，添加 &lt;code&gt;Set-PSReadLineOption -PredictionViewStyle ListView&lt;/code&gt; 命令。确保命令的书写准确无误，以保证配置文件在执行时能够正确生效。&lt;/p&gt;
&lt;h3 id=&#34;保存配置文件&#34;&gt;保存配置文件
&lt;/h3&gt;&lt;p&gt;完成命令添加后，保存配置文件并关闭文本编辑器。此时，配置文件已经包含了我们希望在每次PowerShell启动时执行的命令。&lt;/p&gt;
&lt;h3 id=&#34;验证设置&#34;&gt;验证设置
&lt;/h3&gt;&lt;p&gt;关闭当前的PowerShell窗口，重新启动PowerShell。在新启动的PowerShell中，输入命令时，命令行输入预测视图样式应该已经按照我们的设置，以列表视图的形式展示，这表明我们的设置已经成功生效。&lt;/p&gt;
&lt;p&gt;通过以上步骤，我们不仅深入了解了PowerShell 7的强大功能和特性，还掌握了如何通过设置命令行输入预测视图样式来提升操作体验，并且学会了如何让这些设置持久生效。希望这些知识能够帮助你在使用PowerShell 7的过程中更加得心应手，高效地完成各种系统管理和自动化任务。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/PowerShell/PowerShell/releases&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/PowerShell/PowerShell/releases&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.v2ex.com/t/911909&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.v2ex.com/t/911909&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>visual studio 加载“不配套”的 pdb 文件</title>
        <link>https://ttf248.life/p/visual-studio-load-unmatched-pdb/</link>
        <pubDate>Thu, 23 Jan 2025 20:04:33 +0800</pubDate>
        
        <guid>https://ttf248.life/p/visual-studio-load-unmatched-pdb/</guid>
        <description>&lt;p&gt;windows 下，使用 visual studio 调试程序时，如果 pdb 文件与可执行文件不匹配，visual studio 会提示“无法加载符号文件”。程序运行发生崩溃，落地 dump 文件，如果是不匹配的 pdb 文件，visual studio 也无法顺利的进入崩溃现场。&lt;/p&gt;
&lt;h2 id=&#34;什么是-pdb-文件&#34;&gt;什么是 pdb 文件
&lt;/h2&gt;&lt;p&gt;PDB 文件是微软的一种调试信息文件，用于调试程序。PDB 文件包含了程序的符号表、源代码文件名、行号等信息。在程序编译时，可以生成 PDB 文件，用于调试程序。&lt;/p&gt;
&lt;h2 id=&#34;windbg-调试&#34;&gt;WinDbg 调试
&lt;/h2&gt;&lt;p&gt;WinDbg 是微软的一款调试工具，可以用于调试 windows 程序。WinDbg 可以加载不匹配的 pdb 文件，但是需要手动加载。&lt;code&gt;.reload /f /i&lt;/code&gt; 命令可以强制加载不匹配的 pdb 文件。&lt;/p&gt;
&lt;p&gt;但是 WinDbg 使用起来不如 visual studio 方便，所以我们希望 visual studio 也能加载不匹配的 pdb 文件。&lt;/p&gt;
&lt;h2 id=&#34;visual-studio-加载不匹配的-pdb-文件&#34;&gt;visual studio 加载不匹配的 pdb 文件
&lt;/h2&gt;&lt;p&gt;源码现在一般都是通过 git 管理，完全能找到对应版本的代码，重新编译，生成对应的 pdb 文件。为什么无法加载呢？主要是一些元数据无法匹配。&lt;/p&gt;
&lt;p&gt;有个小工具，可以修改元数据，基于 exe 文件信息，生成一个新的 pdb 文件，使得 visual studio 能够加载。&lt;/p&gt;
&lt;p&gt;chkmatch 下载地址：&lt;a class=&#34;link&#34; href=&#34;https://www.debuginfo.com/tools/chkmatch.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.debuginfo.com/tools/chkmatch.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;站点缓存地址：&lt;a class=&#34;link&#34; href=&#34;chkmatch.zip&#34; &gt;chkmatch.zip&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ChkMatch utility can be used to check whether an executable and debug information file match. It can also be used to enforce matching between an executable and debug information file, if they are compatible.

For more information about debug information matching and related issues, see this article.

Supported debug information formats: DBG, PDB 2.0, PDB 7.0.

chkmatch [-c ExeFile DebugInfoFile ] |
         [-m ExeFile DebugInfoFile]
-c
Check matching between the executable and the debug information file.
-m
Make the executable and the debug information file match.
ExeFile
The name of the executable file.
DebugInfoFile
The name of the debug information file.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;使用-chkmatch&#34;&gt;使用 chkmatch
&lt;/h2&gt;&lt;p&gt;先执行检查操作，分析不匹配的原因，提示签名不匹配。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\tianlong.xiang\Downloads\chkmatch&amp;gt;ChkMatch.exe -c &amp;quot;D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe&amp;quot; E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb
ChkMatch - version 1.0
Copyright (C) 2004 Oleg Starodumov
http://www.debuginfo.com/


Executable: D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe
Debug info file: E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb

Executable:
TimeDateStamp: c26d9be3
Debug info: 2 ( CodeView )
TimeStamp: f86b0a4f  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 122  RVA: 001cdc44  FileOffset: 001cbe44
CodeView format: RSDS
Signature: {428c9b95-39a3-4a8d-a8e5-7be453684757}  Age: 1
PdbFile: D:\stock_UAT\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\obj\Release\YinTrade.Main.pdb
Debug info: 16 ( Unknown )
TimeStamp: 00000000  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 0  RVA: 00000000  FileOffset: 00000000

Debug information file:
Format: PDB 7.00
Signature: {06fae08e-c0a2-4f3d-9c7c-dfc684445dd1}  Age: 1

Result: Unmatched (reason: Signature mismatch)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后执行修改操作，使得 pdb 文件与 exe 文件匹配。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\tianlong.xiang\Downloads\chkmatch&amp;gt;ChkMatch.exe -m &amp;quot;D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe&amp;quot; E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb
ChkMatch - version 1.0
Copyright (C) 2004 Oleg Starodumov
http://www.debuginfo.com/


Executable: D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe
Debug info file: E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb

Executable:
TimeDateStamp: c26d9be3
Debug info: 2 ( CodeView )
TimeStamp: f86b0a4f  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 122  RVA: 001cdc44  FileOffset: 001cbe44
CodeView format: RSDS
Signature: {428c9b95-39a3-4a8d-a8e5-7be453684757}  Age: 1
PdbFile: D:\stock_UAT\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\obj\Release\YinTrade.Main.pdb
Debug info: 16 ( Unknown )
TimeStamp: 00000000  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 0  RVA: 00000000  FileOffset: 00000000

Debug information file:
Format: PDB 7.00
Signature: {06fae08e-c0a2-4f3d-9c7c-dfc684445dd1}  Age: 1

Writing to the debug information file...
Result: Success.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/38147487/forcing-to-load-unmatched-symbols-in-visual-studio-2015-debugger&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;forcing-to-load-unmatched-symbols-in-visual-studio-2015-debugger&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Cursor AI 编程 IDE 试用</title>
        <link>https://ttf248.life/p/cursor-ai-programming-ide-trial/</link>
        <pubDate>Thu, 23 Jan 2025 19:30:13 +0800</pubDate>
        
        <guid>https://ttf248.life/p/cursor-ai-programming-ide-trial/</guid>
        <description>&lt;p&gt;转眼又是一年过去了，工作上的最大的变动，还是AI参与度明显提高了，相当以往来说，不同的开发语言之间切换，需要开发者熟悉的各种语言不同的 api 接口，现在这些基础代码都可以通过 AI 生成代码了，对于开发者来说，就是一个很大的福音。&lt;/p&gt;
&lt;h2 id=&#34;chatgpt&#34;&gt;ChatGPT
&lt;/h2&gt;&lt;p&gt;早在 23 年的时候，整过两篇简单的入门介绍，转眼已经到了 25 年，怎么说呢，并没有感知到显著的进步，还是需要开发有自己的认知，能合理的拆分任务，当然，最重要的是识别 AI 生成的代码是否存在 bug。&lt;/p&gt;
&lt;h2 id=&#34;github-copilot&#34;&gt;Github copilot
&lt;/h2&gt;&lt;p&gt;忘记是是哪天了，看到资料说新加坡部署了服务器，国内使用，再也不用长期挂梯子，当然，登录的时候，还是需要挂个梯子，不过这个梯子只需要登录的时候用一下，之后就可以关闭了。&lt;/p&gt;
&lt;p&gt;日常用的更多的也是 Github copilot，这个插件，可以直接在 vscode、visual studio 中直接使用。不用两个软件之间切换。相对于 ChatGPT，Github copilot 对于项目的支持更好，交互上更友好，能你能选择部分本地的文件投喂，&lt;strong&gt;“训练”AI&lt;/strong&gt;，这样生成的代码更符合你的项目。&lt;/p&gt;
&lt;h2 id=&#34;cursor-ai&#34;&gt;Cursor AI
&lt;/h2&gt;&lt;p&gt;最近看到了一个新的 AI 编程 IDE，Cursor AI，这个 IDE 也是基于 Github copilot 的，不过这个 IDE 更加的智能，可以帮你直接创建文件。&lt;/p&gt;
&lt;p&gt;简单的用了一下，感觉还是不错的，不过对于现有项目的理解还是不够，本地项目文件多的时候，大的重构优化调整，还是需要&lt;strong&gt;开发者拆分任务&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;附上一个例子：切换到 curso 的工程模式，输入内容：新建个人简历网页，支持多个不同风格切换，记得填充一些个人信息用于数据展示。&lt;/p&gt;
&lt;p&gt;经过几次来回的&lt;strong&gt;拉扯&lt;/strong&gt;，你就能拿到如下的网页，当然，这个网页还是比较简单的，不过对于新手来说，还是很不错的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目前注册用户能免费试用 150 次高级 api，付费用户限制 5000 次高级 api&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://ttf248.life/cursor/index.html&#34; &gt;个人简历&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43; 位操作基础：按位取值与标志位设置</title>
        <link>https://ttf248.life/p/cpp-bitwise-operations-flags/</link>
        <pubDate>Fri, 17 Jan 2025 02:23:56 +0800</pubDate>
        
        <guid>https://ttf248.life/p/cpp-bitwise-operations-flags/</guid>
        <description>&lt;p&gt;在实际的C++开发中，位操作是常见的技术，尤其在处理系统状态、标志位或控制位时，位操作可以提供非常高效的解决方案。本文将通过一个例子，讲解如何使用位操作来获取和设置特定的标志位。&lt;/p&gt;
&lt;h3 id=&#34;位操作基础概念&#34;&gt;位操作基础概念
&lt;/h3&gt;&lt;p&gt;在计算机中，数据是以二进制位（0和1）存储的。位操作就是对二进制位进行操作。C++中有几种常用的位操作符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;按位与（&amp;amp;）&lt;/strong&gt;：用于检查某一位是否为1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按位或（|）&lt;/strong&gt;：用于设置某一位为1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按位异或（^）&lt;/strong&gt;：用于反转某一位。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按位取反（~）&lt;/strong&gt;：将所有位反转。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;左移（&amp;laquo;）&lt;/strong&gt;：将所有位左移若干位。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;右移（&amp;raquo;）&lt;/strong&gt;：将所有位右移若干位。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在本例中，我们需要对一个 &lt;code&gt;unsigned short&lt;/code&gt; 类型的变量 &lt;code&gt;wInfo&lt;/code&gt; 进行一系列的位操作，通过不同的标志位来表示不同的状态。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;flowchart LR
    A[原始数值: 00010000] --&amp;gt; B[左移: 00010000 &amp;lt;&amp;lt; 1]
    B --&amp;gt; C[结果: 00100000]
    C --&amp;gt; D[右移: 00100000 &amp;gt;&amp;gt; 1]
    D --&amp;gt; E[结果: 00010000]

    subgraph 左移操作
        direction LR
        A --&amp;gt; B --&amp;gt; C
    end

    subgraph 右移操作
        direction LR
        C --&amp;gt; D --&amp;gt; E
    end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;需求解析&#34;&gt;需求解析
&lt;/h3&gt;&lt;p&gt;根据题目中的描述，我们有一个 16 位的标志位，用来表示不同的状态。这些状态通过各个不同的二进制位来表示，每个二进制位对应一种特定的含义。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;bit0&lt;/strong&gt; 是否失败&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit1&lt;/strong&gt; 是否压缩&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit2&lt;/strong&gt; 是否增量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit3&lt;/strong&gt; 是否有后续包&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit5&lt;/strong&gt; 正常请求或注销&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;使用位操作实现&#34;&gt;使用位操作实现
&lt;/h3&gt;&lt;p&gt;我们将通过位操作来设置和获取这些标志位。具体来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;按位取值&lt;/strong&gt;：获取某一位的值（0或1）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按位设置&lt;/strong&gt;：设置某一位为1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按位清除&lt;/strong&gt;：设置某一位为0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们首先定义一个 &lt;code&gt;unsigned short&lt;/code&gt; 类型的变量 &lt;code&gt;wInfo&lt;/code&gt; 来保存这些标志位。然后，我们通过位操作来检查和设置相应的标志。&lt;/p&gt;
&lt;h3 id=&#34;c-示例代码&#34;&gt;C++ 示例代码
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;bitset&amp;gt;

// 定义标志位常量
const unsigned short BIT_0_FAIL = 1 &amp;lt;&amp;lt; 0;    // bit0 是否失败
const unsigned short BIT_1_COMPRESSED = 1 &amp;lt;&amp;lt; 1; // bit1 是否压缩
const unsigned short BIT_2_INCREMENT = 1 &amp;lt;&amp;lt; 2;  // bit2 是否增量
const unsigned short BIT_3_HAS_MORE = 1 &amp;lt;&amp;lt; 3;   // bit3 是否有后续包
const unsigned short BIT_5_CANCEL = 1 &amp;lt;&amp;lt; 5;     // bit5 正常请求(0)或注销(1)

// 检查某一位是否为1
bool isBitSet(unsigned short wInfo, unsigned short bitMask) {
    return (wInfo &amp;amp; bitMask) != 0;
}

// 设置某一位为1
void setBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo |= bitMask;
}

// 清除某一位（设置为0）
void clearBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo &amp;amp;= ~bitMask;
}

int main() {
    // 假设wInfo的初始值为0
    unsigned short wInfo = 0;

    // 设置bit0（失败标志）
    setBit(wInfo, BIT_0_FAIL);
    
    // 设置bit1（压缩标志）
    setBit(wInfo, BIT_1_COMPRESSED);
    
    // 打印wInfo的二进制值
    std::cout &amp;lt;&amp;lt; &amp;quot;wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    // 检查各个标志位
    std::cout &amp;lt;&amp;lt; &amp;quot;bit0 (是否失败): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_0_FAIL) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit1 (是否压缩): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_1_COMPRESSED) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit2 (是否增量): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_2_INCREMENT) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit3 (是否有后续包): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_3_HAS_MORE) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit5 (是否注销): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_5_CANCEL) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;

    // 清除bit1（压缩标志）
    clearBit(wInfo, BIT_1_COMPRESSED);
    
    // 打印更新后的wInfo
    std::cout &amp;lt;&amp;lt; &amp;quot;Updated wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行代码，推荐老朋友：&lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wInfo (in binary): 0000000000000011
bit0 (是否失败): 是
bit1 (是否压缩): 是
bit2 (是否增量): 否
bit3 (是否有后续包): 否
bit5 (是否注销): 否
Updated wInfo (in binary): 0000000000000001
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;代码解释&#34;&gt;代码解释
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标志位定义&lt;/strong&gt;：使用位移操作（&lt;code&gt;1 &amp;lt;&amp;lt; n&lt;/code&gt;）来定义各个标志位。例如，&lt;code&gt;1 &amp;lt;&amp;lt; 0&lt;/code&gt; 对应 &lt;code&gt;bit0&lt;/code&gt;，&lt;code&gt;1 &amp;lt;&amp;lt; 1&lt;/code&gt; 对应 &lt;code&gt;bit1&lt;/code&gt;，依此类推。这样，我们就为每个标志位分配了唯一的二进制位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;检查某一位&lt;/strong&gt;：&lt;code&gt;isBitSet&lt;/code&gt; 函数通过与运算 &lt;code&gt;wInfo &amp;amp; bitMask&lt;/code&gt; 来检查特定的标志位是否为1。如果该位为1，函数返回&lt;code&gt;true&lt;/code&gt;，否则返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;设置某一位&lt;/strong&gt;：&lt;code&gt;setBit&lt;/code&gt; 函数通过按位或操作 &lt;code&gt;wInfo |= bitMask&lt;/code&gt; 来将特定的标志位置为1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;清除某一位&lt;/strong&gt;：&lt;code&gt;clearBit&lt;/code&gt; 函数通过按位与操作 &lt;code&gt;wInfo &amp;amp;= ~bitMask&lt;/code&gt; 来将特定的标志位置为0。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结
&lt;/h3&gt;&lt;p&gt;通过位操作，我们能够高效地处理多个状态标志位。在实际开发中，这种技术尤其有用。例如，在嵌入式开发、网络协议、系统状态管理等场景中，常常使用位标志来表示多个二进制状态，既节省空间又提高效率。&lt;/p&gt;
&lt;p&gt;希望这篇博客能够帮助你理解如何在 C++ 中使用位操作来实现按位取值和设置，掌握这些技能对编写高效且易于维护的代码非常有帮助！&lt;/p&gt;</description>
        </item>
        <item>
        <title>台式升级到2.5G网卡，加速局域网互联</title>
        <link>https://ttf248.life/p/desktop-upgrade-to-2-5g-network-card-accelerates-local-area-network-interconnection/</link>
        <pubDate>Fri, 10 Jan 2025 00:37:52 +0800</pubDate>
        
        <guid>https://ttf248.life/p/desktop-upgrade-to-2-5g-network-card-accelerates-local-area-network-interconnection/</guid>
        <description>&lt;p&gt;台式机硬件三连发，前文我们提到了固态硬盘 PCIE 转接器，老的固态哪里去了呢？当然没有浪费，有没有坏掉，拆下来安装到了新买的&lt;code&gt;机械师创物者Mini-3765H&lt;/code&gt;上（一年前）。&lt;/p&gt;
&lt;p&gt;新机器，硬件规格还是给力的，2.5G 双网口、PCIE4.0、WiFi6。&lt;/p&gt;
&lt;p&gt;最近搬家了房间没有单独的路由器组网，机器都是走无线网络连接，华硕主板台式机的无线网卡性能不太行，也可能是路由器无线接入，局域网之间上传速度不行，导致机器之间的网速不太行。新购买 2.5G 网卡，安装到台式机上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;至此，主板的插槽用完了：显卡、无线网卡、2.5G 网卡、固态硬盘 PCIE 转接器。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;网络说明&#34;&gt;网络说明
&lt;/h2&gt;&lt;p&gt;两台机器上网还是靠原本的无线网卡，但是两台之间走网线直连，两端都是 2.5G 网卡。怎么网线直连两台机器，这里就不多说明了，网上有很多教程，记得放开防火墙。任选一台作为网关即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
    A[机器1&amp;lt;br&amp;gt;IP: 192.168.4.1&amp;lt;br&amp;gt;子网掩码: 255.255.255.0&amp;lt;br&amp;gt;默认网关: - &amp;lt;br&amp;gt;自动获取DNS] --&amp;gt;|网线直连（2.5G）| B[机器2&amp;lt;br&amp;gt;IP: 192.168.4.2&amp;lt;br&amp;gt;子网掩码: 255.255.255.0&amp;lt;br&amp;gt;默认网关: 192.168.4.1&amp;lt;br&amp;gt;自动获取DNS];
    A --&amp;gt;|无线网卡| Internet;
    B --&amp;gt;|无线网卡| Internet;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;两个网段测速&#34;&gt;两个网段测速
&lt;/h2&gt;&lt;h3 id=&#34;路由器局域网&#34;&gt;路由器局域网
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\core\Desktop\iperf-3.1.3-win32&amp;gt;iperf3.exe -c 192.168.3.237
Connecting to host 192.168.3.237, port 5201
[  4] local 192.168.3.122 port 1656 connected to 192.168.3.237 port 5201
[ ID] Interval           Transfer     Bandwidth
[  4]   0.00-1.00   sec  9.17 MBytes  76.7 Mbits/sec
[  4]   1.00-2.00   sec  9.91 MBytes  83.2 Mbits/sec
[  4]   2.00-3.00   sec  8.74 MBytes  73.3 Mbits/sec
[  4]   3.00-4.00   sec  10.2 MBytes  85.2 Mbits/sec
[  4]   4.00-5.00   sec  9.23 MBytes  77.1 Mbits/sec
[  4]   5.00-6.00   sec  8.80 MBytes  73.9 Mbits/sec
[  4]   6.00-7.01   sec  8.00 MBytes  66.8 Mbits/sec
[  4]   7.01-8.00   sec  7.69 MBytes  64.9 Mbits/sec
[  4]   8.00-9.01   sec  9.72 MBytes  81.1 Mbits/sec
[  4]   9.01-10.01  sec  7.63 MBytes  63.6 Mbits/sec
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bandwidth
[  4]   0.00-10.01  sec  89.0 MBytes  74.6 Mbits/sec                  sender
[  4]   0.00-10.01  sec  89.0 MBytes  74.6 Mbits/sec                  receiver

iperf Done.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;直连局域网&#34;&gt;直连局域网
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\core\Desktop\iperf-3.1.3-win32&amp;gt;iperf3.exe -c 192.168.4.1
Connecting to host 192.168.4.1, port 5201
[  4] local 192.168.4.2 port 1524 connected to 192.168.4.1 port 5201
[ ID] Interval           Transfer     Bandwidth
[  4]   0.00-1.01   sec   178 MBytes  1.48 Gbits/sec
[  4]   1.01-2.00   sec   204 MBytes  1.72 Gbits/sec
[  4]   2.00-3.00   sec   214 MBytes  1.80 Gbits/sec
[  4]   3.00-4.00   sec   229 MBytes  1.92 Gbits/sec
[  4]   4.00-5.00   sec   202 MBytes  1.69 Gbits/sec
[  4]   5.00-6.00   sec   213 MBytes  1.79 Gbits/sec
[  4]   6.00-7.00   sec   230 MBytes  1.93 Gbits/sec
[  4]   7.00-8.00   sec   192 MBytes  1.61 Gbits/sec
[  4]   8.00-9.00   sec   220 MBytes  1.84 Gbits/sec
[  4]   9.00-10.00  sec   230 MBytes  1.93 Gbits/sec
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bandwidth
[  4]   0.00-10.00  sec  2.06 GBytes  1.77 Gbits/sec                  sender
[  4]   0.00-10.00  sec  2.06 GBytes  1.77 Gbits/sec                  receiver

iperf Done.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://wutongsuimeng.github.io/post/%E7%BB%99hugo%E6%B7%BB%E5%8A%A0mermaid%E6%94%AF%E6%8C%81/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;给hugo添加mermaid支持&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>华硕主板 Z490 安装磁盘太多，偶发性磁盘无法识别</title>
        <link>https://ttf248.life/p/asus-z490-motherboard-disk-recognition-issues/</link>
        <pubDate>Fri, 10 Jan 2025 00:08:51 +0800</pubDate>
        
        <guid>https://ttf248.life/p/asus-z490-motherboard-disk-recognition-issues/</guid>
        <description>&lt;p&gt;紧接上文，莫名出现无线网卡无法识别的问题，在重建分区之前，网上也查到了其他方案，比如说：主板电池卸载，断电十五分钟；升级最新版本的 BOIS 驱动，但是都有问题。&lt;/p&gt;
&lt;p&gt;想着还有事情要处理，切换到有限网络，从客厅拉网线的到房间，这个时候，问题又来了，有线网络也无法识别。上大招重装系统，出现引导分区丢失。如果是一直出现问题，也不会折腾这么久，华硕这个磁盘冲突，是偶发性的，系统重启不稳定触发。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上周台式机添置了新的磁盘，长江存储的 2T 固态硬盘，M2 接口，然后机器就一直没重启，直到昨天关机了一次。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/asus-z490-motherboard-disk-recognition-issues/20250110002801.png&#34;
	width=&#34;553&#34;
	height=&#34;322&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;磁盘全家福&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;171&#34;
		data-flex-basis=&#34;412px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;重装系统&#34;&gt;重装系统
&lt;/h2&gt;&lt;p&gt;算算时间也都两年没有重装系统，C盘已经不够用了，windows 老问题，日常各种软件都喜欢在 C盘 存点东西。于是，决定重装系统。系统重装以后，网卡问题都正常了，隔天恢复了日常的开发环境，准备做个系统备份，这个时候新的问题来了，系统重启以后，引导分区丢失。&lt;/p&gt;
&lt;p&gt;按照上一篇文章的步骤，重建了引导分区，但是不太稳定，重启以后，引导分区随时可能加载不到，开始怀疑折腾机箱的时候，硬盘线松动了，但是检查了几次，都没有问题。&lt;/p&gt;
&lt;h2 id=&#34;记忆复苏&#34;&gt;记忆复苏
&lt;/h2&gt;&lt;p&gt;很多年前，这台机器加装过一次固态硬盘，那会是新买了一个 PCIE 转换器（插在显卡接口上），没有直接将硬盘安装到主板上。这次，直接安装到主板上，可能是主板的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/asus-z490-motherboard-disk-recognition-issues/20250110002148.png&#34;
	width=&#34;325&#34;
	height=&#34;545&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;固态转换器&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;59&#34;
		data-flex-basis=&#34;143px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;主板说明书&#34;&gt;主板说明书
&lt;/h2&gt;&lt;p&gt;主板说明书，存在问题，标注的 SATA 接口的位置和实际的位置不同，由于磁盘太多，接口上都安装了硬盘，老的固态都是 SATA 接口，按照主板说明书，接口之间是存在冲突的，经过实际的测试，发现这个冲突是不稳定触发，触发的时候，就会导致对应的磁盘无法加载，刚好这个是系统磁盘，引导也在对应的磁盘上，系统启动就会出现引导加载失败。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/asus-z490-motherboard-disk-recognition-issues/20250110002401.png&#34;
	width=&#34;807&#34;
	height=&#34;847&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Z490&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;95&#34;
		data-flex-basis=&#34;228px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;解决方案&#34;&gt;解决方案
&lt;/h2&gt;&lt;p&gt;重新安装固态硬盘到 PCIE 转换器上，这个时候，主板上的 SATA 接口就不会有冲突了，系统启动正常。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Windows自带的磁盘清理工具：存储</title>
        <link>https://ttf248.life/p/windows-disk-cleanup-storage/</link>
        <pubDate>Mon, 06 Jan 2025 19:29:45 +0800</pubDate>
        
        <guid>https://ttf248.life/p/windows-disk-cleanup-storage/</guid>
        <description>&lt;p&gt;从什么版本开始的我也不清楚，但是在&lt;code&gt;Windows 11&lt;/code&gt;中，磁盘清理工具已经有了很大的改进，变得更加智能了。&lt;/p&gt;
&lt;p&gt;重点它是官方的工具，不会误删文件，不会有广告，不会有弹窗，不会有后台进程，不会有任何不必要的东西。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Windows 11&lt;/code&gt;中，可以通过&lt;code&gt;设置&lt;/code&gt;-&lt;code&gt;系统&lt;/code&gt;-&lt;code&gt;存储&lt;/code&gt;-&lt;code&gt;临时文件&lt;/code&gt;来打开磁盘清理工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/windows-disk-cleanup-storage/20250106194453.png&#34;
	width=&#34;1041&#34;
	height=&#34;775&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;存储界面&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;134&#34;
		data-flex-basis=&#34;322px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;普通用户选择&lt;code&gt;清理建议&lt;/code&gt;即可，系统会根据你的使用情况，给出一些建议。&lt;/p&gt;
&lt;p&gt;笔者作为一个开发者，磁盘上有很多临时文件，所以选择&lt;code&gt;临时文件&lt;/code&gt;，里面包含了很多临时文件，比如&lt;code&gt;Visual Studio&lt;/code&gt;的临时文件，&lt;code&gt;Windows Update&lt;/code&gt;的临时文件等等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/windows-disk-cleanup-storage/Snipaste_2024-12-19_13-39-51.png&#34;
	width=&#34;465&#34;
	height=&#34;980&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;临时文件&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;47&#34;
		data-flex-basis=&#34;113px&#34;
	
&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>Docker 国内镜像代理失效</title>
        <link>https://ttf248.life/p/docker-domestic-image-proxy-failure/</link>
        <pubDate>Sat, 04 Jan 2025 18:29:25 +0800</pubDate>
        
        <guid>https://ttf248.life/p/docker-domestic-image-proxy-failure/</guid>
        <description>&lt;p&gt;国内服务器部署docker，部署以后，如果公司没有提供镜像中心，开发首先要做的就是配置一个国内的镜像加速地址。巧了今天有台服务器，配置了镜像加速地址，但是发现拉取镜像的时候，一直拉取不到。&lt;/p&gt;
&lt;p&gt;报错信息：&lt;code&gt;Error response from daemon: Get &amp;quot;https://registry-1.docker.io/v2/&amp;quot;: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;20250106 时隔两天，所有的服务器都恢复了，这事居然不上热搜，国内所有的镜像代理都挂了&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;故障排查与修复尝试&#34;&gt;故障排查与修复尝试
&lt;/h2&gt;&lt;p&gt;起初，尝试切换至其他镜像加速地址，期望借此解决问题，然而事与愿违，问题依旧。&lt;/p&gt;
&lt;p&gt;紧接着，着手修改本地 DNS 配置，试图从网络解析层面找到突破口，遗憾的是，经过一番调试，故障依然存在。&lt;/p&gt;
&lt;p&gt;此时，本地网络的稳定性已备受质疑，于是果断切换至手机热点，试图绕过可能存在的本地网络故障点，可结果还是令人沮丧，问题毫无改善迹象。&lt;/p&gt;
&lt;h2 id=&#34;问题蔓延&#34;&gt;问题蔓延
&lt;/h2&gt;&lt;p&gt;手头尚有&lt;strong&gt;几台部署于国内的服务器&lt;/strong&gt;，且均安装了 Docker 环境。尝试在这些服务器上拉取镜像，本以为能另辟蹊径，结果发现无一例外，均无法成功拉取，所反馈的报错信息如出一辙，这表明问题并非局限于某一台设备。&lt;/p&gt;
&lt;p&gt;进一步探究发现，镜像代理似乎瞬间失灵，在这紧急关头，迅速切换至境外机器进行尝试，令人稍感欣慰的是，镜像拉取在此处恢复正常，这意味着问题大概率出在国内的网络链路或相关配置上。&lt;/p&gt;
&lt;h2 id=&#34;策略调整迂回解决&#34;&gt;策略调整：迂回解决
&lt;/h2&gt;&lt;p&gt;鉴于国内直接拉取镜像的途径已被重重阻碍，而国外镜像却能正常访问，为尽快推进项目，决定采取迂回战术。首先切换至国外服务器，顺利拉取所需镜像，随后将其推送至国内镜像仓库，以此搭建起一座“数据桥梁”。&lt;/p&gt;
&lt;p&gt;与此同时，同步对 Dockerfile 文件进行修改，将镜像地址替换为适配国内环境的地址，再重新构建镜像，最终成功部署。&lt;/p&gt;</description>
        </item>
        <item>
        <title>CentOS 8 Stream EOL</title>
        <link>https://ttf248.life/p/centos-8-stream-eol/</link>
        <pubDate>Sat, 16 Nov 2024 23:24:50 +0800</pubDate>
        
        <guid>https://ttf248.life/p/centos-8-stream-eol/</guid>
        <description>&lt;p&gt;&lt;code&gt;CentOS Stream&lt;/code&gt;是红帽企业&lt;code&gt;Linux&lt;/code&gt;发行之前的上游开源开发平台‌。
首次关注到开源操作系统生命周期 &lt;a class=&#34;link&#34; href=&#34;https://ttf248.life/p/redhat-centos-lifecycle/&#34; &gt;redhat and centos life cycle&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;到期了，有什么问题呢？除了安全问题，dnf 不能用了，我也是最近安装工具的时候，发现 dnf 失败，检查镜像源，发现是 &lt;code&gt;CentOS 8 Stream&lt;/code&gt; 到期了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;centos-stream简介&#34;&gt;CentOS Stream简介
&lt;/h2&gt;&lt;h3 id=&#34;定位与角色&#34;&gt;定位与角色‌
&lt;/h3&gt;&lt;p&gt;CentOS Stream位于Fedora Linux（上游开发）和RHEL（Red Hat Enterprise Linux，下游开发）之间，充当着桥梁的角色。&lt;/p&gt;
&lt;p&gt;它可以被视为是用来体验最新红帽系Linux特性的一个版本，适合尝鲜使用。‌&lt;/p&gt;
&lt;h3 id=&#34;诞生与背景&#34;&gt;诞生与背景‌
&lt;/h3&gt;&lt;p&gt;随着时间的推移，Red Hat公司开始寻求更加有效的方式来发展其企业级Linux平台，于是推出了CentOS Stream。&lt;/p&gt;
&lt;p&gt;‌CentOS 8在2021年年底结束维护后，CentOS Stream作为其继承者继续更新，并成为CentOS项目的未来发展方向。‌&lt;/p&gt;
&lt;h3 id=&#34;特点与优势&#34;&gt;特点与优势‌
&lt;/h3&gt;&lt;p&gt;CentOS Stream是一个滚动发布的Linux发行版，提供更快捷的更新。它为社区、合作伙伴和客户的参与提供了更高的透明度和更多机会，使得用户可以更快、更直接地为红帽企业Linux做贡献。‌&lt;/p&gt;
&lt;p&gt;CentOS Stream的内容是Red Hat有意收录于下个稳定版RHEL的软件，因此它能为社群成员提供一个稳定的ABI/API进行开发及测试之用。&lt;/p&gt;
&lt;h3 id=&#34;使用场景与目标用户&#34;&gt;使用场景与目标用户‌
&lt;/h3&gt;&lt;p&gt;CentOS Stream适合那些希望继续获得最新Linux特性更新的CentOS用户，以及希望参与红帽企业Linux开发的开发人员和合作伙伴。‌&lt;/p&gt;
&lt;p&gt;它也旨在协助社群中的成员、Red Hat伙伴及其他人在一个较稳定及可预测的Linux生态环境下充分利用创新的开源程序。&lt;/p&gt;
&lt;h2 id=&#34;到期时间httpsendoflifedatecentos-stream&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://endoflife.date/centos-stream&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;到期时间&lt;/a&gt;
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Release&lt;/th&gt;
&lt;th&gt;Released&lt;/th&gt;
&lt;th&gt;Active Support&lt;/th&gt;
&lt;th&gt;Security Support&lt;/th&gt;
&lt;th&gt;Latest&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;3 years ago (15 Sep 2021)&lt;/td&gt;
&lt;td&gt;Ends in 2 years and 6 months (31 May 2027)&lt;/td&gt;
&lt;td&gt;Ends in 2 years and 6 months (31 May 2027)&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;5 years ago (24 Sep 2019)&lt;/td&gt;
&lt;td&gt;Ended 5 months and 3 weeks ago (31 May 2024)&lt;/td&gt;
&lt;td&gt;Ended 5 months and 3 weeks ago (31 May 2024)&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;解决方案&#34;&gt;解决方案
&lt;/h2&gt;&lt;p&gt;懒得折腾升级的问题，选用了&lt;code&gt;ubuntu24.04&lt;/code&gt;长期支持版本。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Hugo Module自定义修改主题：思路讲解</title>
        <link>https://ttf248.life/p/hugo-module-customizing-themes-ideas/</link>
        <pubDate>Fri, 15 Nov 2024 22:01:17 +0800</pubDate>
        
        <guid>https://ttf248.life/p/hugo-module-customizing-themes-ideas/</guid>
        <description>&lt;p&gt;翻看历史提交记录，站点切换过很多次主题，每次切换主题都会有一些自定义的修改，这里记录一下自定义修改主题的思路。笔者的&lt;code&gt;Github&lt;/code&gt;也有个仓库，短暂的维护过even主题，后来由于强迫症，非想要升级&lt;code&gt;hugo&lt;/code&gt;编译器到最新版本，导致even主题不兼容，所以又切换到了&lt;code&gt;stack&lt;/code&gt;主题。&lt;/p&gt;
&lt;h2 id=&#34;hugo的模块化&#34;&gt;Hugo的模块化
&lt;/h2&gt;&lt;p&gt;提到模块化，大家可能会想到的是Nginx模块，IDEA插件等等。 通常是我可以通过上传一些模块，来满足我的差异化需求。 之所以大家都喜欢这种模块，主要是因为足够灵活，不用费太大的劲就可以满足自身的需求。 因为很多时候，虽然大体上差不多，但总有一些细节上的差异。 这也正说明软件的复杂度，除了技术上的复杂度，还有业务上的复杂度。 大多数情况下，我们面对的主要是业务复杂度。 这也正是在软件领域，对”隔行如隔山”这句俗语最好的阐述。 如今，不仅互联网行业，金融行业，就算传统的制造业，都已经使用上了信息化系统，来帮助企业的生产和管理。 同样是请假系统，哪怕在同样的行业，不同的公司，都会有所差异。&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;Hugo&lt;/code&gt;的模块和大家印象中的模块有点不一样，并不是以功能为单位，来满足差异化需求。 而是以目录结构为主，来识别相同的结构。&lt;/p&gt;
&lt;p&gt;资料链接：&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@sunwei.xyz/07-hugo%E6%9E%B6%E6%9E%84-hugo%E7%9A%84%E6%A8%A1%E5%9D%97-8ef5a520a822&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;07. Hugo架构 — Hugo的模块&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[[imports]]
path = &amp;quot;github.com/CaiJimmy/hugo-theme-stack/v3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;git submodule&lt;/code&gt; 方式依旧能用，本文不建议使用，如果引入主题的发生了更新，维护起来会比较麻烦，要单独的 git 仓库管理主题。&lt;/p&gt;
&lt;h2 id=&#34;主题的修改逻辑httpsstackjimmycaicomguidemodify-theme&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://stack.jimmycai.com/guide/modify-theme&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;主题的修改逻辑&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;有了前面模块化的基础概念理解，再来理解自定义主题，就简单那很多了，&lt;code&gt;hugo&lt;/code&gt;现在的主题，也是多个不同的模块组装起来的，我们想要修改其中一个模块，找到对应的模板文件，修改即可。&lt;/p&gt;
&lt;p&gt;摘取自&lt;code&gt;stack&lt;/code&gt;官方文档：&lt;/p&gt;
&lt;p&gt;Using this method, there won&amp;rsquo;t be any file under &lt;code&gt;themes&lt;/code&gt; directory. In order to modify the theme, you will have to copy the file you want to modify to the same directory under &lt;code&gt;layouts&lt;/code&gt; directory.&lt;/p&gt;
&lt;p&gt;For example, in order to modify the &lt;code&gt;themes/hugo-theme-stack/layouts/partials/head/custom.html&lt;/code&gt; file, you will have to copy it to &lt;code&gt;layouts/partials/head/custom.html&lt;/code&gt; and modify it there (copy the code from theme&amp;rsquo;s repository). The same applies to &lt;code&gt;assets&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt; directories。&lt;/p&gt;
&lt;h2 id=&#34;如何找到模板文件&#34;&gt;如何找到模板文件
&lt;/h2&gt;&lt;h3 id=&#34;正统思路&#34;&gt;正统思路
&lt;/h3&gt;&lt;p&gt;翻阅主题的源码文件，理解主题的设计思路，找到对应的模板文件，修改即可。&lt;/p&gt;
&lt;h3 id=&#34;粗暴思路&#34;&gt;粗暴思路
&lt;/h3&gt;&lt;p&gt;笔者并不是很懂前端代码，所以有时候会采用粗暴的方式，比如直接在浏览器中打开对应的页面，找到想要修改的地方，通过&lt;code&gt;审查元素&lt;/code&gt;的方式，定位到&lt;code&gt;css name&lt;/code&gt;，主题源码中搜索，找到对应的文件，复制一份到站点目录，修改即可。&lt;/p&gt;
&lt;h2 id=&#34;小技巧&#34;&gt;小技巧
&lt;/h2&gt;&lt;p&gt;官方默认就提供了一个文件，用于自定义样式，我们需要改造的地方地方，可以通过拆分多个文件，&lt;code&gt;custom.scss&lt;/code&gt; 文件引入我们其他的文件，这样可以更好的管理样式文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/hugo-module-customizing-themes-ideas/image.png&#34;
	width=&#34;141&#34;
	height=&#34;375&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;37&#34;
		data-flex-basis=&#34;90px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;汇总修改内容6h&#34;&gt;汇总修改内容(6h)
&lt;/h2&gt;&lt;p&gt;现在已经是&lt;code&gt;AI&lt;/code&gt;编码的元年，详细的内容，这里就不详细贴出来了，只是简单的列举一下，本站点的一些修改内容，比如调整复制按钮的样式，重新设置代码的块的样式，&lt;code&gt;ChatGPT&lt;/code&gt;都是能轻松搞定的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整体：全局文字样式，沿用以前 &lt;code&gt;even&lt;/code&gt; 融合 &lt;code&gt;info cn&lt;/code&gt; 的显示风格，中文友好&lt;/li&gt;
&lt;li&gt;首页：右侧导航增加鼠标交互动画&lt;/li&gt;
&lt;li&gt;首页：文章新增摘要预览（耗时颇多，用了取巧的办法实现）&lt;/li&gt;
&lt;li&gt;滚动栏：美化了一下滚动栏的样式&lt;/li&gt;
&lt;li&gt;代码块：引入了 &lt;code&gt;highlight.js&lt;/code&gt; 代码高亮插件，美化代码块样式&lt;/li&gt;
&lt;li&gt;文章详情：部分内容属于转载，新增原作者信息展示，原链接展示&lt;/li&gt;
&lt;li&gt;归档页面：顶部的分类图片，移除主题自带的颜色蒙版，显示原图&lt;/li&gt;
&lt;li&gt;归档页面：新增了按照年份的分类的统计展示面板&lt;/li&gt;
&lt;li&gt;归档页面：两栏显示布局&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;stack&lt;/code&gt; 主题的组件复用率很高，也导致首页文章新增摘要预览耗时颇多，改了对应的组件，文章的详情页面也随之发生了变动，导致正文重复展示内容，&lt;code&gt;golang 模板&lt;/code&gt;的语法也不是很熟悉，所以花费了不少时间，组件之间的参数传递一直没搞定，最后通过取巧的办法，主页单独引入&lt;code&gt;JavaScript&lt;/code&gt;脚本，通过自定义特殊变量，来实现摘要预览。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有时候代码复用率太高也是个问题，会导致修改一个地方，其他地方也会受到影响，所以在修改主题的时候，一定要注意，不要破坏原有的逻辑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;评论区&#34;&gt;评论区
&lt;/h3&gt;&lt;p&gt;这哥们的修改更加完善：&lt;a class=&#34;link&#34; href=&#34;https://blog.reincarnatey.net/2024/0719-better-waline/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.reincarnatey.net/2024/0719-better-waline/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;本站点简单的启用了 &lt;code&gt;Waline&lt;/code&gt; 评论系统，&lt;code&gt;stack&lt;/code&gt; 主题默认支持 &lt;code&gt;Waline&lt;/code&gt;，只需要在 &lt;code&gt;config.toml&lt;/code&gt; 中配置即可。&lt;/del&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;推荐首页邮箱联系、本站点不开放评论区&lt;/p&gt;
&lt;/blockquote&gt;</description>
        </item>
        <item>
        <title>linux后端服务处理大量字符串数据-效率很慢</title>
        <link>https://ttf248.life/p/linux-backend-slow-string-processing/</link>
        <pubDate>Wed, 13 Nov 2024 19:42:59 +0800</pubDate>
        
        <guid>https://ttf248.life/p/linux-backend-slow-string-processing/</guid>
        <description>&lt;p&gt;在C++开发的历史项目中，我们使用自定义协议进行通信，协议采用了二维数组的模式。在处理大量数据时，协议内部需要遍历数组并进行序列化操作以生成日志，由于效率较低，导致了系统在高负载下出现明显的卡顿，业务部门反馈系统卡顿。&lt;/p&gt;
&lt;h2 id=&#34;问题定位&#34;&gt;问题定位
&lt;/h2&gt;&lt;p&gt;在排查问题时，我们首先对系统进行了性能分析，发现系统在处理大量数据时，CPU 占用率明显增加，且系统响应时间变长。通过分析系统的日志，我们发现了大量的序列化操作，这些操作在处理二维数组时效率较低，导致了系统性能下降。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pstack&lt;/code&gt;工具截取服务的线程信息，定位到日志线程大部分时间都在处理字符串的拼接。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里是今天的重点，不同的累加方式，效率差别巨大。历史代码中使用的是 &lt;code&gt;+&lt;/code&gt; 运算符，这种方式会频繁的创建临时对象，效率很低。你知道它效率很差，但你不知道它效率有多差的那种。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;demo-验证&#34;&gt;demo 验证
&lt;/h2&gt;&lt;p&gt;基于项目代码，我们抽离业务逻辑，编写了一个简单的 demo，用于验证字符串拼接的效率问题。&lt;code&gt;windows&lt;/code&gt; 下的 &lt;code&gt;vs2022&lt;/code&gt; 编译器，&lt;code&gt;linux&lt;/code&gt; 下的 &lt;code&gt;gcc8.5&lt;/code&gt; 编译器，&lt;code&gt;Release&lt;/code&gt;模式下编译运行，对比效率。&lt;/p&gt;
&lt;h3 id=&#34;关键点说明&#34;&gt;关键点说明
&lt;/h3&gt;&lt;p&gt;项目使用的是方法四，在尚未拿到测试数据的时候，读者可以先思考一下，哪种方式效率最高？哪种方式效率最低？看到结果的时候，我还是很惊讶的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;方法 1 (&lt;code&gt;+=&lt;/code&gt; 拼接)&lt;/strong&gt;：直接通过 &lt;code&gt;+=&lt;/code&gt; 将每个字段拼接到字符串中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法 2 (&lt;code&gt;std::ostringstream&lt;/code&gt; 拼接)&lt;/strong&gt;：使用流（&lt;code&gt;std::ostringstream&lt;/code&gt;）来拼接每个字段，这种方法更高效，特别是对于大量数据拼接时。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法 3（预分配内存的 &lt;code&gt;+=&lt;/code&gt; 拼接）&lt;/strong&gt;：通过 &lt;code&gt;reserve&lt;/code&gt; 提前为字符串分配足够的内存，减少了内存重新分配的开销，从而提升了性能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法 4 (&lt;code&gt;bodys = bodys + body + &amp;quot;\n&amp;quot;&lt;/code&gt;)&lt;/strong&gt;：每次拼接都创建一个新的临时字符串对象，这会导致性能下降，尤其是在大规模拼接时，因为每次拼接都会涉及一次新的内存分配和复制。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考结果，我们可以看到，项目刚好选中了效率最差的方式。&lt;/p&gt;
&lt;p&gt;再进一步，我们来分析不同平台编译器的优化效率，微软的 &lt;code&gt;visual studio&lt;/code&gt; 一如既往的优秀，针对字符串的优化效率很高，而 &lt;code&gt;gcc&lt;/code&gt; 编译器在这方面的优化效率就差了一些。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代码在不同的机器执行，两份数据没有直接的对比意义，可以分别对比不同拼接方法之间的差值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;windows 平台下的 vs2022 编译器

----------------------------------------
Data Generation Time: 0.054 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.053 seconds.
+ ostringstream Data merging took: 0.054 seconds.
+ Pre-reserved Data merging took: 0.045 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 16.108 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;linux 平台下的 gcc8.5 编译器
----------------------------------------
Data Generation Time: 0.108 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.100 seconds.
+ ostringstream Data merging took: 0.083 seconds.
+ Pre-reserved Data merging took: 0.057 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 29.298 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完整代码&#34;&gt;完整代码
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;random&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;iomanip&amp;gt;

typedef std::vector&amp;lt;std::string&amp;gt; DataRow;
typedef std::vector&amp;lt;DataRow&amp;gt; DataGroup;

struct ResponsePackage
{
    std::string ErrorInfo;
    DataRow Head;
    std::string ClientId;
    std::string UUID;
    std::string MsgID;
    std::string SessionID;
    std::string ExtraInfo1;
    std::string ExtraInfo2;
    DataGroup DataBody;
};

// Generate specified length of random string
std::string generateRandomString(size_t length)
{
    const char charset[] = &amp;quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&amp;quot;;
    const size_t max_index = sizeof(charset) - 1;
    std::string random_string;
    random_string.reserve(length);

    std::random_device rd;
    std::mt19937 generator(rd());
    std::uniform_int_distribution&amp;lt;&amp;gt; distribution(0, max_index);

    for (size_t i = 0; i &amp;lt; length; ++i)
    {
        random_string += charset[distribution(generator)];
    }

    return random_string;
}

void create_large_string()
{
    // Example request package with 50 fields
    ResponsePackage requestPackage;

    requestPackage.Head = {
        &amp;quot;Field1&amp;quot;, &amp;quot;Field2&amp;quot;, &amp;quot;Field3&amp;quot;, &amp;quot;Field4&amp;quot;, &amp;quot;Field5&amp;quot;,
        &amp;quot;Field6&amp;quot;, &amp;quot;Field7&amp;quot;, &amp;quot;Field8&amp;quot;, &amp;quot;Field9&amp;quot;, &amp;quot;Field10&amp;quot;,
        &amp;quot;Field11&amp;quot;, &amp;quot;Field12&amp;quot;, &amp;quot;Field13&amp;quot;, &amp;quot;Field14&amp;quot;, &amp;quot;Field15&amp;quot;,
        &amp;quot;Field16&amp;quot;, &amp;quot;Field17&amp;quot;, &amp;quot;Field18&amp;quot;, &amp;quot;Field19&amp;quot;, &amp;quot;Field20&amp;quot;,
        &amp;quot;Field21&amp;quot;, &amp;quot;Field22&amp;quot;, &amp;quot;Field23&amp;quot;, &amp;quot;Field24&amp;quot;, &amp;quot;Field25&amp;quot;,
        &amp;quot;Field26&amp;quot;, &amp;quot;Field27&amp;quot;, &amp;quot;Field28&amp;quot;, &amp;quot;Field29&amp;quot;, &amp;quot;Field30&amp;quot;,
        &amp;quot;Field31&amp;quot;, &amp;quot;Field32&amp;quot;, &amp;quot;Field33&amp;quot;, &amp;quot;Field34&amp;quot;, &amp;quot;Field35&amp;quot;,
        &amp;quot;Field36&amp;quot;, &amp;quot;Field37&amp;quot;, &amp;quot;Field38&amp;quot;, &amp;quot;Field39&amp;quot;, &amp;quot;Field40&amp;quot;,
        &amp;quot;Field41&amp;quot;, &amp;quot;Field42&amp;quot;, &amp;quot;Field43&amp;quot;, &amp;quot;Field44&amp;quot;, &amp;quot;Field45&amp;quot;,
        &amp;quot;Field46&amp;quot;, &amp;quot;Field47&amp;quot;, &amp;quot;Field48&amp;quot;, &amp;quot;Field49&amp;quot;, &amp;quot;Field50&amp;quot;
    };

    requestPackage.ClientId = &amp;quot;ClientID&amp;quot;;
    requestPackage.UUID = &amp;quot;UUID&amp;quot;;
    requestPackage.MsgID = &amp;quot;MsgID&amp;quot;;
    requestPackage.SessionID = &amp;quot;SessionID&amp;quot;;
    requestPackage.ExtraInfo1 = &amp;quot;ExtraInfo1&amp;quot;;
    requestPackage.ExtraInfo2 = &amp;quot;ExtraInfo2&amp;quot;;

    // Start timing for data generation
    auto start_gen = std::chrono::high_resolution_clock::now();

    // Generate 10,000 rows of data, each with 50 fields
    for (size_t i = 0; i &amp;lt; 10000; ++i)
    {
        DataRow dataRow(50, &amp;quot;This is a test string&amp;quot;);
        requestPackage.DataBody.push_back(dataRow);
    }

    // End timing for data generation
    auto end_gen = std::chrono::high_resolution_clock::now();
    std::chrono::duration&amp;lt;double&amp;gt; duration_gen = end_gen - start_gen;

    // Display result generation time
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Generation Time: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_gen.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    // Data merging using different methods
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Performance:\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    {
        // Method 1: Using &#39;+=&#39; string concatenation
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (+=) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 2: Using ostringstream
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::ostringstream bodys;
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::ostringstream body;
            body &amp;lt;&amp;lt; &amp;quot;This is a test string&amp;quot;;
            for (auto&amp;amp; item : vec)
            {
                body &amp;lt;&amp;lt; item &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            }
            bodys &amp;lt;&amp;lt; body.str() &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ ostringstream Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 3: Pre-allocated memory
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys;
        bodys.reserve(1000 * 50 * 20); // Pre-allocate enough memory
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            body.reserve(50 * 20); // Pre-allocate memory for each row
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Pre-reserved Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 4: Using &#39;bodys = bodys + body + &amp;quot;\n&amp;quot;&#39;
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body = body + item + &amp;quot; &amp;quot;; // Note the use of &#39;body = body + item&#39;
            }
            bodys = bodys + body + &amp;quot;\n&amp;quot;; // Again, using &#39;bodys = bodys + body&#39;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (bodys = bodys + body + \&amp;quot;\\n\&amp;quot;) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Complete.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;
}

int main()
{
    try
    {
        create_large_string();
    }
    catch (const std::exception&amp;amp; e)
    {
        std::cerr &amp;lt;&amp;lt; &amp;quot;Caught exception: &amp;quot; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\nProgram finished.\n&amp;quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43;中lambd表达式参数生命周期</title>
        <link>https://ttf248.life/p/cpp-lambda-parameter-lifetime/</link>
        <pubDate>Wed, 13 Nov 2024 19:23:02 +0800</pubDate>
        
        <guid>https://ttf248.life/p/cpp-lambda-parameter-lifetime/</guid>
        <description>&lt;p&gt;在C++中，lambda表达式是一种方便的匿名函数，可以捕获外部变量并在其体内使用。这使得lambda成为一种灵活的编程工具。不过，lambda表达式的参数生命周期是一个需要特别关注的方面，尤其是在捕获和传递参数时&lt;/p&gt;
&lt;h3 id=&#34;1-lambda表达式的参数生命周期&#34;&gt;1. Lambda表达式的参数生命周期
&lt;/h3&gt;&lt;p&gt;Lambda表达式的参数生命周期通常与其他C++函数一样。函数的参数在函数调用时存在，函数调用结束时，参数生命周期结束。然而，由于lambda表达式可能会捕获外部变量，因此参数的生命周期也受到捕获方式的影响。&lt;/p&gt;
&lt;h3 id=&#34;2-捕获与参数生命周期的关系&#34;&gt;2. 捕获与参数生命周期的关系
&lt;/h3&gt;&lt;h4 id=&#34;21-捕获外部变量&#34;&gt;2.1 捕获外部变量
&lt;/h4&gt;&lt;p&gt;C++的lambda表达式允许通过两种方式捕获外部变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;按值捕获&lt;/strong&gt;：通过值捕获，外部变量的值被复制到lambda内部，lambda内的副本生命周期由lambda的生命周期控制。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按引用捕获&lt;/strong&gt;：通过引用捕获，外部变量的引用会保留，lambda内的引用指向原始外部变量，生命周期取决于外部变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda_by_value = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };  // 捕获x的副本
auto lambda_by_reference = [&amp;amp;x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };  // 捕获x的引用

lambda_by_value();  // 打印10
lambda_by_reference();  // 打印10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于捕获的变量，生命周期如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;按值捕获&lt;/strong&gt;：捕获时外部变量的值被复制到lambda，lambda生命周期结束时，复制的副本被销毁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按引用捕获&lt;/strong&gt;：lambda持有外部变量的引用，&lt;strong&gt;外部变量必须在lambda使用之前有效，否则会导致未定义行为&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;22-lambda参数&#34;&gt;2.2 Lambda参数
&lt;/h4&gt;&lt;p&gt;Lambda的参数与常规函数参数类似，它们的生命周期仅限于lambda函数体内。也就是说，lambda参数会在lambda调用时被创建，并且在lambda调用结束后，参数的生命周期也结束。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto lambda = [](int a, int b) {
    std::cout &amp;lt;&amp;lt; a + b &amp;lt;&amp;lt; std::endl;
};
lambda(5, 10);  // a和b在这里是lambda的参数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个例子中，&lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 是lambda表达式的参数，它们在lambda调用时创建，并在lambda执行结束后销毁。&lt;/p&gt;
&lt;h3 id=&#34;3-捕获外部变量时的生命周期问题&#34;&gt;3. 捕获外部变量时的生命周期问题
&lt;/h3&gt;&lt;h4 id=&#34;31-捕获的变量是否能在lambda外部有效&#34;&gt;3.1 捕获的变量是否能在lambda外部有效
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;按值捕获&lt;/strong&gt;：即使外部变量在lambda调用后销毁，lambda内部依然持有外部变量的副本。因此，lambda内部的副本可以安全使用，即使外部变量已经不再存在。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x 在lambda调用后修改
lambda();  // 打印10，捕获的是x的副本
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;按引用捕获&lt;/strong&gt;：如果捕获的是外部变量的引用，lambda内部对该引用的访问依赖于外部变量的生命周期。如果外部变量在lambda执行之前就销毁了，那么会出现悬空引用的问题，导致未定义行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [&amp;amp;x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x 在lambda调用前修改
lambda();  // 打印20，捕获的是x的引用
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;如果lambda的执行顺序不确定，确保捕获的外部变量在lambda执行时仍然有效非常重要。&lt;/p&gt;
&lt;/blockquote&gt;</description>
        </item>
        <item>
        <title>Win11 Logitech G431 耳机驱动安装</title>
        <link>https://ttf248.life/p/win11-logitech-g431-headphone-driver-installation/</link>
        <pubDate>Wed, 05 Jun 2024 07:20:17 +0800</pubDate>
        
        <guid>https://ttf248.life/p/win11-logitech-g431-headphone-driver-installation/</guid>
        <description>&lt;p&gt;书接上回，回来发现 Ghub 有更新，有点小开心，客服说的问题驱动无法正常加载的问题能搞定了，结果折腾一圈，重装卸载，还是不能正常使用。&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景
&lt;/h2&gt;&lt;p&gt;继续联系客服咨询处理处理方案，结果被告知，能有工程师远程协助，但是工程师的上班时间和我自己的上班时间一模一样，无奈下只能放弃，翻看上次排查问题留下的资料，准备尝试手动安装驱动。&lt;/p&gt;
&lt;h2 id=&#34;获取驱动安装包&#34;&gt;获取驱动安装包
&lt;/h2&gt;&lt;p&gt;罗技官方并没有单独提供设备的驱动安装包，我如何才能拿到驱动文件呢？&lt;/p&gt;
&lt;p&gt;配合上次重装系统留下的系统镜像安装包，我们可以在本地虚拟机中重装一次系统，再纯净的系统中，我们单独部署一份Ghub，将耳机设备介入到虚拟机中，找到驱动的路径，拷贝出来即可。&lt;/p&gt;
&lt;p&gt;相关的路径：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C:\ProgramData\LGHUB&lt;/li&gt;
&lt;li&gt;C:\Windows\System32\DriverStore\FileRepository\logi_audio.inf_amd64_010b035044e24be4&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;设备管理器&#34;&gt;设备管理器
&lt;/h2&gt;&lt;p&gt;重点是第二个路径怎么找到的，我们先简单梳理一波 Win11 系统如何手动管理驱动文件。这块内容，&lt;strong&gt;通过控制变量法来识别的，通过不断的插拔设备，在虚拟机里面分析设备管理器中的设备信息，识别到耳机合计有三个驱动需要处理&lt;/strong&gt;。其中有两个驱动是系统自带的，只有一个是罗技提供的。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/win11-logitech-g431-headphone-driver-installation/20240605073331.png&#34;
	width=&#34;433&#34;
	height=&#34;904&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;驱动管理器&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;47&#34;
		data-flex-basis=&#34;114px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;上图中的第二个驱动，是由罗技提供的，我们分析设备现在的驱动程序，再虚拟机里面翻找所有的驱动路径，当然你首先需要找到 logi 开头的文件，然后进行文件的对比，你就能定位到驱动的文件件，拷贝整个文件夹，你就拿到了驱动安装包&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/win11-logitech-g431-headphone-driver-installation/20240605073933.png&#34;
	width=&#34;946&#34;
	height=&#34;645&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;驱动安装包&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;146&#34;
		data-flex-basis=&#34;352px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;安装驱动&#34;&gt;安装驱动
&lt;/h2&gt;&lt;p&gt;还在在设备管理器的界面，点击：更新驱动，点击：浏览我的电脑查找驱动，进入到如下界面：&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/win11-logitech-g431-headphone-driver-installation/20240605074130.png&#34;
	width=&#34;528&#34;
	height=&#34;381&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;驱动安装&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;138&#34;
		data-flex-basis=&#34;332px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;当然你打开的时候，只能看到一个驱动，那就是普通的USB驱动，选择从磁盘安装，路径就是我们前面拷贝出来的文件夹，安装以后，选择的下拉清单中，就能多出来罗技特有的驱动，将设备驱动切换到新安装的驱动即可。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/win11-logitech-g431-headphone-driver-installation/20240605074208.png&#34;
	width=&#34;593&#34;
	height=&#34;423&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;磁盘安装&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;140&#34;
		data-flex-basis=&#34;336px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;人体学设备驱动&#34;&gt;人体学设备驱动
&lt;/h2&gt;&lt;p&gt;这块的驱动文件都是系统提供的，你只需要检查设备的驱动前面是否存在感叹号，如果存在感叹号，进入驱动选择界面，随意切换一个其他类型的驱动，然后再改回来即可恢复正常&lt;/p&gt;
&lt;h2 id=&#34;完工&#34;&gt;完工
&lt;/h2&gt;&lt;p&gt;耳机麦克风的音量恢复正常，熟悉的耳返功能也回来了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/win11-logitech-g431-headphone-driver-installation/20240605074823.png&#34;
	width=&#34;485&#34;
	height=&#34;739&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;侧音&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;65&#34;
		data-flex-basis=&#34;157px&#34;
	
&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>罗技耳机驱动安装失败</title>
        <link>https://ttf248.life/p/logitech-headphone-driver-installation-failure/</link>
        <pubDate>Fri, 31 May 2024 21:46:12 +0800</pubDate>
        
        <guid>https://ttf248.life/p/logitech-headphone-driver-installation-failure/</guid>
        <description>&lt;p&gt;如果完全不懂这些东西，第一时间联系官方的客服也就不会折腾好几个小时。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/logitech-headphone-driver-installation-failure/20240531220709.png&#34;
	width=&#34;693&#34;
	height=&#34;489&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;GHUB&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;141&#34;
		data-flex-basis=&#34;340px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;最近，我家里用于开发的台式电脑C盘空间不够用了，特意拿出了一块256GB的半退役固态硬盘单独给C盘使用，奈何经常瞎折腾。自从搬到上海后一直忙于各种事务，终于在上周抽空重装了系统。&lt;/p&gt;
&lt;p&gt;重装系统过程很顺利，日常软件的安装和开发环境的部署也都没有出现问题。几天后，我打算放松一下，玩几局游戏，这时才想起鼠标和耳机的驱动还没有安装。这两个设备都是罗技的，所以我下载了GHUB软件，它可以自动识别硬件并安装驱动。&lt;/p&gt;
&lt;p&gt;然而，意外发生了。鼠标的驱动安装顺利，但耳机的驱动一直显示“加载中”。我怀疑可能是最新版的Windows 11系统与罗技的驱动不兼容，导致安装失败。于是，我开始查找资料，尝试手动安装驱动，但问题依旧没有解决。&lt;/p&gt;
&lt;p&gt;简单科普一下，这两个设备的驱动分别起什么作用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;鼠标的驱动主要用于调节鼠标的移动速度等功能。宏功能我很少用，只需恢复以前记得的参数即可。&lt;/li&gt;
&lt;li&gt;耳机的驱动则主要用于耳返功能，这在团队语音时非常有用，可以让我听到自己讲话的声音。虽然系统的麦克风设置里有类似的侦听功能，但效果不如驱动实现得好。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽管我反复尝试，耳机的驱动始终无法正常加载。今天，我终于想到可以找客服问问情况，看看是否有解决方案。客服告诉我，最近他们的服务器出了问题，导致驱动下载异常。他们正在处理这个问题，让我不要着急，等下次更新后问题就能解决了。&lt;/p&gt;
&lt;p&gt;虽然还没能解决耳机驱动的问题，但至少知道了原因，希望问题能尽快得到解决。&lt;/p&gt;
&lt;h2 id=&#34;鼠标驱动设置&#34;&gt;鼠标驱动设置
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/logitech-headphone-driver-installation-failure/20240531220930.png&#34;
	width=&#34;1024&#34;
	height=&#34;768&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;G502&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;133&#34;
		data-flex-basis=&#34;320px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/logitech-headphone-driver-installation-failure/20240531220903.png&#34;
	width=&#34;1024&#34;
	height=&#34;768&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;G502&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;133&#34;
		data-flex-basis=&#34;320px&#34;
	
&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>Python 字典存储自定义对象：引用与深拷贝的重要性</title>
        <link>https://ttf248.life/p/python-dictionary-custom-objects-reference-vs-deepcopy/</link>
        <pubDate>Fri, 22 Mar 2024 01:08:05 +0800</pubDate>
        
        <guid>https://ttf248.life/p/python-dictionary-custom-objects-reference-vs-deepcopy/</guid>
        <description>&lt;p&gt;在 Python 编程中，字典是一种非常强大的数据结构，它允许我们将键值对关联起来，并以高效的方式查找和操作这些数据。当我们尝试在字典中存储自定义对象时，通常会遇到一个关键概念：Python 中的对象赋值实际上是引用赋值，而非对象本身的深拷贝。这意味着将自定义对象放入字典时，字典中存储的是对该对象的引用，而非对象的一个全新副本。&lt;/p&gt;
&lt;h2 id=&#34;存储自定义对象的基本示例&#34;&gt;存储自定义对象的基本示例
&lt;/h2&gt;&lt;p&gt;假设我们有一个简单的 &lt;code&gt;Person&lt;/code&gt; 类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

# 创建一个 Person 对象
p1 = Person(&amp;quot;Alice&amp;quot;, 30)

# 将对象存储到字典中
people_dict = {}
people_dict[&amp;quot;alice&amp;quot;] = p1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个例子中，&lt;code&gt;people_dict&lt;/code&gt; 字典现在包含一个键为 &lt;code&gt;&amp;quot;alice&amp;quot;&lt;/code&gt; 的项，其值是对 &lt;code&gt;Person&lt;/code&gt; 类型的 &lt;code&gt;p1&lt;/code&gt; 对象的引用。如果我们修改 &lt;code&gt;p1&lt;/code&gt; 的属性：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;p1.age = 31
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么通过字典访问这个对象时，我们会发现其年龄也被更新了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(people_dict[&amp;quot;alice&amp;quot;].age)  # 输出：31
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是因为字典中存储的并不是 &lt;code&gt;Person&lt;/code&gt; 对象的独立副本，而是指向同一内存地址的引用。&lt;/p&gt;
&lt;h2 id=&#34;深拷贝与浅拷贝的区别&#34;&gt;深拷贝与浅拷贝的区别
&lt;/h2&gt;&lt;p&gt;在涉及嵌套数据结构或自定义对象时，这种引用行为可能会导致意外的结果。例如，如果自定义对象中包含可变类型的属性（如列表或另一个自定义对象），直接将这样的对象存入字典并对其进行修改，会影响到通过字典获取的对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Address:
    def __init__(self, street, city):
        self.street = street
        self.city = city

class Person:
    def __init__(self, name, age, address):
        self.name = name
        self.age = age
        self.address = address

address = Address(&amp;quot;Main St.&amp;quot;, &amp;quot;Springfield&amp;quot;)
p1 = Person(&amp;quot;Bob&amp;quot;, 40, address)
people_dict[&amp;quot;bob&amp;quot;] = p1

# 修改原始地址对象
address.city = &amp;quot;Shelbyville&amp;quot;

# 字典中的人的地址也变了
print(people_dict[&amp;quot;bob&amp;quot;].address.city)  # 输出：Shelbyville
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解决办法：深拷贝&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了避免这种共享状态带来的问题，有时我们需要确保字典存储的是对象的一个完整副本，而不是引用。Python 提供了 &lt;code&gt;copy&lt;/code&gt; 模块中的 &lt;code&gt;deepcopy&lt;/code&gt; 函数来实现这一目标：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import copy

# 使用深拷贝存储对象
people_dict[&amp;quot;bob_deepcopy&amp;quot;] = copy.deepcopy(p1)

# 此时即使修改原始地址对象，深拷贝的对象不会受影响
address.city = &amp;quot;Capital City&amp;quot;
print(people_dict[&amp;quot;bob&amp;quot;].address.city)  # 输出：Capital City
print(people_dict[&amp;quot;bob_deepcopy&amp;quot;].address.city)  # 输出：Shelbyville
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总之，在 Python 中利用字典存储自定义对象时，务必注意默认情况下存储的是对象引用。对于那些需要保持独立状态的情况，请使用 &lt;code&gt;deepcopy&lt;/code&gt; 进行深拷贝，以避免因共享引用而导致的意料之外的数据变化。&lt;/p&gt;</description>
        </item>
        <item>
        <title>新安装的千兆入户光纤，为何测速仅达百兆？</title>
        <link>https://ttf248.life/p/gigabit-fiber-slow-speed/</link>
        <pubDate>Mon, 18 Mar 2024 00:29:02 +0800</pubDate>
        
        <guid>https://ttf248.life/p/gigabit-fiber-slow-speed/</guid>
        <description>&lt;p&gt;想要家里的网络快如闪电？关键在于了解网线的选择、光猫和路由器的配置，还有那些不起眼的小细节。这篇博客将带你轻松了解如何用六类网线打造千兆网络，以及如何通过简单的设备检查和配置，确保你的网络速度不受束缚。让我们一起探索，让家里的网速飞起来！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/gigabit-fiber-slow-speed/image.png&#34;
	width=&#34;1001&#34;
	height=&#34;590&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;手动修复&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;169&#34;
		data-flex-basis=&#34;407px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;第一章深入剖析网络传输介质&#34;&gt;第一章：深入剖析网络传输介质
&lt;/h2&gt;&lt;p&gt;当我们谈论实现千兆网络接入时，承载信息高速传输的载体——网线起着至关重要的作用。下面将对五类、六类和七类网线进行详细的解读：&lt;/p&gt;
&lt;h3 id=&#34;1-五类网线cat5&#34;&gt;1. &lt;strong&gt;五类网线（CAT5）&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;五类网线，也称为CAT5，是较早普及的一种双绞线类型，每对线芯通过精密的螺旋结构设计来减少串扰。它主要适用于10/100Mbps的快速以太网，最大传输频率约100MHz，虽然在过去曾广泛应用，但对于当前追求千兆乃至更高速度的需求而言，五类网线由于物理限制无法满足要求。&lt;/p&gt;
&lt;h3 id=&#34;2-六类网线cat6&#34;&gt;2. &lt;strong&gt;六类网线（CAT6）&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;随着技术发展，六类网线应运而生。相比五类网线，六类线材采用了更严格的制造标准和更先进的结构设计，显著提高了抗干扰能力和传输效率，可支持高达1Gbps的传输速率，并且在理想条件下，传输距离可以达到100米，这恰好符合千兆网络的接入需求。&lt;/p&gt;
&lt;h3 id=&#34;3-七类网线cat7&#34;&gt;3. &lt;strong&gt;七类网线（CAT7）&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;七类网线则代表着当前双绞线技术的尖端水准。它不仅在传输速率上有飞跃式提升，理论上可支持最高10Gbps的超高速率，而且在设计上加入了完整的屏蔽系统，包括每个线对之间的屏蔽以及整体外层的屏蔽，从而极大地降低了外部电磁干扰和近端串扰，保障了数据传输的稳定性与准确性。不过，七类网线主要用于未来的万兆以太网或者特定的高要求场景。&lt;/p&gt;
&lt;p&gt;在搭建千兆家庭网络环境中，为了充分释放千兆光纤的潜力，选用六类网线是最为经济且高效的选择。同时，确保所有连接线材的质量合格，并严格按照标准接线方式操作，也是确保网络性能的重要环节。&lt;/p&gt;
&lt;h2 id=&#34;第二章深挖网络中枢设备光猫路由器lan口带宽的影响&#34;&gt;第二章：深挖网络中枢设备——光猫、路由器LAN口带宽的影响
&lt;/h2&gt;&lt;h3 id=&#34;光猫及其lan口带宽的重要性&#34;&gt;光猫及其LAN口带宽的重要性
&lt;/h3&gt;&lt;p&gt;光猫，全称光纤调制解调器，是家庭宽带接入的核心设备，它的功能在于将光纤中的光信号转化为数字信号，供家庭网络设备使用。对于千兆光纤用户来说，光猫是否支持千兆传输显得尤为重要。如果光猫的WAN口只支持百兆，那么即使入户光纤速率再高，也会因为这个瓶颈而被限制在百兆以内。同样地，光猫的LAN口也需要具备千兆输出能力，否则连接在其上的路由器或其他设备，无法获取到真正的千兆速率。&lt;/p&gt;
&lt;h3 id=&#34;路由器lan口带宽的作用&#34;&gt;路由器LAN口带宽的作用
&lt;/h3&gt;&lt;p&gt;路由器的LAN口负责将接收到的数据分发到各个终端设备。当路由器的LAN口仅为百兆时，即便其他设备配置再好，也只能实现百兆速率的局域网通信。因此，在构建千兆家庭网络时，确保路由器的WAN口能够接收千兆数据，并且LAN口也能提供千兆级别的数据输出能力，这样才能使家中所有的智能设备享受到高速网络带来的流畅体验。&lt;/p&gt;
&lt;p&gt;此外，需要注意的是，部分老旧或低端路由器可能存在LAN口速率自动协商机制，这意味着即使路由器本身支持千兆，也可能因线路、设备兼容性等原因降级为百兆模式。因此，正确配置路由器参数，启用强制千兆模式，并配合千兆交换机或直连设备，是实现全千兆网络的关键步骤之一。&lt;/p&gt;
&lt;p&gt;在升级为千兆光纤后，务必检查并更换为千兆光猫和千兆路由器，确保所有设备接口均达到千兆级别。&lt;/p&gt;
&lt;h2 id=&#34;第三章潜藏之谜一根断裂的子线如何影响千兆网络速度&#34;&gt;第三章：潜藏之谜——一根断裂的子线如何影响千兆网络速度
&lt;/h2&gt;&lt;h3 id=&#34;子线故障与网络性能下降&#34;&gt;子线故障与网络性能下降
&lt;/h3&gt;&lt;p&gt;在测速期间网络始终保持连接，没有出现明显的断网状况。由于是新入户部署的宽带，弱电箱里面很杂乱，时不时还在调整光猫的走线，电源接口插排的位置，偶发性出现过测速达到千兆。&lt;/p&gt;
&lt;p&gt;依据前面的资料，我们已经分析排查了网线型号、光猫 lan 口速度，最终发现罪魁祸首竟是网线内部的一根棕色子线断裂。&lt;/p&gt;
&lt;p&gt;断裂的原因：师傅来安装水晶头的时候，这根网线用力稍微猛了一点，导致一根子线断了一半，没有彻底断开，后续重新调整光猫位置的时候，不断的移动位置，导致彻底断裂。&lt;/p&gt;
&lt;h3 id=&#34;六类网线八根线的功能解析&#34;&gt;六类网线八根线的功能解析
&lt;/h3&gt;&lt;p&gt;六类网线遵循TIA/EIA-568-B标准，包含八根双绞线，颜色编码如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;白橙 / 橙&lt;/li&gt;
&lt;li&gt;白绿 / 绿&lt;/li&gt;
&lt;li&gt;白蓝 / 蓝&lt;/li&gt;
&lt;li&gt;白棕 / 棕&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在千兆以太网（1000BASE-T）的标准下，这八根线中有四对线同时工作，具体分工如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;白橙与橙这对线（1&amp;amp;2），用于发送数据（Tx+/-）；&lt;/li&gt;
&lt;li&gt;白绿与绿这对线（3&amp;amp;6），用于接收数据（Rx+/-）；&lt;/li&gt;
&lt;li&gt;白蓝与蓝这对线（4&amp;amp;5）以及白棕与棕这对线（7&amp;amp;8），在千兆以太网中原本并非主用，但在某些高级应用（例如，部分PoE供电或未来的技术扩展）中可能会启用。而在传统的百兆网络中，确实只需要使用1、2、3、6这四根线即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;断裂子线对网络速度的影响&#34;&gt;断裂子线对网络速度的影响
&lt;/h3&gt;&lt;p&gt;在上述情况下，倘若一根褐色的子线（即棕线或棕白线）断裂，理论上在千兆网络环境下确实会造成速度下降，因为千兆网络需要所有四对线同时进行双向传输以实现满速。但是，由于家庭网络设备往往存在自动协商功能，当检测到线缆出现问题时，会退回到能够正常工作的较低速率模式，也就是百兆模式，这就解释了为何即使有一根子线断裂，网络还能保持连接并工作在百兆速度上。&lt;/p&gt;
&lt;p&gt;简言之，尽管一根棕色子线断裂不影响百兆网络的基本运行，但在千兆网络环境下，它却足以成为限制网络速度的关键因素。直至进行深入诊断和修复，才能真正发挥千兆光纤的全部潜能。这也提醒我们在遇到类似情况时，不应忽视任何潜在的网络基础设施问题，即使是看似不影响基本连接的小故障，也可能成为高速网络体验的隐形障碍。&lt;/p&gt;</description>
        </item>
        <item>
        <title>WPF中的UI线程与卡顿问题及其解决方案</title>
        <link>https://ttf248.life/p/wpf-ui-thread-and-freezing-solutions/</link>
        <pubDate>Tue, 12 Mar 2024 07:12:21 +0800</pubDate>
        
        <guid>https://ttf248.life/p/wpf-ui-thread-and-freezing-solutions/</guid>
        <description>&lt;p&gt;在开发桌面应用程序时，特别是在使用Windows Presentation Foundation (WPF)框架构建富客户端应用时，正确处理用户界面（UI）线程对于保证应用的流畅性和响应性至关重要。UI线程，又称为主线程，是负责处理窗口和控件事件、布局计算以及绘制界面的核心线程。任何与UI元素交互的操作都应当在UI线程上执行，这是WPF以及其他大多数GUI框架遵循的基本原则。&lt;/p&gt;
&lt;h2 id=&#34;什么是ui线程&#34;&gt;什么是UI线程？
&lt;/h2&gt;&lt;p&gt;UI线程在WPF应用启动时由操作系统创建，并初始化应用程序主窗口。它是应用程序中唯一能够直接访问和修改UI组件的状态的线程。这意味着诸如按钮点击、文本框输入、窗口尺寸变化等所有用户交互产生的事件都在这个线程上下文中处理。同时，WPF的依赖属性系统、数据绑定机制以及布局逻辑也都在UI线程上同步执行。&lt;/p&gt;
&lt;h2 id=&#34;卡顿现象及其原因&#34;&gt;卡顿现象及其原因
&lt;/h2&gt;&lt;p&gt;当UI线程被长时间占用或阻塞时，例如执行耗时的计算、大量数据加载、数据库查询或其他I/O密集型任务时，会导致UI线程无法及时响应用户的交互请求，进而表现为界面无响应（Freeze），也就是我们常说的“卡顿”。这种情况下，用户会明显感觉到应用的延迟和不流畅，严重时甚至会出现“Application Not Responding”（ANR）警告。&lt;/p&gt;
&lt;h2 id=&#34;ui线程的两条基本规则&#34;&gt;UI线程的两条基本规则
&lt;/h2&gt;&lt;p&gt;为了避免上述情况的发生，WPF开发者应遵循以下两条关键规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;不要在UI线程上执行耗时操作&lt;/strong&gt;：任何可能导致UI线程挂起的操作都应尽可能地移至后台线程执行，以确保UI线程能及时响应用户的输入和渲染屏幕的变化。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要在非UI线程直接更新UI元素&lt;/strong&gt;：由于WPF的安全机制设计，只有UI线程有权对UI元素进行修改。试图从其他线程直接更改UI状态将会抛出异常。因此，即使在后台线程完成了计算或数据准备，也需要通过适当的跨线程通信机制将结果显示到UI上。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;解决方案异步编程与线程安全更新&#34;&gt;解决方案：异步编程与线程安全更新
&lt;/h2&gt;&lt;p&gt;为了在保持UI流畅的同时又能执行耗时任务，WPF提供了多种异步编程模型和工具来协助开发者实现这一目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Dispatcher对象&lt;/strong&gt;：WPF的Dispatcher类允许你将工作项安排到UI线程的任务队列中执行。你可以使用&lt;code&gt;Dispatcher.Invoke&lt;/code&gt;或&lt;code&gt;Dispatcher.BeginInvoke&lt;/code&gt;方法从后台线程安全地更新UI。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;async/await关键字&lt;/strong&gt;：利用C#语言的异步特性，可以编写异步方法并在其中使用&lt;code&gt;await&lt;/code&gt;关键字等待后台任务完成，完成后自动回到UI线程执行后续的UI更新代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;案例&#34;&gt;案例
&lt;/h2&gt;&lt;h3 id=&#34;使用dispatcherinvoke方法更新ui&#34;&gt;使用&lt;code&gt;Dispatcher.Invoke&lt;/code&gt;方法更新UI
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private void Button_Click(object sender, RoutedEventArgs e)
{
    // 假设这是一个耗时操作
    Task.Run(() =&amp;gt;
    {
        var result = LongRunningOperation(); // 这里是模拟一个耗时计算的方法
        
        // 当耗时操作完成后，在UI线程上更新UI
        Application.Current.Dispatcher.Invoke(() =&amp;gt;
        {
            LabelStatus.Text = $&amp;quot;计算结果: {result}&amp;quot;;
        });
    });
}

private string LongRunningOperation()
{
    // 模拟耗时操作
    Thread.Sleep(5000);
    return &amp;quot;已完成&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用asyncawait关键字配合taskrun&#34;&gt;使用&lt;code&gt;async/await&lt;/code&gt;关键字配合&lt;code&gt;Task.Run&lt;/code&gt;
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private async void Button_ClickAsync(object sender, RoutedEventArgs e)
{
    Button button = sender as Button;
    button.IsEnabled = false; // 防止用户重复点击

    try
    {
        // 开启后台任务
        var result = await Task.Run(() =&amp;gt; LongRunningOperation());

        // 在后台任务完成后，自动切换回UI线程更新UI
        LabelStatus.Text = $&amp;quot;计算结果: {result}&amp;quot;;
    }
    catch (Exception ex)
    {
        MessageBox.Show($&amp;quot;发生错误: {ex.Message}&amp;quot;);
    }
    finally
    {
        button.IsEnabled = true; // 重新启用按钮
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>升级GCC版本导致程序崩溃：代码不规范的隐患</title>
        <link>https://ttf248.life/p/gcc-upgrade-causes-program-crash-code-irregularities/</link>
        <pubDate>Sun, 10 Mar 2024 23:19:06 +0800</pubDate>
        
        <guid>https://ttf248.life/p/gcc-upgrade-causes-program-crash-code-irregularities/</guid>
        <description>&lt;p&gt;在同一段业务代码的情况下，程序在 CentOS 7 环境下编译并运行正常，但当切换到 CentOS 8 并使用更新版的 GCC 进行编译时，程序却发生了崩溃。值得注意的是，问题只在 &lt;strong&gt;Release 模式&lt;/strong&gt;下出现，&lt;strong&gt;Debug 模式&lt;/strong&gt;则完全没有问题。这是我们第一次遇到类似的情况，经过三天的排查，最终找到了问题的根源。&lt;/p&gt;
&lt;h3 id=&#34;问题定位&#34;&gt;问题定位
&lt;/h3&gt;&lt;p&gt;通过一番排查，问题的症结在于 &lt;strong&gt;函数缺少返回值&lt;/strong&gt;。在 Release 模式下，GCC 新版本会进行更多的优化，这导致了原本没有显式返回值的函数在执行过程中出现了未知的逻辑，从而引发了崩溃。我们的结论是，&lt;strong&gt;编译器的警告不容忽视，尤其是在老项目中，部分警告可能被无视，但也应当避免屏蔽所有警告&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;环境说明&#34;&gt;环境说明
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CentOS 7 GCC版本：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39)
Copyright © 2015 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CentOS 8 GCC版本：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 8.5.0 20210514 (Red Hat 8.5.0-21)
Copyright (C) 2018 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;崩溃现象&#34;&gt;崩溃现象
&lt;/h3&gt;&lt;p&gt;我们在分析程序崩溃的堆栈时，看到的堆栈信息如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[New LWP 1385902]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib64/libthread_db.so.1&amp;quot;.
Core was generated by `./pstack_main`.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007ffe894b4420 in ?? ()
(gdb) bt
#0  0x00007ffe894b4420 in ?? ()
#1  0x00000000004008e9 in main ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个堆栈看上去并不直观，崩溃函数的栈信息居然显示为一个 &lt;code&gt;??&lt;/code&gt;，这让问题的排查变得更加复杂。&lt;/p&gt;
&lt;h3 id=&#34;代码示例&#34;&gt;代码示例
&lt;/h3&gt;&lt;p&gt;为了更好地理解问题，下面是重现崩溃的最小代码示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int test() {
    std::cout &amp;lt;&amp;lt; &amp;quot;1&amp;quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    test();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该代码中的 &lt;code&gt;test()&lt;/code&gt; 函数显然没有显式返回一个值，而它的返回类型是 &lt;code&gt;int&lt;/code&gt;。根据 C++ 规范，当一个函数声明为 &lt;code&gt;int&lt;/code&gt; 类型时，必须有一个返回值，否则就可能导致未定义行为。&lt;/p&gt;
&lt;h3 id=&#34;编译警告&#34;&gt;编译警告
&lt;/h3&gt;&lt;p&gt;在我们的项目中，CMake 脚本屏蔽了许多编译时警告，其中就包括了以下警告信息：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/root/pstack/main.cpp: In function ‘int test()’:
/root/pstack/main.cpp:7:1: warning: no return statement in function returning non-void [-Wreturn-type]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这一警告表明 &lt;code&gt;test()&lt;/code&gt; 函数没有返回值，而这正是问题的根源。高版本的 GCC（如 8.5.0）在优化代码时可能会对这种未定义的行为做出不稳定的优化，从而导致程序崩溃。&lt;/p&gt;
&lt;h3 id=&#34;汇编代码差异&#34;&gt;汇编代码差异
&lt;/h3&gt;&lt;p&gt;为了解释 GCC 编译器优化行为的差异，我们对比了不同版本 GCC 生成的汇编代码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;GCC 4.8.5 生成的汇编代码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;汇编代码较为冗长，且包含了对标准输出流（如 &lt;code&gt;std::cout&lt;/code&gt;）的处理逻辑。这表明编译器进行了更保守的优化，未对 &lt;code&gt;test()&lt;/code&gt; 函数中缺失返回值的问题做过多优化，可能因此避免了崩溃。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;GCC 8.5.0 生成的汇编代码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新版本的 GCC 进行了更多的优化，减少了代码量。然而，这种优化可能使得缺少返回值的函数执行时行为不确定，从而导致程序崩溃。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;结论&#34;&gt;结论
&lt;/h3&gt;&lt;p&gt;通过这次问题排查，我们深刻认识到，在 C++ 中，&lt;strong&gt;函数返回值必须明确&lt;/strong&gt;，特别是在函数声明为 &lt;code&gt;int&lt;/code&gt; 时，必须提供一个返回值。对于使用较旧版本编译器的项目，升级到新版本的 GCC 时，可能会遇到更多的优化和更严格的警告机制。因此，我们建议在编译时 &lt;strong&gt;不要屏蔽所有警告&lt;/strong&gt;，而是应该有选择性地处理它们，尤其是函数返回值、类型匹配等常见问题。&lt;/p&gt;
&lt;p&gt;最终，通过为 &lt;code&gt;test()&lt;/code&gt; 函数添加一个返回值，问题得以解决，程序恢复了正常的运行。&lt;/p&gt;</description>
        </item>
        <item>
        <title>vmware虚拟机cpu资源占用异常</title>
        <link>https://ttf248.life/p/vmware-virtual-machine-cpu-usage-anomaly/</link>
        <pubDate>Sun, 10 Mar 2024 22:14:59 +0800</pubDate>
        
        <guid>https://ttf248.life/p/vmware-virtual-machine-cpu-usage-anomaly/</guid>
        <description>&lt;p&gt;背景：本地机器部署 windows 版本的业务系统，cpu 资源占用 5% 左右。vmware安装的 centos8 中部署 linux 版本业务系统，资源占用异常。&lt;/p&gt;
&lt;h2 id=&#34;问题描述&#34;&gt;问题描述
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;宿主机：win10 企业版&lt;/li&gt;
&lt;li&gt;vmware：17.5&lt;/li&gt;
&lt;li&gt;虚拟机：centos8&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虚拟机资源分配为&lt;code&gt;4C8GB&lt;/code&gt;，启动业务系统。业务系统部署在虚拟机Linux系统中，虚拟机内部 top 命令观察系统资源占用，cpu 占用并不高，外层 windows 系统，任务管理器观察到的CPU资源占用很高，查看进程发现，vmware 进程占用CPU资源很高。&lt;/p&gt;
&lt;p&gt;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+
|         Windows           |
|                           |
|   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+  |
|   |      VMware        |  |
|   |      Program       |  |
|   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+  |
|                           |
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+&lt;/p&gt;
&lt;h2 id=&#34;知识点&#34;&gt;知识点
&lt;/h2&gt;&lt;p&gt;此问题的排查，并不顺利，由于导火索并不是业务系统本身，而是虚拟机本身的问题。如何将思路从常规的业务代码转移到系统负载，再从负载数据的异常，定位到软中断，最后来到关键点，什么东西会影响 Vmware 软中断的工作效率？本文将先科普各个知识点，最后给出解决方案。&lt;/p&gt;
&lt;h3 id=&#34;hyper-v&#34;&gt;hyper-v
&lt;/h3&gt;&lt;p&gt;Windows操作系统的虚拟化技术经历了一次重大变革。在微软首次发布WSL时，启用Hyper-V服务会导致无法同时使用VMware虚拟机。直到后续版本，VMware才能与Hyper-V服务兼容。&lt;/p&gt;
&lt;h3 id=&#34;系统负载&#34;&gt;系统负载
&lt;/h3&gt;&lt;p&gt;在Linux系统中，&amp;ldquo;负载&amp;rdquo;（load）是指系统中正在运行或等待执行的进程的数量。负载通常由三个数字表示，分别是1分钟、5分钟和15分钟内运行队列中的平均进程数量。这些数字可以通过运行&amp;quot;uptime&amp;quot;命令或&amp;quot;top&amp;quot;命令来查看。&lt;/p&gt;
&lt;p&gt;具体来说，这三个数字分别代表：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;1分钟负载&lt;/strong&gt;：系统在过去1分钟内运行队列中的平均进程数量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;5分钟负载&lt;/strong&gt;：系统在过去5分钟内运行队列中的平均进程数量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;15分钟负载&lt;/strong&gt;：系统在过去15分钟内运行队列中的平均进程数量。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;负载的含义是在系统中等待运行的进程数。如果这个数字高于系统的逻辑CPU数量，表明系统负载很高，意味着有许多进程正在等待处理器资源。这可能会导致系统变得缓慢或不响应，具体取决于负载的高低程度以及系统的配置和性能。&lt;/p&gt;
&lt;p&gt;在理想情况下，负载应该保持在系统的逻辑CPU数量范围内，这样系统的性能就能够得到最优化。如果负载持续高于CPU数量，可能需要进一步分析系统中的进程，找出导致负载高的原因，并采取相应的措施来调整系统资源分配或优化进程的运行方式。&lt;/p&gt;
&lt;h3 id=&#34;分析负载-mpstat&#34;&gt;分析负载 mpstat
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;mpstat&lt;/code&gt; 命令用于报告单个或多个处理器的多个信息，包括平均负载、CPU利用率、中断和上下文切换等。在 &lt;code&gt;sysstat&lt;/code&gt; 包中，&lt;code&gt;mpstat&lt;/code&gt; 是非常有用的工具，可以用来分析系统的负载情况。下面是使用 &lt;code&gt;mpstat&lt;/code&gt; 进行负载分析的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;安装 sysstat&lt;/strong&gt;：
如果您的系统上没有安装 &lt;code&gt;sysstat&lt;/code&gt;，可以使用适合您系统的包管理工具进行安装。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;运行 mpstat&lt;/strong&gt;：
使用 &lt;code&gt;mpstat&lt;/code&gt; 命令查看 CPU 的使用情况和负载。默认情况下，&lt;code&gt;mpstat&lt;/code&gt; 每秒钟显示一次 CPU 使用情况的平均值。您可以通过指定时间间隔来调整输出频率。例如，要以每秒钟一次的频率运行 &lt;code&gt;mpstat&lt;/code&gt;，可以使用以下命令：&lt;code&gt;mpstat -P ALL 2&lt;/code&gt;，&lt;code&gt;irq&lt;/code&gt; 表示占用资源占用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;01:32:33 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
01:32:35 PM  all    0.00    0.00    0.26    0.00    3.73    0.26    0.00    0.00    0.00   95.76
01:32:35 PM    0    0.00    0.00    0.51    0.00    3.57    0.00    0.00    0.00    0.00   95.92
01:32:35 PM    1    0.00    0.00    0.00    0.00    3.59    0.51    0.00    0.00    0.00   95.90
01:32:35 PM    2    0.00    0.00    0.00    0.00    4.15    0.00    0.00    0.00    0.00   95.85
01:32:35 PM    3    0.00    0.00    0.52    0.00    3.61    0.52    0.00    0.00    0.00   95.36
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分析输出&lt;/strong&gt;：
&lt;code&gt;mpstat&lt;/code&gt; 的输出包括了每个 CPU 的利用率，以及系统的平均负载。特别关注平均负载以及每个 CPU 的利用率，可以帮助您了解系统的负载情况。如果负载较高，可以进一步分析是哪些进程导致的，以及是否存在性能瓶颈。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;结合其他工具&lt;/strong&gt;：
除了 &lt;code&gt;mpstat&lt;/code&gt;，还可以使用 &lt;code&gt;sar&lt;/code&gt;、&lt;code&gt;pidstat&lt;/code&gt;、&lt;code&gt;iostat&lt;/code&gt; 等工具来综合分析系统性能。通过结合多种工具的输出，可以更全面地了解系统的负载情况，并找出性能问题的根源。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;中断&#34;&gt;中断
&lt;/h3&gt;&lt;p&gt;此处不展开讲解内容太多，
推荐: &lt;a class=&#34;link&#34; href=&#34;https://www.codedump.info/post/20200522-sgfap-softirq/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《面向应用开发者的系统指南》CPU篇之软中断&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;频繁的触发软中断，也会体现在系统负载中。&lt;/p&gt;
&lt;h2 id=&#34;问题排查&#34;&gt;问题排查
&lt;/h2&gt;&lt;p&gt;考虑到仅从CPU角度分析无法定位问题，我们是否应该开始怀疑系统是否出现了异常？可能是Linux操作系统的负载过高，导致VMware占用了过多的CPU资源。通过使用&lt;code&gt;mpstat&lt;/code&gt;分析本地虚拟机，我们发现&lt;code&gt;irq&lt;/code&gt;占用异常，单核接近25%，而在正常情况下，启动业务进程空跑时，&lt;code&gt;irq&lt;/code&gt;占比应该约为5%。&lt;/p&gt;
&lt;p&gt;在组内同事的开发环境中，他的CentOS 7部署在VMware上，资源占用显示正常。另一方面，在上海的开发环境中，虽然也是VMware，但我们无法直接观察宿主机的CPU资源情况。这时，我们面临着多个变量：VMware虚拟机、Linux操作系统和GCC版本。&lt;/p&gt;
&lt;p&gt;转而分析测试环境，深圳的测试环境部署在物理机上，运行着低版本GCC编译的服务，而且在CentOS 8上运行。有趣的是，在深圳环境中，&lt;code&gt;irq&lt;/code&gt;占用都是正常的。&lt;/p&gt;
&lt;p&gt;为了排查GCC版本引入的问题，我们将使用高版本GCC编译的程序部署到深圳环境进行测试，结果显示也都是正常的。&lt;/p&gt;
&lt;p&gt;问题似乎变得更加明朗，我们开始怀疑操作系统是否存在问题。毕竟，CentOS 8已经不再受到官方支持。但即便重新部署了纯净的CentOS 7和CentOS 8，问题依然存在。&lt;/p&gt;
&lt;p&gt;此时，我们开始怀疑唯一的不确定因素，即VMware虚拟机软件。突然间，灵光一现，我们想到了Hyper-V技术。是否之前启用了Hyper-V，但没有彻底关闭，从而导致了这个问题？毕竟，软中断也是通过虚拟机软件来实现的。不同的虚拟机虚拟技术是否存在BUG？这些问题值得深入思考和调查。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论
&lt;/h2&gt;&lt;p&gt;根据微软官方的手册，我们完全关闭了本机的Hyper-V服务后，发现VMware在宿主机上恢复了正常。至此，问题终于迎刃而解。正如一开始所述，这段经历曲折而艰辛，需要综合性的分析和判断。这也是我们首次排查问题，定位到了虚拟机这一层面。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Disable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V-Hypervisor
bcdedit /set hypervisorlaunchtype off
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/application-management/virtualization-apps-not-work-with-hyper-v&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/application-management/virtualization-apps-not-work-with-hyper-v&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43;编程中的陷阱：错误使用`std::map`导致程序崩溃详解</title>
        <link>https://ttf248.life/p/cpp-programming-traps-std-map-crash-details/</link>
        <pubDate>Sun, 10 Mar 2024 22:03:06 +0800</pubDate>
        
        <guid>https://ttf248.life/p/cpp-programming-traps-std-map-crash-details/</guid>
        <description>&lt;p&gt;本文旨在揭示在C++编程中不正确使用&lt;code&gt;std::map&lt;/code&gt;容器可能导致程序崩溃，通过中括号操作符尝试访问不存在的键时，会自动添加一个空元素。我们将深入剖析这一误解，并通过实例代码展示其潜在风险。&lt;/p&gt;
&lt;p&gt;存储简单值不会有什么问题，但如果存储的是指针，那么就会有问题。因为指针是一个地址，如果没有初始化，那么这个地址是不确定的，这样就会导致程序崩溃。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;在C++标准库中，&lt;code&gt;std::map&lt;/code&gt;是一种关联容器，它按照键（key）的升序存储元素，并提供了高效的关键字查找功能。然而，新手开发者有时会因为对&lt;code&gt;std::map&lt;/code&gt;中括号操作符 &lt;code&gt;[]&lt;/code&gt; 的行为理解有误而陷入困境。实际上，当使用 &lt;code&gt;[]&lt;/code&gt; 访问一个不存在的键时，&lt;code&gt;std::map&lt;/code&gt; 会插入一个新的键值对，且默认构造函数将会用来初始化该键对应的值类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int main() {
    std::map&amp;lt;std::string, int&amp;gt; myMap;
    
    // 错误的用法：假设这里试图访问一个不存在的键并认为会得到0
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for &#39;nonexistent_key&#39;: &amp;quot; &amp;lt;&amp;lt; myMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;

    // 实际上，上述行代码创建了一个新的键值对，其中值被默认初始化为int的默认值（通常是0）
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上代码虽然没有直接导致程序崩溃，但这种隐式的插入行为在某些情况下可能导致意料之外的副作用，例如资源泄漏或不符合预期的状态变更。更糟糕的是，在多线程环境下并发访问未初始化的内存区域，甚至可能导致程序崩溃。&lt;/p&gt;
&lt;p&gt;为了防止此类问题，推荐使用 &lt;code&gt;std::map::find()&lt;/code&gt; 或 &lt;code&gt;std::map::count()&lt;/code&gt; 方法来检查键是否存在，或者利用 &lt;code&gt;std::map::insert()&lt;/code&gt; 明确地插入元素：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::map&amp;lt;std::string, int&amp;gt; safeMap;
if (safeMap.count(&amp;quot;nonexistent_key&amp;quot;) == 0) {
    std::cout &amp;lt;&amp;lt; &amp;quot;Key does not exist.&amp;quot; &amp;lt;&amp;lt; std::endl;
} else {
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for existing key: &amp;quot; &amp;lt;&amp;lt; safeMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;
}

// 或者明确插入一个键值对，指定初始值
safeMap.insert({ &amp;quot;new_key&amp;quot;, 0 });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果 map 容器内部保存的对象为指针类型，自动插入元素的行为将保存一个未初始化的指针，调用到此指针的任何操作都将导致程序崩溃。&lt;/p&gt;</description>
        </item>
        <item>
        <title>pstack排查进程假死</title>
        <link>https://ttf248.life/p/pstack-troubleshooting-process-hangs/</link>
        <pubDate>Sat, 24 Feb 2024 23:55:59 +0800</pubDate>
        
        <guid>https://ttf248.life/p/pstack-troubleshooting-process-hangs/</guid>
        <description>&lt;p&gt;在软件开发和运维中，经常会遇到进程假死的情况，这种情况会导致系统性能下降或者服务不可用。本文介绍如何使用 pstack 工具来排查进程假死问题，通过分析进程的堆栈信息，找出问题的原因并解决。&lt;/p&gt;
&lt;p&gt;背景：风控系统子服务出现假死，导致风控服务不可用。由于缺乏服务可用性监控，无法及时发现进程假死的情况，导致系统不可用。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;进程假死是指进程停止响应，但并没有退出的状态。这种情况可能由于多种原因引起，比如死锁、资源耗尽、异常等。为了解决这类问题，我们可以使用 pstack 工具来分析进程的堆栈信息，找出问题的根源。&lt;/p&gt;
&lt;h2 id=&#34;步骤&#34;&gt;步骤
&lt;/h2&gt;&lt;p&gt;pstack 是一个常用的工具，通常随着 gdb（GNU 调试器）一起提供。你可以通过以下命令安装它：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt-get install gdb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取进程ID：首先，我们需要获取假死进程的进程ID（PID）。可以使用 ps 命令来列出所有进程，并找到需要排查的进程ID。
使用 pstack 工具分析进程堆栈，一旦获取到进程ID，就可以使用 pstack 工具来获取该进程的堆栈信息。运行以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pstack &amp;lt;PID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这将输出该进程的堆栈信息，显示出当前正在执行的函数调用序列。通过分析这些信息，可以发现进程停滞的位置，进而定位问题。&lt;/p&gt;
&lt;p&gt;分析堆栈信息，通过查看堆栈信息，可以找到导致进程假死的原因。可能会发现一些死锁情况、无限循环或者其他异常情况。根据具体情况采取相应的措施，比如释放锁、修复代码逻辑等。&lt;/p&gt;
&lt;h2 id=&#34;案例&#34;&gt;案例
&lt;/h2&gt;&lt;p&gt;简单 demo，main 函数启动以后，新建子线程，实际执行函数进入死循环，导致程序无法正常结束，陷入假死的状态。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cmake_minimum_required(VERSION 3.0.0)
project(pstack_main VERSION 0.1.0 LANGUAGES C CXX)

include(CTest)
enable_testing()

# 查找线程库
find_package(Threads REQUIRED)

add_executable(pstack_main main.cpp)

# 链接线程库
target_link_libraries(pstack_main PRIVATE Threads::Threads)

set(CPACK_PROJECT_NAME ${PROJECT_NAME})
set(CPACK_PROJECT_VERSION ${PROJECT_VERSION})
include(CPack)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;
#include &amp;lt;chrono&amp;gt;

void infiniteLoop() {
    while (true) {
        // 主线程进入死循环
    }
}

int main() {
    std::thread thread(infiniteLoop); // 创建一个线程，执行死循环函数
    thread.join(); // 等待线程结束
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动程序，执行 pstack 结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Thread 2 (Thread 0x7eff3619b700 (LWP 1315017)):
#0  infiniteLoop () at /root/pstack/main.cpp:6
#1  0x0000000000402ca9 in std::__invoke_impl&amp;lt;void, void (*)()&amp;gt; (__f=@0x2260eb8: 0x4029a6 &amp;lt;infiniteLoop()&amp;gt;) at /usr/include/c++/8/bits/invoke.h:60
#2  0x0000000000402b02 in std::__invoke&amp;lt;void (*)()&amp;gt; (__fn=@0x2260eb8: 0x4029a6 &amp;lt;infiniteLoop()&amp;gt;) at /usr/include/c++/8/bits/invoke.h:95
#3  0x0000000000403150 in std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt;::_M_invoke&amp;lt;0ul&amp;gt; (this=0x2260eb8) at /usr/include/c++/8/thread:244
#4  0x0000000000403126 in std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt;::operator() (this=0x2260eb8) at /usr/include/c++/8/thread:253
#5  0x000000000040310a in std::thread::_State_impl&amp;lt;std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt; &amp;gt;::_M_run (this=0x2260eb0) at /usr/include/c++/8/thread:196
#6  0x00007eff36bceb23 in execute_native_thread_routine () from /lib64/libstdc++.so.6
#7  0x00007eff36ea91ca in start_thread () from /lib64/libpthread.so.0
#8  0x00007eff361d58d3 in clone () from /lib64/libc.so.6
Thread 1 (Thread 0x7eff372e1740 (LWP 1315016)):
#0  0x00007eff36eaa6cd in __pthread_timedjoin_ex () from /lib64/libpthread.so.0
#1  0x00007eff36bceda7 in std::thread::join() () from /lib64/libstdc++.so.6
#2  0x00000000004029d2 in main () at /root/pstack/main.cpp:13
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，进程假死的原因是死循环，主线程进入死循环，子线程无法退出，导致进程假死。&lt;/p&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43;函数调用耗时</title>
        <link>https://ttf248.life/p/cpp-function-call-timing/</link>
        <pubDate>Wed, 24 Jan 2024 14:11:33 +0800</pubDate>
        
        <guid>https://ttf248.life/p/cpp-function-call-timing/</guid>
        <description>&lt;p&gt;设计行情 SDK，针对不同的回调函数实现方式，进行了一次耗时的测试。近期在看 C++ 函数编程，当函数变成了一等公民，在程序内部流转，耗时有什么不同？&lt;/p&gt;
&lt;p&gt;前文链接：&lt;a class=&#34;link&#34; href=&#34;https://ttf248.life/p/compiler-callback-performance-testing/&#34; &gt;编译器、回调函数、性能测试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;leimao&lt;/code&gt; 大佬刚好也做了类似的测试，借代码一用。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;执行平台依旧是我们的老朋友，&lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;cassert&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

int add_one(int input) { return input + 1; }

bool validate_vector_add_one(std::vector&amp;lt;int&amp;gt; const&amp;amp; input_vector,
                             std::vector&amp;lt;int&amp;gt; const&amp;amp; output_vector)
{
    bool is_valid{true};
    for (size_t i{0}; i &amp;lt; input_vector.size(); ++i)
    {
        if (output_vector.at(i) != input_vector.at(i) + 1)
        {
            is_valid = false;
            break;
        }
    }
    return is_valid;
}

void reset_vector(std::vector&amp;lt;int&amp;gt;&amp;amp; input_vector)
{
    for (size_t i{0}; i &amp;lt; input_vector.size(); ++i)
    {
        input_vector.at(i) = 0;
    }
}

template &amp;lt;typename T, typename Func&amp;gt;
void unitary_function_pass_by_lambda_function(T&amp;amp; output, T const&amp;amp; input,
                                              Func const func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_std_function_value(T&amp;amp; output, T const&amp;amp; input,
                                                 std::function&amp;lt;T(T)&amp;gt; const func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_std_function_reference(
    T&amp;amp; output, T const&amp;amp; input, std::function&amp;lt;T(T)&amp;gt; const&amp;amp; func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_function_pointer(T&amp;amp; output, T const&amp;amp; input,
                                               T (*func)(T))
{
    output = func(input);
}

int main()
{
    // Set floating point format std::cout with 3 decimal places.
    std::cout.precision(3);

    size_t const num_elements{10000000};
    std::vector&amp;lt;int&amp;gt; input_vector(num_elements, 0);
    std::vector&amp;lt;int&amp;gt; output_vector(num_elements, 0);

    auto const lambda_function_add_one{[](int const&amp;amp; input) -&amp;gt; int
                                       { return input + 1; }};
    std::function&amp;lt;int(int)&amp;gt; const std_function_add_one{lambda_function_add_one};

    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a function pointer: &amp;quot; &amp;lt;&amp;lt; sizeof(&amp;amp;add_one)
              &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a std::function pointer: &amp;quot;
              &amp;lt;&amp;lt; sizeof(&amp;amp;std_function_add_one) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a std::function: &amp;quot; &amp;lt;&amp;lt; sizeof(std_function_add_one)
              &amp;lt;&amp;lt; std::endl;

    // Call function frequently in a vanilla way.
    // The compiler knows what function to call at compile time and can optimize
    // the code.
    // This is the best performance we could get.
    std::chrono::steady_clock::time_point const time_start_vanilla{
        std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        output_vector.at(i) = add_one(input_vector.at(i));
    }
    std::chrono::steady_clock::time_point const time_end_vanilla{
        std::chrono::steady_clock::now()};
    auto const time_elapsed_vanilla{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(time_end_vanilla -
                                                             time_start_vanilla)
            .count()};
    float const latency_vanilla{time_elapsed_vanilla /
                                static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass Vanilla: &amp;quot; &amp;lt;&amp;lt; latency_vanilla &amp;lt;&amp;lt; &amp;quot; ns&amp;quot;
              &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // Sometimes, we don&#39;t know what function to call at compile time.
    // We can use std::function to pass a function as an argument.
    // In this case, we pass the std::function by value.
    // Because the size of a std::function is 32 bytes, passing by value
    // results in a lot of copying and bad performance.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_std_function_value{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_std_function_value(
            output_vector.at(i), input_vector.at(i), std_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_std_function_value{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_std_function_value{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_std_function_value -
            time_start_pass_by_std_function_value)
            .count()};
    float const latency_pass_by_std_function_value{
        time_elapsed_pass_by_std_function_value /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Std Function Value: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_std_function_value &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // Instead of passing the std::function by value, we can pass it by
    // reference (pointer). In this case, object copying is eliminated. The
    // performance is better than passing the std::function by value. However,
    // the performance is still not as good as the vanilla way.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_std_function_reference{
            std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_std_function_reference(
            output_vector.at(i), input_vector.at(i), std_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_std_function_reference{
            std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_std_function_reference{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_std_function_reference -
            time_start_pass_by_std_function_reference)
            .count()};
    float const latency_pass_by_std_function_reference{
        time_elapsed_pass_by_std_function_reference /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Std Function Reference: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_std_function_reference &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // std::function is a general purpose wrapper for function pointers,
    // callable objects, and lambda functions. Because it&#39;s general purpose,
    // it&#39;s not as efficient as a function pointer. In this case, we pass a
    // function pointer to a function. The performance is better than passing
    // the std::function by reference.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_function_pointer{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_function_pointer(output_vector.at(i),
                                                  input_vector.at(i), &amp;amp;add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_function_pointer{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_function_pointer{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_function_pointer -
            time_start_pass_by_function_pointer)
            .count()};
    float const latency_pass_by_function_pointer{
        time_elapsed_pass_by_function_pointer /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Function Pointer: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_function_pointer &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // We can also pass a lambda function to a function.
    // The compiler knows what function to call at compile time and can optimize
    // the code. The performance is also better than passing the std::function
    // by reference.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_lambda_function{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_lambda_function(
            output_vector.at(i), input_vector.at(i), lambda_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_lambda_function{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_lambda_function{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_lambda_function -
            time_start_pass_by_lambda_function)
            .count()};
    float const latency_pass_by_lambda_function{
        time_elapsed_pass_by_lambda_function /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Lambda Function: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_lambda_function &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 组里常规也就开启 O2 优化，编译选用了 gcc13，不同版本的 gcc 性能耗时略有不同，版本越高 lambda 效果越好
The size of a function pointer: 8
The size of a std::function pointer: 8
The size of a std::function: 32
Latency Pass Vanilla: 0.418 ns
Latency Pass By Std Function Value: 3.47 ns
Latency Pass By Std Function Reference: 1.36 ns
Latency Pass By Function Pointer: 0.396 ns
Latency Pass By Lambda Function: 0.44 ns
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leimao.github.io/blog/CPP-Function-Call-Performance/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://leimao.github.io/blog/CPP-Function-Call-Performance/&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>程序如何反调试</title>
        <link>https://ttf248.life/p/program-anti-debug/</link>
        <pubDate>Tue, 23 Jan 2024 19:46:36 +0800</pubDate>
        
        <guid>https://ttf248.life/p/program-anti-debug/</guid>
        <description>&lt;p&gt;心血来潮，琢磨找找新壁纸，习惯黑色系列，部分区域彩色即可，桌面需要放置图标，其他色系作壁纸，图标就不清晰了。&lt;/p&gt;
&lt;p&gt;盯着上面的汇编代码思考一波，没看懂，尝试扔给&lt;code&gt;AI&lt;/code&gt;，解释了指令，没有解释场景，必然是某个特殊场景用到的指令，常规代码不是这样的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AI&lt;/code&gt;此时不如搜索引擎了，汇编的知识储备不足。&lt;/p&gt;
&lt;h2 id=&#34;壁纸&#34;&gt;壁纸
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/program-anti-debug/Snipaste_2024-01-23_19-50-53.png&#34;
	width=&#34;1020&#34;
	height=&#34;470&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;黑色汇编壁纸&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;217&#34;
		data-flex-basis=&#34;520px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;汇编代码&#34;&gt;汇编代码
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;PUSHFD
MOV DWORD PTR [ESP],0X100
POPFD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际应用场景&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool IsDebugged()
{
    __try
    {
        __asm
        {
            pushfd
            mov dword ptr [esp], 0x100
            popfd
            nop
        }
        return true;
    }
    __except(GetExceptionCode() == EXCEPTION_SINGLE_STEP
        ? EXCEPTION_EXECUTE_HANDLER
        : EXCEPTION_CONTINUE_EXECUTION)
    {
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解释说明&#34;&gt;解释说明
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;TrapFlag&lt;/code&gt;是标志寄存器中的一个标志位，当这个标志位被设置时，会抛出异常&lt;code&gt;SINGLE_STEP&lt;/code&gt;，因为如果我们跟踪代码，这个标志位会被调试器清零，所以我们看不到这个异常。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实际测试时发现，如果直接步过检测调试的函数，那么调试不会被检测到，只有步入检测函数执行时才会检测到(资料查询，尚未实际验证)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料
&lt;/h2&gt;&lt;p&gt;中文的相关资料，都是基于网站的英文稿子翻译，站点科普了很多种反调试的技术。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://anti-debug.checkpoint.com/techniques/assembly.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://anti-debug.checkpoint.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://song-10.gitee.io/2021/08/08/Reverse-2021-08-08-anti-debug/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://song-10.gitee.io/2021/08/08/Reverse-2021-08-08-anti-debug/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>如何下载焦点访谈/CCTV视频文件</title>
        <link>https://ttf248.life/p/how-to-download-focus-interview-cctv-videos/</link>
        <pubDate>Tue, 23 Jan 2024 19:23:35 +0800</pubDate>
        
        <guid>https://ttf248.life/p/how-to-download-focus-interview-cctv-videos/</guid>
        <description>&lt;p&gt;最近有人咨询，如何下载焦点访谈的视频，脑子里面想着十有八九又是 &lt;code&gt;m3u8&lt;/code&gt; 方式加密，洒洒水了，简单处理下。&lt;/p&gt;
&lt;h2 id=&#34;下载器&#34;&gt;下载器
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/nilaoda/N_m3u8DL-CLI&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/nilaoda/N_m3u8DL-CLI&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;m3u8 downloader&lt;/code&gt; 开源的命令行m3u8/HLS/dash下载器，支持普通AES-128-CBC解密，多线程，自定义请求头等. 支持简体中文,繁体中文和英文. English Supported.&lt;/p&gt;
&lt;h2 id=&#34;浏览器插件&#34;&gt;浏览器插件
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://microsoftedge.microsoft.com/addons/detail/ngjclnbcdbahekojpkhancmiobdahemb&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Live Stream Downloader&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;蜜汁自信&#34;&gt;蜜汁自信
&lt;/h2&gt;&lt;p&gt;拿到地址，以为搞定了，结果啥也不是，无法正常解析分段内容，查询资料，发现官方处理了下载地址，需要人工进行一定的替换，将插件解析到的 &lt;code&gt;key&lt;/code&gt; 人工复制替换到下面的链接中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;https://newcntv.qcloudcdn.com/asp/hls/2000/0303000a/3/default/***********************/2000.m3u8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;截止 2024年1月，地址测试有效，后续如有变动，自行分析网页。&lt;/p&gt;
&lt;p&gt;历史地址备份：&lt;code&gt;https://hlswx.cntv.kcdnvip.com/asp/hls/main/0303000a/3/default/一串字符/main.m3u8?maxbr=2000&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://jln.cn/post/517.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://jln.cn/post/517.html&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>批量修改SqlServer数据库磁盘文件权限</title>
        <link>https://ttf248.life/p/bulk-modify-sqlserver-database-disk-permissions/</link>
        <pubDate>Tue, 23 Jan 2024 19:06:36 +0800</pubDate>
        
        <guid>https://ttf248.life/p/bulk-modify-sqlserver-database-disk-permissions/</guid>
        <description>&lt;p&gt;公司安全策略调整，&lt;code&gt;机械师 mini&lt;/code&gt;最终还是搬迁回家作为备用服务器，顺带重装机器系统，&lt;code&gt;ubuntu&lt;/code&gt; 切换到了&lt;code&gt;windows server&lt;/code&gt;，由于激活的手段不正规，自己家里用，好像不激活也没事&lt;/p&gt;
&lt;p&gt;非常规方式激活，触发了微软的检测（正常运行了半个月），服务器开机一小时，自动关机，翻了一圈系统日志，才发现是盗版导致的。&lt;/p&gt;
&lt;p&gt;没辙，再次重装系统，&lt;code&gt;SqlServer&lt;/code&gt;也面临重装，每次弄都比较蛋疼，文件权限管控严格，导致无法正常附加数据库。&lt;/p&gt;
&lt;h2 id=&#34;报错信息&#34;&gt;报错信息
&lt;/h2&gt;&lt;p&gt;系统重装以后，&lt;code&gt;SqlServer&lt;/code&gt;在附加数据库中可能会出现5120，操作系统错误拒绝访问。&lt;/p&gt;
&lt;h2 id=&#34;处理脚本&#34;&gt;处理脚本
&lt;/h2&gt;&lt;p&gt;前文链接：&lt;a class=&#34;link&#34; href=&#34;https://ttf248.life/p/bulk-update-local-git-and-legacy-permissions/&#34; &gt;批量更新本地Git仓库&lt;/a&gt;，没错又是这个熟悉的脚本，改造一下，我们遍历文件夹的同时修改文件的权限，当前用于拥有完全编辑的权限。&lt;/p&gt;
&lt;p&gt;网上的教程大部分都是让你手动修改，他们每次只需要修改几个文件吗？我每次都需要处理一批文件，全部手动处理，人会自闭的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$currentUserName = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8
$rootDirectory = &amp;quot;D:\data\2013_RujiaInfo&amp;quot;

Get-ChildItem -Path $rootDirectory -Recurse | ForEach-Object {
    $itemPath = $_.FullName

    if ($_ -is [System.IO.DirectoryInfo]) {
        $icaclsResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            Write-Host &amp;quot;已更改文件夹 $itemPath 的所有者为 $currentUserName&amp;quot;
            # 授予当前用户写入权限
            Invoke-Expression &amp;quot;icacls `&amp;quot;$itemPath`&amp;quot; /grant `&amp;quot;$($currentUserName):(OI)(CI)F`&amp;quot;&amp;quot;
            Write-Host &amp;quot;已授予 $currentUserName 编辑文件夹的权限&amp;quot;
        } else {
            Write-Host &amp;quot;无法更改文件夹 $itemPath 的所有者。错误信息: $icaclsResult&amp;quot;
        }
    } else {
        $takeownResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            # 授予当前用户写入权限
            Invoke-Expression &amp;quot;icacls `&amp;quot;$itemPath`&amp;quot; /grant `&amp;quot;$($currentUserName):(F)`&amp;quot;&amp;quot;
            Write-Host &amp;quot;已授予 $currentUserName 编辑文件的权限&amp;quot;
        } else {
            Write-Host &amp;quot;无法更改文件 $itemPath 的所有者。错误信息: $takeownResult&amp;quot;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Linux系统跑分测试</title>
        <link>https://ttf248.life/p/linux-system-benchmark-test/</link>
        <pubDate>Tue, 09 Jan 2024 10:56:23 +0800</pubDate>
        
        <guid>https://ttf248.life/p/linux-system-benchmark-test/</guid>
        <description>&lt;p&gt;Windows 平台有个鲁大师（娱乐大师），不能说数据很准，单总归有个参考，当然也有其他的专业跑分软件，到了 Linux 系统，好像一直没遇到特别合适的跑分软件。&lt;/p&gt;
&lt;p&gt;Sysbench 是一款多功能的基准测试工具，可用于测试CPU、内存、文件I/O、线程性能等。您可以使用 sysbench 来执行各种性能测试任务。&lt;/p&gt;
&lt;p&gt;手头上刚好有三台机器用于测试：机械师 mini 本地小主机、阿里云 dev 开发云服务器、华为云开发服务器。&lt;/p&gt;
&lt;h2 id=&#34;安装sysbench&#34;&gt;安装Sysbench
&lt;/h2&gt;&lt;p&gt;在大多数Linux发行版中，您可以使用包管理工具来安装Sysbench。例如，在CentOS 8上，可以使用以下命令进行安装&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo dnf install sysbench
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sysbench的使用示例&#34;&gt;Sysbench的使用示例
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;测试CPU性能：&lt;code&gt;sysbench --test=cpu run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;测试内存读取性能：&lt;code&gt;sysbench --test=memory run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;测试文件I/O性能：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysbench --test=fileio --file-test-mode=rndrw prepare
sysbench --test=fileio --file-test-mode=rndrw run
sysbench --test=fileio --file-test-mode=rndrw cleanup
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;测试多线程性能: &lt;code&gt;sysbench --test=threads --num-threads=4 run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;测试MySQL数据库性能（需调整数据库最大连接数）：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword --oltp-table-size=1000000 prepare
sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword --max-time=60 --oltp-read-only=off --oltp-test-mode=complex --max-requests=0 run
sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword cleanup
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;跑分数据报告&#34;&gt;跑分数据报告
&lt;/h2&gt;&lt;meta http-equiv=&#34;Content-Type&#34; content=&#34;text/html; charset=utf-8&#34;&gt;&lt;link type=&#34;text/css&#34; rel=&#34;stylesheet&#34; href=&#34;resources/sheet.css&#34; &gt;
&lt;style type=&#34;text/css&#34;&gt;.ritz .waffle a { color: inherit; }.ritz .waffle .s0{background-color:#ffffff;text-align:left;color:#000000;font-family:&#39;Arial&#39;;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}&lt;/style&gt;&lt;div class=&#34;ritz grid-container&#34; dir=&#34;ltr&#34;&gt;&lt;table class=&#34;waffle&#34; cellspacing=&#34;0&#34; cellpadding=&#34;0&#34;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th class=&#34;row-header freezebar-origin-ltr&#34;&gt;&lt;/th&gt;&lt;th id=&#34;0C0&#34; style=&#34;width:100px;&#34; class=&#34;column-headers-background&#34;&gt;A&lt;/th&gt;&lt;th id=&#34;0C1&#34; style=&#34;width:421px;&#34; class=&#34;column-headers-background&#34;&gt;B&lt;/th&gt;&lt;th id=&#34;0C2&#34; style=&#34;width:398px;&#34; class=&#34;column-headers-background&#34;&gt;C&lt;/th&gt;&lt;th id=&#34;0C3&#34; style=&#34;width:422px;&#34; class=&#34;column-headers-background&#34;&gt;D&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R0&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;1&lt;/div&gt;&lt;/th&gt;&lt;td&gt;&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;本地机械师&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;阿里云&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;华为云&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R1&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;2&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;系统配置&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;System Information&lt;br&gt;  Operating System              Ubuntu 23.04&lt;br&gt;  Kernel                        Linux 6.2.0-36-generic x86_64&lt;br&gt;  Model                         Machenike Machenike DT Computer&lt;br&gt;  Motherboard                   Machenike Machenike DT Computer&lt;br&gt;  BIOS                          American Megatrends International, LLC.&lt;br&gt;DB19V012&lt;br&gt;&lt;br&gt;CPU Information&lt;br&gt;  Name                          Intel Core i7-12650H&lt;br&gt;  Topology                      1 Processor, 10 Cores, 16 Threads&lt;br&gt;  Identifier                    GenuineIntel Family 6 Model 154 Stepping 3&lt;br&gt;  Base Frequency                4.60 GHz&lt;br&gt;  L1 Instruction Cache          32.0 KB x 8&lt;br&gt;  L1 Data Cache                 48.0 KB x 8&lt;br&gt;  L2 Cache                      1.25 MB x 2&lt;br&gt;  L3 Cache                      24.0 MB&lt;br&gt;&lt;br&gt;Memory Information&lt;br&gt;  Size                          62.6 GB&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;System Information&lt;br&gt;  Operating System              CentOS Stream 8&lt;br&gt;  Kernel                        Linux 4.18.0-513.el8.x86_64 x86_64&lt;br&gt;  Model                         Alibaba Cloud Alibaba Cloud ECS&lt;br&gt;  Motherboard                   N/A&lt;br&gt;  BIOS                          SeaBIOS 449e491&lt;br&gt;&lt;br&gt;CPU Information&lt;br&gt;  Name                          Intel(R) Xeon(R) Platinum&lt;br&gt;  Topology                      1 Processor, 1 Core, 2 Threads&lt;br&gt;  Identifier                    GenuineIntel Family 6 Model 85 Stepping 4&lt;br&gt;  Base Frequency                2.50 GHz&lt;br&gt;  L1 Instruction Cache          32.0 KB&lt;br&gt;  L1 Data Cache                 32.0 KB&lt;br&gt;  L2 Cache                      1.00 MB&lt;br&gt;  L3 Cache                      33.0 MB&lt;br&gt;&lt;br&gt;Memory Information&lt;br&gt;  Size                          1.65 GB&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;System Information&lt;br&gt;  Operating System              Ubuntu 22.04.1 LTS&lt;br&gt;  Kernel                        Linux 5.15.0-60-generic x86_64&lt;br&gt;  Model                         OpenStack Foundation OpenStack Nova&lt;br&gt;  Motherboard                   N/A&lt;br&gt;  BIOS                          SeaBIOS&lt;br&gt;rel-1.10.2-0-g5f4c7b1-20181220_000000-szxrtosci10000&lt;br&gt;&lt;br&gt;CPU Information&lt;br&gt;  Name                          Intel(R) Xeon(R) Gold 6278C CPU @ 2.60GHz&lt;br&gt;  Topology                      1 Processor, 1 Core, 2 Threads&lt;br&gt;  Identifier                    GenuineIntel Family 6 Model 85 Stepping 7&lt;br&gt;  Base Frequency                2.60 GHz&lt;br&gt;  L1 Instruction Cache          32.0 KB&lt;br&gt;  L1 Data Cache                 32.0 KB&lt;br&gt;  L2 Cache                      1.00 MB&lt;br&gt;  L3 Cache                      35.8 MB&lt;br&gt;&lt;br&gt;Memory Information&lt;br&gt;  Size                          3.64 GB&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R2&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;3&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;CPU&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Prime numbers limit: 10000&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;CPU speed:&lt;br&gt;    events per second:  4032.48&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0004s&lt;br&gt;    total number of events:              40330&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.25&lt;br&gt;         avg:                                    0.25&lt;br&gt;         max:                                    0.73&lt;br&gt;         95th percentile:                        0.25&lt;br&gt;         sum:                                 9997.55&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           40330.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9975/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Prime numbers limit: 10000&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;CPU speed:&lt;br&gt;    events per second:  1062.51&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0008s&lt;br&gt;    total number of events:              10628&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.91&lt;br&gt;         avg:                                    0.94&lt;br&gt;         max:                                   22.84&lt;br&gt;         95th percentile:                        1.06&lt;br&gt;         sum:                                 9993.46&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           10628.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9935/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Prime numbers limit: 10000&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;CPU speed:&lt;br&gt;    events per second:  1125.56&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0005s&lt;br&gt;    total number of events:              11258&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.86&lt;br&gt;         avg:                                    0.89&lt;br&gt;         max:                                    1.70&lt;br&gt;         95th percentile:                        0.99&lt;br&gt;         sum:                                 9995.40&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           11258.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9954/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R3&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;4&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;内存&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Running memory speed test with the following options:&lt;br&gt;  block size: 1KiB&lt;br&gt;  total size: 102400MiB&lt;br&gt;  operation: write&lt;br&gt;  scope: global&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;Total operations: 101993199 (10198146.52 per second)&lt;br&gt;&lt;br&gt;99602.73 MiB transferred (9959.13 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0001s&lt;br&gt;    total number of events:              101993199&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.00&lt;br&gt;         max:                                    0.03&lt;br&gt;         95th percentile:                        0.00&lt;br&gt;         sum:                                 4059.50&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           101993199.0000/0.00&lt;br&gt;    execution time (avg/stddev):   4.0595/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Running memory speed test with the following options:&lt;br&gt;  block size: 1KiB&lt;br&gt;  total size: 102400MiB&lt;br&gt;  operation: write&lt;br&gt;  scope: global&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;Total operations: 48418803 (4841004.79 per second)&lt;br&gt;&lt;br&gt;47283.99 MiB transferred (4727.54 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0001s&lt;br&gt;    total number of events:              48418803&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.00&lt;br&gt;         max:                                   25.26&lt;br&gt;         95th percentile:                        0.00&lt;br&gt;         sum:                                 4578.95&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           48418803.0000/0.00&lt;br&gt;    execution time (avg/stddev):   4.5789/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Running memory speed test with the following options:&lt;br&gt;  block size: 1KiB&lt;br&gt;  total size: 102400MiB&lt;br&gt;  operation: write&lt;br&gt;  scope: global&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;Total operations: 57056904 (5704765.11 per second)&lt;br&gt;&lt;br&gt;55719.63 MiB transferred (5571.06 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0001s&lt;br&gt;    total number of events:              57056904&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.00&lt;br&gt;         max:                                    0.06&lt;br&gt;         95th percentile:                        0.00&lt;br&gt;         sum:                                 4556.06&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           57056904.0000/0.00&lt;br&gt;    execution time (avg/stddev):   4.5561/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R4&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;5&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;硬盘&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;2147483648 bytes written in 1.81 seconds (1129.59 MiB/sec).&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Extra file open flags: (none)&lt;br&gt;128 files, 16MiB each&lt;br&gt;2GiB total file size&lt;br&gt;Block size 16KiB&lt;br&gt;Number of IO requests: 0&lt;br&gt;Read/Write ratio for combined random IO test: 1.50&lt;br&gt;Periodic FSYNC enabled, calling fsync() each 100 requests.&lt;br&gt;Calling fsync() at the end of test, Enabled.&lt;br&gt;Using synchronous I/O mode&lt;br&gt;Doing random r/w test&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;File operations:&lt;br&gt;    reads/s:                      3373.41&lt;br&gt;    writes/s:                     2248.94&lt;br&gt;    fsyncs/s:                     7201.80&lt;br&gt;&lt;br&gt;Throughput:&lt;br&gt;    read, MiB/s:                  52.71&lt;br&gt;    written, MiB/s:               35.14&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0127s&lt;br&gt;    total number of events:              128288&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.08&lt;br&gt;         max:                                    5.14&lt;br&gt;         95th percentile:                        0.34&lt;br&gt;         sum:                                 9977.78&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           128288.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9778/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;2147483648 bytes written in 19.29 seconds (106.16 MiB/sec).&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Extra file open flags: (none)&lt;br&gt;128 files, 16MiB each&lt;br&gt;2GiB total file size&lt;br&gt;Block size 16KiB&lt;br&gt;Number of IO requests: 0&lt;br&gt;Read/Write ratio for combined random IO test: 1.50&lt;br&gt;Periodic FSYNC enabled, calling fsync() each 100 requests.&lt;br&gt;Calling fsync() at the end of test, Enabled.&lt;br&gt;Using synchronous I/O mode&lt;br&gt;Doing random r/w test&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;File operations:&lt;br&gt;    reads/s:                      1593.12&lt;br&gt;    writes/s:                     1062.08&lt;br&gt;    fsyncs/s:                     3406.64&lt;br&gt;&lt;br&gt;Throughput:&lt;br&gt;    read, MiB/s:                  24.89&lt;br&gt;    written, MiB/s:               16.60&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0164s&lt;br&gt;    total number of events:              60600&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.16&lt;br&gt;         max:                                   31.32&lt;br&gt;         95th percentile:                        0.54&lt;br&gt;         sum:                                 9956.30&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           60600.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9563/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;2147483648 bytes written in 18.29 seconds (111.98 MiB/sec).&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Extra file open flags: (none)&lt;br&gt;128 files, 16MiB each&lt;br&gt;2GiB total file size&lt;br&gt;Block size 16KiB&lt;br&gt;Number of IO requests: 0&lt;br&gt;Read/Write ratio for combined random IO test: 1.50&lt;br&gt;Periodic FSYNC enabled, calling fsync() each 100 requests.&lt;br&gt;Calling fsync() at the end of test, Enabled.&lt;br&gt;Using synchronous I/O mode&lt;br&gt;Doing random r/w test&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;File operations:&lt;br&gt;    reads/s:                      1665.88&lt;br&gt;    writes/s:                     1110.59&lt;br&gt;    fsyncs/s:                     3563.77&lt;br&gt;&lt;br&gt;Throughput:&lt;br&gt;    read, MiB/s:                  26.03&lt;br&gt;    written, MiB/s:               17.35&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0112s&lt;br&gt;    total number of events:              63355&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.16&lt;br&gt;         max:                                  205.01&lt;br&gt;         95th percentile:                        0.78&lt;br&gt;         sum:                                 9972.64&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           63355.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9726/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R5&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;6&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;多线程&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 4&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0002s&lt;br&gt;    total number of events:              197956&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.16&lt;br&gt;         avg:                                    0.20&lt;br&gt;         max:                                    0.34&lt;br&gt;         95th percentile:                        0.21&lt;br&gt;         sum:                                39970.47&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           49489.0000/5.70&lt;br&gt;    execution time (avg/stddev):   9.9926/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 4&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0174s&lt;br&gt;    total number of events:              18360&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.57&lt;br&gt;         avg:                                    2.18&lt;br&gt;         max:                                   32.77&lt;br&gt;         95th percentile:                        2.61&lt;br&gt;         sum:                                40050.41&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           4590.0000/94.36&lt;br&gt;    execution time (avg/stddev):   10.0126/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 4&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0004s&lt;br&gt;    total number of events:              28536&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.23&lt;br&gt;         avg:                                    1.40&lt;br&gt;         max:                                    3.56&lt;br&gt;         95th percentile:                        1.47&lt;br&gt;         sum:                                39975.16&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           7134.0000/39.87&lt;br&gt;    execution time (avg/stddev):   9.9938/0.01&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;h2 id=&#34;后记&#34;&gt;后记
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ChatGPT&lt;/code&gt; 还是个好东西，上面的表格，按照以前掌握的&lt;code&gt;Markdown&lt;/code&gt;完全无法编排，不做成表格，展示的效果就会很差，自定义主题限制了页面最大宽度，同步调整了一波页面的配置，宽度改为百分比限制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单的方法，使用TablesGenerator等在线工具生成HTML表格（内容复杂不合适）&lt;/li&gt;
&lt;li&gt;或者使用谷歌在线文档编写，然后下载保存为HTML文档，直接复制到博客（简单直接，最终采用）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;确保 config 配置开启了 unsafe 配置项，单独给页面配置宽度&lt;/p&gt;
&lt;p&gt;在 Hugo 中，你可以为页面单独设置宽度。这可以通过在页面的 Front Matter 中添加自定义参数来实现。以下是一个示例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在你的 Markdown 页面的 Front Matter 部分（通常在文件的开头部分）添加一个自定义参数，例如 &lt;code&gt;custom_width&lt;/code&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;---
title: &amp;quot;我的页面&amp;quot;
date: 2024-01-09
custom_width: &amp;quot;800px&amp;quot;  # 设置宽度为 800 像素
---

正文内容...
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;在你的 Hugo 主题中，找到或创建对应的单页面模板文件（例如，&lt;code&gt;layouts/_default/single.html&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在单页面模板中，检查页面的 Front Matter 中是否有 &lt;code&gt;custom_width&lt;/code&gt; 参数，并将其应用到相应的 HTML 元素上，例如 &lt;code&gt;div&lt;/code&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{{ define &amp;quot;main&amp;quot; }}
  &amp;lt;div style=&amp;quot;max-width: {{ with .Params.custom_width }}{{ . }}{{ else }}100%{{ end }}; margin: 0 auto;&amp;quot;&amp;gt;
    {{ .Content }}
  &amp;lt;/div&amp;gt;
{{ end }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个示例中，我们使用了内联样式（&lt;code&gt;style&lt;/code&gt;属性）为 &lt;code&gt;div&lt;/code&gt; 元素设置了 &lt;code&gt;max-width&lt;/code&gt; 属性，使其在没有指定 &lt;code&gt;custom_width&lt;/code&gt; 参数时，宽度默认为100%。&lt;code&gt;margin: 0 auto;&lt;/code&gt; 用于将 &lt;code&gt;div&lt;/code&gt; 元素居中。&lt;/p&gt;
&lt;p&gt;请注意，实际应用中，你可能需要根据你的主题结构和CSS样式的细节来调整上述示例。确保在调整样式时保持主题的一致性和可读性。&lt;/p&gt;
&lt;p&gt;由于启用的主题稍微有些不同，最后调整了站点自定义的&lt;code&gt;CSS&lt;/code&gt;配置。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Git禁用http仓库</title>
        <link>https://ttf248.life/p/git-disable-http-repositories/</link>
        <pubDate>Mon, 08 Jan 2024 21:22:04 +0800</pubDate>
        
        <guid>https://ttf248.life/p/git-disable-http-repositories/</guid>
        <description>&lt;p&gt;习惯更新软件版本，不知道从哪个版本的&lt;code&gt;Git&lt;/code&gt;开始，禁止从&lt;code&gt;Http&lt;/code&gt;仓库拉取代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;fatal: Unencrypted HTTP is not supported for GitLab. Ensure the repository remote URL is using HTTPS
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;背景介绍&#34;&gt;背景介绍
&lt;/h2&gt;&lt;p&gt;环境：Windows 平台，一直用的都是小乌龟来操作git，配置秘钥也是通过小乌龟来处理的，之前弄过一次脚本，批量更新本地的仓库&lt;/p&gt;
&lt;p&gt;前文链接：&lt;a class=&#34;link&#34; href=&#34;https://ttf248.life/p/bulk-update-local-git-and-legacy-permissions/&#34; &gt;批量更新本地Git仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天回家执行代码更新的时候，出现了前面的报错，仓库无法正常更新了，本想着&lt;code&gt;Git&lt;/code&gt;应该提供了配置，让我继续使用&lt;code&gt;http&lt;/code&gt;的协议更新仓库，找了一圈，也没翻到对应的配置项。&lt;/p&gt;
&lt;p&gt;最简单的解决方案当然是切换成&lt;code&gt;ssh&lt;/code&gt;协议来更新仓库，公司配置的&lt;code&gt;gitlab&lt;/code&gt;短期内不会提供&lt;code&gt;https&lt;/code&gt;协议。&lt;/p&gt;
&lt;h2 id=&#34;遗留问题&#34;&gt;遗留问题
&lt;/h2&gt;&lt;p&gt;前面编写批量更新本地仓库脚本的是时候，本来想着使用&lt;code&gt;ssh&lt;/code&gt;的方式拉取仓库，也没细查是因为什么，通过小乌龟配置的&lt;code&gt;git&lt;/code&gt;配置信息并没有同步到 config 中，导致通过命令行执行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git pull #提示没有权限，无法正常更新仓库
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过命令检查秘钥配置也是正确的：&lt;code&gt;ssh -T git@gitlab.yintech.net&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果你使用Git小乌龟（TortoiseGit）能够正常拉取代码，但在命令行中使用 git pull 命令时提示秘钥不对，这可能是因为Git小乌龟使用的是PuTTY的SSH密钥，而命令行使用的是OpenSSH的SSH密钥。&lt;/p&gt;
&lt;p&gt;小乌龟的秘钥配置，不会从系统 .ssh 文件夹读取秘钥文件信息，而是通过界面仓库配置的时候，单独配置秘钥文件的路径，有用的小技巧：拉取的第一个仓库配置了秘钥即可让其余仓库都复用这个秘钥文件，PuTTY 加载秘钥以后，不会立即退出，而是启动了一个代理服务。&lt;/p&gt;
&lt;p&gt;通过调整全局配置，不使用系统默认的&lt;code&gt;ssh&lt;/code&gt;配置，这样配置后，Git Bash 将使用 TortoisePlink 进行 SSH 操作。这种配置适用于使用 TortoiseGit 自带的 PuTTY 工具的情况。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global core.sshCommand &amp;quot;&#39;C:/Program Files/TortoiseGit/bin/TortoisePlink.exe&#39; -batch -ssh&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面配置的执行文件文件路径自行修改到对应的小乌龟路径，由于配置的完整路径，无需添加路径到系统环境变量中。&lt;/p&gt;</description>
        </item>
        <item>
        <title>AI编程和任务拆解</title>
        <link>https://ttf248.life/p/ai-programming-and-task-decomposition/</link>
        <pubDate>Fri, 22 Dec 2023 08:44:26 +0800</pubDate>
        
        <guid>https://ttf248.life/p/ai-programming-and-task-decomposition/</guid>
        <description>&lt;p&gt;两年前给站点添加代码区域的拷贝功能，前后折腾了小半天，最终渲染效果有点不如意，作为半吊子前端开发，也没想着改进，能用就行，今年用&lt;code&gt;AI&lt;/code&gt;开发了小程序，对于前端的开发也更加熟悉了，重构一波（AI重新设计）。&lt;/p&gt;
&lt;p&gt;悟道：任务拆解开，很多小任务，&lt;code&gt;AI&lt;/code&gt;开发起来还是顺手的。已经倒闭的小程序，&lt;code&gt;75%&lt;/code&gt;代码由&lt;code&gt;AI&lt;/code&gt;提供，拆解了多个任务交付，人工进行项目代码的&lt;code&gt;组装&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;前文&#34;&gt;前文
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://ttf248.github.io/post/2022/001-%E4%BB%A5%E4%B8%BA%E5%BE%88%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E6%83%85%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E5%A4%8D%E5%88%B6%E6%8C%89%E9%92%AE/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;以为很简单的事情，增加一个代码复制按钮&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;promot&lt;/strong&gt;: 设计 css 和 JavaScript 代码，定位网页元素 class=&amp;ldquo;highlight&amp;rdquo;，这个元素的容器内，添加一个 复制按钮，实现复制代码的功能&lt;/p&gt;
&lt;p&gt;给的第一稿代码一眼看上去就有问题，重新生成一稿，基本可用，复制的内容不对，有冗余的文字，再次引导优化，人工指定核心的颜色设计，包含哪些特效&lt;/p&gt;
&lt;p&gt;了解到您对按钮的尺寸和颜色有特定的要求，我们可以重新设计按钮的样式以适应这些要求。以下是一个调整后的 CSS 样式，其中包括了您提供的颜色方案，并对按钮的尺寸进行了优化：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.copy-btn {
  position: absolute;
  top: 2px; /* 调整位置 */
  right: 2px;
  padding: 3px 6px; /* 缩小尺寸 */
  font-size: 12px; /* 减小字体大小 */
  background-color: #8FD1E1; /* 按钮背景色 */
  color: #272822; /* 文字颜色 */
  border: 1px solid #272822; /* 边框颜色 */
  border-radius: 3px; /* 圆角 */
  cursor: pointer;
  opacity: 0.7; /* 默认半透明 */
  transition: opacity 0.3s ease, background-color 0.3s ease; /* 平滑过渡效果 */
}

.copy-btn:hover {
  opacity: 1; /* 鼠标悬停时不透明 */
  background-color: #A3D4E5; /* 鼠标悬停时的背景色 */
}

.highlight {
  position: relative;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个样式中，我减小了按钮的尺寸和字体大小，使其更加精致。同时，按钮的默认状态是半透明的，当鼠标悬停在按钮上时，它会变为不透明，并且背景色会变得稍微亮一些，以提供视觉反馈。这样的设计既符合您的颜色要求，又保持了现代化和用户友好的特点。&lt;/p&gt;
&lt;p&gt;对应的提供了一份更简单的 &lt;code&gt;JavaScript&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;document.addEventListener(&#39;DOMContentLoaded&#39;, function() {
  // 查找所有 .highlight 元素
  const highlights = document.querySelectorAll(&#39;.highlight&#39;);

  highlights.forEach(function(highlight) {
    // 创建复制按钮
    const copyBtn = document.createElement(&#39;button&#39;);
    copyBtn.textContent = &#39;复制&#39;;
    copyBtn.classList.add(&#39;copy-btn&#39;);

    // 将按钮添加到每个 .highlight 元素中
    highlight.appendChild(copyBtn);

    // 添加点击事件监听器
    copyBtn.addEventListener(&#39;click&#39;, function() {
      // 假设 .highlight 下的第一个 &amp;lt;code&amp;gt; 元素包含要复制的代码
      const code = highlight.querySelector(&#39;code&#39;) ? highlight.querySelector(&#39;code&#39;).textContent : &#39;&#39;;

      navigator.clipboard.writeText(code).then(() =&amp;gt; {
        // 显示复制成功信息
        copyBtn.textContent = &#39;已复制!&#39;;
        setTimeout(() =&amp;gt; {
          copyBtn.textContent = &#39;复制&#39;;
        }, 2000);
      }).catch(err =&amp;gt; {
        console.error(&#39;复制失败: &#39;, err);
      });
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;后记&#34;&gt;后记
&lt;/h2&gt;&lt;p&gt;虽说我更期望在代码区域的右上角，顶部区域新增复制按钮，由于对前端不够了解，无法基于关键词准确描述功能，和&lt;code&gt;AI&lt;/code&gt;来回折腾几个回合也没有达到预期。&lt;/p&gt;
&lt;p&gt;就是不知道随着时间的发展，&lt;code&gt;AI&lt;/code&gt;对于程序开发会有多大的影响。&lt;/p&gt;</description>
        </item>
        <item>
        <title>云服务器和脚本小子</title>
        <link>https://ttf248.life/p/cloud-servers-and-script-kids/</link>
        <pubDate>Mon, 20 Nov 2023 15:08:53 +0800</pubDate>
        
        <guid>https://ttf248.life/p/cloud-servers-and-script-kids/</guid>
        <description>&lt;p&gt;趁着双十一搞活动，阿里云新入手了一台服务器：经济适用版本，99一年，配置不高，作为跳板机代理家里的服务也是不错的，活动持续到2026年。&lt;/p&gt;
&lt;p&gt;特意选了上海地区的服务器，低延迟代理家里的机器，win11 和 windows server 2022，server 版本是后面部署的，使用的时候，突然收到拒绝访问的消息，本来以为是服务器更新，等会就能恢复正常。隔了五分钟，再去尝试，依旧拒绝登录，检索相关的报错，提示有人正在尝试登录，并且由于密码错误次数太多，现在无法登录。&lt;/p&gt;
&lt;p&gt;以前也是接触过安防攻击的脚本，立马就想到了，这些登录大概率不是正常的行为，是有人在攻击服务，尝试暴力破解登录服务器。服务器防火墙设置图省事，没有设置白名单，代理了两台机器的 3389 端口，在公网里面暴露出来，就和鱼塘里面的鱼饵差不多。既然知道了是脚本小子在攻击，接下来的事情就简单了，设置防火墙白名单，仅允许公司的IP地址和家里的IP地址访问代理服务。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;frps&lt;/code&gt;代理服务端以前也没配置运行日志，开启日志后，给我看乐了，全国各地的代理IP，都在尝试登录家里的服务器，还好有一台是 server 版本，让我意识到了问题，不然 win11 那台机器，迟早别攻破，密码设置的比较简单。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;2023/11/17 16:51:14 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [101.43.98.211:50486]
2023/11/17 16:51:14 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [218.93.202.63:56970]
2023/11/17 16:51:14 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [222.179.106.174:60812]
2023/11/17 16:51:15 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [58.16.204.238:2839]
2023/11/17 16:51:15 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [124.223.47.24:50274]
2023/11/17 16:51:16 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [43.248.128.22:55883]
2023/11/17 16:51:16 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [43.143.53.138:56955]
2023/11/17 16:51:16 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [43.228.7.250:61550]
2023/11/17 16:51:16 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [125.76.228.9:55842]
2023/11/17 16:51:17 [I] [proxy.go:204] [4dfcc2259937dcb9] [winserver-remote] get a user connection [91.240.118.187:49326]
2023/11/17 16:51:17 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [91.240.118.187:49324]
2023/11/17 16:51:17 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [89.248.163.79:51712]
2023/11/17 16:51:18 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [218.63.75.24:62387]
2023/11/17 16:51:19 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [103.186.109.227:51396]
2023/11/17 16:51:20 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [116.233.234.104:51567]
2023/11/17 16:51:20 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [222.187.193.202:51585]
2023/11/17 16:51:20 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [59.48.98.42:57489]
2023/11/17 16:51:20 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [146.56.241.134:53558]
2023/11/17 16:51:21 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [222.179.106.174:30620]
2023/11/17 16:51:23 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [183.14.214.51:62128]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;捎带手，查了下linux服务的登录日志，除开阿里云这台机器，还有朋友一台华为云的机器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo grep &amp;quot;Failed password&amp;quot; /var/log/secure  centos系列
sudo grep &amp;quot;Failed password&amp;quot; /var/log/auth.log  ubuntu系列
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Nov 16 04:46:34 aliyun-sh sshd[156625]: Failed password for root from 120.55.164.64 port 53410 ssh2
Nov 16 04:46:34 aliyun-sh sshd[156623]: Failed password for root from 111.16.215.122 port 36548 ssh2
Nov 16 04:46:58 aliyun-sh sshd[156630]: Failed password for invalid user share from 139.9.233.78 port 53872 ssh2
Nov 16 04:47:23 aliyun-sh sshd[156634]: Failed password for invalid user spark from 139.9.233.78 port 36134 ssh2
Nov 16 04:47:26 aliyun-sh sshd[156636]: Failed password for root from 120.55.164.64 port 46142 ssh2
Nov 16 04:47:47 aliyun-sh sshd[156640]: Failed password for root from 111.16.215.122 port 42962 ssh2
Nov 16 04:48:24 aliyun-sh sshd[156652]: Failed password for root from 120.55.164.64 port 38868 ssh2
Nov 16 04:48:25 aliyun-sh sshd[156654]: Failed password for root from 111.16.215.122 port 46164 ssh2
Nov 16 04:48:39 aliyun-sh sshd[156657]: Failed password for invalid user test from 139.9.233.78 port 39386 ssh2
Nov 16 04:48:50 aliyun-sh sshd[156659]: Failed password for root from 111.16.215.122 port 38892 ssh2
Nov 16 04:48:53 aliyun-sh sshd[156662]: Failed password for root from 120.55.164.64 port 49348 ssh2
Nov 16 04:48:53 aliyun-sh sshd[156664]: Failed password for invalid user test from 139.9.233.78 port 49864 ssh2
Nov 16 04:50:02 aliyun-sh sshd[156672]: Failed password for root from 111.16.215.122 port 45294 ssh2
Nov 16 04:50:30 aliyun-sh sshd[156680]: Failed password for invalid user zabbix from 139.9.233.78 port 52206 ssh2
Nov 16 04:50:50 aliyun-sh sshd[156683]: Failed password for root from 120.55.164.64 port 34820 ssh2
Nov 16 04:50:51 aliyun-sh sshd[156685]: Failed password for root from 111.16.215.122 port 58978 ssh2
Nov 16 04:51:18 aliyun-sh sshd[156689]: Failed password for root from 120.55.164.64 port 45306 ssh2
Nov 16 04:51:25 aliyun-sh sshd[156692]: Failed password for root from 111.16.215.122 port 33938 ssh2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;华为云这台机器开启的时间比较长，已经开始进入字典爆破的中期，各种奇怪的用户都开始出现。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Nov 16 20:30:35 hecs-411458 sshd[182965]: Failed password for invalid user oeh from 39.129.9.180 port 26459 ssh2
Nov 16 20:32:17 hecs-411458 sshd[182967]: Failed password for invalid user dnu from 39.129.9.180 port 27079 ssh2
Nov 16 20:34:12 hecs-411458 sshd[182971]: Failed password for invalid user rq from 39.129.9.180 port 27742 ssh2
Nov 16 20:36:07 hecs-411458 sshd[182979]: Failed password for invalid user zw from 39.129.9.180 port 28415 ssh2
Nov 16 20:37:59 hecs-411458 sshd[182981]: Failed password for invalid user egi from 39.129.9.180 port 29068 ssh2
Nov 16 20:39:52 hecs-411458 sshd[182984]: Failed password for invalid user bjb from 39.129.9.180 port 29723 ssh2
Nov 16 20:41:53 hecs-411458 sshd[182988]: Failed password for invalid user hna from 39.129.9.180 port 30375 ssh2
Nov 16 20:43:46 hecs-411458 sshd[182994]: Failed password for invalid user gar from 39.129.9.180 port 31036 ssh2
Nov 16 20:45:40 hecs-411458 sshd[183003]: Failed password for invalid user mze from 39.129.9.180 port 31703 ssh2
Nov 16 20:47:35 hecs-411458 sshd[183007]: Failed password for invalid user tmh from 39.129.9.180 port 32381 ssh2
Nov 16 21:23:01 hecs-411458 sshd[183047]: Failed password for invalid user amax from 112.4.65.118 port 41188 ssh2
Nov 16 22:31:20 hecs-411458 sshd[183116]: Failed password for root from 211.228.203.123 port 60213 ssh2
Nov 16 22:53:44 hecs-411458 sshd[183162]: Failed password for root from 112.132.249.164 port 39272 ssh2
Nov 17 11:44:26 hecs-411458 sshd[184811]: Failed password for invalid user jsh from 43.157.103.27 port 54608 ssh2
Nov 17 11:47:23 hecs-411458 sshd[184818]: Failed password for invalid user mrunal from 43.157.103.27 port 50448 ssh2
Nov 17 11:48:46 hecs-411458 sshd[184820]: Failed password for invalid user robertsheen from 43.157.103.27 port 50560 ssh2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;后记&#34;&gt;后记
&lt;/h2&gt;&lt;p&gt;开发自用的服务器，windows 公网访问需要设置白名单，linux 建议禁止密码登录，开启秘钥文件登录。&lt;/p&gt;</description>
        </item>
        <item>
        <title>批量更新本地Git仓库和历史遗留的权限问题</title>
        <link>https://ttf248.life/p/bulk-update-local-git-and-legacy-permissions/</link>
        <pubDate>Thu, 19 Oct 2023 14:16:22 +0800</pubDate>
        
        <guid>https://ttf248.life/p/bulk-update-local-git-and-legacy-permissions/</guid>
        <description>&lt;p&gt;组里的项目之间存在依赖关系，由于历史原因，并未使用&lt;code&gt;submodule&lt;/code&gt;维护项目的依赖，日常开发需要手动依次更新仓库代码，否则可能碰到各种奇怪的问题。&lt;/p&gt;
&lt;p&gt;参考网上的资料，结构基本都类似，本地手动维护一份仓库目录：&lt;strong&gt;git_list.txt&lt;/strong&gt;，编写脚本遍历目录，一次执行更新，以后开工前先执行下脚本&lt;/p&gt;
&lt;h2 id=&#34;linux&#34;&gt;linux
&lt;/h2&gt;&lt;p&gt;create new file: batch_pull.sh&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash

echo &amp;quot;============ 更新仓库 ===================&amp;quot;

# 检查 git_list.txt 是否存在
if [ ! -f &amp;quot;git_list.txt&amp;quot; ]; then
  echo &amp;quot;git_list.txt 文件不存在！请创建并添加要拉取的 git 仓库 URL。&amp;quot;
  exit 1
else
  echo &amp;quot;============ 检测到了 git 仓库清单文件 ====&amp;quot;
fi

# 逐行读取 git_list.txt 中的 URL，并执行拉取操作
while read -r url; do
  if [ -d &amp;quot;$url&amp;quot; ]; then
    cd &amp;quot;$url&amp;quot; || continue
    git pull
    cd ..
    echo &amp;quot;Pull $url 完成！&amp;quot;
    echo &amp;quot;========================================&amp;quot;
  else
    echo &amp;quot;目录 $url 不存在，跳过拉取。&amp;quot;
  fi
done &amp;lt; &amp;quot;git_list.txt&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;windows&#34;&gt;windows
&lt;/h2&gt;&lt;p&gt;create a new file: batch_pull.bat&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bat&#34;&gt;@echo off
chcp 65001 &amp;gt; nul
rem 进入脚本所在目录
cd /d &amp;quot;%~dp0&amp;quot;

rem 检查 git_list.txt 是否存在
if not exist &amp;quot;git_list.txt&amp;quot; (
  echo git_list.txt 文件不存在！请创建并添加要拉取的 git 仓库 URL。
  exit /b 1
) else (
  echo ============ 检测到了 git 仓库清单文件 ====
)

rem 逐行读取 git_list.txt 中的 URL，并执行拉取操作
for /f %%i in (git_list.txt) do (
  if exist &amp;quot;%%i&amp;quot; (
    pushd &amp;quot;%%i&amp;quot;
    git pull
    popd
    echo Pull %%i 完成！
    echo ========================================
  ) else (
    echo 目录 %%i 不存在，跳过拉取。
  )
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;历史遗留问题&#34;&gt;历史遗留问题
&lt;/h3&gt;&lt;p&gt;顺带处理重装系统以后碰到的&lt;code&gt;git&lt;/code&gt;文件夹权限文件：&lt;strong&gt;Fatal error &amp;ldquo;unsafe repository (&amp;rsquo;/home/repon&amp;rsquo; is owned by someone else)&amp;rdquo;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网上建议的做法大多来源自&lt;code&gt;stack overflow&lt;/code&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;仓库目录添加信任: &lt;code&gt;git config --global --add safe.directory /home/repon&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;手动修改配置文件&lt;code&gt;.gitconfig&lt;/code&gt;，指定目录添加信任&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[safe]
    directory = /home/repon
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的方式处理以后，仓库更新是正常了，每次执行&lt;code&gt;git pull&lt;/code&gt;控制台都有很多警告信息，提示用户所有者错误&lt;/p&gt;
&lt;h3 id=&#34;台式机重装系统&#34;&gt;台式机重装系统
&lt;/h3&gt;&lt;p&gt;开发的机器，太久没有重装系统，系统盘垃圾文件爆炸，没辙，抽空重装了一波系统，再次碰到这个权限的问题，以前的脚本跑不通，修改的权限不完整&lt;/p&gt;
&lt;p&gt;用上新的方案，直接添加&lt;code&gt;*&lt;/code&gt;，这样&lt;code&gt;git&lt;/code&gt;会自动信任所有目录&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global --add safe.directory &amp;quot;*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;不知道是用户权限的问题，还是大家没习惯&lt;code&gt;windows&lt;/code&gt;平台其实也有类似&lt;code&gt;chown&lt;/code&gt;的命令，修改文件夹所有者，当然如果你的目录不多，手动修改所有者也行，但是这台工作电脑添加了域信息，不知道是公司部署的域存在异常，还是本地系统设置存在异常，用户清单中，找不到登录所用的用户，最后还是通过命令行处理的。&lt;/p&gt;
&lt;p&gt;管理员权限，执行&lt;code&gt;powershell&lt;/code&gt;脚本&lt;code&gt;change_ower.ps1&lt;/code&gt;，记得调整脚本文件编码为&lt;code&gt;gbk&lt;/code&gt;，中文操作系统，这样才不会乱码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;# 获取当前用户的用户名
$currentUserName = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name

# 设置 PowerShell 的字符编码为 UTF-8
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8

# 要更改所有者的根目录路径
$rootDirectory = &amp;quot;G:\workspace&amp;quot;  # 替换为实际的目录路径

# 递归遍历目录并更改文件和文件夹的所有者
Get-ChildItem -Path $rootDirectory -Recurse | ForEach-Object {
    $itemPath = $_.FullName

    # 检查是文件还是文件夹
    if ($_ -is [System.IO.DirectoryInfo]) {
        # 如果是文件夹，使用 icacls 更改所有者权限
        $icaclsResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            Write-Host &amp;quot;已更改文件夹 $itemPath 的所有者为 $currentUserName&amp;quot;
        } else {
            Write-Host &amp;quot;无法更改文件夹 $itemPath 的所有者。错误信息: $icaclsResult&amp;quot;
        }
    } else {
        # 如果是文件，使用 icacls 更改所有者权限
        $takeownResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            # Write-Host &amp;quot;已更改文件 $itemPath 的所有者为 $currentUserName&amp;quot;
        } else {
            Write-Host &amp;quot;无法更改文件 $itemPath 的所有者。错误信息: $takeownResult&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不出意外的还是出现了预料之外的情况，脚本执行输出的中文信息乱，尝试设置控制台的字符编码，调整脚本编码，输出的都是乱码，脑子那会大概率不清醒了，试着启用 控制面板-区域-语言设置的 beta 功能，全局开启 Unicode 编码，脚本执行是正常了，好几个开发软件都无法正常工作，回头梳理资料才想起来，调整脚本文件的编码，设置为 &lt;code&gt;gbk&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;资料&#34;&gt;资料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://ganzhixiong.com/p/f1b9f4fc/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ganzhixiong.com/p/f1b9f4fc/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/71901632/fatal-error-unsafe-repository-home-repon-is-owned-by-someone-else&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stackoverflow.com/questions/71901632/fatal-error-unsafe-repository-home-repon-is-owned-by-someone-else&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>WPF学习资料</title>
        <link>https://ttf248.life/p/wpf-learning-resources/</link>
        <pubDate>Tue, 17 Oct 2023 10:49:24 +0800</pubDate>
        
        <guid>https://ttf248.life/p/wpf-learning-resources/</guid>
        <description>&lt;p&gt;小程序开发设计的坑还没填上，新挖一个&lt;strong&gt;WPF&lt;/strong&gt;，最近公司也动荡了一波，异地协同办公沟通总归效率总归有点不如意，索性承接了客户端界面的开发。&lt;/p&gt;
&lt;h2 id=&#34;wpf&#34;&gt;WPF
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;推荐 &lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/dotnet/desktop/wpf/introduction-to-wpf?view=netframeworkdesktop-4.8&amp;amp;preserve-view=true&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 微软官网学习资料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/zh7791/p/11502696.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 基础总结(学习建议)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.wpfsoft.com/introduction&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 中文网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/638815741&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 个人总结和学习推荐&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;WPF&lt;/code&gt; 界面设计用到的很多概念，类似于网页前端设计，尽可能的剥离UI设计和业务逻辑，让UI的设计能独立出来，也是互联网公司期望的分工方式。今年刚好折腾过小程序，很多概念上的东西都是通用的，上手也就比较轻松，这些算是现代UI设计中的&lt;strong&gt;道&lt;/strong&gt;，掌握了基础的框架概念，后面的路不容易走歪。&lt;/p&gt;
&lt;p&gt;以前有&lt;code&gt;Winform&lt;/code&gt;开发经验的读者，推荐阅读：&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/zh7791/p/11502696.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 基础总结(学习建议)&lt;/a&gt;，篇幅不长，适合有经验的读者规划学习路线&lt;/p&gt;
&lt;p&gt;零基础的读者推荐阅读：&lt;a class=&#34;link&#34; href=&#34;http://www.wpfsoft.com/introduction&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 中文网&lt;/a&gt;，从零开始介绍基础的概念、发展的历史、底层类的认知逻辑。这个网站说来也是巧了，今年八月份作者刚发布的，用来吸引读者购买课程，和我这边的时间刚好对上了，如果再晚一点，和我大概率也就没有缘分了。&lt;/p&gt;
&lt;p&gt;想要最正统的学习资料，当然是微软官网的资料，有些枯燥，新读者需要有耐心。&lt;/p&gt;
&lt;p&gt;经典的电子书籍也有很多，不是很推荐，日常工作的事情也多，静下来看书的时间并不是很多，很难一下子就进入看书的状态，带着项目练习更合适一些。&lt;/p&gt;
&lt;h2 id=&#34;c-和net-发布历史&#34;&gt;C# 和.net 发布历史
&lt;/h2&gt;&lt;p&gt;想对于以前学习的语言，最近几年，发布的新特性稍微有点多，语法的版本每年都在迭代。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/C_Sharp_%28programming_language%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://en.wikipedia.org/wiki/C_Sharp_(programming_language)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方学习资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/dotnet/csharp/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/dotnet/csharp/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/dotnet/core/tutorials/with-visual-studio?pivots=dotnet-7-0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/dotnet/core/tutorials/with-visual-studio?pivots=dotnet-7-0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>异地局域网ZeroTier</title>
        <link>https://ttf248.life/p/zero-tier-remote-lan/</link>
        <pubDate>Tue, 19 Sep 2023 04:58:03 +0800</pubDate>
        
        <guid>https://ttf248.life/p/zero-tier-remote-lan/</guid>
        <description>&lt;p&gt;办公室新入手一台&lt;code&gt;mini&lt;/code&gt;主机，想着配置配置环境方便，在家偶尔也有访问的需求，临时部署内网穿透。按照以往的经验，部署&lt;code&gt;frp&lt;/code&gt;服务，指定端口转发，需要一台公网的服务器，连接的质量取决于公网服务器的宽带质量。折腾一点新鲜的&lt;code&gt;Zerotier&lt;/code&gt;虚拟机局域网，类似于&lt;code&gt;VPN&lt;/code&gt;，本地新建虚拟网卡，所有的机器都加入到一个虚拟网络中。&lt;/p&gt;
&lt;h2 id=&#34;什么是-zerotier&#34;&gt;什么是 Zerotier
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ZeroTier&lt;/code&gt;是一种软件定义的广域网络（&lt;code&gt;SD-WAN&lt;/code&gt;）解决方案，它允许用户在不同地理位置的设备之间创建安全的虚拟网络。通过&lt;code&gt;ZeroTier&lt;/code&gt;，您可以轻松地将多台计算机、服务器和设备连接到一个虚拟的、加密的网络中，就好像它们在同一局域网中一样。这可以帮助程序员和IT专业人员在不同地点之间安全地共享数据和资源，而无需复杂的网络设置和VPN配置。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Zerotier网络&lt;/strong&gt;：Zerotier网络是一个虚拟的、全球性的局域网络，允许不同设备通过互联网连接在一起，就好像它们在同一个物理网络上一样。这个网络可以包含多个子网，所有设备都通过Zerotier的技术连接在一起。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;行星服务器&lt;/strong&gt;：行星服务器是Zerotier网络的关键组件之一。它是全球性的，负责维护和管理整个Zerotier网络的拓扑结构、路由信息和网络状态。行星服务器起到全局的网络控制中心作用，但不直接传输数据。用户的设备需要连接至少一个行星服务器来参与Zerotier网络。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;中转服务器&lt;/strong&gt;：中转服务器是Zerotier网络中的辅助节点，用于帮助设备之间建立直接通信通道。当设备之间无法直接连接时，它们可以通过中转服务器来传输数据。这有助于提高网络的可达性和性能。中转服务器通常位于全球各地，充当数据传输的中转点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总的来说，Zerotier通过行星服务器和中转服务器的协助，使设备能够在全球范围内创建虚拟的局域网络，实现安全、快速的设备之间通信。行星服务器负责全局网络管理，而中转服务器则帮助设备在需要时建立通信连接。&lt;/p&gt;
&lt;h2 id=&#34;安装部署&#34;&gt;安装部署
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;访问 ZeroTier 官方网站（&lt;a class=&#34;link&#34; href=&#34;https://www.zerotier.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.zerotier.com/&lt;/a&gt;）以获取安装文件和文档。&lt;/li&gt;
&lt;li&gt;根据您的操作系统下载和安装ZeroTier One客户端。支持Windows、macOS、Linux和许多其他平台。&lt;/li&gt;
&lt;li&gt;安装完成后，启动ZeroTier One客户端。&lt;/li&gt;
&lt;li&gt;注册一个ZeroTier账户，如果您还没有账户的话。您可以在客户端中创建一个账户。&lt;/li&gt;
&lt;li&gt;登录您的ZeroTier账户并创建一个新的网络。网络将会有一个唯一的16位ID，您需要记住它。&lt;/li&gt;
&lt;li&gt;在您的设备上加入这个网络。您可以在客户端中输入网络ID或使用QR码扫描功能。&lt;/li&gt;
&lt;li&gt;安装并配置ZeroTier客户端的设备将会被添加到同一虚拟网络中。这些设备之间现在可以直接通信，就好像它们在同一局域网中一样。&lt;/li&gt;
&lt;li&gt;您可以在ZeroTier的控制面板中管理网络设置、添加设备和监视网络流量等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;安装部署-moon&#34;&gt;安装部署 moon
&lt;/h2&gt;&lt;p&gt;国内运营商很多都禁止了&lt;code&gt;UDP&lt;/code&gt;打洞，&lt;code&gt;frp&lt;/code&gt;服务稳定，由于走的&lt;code&gt;tcp&lt;/code&gt;协议，&lt;code&gt;Zerotier&lt;/code&gt;部署中转服务器也能实现类似的效果，防火墙需要开放&lt;code&gt;udp 9993&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -s https://install.zerotier.com/ | sudo bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;检查安装是否成功&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zerotier-cli info
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加入到局域网&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zerotier-cli join network-id
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建 &lt;code&gt;moon&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd /var/lib/zerotier-one &amp;amp;&amp;amp; sudo zerotier-idtool initmoon identity.public &amp;gt; moon.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编辑配置文件，调整&lt;code&gt;stableEndpoints&lt;/code&gt;节点，&amp;ldquo;服务器公网ip/9993&amp;rdquo;&lt;/p&gt;
&lt;p&gt;生成签名配置，创建&lt;code&gt;moons.d&lt;/code&gt;文件夹，前面文件文件移动到此，重启服务&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo zerotier-idtool genmoon moon.json
mkdir moons.d &amp;amp;&amp;amp; mv 000000eb444ec0d8.moon moons.d/
systemctl restart zerotier-one.service
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;客户端节点加入 moon 服务器, id 取自前面 json 配置文件中的 id 字段&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zerotier-cli.bat orbit ztaddr ztaddr
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 观察是否出现新的 mooon 节点，id 和信息为服务器配置的相同
[root@idv-36f9d5 ~]# zerotier-cli listpeers
200 listpeers &amp;lt;ztaddr&amp;gt; &amp;lt;path&amp;gt; &amp;lt;latency&amp;gt; &amp;lt;version&amp;gt; &amp;lt;role&amp;gt;
200 listpeers 0cccb***** 35.236.*.*/64393;110;10726 327 1.6.3 LEAF
200 listpeers 3a46f***** 185.180.*.*/9993;110;757 -1 - PLANET
200 listpeers 3ed7c***** 39.97.*.*/9993;172;79 32 1.6.3 MOON
200 listpeers 4f838***** - -1 - LEAF
200 listpeers 62f86***** 50.7.*.*/9993;110;4796 351 - PLANET
200 listpeers 778cd***** 103.195.*.*/9993;5148;4887 253 - PLANET
200 listpeers 992fc***** 195.181.*.*/9993;10161;4921 226 - PLANET
200 listpeers 9d2b5***** - -1 - LEAF
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;windows 平台通过管理员权限启动终端，通过 zerotier-cli.bat 命令行操作，Linux 平台通过 zerotier-cli 操作；peers 子命令查看连接、listpeers查看所有节点，能正常展示 &lt;code&gt;moon&lt;/code&gt; 节点表示加入成功&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;如何卸载&#34;&gt;如何卸载
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Windows&lt;/code&gt;平台如何卸载不再赘述，常规操作，通过控制面板卸载即可，我们重点说下&lt;code&gt;ubuntu&lt;/code&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过dpkg删除zerotier-one服务&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo dpkg -P zerotier-one
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;删除zerotier-one文件夹，该文件夹存储了address地址，删除后再次安装会获得新的address地址&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo rm -rf /var/lib/zerotier-one/
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;后记&#34;&gt;后记
&lt;/h2&gt;&lt;p&gt;原本都是已经卸载了，服务器到了，没有合适的服务作为代理节点，阿里云搞业绩，提供了开发特供服务器，配置不高，99一年，价格实惠，弄了两年。看中的就是服务器提供的带宽。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.wnark.com/archives/152.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.wnark.com/archives/152.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/Yogile/p/12642423.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cnblogs.com/Yogile/p/12642423.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>VMware 虚拟机磁盘空间优化</title>
        <link>https://ttf248.life/p/vmware-virtual-machine-disk-space-optimization/</link>
        <pubDate>Wed, 21 Jun 2023 18:35:41 +0800</pubDate>
        
        <guid>https://ttf248.life/p/vmware-virtual-machine-disk-space-optimization/</guid>
        <description>&lt;p&gt;&lt;code&gt;vmware&lt;/code&gt;虚拟机安装开发系统的时候，一般都会多预留点磁盘空间，用的时间长了，本地占用的磁盘空间远超虚拟机实际文件的内容。&lt;/p&gt;
&lt;h2 id=&#34;场景描述&#34;&gt;场景描述
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;df -h&lt;/code&gt;命令，查看当前机器的磁盘信息，实际用了 60G，删掉所有的快照和克隆镜像，本地虚拟机占用的磁盘空间依旧远大于 60G，让本就不富裕的硬盘，雪上加霜。&lt;/p&gt;
&lt;h2 id=&#34;前置条件&#34;&gt;前置条件
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;虚拟机安装的时候，没有勾选预分配磁盘&lt;/li&gt;
&lt;li&gt;本地存放虚拟机的硬盘，剩余的磁盘空间大于当前虚拟机所占用的空间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;剩余的空间不足，可以考虑临时移动虚拟机到移动硬盘，优化了磁盘以后再迁移回来。&lt;/p&gt;
&lt;h2 id=&#34;工具&#34;&gt;工具
&lt;/h2&gt;&lt;p&gt;官方提供了&lt;code&gt;open-vm-tools&lt;/code&gt;包，可以通过 yum 安装或者 vmware-tools 镜像包安装&lt;/p&gt;
&lt;h2 id=&#34;命令&#34;&gt;命令
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vmware-toolbox-cmd disk shrink /
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行了以后，虚拟机会自动关机，vmware 宿主程序会执行磁盘压缩，执行时间取决于虚拟机的体积和磁盘的访问速度。&lt;/p&gt;
&lt;p&gt;执行效果还是很不错的，虚拟机的磁盘空间占用基本等于&lt;code&gt;df -h&lt;/code&gt;的磁盘信息。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Stable-diffusion-从零安装的恩怨情仇</title>
        <link>https://ttf248.life/p/stable-diffusion-zero-install-story/</link>
        <pubDate>Thu, 13 Apr 2023 00:23:54 +0800</pubDate>
        
        <guid>https://ttf248.life/p/stable-diffusion-zero-install-story/</guid>
        <description>&lt;p&gt;国内的资料，基本都在推荐&lt;strong&gt;秋叶&lt;/strong&gt;大佬的一键部署包，想着都是基于&lt;code&gt;Python&lt;/code&gt;的开源项目，部署也不会很复杂，试试从零开始。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;折腾AI生成图，特意更换了显卡，&lt;code&gt;3060 12g&lt;/code&gt;入门版本；服役七年的&lt;code&gt;960&lt;/code&gt;光荣下线&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;核心的&lt;code&gt;pytorch cuda&lt;/code&gt;安装，以前编写&lt;code&gt;pyhton&lt;/code&gt;游戏辅助脚本时，本地安装过，没想到还是碰到坑，&lt;code&gt;cuda&lt;/code&gt;加密一直无法激活。&lt;/p&gt;
&lt;h2 id=&#34;待处理&#34;&gt;待处理
&lt;/h2&gt;&lt;p&gt;1.重新规划文章结构，先介绍 pytorch，版本的对应关系，如何查看版本
2.本地如何从零开始新建虚拟环境，部署 Pytorch
3.翻译稿子，从零开始 stable diffusion &lt;a class=&#34;link&#34; href=&#34;https://stable-diffusion-art.com/install-windows/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stable-diffusion-art.com/install-windows/&lt;/a&gt;
4.整理参考资料&lt;/p&gt;
&lt;h2 id=&#34;步骤&#34;&gt;步骤
&lt;/h2&gt;&lt;p&gt;用中文搜索可能找不到相关一步一步安装的教程。在&lt;code&gt;Google&lt;/code&gt;里面你用英文去搜索，有很多类似的教程，就是从零开始。介绍了一下，我们需要安装&lt;code&gt;git&lt;/code&gt;，然后又说明了一下，我们需要安装&lt;code&gt;python&lt;/code&gt;。然后就是你去把仓库下载过来，直接双击脚本搞定了。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/AUTOMATIC1111/stable-diffusion-webui&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;详细的使用和答疑，翻看&lt;code&gt;issues&lt;/code&gt;，&lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我也不知道为什么就没人解释这个仓库是干嘛的。其实从名字也不难看出来，它是一个界面控制台，让我们用起来更方便。实际上在安装的时候，他会去下载官方的仓库内容，获取实际的&lt;code&gt;SD&lt;/code&gt;代码。&lt;/p&gt;
&lt;p&gt;仓库呢同时也做了一个安装启动脚本。会自动识别当前文件夹，是否有&lt;code&gt;Python&lt;/code&gt;虚拟环境。如果有的话默认使用当前路径的的&lt;code&gt;python&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果是纯小白用户，建议看一下：&lt;a class=&#34;link&#34; href=&#34;https://stable-diffusion-art.com/install-windows/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stable-diffusion-art.com/install-windows/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;pytorch&#34;&gt;pytorch
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://pytorch.org/get-started/locally/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pytorch.org/get-started/locally/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里才是我今天想说的，首先你不要听他们的步骤直接启动脚本。Python通过requirement文件去安装依赖库，这个都是小问题。核心就是你的显卡版本驱动的版本，需要和pytorch对应。这个呢，也有很多人介绍相应的关系，网上找一找就有了。&lt;/p&gt;
&lt;p&gt;参考：&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/weixin_40660408/article/details/129896700&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/weixin_40660408/article/details/129896700&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;创建一个虚拟环境对，就是一个空的虚拟环境，你在里面直接先去官网执行脚本，把pytorch安装好了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python -c &amp;quot;import torch; print(torch.version.cuda)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python -c &amp;quot;import torch; print(torch.__version__, torch.cuda.is_available())&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面两个脚本可以检查一下你需要安装的cuda版本，也能检查一下你安装是否成功了。&lt;/p&gt;
&lt;p&gt;这里不建议花里胡哨的操作，你先按照官方页面的逻辑复制过来，直接安装就好了，直接pip去安装，你的pytorch很有可能失败，或者没有激活cuda。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重点：文件夹的路径不要有乱七八糟的东西，不然很有可能导致pytorch无法使用。&lt;/p&gt;
&lt;p&gt;中间来来回回安装了很多次，也尝试了把官方的安装文件下载下来手动去安装。就是想着升级一下2.0的版本，因为官方的文档说2.0速度会快一些。但是之前用的不多，也不知道Python的版本和这个是不是有影响。中间呢也查看了官方的手册，说的是建议用3.8的版本。这里就产生了一个小冲突，之前用过一键安装部署包，它里面是3.10的版本。最后就是从零开始先新建文件夹，创建虚拟环境，确保torch已经安装成功了。&lt;/p&gt;
&lt;p&gt;然后把这个安装好的虚拟环境移动到web UI的文件夹里面。这个时候再去启动脚本安装，其他的依赖问题就不大了。&lt;/p&gt;
&lt;p&gt;移动后，需要执行：python -m pip install &amp;ndash;upgrade &amp;ndash;force-reinstall pip，修复一下 pip&lt;/p&gt;
&lt;p&gt;可能看起来挺莫名其妙的，但是这个地方折腾了挺久的。因为它一直无法正确的识别我torch。为了排除所有的干扰因素，才想到先安装它，再去安装其他的依赖库。&lt;/p&gt;
&lt;h2 id=&#34;xformers&#34;&gt;Xformers
&lt;/h2&gt;&lt;p&gt;建议开启，能加速图像生成和减少现存占用，副作用，同一组参数，&lt;strong&gt;生成的图像相对不是那么稳定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Xformers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;stable-diffusion-webui:Xformers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://huggingface.co/docs/diffusers/optimization/xformers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;huggingface optimization&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Optimization Ratio&lt;/th&gt;
&lt;th&gt;Time taken&lt;/th&gt;
&lt;th&gt;Torch active/reserved&lt;/th&gt;
&lt;th&gt;Sys VRAM&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;100.00%&lt;/td&gt;
&lt;td&gt;2m 57.03s&lt;/td&gt;
&lt;td&gt;7440/10058 MiB&lt;/td&gt;
&lt;td&gt;12288/12288 MiB (100.0%)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;51.02%&lt;/td&gt;
&lt;td&gt;1m 29.21s&lt;/td&gt;
&lt;td&gt;4547/7164 MiB&lt;/td&gt;
&lt;td&gt;9298/12288 MiB (75.67%)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;((masterpiece)),((best quality)),((high detial)),((realistic,))
Industrial age city, deep canyons in the middle,chinese architectural streets,bazaars, Bridges, (rainy days:1.2), (steampunk:0.8), chinese architecture
Negative prompt: nsfw,((cowboy)),(((pubic))), ((((pubic_hair))))sketch, duplicate, ugly, huge eyes, text, logo, monochrome, worst face, (bad and mutated hands:1.3), (worst quality:2.0), (low quality:2.0), (blurry:2.0), horror, geometry, bad_prompt, (bad hands), (missing fingers), multiple limbs, bad anatomy, (interlocked fingers:1.2), Ugly Fingers, (extra digit and hands and fingers and legs and arms:1.4), crown braid, ((2girl)), (deformed fingers:1.2), (long fingers:1.2),succubus wings,horn,succubus horn,succubus hairstyle, (bad-artist-anime), bad-artist, bad hand, borrowed character, text focus, watermark, sample watermark, character watermark, lofter username, photo date watermark, movie poster, magazine cover, journal, cover, cover page, doujin cover, album cover, manga cover, brand name imitation, EasyNegative,Tights, silk stockings,shorts
Steps: 35, Sampler: DPM adaptive, CFG scale: 5.5, Seed: 2223996555, Size: 1088x1088, Model hash: 543bcbc212, Model: base_Anything-V3.0-pruned, Clip skip: 2, ENSD: 31337
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;后记&#34;&gt;后记
&lt;/h2&gt;&lt;p&gt;为什么不是推荐那个一键部署包，因为他那个包里面，有部分设置是作者私人定制过的，和官方原模原样的是不一样的。如果你是初学者，你可能不知道为什么要设置那些参数最好的逻辑还是先用官方给的。随着你用的时间越来越长，多去看看官方的手册，你就知道哪些参数需要调整了。&lt;/p&gt;
&lt;h2 id=&#34;显卡的选择&#34;&gt;显卡的选择
&lt;/h2&gt;&lt;p&gt;数据货币矿难之后, 显卡的价格相对来说不是那么高了，普通的入门玩家，&lt;code&gt;3060&lt;/code&gt;和&lt;code&gt;3060ti&lt;/code&gt;之间抉择，一般都会推荐大显存&lt;code&gt;12G&lt;/code&gt;版本的3060，毕竟能生成更大分辨率的图，为什么需要更大的分辨率，因为你可以在生成的时候，把分辨率调大，这样生成的图像就会更加清晰，更加细腻。如果你是想要生成一些小图，那么&lt;code&gt;8G&lt;/code&gt;的显存也是够用的。&lt;/p&gt;
&lt;p&gt;还有一点，&lt;strong&gt;高清放大&lt;/strong&gt;选项，具化细节，让画面细节更加丰富，也需要更多的显存。&lt;/p&gt;
&lt;p&gt;以下是NVIDIA GeForce GTX 970、GeForce RTX 3060 Ti、GeForce RTX 3060、GeForce RTX 3080和GeForce RTX 3080 Ti的单精度（FP32）、半精度（FP16）和双精度（FP64）浮点数计算能力的规格汇总表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;显卡型号&lt;/th&gt;
&lt;th&gt;发布年份&lt;/th&gt;
&lt;th&gt;单精度浮点数计算能力（TFLOPS）&lt;/th&gt;
&lt;th&gt;半精度浮点数计算能力（TFLOPS）&lt;/th&gt;
&lt;th&gt;双精度浮点数计算能力（TFLOPS）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GeForce GTX 970&lt;/td&gt;
&lt;td&gt;2014&lt;/td&gt;
&lt;td&gt;3.49&lt;/td&gt;
&lt;td&gt;87.2&lt;/td&gt;
&lt;td&gt;0.109&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3060 Ti&lt;/td&gt;
&lt;td&gt;2020&lt;/td&gt;
&lt;td&gt;16.2&lt;/td&gt;
&lt;td&gt;32.4&lt;/td&gt;
&lt;td&gt;0.51&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3060&lt;/td&gt;
&lt;td&gt;2021&lt;/td&gt;
&lt;td&gt;12.7&lt;/td&gt;
&lt;td&gt;25.4&lt;/td&gt;
&lt;td&gt;0.39&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3080&lt;/td&gt;
&lt;td&gt;2020&lt;/td&gt;
&lt;td&gt;29.8&lt;/td&gt;
&lt;td&gt;58.9&lt;/td&gt;
&lt;td&gt;0.93&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3080 Ti&lt;/td&gt;
&lt;td&gt;2021&lt;/td&gt;
&lt;td&gt;34.8&lt;/td&gt;
&lt;td&gt;68.7&lt;/td&gt;
&lt;td&gt;1.36&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;摘录来的，&lt;a class=&#34;link&#34; href=&#34;https://docs.google.com/spreadsheets/d/1Zlv4UFiciSgmJZncCujuXKHwc4BcxbjbSBg71-SdeNk/edit#gid=0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;各种显卡性能测试数据&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;更新&#34;&gt;更新
&lt;/h2&gt;&lt;p&gt;间隔半年，本来还想再梳理一下安装步骤，科普更多的基础概念，结果发现，普通人玩AI画图，真就是基于大佬给的图片参数，进行参数调整，或者基于已有的图片，进行格式化的重新渲染。&lt;/p&gt;
&lt;p&gt;中间有过项目，尝试用AI来绘制小程序的UI素材，结果折腾半天，效果都不如意，不如我直接从官方的小程序拉资源图片。&lt;/p&gt;</description>
        </item>
        <item>
        <title>程序优化不要试图对抗硬件</title>
        <link>https://ttf248.life/p/program-optimization-dont-fight-hardware/</link>
        <pubDate>Fri, 07 Apr 2023 16:30:15 +0800</pubDate>
        
        <guid>https://ttf248.life/p/program-optimization-dont-fight-hardware/</guid>
        <description>&lt;p&gt;&lt;code&gt;one loop thread&lt;/code&gt;，耗时已经在&lt;strong&gt;微秒&lt;/strong&gt;层面，更换服务器，从最多积压六万数据包，到几乎没有积压&lt;/p&gt;
&lt;p&gt;在单线程循环处理数据的场景中，CPU的性能取决于主频、缓存大小、指令集架构等因素。一般来说，主频越高、缓存越大、指令集架构越先进的CPU在单线程处理数据时性能越好&lt;/p&gt;
&lt;h2 id=&#34;单线程&#34;&gt;单线程
&lt;/h2&gt;&lt;p&gt;性能提升，增加线程不是分必要的，梳理项目流程，确定耗时的点，单线程是否能满足需求，单线程考虑的东西更少，也不容易出问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上来就和就说加线程，多少有点毛病&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;事件&#34;&gt;事件
&lt;/h2&gt;&lt;p&gt;处理的都是&lt;strong&gt;行情数据，延迟敏感&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;吭哧吭哧加班一晚上，发布新的优化版本，本地剥离接口进行测试，速度也还行，tps：4.2万&lt;/p&gt;
&lt;p&gt;部署到服务器，tps骤降：2.1万，回家尝试台式机，tps：7.9万，开始怀疑组内服务虚拟机多少有点问题，首先怀疑主频导致的，家用台式机和服务器&lt;code&gt;CPU&lt;/code&gt;，差异最大的地方就是主频&lt;/p&gt;
&lt;p&gt;测试服务器A&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;processor	: 7
vendor_id	: GenuineIntel
cpu family	: 6
model		: 47
model name	: Intel(R) Xeon(R) CPU E7- 4807  @ 1.87GHz
stepping	: 2
microcode	: 0x34
cpu MHz		: 1866.733
cache size	: 18432 KB
physical id	: 1
siblings	: 4
core id		: 3
cpu cores	: 4
apicid		: 7
initial apicid	: 7
fpu		: yes
fpu_exception	: yes
cpuid level	: 11
wp		: yes
flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss ht syscall nx rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc cpuid aperfmperf pni pclmulqdq ssse3 cx16 sse4_1 sse4_2 popcnt aes hypervisor lahf_lm pti dtherm arat
bugs		: clflush_monitor cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit
bogomips	: 3733.46
clflush size	: 64
cache_alignment	: 64
address sizes	: 40 bits physical, 48 bits virtual
power management:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试服务器B&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;processor	: 7
vendor_id	: GenuineIntel
cpu family	: 6
model		: 63
model name	: Intel(R) Xeon(R) CPU E5-2640 v3 @ 2.60GHz
stepping	: 2
microcode	: 0x3c
cpu MHz		: 2599.998
cache size	: 20480 KB
physical id	: 14
siblings	: 1
core id		: 0
cpu cores	: 1
apicid		: 14
initial apicid	: 14
fpu		: yes
fpu_exception	: yes
cpuid level	: 15
wp		: yes
flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc cpuid aperfmperf pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand hypervisor lahf_lm cpuid_fault epb pti fsgsbase smep xsaveopt cqm_llc cqm_occup_llc dtherm ida arat pln pts
bugs		: cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit
bogomips	: 5199.99
clflush size	: 64
cache_alignment	: 64
address sizes	: 40 bits physical, 48 bits virtual
power management:
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;咨询-openai&#34;&gt;咨询 OpenAI
&lt;/h2&gt;&lt;p&gt;首先是核心数和主频方面，Intel(R) Xeon(R) CPU E7- 4807 @ 1.87GHz拥有6个物理核心和12个逻辑核心，主频为1.87GHz；而Intel(R) Xeon(R) CPU E5-2640 v3 @ 2.60GHz拥有8个物理核心和16个逻辑核心，主频为2.60GHz。因此，从核心数和主频方面来看，E5-2640 v3在单线程处理数据时应该比E7- 4807更具优势。&lt;/p&gt;
&lt;p&gt;其次是缓存大小方面，E7- 4807的缓存大小为12MB，而E5-2640 v3的缓存大小为20MB。因此，E5-2640 v3拥有更大的缓存空间，可以提高数据的访问速度和缓存命中率。&lt;/p&gt;
&lt;p&gt;最后是架构方面，E5-2640 v3采用了更先进的Haswell架构，而E7- 4807采用的是旧的Nehalem架构。Haswell架构相对于Nehalem架构在性能方面有所提升，这也可能对E5-2640 v3在单线程处理数据时的性能提升产生影响。&lt;/p&gt;
&lt;p&gt;因此，综合考虑，在单线程循环处理数据的场景中，E5-2640 v3应该比E7- 4807具有更好的性能。但是，具体的性能差异会受到多种因素的影响，包括数据处理的算法、内存带宽、系统负载等等，需要具体问题具体分析。&lt;/p&gt;
&lt;h2 id=&#34;硬件资料&#34;&gt;硬件资料
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cpubenchmark.net/compare/3786.2vs2365.2/%5BDual-CPU%5D-Intel-Xeon-E7%e2%80%934807-vs-%5BDual-CPU%5D-Intel-Xeon-E5-2640-v3&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cpubenchmark.net/compare/3786.2vs2365.2/%5BDual-CPU%5D-Intel-Xeon-E7–4807-vs-%5BDual-CPU%5D-Intel-Xeon-E5-2640-v3&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Specification&lt;/th&gt;
&lt;th&gt;Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Price&lt;/td&gt;
&lt;td&gt;Search Online  $78 - BUY&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Socket Type&lt;/td&gt;
&lt;td&gt;LGA1567&lt;/td&gt;
&lt;td&gt;LGA2011-v3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU Class&lt;/td&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Clockspeed&lt;/td&gt;
&lt;td&gt;1.9 GHz&lt;/td&gt;
&lt;td&gt;2.6 GHz&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Turbo Speed&lt;/td&gt;
&lt;td&gt;Not Supported&lt;/td&gt;
&lt;td&gt;Up to 3.4 GHz&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;# of Physical Cores&lt;/td&gt;
&lt;td&gt;6 (Threads: 12)&lt;/td&gt;
&lt;td&gt;8 (Threads: 16)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Cache&lt;/td&gt;
&lt;td&gt;NA2&lt;/td&gt;
&lt;td&gt;NA2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Max TDP&lt;/td&gt;
&lt;td&gt;95W x 2&lt;/td&gt;
&lt;td&gt;90W x 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Yearly Running Cost&lt;/td&gt;
&lt;td&gt;$34.68&lt;/td&gt;
&lt;td&gt;$32.85&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Other&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;First Seen on Chart&lt;/td&gt;
&lt;td&gt;Q3 2020&lt;/td&gt;
&lt;td&gt;Q3 2014&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;# of Samples&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;46&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU Value&lt;/td&gt;
&lt;td&gt;69.1&lt;/td&gt;
&lt;td&gt;225.6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Single Thread Rating&lt;/td&gt;
&lt;td&gt;721 (-59.2%)&lt;/td&gt;
&lt;td&gt;1767 (0.0%)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU Mark&lt;/td&gt;
&lt;td&gt;6223 (-64.6%)&lt;/td&gt;
&lt;td&gt;17600 (0.0%)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description>
        </item>
        <item>
        <title>Prompt 工程师</title>
        <link>https://ttf248.life/p/prompt-engineer/</link>
        <pubDate>Sun, 26 Mar 2023 20:46:53 +0800</pubDate>
        
        <guid>https://ttf248.life/p/prompt-engineer/</guid>
        <description>&lt;p&gt;就如当年学习搜索引擎的技巧，我们也需要学习一些和&lt;code&gt;AI&lt;/code&gt;沟通的技巧，给出合理且充分的限定条件，高效的获取需要的答案。&lt;/p&gt;
&lt;p&gt;如果你换个角度呢，当前的&lt;code&gt;AI&lt;/code&gt;属于一个记忆力很好的小孩子，它拥有过目不忘的能力，有抄作业的能力。我们需要做的是学会如何正确、有效的和&lt;code&gt;AI&lt;/code&gt;沟通，精准的描述需求，帮助&lt;code&gt;AI&lt;/code&gt;生成预期的结果。&lt;/p&gt;
&lt;h2 id=&#34;科普&#34;&gt;科普
&lt;/h2&gt;&lt;p&gt;火出天际的&lt;code&gt;AI&lt;/code&gt;确切的说&lt;code&gt;Generative Pre-Training&lt;/code&gt;，直译过来就是生成式的预训练。它是一种基于互联网可用数据训练的文本生成深度学习模型，用于问答、文本摘要生成、机器翻译、分类、代码生成和对话 AI 等任务。目前已经有 GPT-1、GPT-2、GPT-3 和 GPT-4 等不同版本的模型，每个版本都比前一个版本更大、更强大。&lt;/p&gt;
&lt;h2 id=&#34;到底有没有智能&#34;&gt;到底有没有智能
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;相似度足够高，准确率也就越高&lt;/li&gt;
&lt;li&gt;基础的、重复性的工作，进过特定训练，不再需要人工的介入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;生成式AI是一种利用现有的文本、音频、图像等数据来创建新内容的技术。它可以用于文本生成、语音合成、图像生成、对话系统等多种任务。生成式AI的逻辑性取决于它的训练数据和模型结构。一般来说，生成式AI可以在一定程度上遵循语法、逻辑和常识，但也可能出现错误、偏差或不真实的内容。因此，生成式AI的输出需要人类的判断和验证，不能盲目相信或使用。&lt;/p&gt;
&lt;h2 id=&#34;prompt-工程师&#34;&gt;Prompt 工程师
&lt;/h2&gt;&lt;p&gt;时间河流不会逆流，人需要学会适应潮流。你可以认为&lt;code&gt;AI&lt;/code&gt;不智能，没有逻辑性，它经常写出来不能用的代码。&lt;/p&gt;
&lt;p&gt;如果你换个角度呢，当前的&lt;code&gt;AI&lt;/code&gt;属于一个记忆力很好的小孩子，它拥有过目不忘的能力，有抄作业的能力。我们需要做的是学会如何正确、有效的和&lt;code&gt;AI&lt;/code&gt;沟通，精准的描述需求，帮助&lt;code&gt;AI&lt;/code&gt;生成预期的结果。&lt;/p&gt;
&lt;h2 id=&#34;对话模式&#34;&gt;对话模式
&lt;/h2&gt;&lt;p&gt;两年前&lt;code&gt;Github Copilot&lt;/code&gt;发布，谁也想不到两年后，&lt;code&gt;OpenAI&lt;/code&gt;横空出世，让人类认知到了大语言模型的能力。&lt;/p&gt;
&lt;p&gt;基于&lt;strong&gt;基于注释的编程&lt;/strong&gt;和&lt;strong&gt;基于对话的编程&lt;/strong&gt;，交互逻辑上完全不同，对话的模式，小白用户的交互体验友好，此处必须提到&lt;code&gt;NewBing&lt;/code&gt;在每个问题之后，给出的追问提示，微软在尝试引导用户，获取&lt;code&gt;AI&lt;/code&gt;知识库里面，更多的内容。&lt;/p&gt;
&lt;h2 id=&#34;举个栗子&#34;&gt;举个栗子
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;场景&lt;/strong&gt;：高铁旅途时间漫漫，编码是个不错的选择。流量有限的情况下，处理几个图片，获取了图片素材，下载软件处理图片稍微有点奢侈，网络条件也不允许。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt;：有一批图片素材，带透明背景图，用来作为小程序的导航栏，选中的状态是彩色的，没选中的状态是黑白的，素材都是彩色的，需要预处理一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Prompt&lt;/strong&gt;：编写一段 python 代码，从一个文件夹中读取所有的图片，将图片转换成黑白，维持透明背景，保存图片的时候，优化图片的质量，减少文件体积，同时在控制台展示，优化前后的文件体积大小对比&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 导入必要的库
import os
import PIL
from PIL import Image

# 定义一个函数，将图片转换成黑白，维持透明背景，保存图片，并返回文件体积
def convert_and_save(image_file):
    # 打开图片
    image = Image.open(image_file)
    # 获取图片的模式，如果是 RGBA 模式，说明有透明背景
    mode = image.mode
    if mode == &amp;quot;RGBA&amp;quot;:
        # 创建一个和图片大小一致的白色背景图片
        background = Image.new(&amp;quot;RGB&amp;quot;, image.size, (255, 255, 255))
        # 将原图片粘贴到白色背景上，忽略透明像素
        background.paste(image, mask=image.split()[3])
        # 将合成的图片转换成灰度模式
        gray_image = background.convert(&amp;quot;L&amp;quot;)
        # 将灰度图片再转换成 RGBA 模式，以便保留透明背景
        final_image = gray_image.convert(&amp;quot;RGBA&amp;quot;)
    else:
        # 如果不是 RGBA 模式，直接将图片转换成灰度模式
        final_image = image.convert(&amp;quot;L&amp;quot;)
    # 获取原图片的文件名和扩展名
    file_name, file_ext = os.path.splitext(image_file)
    # 定义新图片的文件名，添加 _bw 后缀表示黑白
    new_file_name = file_name + &amp;quot;_bw&amp;quot; + file_ext
    # 保存新图片，并优化质量，减少文件体积
    final_image.save(new_file_name, optimize=True)
    # 获取原图片和新图片的文件体积，并返回
    old_size = os.path.getsize(image_file)
    new_size = os.path.getsize(new_file_name)
    return old_size, new_size

# 定义一个文件夹路径，存放所有的图片
folder_path = &amp;quot;images&amp;quot;
# 遍历文件夹中的所有文件
for file in os.listdir(folder_path):
    # 拼接完整的文件路径
    file_path = os.path.join(folder_path, file)
    # 判断是否是图片文件，根据扩展名判断，可以根据需要添加或修改扩展名
    if file_path.endswith((&amp;quot;.png&amp;quot;, &amp;quot;.jpg&amp;quot;, &amp;quot;.jpeg&amp;quot;, &amp;quot;.gif&amp;quot;)):
        # 调用函数，转换并保存图片，并获取文件体积
        old_size, new_size = convert_and_save(file_path)
        # 在控制台展示优化前后的文件体积大小对比
        print(f&amp;quot;{file}: {old_size} bytes -&amp;gt; {new_size} bytes&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;AI&lt;/code&gt;迅速给出了答案，看着很漂亮，用起来也没问题，经验丰富的程序源，会觉得下面的代码不够通用，也没法上生产环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参数固定了&lt;/li&gt;
&lt;li&gt;没有日志文件，信息都打印在控制台&lt;/li&gt;
&lt;li&gt;图片处理的任务，适合多线程模型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;NewBing&lt;/code&gt;登场，依据提示，选择了一个问题：&lt;strong&gt;这段代码有什么可以改进的地方吗&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这次给的答案，实话，完全超出了预期，一般程序员能想到的优化措施，&lt;code&gt;AI&lt;/code&gt;都给出对应的建议&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;这段代码可能还有一些可以改进的地方，比如：

可以使用 argparse 库，让用户可以通过命令行参数指定文件夹路径和扩展名，而不是写死在代码里。
可以使用 logging 库，记录程序的运行情况，而不是直接打印到控制台。
可以使用 try-except 语句，捕获可能出现的异常，比如文件打开失败，图片转换失败等，并做相应的处理。
可以使用 multiprocessing 库，利用多核处理器，加速图片的转换和保存过程。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很友好的应答，考虑到部署的环境存在差异，允许不支持多进程&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;当然，我很乐意帮你修改一下代码。我尝试添加了 argparse, logging 和 try-except 语句，但没有添加 multiprocessing 库，因为我不确定你的电脑是否支持多核处理。修改后的代码如下：
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 导入必要的库
import argparse
import logging
import multiprocessing
import os

from PIL import Image


# 定义一个函数，将图片转换成黑白，维持透明背景，保存图片，并返回文件体积
def convert_and_save(image_file):
    # 打开图片
    try:
        image = Image.open(image_file)
    except Exception as e:
        logging.error(f&amp;quot;Failed to open {image_file}: {e}&amp;quot;)
        return None, None
    # 获取图片的模式，如果是 RGBA 模式，说明有透明背景
    mode = image.mode
    if mode == &amp;quot;RGBA&amp;quot;:
        # 创建一个和图片大小一致的白色背景图片
        background = Image.new(&amp;quot;RGB&amp;quot;, image.size, (255, 255, 255))
        # 将原图片粘贴到白色背景上，忽略透明像素
        background.paste(image, mask=image.split()[3])
        # 将合成的图片转换成灰度模式
        gray_image = background.convert(&amp;quot;L&amp;quot;)
        # 将灰度图片再转换成 RGBA 模式，以便保留透明背景
        final_image = gray_image.convert(&amp;quot;RGBA&amp;quot;)
    else:
        # 如果不是 RGBA 模式，直接将图片转换成灰度模式
        final_image = image.convert(&amp;quot;L&amp;quot;)
    # 获取原图片的文件名和扩展名
    file_name, file_ext = os.path.splitext(image_file)
    # 定义新图片的文件名，添加 _bw 后缀表示黑白
    new_file_name = file_name + &amp;quot;_bw&amp;quot; + file_ext
    # 保存新图片，并优化质量，减少文件体积
    try:
        final_image.save(new_file_name, optimize=True)
    except Exception as e:
        logging.error(f&amp;quot;Failed to save {new_file_name}: {e}&amp;quot;)
        return None, None
    # 获取原图片和新图片的文件体积，并返回
    old_size = os.path.getsize(image_file)
    new_size = os.path.getsize(new_file_name)
    return file_name, old_size, new_size

# 定义一个函数，解析命令行参数，并返回文件夹路径和扩展名列表
def parse_args():
    # 创建一个解析器对象
    parser = argparse.ArgumentParser(description=&amp;quot;Convert images to black and white and optimize quality.&amp;quot;)
    # 添加一个必选的位置参数，表示文件夹路径
    parser.add_argument(&amp;quot;folder_path&amp;quot;, help=&amp;quot;The path of the folder that contains the images.&amp;quot;)
    # 添加一个可选的参数，表示扩展名列表，默认为 png, jpg, jpeg 和 gif
    parser.add_argument(&amp;quot;-e&amp;quot;, &amp;quot;--extensions&amp;quot;, nargs=&amp;quot;+&amp;quot;, default=[&amp;quot;.png&amp;quot;, &amp;quot;.jpg&amp;quot;, &amp;quot;.jpeg&amp;quot;, &amp;quot;.gif&amp;quot;], help=&amp;quot;The extensions of the image files.&amp;quot;)
    # 解析命令行参数，并返回结果对象
    args = parser.parse_args()
    return args.folder_path, args.extensions

# 定义一个函数，打印优化前后的文件体积大小对比
def print_result(result):
    # 如果结果不为空，说明转换和保存成功
    if result:
        # 解包结果为文件名和文件体积元组
        if len(result) == 3:
            file, old_size, new_size = result
            # 在控制台展示优化前后的文件体积大小对比
            logging.info(f&amp;quot;{file}: {old_size} bytes -&amp;gt; {new_size} bytes&amp;quot;)
        else:
            logging.info(f&amp;quot;{result}&amp;quot;)

# 配置日志记录器，将日志输出到控制台和文件中，设置日志等级为 INFO
logging.basicConfig(level=logging.INFO,
                    format=&amp;quot;%(asctime)s %(levelname)s %(message)s&amp;quot;,
                    handlers=[logging.StreamHandler(),
                              logging.FileHandler(&amp;quot;log.txt&amp;quot;)])

# 调用函数，获取文件夹路径和扩展名列表
folder_path, extensions = parse_args()

if __name__ == &amp;quot;__main__&amp;quot;:
    # Windows 需要这个函数的原因是 Windows 缺乏 fork() 函数（这不完全正确）。
    # 因此，在 Windows 上，fork() 是通过创建一个新的进程来模拟的，这个新的进程中运行的代码，在 Linux 上是在子进程中运行的。
    # 由于这些代码要在技术上无关的进程中运行，所以它必须在运行之前被传递到那里。
    # 传递的方式是先将它们序列化，然后通过管道从原始进程发送到新的进程。
    # 另外，这个新的进程被通知它必须运行通过管道传递的代码，通过向它传递 --multiprocessing-fork 命令行参数。
    # 如果你看一下 freeze_support() 函数的实现，它的任务是检查它运行在哪个进程中，是否应该运行通过管道传递的代码
    multiprocessing.freeze_support()

    # 创建一个进程池，根据电脑的核心数自动分配进程
    pool = multiprocessing.Pool()
    # 创建一个空列表，用于存放异步任务的结果对象
    results = []
    # 遍历文件夹中的所有文件
    for file in os.listdir(folder_path):
        # 拼接完整的文件路径
        file_path = os.path.join(folder_path, file)
        # 判断是否是图片文件，根据扩展名判断，可以根据需要修改扩展名列表
        if any(file_path.endswith(ext) for ext in extensions):
            # 调用函数，转换并保存图片，并获取文件体积，使用异步方式，不阻塞主进程
            result = pool.apply_async(convert_and_save, args=(file_path,), callback=print_result)
            # 将结果对象添加到列表中
            results.append((file, result))
    # 关闭进程池，不再接受新的任务
    pool.close()
    # 等待所有的任务完成
    pool.join()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;后记&#34;&gt;后记
&lt;/h2&gt;&lt;p&gt;由于本地开发是&lt;code&gt;windows&lt;/code&gt;系统，&lt;code&gt;AI&lt;/code&gt;第一次给出的答案，并没有加上&lt;code&gt;main&lt;/code&gt;函数，也没有&lt;code&gt;multiprocessing.freeze_support&lt;/code&gt;。通过追问发生的报错，修复了代码。&lt;/p&gt;
&lt;p&gt;就如当年学习搜索引擎的技巧，我们也需要学习一些和&lt;code&gt;AI&lt;/code&gt;沟通的技巧，给出合理且充分的限定条件，高效的获取需要的答案。&lt;/p&gt;
&lt;p&gt;注意：&lt;strong&gt;如果你是个编程新手，基于给出的注释，还有看不懂的地方，可以继续追问相关代码&lt;/strong&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>微信小程序背景和开发环境</title>
        <link>https://ttf248.life/p/wechat-mini-program-background-and-development-environment/</link>
        <pubDate>Fri, 24 Mar 2023 21:59:11 +0800</pubDate>
        
        <guid>https://ttf248.life/p/wechat-mini-program-background-and-development-environment/</guid>
        <description>&lt;p&gt;微信小程序介绍与开发准备&lt;/p&gt;
&lt;h2 id=&#34;为什么会有小程序&#34;&gt;为什么会有小程序
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;更好的体验：内嵌网页加载缓慢、白屏；原生应用的体验，更快速的加载&lt;/li&gt;
&lt;li&gt;规范与管理：对于微信来说，接入和管理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在小程序发布之前，微信发布过一个&lt;code&gt;SDK&lt;/code&gt;叫做&lt;code&gt;JSSDK&lt;/code&gt;，开放部分的微信原生能力：微信支付、卡券。但是开发者基于网页开发语言的逻辑来进行开发，能绕过微信的一些监管。小程序有一套自己的描述语言。&lt;/p&gt;
&lt;h2 id=&#34;什么是小程序&#34;&gt;什么是小程序
&lt;/h2&gt;&lt;p&gt;小程序是一种不需要下载安装即可使用的应用，它实现了应用&lt;strong&gt;触手可及&lt;/strong&gt;的梦想&lt;/p&gt;
&lt;p&gt;用户扫一扫或者搜一下即可打开应用，也体现了&lt;strong&gt;用完即走&lt;/strong&gt;的理念&lt;/p&gt;
&lt;p&gt;用户不用关系是否安装太多应用的问题。应用将无处不在，随时可用，但又&lt;strong&gt;无需安装卸载&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;小程序和移动应用的区别&#34;&gt;小程序和移动应用的区别
&lt;/h2&gt;&lt;p&gt;无需安装、不占内存、易传播：扫码、小程序卡片、搜一搜&lt;/p&gt;
&lt;h2 id=&#34;小程序能做什么&#34;&gt;小程序能做什么
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;内容工具：知乎热榜、微博热门、摩拜单车、今日头条、腾讯地图、腾讯翻译&lt;/li&gt;
&lt;li&gt;零售：拼多多、京东购物、蘑菇街、每日优鲜、小米商城、屈臣氏&lt;/li&gt;
&lt;li&gt;游戏：跳一跳、欢乐斗地主、欢乐麻将、斗鱼直播、YY直播&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;课程内容2018年的，到了现在，部分应用厂商已经倒闭了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;开发准备&#34;&gt;开发准备
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;注册小程序账号：正常填写信息即可注册，邮箱点击激活链接&lt;/li&gt;
&lt;li&gt;信息登记&lt;/li&gt;
&lt;li&gt;登录小程序管理后台&lt;/li&gt;
&lt;li&gt;完善小程序信息&lt;/li&gt;
&lt;li&gt;绑定开发者：个人开发者，登录的微信号为管理员账号，无需额外的绑定操作&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;邮箱有一定的限制，需要一个新的邮箱，但是&lt;code&gt;QQ&lt;/code&gt;邮箱能申请别名，微信后台并不会校验。尝试过后，小程序的名字比较麻烦，但凡涉及到了商标，就容易审核失败。&lt;/p&gt;
&lt;p&gt;服务类目可以选择，也能自定义添加，一个小程序能添加五个类目。&lt;/p&gt;
&lt;p&gt;设置里面能查看小程序的&lt;code&gt;ID&lt;/code&gt;信息，也能开启消息推送，启用了消息推送就能使用消息模板功能。&lt;/p&gt;
&lt;h2 id=&#34;开发者工具笔者自述&#34;&gt;开发者工具（笔者自述）
&lt;/h2&gt;&lt;p&gt;正常下载安装，没什么特殊注意事项，简单了解，直接游客模式进入，如果想启用手机调试，也就是手机查看小程序的开发版本，需要登录小程序的开发者账号，然后点击设置，在项目详情里面切换到指定的小程序&lt;code&gt;ID&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;代码结构&#34;&gt;代码结构
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;js: 交互逻辑&lt;/li&gt;
&lt;li&gt;json：数据配置&lt;/li&gt;
&lt;li&gt;wxml：界面的元素&lt;/li&gt;
&lt;li&gt;wxss：界面的样式&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>办公室迁移，服务器无法访问了</title>
        <link>https://ttf248.life/p/office-move-server-inaccessible/</link>
        <pubDate>Sat, 11 Mar 2023 01:42:05 +0800</pubDate>
        
        <guid>https://ttf248.life/p/office-move-server-inaccessible/</guid>
        <description>&lt;p&gt;行政通知，办公位变动，从原本的二楼，迁移到十五楼，普普通通的一次工位迁移&lt;/p&gt;
&lt;h2 id=&#34;设计感&#34;&gt;设计感
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/office-move-server-inaccessible/20230311014537.png&#34;
	width=&#34;511&#34;
	height=&#34;916&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;办公楼&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;55&#34;
		data-flex-basis=&#34;133px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;迁徙&#34;&gt;迁徙
&lt;/h2&gt;&lt;p&gt;收市打包、轻车熟路，新的工位，调整电脑布线，舒服的姿势开始工作&lt;/p&gt;
&lt;p&gt;(ÒωÓױ)！，接上网线，组里常用的服务器，不能访问了，试着切换无线网络，访问又正常了&lt;/p&gt;
&lt;p&gt;起初呢以为是服务器网段设置问题，新的工位的有线网络，不在防火墙配置的名单里面，联系IT同事调整下就好了；这个网段呢，不止一台服务器，试着访问其他服务器，都是正常的，逐渐产生疑惑？专业的事情交给专业的人来处理，最后运维部门的同事定位到，由于这台服务器部署了&lt;code&gt;docker&lt;/code&gt;，服务的默认网络&lt;code&gt;docker0&lt;/code&gt;和办公室有线网络配置的网段冲突了，导致发过去的数据包，都收不到应答，被路由给了&lt;code&gt;docker&lt;/code&gt;服务。&lt;/p&gt;
&lt;p&gt;其他服务器都没部署&lt;code&gt;docker&lt;/code&gt;服务，也就这台，我比较常用，偶尔用容器部署一些测试服务，没想到还能碰到这个场景。后来细想想，由于整个集团都在一个办公大楼里面，IT部门的同事划分网段，用到了&lt;code&gt;172&lt;/code&gt;打头的地址也不奇怪。&lt;/p&gt;
&lt;h2 id=&#34;docker0&#34;&gt;docker0
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# vim /etc/docker/daemon.json
{
    &amp;quot;bip&amp;quot;:&amp;quot;172.200.0.1/24&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重启下服务，切换到新的网络，服务器恢复正常访问。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://yeasy.gitbook.io/docker_practice/advanced_network/docker0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Docker从入门到实践-docker0&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>嵌入式入门篇1-专业名词</title>
        <link>https://ttf248.life/p/embedded-entry-professional-terms/</link>
        <pubDate>Tue, 07 Mar 2023 13:42:36 +0800</pubDate>
        
        <guid>https://ttf248.life/p/embedded-entry-professional-terms/</guid>
        <description>&lt;p&gt;提到嵌入式，脑海里还是当年学校实验室的51单片机和飞思卡尔。&lt;/p&gt;
&lt;p&gt;LPA3399Pro 是一款基于瑞芯微RK3399Pro平台开发的视觉主机，针对需要大量视觉运算场景的便携式运算主机。它内置NPU计算单元，具有3.0TOPS算力，支持多种算法模型。&lt;/p&gt;
&lt;p&gt;RV1109 是瑞芯微人工智能下机器视觉分支的SoC，内置独立NPU。 RV1109可提供1TOPS算力。&lt;/p&gt;
&lt;h2 id=&#34;system-on-chip&#34;&gt;System on Chip
&lt;/h2&gt;&lt;p&gt;SoC 是 System on a Chip 的缩写，意为“片上系统”。它是一种将多个电子系统集成到一个芯片上的技术。这种技术可以大大减小电子产品的体积和重量，同时提高性能和降低功耗。&lt;/p&gt;
&lt;p&gt;SoC（System on a Chip）和 CPU（Central Processing Unit）都是计算机系统中的重要组成部分，但它们之间有一些区别。&lt;/p&gt;
&lt;p&gt;CPU 是计算机系统中的核心处理器，负责执行程序指令。它通常只包含运算单元、控制单元和寄存器等基本部件。&lt;/p&gt;
&lt;p&gt;SoC 则是将多个电子系统集成到一个芯片上，除了包含 CPU 外，还可以集成其他组件，如内存、图形处理器、输入/输出接口等。这样可以大大减小电子产品的体积和重量，同时提高性能和降低功耗。&lt;/p&gt;
&lt;p&gt;总之，CPU 是 SoC 的一个组成部分，而 SoC 则是一个更为复杂、集成度更高的电子系统。&lt;/p&gt;
&lt;h2 id=&#34;microcontroller-unit&#34;&gt;Microcontroller Unit
&lt;/h2&gt;&lt;p&gt;SoC（System on a Chip）和 MCU（Microcontroller Unit）都是将多个电子系统集成到一个芯片上的技术，但它们之间也有一些区别。&lt;/p&gt;
&lt;p&gt;MCU 是一种微控制器，通常包含一个 CPU、内存、输入/输出接口等基本部件。它通常用于控制其他电子设备，如家用电器、汽车电子系统等。&lt;/p&gt;
&lt;p&gt;SoC 则是将更多的电子系统集成到一个芯片上，除了包含 MCU 的基本部件外，还可以集成其他组件，如图形处理器、无线通信模块等。这样可以大大减小电子产品的体积和重量，同时提高性能和降低功耗。&lt;/p&gt;
&lt;p&gt;总之，MCU 是一种简单的微控制器，而 SoC 则是一个更为复杂、集成度更高的电子系统。&lt;/p&gt;</description>
        </item>
        <item>
        <title>AI辅助编程，生产力的进化</title>
        <link>https://ttf248.life/p/ai-assisted-programming-productivity-evolution/</link>
        <pubDate>Tue, 28 Feb 2023 17:05:17 +0800</pubDate>
        
        <guid>https://ttf248.life/p/ai-assisted-programming-productivity-evolution/</guid>
        <description>&lt;p&gt;&lt;code&gt;GitHub Copilot&lt;/code&gt; 发布也不到两年时间，&lt;code&gt;ChatGPT&lt;/code&gt; 问世了，不是很懂背后的原理，都用了一段时间。两个工具的辅助层面完全不同，但是都做到了大幅提高生产力。&lt;/p&gt;
&lt;p&gt;太复杂的事情，&lt;code&gt;AI&lt;/code&gt;还做不到，毕竟他们没有逻辑，有套路的或者说范式固定的事情，训练的语料足够，&lt;code&gt;AI&lt;/code&gt;的效果能打个九分。&lt;/p&gt;
&lt;h2 id=&#34;github-copilot&#34;&gt;github copilot
&lt;/h2&gt;&lt;p&gt;发布的时候，看着官网的介绍&lt;code&gt;demo&lt;/code&gt;，不是很智能，试用了一下，不是很好用，放弃了。&lt;/p&gt;
&lt;p&gt;2022年前，闲来无事，切换到新版本体验一下，效果已经不错了，就是国内的速度有点慢，大概率是网络的原因。&lt;code&gt;Python&lt;/code&gt;之类的语言，依据注释写出来的代码都还不错，比我自己查资料然后编写的速度快了很多。&lt;/p&gt;
&lt;h2 id=&#34;chatgpt&#34;&gt;ChatGPT
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Github Copilot&lt;/code&gt;还停留在程序员，也就是开发的角度来设计产品，你需要懂的如何编程，慢慢的通过注释来引导AI辅助编程。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ChatGPT&lt;/code&gt; 走到了下一个层面，&lt;strong&gt;让外行人也能迅速上手&lt;/strong&gt;。对话聊天交互式的设计，你完全可以提出问题，描述需求，不懂的地方，继续提问。&lt;/p&gt;
&lt;p&gt;简单来个例子，知道分词的概念，但是不知道如何编码，想要计算字符串的相似度：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Python 分词计算 維天運通 LOGORY 和 合肥維天運通信息科技股份有限公司 两个字符串的相似度；
比较前，统一处理字符串，英文转换为小写；
第二个字符中如果能找到第一个字符的首字符，将第二个字符串截位，截位的长度为第一个字符串的长度
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你好，这是Bing。😊&lt;/p&gt;
&lt;p&gt;根据网上的信息123，Python 分词计算可以使用 jieba 库来实现。jieba 库支持三种分词模式：精确模式、全模式和搜索引擎模式。你可以根据你的需求选择合适的模式。&lt;/p&gt;
&lt;p&gt;为了比较两个字符串的相似度，你需要先对它们进行分词，然后计算它们的词向量或者编辑距离等指标。你可以使用 numpy 或者 scipy 等库来进行数学运算。&lt;/p&gt;
&lt;p&gt;为了统一处理字符串，英文转换为小写，你可以使用 Python 的内置函数 lower() 来实现。&lt;/p&gt;
&lt;p&gt;为了截取第二个字符串，你可以使用 Python 的切片操作符 [ ] 来实现。&lt;/p&gt;
&lt;p&gt;以下是一个可能的代码示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import jieba
import numpy as np
from scipy.spatial.distance import cosine

# 定义两个字符串
str1 = &amp;quot;維天運通 LOGORY&amp;quot;
str2 = &amp;quot;合肥維天運通信息科技股份有限公司&amp;quot;

# 统一处理字符串，英文转换为小写
str1 = str1.lower()
str2 = str2.lower()

# 找到第二个字符串中第一个字符的位置
index = str2.find(str1[0])

# 如果找到了，截取第二个字符串
if index != -1:
    str2 = str2[index:index+len(str1)]

# 使用 jieba 库进行分词
words1 = list(jieba.cut(str1))
words2 = list(jieba.cut(str2))

# 计算两个字符串的词向量（以词频作为权重）
vector1 = np.zeros(len(words1))
vector2 = np.zeros(len(words1))

for i, word in enumerate(words1):
    vector1[i] += 1 # 统计第一个字符串中每个词出现的次数
    if word in words2:
        vector2[i] += 1 # 统计第二个字符串中每个词出现的次数

# 计算两个字符串的相似度（以余弦距离作为指标）
similarity = 1 - cosine(vector1, vector2)

print(&amp;quot;两个字符串的相似度是：&amp;quot;, similarity)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;更进一步，咨询运行的结果，恭喜你，发现问题了，结果是瞎编的，它并没有实际运行代码，但是会给你一个不错的结果&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;栗子&#34;&gt;栗子
&lt;/h3&gt;&lt;p&gt;提问：sql 语句，查出产品代码表中，产品代码在这个区间 80000-89999 的记录&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;你好，这是 Bing。😊

根据搜索结果12，你可以使用 SQL BETWEEN 运算符来选择给定区间内的值。BETWEEN 运算符包含了开始和结束的值。

你需要先指定要查询的表名和列名，然后在 WHERE 子句中使用 BETWEEN 运算符和区间值。

例如，如果你要查询产品代码表中，产品代码在 80000 到 89999 之间的记录，你可以使用以下语句：

SELECT * FROM product_code
WHERE code BETWEEN 80000 AND 89999;
这里，* 表示选择所有列3。如果你只想选择特定的列，比如产品名称和价格，你可以用逗号分隔它们，如下：

SELECT name, price FROM product_code
WHERE code BETWEEN 80000 AND 89999;
希望这能帮助到你。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;继续提问，否定它：产品代码是字符串，你的代码错了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;抱歉，我没有注意到产品代码是字符串。如果是这样的话，你需要在区间值两边加上单引号，如下：

SELECT * FROM product_code
WHERE code BETWEEN &#39;80000&#39; AND &#39;89999&#39;;
请原谅我的错误。🙏
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;恭喜你，它会认错的。&lt;/p&gt;</description>
        </item>
        <item>
        <title>几个不常用GIT命令汇总</title>
        <link>https://ttf248.life/p/less-common-git-commands-summary/</link>
        <pubDate>Fri, 17 Feb 2023 10:08:57 +0800</pubDate>
        
        <guid>https://ttf248.life/p/less-common-git-commands-summary/</guid>
        <description>&lt;p&gt;不常用，但是很有用的&lt;code&gt;git&lt;/code&gt;命令&lt;/p&gt;
&lt;h3 id=&#34;重装系统导致windows上文件夹所有者信息变更&#34;&gt;重装系统导致&lt;code&gt;windows&lt;/code&gt;上文件夹所有者信息变更
&lt;/h3&gt;&lt;p&gt;新版本&lt;code&gt;git&lt;/code&gt;增加了安全性校验，提示不安全，导致无法继续操作&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global --add safe.directory
git config --global --add safe.directory &amp;quot;*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;新电脑保存账号密码信息&#34;&gt;新电脑保存账号密码信息
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global credential.helper store
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果保存的信息需要更新，先清理老的凭证&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --system --unset credential.helper
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>编译器、回调函数、性能测试</title>
        <link>https://ttf248.life/p/compiler-callback-performance-testing/</link>
        <pubDate>Wed, 15 Feb 2023 13:59:25 +0800</pubDate>
        
        <guid>https://ttf248.life/p/compiler-callback-performance-testing/</guid>
        <description>&lt;p&gt;去年设计了一个&lt;code&gt;SDK&lt;/code&gt;，负责处理封装一些事件，对外提供一个类接口，服务初始化的时候，调用方实现对应的类，并将对象指针传给模块。
接触过&lt;code&gt;C11&lt;/code&gt;，好奇心害死猫，就想着这些接口都用&lt;code&gt;lambda&lt;/code&gt;函数对象回调来实现会是什么结果，和纯虚函数的接口定义方法比较，更加灵活。
疑问就出现了，两种不同的语法，从性能角度来说，哪个更快一些？不懂编译原理，弄段代码试试看。&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言
&lt;/h2&gt;&lt;p&gt;在线网址，能选择不同编译器，编译参数，在&lt;code&gt;linux&lt;/code&gt;平台运行代码，亦或者查看对应的汇编代码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt;：有时候做些技术验证，网页执行小片段的代码很省事&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://godbolt.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://godbolt.org/&lt;/a&gt;：用不同的颜色，区分不同的汇编对应的代码，比本地的调试器看起来更加省事。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;标准委员会制定了语法的规则，在编译层面，如何实现，取决于各家的编译器，这里不得不说一声，微软的编译器，挺厉害的。语法糖不是万能的，回调接口不多，使用&lt;code&gt;lambda&lt;/code&gt;更加便捷，也无需定义空回调函数接口；回调接口种类繁多的时候，传统的虚函数更有利于业务接口定义的统一。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;windows&lt;/code&gt;平台，两者性能接近，没有太多的差异&lt;/li&gt;
&lt;li&gt;&lt;code&gt;linux&lt;/code&gt;平台，虚函数和&lt;code&gt;lambda&lt;/code&gt;比较，单次多了1.35ns&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常规的业务系统开发中，此级别的性能损耗可以忽略，引入&lt;code&gt;lambda&lt;/code&gt;，在设计的上，能带来更多的便捷。在设计多信号处理时，尤为明显，底层有事件触发，如果需要落地日志，出入日志对象的的处理函数。当需要更多的业务处理接口时，底层用&lt;code&gt;vector&lt;/code&gt;保存&lt;code&gt;lambda&lt;/code&gt;对象，事件触发时，依次遍历调用，类似于&lt;code&gt;QT&lt;/code&gt;中的信号和槽，日志、监控、业务1、业务2，互相之间完全解耦。&lt;/p&gt;
&lt;h2 id=&#34;代码&#34;&gt;代码
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Counter: 1000000
Time: 3966us
Counter: 1000000
Time: 5316us
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;memory&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;atomic&amp;gt;
#include &amp;lt;string&amp;gt;

std::atomic_int64_t counter = 0;

// 定义回调接口
class UserInterface
{
public:
    virtual void name() = 0;
    virtual void full_name() = 0;
};

class User : public UserInterface
{
public:
    void name() {}
    void full_name() { counter++; }
};

void to_string(UserInterface* user)
{
    user-&amp;gt;name();
    user-&amp;gt;full_name();
}

using name_handler = std::function&amp;lt;void()&amp;gt;;
using full_name_handler = std::function&amp;lt;void()&amp;gt;;

class Test
{
    name_handler name_;
    full_name_handler full_name_;

public:
    void set_name_handler(name_handler name)
    {
        name_ = name;
    }

    void set_full_name_handler(full_name_handler full_name)
    {
        full_name_ = full_name;
    }

    void to_string()
    {
        name_();
        full_name_();
    }
};

int main()
{
    User user;

    auto start = std::chrono::high_resolution_clock::now();

    for (int i = 0; i &amp;lt; 1000000; i++)
    {
        to_string(&amp;amp;user);
    }

    auto end = std::chrono::high_resolution_clock::now();
    std::cout &amp;lt;&amp;lt; &amp;quot;Counter: &amp;quot; &amp;lt;&amp;lt; counter &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;Time: &amp;quot; &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(end - start).count() &amp;lt;&amp;lt; &amp;quot;us&amp;quot; &amp;lt;&amp;lt; std::endl;

    counter = 0;
    auto name = []() {};
    auto full_name = []() { counter++; };

    Test test;
    test.set_name_handler(name);
    test.set_full_name_handler(full_name);

    start = std::chrono::high_resolution_clock::now();

    for (int i = 0; i &amp;lt; 1000000; i++)
    {
        test.to_string();
    }

    end = std::chrono::high_resolution_clock::now();
    std::cout &amp;lt;&amp;lt; &amp;quot;Counter: &amp;quot; &amp;lt;&amp;lt; counter &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;Time: &amp;quot; &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(end - start).count() &amp;lt;&amp;lt; &amp;quot;us&amp;quot; &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;后记&#34;&gt;后记
&lt;/h2&gt;&lt;p&gt;查找资料的时候，翻到类似的代码片段 &lt;a class=&#34;link&#34; href=&#34;https://gist.githubusercontent.com/benloong/8050171/raw/fa577ec923b460862078b8b40233a42a1c619eeb/functionperformance.cpp&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;functionperformance.cpp&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;memory&amp;gt;
#include &amp;lt;functional&amp;gt;

using namespace std;
using namespace std::chrono;

class Base
{
public:
	Base(){}
	virtual ~Base(){}
	virtual int func(int i) = 0;
};

class Derived : public Base
{
public:
	Derived(int base = 10) : base{base}
	{

	}
	~Derived(){}

	virtual int func(int i)
	{
		return i*base;
	}
private:
	int base;
};

struct Func
{
	int base;
	int operator()(int i)
	{
		return i*base;
	}
	Func(int base) : base {base}
	{

	}
};
const int base = 10;
int calculate(int i)
{
	return base*i;
}

int main()
{
	const int num = 10000;
	Base *p = new Derived{10};
	int total = 0;
	auto start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += p-&amp;gt;func(i);
	}
	auto end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nvirtual call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;

	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += calculate(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\ndirect function call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;

	Func functor{10};
	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += functor(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nfunctor call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;
	int base = 10;
	function&amp;lt;int(int)&amp;gt; lambda = [base](int i)
	{
		return i*base;
	};
	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += lambda(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nlambda call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;
	return 0;
}

/*
test on mac mini i7 2.7GHz
clang++ -std=c++11 chronotest.cpp -O0
output:
result: 499950000
virtual call elapsed: 	43171 nanoseconds.

result: 499950000
direct function call elapsed: 	31379 nanoseconds.

result: 499950000
functor call elapsed: 	41497 nanoseconds.

result: 499950000
lambda call elapsed: 	207416 nanoseconds.
===================================================
clang++ -std=c++11 chronotest.cpp -O1
output:
result: 499950000
virtual call elapsed: 	26144 nanoseconds.

result: 499950000
direct function call elapsed: 	22384 nanoseconds.

result: 499950000
functor call elapsed: 	33477 nanoseconds.

result: 499950000
lambda call elapsed: 	55799 nanoseconds.
===================================================
clang++ -std=c++11 chronotest.cpp -O2
result: 499950000
virtual call elapsed: 	22284 nanoseconds.

result: 499950000
direct function call elapsed: 	36 nanoseconds.

result: 499950000
functor call elapsed: 	30 nanoseconds.

result: 499950000
lambda call elapsed: 	28292 nanoseconds.

===================================================
clang++ -std=c++11 chronotest.cpp -O3
result: 499950000
virtual call elapsed: 	18975 nanoseconds.

result: 499950000
direct function call elapsed: 	29 nanoseconds.

result: 499950000
functor call elapsed: 	30 nanoseconds.

result: 499950000
lambda call elapsed: 	22542 nanoseconds.
===================================================
clang++ -std=c++11 chronotest.cpp -O4

result: 499950000
virtual call elapsed: 	22141 nanoseconds.

result: 499950000
direct function call elapsed: 	30 nanoseconds.

result: 499950000
functor call elapsed: 	30 nanoseconds.

result: 499950000
lambda call elapsed: 	22584 nanoseconds.
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里多了两种模式，普通函数和仿函数，提供接口回调的方式和直接调用比较，性能损耗是数量级的差异，仿函数性能和函数接近，有时候仿函数的性能更优，编译原理这块算是知识盲区，猜测是由于访问的变量地址和函数挨着，有利于&lt;code&gt;CPU&lt;/code&gt;处理&lt;/p&gt;
&lt;p&gt;附上 &lt;code&gt;wandbox&lt;/code&gt; 运行结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;result: 499950000
virtual call elapsed: 6143 nanoseconds.

result: 499950000
direct function call elapsed: 30 nanoseconds.

result: 499950000
functor call elapsed: 31 nanoseconds.

result: 499950000
lambda call elapsed: 15134 nanoseconds.
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>主机序、网络序，通过调试器，直接观察</title>
        <link>https://ttf248.life/p/host-network-byte-order-debugger/</link>
        <pubDate>Tue, 10 Jan 2023 14:18:12 +0800</pubDate>
        
        <guid>https://ttf248.life/p/host-network-byte-order-debugger/</guid>
        <description>&lt;p&gt;在计算机的发展历史中，如何存储数据并没有统一的标准。&lt;/p&gt;
&lt;p&gt;字节的排列方式有两个通用规则。例如，将一个多位数的低位放在较小的地址处，高位放在较大的地址处，则称小端序；反之则称大端序。在网络应用中，字节序是一个必须被考虑的因素，因为不同机器类型可能采用不同标准的字节序，所以均按照网络标准转化。&lt;/p&gt;
&lt;p&gt;按照阅读习惯，大端字节序更符合从左到右的阅读顺序。&lt;/p&gt;
&lt;h2 id=&#34;处理器体系httpszhwikipediaorgwikie5ad97e88a82e5ba8f&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;处理器体系&lt;/a&gt;
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;x86、MOS Technology 6502、Z80、VAX、PDP-11 等处理器为小端序&lt;/li&gt;
&lt;li&gt;Motorola 6800、Motorola 68000、PowerPC 970 等处理器为大端序&lt;/li&gt;
&lt;li&gt;ARM、PowerPC（除PowerPC 970外）、DEC Alpha、SPARC V9、MIPS、PA-RISC及IA64的字节序是可配置的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;网络序&#34;&gt;网络序
&lt;/h2&gt;&lt;p&gt;网络传输一般采用大端序，也被称之为网络字节序，或网络序。IP协议中定义大端序为网络字节序。
&lt;code&gt;Berkeley&lt;/code&gt;套接字定义了一组转换函数，用于16和32bit整数在网络序和本机字节序之间的转换。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;arpa/inet.h&amp;gt;

uint32_t htonl(uint32_t hostlong); //把uint32_t类型从主机序转换到网络序
uint16_t htons(uint16_t hostshort); //把uint16_t类型从主机序转换到网络序
uint32_t ntohl(uint32_t netlong); //把uint32_t类型从网络序转换到主机序
uint16_t ntohs(uint16_t netshort); //把uint16_t类型从网络序转换到主机序
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果选用&lt;code&gt;asio&lt;/code&gt;作为网络库，内置的命名空间中有跨平台适配的函数名&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;boost::asio::detail::socket_ops::network_to_host_long&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::network_to_host_short&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::host_to_network_long&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::host_to_network_short&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;visual-studio-调试器&#34;&gt;visual studio 调试器
&lt;/h2&gt;&lt;p&gt;调试模式下，选中调试菜单，窗口，勾选内存窗口&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;visual studio&lt;/code&gt;中，可以直接在调试器中查看内存中的数据，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/host-network-byte-order-debugger/Snipaste_2023-01-10_14-44-00.png&#34;
	width=&#34;535&#34;
	height=&#34;147&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;调试器菜单&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;363&#34;
		data-flex-basis=&#34;873px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;查看内存的方式&#34;&gt;查看内存的方式
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;窗口直接输出 &amp;amp;变量名，跳转到对应变量地址&lt;/li&gt;
&lt;li&gt;如果变量原本就是指针，双击选中变量，拖动到内存窗口，展示对应地址的内容&lt;/li&gt;
&lt;li&gt;如果变量不是指针，添加到计算窗口，获取地址，然后手工复制到内存窗口&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;举个栗子&#34;&gt;举个栗子
&lt;/h3&gt;&lt;p&gt;收到一段数据，存储到&lt;code&gt;buffer&lt;/code&gt;对象中，将网络序转成主机序，得到&lt;code&gt;body_length&lt;/code&gt;等于 30，服务端划分了四个字节用于传出此数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool NetworkMessage::decode_header()
{
    // 网络序转成主机序
    body_length_ = boost::asio::detail::socket_ops::network_to_host_long(*(int *)buffer_.data());
    return auto_reserve(body_length_);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;大端字节序&lt;/strong&gt;：在内存窗口中，观察 &lt;code&gt;buffer_&lt;/code&gt; 的内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/host-network-byte-order-debugger/buffer_.png&#34;
	width=&#34;603&#34;
	height=&#34;318&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;buffer_&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;189&#34;
		data-flex-basis=&#34;455px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;小端字节序&lt;/strong&gt;：在内存窗口中，观察 &lt;code&gt;body_length_&lt;/code&gt; 的内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/host-network-byte-order-debugger/body_length_.png&#34;
	width=&#34;581&#34;
	height=&#34;333&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;body_length_&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;174&#34;
		data-flex-basis=&#34;418px&#34;
	
&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>C11: sleep for vs yield</title>
        <link>https://ttf248.life/p/c11-sleep-for-vs-yield/</link>
        <pubDate>Tue, 20 Sep 2022 20:54:51 +0800</pubDate>
        
        <guid>https://ttf248.life/p/c11-sleep-for-vs-yield/</guid>
        <description>&lt;p&gt;翻看代码的时候，&lt;code&gt;std::this_thread::yield()&lt;/code&gt; 猛的引入眼帘，&lt;code&gt;C11&lt;/code&gt;里面的语法糖，用了不少，&lt;code&gt;yield&lt;/code&gt;还是第一次看到，以前都没注意。&lt;/p&gt;
&lt;p&gt;没查手册，首先想到的是不是和异步变成相关，&lt;code&gt;yield&lt;/code&gt;boost库的协程实现里面用到了这个单词，这里肯定和协程没关系，控制逻辑和普通线程相关。&lt;/p&gt;
&lt;h2 id=&#34;文档&#34;&gt;文档
&lt;/h2&gt;&lt;h3 id=&#34;yield&#34;&gt;yield
&lt;/h3&gt;&lt;p&gt;此函数的准确性为依赖于实现，特别是使用中的 OS 调度器机制和系统状态。例如，先进先出实时调度器（ Linux 的 SCHED_FIFO ）将悬挂当前线程并将它放到准备运行的同优先级线程的队列尾（而若无其他线程在同优先级，则 yield 无效果）&lt;/p&gt;
&lt;h3 id=&#34;sleep_for&#34;&gt;sleep_for
&lt;/h3&gt;&lt;p&gt;阻塞当前线程执行，至少经过指定的 sleep_duration
此函数可能阻塞长于 sleep_duration ，因为调度或资源争议延迟
标准库建议用稳定时钟度量时长。若实现用系统时间代替，则等待时间亦可能对时钟调节敏感&lt;/p&gt;
&lt;h3 id=&#34;分析&#34;&gt;分析
&lt;/h3&gt;&lt;p&gt;两个函数都是让当前线程不再占用线程，执行的效果按照平台情况而定？看到这里依旧有点云里雾里的，运行代码看看执行效果&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ThinkPad 笔记本（visual studio 社区版2022）、腾讯云S2标准服务器（gcc8.5）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运行平台&lt;/th&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;第一次/us&lt;/th&gt;
&lt;th&gt;第二次/us&lt;/th&gt;
&lt;th&gt;第三次/us&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;sleep_for&lt;/td&gt;
&lt;td&gt;9872&lt;/td&gt;
&lt;td&gt;1884&lt;/td&gt;
&lt;td&gt;11302&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;yield&lt;/td&gt;
&lt;td&gt;119&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;sleep_for&lt;/td&gt;
&lt;td&gt;171&lt;/td&gt;
&lt;td&gt;168&lt;/td&gt;
&lt;td&gt;167&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;yield&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;td&gt;102&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;从运行结果不难理解，由于操作系统实现的不同，高精度的休眠时，&lt;code&gt;sleep_for&lt;/code&gt;稳定性差异巨大，如果想要高精度的休眠，使用&lt;code&gt;yield&lt;/code&gt;更加合适&lt;/p&gt;
&lt;p&gt;时间精度提升到&lt;code&gt;ms&lt;/code&gt;时，两者差异并不明显&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;thread&amp;gt;
 
// 建议其他线程运行一小段时间的“忙睡眠”
void little_sleep(std::chrono::microseconds us)
{
    auto start = std::chrono::high_resolution_clock::now();
    auto end = start + us;
    do {
        std::this_thread::yield();
    } while (std::chrono::high_resolution_clock::now() &amp;lt; end);
}
 
int main()
{
    auto start = std::chrono::high_resolution_clock::now();
 
    little_sleep(std::chrono::microseconds(100));
    std::this_thread::sleep_for(std::chrono::microseconds(100));
 
    auto elapsed = std::chrono::high_resolution_clock::now() - start;
    std::cout &amp;lt;&amp;lt; &amp;quot;waited for &amp;quot;
              &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(elapsed).count()
              &amp;lt;&amp;lt; &amp;quot; microseconds\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/header/thread.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/header/thread.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/thread/sleep_for.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/thread/sleep_for.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Linux服务器，重置Mysql密码</title>
        <link>https://ttf248.life/p/linux-server-reset-mysql-password/</link>
        <pubDate>Tue, 20 Sep 2022 14:27:35 +0800</pubDate>
        
        <guid>https://ttf248.life/p/linux-server-reset-mysql-password/</guid>
        <description>&lt;p&gt;有台闲置的腾讯云服务器，年底到期，也没想着续费，部署个MYSQL当作开发用的数据库。重装系统的时候，图省事，直接选择了腾讯云提供的三方镜像，已经安装好了MYSQL数据库。原以为系统里面应该自带个Readme之类的文件，说明下密码是什么，部署路径是什么。&lt;/p&gt;
&lt;p&gt;腾讯云重装系统很快，一分钟左右通知已经重装好了，登录进去，&lt;code&gt;systemctl status mysql&lt;/code&gt; 服务已经启动了，找找密码在哪里，找了一圈，没找到，逐渐开始自闭。&lt;/p&gt;
&lt;p&gt;这时想着，都已经摸到了服务器，拿着&lt;code&gt;root&lt;/code&gt;权限，总归是有法子重置下密码。翻翻资料，阿里云论坛有个帖子，继续折腾。&lt;/p&gt;
&lt;h2 id=&#34;重置密码&#34;&gt;重置密码
&lt;/h2&gt;&lt;p&gt;编辑配置文件 &lt;code&gt;vim /etc/my.cnf&lt;/code&gt;，&lt;code&gt;mysqld&lt;/code&gt;节点增加配置：&lt;code&gt;skip-grant-tables&lt;/code&gt;，执行命令重启数据：&lt;code&gt;systemctl restart mysql&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;再使用&lt;code&gt;mysql&lt;/code&gt;直接登录数据，接来下就是正常操作了，重置&lt;code&gt;root&lt;/code&gt;用户密码，顺带开启下允许远程登录&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;USE mysql;
UPDATE user SET authentication_string = password (&#39;pass&#39;) WHERE User = &#39;root&#39;;
grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;pass&#39; with grant option;
flush privileges;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;回退修改的配置文件，重启下数据库，搞定。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://help.aliyun.com/document_detail/42520.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://help.aliyun.com/document_detail/42520.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>浅谈自动化测试</title>
        <link>https://ttf248.life/p/automated-testing-overview/</link>
        <pubDate>Thu, 04 Aug 2022 11:39:18 +0800</pubDate>
        
        <guid>https://ttf248.life/p/automated-testing-overview/</guid>
        <description>&lt;p&gt;金融交易系统在测试上的投入，远超其他系统，繁琐的测试步骤重复进行，&lt;code&gt;ROI&lt;/code&gt; 太低。随着项目和人员的更替，不可避免引入更多的不可控因素，常见的情况，修改的是A接口输出的某个字段，却影响了B接口的结果，每次版本发布，风险也在积累。&lt;/p&gt;
&lt;h2 id=&#34;理论知识&#34;&gt;理论知识
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如何衡量自动化的价值？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个自动化测试案例ROI = （手工运行时间）*（运行次数）/ (开发成本 + 维护成本)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;哪些功能需要做自动化测试？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用户常用的功能，不会经常改变的功能。针对此类型的接口编写自动化测试代码，收益最高。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;为什么选择这个时间点推动自动化测试？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;临近项目上线，肯定不合适，远水解不了近渴，自动化属于长期收益模型。项目已经在&lt;strong&gt;生产环境&lt;/strong&gt;上线，进入稳定发布周期，此时最为合适。&lt;/p&gt;
&lt;h2 id=&#34;框架的选择&#34;&gt;框架的选择
&lt;/h2&gt;&lt;p&gt;缺乏相关实践经验的情况下，拿到自动化测试这么一个任务，常规开局：打开搜索引擎，寻找当前系统&lt;strong&gt;技术栈&lt;/strong&gt;能用上的工具和框架，过一遍使用手册，开工大吉。能立马找个合适的工具，恭喜你，&lt;strong&gt;完美开局&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;先说一声我错了，翻查了相关的资料，不是说没有，而是框架本身太复杂了，部署占用的资源也过多。小白入门需要的是小巧的，精简的，咨询测试组的同事，提到了 &lt;code&gt;Python&lt;/code&gt; 自建框架，简单来说就是用现有的单元测试框架，封装成自动测试框架。&lt;/p&gt;
&lt;p&gt;参考此项目的设计思路：&lt;a class=&#34;link&#34; href=&#34;https://github.com/wintests/pytestDemo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/wintests/pytestDemo&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;为什么需要框架&#34;&gt;为什么需要框架？
&lt;/h2&gt;&lt;p&gt;服务有多个不同的部署环境，开发环境、测试环境、线上测试环境，框架的作用在于做一层剥离，测试案例和数据进行分离，按照不同的环境配置不同的案例数据，当然也支持公用的数据。&lt;/p&gt;
&lt;p&gt;核心的逻辑都是为了提高自动化的利用率。场景再复杂一些，不同环境之间的数据就是不通的，完全没有任何关系，配置案例数据的时候，增加 &lt;code&gt;label&lt;/code&gt; 标签即可，指定当前数据支持的环境。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://time.geekbang.org/column/article/496850&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;做性价比最高的自动化测试&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>为什么需要学习一门新语言</title>
        <link>https://ttf248.life/p/why-learn-a-new-language/</link>
        <pubDate>Thu, 04 Aug 2022 11:27:30 +0800</pubDate>
        
        <guid>https://ttf248.life/p/why-learn-a-new-language/</guid>
        <description>&lt;p&gt;从上学时期开始算，接触 &lt;code&gt;C++&lt;/code&gt; 已经十多年了，为什么需要学习其他的编程语言？&lt;/p&gt;
&lt;p&gt;工作经历：缺乏优雅的模块设计经验，&lt;code&gt;C++&lt;/code&gt; 语法是自由的，学习了其他的语言，也能引导写出更优雅的设计&lt;/p&gt;
&lt;p&gt;编写一些工具的时候，时常会用到&lt;/p&gt;
&lt;p&gt;底层库的设计也好、业务模块实现也好，设计的准则都是想通的&lt;/p&gt;</description>
        </item>
        <item>
        <title>Visual Studio 编译字符集[转]</title>
        <link>https://ttf248.life/p/visual-studio-character-set/</link>
        <pubDate>Thu, 04 Aug 2022 10:51:43 +0800</pubDate>
        
        <guid>https://ttf248.life/p/visual-studio-character-set/</guid>
        <description>&lt;p&gt;&lt;code&gt;C++&lt;/code&gt;跨平台开发，中文操作系统经常能碰到：&lt;code&gt;error C2001&lt;/code&gt;常量中有换行符&lt;/p&gt;
&lt;h2 id=&#34;visual-studio&#34;&gt;visual studio
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;cmake&lt;/code&gt;组织项目编译脚本，&lt;code&gt;windows&lt;/code&gt;系统下面开发时，临时生成一份解决方案，跨平台的原因，文件编码选择&lt;code&gt;utf-8&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;引用资料从原理出发详细的解释了问题的的成因&lt;/p&gt;
&lt;p&gt;针对编码，&lt;code&gt;MSVC&lt;/code&gt;有专门的编译选项&lt;code&gt;/source-charset&lt;/code&gt;和&lt;code&gt;/execution-charset&lt;/code&gt;，前者表示文件本身的编码，后者表示编译以后的字符数组内的字节是什么编码，编码问题基本可以用这两个选项解决。&lt;/p&gt;
&lt;p&gt;比如，&lt;code&gt;windows&lt;/code&gt;的&lt;code&gt;cmd&lt;/code&gt;控制台默认只能显示&lt;code&gt;GBK&lt;/code&gt;编码，但是代码文件本身是&lt;code&gt;UTF-8&lt;/code&gt;，因为跨平台的缘故，又不方便直接修改成&lt;code&gt;GBK&lt;/code&gt;，当然这里就不包括为不同平台写编码转换代码这种办法。在&lt;code&gt;Win10&lt;/code&gt;上，可以设置这两个编译选项为&lt;code&gt;/source-charset:utf-8 /execution-charset:gbk&lt;/code&gt;，表示让编译器以&lt;code&gt;UTF-8&lt;/code&gt;编码读入，然后转为&lt;code&gt;GBK&lt;/code&gt;保存在数组里面，这样直接&lt;code&gt;printf&lt;/code&gt;就能在&lt;code&gt;cmd&lt;/code&gt;控制台上正常显示汉字。&lt;/p&gt;
&lt;h2 id=&#34;cmake-针对-visual-studio-设置&#34;&gt;CMake 针对 Visual studio 设置
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;if( WIN32 )
    message( STATUS &amp;quot;Configuring trade on WIN32&amp;quot;)
    set( CMAKE_CXX_FLAGS &amp;quot;${CMAKE_CXX_FLAGS} /source-charset:utf-8 /execution-charset:gbk&amp;quot;)
endif()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/146543940&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/146543940&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Windows平台快速统计文件夹大小</title>
        <link>https://ttf248.life/p/windows-platform-quick-folder-size-statistics/</link>
        <pubDate>Mon, 01 Aug 2022 19:54:18 +0800</pubDate>
        
        <guid>https://ttf248.life/p/windows-platform-quick-folder-size-statistics/</guid>
        <description>&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt; 平台很简单 &lt;code&gt;du -sh *&lt;/code&gt; 一行代码就搞定了。&lt;code&gt;Windows&lt;/code&gt; 怎么办呢？磁盘很多，想清理一波，文件很多的情况下，系统自带的资源管理器，统计文件夹大小，速度慢的让你想放弃&lt;/p&gt;
&lt;h2 id=&#34;everything&#34;&gt;Everything
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;windows&lt;/code&gt; 平台下做开发的朋友，没有亲手用过 &lt;code&gt;everything&lt;/code&gt;，也应该听朋友提过。搜索速度远超系统自带的资源管理器。既然系统层面支持快速索引文件，肯定就能找到类似的工具，建立文件索引的同时，统计下文件的大小。&lt;/p&gt;
&lt;h2 id=&#34;wiztree&#34;&gt;WizTree
&lt;/h2&gt;&lt;p&gt;官网：&lt;a class=&#34;link&#34; href=&#34;https://www.diskanalyzer.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.diskanalyzer.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;普通的安装模式或者绿色版本解压运行&lt;/p&gt;
&lt;p&gt;速度快，数据展示类型丰富，左侧是树状图模式，右边是文件类型，当然也有图形化展示，在软件底栏。&lt;/p&gt;
&lt;h2 id=&#34;spacesnifferupdate-2023-不再维护更新了&#34;&gt;SpaceSniffer(update 2023 不再维护更新了)
&lt;/h2&gt;&lt;p&gt;软件官网：&lt;a class=&#34;link&#34; href=&#34;http://www.uderzo.it/main_products/space_sniffer/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.uderzo.it/main_products/space_sniffer/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;操作很简单，选择对应的盘符，软件会用图形化的方式，展示文件夹体积，体积越大，图像中对应的矩阵也就越大，其余操作，自己点点就明白了，支持输入条件过滤文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件体积过滤&lt;/li&gt;
&lt;li&gt;文件日期过滤&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/windows-platform-quick-folder-size-statistics/space_sniffer.gif&#34;
	width=&#34;960&#34;
	height=&#34;540&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;基础用法&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;177&#34;
		data-flex-basis=&#34;426px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/windows-platform-quick-folder-size-statistics/advance.gif&#34;
	width=&#34;960&#34;
	height=&#34;540&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;高级用法&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;177&#34;
		data-flex-basis=&#34;426px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://moe.best/software/spacesniffer.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://moe.best/software/spacesniffer.html&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>如何Copy网页样式表（CSS）：元素审查</title>
        <link>https://ttf248.life/p/how-to-copy-webpage-css-element-inspect/</link>
        <pubDate>Sun, 31 Jul 2022 23:36:48 +0800</pubDate>
        
        <guid>https://ttf248.life/p/how-to-copy-webpage-css-element-inspect/</guid>
        <description>&lt;p&gt;静态博客的主题，主流是基于国外的模板，进行修改调整，没有过多考虑中文内容的排版&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;半个月前，调整了一下博客的样式表，工作多年都是做的后端服务开发，前端纯纯的小白一枚。前后折腾了半天，设计上都不太合理。灵光闪现，想到了常看的技术博客：infoq、开源中国，这些站点的排版看着就很不错，能不能借来用用？看了一会源码文件，定位相关的元素弄的一头雾水。&lt;/p&gt;
&lt;p&gt;做前端的朋友看到这里可能要笑了。。定位指定的元素都不懂。不懂没事，周末时间多，停下来思考下，以前写 &lt;code&gt;python&lt;/code&gt; 爬虫的时候，好像用到了类似的东西。&lt;/p&gt;
&lt;h3 id=&#34;元素审查&#34;&gt;元素审查
&lt;/h3&gt;&lt;p&gt;没错，就是浏览器自带的元素审查工具，复制样式表、定位指定元素，都是分分钟的事情；&lt;code&gt;selector&lt;/code&gt; 定位元素、&lt;code&gt;hugo&lt;/code&gt; 新建 &lt;code&gt;user define css&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;复制元素&lt;/li&gt;
&lt;li&gt;复制 outerHTML&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;复制 selector&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;复制 JS 路径&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;复制样式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;复制 XPath&lt;/li&gt;
&lt;li&gt;复制完整的 XPath&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Windows平台编辑超大型文件：EmEditor (Text Editor)</title>
        <link>https://ttf248.life/p/windows-platform-edit-large-files-emeditor-text-editor/</link>
        <pubDate>Sun, 31 Jul 2022 23:21:24 +0800</pubDate>
        
        <guid>https://ttf248.life/p/windows-platform-edit-large-files-emeditor-text-editor/</guid>
        <description>&lt;p&gt;上海国安数据库事件，黑产圈子里面闹的沸沸扬扬，也不知道真假，过两年如果还记得，再回头看看。根据以往的经验，更新了一波本地的社工数据库资料，看到一个巨型SQL文件：17.9G，一般的文本编辑器，预览都是个问题，更别说打开了，和网友闲聊，提到了：EmEditor。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;官网：&lt;a class=&#34;link&#34; href=&#34;https://www.emeditor.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.emeditor.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;周末抽空试了一下，挺方便的，设计上就支持编辑大型文件，内存足够的情况下，整个文件都载入到内存中，搜索、编辑速度都挺快，也支持分割文件。&lt;/p&gt;</description>
        </item>
        <item>
        <title>以为很简单的事情，增加一个代码复制按钮</title>
        <link>https://ttf248.life/p/add-copy-button-for-simple-task/</link>
        <pubDate>Fri, 25 Feb 2022 01:23:39 +0800</pubDate>
        
        <guid>https://ttf248.life/p/add-copy-button-for-simple-task/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;ouuan&lt;/code&gt; 弄了四个小时，看到这句话的时候，我还觉得搞笑了，怎么可能这么久？最后一看时间：三个小时。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;算是二零二二年开年的第一篇稿子，要搞的东西不复杂，就和标题说的一模一样（此时的我还很年轻），以为照抄 &lt;a class=&#34;link&#34; href=&#34;https://ouuan.github.io/post/from-hexo-to-hugo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;作业&lt;/a&gt; 就行，放到收藏夹里面，拖拖拉拉等了一个多月，终于想起来这个事情。&lt;/p&gt;
&lt;p&gt;迁移到&lt;code&gt;hugo&lt;/code&gt;的时候一直觉得插件太少了，不能复制代码，导致很多笔记从印象笔记迁移到博客，复制代码的代码的操作就变得繁琐了，严重耽误我水博客的动力。&lt;/p&gt;
&lt;h2 id=&#34;序章&#34;&gt;序章
&lt;/h2&gt;&lt;p&gt;先仔细看看原作者的稿子，通读一遍然后翻翻作者介绍，我靠，碰到个大佬了，清华在读本科生，很早就接触到了计算机，诶，就是皮，先翻翻这个博客再说，完全不记得自己要做什么事情。顺带翻翻作者的&lt;code&gt;Github&lt;/code&gt;仓库，这个修改后的&lt;code&gt;even&lt;/code&gt;主题比现在的好看多了，新功能也多，搞起来，先把相关代码合并到过来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/add-copy-button-for-simple-task/2022-02-25-02-08-19.png&#34;
	width=&#34;215&#34;
	height=&#34;150&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;143&#34;
		data-flex-basis=&#34;344px&#34;
	
&gt; &lt;img src=&#34;https://ttf248.life/p/add-copy-button-for-simple-task/2022-02-25-02-08-40.png&#34;
	width=&#34;217&#34;
	height=&#34;167&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;129&#34;
		data-flex-basis=&#34;311px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;新功能查看文章历史关联递交记录&#34;&gt;新功能：查看文章历史、关联递交记录
&lt;/h3&gt;&lt;p&gt;效果还是不错的，拖到文章末尾就能体验。&lt;/p&gt;
&lt;p&gt;动手前也没太细看作者原仓库的历史记录，以为简单的合并下就好了，最后合并了一堆代码，中间还冲突和N次，无脑覆盖，都是前端和渲染的模板代码，以我要的为准。&lt;/p&gt;
&lt;p&gt;仓库地址：&lt;a class=&#34;link&#34; href=&#34;https://github.com/TianlongXiang/hugo-theme-even&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/TianlongXiang/hugo-theme-even&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中文的一个坑，&lt;code&gt;git&lt;/code&gt;不调整这个参数，会导致生成的获取不到当前文章的&lt;code&gt;commit hash&lt;/code&gt;，导致历史链接生成失败；生成文章完整历史的时候也需要改改自动集成脚本，记得拉取当前仓库全部的历史记录。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/TianlongXiang/TianlongXiang.github.io/commit/0d860154de9b335ed88a57d62eedd4b6e3ccbeee&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;feat: 尝试拉取完整 github 仓库，用于动态更新文章最后一次改动记录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/TianlongXiang/TianlongXiang.github.io/commit/1b5d719966737f16a8c67880370dc2722adea0b3&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;chore: 路径存在中文，hugo GitInfo 需要启用此设置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;name: Build Github
run: git config --global core.quotePath false &amp;amp;&amp;amp; hugo -b &amp;quot;https://www.xiangtianlong.com/&amp;quot; -d &amp;quot;github_public&amp;quot; &amp;amp;&amp;amp; ls
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;样式调整&#34;&gt;样式调整
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;调整站点内容宽度，之前的设计适合移动端和电脑端，实际上也没人手机上看，我自己都是电脑上看&lt;/li&gt;
&lt;li&gt;目录栏支持自动伸缩&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;参考&lt;code&gt;ouuan&lt;/code&gt;的代码记录看了半个多小时，愣是没太看懂怎么增加的复制按钮。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时光穿梭，一月之后，又想到这事&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然这个作业没看懂，换个作业抄，总归能抄明白。搜索出来的结果，还挺让人意外，&lt;code&gt;hugo&lt;/code&gt;官方的论坛里面就有个帖子提到了如何增加复制按钮，跑过去一看，逻辑清晰。懵逼的事情来了，回到的站点一看&lt;code&gt;even&lt;/code&gt;渲染生成的代码块样式和资料中的描述不同，这块就比较啰嗦了，简单记录下。&lt;/p&gt;
&lt;p&gt;由于基本不懂前端开发，不懂的地方就开着浏览器&lt;code&gt;审查元素&lt;/code&gt;，对着代码分析、靠着右边的样式器信息，慢慢也分析懂了逻辑；&lt;code&gt;JavaScript&lt;/code&gt;没看懂，控制台来点日志。不懂的时候很多，静下心，慢慢梳理拆分逻辑，总归能找到思路。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;pre&lt;/code&gt;节点有多个，这里指的是单个代码块，主题自己渲染了一行号出来，导致复制按钮出来两个&lt;/li&gt;
&lt;li&gt;想要关点主题自带的代码高亮渲染，奈何这个主题设置不熟悉&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hugo&lt;/code&gt;官网看资料，看了个半懂，知道有&lt;code&gt;markup&lt;/code&gt;设置能控制代码高亮&lt;/li&gt;
&lt;li&gt;调整配置文件，一直不对劲，渲染出来和预期不同&lt;/li&gt;
&lt;li&gt;发现这堆设置&lt;code&gt;pygmentsOptions&lt;/code&gt;，又继续翻资料，调整设置，先去掉行号&lt;/li&gt;
&lt;li&gt;配置自定义的&lt;code&gt;css&lt;/code&gt;样式表，配置自定义的&lt;code&gt;js&lt;/code&gt;脚本&lt;/li&gt;
&lt;li&gt;既然都搞了这么多事情，脑子突然想到最近看到一个配色图不错，改改按钮的样式：中国风天青色走起&lt;/li&gt;
&lt;/ol&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:20%&#34; src=&#34;2022-02-25-02-01-22.png&#34; /&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:20%&#34; src=&#34;2022-02-25-02-01-33.png&#34; /&gt;
&lt;p&gt;ouuan 弄了四个小时，看到这句话的时候，我还觉得搞笑了，怎么可能这么久？最后一看时间：三个小时。&lt;/p&gt;
&lt;h2 id=&#34;参考链接&#34;&gt;参考链接
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://ouuan.github.io/post/from-hexo-to-hugo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ouuan.github.io/post/from-hexo-to-hugo/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://gohugobrasil.netlify.app/content-management/syntax-highlighting/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://gohugobrasil.netlify.app/content-management/syntax-highlighting/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://gohugo.io/getting-started/configuration-markup#highlight&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://gohugo.io/getting-started/configuration-markup#highlight&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.dannyguo.com/blog/how-to-add-copy-to-clipboard-buttons-to-code-blocks-in-hugo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.dannyguo.com/blog/how-to-add-copy-to-clipboard-buttons-to-code-blocks-in-hugo/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>混沌工程</title>
        <link>https://ttf248.life/p/chaos-engineering/</link>
        <pubDate>Wed, 28 Jul 2021 14:35:07 +0800</pubDate>
        
        <guid>https://ttf248.life/p/chaos-engineering/</guid>
        <description>&lt;p&gt;一种破坏系统的模式，进行系统稳定性测试&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;国内的互联网行业总是喜欢折腾点新东西出来，有时候听到个名词，一般人都想不到它是什么东西？&lt;/p&gt;
&lt;p&gt;看了部分文章，还是这段针对混沌工程初期的定义，较为容易接受&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;混沌工程的早期探索，其实在行业内一直有，曾经是以故障测试、容灾演练等身份存在。而随着微服务架构的不断发展，以及分布式系统的不断庞大，混沌工程开始崭露头角，越来越被重视。当 Netflix 正式提出混沌工程概念后，相关理论也开始飞快丰富。Netflix 的实践也证明了混沌工程在稳定性领域所带来的巨大意义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;参考链接&#34;&gt;参考链接
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.infoq.cn/article/gsqtykoa3uvrtqi1kkmo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;字节跳动混沌工程实践总结&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>kubernetes暂停pod</title>
        <link>https://ttf248.life/p/kubernetes-pause-pod/</link>
        <pubDate>Mon, 12 Jul 2021 11:23:09 +0800</pubDate>
        
        <guid>https://ttf248.life/p/kubernetes-pause-pod/</guid>
        <description>&lt;p&gt;Deployment控制器实现了Kubernetes集群中一个很重要的功能，Pod的水平拓展和收缩功能。这个功能是传统云时代平台所必备的能力。&lt;/p&gt;
&lt;p&gt;碰到一个业务场景，需要修改数据库中的数据，调整后重启Pod节点。但是在Pod运行过程中，一直在修改表字段，需要临时性的暂停应用对表的更新，调整数据后恢复Pod。&lt;/p&gt;
&lt;p&gt;除了暴力的删除Deployment，有没有其他的方式，实现类似暂停的效果？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl scale --replicas=0 deployment/&amp;lt;your-deployment&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在看到答案之前，很多人可能都没想到，看到答案后，会心一笑，脑子没有转弯，思路还停留在直接操作进程的时代，想着直接操作业务进程。&lt;/p&gt;
&lt;h2 id=&#34;参考链接&#34;&gt;参考链接
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/54821044/how-to-stop-pause-a-pod-in-kubernetes&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;how to stop/pause a pod in kubernetes&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>docker二三事</title>
        <link>https://ttf248.life/p/docker-two-three-things/</link>
        <pubDate>Thu, 21 Jan 2021 09:26:07 +0800</pubDate>
        
        <guid>https://ttf248.life/p/docker-two-three-things/</guid>
        <description>&lt;p&gt;工作多年接触到的都是&lt;code&gt;centos&lt;/code&gt;操作系统，如果是&lt;code&gt;mac&lt;/code&gt;用户或者&lt;code&gt;Ubuntu&lt;/code&gt;用户，部分内容无法适用。&lt;/p&gt;
&lt;p&gt;安装部分可以参考清华大学的手册：&lt;a class=&#34;link&#34; href=&#34;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装
&lt;/h2&gt;&lt;p&gt;由于不可知的神秘力量，国内安装docker推荐设置云厂商提供的仓库地址，这里推荐使用&lt;strong&gt;阿里云&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;设置仓库源地址&#34;&gt;设置仓库源地址
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install yum-utils device-mapper-persistent-data lvm2 &amp;amp;&amp;amp; \
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;部署最新版本&#34;&gt;部署最新版本
&lt;/h3&gt;&lt;p&gt;docker作为常用的后台服务，推荐设置为开机启动，当前命令适用于centos7&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum install -y docker-ce docker-ce-cli containerd.io &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;部署指定版本&#34;&gt;部署指定版本
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;kubernetes&lt;/code&gt;和&lt;code&gt;docker&lt;/code&gt;的发布并没与完全同步，如果接下来需要部署&lt;code&gt;kubernetes&lt;/code&gt;，请参考&lt;code&gt;kubernetes&lt;/code&gt;部署说明，安装指定版本的&lt;code&gt;docker&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum list docker-ce --showduplicates | sort -r
sudo yum install -y docker-ce-18.09.2-3.el7 docker-ce-cli-18.09.2-3.el7 containerd.io-18.09.2-3.el7 &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;普通用户添加docker权限&#34;&gt;普通用户添加docker权限
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo usermod -aG docker ${USER}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;卸载&#34;&gt;卸载
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum erase -y docker-ce docker-ce-cli containerd.io
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;日常使用&#34;&gt;日常使用
&lt;/h2&gt;&lt;h3 id=&#34;镜像加速&#34;&gt;镜像加速
&lt;/h3&gt;&lt;p&gt;依旧存在不可知的神秘力量，导致拉取镜像的时候速度不给力，此时国内的云厂商站出来了，提供了很多加速服务，依旧推荐一波&lt;strong&gt;阿里云&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;加速的地址各位看管自己注册阿里云账号获取，此服务免费，阿里云也提供免费的镜像构建服务&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt; /etc/docker/daemon.json &amp;lt;&amp;lt;EOF
{
  &amp;quot;registry-mirrors&amp;quot;: [
    &amp;quot;https://docker.nju.edu.cn&amp;quot;,
    &amp;quot;https://mirror.baidubce.com&amp;quot;,
    &amp;quot;https://docker.m.daocloud.io&amp;quot;,
    &amp;quot;https://docker.mirrors.sjtug.sjtu.edu.cn&amp;quot;
  ]
}
EOF
systemctl daemon-reload &amp;amp;&amp;amp; \
systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;强烈推荐的控制面板&#34;&gt;强烈推荐的控制面板
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker volume create portainer_data &amp;amp;&amp;amp; \
docker run -d --name=portainer --restart=always -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:2.20.3-alpine
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;常用镜像拉取合集&#34;&gt;常用镜像拉取合集
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker pull rancher/rancher:stable &amp;amp;&amp;amp; docker pull  portainer/portainer-ce:2.0.1 &amp;amp;&amp;amp; \
docker pull centos:7 &amp;amp;&amp;amp; docker pull ubuntu:20.04 &amp;amp;&amp;amp; docker pull ubuntu:18.04 &amp;amp;&amp;amp; \
docker pull redis:5 &amp;amp;&amp;amp; docker pull redis:6 &amp;amp;&amp;amp; \
docker pull alpine:3.11 &amp;amp;&amp;amp; docker pull busybox:1.32 &amp;amp;&amp;amp; \
docker pull rabbitmq:3.7-management &amp;amp;&amp;amp; \
docker pull mariadb:10.2 &amp;amp;&amp;amp; \
docker pull nginx:1.18 &amp;amp;&amp;amp; docker pull nginx:1.19 &amp;amp;&amp;amp; \
docker pull mysql:5.6 &amp;amp;&amp;amp; docker pull mysql:8 &amp;amp;&amp;amp; \
docker pull elasticsearch:6.8.11 &amp;amp;&amp;amp; docker pull logstash:6.8.11 &amp;amp;&amp;amp; docker pull kibana:6.8.11 &amp;amp;&amp;amp; \
docker pull zookeeper:3.4 &amp;amp;&amp;amp; \
docker pull influxdb:1.7 &amp;amp;&amp;amp; docker pull grafana/grafana:7.3.1 &amp;amp;&amp;amp; \
docker pull percona:8 &amp;amp;&amp;amp; docker pull percona:5.6 &amp;amp;&amp;amp; \
docker pull cloverzrg/frps-docker:0.34.3 &amp;amp;&amp;amp; docker pull cloverzrg/frpc-docker:0.34.3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;常用组合命令&#34;&gt;常用组合命令
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/engine/reference/commandline/docker/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.docker.com/engine/reference/commandline/docker/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;查看容器运行状态，附加&lt;code&gt;format&lt;/code&gt;参数，查看详细的容器信息，此时不关注镜像信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker ps --format &amp;quot;{{.Names}}: {{.Ports}}: {{.Size}}&amp;quot;
#portainer: 0.0.0.0:8000-&amp;gt;8000/tcp, 0.0.0.0:9000-&amp;gt;9000/tcp: 0B (virtual 172MB)
#influxdb: 0.0.0.0:8086-&amp;gt;8086/tcp: 183B (virtual 311MB)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;一键停止所有容器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker stop $(docker ps -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一键删除所有镜像&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dokcer rmi $(docker images -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;导出镜像&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; &amp;gt; -o XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;导出镜像并压缩&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; | gzip &amp;gt; XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;导入镜像&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker load -i XXX.tar
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Linux搭建Jmeter压测环境</title>
        <link>https://ttf248.life/p/linux-setup-jmeter-testing-environment/</link>
        <pubDate>Tue, 22 Dec 2020 10:12:50 +0800</pubDate>
        
        <guid>https://ttf248.life/p/linux-setup-jmeter-testing-environment/</guid>
        <description>&lt;p&gt;作者对硬件有浓厚兴趣，使用Jmeter进行压力测试，记录了在CentOS 7上部署Jmeter、InfluxDB和Grafana的过程。分享了Jmeter的安装和命令使用，InfluxDB的特点和Docker安装方法，以及Grafana的简单部署和配置。总结了高性能程序模式的经验和参考资料。&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;众所周知&lt;/code&gt;本人对硬件有很浓厚的兴趣，凑巧测试组在用&lt;code&gt;Jmeter&lt;/code&gt;做压力测试，发现性能上不去，作为好奇宝宝的我果断出击，试试公司的压测是怎么玩的。此处还有个小故事，在某个久远的时间点，在开源中国看过一篇帖子，如何绘制看上去更加高大上的性能压测图，在测试围观过&lt;code&gt;windows&lt;/code&gt;版本执行测试，已经做到了可视化的&lt;code&gt;TPS&lt;/code&gt;数据展示，另外配置一份web面板能有什么用？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;脑子想的都是想当然的东西，你要去试试才明白
Don&amp;rsquo;t use GUI mode for load testing! only for Test creation and Test debuggin.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;官方推荐的是通过命令行的方式获取压测报告，绘制GUI的方式展示，存在数据上的误差？对于Jmeter了解的不是很深入，至少找到一个理由去折腾一下&lt;code&gt;Linux&lt;/code&gt;版本的控制台面板&lt;/p&gt;
&lt;p&gt;开源中国的帖子，核心组件的部署方式并不友好，安装所需的文件也需要关注公众号才能下载，作为新生代的好青年，当然是用&lt;code&gt;Docker&lt;/code&gt;替代了。说白了还是自己服务器在境内，跨境的源地址访问速度都很慢，至少镜像服务，阿里云有个免费的加速。&lt;/p&gt;
&lt;p&gt;关于&lt;code&gt;docker&lt;/code&gt;的安装部署，此处不再赘述，推荐参考以前的稿子。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;接下来的内容氛围两大块：基本测试环境组件的搭建、各个组件的简单认知讲解&lt;/p&gt;
&lt;h2 id=&#34;jmeter&#34;&gt;Jmeter
&lt;/h2&gt;&lt;p&gt;Apache JMeter是Apache组织开发的基于Java的压力测试工具。用于对软件做压力测试，它最初被设计用于Web应用测试，但后来扩展到其他测试领域。 它可以用于测试静态和动态资源，例如静态文件、Java 小服务程序、CGI 脚本、Java 对象、数据库、FTP 服务器， 等等。JMeter 可以用于对服务器、网络或对象模拟巨大的负载，来自不同压力类别下测试它们的强度和分析整体性能。另外，JMeter能够对应用程序做功能/回归测试，通过创建带有断言的脚本来验证你的程序返回了你期望的结果。为了最大限度的灵活性，JMeter允许使用正则表达式创建断言。&lt;/p&gt;
&lt;p&gt;Apache jmeter 可以用于对静态的和动态的资源（文件，Servlet，Perl脚本，java 对象，数据库和查询，FTP服务器等等）的性能进行测试。它可以用于对服务器、网络或对象模拟繁重的负载来测试它们的强度或分析不同压力类型下的整体性能。你可以使用它做性能的图形分析或在大并发负载测试你的服务器/脚本/对象。&lt;/p&gt;
&lt;h3 id=&#34;jmeter-部署-centos7&#34;&gt;Jmeter 部署 centos7
&lt;/h3&gt;&lt;p&gt;安装&lt;code&gt;JDK&lt;/code&gt;运行环境、下载&lt;code&gt;Jmeter&lt;/code&gt;安装包&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install java-1.8.0-openjdk -y &amp;amp;&amp;amp; \
wget https://mirrors.bfsu.edu.cn/apache//jmeter/binaries/apache-jmeter-5.4.tgz &amp;amp;&amp;amp; tar -xf apache-jmeter-5.4.tgz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置环境变量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export JMETER_HOME=$HOME/jmeter/apache-jmeter-5.4
export PATH=$JMETER_HOME/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;jmeter-命令&#34;&gt;Jmeter 命令
&lt;/h3&gt;&lt;p&gt;最后会对接&lt;code&gt;Grafana&lt;/code&gt;控制面板，可以不输入&lt;code&gt;-l&lt;/code&gt;参数，在&lt;code&gt;web&lt;/code&gt;控制台观察数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;jmeter -n -t /tmp/order-500-10s.jmx -l /tmp/jmeter-order-report-20200109/order-500-10s.jtl
# 一般不用测试结果和测试报告，简化命令
jmeter -n -t /tmp/order-500-10s.jmx
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;influxdb&#34;&gt;InfluxDB
&lt;/h2&gt;&lt;p&gt;InfluxDB是一款用Go语言编写的开源分布式时序、事件和指标数据库，无需外部依赖。该数据库现在主要用于存储涉及大量的时间戳数据，如DevOps监控数据，APP metrics, loT传感器数据和实时分析数据。&lt;/p&gt;
&lt;h3 id=&#34;influxdb-特点&#34;&gt;InfluxDB 特点
&lt;/h3&gt;&lt;p&gt;InfluxDB的特点可以归纳为以下9个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无结构(无模式)：可以是任意数量的列;&lt;/li&gt;
&lt;li&gt;可以设置metric的保存时间;&lt;/li&gt;
&lt;li&gt;支持与时间有关的相关函数(如min、max、sum、count、mean、median等)，方便统计;&lt;/li&gt;
&lt;li&gt;支持存储策略:可以用于数据的删改。(influxDB没有提供数据的删除与修改方法);&lt;/li&gt;
&lt;li&gt;支持连续查询:是数据库中自动定时启动的一组语句，和存储策略搭配可以降低InfluxDB的系统占用量;&lt;/li&gt;
&lt;li&gt;原生的HTTP支持，内置HTTP API;&lt;/li&gt;
&lt;li&gt;支持类似sql语法;&lt;/li&gt;
&lt;li&gt;支持设置数据在集群中的副本数;&lt;/li&gt;
&lt;li&gt;支持定期采样数据，写入另外的measurement，方便分粒度存储数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;influxdb-docker-安装&#34;&gt;InfluxDB docker 安装
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir influxdb &amp;amp;&amp;amp; cd influxdb &amp;amp;&amp;amp; \
docker run -p 8086:8086 -d --name influxdb -v $PWD:/var/lib/influxdb influxdb:1.7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker exec -it influxdb /bin/bash&lt;/code&gt; 进入容器，执行命令，人工创建数据库&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;root@bce0a55bbc72:/# influx
Connected to http://localhost:8086 version 1.7.10
InfluxDB shell version: 1.7.10
&amp;gt; 交互面板执行命令
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;influxdb-创建数据库和用户&#34;&gt;InfluxDB 创建数据库和用户
&lt;/h3&gt;&lt;p&gt;创建数据库：create database jmeter_t2
查看数据库：show databases
切换数据库：use jmeter_t2
创建用户：create user &amp;ldquo;admin&amp;rdquo; with password &amp;lsquo;admin&amp;rsquo; with all privileges
查看用户：show users&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; show users
user  admin
----  -----
admin true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果显示用户权限&lt;code&gt;admin&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;，数据库的准备工作就完成了&lt;/p&gt;
&lt;h2 id=&#34;grafana&#34;&gt;Grafana
&lt;/h2&gt;&lt;p&gt;编写测试案例的时候发现，图表展示的效果其实没太多必要，接口的&lt;code&gt;tps&lt;/code&gt;数据在命令行执行的时候已经能观测到，更多是想知道程序内部的耗时&lt;/p&gt;
&lt;p&gt;简单部署&lt;code&gt;grafana&lt;/code&gt;控制台面板，导入配置文件对接&lt;code&gt;InfluxDB&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;控制台支持通过标签过滤测试结果，一般只需要配置一个&lt;code&gt;InfluxDB&lt;/code&gt;数据库即可：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用名称&lt;/li&gt;
&lt;li&gt;测试案例名称&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/linux-setup-jmeter-testing-environment/Snipaste_2021-03-09_19-44-22.png&#34;
	width=&#34;861&#34;
	height=&#34;357&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;grafana&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;241&#34;
		data-flex-basis=&#34;578px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -d --name=grafana -p 3000:3000 grafana/grafana:7.3.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;网页版由于采样器间隔会导致计算的&lt;code&gt;TPS&lt;/code&gt;和相关数值与&lt;code&gt;Jmeter&lt;/code&gt;聚合报告不相符，参考链接：&lt;a class=&#34;link&#34; href=&#34;https://www.vinsguru.com/jmeter-real-time-results-influxdb-grafana/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.vinsguru.com/jmeter-real-time-results-influxdb-grafana/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;资料中也描述了如何自定义&lt;code&gt;监听器&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;后记&#34;&gt;后记
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;高性能的程序模式必然是 one loop thread，任何的锁、入队列和出队列，都会造成不必要的性能损失&lt;/li&gt;
&lt;li&gt;核心业务逻辑的耗时大于引入其他代码的耗时，并发才能有效提高效率，核心耗时如果足够小谨慎引入其他代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://my.oschina.net/u/4617935/blog/4680856&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Jmeter系列之Jmeter+Grafana+InfluxDB实时监控&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/_/influxdb&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;influxdb官方镜像&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/r/grafana/grafana&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;grafane官方镜像&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://jmeter.apache.org/download_jmeter.cgi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Jmeter官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@jasonli.studio/to-install-apache-jmeter-in-centos7-294bc72a97ba&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;To install Apache JMeter in CentOS7&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Redhat 和 Centos 生命周期</title>
        <link>https://ttf248.life/p/redhat-centos-lifecycle/</link>
        <pubDate>Tue, 21 Jul 2020 20:02:35 +0800</pubDate>
        
        <guid>https://ttf248.life/p/redhat-centos-lifecycle/</guid>
        <description>&lt;p&gt;线上生产环境操作系统，Red Hat和CentOS为主流选择。记录了两个系统生命周期的官网链接，并分享了从CentOS 8升级到CentOS 8 Stream的经验。&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言
&lt;/h2&gt;&lt;p&gt;线上生产环境操作系统，目前国内的环境来说，Red Hat和CentOS为主流选择。前两年经历了Red Hat 6的退役，特此记录两个系统生命周期官网链接。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://access.redhat.com/support/policy/updates/errata&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Red Hat Enterprise Linux Life Cycle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://wiki.centos.org/zh/About/Product&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CentOS 产品规范&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Red Hat Enterprise Linux（RHEL）和CentOS是企业级服务器操作系统的主流选择。RHEL提供了稳定的支持和更新周期，适合企业级应用。CentOS作为RHEL的社区版，提供了相似的功能和稳定性，但没有官方支持。&lt;/p&gt;
&lt;h2 id=&#34;追更&#34;&gt;追更
&lt;/h2&gt;&lt;p&gt;发布这篇稿子的时候，我也想不到自己会在两年后来更新，前两天刚把日常用的虚拟机，从CentOS 8升级到了CentOS 8 Stream。生产上怎么选择，我不好多说，本地环境还是追求最新的版本。&lt;/p&gt;
&lt;p&gt;CentOS 8 Stream是一个滚动发布的版本，提供了比传统CentOS更快的更新和新特性，适合开发和测试环境使用。&lt;/p&gt;</description>
        </item>
        <item>
        <title>电脑组装那些事</title>
        <link>https://ttf248.life/p/computer-assembly/</link>
        <pubDate>Sat, 18 Jul 2020 14:33:46 +0800</pubDate>
        
        <guid>https://ttf248.life/p/computer-assembly/</guid>
        <description>&lt;p&gt;作者从小对组装电脑充满兴趣，大学后开始接触硬件组装。推荐了硬件性能对比网站和选购建议，包括CPU、固态硬盘、机械硬盘和内存频率等。分享了硬件选购经验和注意事项&lt;/p&gt;
&lt;h3 id=&#34;缘妙不可言&#34;&gt;缘·妙不可言
&lt;/h3&gt;&lt;p&gt;打小呢就想着组装一台自己的电脑，奈何经济条件不允许。好不容易熬到了大学，为了便于携带，配置的也是笔记本。如果非要有个具体的时间点，我是什么时候开始有组装电脑这个念想的，就要说到老家的图书馆。毕竟也是个市区级别的图书馆，不仅有电子阅览室（其实从没去过，据说是按时计费），还有个杂志阅览室，也就是在这里，翻阅到了《大众软件》、《电脑报》这类杂志，对接触电脑不多的我来说，堪称神级科普资料。看到打副本的章节，就想着自己弄个电脑，也去拉怪，当主力输出；看到黑科技呢，幻想自己照着书上的做，也能达到描述的效果（论黑客工具的使用）。虽说高中课业重，就我那会的认知，书要读，玩也要玩，过的也算是“天真烂漫”，打着去图书馆看书的由头，没事就拎着个小包溜达过去，市区不大，一般都是徒步走去图书馆。到了地，吹着空调，看着小说、漫画、游戏杂志，偶尔也看点正经的书籍。&lt;/p&gt;
&lt;p&gt;年纪大了就容易忘事，图书馆引发的还不算是初次萌芽。初中的时候，亲戚家组装过一台电脑，也不知道当初组装那台机器是干嘛用的。操作系统还是 windows 2003，游戏有系统自带的纸牌 + 帝国时代。各种“斗智斗勇”想着偷到钥匙，带着堂弟一起玩游戏。&lt;/p&gt;
&lt;p&gt;刚入初中，学校就有就计算机的初级培训，后来转学，也接触到了一点计算机竞赛的概念。等到了高中，NOIP混过一次。说道这里，就不得不提，校友的力量，高中的计算机大楼是校友捐赠的，包含计算机教学室+图书馆。其实那会也是国内互联网浪潮的初浪。校领导也支持参与计算机竞赛，毕竟前面两届的学长，好几位前辈通过计算机保送了重点大学。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从未这样回顾过我和电脑这些事。也难怪我毕业后硬是从自动化专业义无反顾的转到了计算机行业，种子早已种下，局中人不自知而已。从小接触的多了，以为自己很厉害，其实也就懂个皮毛，最大的优势也就是最初的那份热情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;硬件组装&#34;&gt;硬件组装
&lt;/h3&gt;&lt;p&gt;多逛逛卡吧、chiphell、知乎电脑组装的板块，萌新能较为简单的给出一份自己需要的机器清单。2019年后选购CPU，经济条件不充裕的情况下，想要更高的性能，首选AMD。&lt;/p&gt;
&lt;p&gt;推荐一个常用的硬件性能对比网站：&lt;a class=&#34;link&#34; href=&#34;https://cpu.userbenchmark.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cpu.userbenchmark.com/&lt;/a&gt;，价格这块基本可以和咸鱼的美版做个对比。真大佬可以去咸鱼淘二手的，能便宜很多。如果不是很精通，不推荐去咸鱼，本人就购买了假内存，虽说目前使用没发现问题，不太确定太多了，型号和参数完全对不上。&lt;/p&gt;
&lt;h4 id=&#34;sn550-vs-sn750&#34;&gt;SN550 VS SN750
&lt;/h4&gt;&lt;p&gt;SN550 1TB容量和SN750 1TB容量差别就是，两者持续读写差一倍，一个850MB，一个1.6GB，但日常使用没区别，因为两者4K都一样。当然这里说的是1TB容量的SN550，500G和250G速度顺序读写更慢。其实我觉得只要不是不差钱的，日常使用买SN550就行，我没买这个最大原因不是因为它的顺序读写速度，而是它最大只有1TB容量，而SN750有2TB容量。对我来说，在不额外扩展的情况下，主板的M.2 Nvme接口比这些固态的差价更值钱&lt;/p&gt;
&lt;p&gt;综合网友的结论，入手一块转接板，B150 主板也能支持 M2 接口的固态。&lt;/p&gt;
&lt;h4 id=&#34;机械硬盘选购&#34;&gt;机械硬盘选购
&lt;/h4&gt;&lt;p&gt;机械硬盘目前价格趋于稳定，对于有大量存储需求的用户，需要选购一款合适的机械硬盘，频繁下载资源的用户推荐企业级硬盘，常见的有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;西数金盘&lt;/li&gt;
&lt;li&gt;希捷exos&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;大容量的机械硬盘推荐进行分区，频繁的下载操作固定在某个分区进行，日后出现坏道，可以集中在某个分区，废弃当前分区即可，能有效延长机械硬盘寿命。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;希捷系列&lt;a class=&#34;link&#34; href=&#34;https://www.seagate.com/cn/zh/enterprise-storage/exos-drives/exos-e-drives/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官网介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/computer-assembly/%E5%B8%8C%E6%8D%B7exos1.png&#34;
	width=&#34;589&#34;
	height=&#34;659&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;希捷企业级硬盘概述&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;89&#34;
		data-flex-basis=&#34;214px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/computer-assembly/%E5%B8%8C%E6%8D%B7exos2.png&#34;
	width=&#34;588&#34;
	height=&#34;661&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;希捷企业级硬盘概述&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;88&#34;
		data-flex-basis=&#34;213px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;内存频率&#34;&gt;内存频率
&lt;/h4&gt;&lt;p&gt;日常工作的角度出发，频率不会对性能产生太大的影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/computer-assembly/%E5%86%85%E5%AD%98.png&#34;
	width=&#34;407&#34;
	height=&#34;404&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;内存时序&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;100&#34;
		data-flex-basis=&#34;241px&#34;
	
&gt; &lt;img src=&#34;https://ttf248.life/p/computer-assembly/%E5%92%B8%E9%B1%BC%E5%86%85%E5%AD%98.png&#34;
	width=&#34;407&#34;
	height=&#34;404&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;咸鱼内存&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;100&#34;
		data-flex-basis=&#34;241px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;内存时序（英语：Memory timings或RAM timings）是描述同步动态随机存取存储器（SDRAM）性能的四个参数：CL、TRCD、TRP和TRAS，单位为时钟周期。它们通常被写为四个用破折号分隔开的数字，例如7-8-8-24。第四个参数（RAS）经常被省略，而有时还会加入第五个参数：Command rate（命令速率），通常为2T或1T，也写作2N、1N。这些参数指定了影响随机存取存储器速度的潜伏时间（延迟时间）。较低的数字通常意味着更快的性能。决定系统性能的最终元素是实际的延迟时间，通常以纳秒为单位。&lt;/p&gt;
&lt;p&gt;当将内存时序转换为实际的延迟时，最重要的是注意它是以时钟周期为单位。如果不知道时钟周期的时间，就不可能了解一组数字是否比另一组数字更快。&lt;/p&gt;
&lt;p&gt;举例来说，DDR3-2000内存的时钟频率是1000 MHz，其时钟周期为1 ns。基于这个1 ns的时钟，CL=7给出的绝对延迟为7 ns。而更快的DDR3-2666（时钟1333 MHz，每个周期0.75 ns）则可能用更大的CL=9，但产生的绝对延迟6.75 ns更短。&lt;/p&gt;
&lt;p&gt;现代DIMM包括一个串行存在检测（SPD）ROM芯片，其中包含为自动配置推荐的内存时序。PC上的BIOS可能允许用户调整时序以提高性能（存在降低稳定性的风险），或在某些情况下增加稳定性（如使用建议的时序）。&lt;/p&gt;
&lt;p&gt;注意：内存带宽是测量内存的吞吐量，并通常受到传输速率而非潜伏时间的限制。通过交错访问SDRAM的多个内部bank，有可能以峰值速率连续传输。可能以增加潜伏时间为代价来增加带宽。具体来说，每个新一代的DDR内存都有着较高的传输速率，但绝对延迟没有显著变化，尤其是市场上的第一批新一代产品，通常有着较上一代更长的延迟。&lt;/p&gt;
&lt;p&gt;即便增加了内存延迟，增加内存带宽也可以改善多处理器或多个执行线程的计算机系统的性能。更高的带宽也将提升没有专用显存的集成显卡的性能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/computer-assembly/%E5%86%85%E5%AD%98%E6%97%B6%E5%BA%8F%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E.png&#34;
	width=&#34;731&#34;
	height=&#34;477&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;内存时序参数说明&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;153&#34;
		data-flex-basis=&#34;367px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;参考资料
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E6%97%B6%E5%BA%8F&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;内存时序参数说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>网站加速和域名设置</title>
        <link>https://ttf248.life/p/website-acceleration-and-domain-setup/</link>
        <pubDate>Sat, 20 Jun 2020 10:36:27 +0800</pubDate>
        
        <guid>https://ttf248.life/p/website-acceleration-and-domain-setup/</guid>
        <description>&lt;p&gt;由于境内访问GitHub Pages较慢，作者申请了个人域名并购买了国内云主机供应商的CDN加速服务。配置过程中，作者遇到了www子域名无法访问的问题，最终通过删除泛域名解析并单独设置二级域名解决。作者还分享了CDN加速的原理和配置经验，以及使用Nginx反向代理的尝试和教训。&lt;/p&gt;
&lt;h3 id=&#34;背景&#34;&gt;背景
&lt;/h3&gt;&lt;p&gt;网站托管在GitHub Pages，某些众所周知的原因，境内访问GitHub Pages有点慢。故而申请了个人域名，购买了国内云主机供应商的CDN加速服务。在设置加速服务的时候，想到了自己还有开发机器，上面部署了docker、frp、k8s等服务，这些服务都有配套的dashboard，本着不浪费的原则，配置了几个反向代理，全部挂上了二级域名。&lt;/p&gt;
&lt;p&gt;当我美滋滋用着二级域名的时候，突发现www子域名无法访问了，阿里云上命名配置了DNS同时解析到www.xiangtianlong.com和xiangtianlong.com，尚未启用CDN加速的时候，两个域名都能正常使用。&lt;/p&gt;
&lt;p&gt;在配置CDN加速的时候，由于二级域名太多，启用了泛域名规则，统一路由到了开发机器，结果导致www这个二级域名也挂了，是的，你没看错，www前缀是个二级域名。实际网站部署在GitHub Pages，开发机器没有任何网站的缓存信息。&lt;/p&gt;
&lt;p&gt;至于为什么开发机器上没有部署站点，因为静态博客，配着GitHub提供的action，自动集成发布，真香。&lt;/p&gt;
&lt;h3 id=&#34;域名&#34;&gt;域名
&lt;/h3&gt;&lt;p&gt;非专业的web开发，对于域名的理解不涉及SEO和跨域问题。作为博客站点，裸域容易突出博客主的站点，说的就是我这种用汉字拼音当做域名的小朋友，加之当前移动访问居多，能少输入几个字符。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;电脑端能使用快捷键免去输入www和com&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;cdn&#34;&gt;CDN
&lt;/h3&gt;&lt;p&gt;阿里云和腾讯云的都用过，新人上手不难，腾讯云还有个视频单独讲解相关的概念。CDN加速的原理和京东仓库是一个道理，发售新商品，提前统一配送到全国各地的仓库，触发配送请求的时候，就近分发。&lt;/p&gt;
&lt;p&gt;回源地址：网站资源原始存放的地址&lt;/p&gt;
&lt;p&gt;缓存文件设置，浏览器F12，管理控制台，简单分析静态资源和动态资源&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全部0天有效期&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.php;.jsp;.asp;.aspx&lt;/code&gt; 0天有效期&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.jpg;.png;.js;.css;.woff2&lt;/code&gt; 1天有效期&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;腾讯云配置规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存过期规则最多可配置10条&lt;/li&gt;
&lt;li&gt;多条缓存过期规则之间的优先级为底部优先&lt;/li&gt;
&lt;li&gt;缓存过期时间最多可设置365天&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;悲惨自述&#34;&gt;悲惨自述
&lt;/h3&gt;&lt;p&gt;以前也没用过Nginx，以为网站随便搜索就能明白反向代理的配置，结果有点混乱，折腾半天连个302跳转也没弄明白，结果屁用没有。就想着笨办法解决一下，DNS解析删除*模式的泛域名解析，单个二级域名进行独立设置。此时突然注意到了阿里云DNS解析有一个叫做显示URL跳转的模式，尝试了一下，这不就是我想要的302跳转。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设置了第一个二级域名正常访问，等我设置第二个的时候，发现没用，都快怀疑人生了，等了一会突然就能用了，看来阿里云的DNS扩散偶尔也是会抽风的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;参考资料
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/question/20414602&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;为什么越来越多的网站域名不加「www」前缀？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cloudxns.net/Support/detail/id/918.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;带www和不带www域名有什么区别呢?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://gythialy.github.io/Docker-nginx-reverse-proxy/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Docker nginx 反向代理设置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>博客IDE环境和碎碎念</title>
        <link>https://ttf248.life/p/blog-ide-environment-and-ramblings/</link>
        <pubDate>Tue, 31 Mar 2020 13:54:27 +0800</pubDate>
        
        <guid>https://ttf248.life/p/blog-ide-environment-and-ramblings/</guid>
        <description>&lt;p&gt;本文介绍了Markdown的基本概念及其在各种软件中的应用，推荐了使用VSCode作为IDE，并列出了推荐的插件。作者分享了从Hexo切换到Hugo的经验，强调了Hugo的灵活性和自定义能力。最后，提供了一些快速上手新技术的建议，并分享了一个解决Hugo主题样式不更新的小技巧。&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言
&lt;/h2&gt;&lt;h3 id=&#34;markdown&#34;&gt;Markdown
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;详细的Markdown语法本文不做额外赘述，推荐一本电子书，&lt;a class=&#34;link&#34; href=&#34;https://markdown-zh.readthedocs.io/en/latest/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;点击此处&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;市面上很多软件都已经支持md作为书写方式。csdn博文系统推出了支持md语法的在线编辑器，在首次使用时，默认会有一篇关于md语法的介绍文章，笔者觉得还不错；印象笔记在2018年增加了对于md笔记的支持，快捷栏中有各种md标记的选项，用起来和编辑普通的文章差不多，整体的交互流程属于新手友好&lt;/p&gt;
&lt;h3 id=&#34;ide推荐&#34;&gt;IDE推荐
&lt;/h3&gt;&lt;p&gt;编写本文的时候，已经是2020年，vscode你必然是听说过的，毕竟能想到使用git page来搭建博文系统的都是业内人士。早些年的时候，sublime、atom也是不错的选择，经过两年开源社区的推动，vscode发展迅速，已经逐渐成为新手入场的首选。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;微软巨头和开源社区的关系从割裂的状态，成功跨入蜜月期：拥抱开源；笔者所在的公司在最近两年也积极的引入Java体系，换言之在业务开发上，如今的Java生态在国内属实真香&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;vscode插件推荐&#34;&gt;vscode插件推荐
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/blog-ide-environment-and-ramblings/2020-03-31-14-07-17.png&#34;
	width=&#34;310&#34;
	height=&#34;306&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;插件清单&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;101&#34;
		data-flex-basis=&#34;243px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;插件都有自带的Readme，介绍基本用法，核心功能，部分插件作者还提供动态效果展示图&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Paste Image&lt;/code&gt;，配合hugo的图片插件方式，很便捷的就能引入图片&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;快捷键没记住，打开vscode快捷键管理菜单，搜索md，多看几遍；重看一遍插件使用说明&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;hugo&#34;&gt;hugo
&lt;/h2&gt;&lt;p&gt;笔者从&lt;code&gt;hexo&lt;/code&gt;切换到了&lt;code&gt;hugo&lt;/code&gt;，爱折腾是我的天性，终归是耐不住性子安安静静写文章&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;hugo支持在单独的文件夹放置图片和md文档&lt;/li&gt;
&lt;li&gt;academic主题在设计上支持多种各式的文章样式&lt;/li&gt;
&lt;li&gt;各种便捷的自定义拓展&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;academic&#34;&gt;academic
&lt;/h2&gt;&lt;p&gt;官网默认&lt;code&gt;exampleSite&lt;/code&gt;，menu引入采用&lt;code&gt;#组件&lt;/code&gt;的方式，推荐使用&lt;code&gt;url&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;url的模式，点击导航栏能实现单页的跳转，而非在首页进行滚动，这点纯属个人喜好&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;样式上：随笔、演讲、电子书&lt;/li&gt;
&lt;li&gt;灵活性：自定义整体风格、自定义css样式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这款主题对于中文的支持还不是很完善，主要是从视觉的角度来说，字体大小不太符合中文阅读习惯，hexo的开发人员大部分为国人，在这点优于hugo&lt;/p&gt;
&lt;p&gt;但是呢，自己动手丰衣足食，浏览器审核元素。定位了到了元素，想要知道需要修改的css样式名称，侧栏点击&lt;strong&gt;Insert Style Rule Below&lt;/strong&gt;，即使嵌套多层的css，也能轻松拿到节点名称。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://sourcethemes.com/academic/docs/customization/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;引入&lt;strong&gt;custom.css&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://sourcethemes.com/academic/docs/customization/#add-scripts-js&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;引入&lt;strong&gt;custom_js&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;主题内置的语法高亮设置，&lt;a class=&#34;link&#34; href=&#34;https://sourcethemes.com/academic/docs/writing-markdown-latex/#highlighting-options.&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;结尾&#34;&gt;结尾
&lt;/h2&gt;&lt;p&gt;小朋友又要吐槽了，你怎么从头到尾都说的模模糊糊，细节什么的都不提&lt;/p&gt;
&lt;p&gt;我想说的是，有下面这些东西，足够你用了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;官方手册&lt;/li&gt;
&lt;li&gt;插件说明&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;快速上手新技术，推荐先阅读官网文档，&lt;strong&gt;粗读&lt;/strong&gt;不求一遍看懂，至少心里有个数，搜索引擎出来的结果，不一定和当前最新的版本保持一致，也许会产生误导。翻阅新书也是如此，先看目录，搞清楚作者准备讲什么，有时候读书先读序，部分国外的著作翻译成中文，译者的序其实涵盖了书籍和核心内容。&lt;/p&gt;
&lt;h2 id=&#34;彩蛋&#34;&gt;彩蛋
&lt;/h2&gt;&lt;p&gt;切换hugo academic内置风格样式，发布到站点，访问时，风格没有发生变换。聪明的小伙伴已经想到了，清空本地浏览器缓存，能解决问题。机智的我：F12开发者模式，切换到&lt;code&gt;network&lt;/code&gt;，勾选&lt;code&gt;disable cache&lt;/code&gt;，刷新，搞定！&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/blog-ide-environment-and-ramblings/2020-03-31-14-27-15.png&#34;
	width=&#34;399&#34;
	height=&#34;142&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;network&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;280&#34;
		data-flex-basis=&#34;674px&#34;
	
&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>自动集成系统切换</title>
        <link>https://ttf248.life/p/auto-integration-system-switch/</link>
        <pubDate>Sun, 29 Mar 2020 02:11:33 +0800</pubDate>
        
        <guid>https://ttf248.life/p/auto-integration-system-switch/</guid>
        <description>&lt;p&gt;使用 GitHub Actions 自动部署 Hugo 博客到 GitHub Pages 和 Gitee。&lt;/p&gt;
&lt;h4 id=&#34;背景介绍&#34;&gt;背景介绍
&lt;/h4&gt;&lt;p&gt;昨天更新博客时发现travis服务不可用，查看travis网页，发现进度卡在拉取源码的时候，灵光闪现想到了github之前推出的action服务&lt;/p&gt;
&lt;p&gt;由于那会比较忙，同时也需要申请才能使用action，现在已经开始正式上线，周末闲来无事，尝试一个新玩具？&lt;/p&gt;
&lt;p&gt;官方资料大家自行进入网站查阅即可，本文就不做更多的转载了，如果之前用过kubernetes会觉得，action的yaml文件配置和kubernetes很像。&lt;/p&gt;
&lt;p&gt;关于的入门的教程，或者说是中文的介绍资料，推荐搜索&lt;strong&gt;阮一峰的博客&lt;/strong&gt;，有两篇文章，第一篇是基础的语法介绍，第二篇是一个实际的案例。&lt;/p&gt;
&lt;h4 id=&#34;正文&#34;&gt;正文
&lt;/h4&gt;&lt;p&gt;需要的知识点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;github secrets&lt;/li&gt;
&lt;li&gt;action 语法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;核心的job使用现有的组件完成，推送到国内gitee使用command实现，command这部分比较粗暴，都是强制推送，沿用了使用travis的逻辑。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;name: github pages and gitee pages

on:
  push:
    branches:
      - hugo

jobs:
  deploy:
    runs-on: ubuntu-18.04
    steps:
      - uses: actions/checkout@v2
        with:
          submodules: true

      - name: Setup Hugo
        uses: peaceiris/actions-hugo@v2
        with:
          hugo-version: &#39;latest&#39;
          extended: true

      - name: Build Github and Gitee ## 单个step只能写一个run命令
        run: hugo -b &amp;quot;https://www.xiangtianlong.com/&amp;quot; -d &amp;quot;github_public&amp;quot; &amp;amp;&amp;amp; hugo -b &amp;quot;https://www.xiangtianlong.com/&amp;quot; -d &amp;quot;gitee_public&amp;quot; &amp;amp;&amp;amp; ls

      - name: Deploy Github
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.BLOG_TOKEN }}
          publish_dir: ./github_public
          publish_branch: master
          cname: xiangtianlong.com

      - name: Deploy Gitee
        run: cd ./gitee_public &amp;amp;&amp;amp; git init &amp;amp;&amp;amp; git config user.name &amp;quot;TianlongXiang&amp;quot; &amp;amp;&amp;amp; git config user.email &amp;quot;tianlongxiang51@gmail.com&amp;quot; &amp;amp;&amp;amp; git add . &amp;amp;&amp;amp; git commit -m &amp;quot;Update TianlongXiang&#39;s Blog&amp;quot; &amp;amp;&amp;amp; git push --force &amp;quot;https://xiangtianlong:${{ secrets.GITEE_PASSWORD }}@gitee.com/xiangtianlong/xiangtianlong.git&amp;quot; master:master   
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;后记&#34;&gt;后记
&lt;/h4&gt;&lt;p&gt;从官方市场提供的action来看，目前支持的玩法挺多，构建docker镜像以后也能不再依赖dockerhub提供的服务&lt;/p&gt;
&lt;p&gt;查阅hugo的issue，发现使用github action自动部署git pages，最终发布的网页需要在master分支，如果是部署在其他分支，在setting界面，github会提示部署的网页存在语法问题&lt;/p&gt;
&lt;p&gt;实际上只是由于hugo的源文件放在了master分支，github当作jelly博客的源码进行检测，无法检查无法通过导致的报错&lt;/p&gt;
&lt;p&gt;解决方案也简单，hugo源码文件放到其他分支，静态文件发布在master分支&lt;/p&gt;</description>
        </item>
        <item>
        <title>标准库容器的内存分配器：allocator</title>
        <link>https://ttf248.life/p/standard-library-container-memory-allocator/</link>
        <pubDate>Mon, 30 Dec 2019 13:26:19 +0800</pubDate>
        
        <guid>https://ttf248.life/p/standard-library-container-memory-allocator/</guid>
        <description>&lt;p&gt;自定义分配器可以提升性能、提高内存使用效率，并解决频繁少量内存分配的问题。&lt;/p&gt;
&lt;h4 id=&#34;前因&#34;&gt;前因
&lt;/h4&gt;&lt;p&gt;近期接触到了网络网络数据包的开发，需要频繁的申请和释放小块的内存，原本想着使用内存池，查看了几个现有的内存池，发现了这个&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/cacay/MemoryPool&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/cacay/MemoryPool&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看到接口的时候，就比较纳闷，这个内存池的实现怎么有点奇怪。&lt;code&gt;MemoryPool&lt;/code&gt;的实现逻辑，是在申请固定大小的内存空间。看过boost的内存池接口，提供的是一个模板，用的时候进行实例化。正巧这个库已经有文章进行过介绍，提到了&lt;code&gt;allocator&lt;/code&gt;这个概念。&lt;/p&gt;
&lt;h4 id=&#34;wikihttpszhwikipediaorgwikie58886e9858de599a8_c2b2b&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_%28C%2B%2B%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wiki&lt;/a&gt;
&lt;/h4&gt;&lt;p&gt;在C++编程中，分配器（英语：allocator）是C++标准库的重要组成部分。C++的库中定义了多种被统称为“容器”的数据结构（如链表、集合等），这些容器的共同特征之一，就是其大小可以在程序的运行时改变；为了实现这一点，进行动态内存分配就显得尤为必要，在此分配器就用于处理容器对内存的分配与释放请求。换句话说，分配器用于封装标准模板库（STL）容器在内存管理上的低层细节。默认情况下，C++标准库使用其自带的通用分配器，但根据具体需要，程序员也可自行定制分配器以替代之。&lt;/p&gt;
&lt;p&gt;分配器最早由亚历山大·斯特潘诺夫作为C++标准模板库（Standard Template Library，简称STL）的一部分发明，其初衷是创造一种能“使库更加灵活，并能独立于底层数据模型的方法”，并允许程序员在库中利用自定义的指针和引用类型；但在将标准模板库纳入C++标准时，C++标准委员会意识到对数据模型的完全抽象化处理会带来不可接受的性能损耗，为作折中，标准中对分配器的限制变得更加严格，而有鉴于此，与斯特潘诺夫原先的设想相比，现有标准所描述的分配器可定制程度已大大受限。&lt;/p&gt;
&lt;p&gt;虽然分配器的定制有所限制，但在许多情况下，仍需要用到自定义的分配器，而这一般是为封装对不同类型内存空间（如共享内存与已回收内存）的访问方式，或在使用内存池进行内存分配时提高性能而为。除此以外，从内存占用和运行时间的角度看，在频繁进行少量内存分配的程序中，若引入为之专门定制的分配器，也会获益良多。&lt;/p&gt;
&lt;h4 id=&#34;使用需求httpszhwikipediaorgwikie58886e9858de599a8_c2b2b&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_%28C%2B%2B%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;使用需求&lt;/a&gt;
&lt;/h4&gt;&lt;p&gt;定义自定义分配器的主要原因之一是提升性能。利用专用的自定义分配器可以提高程序的性能，又或提高内存使用效率，亦或两者兼而有之[4][8]。默认分配器使用new操作符分配存储空间[文 5]，而这常利用C语言堆分配函数（malloc()）实现[9]。由于堆分配函数常针对偶发的内存大量分配作优化，因此在为需要一次分配大量内存的容器（如向量、双端队列）分配内存时，默认分配器一般效率良好[8]。但是，对于关联容器与双向链表这类需要频繁分配少量内存的容器来说，若采用默认分配器分配内存，则通常效率很低[4][9]。除此之外，基于malloc()的默认分配器还存在许多问题，诸如较差的引用局部性[4]，以及可能造成内存碎片化[4][9]。&lt;/p&gt;
&lt;p&gt;简言之，此段（……）（如同）是这一标准针对分配器的一场《我有一个梦想》的演讲。在梦想成真之前，关心可移植性的程序员将把自己局限于（使用）无状态的自定义分配器上。
——斯科特 梅耶斯，《Effective STL》
有鉴于此，在这一情况下，人们常使用基于内存池的分配器来解决频繁少量分配问题[8]。与默认的“按需分配”方式不同，在使用基于内存池的分配器时，程序会预先为之分配大块内存（即“内存池”），而后在需要分配内存时，自定义分配器只需向请求方返回一个指向池内内存的指针即可；而在对象析构时，并不需实际解除分配内存，而是延迟到内存池的生命周期完结时才真正解除分配[注 1][8]。&lt;/p&gt;
&lt;p&gt;在“自定义分配器”这一话题上，已有诸多C++专家与相关作者参与探讨，例如斯科特·梅耶斯的作品《Effective STL》与安德烈·亚历山德雷斯库的《Modern C++ Design》都有提及。梅耶斯洞察到，若要求针对某一类型T的分配器的所有实例都相等，则可移植的分配器的实例必须不包含状态。虽然C++标准鼓励库的实现者支持带状态的分配器[文 4]，但梅耶斯称，相关段落是“（看似）美妙的观点”，但也几乎是空话，并称分配器的限制“过于严苛”[4]。例如，STL的list允许splice方法，即一个list对象A的节点可以被直接移入另一个list对象B中，这就要求A的分配器申请到的内存，可被B的分配器释放掉，从而推导出A与B的分配器实例必须相等。梅耶斯的结论是，分配器最好定义为使用静态方法的类型。例如，根据C++标准，分配器必须提供一个实现了rebind方法的other类模板。&lt;/p&gt;
&lt;p&gt;另外，在《C++程序设计语言》中，比雅尼·斯特劳斯特鲁普则认为“‘严格限制分配器，以免各对象信息不同’，这点显然问题不大”（大意），并指出大部分分配器并不需要状态，甚至没有状态情形下性能反倒更佳。他提出了三个自定义分配器的用例：内存池型的分配器、共享内存型分配器与垃圾回收型分配器，并展示了一个分配器的实现，此间利用了一个内部内存池，以快速分配/解除分配少量内存。但他也提到，如此优化可能已经在他所提供的样例分配器中实现[3]。&lt;/p&gt;
&lt;p&gt;自定义分配器的另一用途是调试内存相关错误[10]。若要做到这一点，可以编写一个分配器，令之在分配时分配额外的内存，并借此存放调试信息。这类分配器不仅可以保证内存由同类分配器分配/解除分配内存，还可在一定程度上保护程序免受缓存溢出之害[11]。&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
