<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Allocator on 향숙의 수첩</title>
        <link>https://ttf248.life/ko/tags/allocator/</link>
        <description>Recent content in Allocator on 향숙의 수첩</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ko</language>
        <lastBuildDate>Sun, 25 May 2025 14:10:37 +0800</lastBuildDate><atom:link href="https://ttf248.life/ko/tags/allocator/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>표준 라이브러리 컨테이너의 메모리 할당자: allocator</title>
        <link>https://ttf248.life/ko/p/standard-library-container-memory-allocator/</link>
        <pubDate>Mon, 30 Dec 2019 13:26:19 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/standard-library-container-memory-allocator/</guid>
        <description>&lt;p&gt;사용자 정의 할당자는 성능을 향상시키고 메모리 사용 효율성을 높이며 빈번한 소량의 메모리 할당 문제를 해결할 수 있습니다&lt;/p&gt;
&lt;h4 id=&#34;전인&#34;&gt;전인
&lt;/h4&gt;&lt;p&gt;최근 네트워크 데이터 패킷 개발을 진행하면서 빈번하게 작은 메모리 블록을 할당하고 해제해야 하는데, 원래는 메모리 풀을 사용하려 했고, 기존의 몇몇 메모리 풀들을 살펴보니 이런 것을 발견했다&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/cacay/MemoryPool&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/cacay/MemoryPool&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;인터페이스를 보니까 좀 이상하다는 생각이 들었는데, 이 메모리 풀 구현 방식이 왜 이렇게 특이할까. &lt;code&gt;MemoryPool&lt;/code&gt;의 구현 로직은 고정된 크기의 메모리 공간을 할당하는 방식인데. Boost의 메모리 풀 인터페이스를 보면 템플릿으로 제공되고 사용 시에 인스턴스화해야 한다. 다행히 이 라이브러리에 대한 설명이 있는 글도 있고, 거기서 &lt;code&gt;allocator&lt;/code&gt;라는 개념이 언급되어 있었다.&lt;/p&gt;
&lt;h4 id=&#34;wikihttpszhwikipediaorgwikie58886e9858de599a8_c2b2b&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_%28C%2B%2B%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wiki&lt;/a&gt;
&lt;/h4&gt;&lt;p&gt;C++ 프로그래밍에서 할당자(allocator)는 C++ 표준 라이브러리의 중요한 구성 요소입니다. C++ 라이브러리에는 연결 리스트, 집합 등 다양한 “컨테이너” 데이터 구조가 정의되어 있으며, 이러한 컨테이너의 공통적인 특징 중 하나는 프로그램 실행 시간에 크기를 변경할 수 있다는 것입니다. 이를 구현하기 위해 동적 메모리 할당이 필수적이므로 할당자는 컨테이너의 메모리 할당 및 해제 요청을 처리하는 데 사용됩니다. 다시 말해, 할당자는 표준 템플릿 라이브러리(STL) 컨테이너의 메모리 관리에 대한 저수준 세부 사항을 캡슐화합니다. 기본적으로 C++ 표준 라이브러리는 자체 제공하는 범용 할당자를 사용하지만, 필요에 따라 프로그래머는 자신만의 할당자를 정의하여 이를 대체할 수 있습니다.&lt;/p&gt;
&lt;p&gt;할당기는 원래 C++ 표준 템플릿 라이브러리(Standard Template Library, STL)의 일부로 알렉산드르 스테파노프에 의해 발명되었으며, 그의 초기 목표는 &amp;ldquo;라이브러리를 더욱 유연하게 만들고 기본 데이터 모델에 의존하지 않는 방법&amp;quot;을 만드는 것이었습니다. 이를 통해 프로그래머는 라이브러리에서 사용자 정의 포인터 및 참조 유형을 활용할 수 있었습니다. 그러나 C++ 표준 템플릿 라이브러리를 C++ 표준으로 포함하는 과정에서 C++ 표준 위원회는 데이터 모델의 완전한 추상화가 용납할 수 없는 성능 저하를 초래한다는 것을 깨달았습니다. 이러한 절충안으로 인해 표준에서 할당기에 대한 제한이 더욱 엄격해졌고, 결과적으로 현재 표준에 설명된 할당기는 스테파노프의 원래 구상과 비교하여 사용자 정의 가능성이 크게 제한되었습니다.&lt;/p&gt;
&lt;p&gt;할당기 사용자 정의는 어느 정도 제한이 있지만, 많은 경우 다양한 메모리 공간(공유 메모리나 재활용 메모리와 같은)에 대한 접근 방식을 캡슐화하거나, 메모리 풀을 사용하여 메모리를 할당할 때 성능을 향상시키기 위해 여전히 사용자 정의 할당기가 필요합니다. 또한, 빈번한 소량의 메모리 할당이 발생하는 프로그램에서 전용으로 맞춤 제작된 할당기를 도입하면 메모리 사용량과 실행 시간 측면에서도 상당한 이점을 얻을 수 있습니다.&lt;/p&gt;
&lt;h4 id=&#34;사용-요건&#34;&gt;사용 요건
&lt;/h4&gt;&lt;p&gt;정의된 사용자 정의 할당자의 주요 이유 중 하나는 성능 향상입니다. 전용 사용자 정의 할당자를 사용하면 프로그램의 성능을 높이거나 메모리 사용 효율성을 높이거나 둘 다 달성할 수 있습니다[4][8]. 기본 할당자는 new 연산자를 사용하여 저장 공간을 할당하는데, 이는 종종 C 언어 힙 할당 함수(malloc())를 통해 구현됩니다[9]. 힙 할당 함수는 일반적으로 일시적으로 많은 양의 메모리를 할당하는 데 최적화되므로 대량의 메모리를 한 번에 할당해야 하는 컨테이너(예: 벡터, 양방향 큐)의 경우 기본 할당자는 일반적으로 효율적입니다[8]. 그러나 연결된 컨테이너 및 양방향 링크드 리스트와 같이 빈번하게 소량의 메모리를 할당해야 하는 컨테이너의 경우 기본 할당자를 사용하면 일반적으로 효율성이 매우 낮습니다[4][9]. 또한 malloc()을 기반으로 하는 기본 할당자는 낮은 지역성[4]과 메모리 조각화 발생 가능성[4][9]과 같은 많은 문제를 가지고 있습니다.&lt;/p&gt;
&lt;p&gt;간단히 말해서, 이 부분(……)은 마치 이 표준이 할당기(allocator)에 대해 발표한 《나는 꿈이 있다》와 같습니다. 꿈이 실현되기 전에는 이식 가능성을 고려하는 프로그래머들은 상태 없는(stateless) 사용자 정의 할당기를 사용하는 데 스스로를 제한할 것입니다.
——스코트 메이스, 《Effective STL》
이러한 점을 감안하여, 이러한 상황에서 사람들은 빈번한 소량 할당 문제를 해결하기 위해 메모리 풀 기반 할당기를 자주 사용합니다[8]. 기본 “요청 시 할당” 방식과 달리, 메모리 풀 기반 할당기를 사용할 때는 프로그램이 미리 대용량 메모리(즉, &amp;ldquo;메모리 풀&amp;rdquo;)를 할당하고, 필요할 때 사용자 정의 할당기는 요청자에게 풀 내 메모리의 포인터를 반환하기만 합니다. 객체 소멸 시에는 실제로 메모리를 해제하지 않고, 메모리 풀의 수명이 종료될 때 비로소 메모리를 해제합니다[주 1][8].&lt;/p&gt;
&lt;p&gt;“사용자 정의 할당기”라는 주제에 대해 이미 많은 C++ 전문가와 관련 저자들이 참여하여 토론해 왔습니다. 예를 들어 스콧 메이어스의 “Effective STL”과 안드레이 알렉산더레스쿠의 “Modern C++ Design”에도 언급되어 있습니다. 메이어스는 특정 타입 T의 할당기 인스턴스가 모두 동일해야 한다면, 이식 가능한 할당기 인스턴스는 상태를 포함해서는 안 된다고 통찰했습니다. C++ 표준은 라이브러리 구현자가 상태 기반 할당기를 지원하도록 장려하지만[문헌 4], 메이어스는 관련 단락이 “（보이는 듯한）아름다운 관점”이지만 거의 말장난이라고 비판하며, 할당기의 제약이 “지나치게 엄격하다”고 주장했습니다[4]. 예를 들어 STL의 list는 splice 메서드를 제공하는데, 이는 list 객체 A의 노드를 다른 list 객체 B에 직접 이동시킬 수 있습니다. 이는 A의 할당기가 할당한 메모리가 B의 할당기에 의해 해제될 수 있어야 하므로, A와 B의 할당기 인스턴스가 동일해야 함을 의미합니다. 메이어스의 결론은 할당기를 정적 메서드를 사용하는 타입으로 정의하는 것이 가장 좋다는 것입니다. 예를 들어 C++ 표준에 따르면 할당기는 rebind 메서스를 구현한 other 클래스 템플릿을 제공해야 합니다.&lt;/p&gt;
&lt;p&gt;또 다른 한편, 《C++ 프로그램 설계 언어》에서 비야니 스트라우스트루프는 “‘엄격한 할당기 제한으로 각 객체 정보의 차이를 없앤다’는 점은 분명 큰 문제가 아니다.”라고 주장하며 대부분의 할당기는 상태가 필요하지 않으며 심지어 상태가 없는 경우 성능이 더 좋을 수도 있다고 지적한다. 그는 메모리 풀형 할당기, 공유 메모리형 할당기 및 가비지 컬렉션형 할당기의 세 가지 사용자 정의 할당기 사용 사례를 제시하고 내부 메모리 풀을 활용하여 소량의 메모리를 빠르게 할당/해제하는 할당기 구현을 보여준다. 하지만 그는 이러한 최적화가 이미 그가 제공한 예시 할당기에서 구현되었을 수도 있다고 언급한다[3].&lt;/p&gt;
&lt;p&gt;사용자 정의 할당기의 또 다른 용도는 메모리 관련 오류를 디버깅하는 것입니다[10]. 이를 위해 추가 메모리를 할당하여 디버그 정보를 저장할 수 있도록 할당기를 작성할 수 있습니다. 이러한 할당기는 메모리가 동일한 유형의 할당기에서 할당/해제되는지 확인하는 것 외에도 캐시 오버플로로부터 프로그램이 어느 정도 보호되도록 할 수 있습니다[11].&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
