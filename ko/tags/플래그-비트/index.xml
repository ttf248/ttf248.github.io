<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>플래그 비트 on 향숙의 수첩</title>
        <link>https://ttf248.life/ko/tags/%ED%94%8C%EB%9E%98%EA%B7%B8-%EB%B9%84%ED%8A%B8/</link>
        <description>Recent content in 플래그 비트 on 향숙의 수첩</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ko</language>
        <lastBuildDate>Sun, 25 May 2025 14:10:37 +0800</lastBuildDate><atom:link href="https://ttf248.life/ko/tags/%ED%94%8C%EB%9E%98%EA%B7%B8-%EB%B9%84%ED%8A%B8/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>C&#43;&#43; 비트 연산 기초: 비트별 값 가져오기 및 플래그 설정</title>
        <link>https://ttf248.life/ko/p/cpp-bitwise-operations-basics-flags/</link>
        <pubDate>Fri, 17 Jan 2025 02:23:56 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/cpp-bitwise-operations-basics-flags/</guid>
        <description>&lt;p&gt;실제 C++ 개발에서 비트 연산은 흔한 기술이며, 특히 시스템 상태, 플래그 또는 제어 비트를 처리할 때 매우 효율적인 솔루션을 제공합니다. 본 글에서는 예제를 통해 비트 연산을 사용하여 특정 플래그를 가져오고 설정하는 방법을 설명하겠습니다.&lt;/p&gt;
&lt;h3 id=&#34;비트-연산-기초-개념&#34;&gt;비트 연산 기초 개념
&lt;/h3&gt;&lt;p&gt;컴퓨터에서 데이터는 이진 비트(0과 1)로 저장됩니다. 비트 연산은 이러한 이진 비트에 대한 연산을 말합니다. C++에는 몇 가지 일반적인 비트 연산자가 있습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;비트 AND 연산 (&amp;amp;)는 특정 비트가 1인지 확인하는 데 사용됩니다&lt;/li&gt;
&lt;li&gt;비트 OR (|) : 특정 비트를 1로 설정하는 데 사용됩니다&lt;/li&gt;
&lt;li&gt;비트별 XOR(^) 연산은 특정 비트를 반전시키는 데 사용됩니다&lt;/li&gt;
&lt;li&gt;비트 반전(~)&lt;/li&gt;
&lt;li&gt;모든 비트를 몇 자리 왼쪽으로 이동합니다&lt;/li&gt;
&lt;li&gt;모든 비트를 지정된 자릿수만큼 오른쪽으로 이동합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 예제에서는 &lt;code&gt;unsigned short&lt;/code&gt; 타입의 변수 &lt;code&gt;wInfo&lt;/code&gt;에 대해 일련의 비트 연산을 수행하여 다양한 플래그를 통해 서로 다른 상태를 표현해야 합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;flowchart LR
    A[原始数值: 00010000] --&amp;gt; B[左移: 00010000 &amp;lt;&amp;lt; 1]
    B --&amp;gt; C[结果: 00100000]
    C --&amp;gt; D[右移: 00100000 &amp;gt;&amp;gt; 1]
    D --&amp;gt; E[结果: 00010000]

    subgraph 左移操作
        direction LR
        A --&amp;gt; B --&amp;gt; C
    end

    subgraph 右移操作
        direction LR
        C --&amp;gt; D --&amp;gt; E
    end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;요구사항-분석&#34;&gt;요구사항 분석
&lt;/h3&gt;&lt;p&gt;문제 설명에 따르면, 우리는 다양한 상태를 나타내기 위해 사용되는 16비트 플래그가 있습니다. 이러한 상태는 각각 다른 이진 비트를 통해 표현되며, 각 이진 비트는 특정 의미를 가집니다. 예를 들어:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;비트 0가 실패했습니까?&lt;/li&gt;
&lt;li&gt;비트 1 압축되었습니까?&lt;/li&gt;
&lt;li&gt;비트2 증분 업데이트인가?&lt;/li&gt;
&lt;li&gt;비트3에 후속 패키지가 있나요?&lt;/li&gt;
&lt;li&gt;정상 요청 또는 로그아웃&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;비트-연산을-사용하여-구현하세요&#34;&gt;비트 연산을 사용하여 구현하세요
&lt;/h3&gt;&lt;p&gt;우리는 비트 연산을 통해 이러한 플래그를 설정하고 가져올 것입니다. 구체적으로:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;각 자리 값 가져오기：어떤 한 자리의 값(0 또는 1)을 얻는다&lt;/li&gt;
&lt;li&gt;비트 설정: 특정 비트를 1로 설정합니다&lt;/li&gt;
&lt;li&gt;비트 단위로 지우기: 특정 비트를 0으로 설정합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;우리는 먼저 &lt;code&gt;unsigned short&lt;/code&gt; 타입의 변수 &lt;code&gt;wInfo&lt;/code&gt;를 정의하여 이러한 플래그들을 저장합니다. 그런 다음, 비트 연산을 통해 해당 플래그들을 확인하고 설정합니다.&lt;/p&gt;
&lt;h3 id=&#34;c-예제-코드&#34;&gt;C++ 예제 코드
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;bitset&amp;gt;

// 定义标志位常量
const unsigned short BIT_0_FAIL = 1 &amp;lt;&amp;lt; 0;    // bit0 是否失败
const unsigned short BIT_1_COMPRESSED = 1 &amp;lt;&amp;lt; 1; // bit1 是否压缩
const unsigned short BIT_2_INCREMENT = 1 &amp;lt;&amp;lt; 2;  // bit2 是否增量
const unsigned short BIT_3_HAS_MORE = 1 &amp;lt;&amp;lt; 3;   // bit3 是否有后续包
const unsigned short BIT_5_CANCEL = 1 &amp;lt;&amp;lt; 5;     // bit5 正常请求(0)或注销(1)

// 检查某一位是否为1
bool isBitSet(unsigned short wInfo, unsigned short bitMask) {
    return (wInfo &amp;amp; bitMask) != 0;
}

// 设置某一位为1
void setBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo |= bitMask;
}

// 清除某一位（设置为0）
void clearBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo &amp;amp;= ~bitMask;
}

int main() {
    // 假设wInfo的初始值为0
    unsigned short wInfo = 0;

    // 设置bit0（失败标志）
    setBit(wInfo, BIT_0_FAIL);
    
    // 设置bit1（压缩标志）
    setBit(wInfo, BIT_1_COMPRESSED);
    
    // 打印wInfo的二进制值
    std::cout &amp;lt;&amp;lt; &amp;quot;wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    // 检查各个标志位
    std::cout &amp;lt;&amp;lt; &amp;quot;bit0 (是否失败): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_0_FAIL) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit1 (是否压缩): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_1_COMPRESSED) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit2 (是否增量): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_2_INCREMENT) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit3 (是否有后续包): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_3_HAS_MORE) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit5 (是否注销): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_5_CANCEL) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;

    // 清除bit1（压缩标志）
    clearBit(wInfo, BIT_1_COMPRESSED);
    
    // 打印更新后的wInfo
    std::cout &amp;lt;&amp;lt; &amp;quot;Updated wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;코드 실행, 오래된 친구 추천: &lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wInfo (in binary): 0000000000000011
bit0 (是否失败): 是
bit1 (是否压缩): 是
bit2 (是否增量): 否
bit3 (是否有后续包): 否
bit5 (是否注销): 否
Updated wInfo (in binary): 0000000000000001
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;코드-설명&#34;&gt;코드 설명
&lt;/h3&gt;&lt;p&gt;플래그 비트는 비트 시프트 연산(&lt;code&gt;1 &amp;lt;&amp;lt; n&lt;/code&gt;)을 사용하여 정의합니다. 예를 들어, &lt;code&gt;1 &amp;lt;&amp;lt; 0&lt;/code&gt;은 &lt;code&gt;bit0&lt;/code&gt;에 해당하고, &lt;code&gt;1 &amp;lt;&amp;lt; 1&lt;/code&gt;은 &lt;code&gt;bit1&lt;/code&gt;에 해당하며, 이와 같은 방식으로 계속됩니다. 이렇게 하면 각 플래그 비트에 고유한 이진 위치를 할당하게 됩니다.&lt;/p&gt;
&lt;p&gt;특정 비트가 1인지 확인하려면 &lt;code&gt;isBitSet&lt;/code&gt; 함수가 비트 AND 연산 &lt;code&gt;wInfo &amp;amp; bitMask&lt;/code&gt;를 사용하여 이를 수행합니다. 해당 비트가 1이면 함수는 &lt;code&gt;true&lt;/code&gt;를 반환하고, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt;를 반환합니다.&lt;/p&gt;
&lt;p&gt;설정비트: &lt;code&gt;setBit&lt;/code&gt; 함수는 비트 OR 연산 &lt;code&gt;wInfo |= bitMask&lt;/code&gt;를 통해 특정 플래그 비트를 1로 설정합니다&lt;/p&gt;
&lt;p&gt;특정 비트 위치를 0으로 설정하기 위해 &lt;code&gt;clearBit&lt;/code&gt; 함수는 비트 AND 연산 &lt;code&gt;wInfo &amp;amp;= ~bitMask&lt;/code&gt;를 사용합니다&lt;/p&gt;
&lt;h3 id=&#34;요약&#34;&gt;요약
&lt;/h3&gt;&lt;p&gt;비트 연산을 통해 우리는 여러 상태 플래그를 효율적으로 처리할 수 있습니다. 실제 개발에서 이 기술은 특히 유용합니다. 예를 들어, 임베디드 개발, 네트워크 프로토콜, 시스템 상태 관리 등의 시나리오에서 비트 플래그를 사용하여 여러 개의 이진 상태를 표현함으로써 공간을 절약하고 효율성을 높일 수 있습니다.&lt;/p&gt;
&lt;p&gt;이 블로그 게시물이 C++에서 비트 연산을 사용하여 비트 값 가져오기 및 설정 방법을 이해하는 데 도움이 되기를 바랍니다. 이러한 기술을 숙달하면 효율적이고 유지 관리하기 쉬운 코드를 작성하는 데 매우 유용합니다!&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
