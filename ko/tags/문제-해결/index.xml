<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>문제 해결 on 향숙의 수첩</title>
        <link>https://ttf248.life/ko/tags/%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0/</link>
        <description>Recent content in 문제 해결 on 향숙의 수첩</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ko</language>
        <lastBuildDate>Sun, 25 May 2025 14:10:37 +0800</lastBuildDate><atom:link href="https://ttf248.life/ko/tags/%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>프로토Buf 0치 함정: 기본값이 비즈니스 로직의 보이지 않는 살인자</title>
        <link>https://ttf248.life/ko/p/protobuf-zero-value-traps/</link>
        <pubDate>Thu, 20 Feb 2025 15:26:51 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/protobuf-zero-value-traps/</guid>
        <description>&lt;p&gt;미국 주식 시장에는 세 가지 거래 시간대가 있습니다. 전시장, 장중, 장후입니다. 인터페이스 데이터 푸시는 값의 증분 로직(가능한 한 대역폭을 절약)이며, 처음 보내는 때는 전체 데이터를 보내고, 두 번째부터 모든 필드는 증분 방식으로 푸시됩니다.&lt;/p&gt;
&lt;p&gt;최적의 방안을 사용하지 않는 이유는 무엇인가요? 여러 프로젝트 팀이 관련되어 있고, 일부는 이미 수년 전에 배포되었습니다. 저희 쪽은 새로 연결하는 입장이므로 최대한 호환성을 고려할 수밖에 없습니다.&lt;/p&gt;
&lt;h2 id=&#34;일련의-문제&#34;&gt;일련의 문제
&lt;/h2&gt;&lt;p&gt;초록만 보더라도 별다른 문제가 없어 보일 수 있지만, 시스템 아키텍처가 문제 그룹으로 들어오면서 일련의 문제가 발생했습니다. 막 지난 문제를 해결하려 했더니 또 다른 문제가 생겼고, 이 문제는 이전 문제로 인해 발생한 것입니다.&lt;/p&gt;
&lt;h3 id=&#34;거래-기간을-식별할-수-없습니다&#34;&gt;거래 기간을 식별할 수 없습니다
&lt;/h3&gt;&lt;p&gt;알려진 바에 따르면, 디스크 내 단계 정의는 &lt;code&gt;protobuf&lt;/code&gt;에서 0으로 정의되어 있지만, 데이터를 수신할 때 증분 푸시로 인해 비즈니스 측면에서는 이 &lt;code&gt;0&lt;/code&gt;이 기본값인지 실제 비즈니스 값인지 효과적으로 식별하기 어렵습니다&lt;/p&gt;
&lt;p&gt;일반적인 이해로, 0을 받을 때마다 이 0이 새로운 시세 설정 값인지, 아니면 프로토콜 버퍼의 기본값인지 판단하기 어렵습니다&lt;/p&gt;
&lt;h3 id=&#34;선택적-도입&#34;&gt;선택적 도입
&lt;/h3&gt;&lt;p&gt;Since protobuf release 3.15, proto3 supports using the optional keyword (just as in proto2) to give a scalar field presence information&lt;/p&gt;
&lt;p&gt;조 내 통신 프로토콜은 &lt;code&gt;protobuf&lt;/code&gt; 기반이지만, 역사적인 이유로 비교적 오래된 버전이 선택되었고 &lt;code&gt;optional&lt;/code&gt; 키워드를 지원하지 않습니다. 아시는 분들은 이해하실 텐데, 하위부터 &lt;code&gt;protobuf&lt;/code&gt;를 도입하기 시작했고 프로젝트가 정적 라이브러리 방식으로 배포되어 전체 컴파일 링크를 업그레이드해야 하는데, 이 비용은 매우 높습니다.&lt;/p&gt;
&lt;h3 id=&#34;gcc-버전-문제&#34;&gt;GCC 버전 문제
&lt;/h3&gt;&lt;p&gt;정말 어렵게 대안을 마련했는데, 하위 레이어에서 두 가지 다른 버전을 배포하여 가능한 한 &lt;code&gt;protobuf&lt;/code&gt; 새 버전의 컴파일 의존성 전파를 제어하려고 했습니다. 하지만 컴파일하는 과정에서 &lt;code&gt;gcc&lt;/code&gt; 버전이 너무 낮아 &lt;code&gt;protobuf&lt;/code&gt;의 새로운 기능을 지원하지 않는다는 것을 발견했습니다.&lt;/p&gt;
&lt;p&gt;그룹 내에서 일반적으로 사용되는 서버 유형은 CentOS 7, CentOS 8입니다. CentOS 7의 기본 &lt;code&gt;gcc&lt;/code&gt; 버전은 4.8이고, CentOS 8의 기본 &lt;code&gt;gcc&lt;/code&gt; 버전은 8.3입니다. &lt;code&gt;protobuf&lt;/code&gt;의 새로운 기능은 &lt;code&gt;gcc&lt;/code&gt; 버전이 7.4 이상을 요구하므로 CentOS 7은 지원할 수 없습니다.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=82461&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Bug 82461 - [7 Regression] Temporary required for brace-initializing (non-literal-type) member variable&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;마지막으로 관련 서비스 배포 및 컴파일 서버를 CentOS 8로 옮겨서 이 문제를 해결했다&lt;/p&gt;
&lt;h2 id=&#34;합리적인-열거&#34;&gt;합리적인 열거
&lt;/h2&gt;&lt;p&gt;전체 문제를 되돌아보면, 사실 더 간단하고 효율적인 해결책이 있습니다. 바로 열거형의 정의를 조정하여 1부터 번호를 매기도록 하는 것입니다. 이렇게 하면 기본값과 비즈니스 값을 효과적으로 구별할 수 있으며, 위에서 언급한 일련의 문제들을 피할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;왜-1부터-시작하는-것이-더-합리적일까요&#34;&gt;왜 1부터 시작하는 것이 더 합리적일까요?
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;protobuf&lt;/code&gt;에서 열거형 유형의 기본값은 0으로 고정되어 있습니다. 의미 있는 비즈니스 값을 0으로 정의할 경우(예: &amp;ldquo;거래 중&amp;rdquo;), 증분 푸시 시 비즈니스 측에서 수신된 0이 비즈니스 값인지, 아니면 초기화되지 않은 기본값인지 판단하기 어렵습니다. 하지만 열거형을 1부터 시작하여 정의하면 0은 무의미한 기본값 또는 &amp;ldquo;알 수 없음&amp;rdquo; 상태로 유지할 수 있어 문제가 해결됩니다.&lt;/p&gt;
&lt;p&gt;권장되는 방법:&lt;/p&gt;
&lt;p&gt;프로토콜 버퍼 열거형을 설계할 때 항상 0을 무의미한 기본값(예: &lt;code&gt;UNKNOWN&lt;/code&gt; 또는 &lt;code&gt;RESERVED&lt;/code&gt;)으로 정의하십시오
실제 비즈니스 값을 1부터 할당하여 기본값 0과 구별되도록 합니다&lt;/p&gt;
&lt;p&gt;이 작은 조정 덕분에 우리는 거래 시간대 식별 문제를 해결했을 뿐만 아니라 향후 프로토콜 설계에 귀중한 교훈을 얻게 되었습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>백그라운드 서비스 TCP 통신 이상 점검</title>
        <link>https://ttf248.life/ko/p/backend-service-tcp-communication-troubleshooting/</link>
        <pubDate>Fri, 14 Feb 2025 22:54:13 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/backend-service-tcp-communication-troubleshooting/</guid>
        <description>&lt;p&gt;비즈니스 모델: 백엔드 서비스는 TCP를 통해 그룹의 시장 게이트웨이와 연결을 맺습니다. 각 연결 시에는 먼저 인증 요청을 보내고, 그 후 지속적으로 하트비트 패킷을 전송하여 연결 상태를 유지합니다.
하지만 어느 날, 서비스 연결 해제 경고 메시지를 받았습니다. 로그를 꼼꼼히 확인해 본 결과, 백엔드 서비스는 계속해서 하트비트 패킷을 전송하고 있었지만 상대방은 전혀 응답하지 않았음에도 불구하고 연결은 끊어지지 않고 있었습니다.&lt;/p&gt;
&lt;h2 id=&#34;현장-간략-설명&#34;&gt;현장 간략 설명
&lt;/h2&gt;&lt;p&gt;원래 회사에서 야근하며 프로젝트 진행을 추진 중이었는데, 업무 그룹 채팅방에 갑자기 경고 메시지가 떴다. 처음에는 예전 문제라고 생각했다. 네트워크 타임아웃으로 인해 하트비트 전송이 실패해서 연결이 끊어진 것 같았다. 하지만 로그를 자세히 확인해 보니 실제 상황은 그렇지 않았다. 백엔드에서 인증 로그인 메시지를 보냈지만 계속 응답을 받지 못했고, 동시에 하트비트는 지속적으로 전송되었지만 상대방은 어떠한 하트비트 데이터도 반환하지 않았다. 로그를 심층적으로 분석한 결과 다음과 같은 몇 가지 주요 문제가 드러났다:&lt;/p&gt;
&lt;p&gt;인가 메시지에 대한 응답이 없으면, 상대방 시스템이 재시동 중이라 인가 메시지가 적시에 처리되지 않았을 가능성이 매우 높습니다
승인되지 않은 상태에서 하트비트 데이터를 전송하는 문제: 조사 결과, 프로그램 로직의 결함이 원인입니다. 하트비트 전송 함수의 판단 로직에 문제가 있어 연결 상태만 확인하고 인증 상태를 확인하지 않았습니다.
서비스 연결이 끊어지면 재연결 메커니즘을 트리거하여 인증 메시지를 다시 보낼 수 있습니다&lt;/p&gt;
&lt;p&gt;현재, 해결해야 할 마지막 문제점은 서비스 연결이 끊어지지 않은 이유입니다. 이 문제의 해결을 위해서는 보다 심층적이고 세밀한 점검 작업이 필요합니다.&lt;/p&gt;
&lt;h2 id=&#34;네트워크-데이터-패킷-분석&#34;&gt;네트워크 데이터 패킷 분석
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;tcpdump&lt;/code&gt;는 매우 강력한 네트워크 패킷 캡처 도구로, 네트워크 데이터 패킷을 포착하는 데 사용할 수 있습니다. 네트워크 데이터 패킷을 분석함으로써 우리는 네트워크 통신의 세부 사항을 보다 직관적으로 이해할 수 있습니다. 여기서는 &lt;code&gt;tcpdump&lt;/code&gt;를 사용하여 네트워크 데이터 패킷을 포착하여 추가 분석을 할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/backend-service-tcp-communication-troubleshooting/20250220151952.png&#34;
	width=&#34;1126&#34;
	height=&#34;202&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;tcpdump&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;557&#34;
		data-flex-basis=&#34;1337px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;데이터를 분석해 보면 심박수는 계속 정상적으로 전송되고 있지만, 상대방 서버로부터는 아무런 데이터도 수신되지 않았고, 단지 &lt;code&gt;ACK&lt;/code&gt;만 받았기 때문에 연결이 자동으로 끊어지지 않고 있습니다&lt;/p&gt;
&lt;h2 id=&#34;일반적인-플래그-설명&#34;&gt;일반적인 플래그 설명
&lt;/h2&gt;&lt;p&gt;TCP 프로토콜에서 &lt;code&gt;PSH&lt;/code&gt;(Push)와 &lt;code&gt;ACK&lt;/code&gt;(Acknowledgment)는 데이터 전송과 흐름 제어를 위해 사용되는 중요한 플래그 비트입니다. 이들의 역할은 다음과 같습니다:&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;1-pshpush-flag&#34;&gt;&lt;strong&gt;1. PSH（Push Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;기능:
PSH 플래그는 &lt;strong&gt;수신 측이 버퍼에 있는 데이터를 상위 애플리케이션으로 즉시 푸시하도록 요청하는 역할&lt;/strong&gt;을 합니다(버퍼가 채워질 때까지 기다리지 않고). 이는 PSH 플래그가 있는 데이터 세그먼트를 받으면 수신 측은 운영체제 버퍼에 저장하기보다는 가능한 한 빨리 처리하여 애플리케이션에 전달합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;전형적인 장면&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP/HTTPS 요청 시(예: &lt;code&gt;GET /index.html&lt;/code&gt;) 클라이언트는 서버가 즉시 응답하기를 바라는 &lt;code&gt;PSH&lt;/code&gt;를 설정합니다&lt;/li&gt;
&lt;li&gt;SSH 프로토콜: 키보드 입력이 있을 때마다 &lt;code&gt;PSH&lt;/code&gt;가 트리거되어 입력 문자가 실시간으로 전송되도록 합니다&lt;/li&gt;
&lt;li&gt;실시간 통신: 비디오 스트리밍, 온라인 게임 등 저지연 시나리오에서는 &lt;code&gt;PSH&lt;/code&gt;를 사용하여 지연을 줄일 수 있습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;주의:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PSH는 필수가 아니며, 수신측은 해당 비트(flag bit)를 무시할 수 있습니다(데이터는 정상적으로 처리해야 합니다)&lt;/li&gt;
&lt;li&gt;보내는 쪽에서 &lt;code&gt;PSH&lt;/code&gt;를 설정하지 않을 수 있으며, 이 경우 받는 쪽은 자체 버퍼링 정책에 따라 데이터를 언제 보낼지 결정합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2-ackacknowledgment-flag&#34;&gt;&lt;strong&gt;2. ACK（Acknowledgment Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;기능:
ACK 플래그는 &lt;strong&gt;이전 데이터 세그먼트가 올바르게 수신되었음을 확인&lt;/strong&gt;합니다. 각 ACK에는 확인 번호(Acknowledgment Number)가 포함되어 있으며, 이는 예상되는 다음 바이트 시퀀스 번호를 나타냅니다. 이는 TCP 신뢰성 있는 전송의 핵심 메커니즘입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;작동 원리:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;송신자는 데이터 세그먼트를 보낼 때, 예상 수신자의 &lt;code&gt;ACK&lt;/code&gt; 값(예: &lt;code&gt;ACK = 시퀀스 번호 + 데이터 길이&lt;/code&gt;)을 함께 전송합니다&lt;/li&gt;
&lt;li&gt;수신 장치가 데이터를 수신하면, 수신 확인(&lt;code&gt;ACK&lt;/code&gt;) 세그먼트를 생성하여 수신된 데이터의 시퀀스 번호를 확인합니다&lt;/li&gt;
&lt;li&gt;송신자는 해당 &lt;code&gt;ACK&lt;/code&gt;를 수신한 후에야만 확인되지 않은 데이터를 재전송합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예시입니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;송신자가 시퀀스 번호가 &lt;code&gt;100~199&lt;/code&gt;인 데이터 세그먼트를 보냈다면, 예상되는 수신자의 &lt;code&gt;ACK&lt;/code&gt;는 &lt;code&gt;200&lt;/code&gt;이어야 한다&lt;/li&gt;
&lt;li&gt;수신자가 &lt;code&gt;100~199&lt;/code&gt; 범위 내의 특정 데이터를 받지 못하면, 송신자에게 재전송을 요청하기 위해 &lt;code&gt;ACK=150&lt;/code&gt;으로 알립니다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;psh와-ack의-조합&#34;&gt;PSH와 ACK의 조합
&lt;/h3&gt;&lt;p&gt;TCP 패킷에서 &lt;code&gt;PSH&lt;/code&gt;와 &lt;code&gt;ACK&lt;/code&gt;가 동시에 나타나는 경우는 다음과 같은 상황에서 흔히 볼 수 있습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;HTTP 요청 응답
클라이언트가 &lt;code&gt;POST&lt;/code&gt; 요청(데이터 포함)을 보낼 때, &lt;code&gt;PSH&lt;/code&gt;와 &lt;code&gt;ACK&lt;/code&gt;(이전 응답 확인)가 설정됩니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Client → Server: SYN, ACK=1 → 建立连接
Client → Server: PSH, ACK=1, 数据 → 发送请求数据
Server → Client: PSH, ACK=数据长度+1 → 返回响应
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SSH 핸드셰이킹 후 명령 전송
클라이언트가 명령을 입력하면 &lt;code&gt;PSH&lt;/code&gt; 및 &lt;code&gt;ACK&lt;/code&gt;가 포함된 데이터 세그먼트를 전송하여 명령이 즉시 전송되고 서버에서 처리되도록 합니다&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;다른-플래그-비트의-연관성&#34;&gt;다른 플래그 비트의 연관성
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;기호&lt;/th&gt;
&lt;th&gt;이름&lt;/th&gt;
&lt;th&gt;간략 설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;동기화&lt;/td&gt;
&lt;td&gt;초기화 연결 (세 번의 악수)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FIN&lt;/td&gt;
&lt;td&gt;종료&lt;/td&gt;
&lt;td&gt;연결 우아하게 닫기&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;재설정&lt;/td&gt;
&lt;td&gt;강제 연결 종료 (비정상 상황)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;URG&lt;/td&gt;
&lt;td&gt;긴급&lt;/td&gt;
&lt;td&gt;긴급 포인터 표시 (거의 사용하지 않음)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h3 id=&#34;요약&#34;&gt;요약
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;데이터가 최대한 빨리 애플리케이션 계층에 도달하도록 하여 지연 시간을 줄이는 데 중점을 두고 있습니다&lt;/li&gt;
&lt;li&gt;데이터의 신뢰성 있는 전송에 중점을 두고, 패킷 손실이나 순서 변경을 방지합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;두 가지는 협력하여 TCP 프로토콜의 효율성과 안정성을 균형 있게 맞췄다&lt;/p&gt;</description>
        </item>
        <item>
        <title>atop 도구를 사용하여 Linux 시스템 지표를 모니터링하는 방법: 설치, 구성 및 사용법 완벽 가이드</title>
        <link>https://ttf248.life/ko/p/using-atop-to-monitor-linux-system-metrics-installation-configuration-and-usage-guide/</link>
        <pubDate>Thu, 06 Feb 2025 22:48:55 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/using-atop-to-monitor-linux-system-metrics-installation-configuration-and-usage-guide/</guid>
        <description>&lt;p&gt;리눅스 시스템 운영 과정에서 시스템 자원과 프로세스 상태를 실시간으로 종합적으로 모니터링하는 것은 매우 중요합니다. atop 도구는 강력한 모니터링 도구로서, 이를 쉽게 달성하도록 도와줍니다. 본 문서에서는 리눅스 인스턴스에 atop 모니터링 도구를 설치, 구성 및 사용하는 방법을 자세히 설명하겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;일반적으로-사용되는-atop-도구-소개&#34;&gt;일반적으로 사용되는 atop 도구 소개
&lt;/h2&gt;&lt;p&gt;atop은 Linux 시스템 리소스 및 프로세스를 모니터링하는 데 특화된 도구입니다. 시스템과 프로세스의 활동을 기록하고 모든 프로세스의 실행 상황을 보고합니다. 이 도구는 CPU, 메모리, 디스크, 네트워크 등 리소스 사용량 정보와 프로세스 상태 데이터를 수집하며, 데이터를 로그 파일 형태로 디스크에 저장할 수도 있습니다. 각 프로세스별로 CPU 사용률, 메모리 증가량, 디스크 사용률, 우선순위, 사용자 이름, 상태 및 종료 코드 등의 주요 정보를 얻을 수 있습니다. 또한 atop 설정 파일을 통해 로그 수집 빈도, 로그 파일 저장 경로 및 로테이션 정책과 같은 매개변수를 사용자 정의할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;두-번째-atop-도구-설치&#34;&gt;두 번째, atop 도구 설치
&lt;/h2&gt;&lt;p&gt;다양한 Linux 배포판에서 atop을 설치하는 방법은 약간씩 다르며, 다음에서는 일반적인 운영체제를 기준으로 설명하겠습니다&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Alibaba Cloud Linux 3/2、CentOS 7/8、Fedora、Rocky Linux 9&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실행 설치 명령: &lt;code&gt;sudo yum install -y atop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;atop 서비스를 시작합니다: &lt;code&gt;sudo systemctl start atop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Ubuntu / Debian&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;소프트웨어 저장소 목록 업데이트: &lt;code&gt;sudo apt update&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;실행 설치 명령: &lt;code&gt;sudo apt install -y atop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;atop 서비스를 시작합니다: &lt;code&gt;sudo systemctl start atop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CentOS Stream 9&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다운로드 및 설치: &lt;code&gt;sudo wget https://www.atoptool.nl/download/atop-2.11.0-1.el9.x86_64.rpm &amp;amp;&amp;amp; sudo rpm -i atop-2.11.0-1.el9.x86_64.rpm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;atop 서비스를 시작합니다: &lt;code&gt;sudo systemctl start atop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;openSUSE&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실행할 설치 명령: &lt;code&gt;sudo zypper install -y atop atop-daemon&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;atop 서비스를 시작합니다: &lt;code&gt;sudo systemctl start atop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;위에 나열된 운영체제에 사용하시는 배포판이 포함되어 있지 않다면, atop 공식 웹사이트에서 설치 정보를 확인하실 수 있습니다&lt;/p&gt;
&lt;h2 id=&#34;세-모니터링-주기-및-로그-보존-기간-설정&#34;&gt;세, 모니터링 주기 및 로그 보존 기간 설정
&lt;/h2&gt;&lt;p&gt;설정 파일 위치: Alibaba Cloud Linux 3/2, CentOS 7/8 및 Fedora 시스템에서는 atop의 설정 파일이 &lt;code&gt;/etc/sysconfig/atop&lt;/code&gt;이고, Ubuntu, Debian 및 openSUSE 시스템에서는 설정 파일이 &lt;code&gt;/etc/default/atop&lt;/code&gt;입니다
기본 설정 매개변수 설명
- 로그옵션은 로그 파일 기록 옵션을 제어하는 데 사용되며, 기본값은 비어 있습니다
- 로그 간격입니다. 기본값은 600초입니다. 과거 로그 추적 문제를 수집하려면 실제 요구 사항에 따라 이 빈도를 조정하는 것이 좋습니다.
- 로그 보존 기간, 기본값 28일
- 로그 파일 저장 경로입니다. 기본값은 /var/log/atop 입니다.
설정 단계
- 명령을 실행하여 설정 파일을 엽니다:
- Alibaba Cloud Linux 3/2, CentOS 7/8, Fedora 시스템에서: &lt;code&gt;sudo vim /etc/sysconfig/atop&lt;/code&gt;
- Ubuntu, Debian, openSUSE, CentOS Stream 9, Rocky Linux 9 시스템에서: &lt;code&gt;sudo vim /etc/default/atop&lt;/code&gt;
- &lt;code&gt;i&lt;/code&gt;로 들어가 편집 모드로 전환한 다음, 필요에 따라 구성 매개변수를 조정합니다. 예를 들어, 모니터링 주기를 30초로 변경하고, 로그 보존 기간을 7일로 설정하며, 로그 경로를 기본값으로 유지합니다.
- &lt;code&gt;Esc&lt;/code&gt; 키를 누르고 &lt;code&gt;:wq&lt;/code&gt; 를 입력하여 저장하고 편집을 종료합니다
- atop 서비스를 재시작하여 설정이 적용됩니다: &lt;code&gt;sudo systemctl restart atop&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;LOGOPTS=&amp;quot;&amp;quot;
LOGINTERVAL=30
LOGGENERATIONS=7
LOGPATH=/var/log/atop 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;네-알겠습니다-사-atop-도구-사용&#34;&gt;네, 알겠습니다. 사, atop 도구 사용
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;자주 사용되는 명령어 소개:&lt;/strong&gt; 상호 작용 명령 모드에서 다음의 자주 사용되는 명령어가 있습니다
- 기본 통합 출력 보기로 전환합니다
- 프로세스 열의 전체 명령줄을 표시합니다
- 프로세스 메모리 사용률에 따라 내림차순으로 필터링합니다
- 프로세스 디스크 사용률을 기준으로 내림차순으로 필터링합니다
- 프로세스 자원 종합 활용률에 따라 내림차순으로 필터링합니다
- 프로세스 네트워크 사용률에 따라 내림차순으로 필터링합니다
- 다음 모니터링 수집 지점으로 이동합니다
- 이전 모니터링 수집 지점으로 이동합니다
- 시간 지정, 형식은 &lt;code&gt;YYYYMMDDhhmm&lt;/code&gt;입니다&lt;/p&gt;
&lt;p&gt;자원 모니터링 필드 의미 설명
- 호스트 이름, 정보 샘플링 날짜 및 시간입니다
- 프로세스 전체 실행 상황, 커널 모드 및 사용자 모드 실행 시간, 프로세스 총 수, 다양한 상태의 프로세스 수 등을 포함합니다
- CPU 전체 사용률은 각 필드의 숫자 합계가 &lt;code&gt;N*100%&lt;/code&gt;(N은 CPU 코어 수)로 표시되며, 커널 모드, 사용자 모드, 인터럽트, 유휴 상태, 디스크 I/O 대기 등의 시간 비율을 포함합니다
- CPL은 CPU 부하 상황을 나타내며, 과거 1분, 5분 및 15분 동안 실행 대기열에 있는 평균 프로세스 수, 컨텍스트 스위칭 횟수, 인터럽트 발생 횟수를 포함합니다
- 메모리 사용량 정보로, 총 물리 메모리 용량, 유휴 메모리, 페이지 캐시 메모리, 파일 캐시 메모리, 커널 점유 메모리 등을 포함합니다
- SWP：스왑 공간 사용량 정보, 스왑 영역 총 용량 및 남은 스왑 공간 크기를 포함합니다
- 가상 메모리 페이지 상태, 예를 들어 스왑 인 및 스왑 아웃된 페이지 수
- DSK：디스크 사용률, 각 디스크 장치별로 한 열을 표시하며 장치 식별자, 바쁜 상태 시간 비율, 읽기/쓰기 요청 횟수를 나타냅니다
- 네트워크 상태를 보여주며, 전송 계층 TCP와 UDP, IP 계층 및 각 활성 네트워크 포트의 송수신 패킷 크기를 표시합니다&lt;/p&gt;
&lt;p&gt;실시간 시스템 지표 확인
- 매 5초마다 시스템 지표를 확인합니다: &lt;code&gt;atop 5&lt;/code&gt;
- 현재 시간 이후 5분 내 (총 30회, 간격 10초)의 시스템 지표를 확인합니다: &lt;code&gt;atop -M 10 30&lt;/code&gt;
- 현재 시간 이후 10분(10회, 간격 60초)의 시스템 지표를 확인하고 결과를 파일에 기록합니다: &lt;code&gt;atop -M 60 10 &amp;gt; /log/atop.mem&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;atop을 시작한 후 수집된 기록은 기본적으로 &lt;code&gt;/var/log/atop&lt;/code&gt; 디렉터리에 저장됩니다. 확인할 때는 지정된 날짜의 로그 파일이 반드시 존재해야 하며, 그렇지 않으면 오류가 발생합니다.
- 오늘 날짜의 히스토리 지표 로그 보기: &lt;code&gt;atop -r&lt;/code&gt;
- 어제 기록 지표 로그 확인: &lt;code&gt;atop -r y&lt;/code&gt;
- 지정된 날짜의 과거 지표 로그를 확인합니다. 예를 들어 2024년 11월 06일: &lt;code&gt;atop -r 20241106&lt;/code&gt;
- 지정된 날짜 및 시간 이후의 과거 지표 로그를 확인합니다. 예를 들어 2024년 11월 6일 14:00 이후: &lt;code&gt;atop -r 20241106 -b 14:00&lt;/code&gt;
- 지정된 날짜 및 시간 범위 내의 과거 지표 로그를 확인합니다. 예를 들어 2024년 11월 5일 00시 04분부터 00시 08분까지는 &lt;code&gt;atop -r 20241105 -b 00:04 -e 00:08&lt;/code&gt; 명령을 사용합니다.&lt;/p&gt;
&lt;p&gt;시스템 활동 보고서 확인
- 현재 시스템의 CPU 사용률 보고서를 1분 동안(12회, 간격 5초) 확인합니다: &lt;code&gt;atopsar -c 5 12&lt;/code&gt;
- 당일 지정된 시간대의 메모리 지표 보고서를 확인하려면, 예를 들어 18:00부터 18:01까지: &lt;code&gt;atopsar -m -b 18:00 -e 18:01&lt;/code&gt;
- 지정된 날짜 및 시간 범위 내의 메모리 지표 보고서를 확인합니다. 예를 들어 2024년 11월 5일 18:00부터 18:01까지: &lt;code&gt;atopsar -m -r 20241105 -b 18:00 -e 18:01&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;다섯-기타-조작&#34;&gt;다섯. 기타 조작
&lt;/h2&gt;&lt;p&gt;천기 수준 로그 로테이션 정책 구성: 매일 atop 지표 로그 파일을 생성하려면 다음 단계를 수행할 수 있습니다
- (선택 사항) 필요에 따라 모니터링 주기, 로그 보존 기간 및 로그 저장 경로를 조정합니다
- 명령을 실행하여 매일 로그 로테이션 관련 서비스의 자동 시작을 설정하고 서비스를 시작합니다: &lt;code&gt;sudo systemctl enable --now atop atopacct atop-rotate.timer&lt;/code&gt;
- 비즈니스에서 더 복잡한 로깅 처리가 필요하다면 logrotate나 사용자 정의 스크립트를 활용하여 로그 관리를 구현할 수 있습니다&lt;/p&gt;
&lt;p&gt;선택적 netatop 커널 모듈 로드: 네트워크 사용률을 모니터링하려면 netatop 모듈(atop에서 기본적으로 설치되지 않음)을 설치할 수 있습니다. Alibaba Cloud Linux 3 시스템의 예를 들어:
- 커널 개발 패키지 및 컴파일에 필요한 소프트웨어 환경 설치: &lt;code&gt;sudo yum install -y kernel-devel dkms elfutils-libelf-devel&lt;/code&gt;
- 최신 버전 netatop 소스 코드를 지정된 디렉터리로 다운로드합니다: &lt;code&gt;cd /usr/src/ &amp;amp;&amp;amp; sudo wget https://www.atoptool.nl/download/netatop-3.2.2.tar.gz --no-check-certificate&lt;/code&gt;
- 소스 코드를 압축 해제하고 소스 코드 디렉토리로 들어갑니다: &lt;code&gt;sudo tar -zxvf netatop-3.2.2.tar.gz &amp;amp;&amp;amp; cd netatop-3.2.2&lt;/code&gt;
- 소스 코드를 기반으로 모듈과 데몬을 빌드하고 설치합니다: &lt;code&gt;sudo make &amp;amp;&amp;amp; sudo make install&lt;/code&gt;
- netatop 서비스 시작: &lt;code&gt;sudo systemctl start netatop&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;atop 도구는 기능이 강력하고 사용하기 유연하며, 적절한 설치, 구성 및 사용을 통해 Linux 시스템의 실행 상태를 더 잘 이해하고 잠재적인 문제를 조기에 발견하여 해결할 수 있습니다. 본 문서가 Linux 시스템 모니터링 측면에서 여러분의 역량을 향상시키는 데 도움이 되기를 바랍니다.&lt;/p&gt;
&lt;h2 id=&#34;6-참고-자료-링크&#34;&gt;6. 참고 자료 링크
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;[atop 공식 웹사이트]&lt;/li&gt;
&lt;li&gt;[ atop 모니터링 도구 설치, 구성 및 사용 ]&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Visual Studio에서 일치하지 않는 PDB 파일을 로드합니다</title>
        <link>https://ttf248.life/ko/p/visual-studio-loading-unmatched-pdb-files/</link>
        <pubDate>Thu, 23 Jan 2025 20:04:33 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/visual-studio-loading-unmatched-pdb-files/</guid>
        <description>&lt;p&gt;윈도우에서 Visual Studio로 프로그램을 디버깅할 때, pdb 파일이 실행 파일과 일치하지 않으면 Visual Studio가 &amp;ldquo;기호 파일을 로드할 수 없음&amp;quot;이라는 메시지를 표시합니다. 프로그램이 충돌하고 덤프 파일이 생성되면, 일치하지 않는 pdb 파일 때문에 Visual Studio는 충돌 현장에 원활하게 진입하지 못합니다.&lt;/p&gt;
&lt;h2 id=&#34;pdb-파일이-뭐죠&#34;&gt;pdb 파일이 뭐죠?
&lt;/h2&gt;&lt;p&gt;PDB 파일은 마이크로소프트에서 제공하는 디버깅 정보 파일이며, 프로그램 디버깅에 사용됩니다. PDB 파일에는 프로그램의 심볼 테이블, 소스 코드 파일 이름, 행 번호 등의 정보가 포함되어 있습니다. 프로그램 컴파일 시 PDB 파일을 생성하여 프로그램을 디버깅할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;windbg-디버깅&#34;&gt;WinDbg 디버깅
&lt;/h2&gt;&lt;p&gt;WinDbg는 마이크로소프트의 디버깅 도구이며, Windows 프로그램을 디버깅하는 데 사용될 수 있습니다. WinDbg는 호환되지 않는 pdb 파일을 로드할 수 있지만, 수동으로 로드해야 합니다. &lt;code&gt;.reload /f /i&lt;/code&gt; 명령어를 사용하여 호환되지 않는 pdb 파일을 강제로 로드할 수 있습니다.&lt;/p&gt;
&lt;p&gt;하지만 WinDbg는 Visual Studio만큼 사용하기 편리하지 않으므로, 저희는 Visual Studio에서도 호환되지 않는 PDB 파일을 로드할 수 있기를 바랍니다&lt;/p&gt;
&lt;h2 id=&#34;비주얼-스튜디오에서-호환되지-않는-pdb-파일을-로드합니다&#34;&gt;비주얼 스튜디오에서 호환되지 않는 PDB 파일을 로드합니다
&lt;/h2&gt;&lt;p&gt;소스 코드는 보통 git으로 관리되므로, 해당 버전의 코드를 찾아 다시 컴파일하여 일치하는 pdb 파일을 생성할 수 있습니다. 왜 로드되지 않을까요? 주로 메타데이터가 매칭되지 않기 때문입니다.&lt;/p&gt;
&lt;p&gt;작은 도구가 있는데, 실행 파일 정보에 기반하여 메타데이터를 수정하고 새로운 pdb 파일을 생성하여 Visual Studio가 로드할 수 있게 합니다&lt;/p&gt;
&lt;p&gt;chkmatch 다운로드 주소: &lt;a class=&#34;link&#34; href=&#34;https://www.debuginfo.com/tools/chkmatch.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.debuginfo.com/tools/chkmatch.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;사이트 캐시 주소: &lt;a class=&#34;link&#34; href=&#34;chkmatch.zip&#34; &gt;chkmatch.zip&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ChkMatch utility can be used to check whether an executable and debug information file match. It can also be used to enforce matching between an executable and debug information file, if they are compatible.

For more information about debug information matching and related issues, see this article.

Supported debug information formats: DBG, PDB 2.0, PDB 7.0.

chkmatch [-c ExeFile DebugInfoFile ] |
         [-m ExeFile DebugInfoFile]
-c
Check matching between the executable and the debug information file.
-m
Make the executable and the debug information file match.
ExeFile
The name of the executable file.
DebugInfoFile
The name of the debug information file.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;chkmatch-사용하세요&#34;&gt;chkmatch 사용하세요
&lt;/h2&gt;&lt;p&gt;먼저 검사 작업을 수행하고, 불일치 원인을 분석한 후 서명 불일치를 알립니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\tianlong.xiang\Downloads\chkmatch&amp;gt;ChkMatch.exe -c &amp;quot;D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe&amp;quot; E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb
ChkMatch - version 1.0
Copyright (C) 2004 Oleg Starodumov
http://www.debuginfo.com/


Executable: D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe
Debug info file: E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb

Executable:
TimeDateStamp: c26d9be3
Debug info: 2 ( CodeView )
TimeStamp: f86b0a4f  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 122  RVA: 001cdc44  FileOffset: 001cbe44
CodeView format: RSDS
Signature: {428c9b95-39a3-4a8d-a8e5-7be453684757}  Age: 1
PdbFile: D:\stock_UAT\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\obj\Release\YinTrade.Main.pdb
Debug info: 16 ( Unknown )
TimeStamp: 00000000  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 0  RVA: 00000000  FileOffset: 00000000

Debug information file:
Format: PDB 7.00
Signature: {06fae08e-c0a2-4f3d-9c7c-dfc684445dd1}  Age: 1

Result: Unmatched (reason: Signature mismatch)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그런 다음 수정 작업을 실행하여 pdb 파일과 exe 파일을 일치시킵니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\tianlong.xiang\Downloads\chkmatch&amp;gt;ChkMatch.exe -m &amp;quot;D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe&amp;quot; E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb
ChkMatch - version 1.0
Copyright (C) 2004 Oleg Starodumov
http://www.debuginfo.com/


Executable: D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe
Debug info file: E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb

Executable:
TimeDateStamp: c26d9be3
Debug info: 2 ( CodeView )
TimeStamp: f86b0a4f  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 122  RVA: 001cdc44  FileOffset: 001cbe44
CodeView format: RSDS
Signature: {428c9b95-39a3-4a8d-a8e5-7be453684757}  Age: 1
PdbFile: D:\stock_UAT\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\obj\Release\YinTrade.Main.pdb
Debug info: 16 ( Unknown )
TimeStamp: 00000000  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 0  RVA: 00000000  FileOffset: 00000000

Debug information file:
Format: PDB 7.00
Signature: {06fae08e-c0a2-4f3d-9c7c-dfc684445dd1}  Age: 1

Writing to the debug information file...
Result: Success.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/38147487/forcing-to-load-unmatched-symbols-in-visual-studio-2015-debugger&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;forcing-to-load-unmatched-symbols-in-visual-studio-2015-debugger&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>리눅스 백엔드 서비스 문자열 데이터 처리 - 속도가 느림</title>
        <link>https://ttf248.life/ko/p/linux-backend-slow-string-processing/</link>
        <pubDate>Wed, 13 Nov 2024 19:42:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/linux-backend-slow-string-processing/</guid>
        <description>&lt;p&gt;C++ 개발의 과거 프로젝트에서 우리는 자체 프로토콜을 사용하여 통신했고, 이 프로토콜은 2차원 배열 패턴을 채택했습니다. 대량의 데이터를 처리할 때 프로토콜 내부에서 배열을 순회하고 시리얼화 작업을 수행하여 로그를 생성해야 했는데, 효율성이 낮아 시스템이 고부하 상태에서 눈에 띄는 끊김 현상을 일으켰고, 이로 인해 사업 부서로부터 시스템 끊김에 대한 피드백을 받았습니다.&lt;/p&gt;
&lt;h2 id=&#34;문제-파악&#34;&gt;문제 파악
&lt;/h2&gt;&lt;p&gt;문제 해결 과정에서, 우리는 먼저 시스템 성능을 분석했고, 대량의 데이터를 처리할 때 CPU 사용률이 눈에 띄게 증가하고 시스템 응답 시간이 길어지는 것을 확인했습니다. 시스템 로그를 분석한 결과, 많은 양의 직렬화 작업이 있었고, 이러한 작업은 특히 2차원 배열을 처리할 때 효율성이 낮아 시스템 성능 저하를 유발하는 것으로 나타났습니다.&lt;/p&gt;
&lt;p&gt;pstack 도구로 스레드 정보를 캡처한 결과, 로그 스레드가 대부분의 시간을 문자열 연결 처리에 소비하는 것으로 나타났다&lt;/p&gt;
&lt;p&gt;여기 오늘의 핵심인데, 다른 누적 방식에 따라 효율성이 엄청나게 달라집니다. 기존 코드에서는 + 연산자를 사용했는데, 이 방식은 빈번하게 임시 객체를 생성하므로 효율이 매우 낮습니다. 그 비효율성을 알고는 있지만, 얼마나 비효율적인지 제대로 모르는 그런 종류입니다.&lt;/p&gt;
&lt;h2 id=&#34;데모-검증&#34;&gt;데모 검증
&lt;/h2&gt;&lt;p&gt;프로젝트 코드를 기반으로 비즈니스 로직을 분리하고, 문자열 연결 효율성 문제를 검증하기 위한 간단한 데모를 작성했습니다. &lt;code&gt;windows&lt;/code&gt; 환경의 &lt;code&gt;vs2022&lt;/code&gt; 컴파일러와 &lt;code&gt;linux&lt;/code&gt; 환경의 &lt;code&gt;gcc8.5&lt;/code&gt; 컴파일러로 &lt;code&gt;Release&lt;/code&gt; 모드에서 컴파일 및 실행하여 효율성을 비교했습니다.&lt;/p&gt;
&lt;h3 id=&#34;주요-사항-안내&#34;&gt;주요 사항 안내
&lt;/h3&gt;&lt;p&gt;프로젝트에서는 방법 네 가지를 사용했는데, 테스트 데이터를 받기 전 독자들은 어떤 방식이 가장 효율적이고 어떤 방식이 가장 비효율적인지 먼저 생각해 볼 수 있습니다. 결과를 보았을 때 저는 여전히 놀랐습니다.&lt;/p&gt;
&lt;p&gt;방법 1 (&lt;code&gt;+=&lt;/code&gt; 연결): 각 필드를 &lt;code&gt;+=&lt;/code&gt; 연산자를 사용하여 문자열에 직접 연결합니다
방법 2 ( &lt;code&gt;std::ostringstream&lt;/code&gt; 연결): 스트림(&lt;code&gt;std::ostringstream&lt;/code&gt;)을 사용하여 각 필드를 연결하는 방법으로, 특히 대량의 데이터를 연결할 때 더 효율적입니다
방법 3(미리 할당된 메모리의 += 연결): &lt;code&gt;reserve&lt;/code&gt;를 사용하여 문자열에 필요한 충분한 메모리를 미리 할당하면 메모리 재할당 비용을 줄여 성능을 향상시킬 수 있습니다
방법 4(&lt;code&gt;bodys = bodys + body + &amp;quot;\n&amp;quot;&lt;/code&gt;): 매번 연결할 때마다 새로운 임시 문자열 객체를 생성하므로, 특히 대규모 연결 시 성능 저하가 발생합니다. 이는 매번 연결이 새로운 메모리 할당 및 복사를 수반하기 때문입니다.&lt;/p&gt;
&lt;p&gt;참고 결과, 프로젝트가 효율이 가장 낮은 방식을 선택한 것을 알 수 있습니다&lt;/p&gt;
&lt;p&gt;더 나아가, 다양한 플랫폼 컴파일러의 최적화 효율을 분석해 보겠습니다. 마이크로소프트의 &lt;code&gt;Visual Studio&lt;/code&gt;는 여전히 뛰어난 성능을 보여주며 문자열 최적화 효율이 매우 높지만, &lt;code&gt;gcc&lt;/code&gt; 컴파일러는 이 부분에서 최적화 효율이 다소 떨어지는 편입니다.&lt;/p&gt;
&lt;p&gt;코드 실행 환경이 다른 기계에서 이루어지므로 데이터 간의 직접적인 비교는 의미가 없습니다. 각각의 조인 방법 간의 차이를 비교하는 것이 좋습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;windows 平台下的 vs2022 编译器

----------------------------------------
Data Generation Time: 0.054 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.053 seconds.
+ ostringstream Data merging took: 0.054 seconds.
+ Pre-reserved Data merging took: 0.045 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 16.108 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;linux 平台下的 gcc8.5 编译器
----------------------------------------
Data Generation Time: 0.108 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.100 seconds.
+ ostringstream Data merging took: 0.083 seconds.
+ Pre-reserved Data merging took: 0.057 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 29.298 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;전체-코드&#34;&gt;전체 코드
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;random&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;iomanip&amp;gt;

typedef std::vector&amp;lt;std::string&amp;gt; DataRow;
typedef std::vector&amp;lt;DataRow&amp;gt; DataGroup;

struct ResponsePackage
{
    std::string ErrorInfo;
    DataRow Head;
    std::string ClientId;
    std::string UUID;
    std::string MsgID;
    std::string SessionID;
    std::string ExtraInfo1;
    std::string ExtraInfo2;
    DataGroup DataBody;
};

// Generate specified length of random string
std::string generateRandomString(size_t length)
{
    const char charset[] = &amp;quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&amp;quot;;
    const size_t max_index = sizeof(charset) - 1;
    std::string random_string;
    random_string.reserve(length);

    std::random_device rd;
    std::mt19937 generator(rd());
    std::uniform_int_distribution&amp;lt;&amp;gt; distribution(0, max_index);

    for (size_t i = 0; i &amp;lt; length; ++i)
    {
        random_string += charset[distribution(generator)];
    }

    return random_string;
}

void create_large_string()
{
    // Example request package with 50 fields
    ResponsePackage requestPackage;

    requestPackage.Head = {
        &amp;quot;Field1&amp;quot;, &amp;quot;Field2&amp;quot;, &amp;quot;Field3&amp;quot;, &amp;quot;Field4&amp;quot;, &amp;quot;Field5&amp;quot;,
        &amp;quot;Field6&amp;quot;, &amp;quot;Field7&amp;quot;, &amp;quot;Field8&amp;quot;, &amp;quot;Field9&amp;quot;, &amp;quot;Field10&amp;quot;,
        &amp;quot;Field11&amp;quot;, &amp;quot;Field12&amp;quot;, &amp;quot;Field13&amp;quot;, &amp;quot;Field14&amp;quot;, &amp;quot;Field15&amp;quot;,
        &amp;quot;Field16&amp;quot;, &amp;quot;Field17&amp;quot;, &amp;quot;Field18&amp;quot;, &amp;quot;Field19&amp;quot;, &amp;quot;Field20&amp;quot;,
        &amp;quot;Field21&amp;quot;, &amp;quot;Field22&amp;quot;, &amp;quot;Field23&amp;quot;, &amp;quot;Field24&amp;quot;, &amp;quot;Field25&amp;quot;,
        &amp;quot;Field26&amp;quot;, &amp;quot;Field27&amp;quot;, &amp;quot;Field28&amp;quot;, &amp;quot;Field29&amp;quot;, &amp;quot;Field30&amp;quot;,
        &amp;quot;Field31&amp;quot;, &amp;quot;Field32&amp;quot;, &amp;quot;Field33&amp;quot;, &amp;quot;Field34&amp;quot;, &amp;quot;Field35&amp;quot;,
        &amp;quot;Field36&amp;quot;, &amp;quot;Field37&amp;quot;, &amp;quot;Field38&amp;quot;, &amp;quot;Field39&amp;quot;, &amp;quot;Field40&amp;quot;,
        &amp;quot;Field41&amp;quot;, &amp;quot;Field42&amp;quot;, &amp;quot;Field43&amp;quot;, &amp;quot;Field44&amp;quot;, &amp;quot;Field45&amp;quot;,
        &amp;quot;Field46&amp;quot;, &amp;quot;Field47&amp;quot;, &amp;quot;Field48&amp;quot;, &amp;quot;Field49&amp;quot;, &amp;quot;Field50&amp;quot;
    };

    requestPackage.ClientId = &amp;quot;ClientID&amp;quot;;
    requestPackage.UUID = &amp;quot;UUID&amp;quot;;
    requestPackage.MsgID = &amp;quot;MsgID&amp;quot;;
    requestPackage.SessionID = &amp;quot;SessionID&amp;quot;;
    requestPackage.ExtraInfo1 = &amp;quot;ExtraInfo1&amp;quot;;
    requestPackage.ExtraInfo2 = &amp;quot;ExtraInfo2&amp;quot;;

    // Start timing for data generation
    auto start_gen = std::chrono::high_resolution_clock::now();

    // Generate 10,000 rows of data, each with 50 fields
    for (size_t i = 0; i &amp;lt; 10000; ++i)
    {
        DataRow dataRow(50, &amp;quot;This is a test string&amp;quot;);
        requestPackage.DataBody.push_back(dataRow);
    }

    // End timing for data generation
    auto end_gen = std::chrono::high_resolution_clock::now();
    std::chrono::duration&amp;lt;double&amp;gt; duration_gen = end_gen - start_gen;

    // Display result generation time
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Generation Time: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_gen.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    // Data merging using different methods
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Performance:\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    {
        // Method 1: Using &#39;+=&#39; string concatenation
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (+=) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 2: Using ostringstream
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::ostringstream bodys;
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::ostringstream body;
            body &amp;lt;&amp;lt; &amp;quot;This is a test string&amp;quot;;
            for (auto&amp;amp; item : vec)
            {
                body &amp;lt;&amp;lt; item &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            }
            bodys &amp;lt;&amp;lt; body.str() &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ ostringstream Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 3: Pre-allocated memory
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys;
        bodys.reserve(1000 * 50 * 20); // Pre-allocate enough memory
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            body.reserve(50 * 20); // Pre-allocate memory for each row
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Pre-reserved Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 4: Using &#39;bodys = bodys + body + &amp;quot;\n&amp;quot;&#39;
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body = body + item + &amp;quot; &amp;quot;; // Note the use of &#39;body = body + item&#39;
            }
            bodys = bodys + body + &amp;quot;\n&amp;quot;; // Again, using &#39;bodys = bodys + body&#39;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (bodys = bodys + body + \&amp;quot;\\n\&amp;quot;) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Complete.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;
}

int main()
{
    try
    {
        create_large_string();
    }
    catch (const std::exception&amp;amp; e)
    {
        std::cerr &amp;lt;&amp;lt; &amp;quot;Caught exception: &amp;quot; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\nProgram finished.\n&amp;quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Win11 로지텍 G431 헤드셋 드라이버 설치</title>
        <link>https://ttf248.life/ko/p/win11-logitech-g431-headphone-driver-installation/</link>
        <pubDate>Wed, 05 Jun 2024 07:20:17 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/win11-logitech-g431-headphone-driver-installation/</guid>
        <description>&lt;p&gt;책은 지난 번에 이어져서, 돌아와 보니 Ghub이 업데이트되었네. 조금 기뻤는데, 고객센터에서 해결했다고 하는 문제 드라이브가 정상적으로 로드되지 않는 문제가 해결되었다고 했는데, 결과적으로 한 바퀴 뱅글뱅글 돌리고 재설치 및 제거를 해도 제대로 사용하지 못하네.&lt;/p&gt;
&lt;h2 id=&#34;배경&#34;&gt;배경
&lt;/h2&gt;&lt;p&gt;계속 고객센터에 문의하여 처리 방안을 알아보니, 엔지니어의 원격 지원은 가능하지만 엔지니어의 근무 시간과 제 근무 시간이 똑같다는 답변을 받았습니다. 어쩔 수 없이 포기하고, 이전 문제 해결 과정에서 남겨둔 자료를 살펴보며 직접 드라이버를 설치해 보려고 합니다.&lt;/p&gt;
&lt;h2 id=&#34;드라이버-설치-패키지-받기&#34;&gt;드라이버 설치 패키지 받기
&lt;/h2&gt;&lt;p&gt;로지텍 공식에서는 별도의 장치 드라이버 설치 파일을 제공하지 않습니다. 드라이버 파일은 어떻게 얻을 수 있나요?&lt;/p&gt;
&lt;p&gt;이전 시스템 재설치로 남은 시스템 이미지 설치 패키지를 활용하여, 로컬 가상 머신에서 시스템을 다시 설치할 수 있습니다. 깨끗한 시스템 환경에서 Ghub를 개별적으로 배포하고, 헤드폰 장치를 가상 머신에 연결한 후 드라이버 경로를 찾아 복사해낼 수 있습니다.&lt;/p&gt;
&lt;p&gt;관련 경로:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C:\ProgramData\LGHUB&lt;/li&gt;
&lt;li&gt;C:\Windows\System32\DriverStore\FileRepository\logi_audio.inf_amd64_010b035044e24be4&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장치-관리자&#34;&gt;장치 관리자
&lt;/h2&gt;&lt;p&gt;두 번째 경로를 찾는 것이 핵심인데, 먼저 Win11 시스템에서 드라이버 파일을 수동으로 관리하는 방법을 간단히 정리해 보겠습니다. 이 내용은 &lt;strong&gt;변수 제어법을 통해 식별했는데, 가상 머신 안에서 장치를 계속 연결하고 분리하면서 장치 관리자에서 장치 정보를 분석하여 헤드폰에 대해 처리해야 할 세 개의 드라이버가 있다는 것을 확인했습니다&lt;/strong&gt;. 그 중 두 개는 시스템 내장 드라이버이고 하나는 로지텍에서 제공하는 것입니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;드라이버 관리자&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;상단 그림의 두 번째 드라이버는 로지텍에서 제공하는 것으로, 현재 장치의 드라이버를 분석하고 가상 머신 안에서 모든 드라이버 경로를 뒤져야 합니다. 당연히 logi로 시작하는 파일을 먼저 찾아야 하고, 파일 비교를 통해 드라이버 파일을 찾을 수 있습니다. 전체 폴더를 복사하면 드라이버 설치 패키지를 얻게 됩니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;드라이버 설치 패키지&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;드라이버-설치&#34;&gt;드라이버 설치
&lt;/h2&gt;&lt;p&gt;장치 관리자 인터페이스에서 “드라이버 업데이트”를 클릭한 다음, “내 컴퓨터에서 드라이버 찾아보기”를 클릭하면 다음과 같은 화면으로 진입합니다&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;드라이버 설치&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;물론 열면 드라이버 하나만 보일 텐데, 그것은 일반 USB 드라이버입니다. &amp;ldquo;디스크에서 설치&amp;quot;를 선택하고 경로가 앞서 복사해 놓은 폴더로 설정하면 됩니다. 설치 후에는 드롭다운 목록에 로지텍 특유의 드라이버가 추가될 것이고, 새로 설치된 드라이버로 장치 드라이버를 전환하면 됩니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;디스크 설치&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;인체학-장비-드라이버&#34;&gt;인체학 장비 드라이버
&lt;/h2&gt;&lt;p&gt;이 장치의 드라이버 파일은 모두 시스템에서 제공하는 것이므로, 장치 드라이버 앞에 느낌표가 있는지 확인하기만 하면 됩니다. 느낌표가 있다면 드라이버 선택 화면으로 들어가서 다른 유형의 드라이버로 임시로 변경한 후 다시 원래대로 돌리면 정상적으로 복구됩니다.&lt;/p&gt;
&lt;h2 id=&#34;완료&#34;&gt;완료
&lt;/h2&gt;&lt;p&gt;헤드폰 마이크 음량이 정상으로 돌아왔고, 익숙한 이어모니터 기능도 다시 작동하기 시작했습니다&lt;/p&gt;
&lt;p&gt;측음&lt;/p&gt;</description>
        </item>
        <item>
        <title>새로 설치한 기가급 유선 광섬유 회선인데 속도 측정 시 100메가에 그치는 이유는 무엇인가요?</title>
        <link>https://ttf248.life/ko/p/new-gigabit-fiber-slow-speed/</link>
        <pubDate>Mon, 18 Mar 2024 00:29:02 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/new-gigabit-fiber-slow-speed/</guid>
        <description>&lt;p&gt;집안 네트워크를 번개처럼 빠릿하게 만들고 싶으신가요? 핵심은 랜 케이블 선택, 광모뎀 및 공유기 설정, 그리고 눈에 띄지 않는 작은 디테일을 이해하는 데 있습니다. 이 블로그는 6급 랜 케이블로 기가비트 네트워크를 구축하고 간단한 장비 점검과 설정을 통해 네트워크 속도를 제약 없이 유지하는 방법을 쉽게 알려드릴 것입니다. 함께 탐색하며 집안 인터넷 속도를 높여 봅시다!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;수동 복구&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;제1장-네트워크-전송-매체-심층-분석&#34;&gt;제1장: 네트워크 전송 매체 심층 분석
&lt;/h2&gt;&lt;p&gt;기가비트급 네트워크 접속을 논할 때, 정보를 고속으로 전송하는 매개체인 랜 케이블은 매우 중요한 역할을 합니다. 다음에서는 5급, 6급 및 7급 랜 케이블에 대해 자세히 설명하겠습니다.&lt;/p&gt;
&lt;h3 id=&#34;다섯-종류의-네트워크-케이블cat5&#34;&gt;다섯 종류의 네트워크 케이블(CAT5)
&lt;/h3&gt;&lt;p&gt;다섯 종류의 네트워크 케이블, CAT5라고도 불리는 이 케이블은 비교적 초기에 널리 사용된 트위스트 페어 케이블 유형으로, 각 선 코어가 정밀한 나선 구조 설계로 인해 신호 간섭을 줄입니다. 주로 10/100Mbps의 빠른 이더넷에 적용되며 최대 전송 주파수는 약 100MHz입니다. 과거에는 널리 사용되었지만 현재 기가비트 이상 속도를 추구하는 요구 사항을 충족하기 위해서는 물리적인 한계로 인해 다섯 종류의 네트워크 케이블은 요구를 만족시키지 못합니다.&lt;/p&gt;
&lt;h3 id=&#34;6가지-네트워크-케이블cat6&#34;&gt;6가지 네트워크 케이블(CAT6)
&lt;/h3&gt;&lt;p&gt;기술 발전과 함께 6가지 종류의 네트워크 케이블이 등장했습니다. 5가지 종류의 네트워크 케이블에 비해 6가지 종류의 케이블은 더 엄격한 제조 기준과 더욱 발전된 구조 설계로 제작되어, 전반적인 내성능과 데이터 전송 효율을 크게 향상시켰습니다. 최대 1Gbps의 전송 속도를 지원하며 이상적인 조건에서는 전송 거리가 100미터까지 가능하여, 기가비트 네트워크 접속 요구 사항에 정확히 부합합니다.&lt;/p&gt;
&lt;h3 id=&#34;7가지-네트워크-케이블-cat7&#34;&gt;7가지 네트워크 케이블 (CAT7)
&lt;/h3&gt;&lt;p&gt;7가지 종류의 네트워크 케이블은 현재 트위스트 페어 기술의 최첨단을 나타냅니다. 이는 전송 속도에서 비약적인 향상을 가져왔을 뿐만 아니라 이론적으로 최대 10Gbps의 초고속을 지원하며, 설계에 완전한 차폐 시스템을 적용하여 각 선 쌍 간의 차폐와 전체 외부층의 차폐를 포함함으로써 외부 전자파 간섭과 근접 교차 누화를 크게 줄여 데이터 전송의 안정성과 정확성을 보장합니다. 하지만 7가지 종류의 네트워크 케이블은 주로 미래의 10기가비트 이더넷 또는 특정 고 요구 사항 시나리오에 사용됩니다.&lt;/p&gt;
&lt;p&gt;기가비트 가정 네트워크 환경을 구축할 때, 기가 광섬유의 잠재력을 최대한 발휘하기 위해서는 6급 랜 케이블을 선택하는 것이 가장 경제적이고 효율적인 방법입니다. 동시에 모든 연결 케이블의 품질이 양호한지 확인하고 엄격하게 표준 배선 방식으로 작업하는 것도 네트워크 성능을 확보하는 중요한 단계입니다.&lt;/p&gt;
&lt;h2 id=&#34;제2장-네트워크-핵심-장비인-광모뎀-라우터-lan-포트-대역폭의-영향-심층-분석&#34;&gt;제2장: 네트워크 핵심 장비인 광모뎀, 라우터 LAN 포트 대역폭의 영향 심층 분석
&lt;/h2&gt;&lt;h3 id=&#34;광촉매와-lan-포트-대역폭의-중요성&#34;&gt;광촉매와 LAN 포트 대역폭의 중요성
&lt;/h3&gt;&lt;p&gt;광촉매, 정식 명칭 광섬유 모뎀은 가정용 초고속 인터넷 접속의 핵심 장비이며, 빛 신호를 디지털 신호로 변환하여 가정 네트워크 장비에서 사용하도록 하는 기능이 있습니다. 기가급 광섬유 사용자에게 있어 광촉매가 기가 전송을 지원하는지 여부가 특히 중요합니다. 만약 광촉매의 WAN 포트가 기가 속도를 지원하지 않는다면, 입구 광섬유 속도가 아무리 높아도 이 병목 현상으로 인해 기가 속도 내에서 제한됩니다. 마찬가지로 광촉매의 LAN 포트 또한 기가 출력 능력을 갖춰야 하며, 그렇지 않으면 연결된 라우터나 다른 장비는 진정한 기가 속도를 얻을 수 없습니다.&lt;/p&gt;
&lt;h3 id=&#34;라우터-lan-포트-대역폭의-역할&#34;&gt;라우터 LAN 포트 대역폭의 역할
&lt;/h3&gt;&lt;p&gt;라우터의 LAN 포트는 수신된 데이터를 각 단말 장치에 분배하는 역할을 합니다. 라우터의 LAN 포트가 100메가비트에 불과할 경우, 다른 장치의 구성이 아무리 좋아도 100메가비트 속도의 로컬 네트워크 통신만 가능합니다. 따라서 기가홈 파티를 구축할 때는 라우터의 WAN 포트가 기가 데이터를 수신할 수 있도록 하고, LAN 포트 또한 기가 수준의 데이터 출력 능력을 제공해야 모든 스마트 장치가 고속 네트워크가 제공하는 원활한 경험을 누릴 수 있습니다.&lt;/p&gt;
&lt;p&gt;또한, 주의해야 할 점은 일부 구형 또는 저가형 라우터는 LAN 포트 자동 협상 기능이 있을 수 있다는 것입니다. 즉, 라우터 자체는 기가비트를 지원하더라도 회선, 장치 호환성 등의 이유로 속도가 100메가비트 모드로 낮아질 수 있습니다. 따라서 기가비트 네트워크를 구현하기 위해서는 라우터 설정을 올바르게 구성하고 강제 기가비트 모드를 활성화하며 기가비트 스위치 또는 직접 연결 장치를 함께 사용하는 것이 중요한 단계 중 하나입니다.&lt;/p&gt;
&lt;p&gt;기가급 광섬유로 업그레이드한 후에는 반드시 기가급 ONT와 기가급 라우터로 교체하고, 모든 장비 인터페이스가 기가급 수준에 도달하는지 확인하십시오&lt;/p&gt;
&lt;h2 id=&#34;제3장-숨겨진-미스터리---끊어진-서브스레드가-어떻게-테라비트급-네트워크-속도에-영향을-미치는가&#34;&gt;제3장: 숨겨진 미스터리 - 끊어진 서브스레드가 어떻게 테라비트급 네트워크 속도에 영향을 미치는가
&lt;/h2&gt;&lt;h3 id=&#34;서브-라인-장애-및-네트워크-성능-저하&#34;&gt;서브 라인 장애 및 네트워크 성능 저하
&lt;/h3&gt;&lt;p&gt;측정 기간 동안 네트워크 연결은 항상 유지되었으며, 눈에 띄는 단절 현상은 없었습니다. 신규 입주형 광대역 회선이라 분배함 내부가 어수선하고, 가끔은 광모뎀 배선이나 전원 인터페이스 콘센트 위치를 조정하다 보니 간혹 기가 속도가 측정된 적도 있습니다.&lt;/p&gt;
&lt;p&gt;앞선 자료를 바탕으로 점검해 본 결과, 랜 케이블 모델과 광케이블 LAN 포트 속도를 분석했더니, 결국 범인은 랜 케이블 내부의 갈색 서브 와이어가 끊어진 것이었습니다&lt;/p&gt;
&lt;p&gt;설치 기사님이 크리스탈 헤드를 설치할 때 이 랜선에 조금 세게 힘을 가했고, 그 결과 한 선이 반쯤 끊어졌지만 완전히 끊어진 것은 아니었습니다. 이후 광모뎀 위치를 계속 조정하면서 위치를 옮기니 결국 완전히 끊어졌습니다.&lt;/p&gt;
&lt;h3 id=&#34;6가지-랜-케이블-8가닥-선의-기능-분석&#34;&gt;6가지 랜 케이블 8가닥 선의 기능 분석
&lt;/h3&gt;&lt;p&gt;여섯 종류의 네트워크 케이블은 TIA/EIA-568-B 표준을 따르며, 8개의 트위스트 페어 전선으로 구성되어 있으며, 색상 코딩은 다음과 같습니다:&lt;/p&gt;
&lt;p&gt;백귤 / 귤
백록 / 녹
흰색과 파란색 / 파란색
백갈색 / 갈색&lt;/p&gt;
&lt;p&gt;기가비트 이더넷(1000BASE-T) 표준 하에서, 이 8개의 선 중 4쌍의 선이 동시에 작동하며, 구체적인 역할 분담은 다음과 같습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;백오렌지와 오렌지 이 두 선(1&amp;amp;2)은 데이터를 전송(Tx+/-)하는 데 사용됩니다&lt;/li&gt;
&lt;li&gt;백록과 녹색의 이 선(3&amp;amp;6)은 데이터 수신(Rx+/-)에 사용됩니다&lt;/li&gt;
&lt;li&gt;백란과 남색의 이 선(4&amp;amp;5)과 백갈색과 갈색의 이 선(7&amp;amp;8)은 기가비트 이더넷에서는 원래 주 용도로 사용되지 않지만, 일부 고급 애플리케이션(예: 특정 PoE 전원 공급 또는 미래 기술 확장)에서 활성화될 수 있습니다. 반면 전통적인 100메가비트 네트워크에서는 1, 2, 3, 6번 선만 사용하는 것으로 충분합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;절단된-하위-링크가-네트워크-속도에-미치는-영향&#34;&gt;절단된 하위 링크가 네트워크 속도에 미치는 영향
&lt;/h3&gt;&lt;p&gt;위와 같은 상황에서 갈색의 부선(갈색 선 또는 갈색 흰색 선)이 끊어지면 이론적으로는 1Gbps 네트워크 환경에서 속도 저하가 발생할 수 있습니다. 왜냐하면 1Gbps 네트워크는 모든 네 쌍의 선이 동시에 양방향으로 데이터를 전송하여 최고 속도를 달성하기 때문입니다. 하지만 가정용 네트워크 장비에는 자동 협상 기능이 종종 존재하며, 케이블에 문제가 감지되면 정상적으로 작동하는 낮은 속도 모드, 즉 100Mbps 모드로 되돌아갑니다. 따라서 부선이 끊어져도 네트워크 연결은 유지되고 100Mbps 속도로 작동하는 이유가 바로 이것입니다.&lt;/p&gt;
&lt;p&gt;간단히 말해서, 하나의 갈색 보조 광섬유가 끊어진다고 해서 100메가 네트워크의 기본적인 작동에는 영향을 미치지 않지만, 기가비트 네트워크 환경에서는 네트워크 속도를 제한하는 중요한 요인이 될 수 있습니다. 심층적인 진단과 복구가 이루어져야 비로소 기가급 광섬유의 잠재력을 완전히 발휘할 수 있습니다. 이는 유사한 상황에 직면했을 때, 기본적인 연결에는 영향을 미치지 않는 것처럼 보이는 작은 결함이라 할지라도 네트워크 인프라의 잠재적인 문제를 간과해서는 안 된다는 점을 상기시켜 줍니다. 이러한 결함은 고속 네트워크 경험의 보이지 않는 장애물이 될 수 있기 때문입니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>WPF UI 스레드와 멈춤 문제 및 해결 방법</title>
        <link>https://ttf248.life/ko/p/wpf-ui-thread-and-freezing-issues-solutions/</link>
        <pubDate>Tue, 12 Mar 2024 07:12:21 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/wpf-ui-thread-and-freezing-issues-solutions/</guid>
        <description>&lt;p&gt;데스크톱 애플리케이션을 개발할 때, 특히 Windows Presentation Foundation(WPF) 프레임워크를 사용하여 리치 클라이언트 애플리케이션을 구축할 때는 애플리케이션의 원활성과 응답성을 보장하기 위해 사용자 인터페이스(UI) 스레드를 올바르게 처리하는 것이 매우 중요합니다. UI 스레드, 또는 메인 스레드는 창과 컨트롤 이벤트 처리, 레이아웃 계산 및 인터페이스 렌더링을 담당하는 핵심 스레드입니다. UI 요소와의 모든 상호 작용은 UI 스레드에서 실행되어야 하며, 이는 WPF는 물론 다른 대부분의 GUI 프레임워크가 따르는 기본 원칙입니다.&lt;/p&gt;
&lt;h2 id=&#34;ui-스레드가-무엇인가요&#34;&gt;UI 스레드가 무엇인가요?
&lt;/h2&gt;&lt;p&gt;WPF 애플리케이션 시작 시 UI 스레드는 운영체제에 의해 생성되고 애플리케이션의 주 창을 초기화합니다. 이는 애플리케이션 내에서 UI 구성 요소의 상태를 직접적으로 액세스하고 수정할 수 있는 유일한 스레드입니다. 즉, 버튼 클릭, 텍스트 상자 입력, 창 크기 변경과 같은 모든 사용자 상호 작용으로 발생하는 이벤트는 이 스레드 컨텍스트 내에서 처리됩니다. 동시에 WPF의 종속 속성 시스템, 데이터 바인딩 메커니즘 및 레이아웃 로직도 UI 스레드 위에서 동기적으로 실행됩니다.&lt;/p&gt;
&lt;h2 id=&#34;끊김-현상-및-원인&#34;&gt;끊김 현상 및 원인
&lt;/h2&gt;&lt;p&gt;UI 스레드가 장시간 점유되거나 차단될 때, 예를 들어 시간이 오래 걸리는 계산, 대량 데이터 로딩, 데이터베이스 쿼리 또는 기타 I/O 집약적인 작업을 수행할 때 발생합니다. 이로 인해 UI 스레드가 사용자 상호 작용 요청에 즉시 응답하지 못하고, 결과적으로 화면이 응답하지 않는(Freeze) 현상이 나타납니다. 흔히 “카통”이라고 불리는 이것은 사용자가 앱의 지연과 끊김을 명확하게 느낄 수 있으며, 심할 경우 &amp;ldquo;Application Not Responding&amp;rdquo;(ANR) 경고가 발생할 수도 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;ui-스레드의-두-가지-기본-규칙&#34;&gt;UI 스레드의 두 가지 기본 규칙
&lt;/h2&gt;&lt;p&gt;위와 같은 상황을 방지하기 위해 WPF 개발자는 다음 두 가지 주요 규칙을 준수해야 합니다&lt;/p&gt;
&lt;p&gt;UI 스레드에서 시간이 오래 걸리는 작업을 수행하지 마세요. UI 스레드를 멈추게 할 수 있는 작업은 가능한 한 백그라운드 스레드로 옮겨서 사용자 입력에 즉시 응답하고 화면 변경을 렌더링할 수 있도록 해야 합니다.
UI 스레드에서 직접 UI 요소를 업데이트하지 마세요. WPF의 보안 메커니즘 설계상, UI 요소 수정은 UI 스레드만 권한이 있습니다. 다른 스레드에서 직접 UI 상태를 변경하려고 하면 예외가 발생합니다. 따라서 백그라운드 스레드에서 계산이나 데이터 준비가 완료되더라도 적절한 크로스 스레드 통신 메커니즘을 통해 결과를 UI에 표시해야 합니다.&lt;/p&gt;
&lt;h2 id=&#34;비동기-프로그래밍-및-스레드-안전-업데이트-솔루션&#34;&gt;비동기 프로그래밍 및 스레드 안전 업데이트 솔루션
&lt;/h2&gt;&lt;p&gt;UI의 응답성을 유지하면서도 시간이 오래 걸리는 작업을 수행하기 위해 WPF는 개발자가 이 목표를 달성하도록 돕기 위한 다양한 비동기 프로그래밍 모델과 도구를 제공합니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;디스패처 객체: WPF의 디스패처 클래스는 작업 항목을 UI 스레드의 작업 큐에 배치하여 실행할 수 있습니다. &lt;code&gt;Dispatcher.Invoke&lt;/code&gt; 또는 &lt;code&gt;Dispatcher.BeginInvoke&lt;/code&gt; 메서드를 사용하여 백그라운드 스레드에서 안전하게 UI를 업데이트할 수 있습니다.&lt;/li&gt;
&lt;li&gt;C# 언어의 비동기 기능을 활용하면 &lt;code&gt;await&lt;/code&gt; 키워드를 사용하여 백그라운드 작업 완료를 기다리고, 완료 후 자동으로 UI 스레드로 돌아와서 이후 UI 업데이트 코드를 실행할 수 있습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;사례&#34;&gt;사례
&lt;/h2&gt;&lt;h3 id=&#34;ui를-업데이트하려면-dispatcherinvoke-메서드를-사용하세요&#34;&gt;UI를 업데이트하려면 &lt;code&gt;Dispatcher.Invoke&lt;/code&gt; 메서드를 사용하세요
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private void Button_Click(object sender, RoutedEventArgs e)
{
    // 假设这是一个耗时操作
    Task.Run(() =&amp;gt;
    {
        var result = LongRunningOperation(); // 这里是模拟一个耗时计算的方法
        
        // 当耗时操作完成后，在UI线程上更新UI
        Application.Current.Dispatcher.Invoke(() =&amp;gt;
        {
            LabelStatus.Text = $&amp;quot;计算结果: {result}&amp;quot;;
        });
    });
}

private string LongRunningOperation()
{
    // 模拟耗时操作
    Thread.Sleep(5000);
    return &amp;quot;已完成&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;asyncawait-키워드와-taskrun을-함께-사용하세요&#34;&gt;&lt;code&gt;async/await&lt;/code&gt; 키워드와 &lt;code&gt;Task.Run&lt;/code&gt;을 함께 사용하세요
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private async void Button_ClickAsync(object sender, RoutedEventArgs e)
{
    Button button = sender as Button;
    button.IsEnabled = false; // 防止用户重复点击

    try
    {
        // 开启后台任务
        var result = await Task.Run(() =&amp;gt; LongRunningOperation());

        // 在后台任务完成后，自动切换回UI线程更新UI
        LabelStatus.Text = $&amp;quot;计算结果: {result}&amp;quot;;
    }
    catch (Exception ex)
    {
        MessageBox.Show($&amp;quot;发生错误: {ex.Message}&amp;quot;);
    }
    finally
    {
        button.IsEnabled = true; // 重新启用按钮
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>GCC 버전 업그레이드로 인한 프로그램 충돌: 비표준 코드의 잠재적 위험</title>
        <link>https://ttf248.life/ko/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</link>
        <pubDate>Sun, 10 Mar 2024 23:19:06 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</guid>
        <description>&lt;p&gt;동일한 비즈니스 코드의 경우, 프로그램은 CentOS 7 환경에서 정상적으로 컴파일 및 실행되었지만, CentOS 8로 전환하고 최신 버전의 GCC를 사용하여 컴파일하면 프로그램이 충돌합니다. 주목할 점은 문제가 &lt;strong&gt;릴리스 모드&lt;/strong&gt;에서만 발생하며, &lt;strong&gt;디버그 모드&lt;/strong&gt;에서는 전혀 문제가 없다는 것입니다. 이와 같은 상황은 처음 경험했으며, 삼 일간의 조사 끝에 문제의 근본 원인을 찾았습니다.&lt;/p&gt;
&lt;h3 id=&#34;문제-파악&#34;&gt;문제 파악
&lt;/h3&gt;&lt;p&gt;일련의 점검을 거쳐 문제의 원인은 &lt;strong&gt;함수가 반환값을 갖지 못하는 것&lt;/strong&gt;으로 밝혀졌습니다. Release 모드에서는 GCC 최신 버전이 더 많은 최적화를 수행하는데, 이로 인해 명시적으로 반환값이 없는 함수 실행 과정에서 예상치 못한 로직이 발생하여 충돌을 일으켰습니다. 결론은 &lt;strong&gt;컴파일러 경고를 간과해서는 안 된다는 것입니다. 특히 기존 프로젝트에서는 일부 경고가 무시될 수도 있지만, 모든 경고를 차단하는 것은 피해야 합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;환경-설명&#34;&gt;환경 설명
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CentOS 7 GCC 버전:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39)
Copyright © 2015 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CentOS 8 GCC 버전:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 8.5.0 20210514 (Red Hat 8.5.0-21)
Copyright (C) 2018 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;붕괴-현상&#34;&gt;붕괴 현상
&lt;/h3&gt;&lt;p&gt;프로그램 충돌 스택을 분석하는 과정에서 다음과 같은 스택 정보를 확인했습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[New LWP 1385902]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib64/libthread_db.so.1&amp;quot;.
Core was generated by `./pstack_main`.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007ffe894b4420 in ?? ()
(gdb) bt
#0  0x00007ffe894b4420 in ?? ()
#1  0x00000000004008e9 in main ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 스택은 직관적이지 않아 보이고, 충돌 함수의 스택 정보가 &lt;code&gt;??&lt;/code&gt;로 표시되어 있어 문제 해결이 더욱 복잡해졌다&lt;/p&gt;
&lt;h3 id=&#34;코드-예시&#34;&gt;코드 예시
&lt;/h3&gt;&lt;p&gt;문제 이해를 돕기 위해, 오류 재현을 위한 최소 코드 예제는 다음과 같습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int test() {
    std::cout &amp;lt;&amp;lt; &amp;quot;1&amp;quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    test();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;해당 코드의 &lt;code&gt;test()&lt;/code&gt; 함수는 명시적으로 값을 반환하지 않음에도 불구하고, 반환 타입이 &lt;code&gt;int&lt;/code&gt;로 선언되어 있습니다. C++ 규격에 따르면 &lt;code&gt;int&lt;/code&gt; 타입으로 선언된 함수는 반드시 값을 반환해야 하며, 그렇지 않으면 정의되지 않은 동작을 초래할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;컴파일-경고&#34;&gt;컴파일 경고
&lt;/h3&gt;&lt;p&gt;우리 프로젝트에서 CMake 스크립트는 많은 컴파일 시 경고를 비활성화했으며, 그 중에는 다음과 같은 경고 메시지도 포함되어 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/root/pstack/main.cpp: In function ‘int test()’:
/root/pstack/main.cpp:7:1: warning: no return statement in function returning non-void [-Wreturn-type]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 경고는 &lt;code&gt;test()&lt;/code&gt; 함수가 값을 반환하지 않는다는 것을 의미하며, 이것이 문제의 근원입니다. 높은 버전의 GCC(예: 8.5.0)는 코드를 최적화할 때 이러한 정의되지 않은 동작에 대해 불안정한 최적화를 수행하여 프로그램 충돌을 일으킬 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;어셈블리-코드-차이&#34;&gt;어셈블리 코드 차이
&lt;/h3&gt;&lt;p&gt;GCC 컴파일러 최적화 동작의 차이를 설명하기 위해, 우리는 서로 다른 버전의 GCC가 생성한 어셈블리 코드를 비교했습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;GCC 4.8.5가 생성한 어셈블리 코드:&lt;/p&gt;
&lt;p&gt;어셈블리 코드는 다소 장황하며 표준 출력 스트림(예: &lt;code&gt;std::cout&lt;/code&gt;) 처리를 위한 로직을 포함하고 있습니다. 이는 컴파일러가 더 보수적인 최적화를 수행했으며, &lt;code&gt;test()&lt;/code&gt; 함수에서 누락된 반환값 문제에 대한 과도한 최적화를 하지 않았음을 시사합니다. 아마도 이로 인해 프로그램이 충돌하는 것을 피했을 것입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GCC 8.5.0에서 생성된 어셈블리 코드:&lt;/p&gt;
&lt;p&gt;새 버전의 GCC는 더 많은 최적화를 수행하여 코드 양을 줄였습니다. 하지만 이러한 최적화로 인해 반환 값이 없는 함수의 실행 시 동작이 불확실해져 프로그램이 충돌할 수 있습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;결론&#34;&gt;결론
&lt;/h3&gt;&lt;p&gt;이번 문제 해결 과정을 통해, C++에서 &lt;strong&gt;함수 반환 값은 명시적이어야 한다&lt;/strong&gt;는 것을 깊이 인식하게 되었습니다. 특히 함수가 &lt;code&gt;int&lt;/code&gt;로 선언된 경우 반드시 반환 값을 제공해야 합니다. 구 버전 컴파일러를 사용하는 프로젝트의 경우, 최신 버전 GCC로 업그레이드하면 더 많은 최적화와 엄격한 경고 메커니즘을 마주할 수 있습니다. 따라서 컴파일 시 &lt;strong&gt;모든 경고를 숨기지 말고&lt;/strong&gt;, 함수 반환 값, 타입 매칭 등과 같은 일반적인 문제에 대해 선택적으로 처리하는 것을 권장합니다.&lt;/p&gt;
&lt;p&gt;결국, &lt;code&gt;test()&lt;/code&gt; 함수에 반환값을 추가함으로써 문제가 해결되었고 프로그램이 정상적으로 작동하게 되었습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>VMware 가상 머신 CPU 리소스 사용량 이상</title>
        <link>https://ttf248.life/ko/p/vmware-virtual-machine-cpu-resource-usage-anomaly/</link>
        <pubDate>Sun, 10 Mar 2024 22:14:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/vmware-virtual-machine-cpu-resource-usage-anomaly/</guid>
        <description>&lt;p&gt;로컬 머신에 Windows 버전의 업무 시스템이 배포되어 있으며, CPU 자원 사용량은 약 5% 정도입니다. VMware에 설치된 CentOS8에서 Linux 버전의 업무 시스템을 배포했는데, 자원 사용량이 비정상적입니다.&lt;/p&gt;
&lt;h2 id=&#34;문제-설명&#34;&gt;문제 설명
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;호스트 시스템: win10 기업 버전&lt;/li&gt;
&lt;li&gt;vmware：17.5&lt;/li&gt;
&lt;li&gt;가상 머신: CentOS 8&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;가상 머신 리소스 할당은 &lt;code&gt;4C8GB&lt;/code&gt;로 설정하고, 비즈니스 시스템을 시작했습니다. 비즈니스 시스템은 가상 머신 Linux 시스템에 배포되었으며, 내부 top 명령어를 통해 시스템 리소스 사용량을 관찰한 결과 CPU 사용량은 높지 않았습니다. 하지만 외부 Windows 시스템에서 작업 관리자를 통해 확인했을 때 CPU 리소스 사용량이 매우 높았고, 프로세스를 확인해 보니 VMware 프로세스가 CPU 리소스를 많이 사용하고 있었습니다.&lt;/p&gt;
&lt;p&gt;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+
|         Windows           |
|                           |
|   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+  |
|   |      VMware        |  |
|   |      Program       |  |
|   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+  |
|                           |
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+&lt;/p&gt;
&lt;h2 id=&#34;지식점&#34;&gt;지식점
&lt;/h2&gt;&lt;p&gt;이 문제의 원인 분석은 순조롭지 않았는데, 그 이유는 도화선이 비즈니스 시스템 자체가 아니라 가상 머신 자체의 문제였기 때문이다. 어떻게 하면 일반적인 비즈니스 코드에서 벗어나 시스템 부하로 사고를 전환하고, 부하 데이터의 이상 현상을 통해 소프트 인터럽트를 찾아내어 결국 핵심에 다다를 수 있을까? 무엇이 VMware 소프트 인터럽트의 효율성을 저해하는 것일까? 본 논문에서는 먼저 각 지식 포인트를 설명하고 마지막으로 해결책을 제시한다.&lt;/p&gt;
&lt;h3 id=&#34;hyper-v&#34;&gt;hyper-v
&lt;/h3&gt;&lt;p&gt;윈도우 운영 체제의 가상화 기술이 중대한 변화를 겪었습니다. 마이크로소프트가 WSL을 처음 출시했을 때 Hyper-V 서비스를 활성화하면 VMware 가상 머신을 동시에 사용할 수 없었습니다. 이후 버전에서 VMware는 Hyper-V 서비스와 호환되게 되었습니다.&lt;/p&gt;
&lt;h3 id=&#34;시스템-부하&#34;&gt;시스템 부하
&lt;/h3&gt;&lt;p&gt;리눅스 시스템에서 &amp;ldquo;로드(load)&amp;ldquo;는 실행 중이거나 실행을 기다리는 프로세스의 수를 의미합니다. 로드는 일반적으로 1분, 5분, 15분 동안의 실행 대기열에 있는 평균 프로세스 수를 나타내는 세 자리 숫자로 표시됩니다. 이러한 숫자는 &amp;ldquo;uptime&amp;rdquo; 명령이나 &amp;ldquo;top&amp;rdquo; 명령을 실행하여 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;구체적으로 말씀드리면, 이 세 개의 숫자는 각각 다음을 의미합니다:&lt;/p&gt;
&lt;p&gt;1분간의 로드(load): 시스템이 지난 1분 동안 실행 중인 프로세스들의 평균 수량입니다
과거 5분 동안의 평균 실행 프로세스 수입니다
지난 15분 동안 시스템에서 실행 중인 프로세스 평균 수입니다&lt;/p&gt;
&lt;p&gt;부하의 의미는 시스템에서 실행을 기다리는 프로세스 수입니다. 이 숫자가 시스템의 논리 CPU 수보다 높으면 시스템 부하가 높다는 것을 나타내며, 많은 프로세스가 프로세서 리소스를 기다리고 있다는 뜻입니다. 부하 정도와 시스템 구성 및 성능에 따라 시스템이 느려지거나 응답하지 않을 수 있습니다.&lt;/p&gt;
&lt;p&gt;이상적으로는, 부하가 시스템의 논리 CPU 수 범위 내에 유지되어야 시스템 성능을 최적화할 수 있습니다. 부하가 지속적으로 CPU 수보다 높다면, 시스템 내 프로세스를 추가적으로 분석하여 높은 부하를 유발하는 원인을 파악하고, 시스템 리소스 할당을 조정하거나 프로세스 실행 방식을 최적화하기 위한 적절한 조치를 취해야 합니다.&lt;/p&gt;
&lt;h3 id=&#34;mpstat-로드-분석&#34;&gt;mpstat 로드 분석
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;mpstat&lt;/code&gt; 명령은 평균 로드, CPU 사용률, 인터럽트 및 컨텍스트 스위치와 같은 단일 또는 여러 프로세서의 다양한 정보를 보고하는 데 사용됩니다. &lt;code&gt;sysstat&lt;/code&gt; 패키지에서 &lt;code&gt;mpstat&lt;/code&gt;은 시스템 부하를 분석하는 데 유용한 도구입니다. 다음은 &lt;code&gt;mpstat&lt;/code&gt;을 사용하여 부하를 분석하는 단계입니다.&lt;/p&gt;
&lt;p&gt;설치 sysstat
시스템에 &lt;code&gt;sysstat&lt;/code&gt;이 설치되어 있지 않다면, 시스템에 적합한 패키지 관리 도구를 사용하여 설치할 수 있습니다&lt;/p&gt;
&lt;p&gt;mpstat 실행
&lt;code&gt;mpstat&lt;/code&gt; 명령어를 사용하여 CPU 사용률과 부하를 확인합니다. 기본적으로 &lt;code&gt;mpstat&lt;/code&gt;는 CPU 사용률의 평균값을 매초마다 표시합니다. 출력 빈도를 조정하려면 시간 간격을 지정할 수 있습니다. 예를 들어, &lt;code&gt;mpstat -P ALL 2&lt;/code&gt; 명령어를 사용하면 매초마다 한 번씩 실행되며, &lt;code&gt;irq&lt;/code&gt;는 리소스 점유를 나타냅니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```shell
01:32:33 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
01:32:35 PM  all    0.00    0.00    0.26    0.00    3.73    0.26    0.00    0.00    0.00   95.76
01:32:35 PM    0    0.00    0.00    0.51    0.00    3.57    0.00    0.00    0.00    0.00   95.92
01:32:35 PM    1    0.00    0.00    0.00    0.00    3.59    0.51    0.00    0.00    0.00   95.90
01:32:35 PM    2    0.00    0.00    0.00    0.00    4.15    0.00    0.00    0.00    0.00   95.85
01:32:35 PM    3    0.00    0.00    0.52    0.00    3.61    0.52    0.00    0.00    0.00   95.36
```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;분석 결과 출력
mpstat 출력에는 각 CPU의 사용률과 시스템의 평균 부하가 포함됩니다. 평균 부하와 각 CPU의 사용률에 특히 주의를 기울이면 시스템의 부하 상태를 파악하는 데 도움이 됩니다. 부하가 높으면 어떤 프로세스가 원인인지 추가 분석하고 성능 병목 현상이 있는지 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;다른 도구와 결합하세요:
&lt;code&gt;mpstat&lt;/code&gt; 외에도 &lt;code&gt;sar&lt;/code&gt;, &lt;code&gt;pidstat&lt;/code&gt;, &lt;code&gt;iostat&lt;/code&gt; 등의 도구를 사용하여 시스템 성능을 종합적으로 분석할 수 있습니다. 다양한 도구의 출력을 결합하면 시스템 부하를 보다 포괄적으로 파악하고 성능 문제의 근본 원인을 찾아낼 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;중단&#34;&gt;중단
&lt;/h3&gt;&lt;p&gt;여기서는 내용을 너무 자세히 설명하지 않겠습니다
추천: &lt;a class=&#34;link&#34; href=&#34;https://www.codedump.info/post/20200522-sgfap-softirq/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;애플리케이션 개발자를 위한 시스템 가이드 CPU편 - 소프트 인터럽트&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;잦은 소프트웨어 인터럽트 발생은 시스템 부하에도 반영된다&lt;/p&gt;
&lt;h2 id=&#34;문제-해결&#34;&gt;문제 해결
&lt;/h2&gt;&lt;p&gt;CPU 관점에서만 문제를 파악하기 어렵다는 점을 고려할 때, 시스템에 이상이 발생했을 가능성을 의심해 볼 시점일까요? Linux 운영체제의 부하가 과도하여 VMware가 지나치게 많은 CPU 자원을 사용하고 있을 수도 있습니다. &lt;code&gt;mpstat&lt;/code&gt;를 사용하여 로컬 가상 머신을 분석한 결과, &lt;code&gt;irq&lt;/code&gt; 점유율이 비정상적으로 높았고 단일 코어는 약 25%에 달했습니다. 정상적인 상황에서는 비즈니스 프로세스를 시작하지 않은 상태에서 &lt;code&gt;irq&lt;/code&gt; 점유율은 약 5% 정도여야 합니다.&lt;/p&gt;
&lt;p&gt;그룹 내 동료 개발 환경에서 그의 CentOS 7은 VMware에 배포되었으며, 리소스 사용량은 정상적으로 표시됩니다. 반면에 상하이의 개발 환경에서는 동일하게 VMware이지만 호스트 CPU 리소스 상황을 직접 관찰할 수 없습니다. 이때 우리는 VMware 가상 머신, Linux 운영 체제 및 GCC 버전을 포함한 여러 변수를 고려해야 합니다.&lt;/p&gt;
&lt;p&gt;전환하여 테스트 환경을 분석해 보니, 선전의 테스트 환경은 물리 머신에 배포되어 있고, 오래된 버전 GCC 컴파일 서비스가 실행 중이며 CentOS 8 위에서 운영되고 있습니다. 흥미롭게도, 선전 환경에서는 &lt;code&gt;irq&lt;/code&gt; 점유량이 모두 정상입니다.&lt;/p&gt;
&lt;p&gt;문제점을 파악하기 위해 GCC 최신 버전으로 컴파일된 프로그램을 선전 환경에 배포하여 테스트한 결과, 모두 정상 작동하는 것으로 나타났습니다&lt;/p&gt;
&lt;p&gt;문제는 더 명확해지는 듯하고, 우리는 운영체제에 문제가 있는 것은 아닌지 의심하기 시작했다. 결국 CentOS 8은 더 이상 공식 지원을 받지 못한다. 하지만 순수한 CentOS 7과 CentOS 8을 다시 배포해도 문제는 여전히 존재한다.&lt;/p&gt;
&lt;p&gt;지금, 우리는 유일한 불확실 요소인 VMware 가상화 소프트웨어를 의심하기 시작했습니다. 갑자기 아이디어가 떠올랐습니다. Hyper-V 기술은 어떨까요? 혹시 이전에 Hyper-V가 활성화되었지만 완전히 종료되지 않아 이런 문제가 발생했을 수도 있습니다? 결국, 소프트 인터럽트도 가상화 소프트웨어를 통해 구현되니까요. 서로 다른 가상화 기술에 버그는 없는 걸까요? 이러한 문제들은 깊이 생각하고 조사할 가치가 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;결론&#34;&gt;결론
&lt;/h2&gt;&lt;p&gt;마이크로소프트 공식 매뉴얼에 따르면, 로컬 Hyper-V 서비스를 완전히 종료한 후 VMware가 호스트에서 정상적으로 복구되는 것을 확인했습니다. 이렇게 해서 문제 해결이 마침내 순조롭게 진행되었습니다. 처음 설명했듯이 이 경험은 굴곡지고 고되었으며 종합적인 분석과 판단이 필요했습니다. 또한, 이번에 처음으로 문제를 진단하고 가상 머신 수준까지 위치를 특정하게 되었습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Disable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V-Hypervisor
bcdedit /set hypervisorlaunchtype off
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/application-management/virtualization-apps-not-work-with-hyper-v&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/application-management/virtualization-apps-not-work-with-hyper-v&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43; 프로그래밍의 함정: `std::map` 오용으로 인한 프로그램 충돌 상세 분석</title>
        <link>https://ttf248.life/ko/p/cpp-programming-traps-std-map-crash-details/</link>
        <pubDate>Sun, 10 Mar 2024 22:03:06 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/cpp-programming-traps-std-map-crash-details/</guid>
        <description>&lt;p&gt;C++ 프로그래밍에서 &lt;code&gt;std::map&lt;/code&gt; 컨테이너를 잘못 사용하면 프로그램이 충돌할 수 있습니다. 대괄호 연산자를 사용하여 존재하지 않는 키에 접근하려고 하면 자동으로 빈 요소가 추가됩니다. 이 오해를 자세히 분석하고 예제 코드를 통해 잠재적인 위험을 보여드리겠습니다.&lt;/p&gt;
&lt;p&gt;저장하는 값이 단순한 값이라면 문제가 없지만, 포인터를 저장하면 문제가 발생할 수 있습니다. 왜냐하면 포인터는 주소이고, 초기화되지 않으면 해당 주소가 불확실해져 프로그램이 충돌할 수 있기 때문입니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;C++ 표준 라이브러리에서 &lt;code&gt;std::map&lt;/code&gt;은 키(key)를 기준으로 오름차순으로 요소를 저장하는 연관 컨테이너이며, 효율적인 키워드 검색 기능을 제공합니다. 하지만 초보 개발자는 &lt;code&gt;std::map&lt;/code&gt;의 대괄호 연산자 &lt;code&gt;[]&lt;/code&gt;의 동작 방식에 대한 이해 부족으로 어려움을 겪을 수 있습니다. 실제로 &lt;code&gt;[]&lt;/code&gt;를 사용하여 존재하지 않는 키에 접근하면 &lt;code&gt;std::map&lt;/code&gt;은 새로운 키-값 쌍을 삽입하고, 기본 생성자를 사용하여 해당 키에 해당하는 값 타입이 초기화됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int main() {
    std::map&amp;lt;std::string, int&amp;gt; myMap;
    
    // 错误的用法：假设这里试图访问一个不存在的键并认为会得到0
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for &#39;nonexistent_key&#39;: &amp;quot; &amp;lt;&amp;lt; myMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;

    // 实际上，上述行代码创建了一个新的键值对，其中值被默认初始化为int的默认值（通常是0）
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 코드 조각은 프로그램 충돌을 직접적으로 유발하지는 않지만, 이러한 암묵적인 삽입 동작은 특정 상황에서 예상치 못한 부작용을 초래할 수 있습니다. 예를 들어 리소스 누수나 예측 불가능한 상태 변경이 발생할 수 있습니다. 더 나쁜 것은 다중 스레드 환경에서 초기화되지 않은 메모리 영역에 동시에 접근하면 프로그램 충돌로 이어질 수도 있습니다.&lt;/p&gt;
&lt;p&gt;이러한 문제가 발생하는 것을 방지하기 위해 &lt;code&gt;std::map::find()&lt;/code&gt; 또는 &lt;code&gt;std::map::count()&lt;/code&gt; 메서드를 사용하여 키가 존재하는지 확인하거나, &lt;code&gt;std::map::insert()&lt;/code&gt;를 사용하여 명시적으로 요소를 삽입하는 것이 좋습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::map&amp;lt;std::string, int&amp;gt; safeMap;
if (safeMap.count(&amp;quot;nonexistent_key&amp;quot;) == 0) {
    std::cout &amp;lt;&amp;lt; &amp;quot;Key does not exist.&amp;quot; &amp;lt;&amp;lt; std::endl;
} else {
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for existing key: &amp;quot; &amp;lt;&amp;lt; safeMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;
}

// 或者明确插入一个键值对，指定初始值
safeMap.insert({ &amp;quot;new_key&amp;quot;, 0 });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;만약 map 컨테이너 내부에 저장된 객체가 포인터 타입이라면, 자동 삽입 동작은 초기화되지 않은 포인터를 저장하며, 이 포인터에 대한 어떠한 작업도 프로그램 충돌을 야기할 수 있습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>pstack으로 프로세스 멈춤 확인</title>
        <link>https://ttf248.life/ko/p/pstack-troubleshooting-process-hang/</link>
        <pubDate>Sat, 24 Feb 2024 23:55:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/pstack-troubleshooting-process-hang/</guid>
        <description>&lt;p&gt;소프트웨어 개발 및 운영 환경에서 프로세스 응답 없음 현상이 자주 발생하는데, 이로 인해 시스템 성능 저하나 서비스 중단이 발생할 수 있습니다. 본 문서에서는 pstack 도구를 사용하여 프로세스 응답 없음 문제를 진단하고, 프로세스의 스택 정보를 분석하여 문제 원인을 파악하고 해결하는 방법을 소개합니다.&lt;/p&gt;
&lt;p&gt;배경: 위험 관리 시스템 하위 서비스가 응답하지 않는 상태로 멈춰 위험 관리 서비스를 사용할 수 없게 되었습니다. 서비스 가용성 모니터링이 부족하여 프로세스가 멈춘 상황을 즉시 파악하지 못했고, 이로 인해 시스템이 사용할 수 없게 되었습니다.&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;프로세스 응답 없음은 프로세스가 응답을 멈춘 상태이지만 종료되지 않은 것을 의미합니다. 이는 데드락, 리소스 고갈, 예외 등 다양한 원인으로 발생할 수 있습니다. 이러한 문제를 해결하기 위해 pstack 도구를 사용하여 프로세스의 스택 정보를 분석하고 문제의 근본 원인을 파악할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;단계&#34;&gt;단계
&lt;/h2&gt;&lt;p&gt;pstack은 일반적으로 gdb(GNU 디버거)와 함께 제공되는 유용한 도구입니다. 다음 명령을 통해 설치할 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt-get install gdb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;프로세스 ID 획득: 먼저, 응답하지 않는 프로세스의 프로세스 ID(PID)를 얻어야 합니다. ps 명령어를 사용하여 모든 프로세스를 나열하고 문제 해결이 필요한 프로세스 ID를 찾을 수 있습니다.
pstack 도구를 사용하여 프로세스 스택을 분석하고, 일단 프로세스 ID를 얻으면 pstack 도구를 사용하여 해당 프로세스의 스택 정보를 가져올 수 있습니다. 다음 명령어를 실행하세요:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pstack &amp;lt;PID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 프로세스의 스택 정보를 출력하여 현재 실행 중인 함수 호출 시퀀스를 표시합니다. 이러한 정보를 분석하면 프로세스가 멈춘 위치를 파악하고 문제를 진단할 수 있습니다.&lt;/p&gt;
&lt;p&gt;스택 정보를 분석하면 프로세스가 멈추는 원인을 파악할 수 있습니다. 데드락, 무한 루프 또는 기타 예외 상황이 발견될 수 있습니다. 구체적인 상황에 따라 잠금을 해제하거나 코드 로직을 수정하는 등의 조치를 취하십시오.&lt;/p&gt;
&lt;h2 id=&#34;사례&#34;&gt;사례
&lt;/h2&gt;&lt;p&gt;간단한 데모인데, 메인 함수가 시작된 후 서브 스레드를 새로 만들고 실제 실행 함수에 들어가면 무한 루프에 빠져 프로그램이 정상적으로 종료되지 않고 멈춰버리는 상태입니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cmake_minimum_required(VERSION 3.0.0)
project(pstack_main VERSION 0.1.0 LANGUAGES C CXX)

include(CTest)
enable_testing()

# 查找线程库
find_package(Threads REQUIRED)

add_executable(pstack_main main.cpp)

# 链接线程库
target_link_libraries(pstack_main PRIVATE Threads::Threads)

set(CPACK_PROJECT_NAME ${PROJECT_NAME})
set(CPACK_PROJECT_VERSION ${PROJECT_VERSION})
include(CPack)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;
#include &amp;lt;chrono&amp;gt;

void infiniteLoop() {
    while (true) {
        // 主线程进入死循环
    }
}

int main() {
    std::thread thread(infiniteLoop); // 创建一个线程，执行死循环函数
    thread.join(); // 等待线程结束
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;프로그램을 시작하고 pstack 결과를 실행합니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Thread 2 (Thread 0x7eff3619b700 (LWP 1315017)):
#0  infiniteLoop () at /root/pstack/main.cpp:6
#1  0x0000000000402ca9 in std::__invoke_impl&amp;lt;void, void (*)()&amp;gt; (__f=@0x2260eb8: 0x4029a6 &amp;lt;infiniteLoop()&amp;gt;) at /usr/include/c++/8/bits/invoke.h:60
#2  0x0000000000402b02 in std::__invoke&amp;lt;void (*)()&amp;gt; (__fn=@0x2260eb8: 0x4029a6 &amp;lt;infiniteLoop()&amp;gt;) at /usr/include/c++/8/bits/invoke.h:95
#3  0x0000000000403150 in std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt;::_M_invoke&amp;lt;0ul&amp;gt; (this=0x2260eb8) at /usr/include/c++/8/thread:244
#4  0x0000000000403126 in std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt;::operator() (this=0x2260eb8) at /usr/include/c++/8/thread:253
#5  0x000000000040310a in std::thread::_State_impl&amp;lt;std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt; &amp;gt;::_M_run (this=0x2260eb0) at /usr/include/c++/8/thread:196
#6  0x00007eff36bceb23 in execute_native_thread_routine () from /lib64/libstdc++.so.6
#7  0x00007eff36ea91ca in start_thread () from /lib64/libpthread.so.0
#8  0x00007eff361d58d3 in clone () from /lib64/libc.so.6
Thread 1 (Thread 0x7eff372e1740 (LWP 1315016)):
#0  0x00007eff36eaa6cd in __pthread_timedjoin_ex () from /lib64/libpthread.so.0
#1  0x00007eff36bceda7 in std::thread::join() () from /lib64/libstdc++.so.6
#2  0x00000000004029d2 in main () at /root/pstack/main.cpp:13
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;볼 수 있듯이, 프로세스가 멈춘 이유는 무한 루프 때문입니다. 메인 스레드가 무한 루프에 진입하고, 서브 스레드가 종료되지 않아 프로세스가 멈춥니다.&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
