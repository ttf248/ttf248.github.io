<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>문제 해결 on 향숙의 수첩</title>
        <link>https://blog.ttf248.life/ko/tags/%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0/</link>
        <description>Recent content in 문제 해결 on 향숙의 수첩</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ko</language>
        <lastBuildDate>Wed, 28 May 2025 09:47:38 +0800</lastBuildDate><atom:link href="https://blog.ttf248.life/ko/tags/%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>프로토콜 버퍼 기본값 함정: 기본값이 비즈니스 로직의 숨겨진 살인자</title>
        <link>https://blog.ttf248.life/ko/p/protobuf-zero-value-traps/</link>
        <pubDate>Thu, 20 Feb 2025 15:26:51 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/protobuf-zero-value-traps/</guid>
        <description>&lt;p&gt;미국 주식 시장은 세 가지 거래 시간대로 나뉘는데, 전시장, 장중, 장후가 있습니다. 데이터 인터페이스는 가능한 한 대역폭을 절약하기 위해 최초에는 전체 데이터를 전송하고, 이후부터는 모든 필드를 증분 방식으로 푸시합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;최적의 방안을 안 쓰는 이유는 무엇인가요? 여러 프로젝트 그룹에 영향을 미치고, 일부는 이미 오래전에 배포되었기 때문입니다. 저희 쪽은 새로 연결하는 입장이므로 최대한 호환성을 고려할 수밖에 없습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;일련의-문제&#34;&gt;일련의 문제
&lt;/h2&gt;&lt;p&gt;초록만 보면 별다른 문제 없어 보이지만, 시스템 아키텍처에 문제가 유입되면서 일련의 문제가 발생했다. 막 지난 문제를 해결하려니 또 다른 문제가 생겼는데, 이 문제는 이전 문제 때문에 생긴 것이다.&lt;/p&gt;
&lt;h3 id=&#34;거래-시간-식별-불가&#34;&gt;거래 시간 식별 불가
&lt;/h3&gt;&lt;p&gt;알려진 디스크 상태는 __INLINE_CODE_0__BOLD_2&lt;code&gt;零&lt;/code&gt;이 기본값인지, 실제 비즈니스 값인지를 나타냅니다&lt;/p&gt;
&lt;p&gt;일반적인 이해로, 0을 받을 때마다 이 0이 새로운 시세 설정 값인지, 아니면 protobuf의 기본값인지 판단하기 어렵습니다&lt;/p&gt;
&lt;h3 id=&#34;선택-사항-도입&#34;&gt;선택 사항 도입
&lt;/h3&gt;&lt;p&gt;Since protobuf release 3.15, proto3 supports using the optional keyword (just as in proto2) to give a scalar field presence information&lt;/p&gt;
&lt;p&gt;조 내 통신 프로토콜은 &lt;code&gt;protobuf&lt;/code&gt;BOLD_3&lt;code&gt;optional&lt;/code&gt; 关键字。懂的都理解，由于从底层开始引入 &lt;code&gt;protobuf&lt;/code&gt;을 기반으로 하며, 프로젝트 하위 계층이 정적 라이브러리 방식으로 배포되어 전체 컴파일 링크를 업그레이드해야 하는데, 이 비용은 매우 높습니다&lt;/p&gt;
&lt;h3 id=&#34;gcc-버전-문제&#34;&gt;GCC 버전 문제
&lt;/h3&gt;&lt;p&gt;어떻게든 대안을 마련했는데, 하위에서 두 가지 다른 버전을 출시하여 최대한 &lt;code&gt;protobuf&lt;/code&gt; 新版本的编译依赖传播。但是在编译的时候，发现 &lt;code&gt;gcc&lt;/code&gt; 版本太低，不支持 &lt;code&gt;protobuf&lt;/code&gt;의 새로운 기능을 제어하려고 합니다&lt;/p&gt;
&lt;p&gt;팀 내에서 주로 사용되는 서버 유형은 CentOS 7, CentOS 8입니다. CentOS 7의 기본 버전이 7.4 이상이기 때문에 CentOS 7을 지원하지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=82461&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Bug 82461 - [7 Regression] Temporary required for brace-initializing (non-literal-type) member variable&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;최종적으로 관련 서비스 배포 및 컴파일 서버를 CentOS 8로 옮겨 이 문제를 해결했습니다&lt;/p&gt;
&lt;h2 id=&#34;합리적-열거&#34;&gt;합리적 열거
&lt;/h2&gt;&lt;p&gt;전체 문제를 되돌아보면, 사실 더 간단하고 효율적인 해결책이 있습니다. 열거형의 정의를 0부터 시작하는 대신 1부터 시작하도록 조정하면 기본값과 비즈니스 값을 효과적으로 구별하여 위에서 언급한 일련의 번거로움을 피할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;왜-1부터-시작하는-것이-더-합리적일까요&#34;&gt;왜 1부터 시작하는 것이 더 합리적일까요?
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 내에서, 열거형의 기본값은 항상 0으로 고정됩니다. 만약 의미 있는 비즈니스 값을 0으로 정의한다면(예: &amp;ldquo;판 중&amp;rdquo;), 증분 푸시 시 비즈니스 측에서는 수신된 0이 비즈니스 값인지 아니면 초기화되지 않은 기본값인지 판단할 수 없습니다. 하지만 열거형을 1부터 시작하여 정의하면, 0은 무의미한 기본값 또는 &amp;ldquo;알 수 없음&amp;rdquo; 상태로 유지될 수 있으며, 문제는 해결됩니다.&lt;/p&gt;
&lt;p&gt;제안된 방법:&lt;/p&gt;
&lt;p&gt;프로토콜 버퍼 열거형을 설계할 때 항상 0을 무의미한 기본값으로 정의하십시오
실제 비즈니스 값을 1부터 할당하여 기본값 0과 구분합니다&lt;/p&gt;
&lt;p&gt;이 작은 조정으로 우리는 거래 시간대 식별 문제를 해결했을 뿐만 아니라, 향후 프로토콜 설계에 귀중한 교훈을 얻었습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>백그라운드 서비스 TCP 통신 이상 점검</title>
        <link>https://blog.ttf248.life/ko/p/backend-service-tcp-communication-troubleshooting/</link>
        <pubDate>Fri, 14 Feb 2025 22:54:13 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/backend-service-tcp-communication-troubleshooting/</guid>
        <description>&lt;p&gt;비즈니스 모델: 백엔드 서비스는 TCP를 통해 그룹의 호가 게이트웨이와 연결을 맺습니다. 각 연결 시, 먼저 인증 요청을 보내고 이후 지속적으로 하트비트 패킷을 전송하여 연결 상태를 유지합니다.
그러나 어느 날, 서비스 연결 해제 경고 메시지를 받았다. 꼼꼼히 로그를 확인한 결과, 백엔드 서비스는 계속해서 하트비트를 전송하고 있었지만 상대방은 전혀 응답하지 않았음에도 불구하고 연결은 끊어지지 않았다.&lt;/p&gt;
&lt;h2 id=&#34;현장-설명&#34;&gt;현장 설명
&lt;/h2&gt;&lt;p&gt;원래 회사에서 야근하며 프로젝트 진행을 추진 중이었는데, 업무 그룹 채팅방에 갑자기 경고 메시지가 떴다. 처음에는 예전 문제라고 생각했다. 네트워크 타임아웃으로 인해 하트비트 전송이 실패해서 서비스 연결이 끊어진 것 같았다. 하지만 로그를 자세히 확인해 보니 실제 상황은 그렇지 않았다. 백엔드에서 인증 로그인 메시지를 보냈지만 응답을 받지 못했고, 동시에 하트비트는 계속 전송되었지만 상대방은 어떠한 하트비트 데이터도 반환하지 않았다. 로그를 심층적으로 분석한 결과 다음과 같은 몇 가지 주요 문제가 드러났다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;인가 메시지 응답 없음: 상대방 시스템이 재시동 중일 가능성이 높으며, 이로 인해 인가 메시지가 적시에 처리되지 못했을 수 있습니다&lt;/li&gt;
&lt;li&gt;승인되지 않은 상태에서 하트비트 데이터를 전송하는 문제는 프로그램 로직의 결함 때문입니다. 하트비트 전송 함수가 연결 상태만 확인하고, 승인 상태를 확인하지 않아 판단 로직에 오류가 있었습니다.&lt;/li&gt;
&lt;li&gt;서비스 연결 해제 실패: 서비스가 연결을 끊을 수 있다면, 재연결 메커니즘이 작동하여 인증 메시지를 다시 보낼 수 있습니다&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;현재 해결해야 할 마지막 문제, 즉 서비스 연결 해제 실패 원인을 파악하기 위해 보다 면밀한 점검이 필요합니다&lt;/p&gt;
&lt;h2 id=&#34;네트워크-데이터-패킷-분석&#34;&gt;네트워크 데이터 패킷 분석
&lt;/h2&gt;&lt;p&gt;네트워크 데이터 패킷을 획득하여 추가 분석합니다&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/backend-service-tcp-communication-troubleshooting/20250220151952.png&#34;
	width=&#34;1126&#34;
	height=&#34;202&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;tcpdump&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;557&#34;
		data-flex-basis=&#34;1337px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;데이터를 분석해 보면 심박수는 정상적으로 전송되고 있지만, 상대방 서버로부터 응답이 없고, __INLINE_CODE_0__가 주어졌기 때문에 연결이 자동으로 끊어지지 않습니다&lt;/p&gt;
&lt;h2 id=&#34;일반적인-플래그-설명&#34;&gt;일반적인 플래그 설명
&lt;/h2&gt;&lt;p&gt;TCP 프로토콜에서 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;（Push）和 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt;(ACK)는 데이터 전송과 흐름 제어를 위해 사용되는 두 개의 중요한 플래그입니다. 이들의 역할은 다음과 같습니다:&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;1-pshpush-flag&#34;&gt;&lt;strong&gt;1. PSH（Push Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;:
수신측은 버퍼 내의 데이터를 상위 애플리케이션으로 즉시 푸시하고, __BOLD_2&lt;code&gt;PSH&lt;/code&gt; 플래그가 설정된 데이터 블록을 처리하여 운영체제 버퍼에 보관하지 않고 최대한 빠르게 애플리케이션으로 전달해야 합니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;典型场景&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클라이언트가 요청을 보낼 때(예: &lt;code&gt;GET /index.html&lt;/code&gt;BOLD_3&lt;code&gt;PSH&lt;/code&gt;), 서버의 즉각적인 응답을 기대합니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;키보드 입력 시마다 __인라인_2____가 발생하여 입력 문자열이 실시간으로 전송됩니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;비디오 스트리밍, 온라인 게임 등 저지연 시나리오에서 &lt;code&gt;PSH&lt;/code&gt;을 사용하여 지연 시간을 줄일 수 있습니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 필수는 아니며, 수신자는 해당 비트(flag bit)를 무시할 수 있습니다(데이터는 정상적으로 처리해야 합니다)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;발신자가 __INLINE_CODE_0__을 설정하지 않을 경우, 수신자는 자체 버퍼링 정책에 따라 데이터를 푸시할 시점을 결정합니다&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2-ackacknowledgment-flag&#34;&gt;&lt;strong&gt;2. ACK（Acknowledgment Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;:
수신된 이전 데이터 세그먼트가 올바르게 전달되었음을 확인하는 신호이며, 다음 바이트 시퀀스 번호를 나타냅니다. 이는 TCP의 핵심적인 신뢰성 있는 전송 메커니즘입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;工作原理&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터 전송 시, 송신자는 수신자가 기대하는 (&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 值（例如 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt;)을 함께 보냅니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;수신측은 데이터를 수신한 후, &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 메시지 세그먼트를 생성하여 수신 확인된 데이터 시퀀스 번호를 알립니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;발신자는 해당 __INLINE_CODE_0__을 수신한 후에야 재전송할 것입니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;만약 발신자가 번호가 &lt;code&gt;100~199&lt;/code&gt; 的数据段，则期望接收方的 &lt;code&gt;ACK&lt;/code&gt; 应为 __INLINE_CODE_2__인 메시지를 보냈다면,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;수신자가 재전송 요청을 __INLINE_CODE_0__BOLD_2&lt;code&gt;ACK=150&lt;/code&gt;에 알리지 못함&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;3-psh-和-ack-的组合&#34;&gt;&lt;strong&gt;3. PSH 和 ACK 的组合&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;TCP 패킷에서 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 和 __INLINE_CODE_1__이 동시에 나타날 수 있으며, 다음과 같은 상황에서 흔히 볼 수 있습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;HTTP 请求响应&lt;/strong&gt;:
클라이언트가 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 请求时（含数据），会设置 __INLINE_CODE_1__BOLD_4&lt;code&gt;ACK&lt;/code&gt;(이전 응답 확인)을 보냅니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Client → Server: SYN, ACK=1 → 建立连接
Client → Server: PSH, ACK=1, 数据 → 发送请求数据
Server → Client: PSH, ACK=数据长度+1 → 返回响应
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SSH 握手后传输命令&lt;/strong&gt;:
클라이언트가 명령을 입력하면 &lt;code&gt;PSH&lt;/code&gt; 和 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; 데이터 세그먼트를 전송하여 명령이 즉시 전송되고 서버에서 처리되도록 합니다&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;4-其他标志位的关联&#34;&gt;&lt;strong&gt;4. 其他标志位的关联&lt;/strong&gt;
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;플래그&lt;/th&gt;
&lt;th&gt;이름&lt;/th&gt;
&lt;th&gt;간략 설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;동기화, 초기화 연결 (세 번의 악수)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;연결 우아하게 종료&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RST&lt;/td&gt;
&lt;td&gt;재설정&lt;/td&gt;
&lt;td&gt;강제 연결 종료 (비정상 상황)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;URG&lt;/td&gt;
&lt;td&gt;긴급&lt;/td&gt;
&lt;td&gt;긴급 포인터 표시 (거의 사용하지 않음)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h3 id=&#34;总结&#34;&gt;&lt;strong&gt;总结&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;관심사는 &lt;strong&gt;数据尽快到达应用层&lt;/strong&gt;, 지연 감소입니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ACK&lt;/strong&gt; 중점은 &lt;strong&gt;数据的可靠传输&lt;/strong&gt;, 데이터 손실이나 순서 오류 방지입니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;두 가지가 협력하여 TCP 프로토콜의 효율성과 안정성을 균형 있게 맞췄다&lt;/p&gt;</description>
        </item>
        <item>
        <title>atop 도구를 이용한 Linux 시스템 지표 모니터링: 설치, 설정 및 사용법 완벽 가이드</title>
        <link>https://blog.ttf248.life/ko/p/using-atop-to-monitor-linux-system-metrics-installation-configuration-and-usage-guide/</link>
        <pubDate>Thu, 06 Feb 2025 22:48:55 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/using-atop-to-monitor-linux-system-metrics-installation-configuration-and-usage-guide/</guid>
        <description>&lt;p&gt;리눅스 시스템 운영 과정에서 시스템 자원과 프로세스 상태를 실시간으로 종합적으로 모니터링하는 것은 매우 중요합니다. atop 도구는 강력한 모니터링 도구로서, 이를 쉽게 달성하도록 돕습니다. 본 문서에서는 리눅스 인스턴스에 atop 모니터링 도구를 설치, 구성 및 사용하는 방법을 자세히 설명하겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;일반적으로-사용되는-atop-도구-소개&#34;&gt;일반적으로 사용되는 atop 도구 소개
&lt;/h2&gt;&lt;p&gt;atop은 Linux 시스템 리소스 및 프로세스를 모니터링하는 도구로, 시스템과 프로세스의 활동을 기록하고 모든 프로세스의 실행 상태를 보고합니다. 이 도구는 CPU, 메모리, 디스크, 네트워크 등 리소스 사용량 정보와 프로세스 상태 데이터를 수집하며, 로그 파일 형태로 저장할 수 있습니다. 각 프로세스별 CPU 사용률, 메모리 증가량, 디스크 사용률, 우선순위, 사용자 이름, 상태 및 종료 코드 등의 주요 정보를 얻을 수 있으며, atop 설정 파일을 통해 로그 수집 빈도, 로그 파일 저장 경로 및 로테이션 정책 등의 매개변수를 사용자 정의할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;두-번째-atop-도구-설치&#34;&gt;두 번째, atop 도구 설치
&lt;/h2&gt;&lt;p&gt;다양한 Linux 배포판에서 atop 설치 방법은 약간씩 다르므로, 여기서는 일반적인 운영체제를 기준으로 설명하겠습니다&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Alibaba Cloud Linux 3/2、CentOS 7/8、Fedora、Rocky Linux 9&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;설치 명령 실행: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;atop 서비스 시작:&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;Ubuntu / Debian&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;소프트웨어 저장소 목록 업데이트:&lt;/li&gt;
&lt;li&gt;설치 명령 실행: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;atop 서비스 시작:&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;CentOS Stream 9&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;다운로드 및 설치:&lt;/li&gt;
&lt;li&gt;atop 서비스 시작:&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;openSUSE&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;설치 명령 실행: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;atop 서비스 시작:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위에 언급된 운영체제에 사용하시는 배포판이 포함되지 않았다면, atop 공식 웹사이트에서 설치 정보를 확인하실 수 있습니다&lt;/p&gt;
&lt;h2 id=&#34;세-모니터링-주기-및-로그-보존-기간-설정&#34;&gt;세, 모니터링 주기 및 로그 보존 기간 설정
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Alibaba Cloud Linux 3/2, CentOS 7/8 및 Fedora 시스템에서 atop 설정 파일은 __；在Ubuntu、Debian和openSUSE系统中，配置文件是__INLINE_CODE_1__입니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;默认配置参数说明&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;：로그 파일 기록 옵션을 제어하며, 기본값은 비어 있습니다&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LOGINTERVAL&lt;/code&gt;：모니터링 주기, 기본 600초입니다. 과거 로그 추적 문제가 필요한 경우, 실제 요구사항에 따라 해당 주기를 조정하는 것이 좋습니다.&lt;/li&gt;
&lt;li&gt;로그 보관 기간, 기본 28일&lt;/li&gt;
&lt;li&gt;__INLINE_CODE_0__BOLD_2&lt;code&gt;/var/log/atop&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;配置步骤&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;명령 실행하여 설정 파일 열기:&lt;/li&gt;
&lt;li&gt;Alibaba Cloud Linux 3/2, CentOS 7/8, Fedora 시스템에서: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Ubuntu, Debian, openSUSE, CentOS Stream 9, Rocky Linux 9 시스템에서: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;을 눌러 편집 모드로 진입한 다음, 필요에 따라 구성 매개변수를 조정합니다. 예를 들어, 모니터링 주기를 30초로 변경하고, 로그 보존 기간을 7일로 설정하며, 로그 경로는 기본값으로 유지합니다.&lt;/li&gt;
&lt;li&gt;저장하고 편집을 종료합니다&lt;/li&gt;
&lt;li&gt;atop 서비스 재시작 시 설정이 적용됩니다&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;LOGOPTS=&amp;quot;&amp;quot;
LOGINTERVAL=30
LOGGENERATIONS=7
LOGPATH=/var/log/atop 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;네-알겠습니다-네-가지-사용-atop-도구&#34;&gt;네, 알겠습니다. 네 가지 사용 atop 도구
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;常用命令介绍&lt;/strong&gt;: 대화형 명령 모드에서 다음의 일반적인 명령어가 있습니다&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;기본 통합 출력 보기로 전환합니다&lt;/li&gt;
&lt;li&gt;프로세스 목록의 전체 명령줄 표시&lt;/li&gt;
&lt;li&gt;프로세스 메모리 사용량별 내림차순으로 필터링합니다&lt;/li&gt;
&lt;li&gt;프로세스 디스크 사용률을 기준으로 내림차순 정렬합니다&lt;/li&gt;
&lt;li&gt;프로세스 자원 종합 활용률에 따라 내림차순으로 필터링합니다&lt;/li&gt;
&lt;li&gt;프로세스 네트워크 사용률을 기준으로 내림차순 정렬합니다&lt;/li&gt;
&lt;li&gt;다음 모니터링 지점으로 이동합니다&lt;/li&gt;
&lt;li&gt;이전 모니터링 지점으로 이동합니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;：指定时间点，格式为__INLINE_CODE_1__。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;资源监控字段含义介绍&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ATOP&lt;/strong&gt;: 호스트 이름, 정보 샘플링 날짜 및 시간&lt;/li&gt;
&lt;li&gt;프로세스 전체 실행 상황, 커널 모드 및 사용자 모드 실행 시간, 프로세스 총 수, 다양한 상태의 프로세스 수 등을 포함합니다&lt;/li&gt;
&lt;li&gt;CPU 전체 사용률을 나타내며, 각 필드의 숫자 합은 &lt;strong&gt;INLIN_2&lt;/strong&gt;__(N은 CPU 코어 수)이며, 커널 모드, 사용자 모드, 인터럽트, 유휴 상태, 디스크 I/O 대기 등의 시간 비율을 포함합니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPL&lt;/strong&gt;: CPU 사용률 정보, 예를 들어 지난 1분, 5분 및 15분 동안의 실행 중인 프로세스 평균 수, 컨텍스트 스위칭 횟수, 인터럽트 발생 횟수&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MEM&lt;/strong&gt;: 메모리 사용량 정보, 물리 메모리 총량, 유휴 메모리, 페이지 캐시 메모리, 파일 캐시 메모리, 커널 점유 메모리 등을 포함합니다&lt;/li&gt;
&lt;li&gt;스왑 공간 사용량 정보, 스왑 영역 총 용량 및 남은 스왑 공간 크기 포함&lt;/li&gt;
&lt;li&gt;가상 메모리 페이지 상태, 예를 들어 스왑 인/아웃된 페이지 수&lt;/li&gt;
&lt;li&gt;디스크 사용률, 각 디스크 장치별로 표시되며 장치 식별자, 바쁨 상태 시간 비율, 읽기/쓰기 요청 횟수를 나타냅니다&lt;/li&gt;
&lt;li&gt;네트워크 상태를 보여주며, 전송 계층 TCP 및 UDP, IP 계층과 각 활성 네트워크 포트의 송수신 패킷 크기를 표시합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;查看实时系统指标&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;5초마다 시스템 지표 확인: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 시스템 지표를 현재 시간 이후 5분 내(총 30회, 간격 10초)에 확인합니다&lt;/li&gt;
&lt;li&gt;현재 시간 이후 10분 후의 시스템 지표를 확인하고(10회, 60초 간격으로), 결과를 파일에 기록합니다: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;查看历史指标日志&lt;/strong&gt;: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 디렉터리에 기본적으로 저장됩니다. 확인 시 지정된 날짜의 로그 파일이 존재해야 하며, 그렇지 않으면 오류가 발생합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;일별 히스토리 지표 로그 확인: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;어제 기록 지표 로그 확인: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;지정된 날짜의 과거 지표 로그를 확인합니다. 예: 2024년 11월 06일: &lt;code&gt;atop -r 20241106&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;지정된 날짜 및 시간 이후의 과거 지표 로그를 확인합니다. 예: 2024년 11월 6일 14:00부터 &lt;code&gt;atop -r 20241106 -b 14:00&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;지정된 날짜 및 시간 범위 내의 과거 지표 로그를 확인합니다. 예: 2024년 11월 5일 00:04 ~ 00:08: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;查看系统活动报告&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;현재 시스템의 CPU 사용률 보고서를 1분 동안(12회, 간격 5초) 확인합니다: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;해당 날짜 지정 시간대의 메모리 지표 보고서를 확인합니다. 예: 18:00~18:01&lt;/li&gt;
&lt;li&gt;지정된 날짜 및 시간 범위 내의 메모리 지표 보고서 확인 (예: 2024년 11월 5일 18:00~18:01):&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;다섯-기타-작업&#34;&gt;다섯. 기타 작업
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;配置天级别日志轮转策略&lt;/strong&gt;: 매일 atop 지표 로그 파일을 생성하려면 다음 단계를 따르세요&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;(선택 사항) 필요에 따라 모니터링 주기, 로그 보존 기간 및 로그 저장 경로를 조정합니다&lt;/li&gt;
&lt;li&gt;명령 실행하여 매일 로그 로테이션 관련 서비스 자동 시작 및 서비스 시작: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;더 복잡한 로깅 처리가 필요하다면 logrotate나 사용자 정의 스크립트를 활용하여 로그 관리를 구현할 수 있습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;加载可选的netatop内核模块&lt;/strong&gt;: 네트워크 사용률을 모니터링하려면 netatop 모듈(atop에서 기본 설치되지 않음)을 설치할 수 있습니다. Alibaba Cloud Linux 3 시스템을 예로 들면:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;커널 개발 패키지 및 컴파일에 필요한 소프트웨어 환경 설치: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;최신 버전 netatop 소스 코드를 지정된 디렉터리에 다운로드합니다&lt;/li&gt;
&lt;li&gt;소스 코드를 압축 해제하고 소스 코드 디렉토리로 들어갑니다: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;소스 코드 기반으로 모듈과 데몬을 구축 및 설치합니다&lt;/li&gt;
&lt;li&gt;netatop 서비스 시작:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;atop 도구는 기능이 강력하고 사용하기 유연하여, 적절한 설치, 구성 및 활용을 통해 Linux 시스템의 실행 상태를 더 잘 파악하고 잠재적인 문제를 조기에 발견하고 해결할 수 있습니다. 본 문서가 Linux 시스템 모니터링 역량 향상에 도움이 되기를 바랍니다.&lt;/p&gt;
&lt;h2 id=&#34;참고-링크&#34;&gt;참고 링크
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Visual Studio에서 호환되지 않는 pdb 파일을 로드합니다</title>
        <link>https://blog.ttf248.life/ko/p/visual-studio-loading-unmatched-pdb-files/</link>
        <pubDate>Thu, 23 Jan 2025 20:04:33 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/visual-studio-loading-unmatched-pdb-files/</guid>
        <description>&lt;p&gt;Windows에서 Visual Studio로 프로그램을 디버깅할 때 pdb 파일과 실행 파일이 일치하지 않으면 &amp;ldquo;기호 파일을 로드할 수 없음&amp;quot;이라는 메시지가 표시됩니다. 프로그램 충돌 후 덤프 파일이 생성되더라도 일치하지 않는 pdb 파일이면 Visual Studio가 정상적으로 충돌 현장에 진입하지 못합니다.&lt;/p&gt;
&lt;h2 id=&#34;pdb-파일이-뭐죠&#34;&gt;pdb 파일이 뭐죠?
&lt;/h2&gt;&lt;p&gt;PDB 파일은 마이크로소프트에서 제공하는 디버깅 정보 파일이며, 프로그램 디버깅에 사용됩니다. PDB 파일에는 프로그램의 심볼 테이블, 소스 코드 파일 이름, 행 번호 등의 정보가 포함되어 있습니다. 프로그램 컴파일 시 PDB 파일을 생성하여 디버깅에 활용할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;windbg-디버깅&#34;&gt;WinDbg 디버깅
&lt;/h2&gt;&lt;p&gt;WinDbg는 마이크로소프트의 디버깅 도구이며, Windows 프로그램을 디버깅하는 데 사용될 수 있습니다. WinDbg는 불일치하는 pdb 파일을 로드할 수 있지만, 수동으로 로드해야 합니다. &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 명령은 불일치하는 pdb 파일을 강제로 로드할 수 있습니다.&lt;/p&gt;
&lt;p&gt;하지만 WinDbg가 Visual Studio만큼 사용하기 편리하지 않으므로, 저희는 Visual Studio에서도 호환되지 않는 PDB 파일을 로드할 수 있기를 바랍니다&lt;/p&gt;
&lt;h2 id=&#34;비주얼-스튜디오에서-호환되지-않는-pdb-파일-로드&#34;&gt;비주얼 스튜디오에서 호환되지 않는 PDB 파일 로드
&lt;/h2&gt;&lt;p&gt;소스 코드는 보통 git으로 관리되므로, 해당 버전의 코드를 찾아 재컴파일하여 일치하는 pdb 파일을 생성할 수 있습니다. 왜 로드되지 않을까요? 주로 메타데이터 불일치가 원인입니다.&lt;/p&gt;
&lt;p&gt;작은 도구가 있어, 실행 파일 정보를 기반으로 메타데이터를 수정하여 Visual Studio가 로드할 수 있는 새로운 pdb 파일을 생성한다&lt;/p&gt;
&lt;p&gt;chkmatch 다운로드 주소: &lt;a class=&#34;link&#34; href=&#34;https://www.debuginfo.com/tools/chkmatch.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.debuginfo.com/tools/chkmatch.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;사이트 캐시 주소: &lt;a class=&#34;link&#34; href=&#34;chkmatch.zip&#34; &gt;chkmatch.zip&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ChkMatch utility can be used to check whether an executable and debug information file match. It can also be used to enforce matching between an executable and debug information file, if they are compatible.

For more information about debug information matching and related issues, see this article.

Supported debug information formats: DBG, PDB 2.0, PDB 7.0.

chkmatch [-c ExeFile DebugInfoFile ] |
         [-m ExeFile DebugInfoFile]
-c
Check matching between the executable and the debug information file.
-m
Make the executable and the debug information file match.
ExeFile
The name of the executable file.
DebugInfoFile
The name of the debug information file.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;chkmatch-사용&#34;&gt;chkmatch 사용
&lt;/h2&gt;&lt;p&gt;먼저 검사 작업을 수행하고, 불일치 원인을 분석한 후 서명 불일치를 알립니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\tianlong.xiang\Downloads\chkmatch&amp;gt;ChkMatch.exe -c &amp;quot;D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe&amp;quot; E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb
ChkMatch - version 1.0
Copyright (C) 2004 Oleg Starodumov
http://www.debuginfo.com/


Executable: D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe
Debug info file: E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb

Executable:
TimeDateStamp: c26d9be3
Debug info: 2 ( CodeView )
TimeStamp: f86b0a4f  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 122  RVA: 001cdc44  FileOffset: 001cbe44
CodeView format: RSDS
Signature: {428c9b95-39a3-4a8d-a8e5-7be453684757}  Age: 1
PdbFile: D:\stock_UAT\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\obj\Release\YinTrade.Main.pdb
Debug info: 16 ( Unknown )
TimeStamp: 00000000  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 0  RVA: 00000000  FileOffset: 00000000

Debug information file:
Format: PDB 7.00
Signature: {06fae08e-c0a2-4f3d-9c7c-dfc684445dd1}  Age: 1

Result: Unmatched (reason: Signature mismatch)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그런 다음 수정 작업을 실행하여 pdb 파일과 exe 파일을 일치시킵니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\tianlong.xiang\Downloads\chkmatch&amp;gt;ChkMatch.exe -m &amp;quot;D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe&amp;quot; E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb
ChkMatch - version 1.0
Copyright (C) 2004 Oleg Starodumov
http://www.debuginfo.com/


Executable: D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe
Debug info file: E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb

Executable:
TimeDateStamp: c26d9be3
Debug info: 2 ( CodeView )
TimeStamp: f86b0a4f  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 122  RVA: 001cdc44  FileOffset: 001cbe44
CodeView format: RSDS
Signature: {428c9b95-39a3-4a8d-a8e5-7be453684757}  Age: 1
PdbFile: D:\stock_UAT\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\obj\Release\YinTrade.Main.pdb
Debug info: 16 ( Unknown )
TimeStamp: 00000000  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 0  RVA: 00000000  FileOffset: 00000000

Debug information file:
Format: PDB 7.00
Signature: {06fae08e-c0a2-4f3d-9c7c-dfc684445dd1}  Age: 1

Writing to the debug information file...
Result: Success.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/38147487/forcing-to-load-unmatched-symbols-in-visual-studio-2015-debugger&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;forcing-to-load-unmatched-symbols-in-visual-studio-2015-debugger&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>리눅스 백엔드 서비스 문자열 데이터 처리 - 속도 느림</title>
        <link>https://blog.ttf248.life/ko/p/linux-backend-slow-string-processing/</link>
        <pubDate>Wed, 13 Nov 2024 19:42:59 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/linux-backend-slow-string-processing/</guid>
        <description>&lt;p&gt;C++ 개발 프로젝트에서 사용자 정의 프로토콜을 사용하여 통신했는데, 이 프로토콜은 2차원 배열 패턴을 채택했습니다. 대량의 데이터를 처리할 때 프로토콜 내부에서 배열을 순회하고 시리얼화하여 로그를 생성하는 과정이 비효율적이었고, 이는 고부하 상황에서 시스템 응답 지연을 야기했습니다. 이로 인해 사업 부서로부터 시스템 멈춤 현상에 대한 피드백을 받았습니다.&lt;/p&gt;
&lt;h2 id=&#34;문제-파악&#34;&gt;문제 파악
&lt;/h2&gt;&lt;p&gt;문제 해결 과정에서 우선 시스템 성능을 분석한 결과, 대량의 데이터를 처리할 때 CPU 사용률이 눈에 띄게 증가하고 응답 시간이 길어지는 것을 확인했습니다. 시스템 로그를 분석한 결과, 2차원 배열 처리에 비효율적인 많은 양의 직렬화 작업이 수행되고 있었고, 이로 인해 시스템 성능이 저하되었습니다.&lt;/p&gt;
&lt;p&gt;도구 캡처 서비스의 스레드 정보를 분석한 결과, 로그 스레드는 대부분의 시간을 문자열 연결 처리에 소비하는 것으로 나타났다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;여기 오늘의 핵심인데, 다른 누적 방식에 따라 효율성의 차이가 엄청나다. 기존 코드에서는 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 연산자를 사용했는데, 이 방식은 빈번하게 임시 객체를 생성하므로 효율이 매우 낮다. 얼마나 심각한지 모르는 수준으로 비효율적이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;데모-검증&#34;&gt;데모 검증
&lt;/h2&gt;&lt;p&gt;프로젝트 코드를 기반으로 비즈니스 로직을 분리하고, 문자열 연결 효율성 문제를 검증하기 위한 간단한 데모를 작성했습니다. &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 下的 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; 编译器，__INLINE_CODE_2__BOLD_7&lt;code&gt;gcc8.5&lt;/code&gt; 编译器，&lt;strong&gt;INLINE_CODE_4&lt;/strong&gt; 모드에서 컴파일 및 실행하여 효율성을 비교했습니다.&lt;/p&gt;
&lt;h3 id=&#34;주요-사항-안내&#34;&gt;주요 사항 안내
&lt;/h3&gt;&lt;p&gt;프로젝트는 방법 네 가지를 사용하고 있는데, 테스트 데이터를 받기 전 독자들은 어떤 방식이 가장 효율적이고 어떤 방식이 가장 비효율적인지 먼저 생각해 볼 수 있습니다. 결과를 보고 저는 여전히 놀랐습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;각 필드를 문자열에 직접 연결합니다&lt;/li&gt;
&lt;li&gt;스트림(Stream)을 사용하여 각 필드를 연결하면 더 효율적이며, 특히 대량 데이터를 연결할 때 더욱 그렇습니다&lt;/li&gt;
&lt;li&gt;**方法 3（预分配内存的 &lt;strong&gt;인라인_4&lt;/strong&gt; &lt;em&gt;이탤릭체_3&lt;/em&gt;_： 미리 문자열에 충분한 메모리를 할당하면 메모리 재할당 비용을 줄여 성능을 향상시킬 수 있습니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法 4 (&lt;strong&gt;인라인__이탤릭_3&lt;/strong&gt; __)&lt;/strong&gt;: 매번 연결할 때마다 새로운 임시 문자열 객체를 생성하므로, 특히 대규모 연결 시 성능 저하가 발생합니다. 이는 매번 연결 시 새로운 메모리 할당 및 복사가 수반되기 때문입니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;참고 결과, 프로젝트가 효율이 가장 낮은 방식을 선택한 것을 알 수 있습니다&lt;/p&gt;
&lt;p&gt;더 나아가, 다양한 플랫폼 컴파일러의 최적화 효율을 분석해 보면, 마이크로소프트의 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 一如既往的优秀，针对字符串的优化效率很高，而 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; 컴파일러는 이 부분에서 최적화 효율이 다소 떨어지는 편입니다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;코드 실행 환경이 다른 기기에서 이루어지므로 데이터 간 직접적인 비교는 무의미하며, 각각의 조립 방식별 차이를 비교하는 것이 좋습니다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;windows 平台下的 vs2022 编译器

----------------------------------------
Data Generation Time: 0.054 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.053 seconds.
+ ostringstream Data merging took: 0.054 seconds.
+ Pre-reserved Data merging took: 0.045 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 16.108 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;linux 平台下的 gcc8.5 编译器
----------------------------------------
Data Generation Time: 0.108 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.100 seconds.
+ ostringstream Data merging took: 0.083 seconds.
+ Pre-reserved Data merging took: 0.057 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 29.298 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;전체-코드&#34;&gt;전체 코드
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;random&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;iomanip&amp;gt;

typedef std::vector&amp;lt;std::string&amp;gt; DataRow;
typedef std::vector&amp;lt;DataRow&amp;gt; DataGroup;

struct ResponsePackage
{
    std::string ErrorInfo;
    DataRow Head;
    std::string ClientId;
    std::string UUID;
    std::string MsgID;
    std::string SessionID;
    std::string ExtraInfo1;
    std::string ExtraInfo2;
    DataGroup DataBody;
};

// Generate specified length of random string
std::string generateRandomString(size_t length)
{
    const char charset[] = &amp;quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&amp;quot;;
    const size_t max_index = sizeof(charset) - 1;
    std::string random_string;
    random_string.reserve(length);

    std::random_device rd;
    std::mt19937 generator(rd());
    std::uniform_int_distribution&amp;lt;&amp;gt; distribution(0, max_index);

    for (size_t i = 0; i &amp;lt; length; ++i)
    {
        random_string += charset[distribution(generator)];
    }

    return random_string;
}

void create_large_string()
{
    // Example request package with 50 fields
    ResponsePackage requestPackage;

    requestPackage.Head = {
        &amp;quot;Field1&amp;quot;, &amp;quot;Field2&amp;quot;, &amp;quot;Field3&amp;quot;, &amp;quot;Field4&amp;quot;, &amp;quot;Field5&amp;quot;,
        &amp;quot;Field6&amp;quot;, &amp;quot;Field7&amp;quot;, &amp;quot;Field8&amp;quot;, &amp;quot;Field9&amp;quot;, &amp;quot;Field10&amp;quot;,
        &amp;quot;Field11&amp;quot;, &amp;quot;Field12&amp;quot;, &amp;quot;Field13&amp;quot;, &amp;quot;Field14&amp;quot;, &amp;quot;Field15&amp;quot;,
        &amp;quot;Field16&amp;quot;, &amp;quot;Field17&amp;quot;, &amp;quot;Field18&amp;quot;, &amp;quot;Field19&amp;quot;, &amp;quot;Field20&amp;quot;,
        &amp;quot;Field21&amp;quot;, &amp;quot;Field22&amp;quot;, &amp;quot;Field23&amp;quot;, &amp;quot;Field24&amp;quot;, &amp;quot;Field25&amp;quot;,
        &amp;quot;Field26&amp;quot;, &amp;quot;Field27&amp;quot;, &amp;quot;Field28&amp;quot;, &amp;quot;Field29&amp;quot;, &amp;quot;Field30&amp;quot;,
        &amp;quot;Field31&amp;quot;, &amp;quot;Field32&amp;quot;, &amp;quot;Field33&amp;quot;, &amp;quot;Field34&amp;quot;, &amp;quot;Field35&amp;quot;,
        &amp;quot;Field36&amp;quot;, &amp;quot;Field37&amp;quot;, &amp;quot;Field38&amp;quot;, &amp;quot;Field39&amp;quot;, &amp;quot;Field40&amp;quot;,
        &amp;quot;Field41&amp;quot;, &amp;quot;Field42&amp;quot;, &amp;quot;Field43&amp;quot;, &amp;quot;Field44&amp;quot;, &amp;quot;Field45&amp;quot;,
        &amp;quot;Field46&amp;quot;, &amp;quot;Field47&amp;quot;, &amp;quot;Field48&amp;quot;, &amp;quot;Field49&amp;quot;, &amp;quot;Field50&amp;quot;
    };

    requestPackage.ClientId = &amp;quot;ClientID&amp;quot;;
    requestPackage.UUID = &amp;quot;UUID&amp;quot;;
    requestPackage.MsgID = &amp;quot;MsgID&amp;quot;;
    requestPackage.SessionID = &amp;quot;SessionID&amp;quot;;
    requestPackage.ExtraInfo1 = &amp;quot;ExtraInfo1&amp;quot;;
    requestPackage.ExtraInfo2 = &amp;quot;ExtraInfo2&amp;quot;;

    // Start timing for data generation
    auto start_gen = std::chrono::high_resolution_clock::now();

    // Generate 10,000 rows of data, each with 50 fields
    for (size_t i = 0; i &amp;lt; 10000; ++i)
    {
        DataRow dataRow(50, &amp;quot;This is a test string&amp;quot;);
        requestPackage.DataBody.push_back(dataRow);
    }

    // End timing for data generation
    auto end_gen = std::chrono::high_resolution_clock::now();
    std::chrono::duration&amp;lt;double&amp;gt; duration_gen = end_gen - start_gen;

    // Display result generation time
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Generation Time: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_gen.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    // Data merging using different methods
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Performance:\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    {
        // Method 1: Using &#39;+=&#39; string concatenation
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (+=) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 2: Using ostringstream
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::ostringstream bodys;
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::ostringstream body;
            body &amp;lt;&amp;lt; &amp;quot;This is a test string&amp;quot;;
            for (auto&amp;amp; item : vec)
            {
                body &amp;lt;&amp;lt; item &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            }
            bodys &amp;lt;&amp;lt; body.str() &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ ostringstream Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 3: Pre-allocated memory
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys;
        bodys.reserve(1000 * 50 * 20); // Pre-allocate enough memory
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            body.reserve(50 * 20); // Pre-allocate memory for each row
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Pre-reserved Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 4: Using &#39;bodys = bodys + body + &amp;quot;\n&amp;quot;&#39;
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body = body + item + &amp;quot; &amp;quot;; // Note the use of &#39;body = body + item&#39;
            }
            bodys = bodys + body + &amp;quot;\n&amp;quot;; // Again, using &#39;bodys = bodys + body&#39;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (bodys = bodys + body + \&amp;quot;\\n\&amp;quot;) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Complete.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;
}

int main()
{
    try
    {
        create_large_string();
    }
    catch (const std::exception&amp;amp; e)
    {
        std::cerr &amp;lt;&amp;lt; &amp;quot;Caught exception: &amp;quot; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\nProgram finished.\n&amp;quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Win11 로지텍 G431 헤드셋 드라이버 설치</title>
        <link>https://blog.ttf248.life/ko/p/win11-logitech-g431-headphone-driver-installation/</link>
        <pubDate>Wed, 05 Jun 2024 07:20:17 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/win11-logitech-g431-headphone-driver-installation/</guid>
        <description>&lt;p&gt;책 이어받아, 돌아와 보니 Ghub 업데이트가 있네. 좀 기뻤는데, 고객센터에서 해결했다고 하는 문제 드라이브 로딩 오류 문제는 고쳤다고 했는데, 결과적으로 설치하고 제거하고 또 설치해도 제대로 안 된다.&lt;/p&gt;
&lt;h2 id=&#34;배경&#34;&gt;배경
&lt;/h2&gt;&lt;p&gt;계속 고객 지원에 문의하여 해결 방안을 알아보니, 엔지니어의 원격 지원이 가능하다는 답변을 받았지만, 엔지니어의 근무 시간과 제 근무 시간이 겹쳐 어쩔 수 없이 포기했습니다. 이전 문제 해결 과정에서 남겨둔 자료를 다시 살펴보고, 직접 드라이버를 설치해 보려고 합니다.&lt;/p&gt;
&lt;h2 id=&#34;드라이버-설치-패키지-받기&#34;&gt;드라이버 설치 패키지 받기
&lt;/h2&gt;&lt;p&gt;로지텍 공식에서 별도의 장치 드라이버 설치 파일을 제공하지 않습니다. 드라이버 파일은 어떻게 얻을 수 있나요?&lt;/p&gt;
&lt;p&gt;이전 시스템 재설치 시 남겨진 시스템 이미지 설치 패키지를 활용하여, 로컬 가상 머신에서 시스템을 다시 설치할 수 있습니다. 깨끗한 환경에서 Ghub를 개별적으로 배포하고 헤드셋 장치를 가상 머신에 연결한 후, 드라이버 경로를 찾아 복사하면 됩니다.&lt;/p&gt;
&lt;p&gt;관련 경로:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C:\ProgramData\LGHUB&lt;/li&gt;
&lt;li&gt;C:\Windows\System32\DriverStore\FileRepository\logi_audio.inf_amd64_010b035044e24be4&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장치-관리자&#34;&gt;장치 관리자
&lt;/h2&gt;&lt;p&gt;두 번째 경로를 찾는 것이 중요하며, 먼저 Win11 시스템에서 드라이버 파일을 수동으로 관리하는 방법을 간단히 정리해 보겠습니다. 이 부분은 &lt;strong&gt;通过控制变量法来识别的，通过不断的插拔设备，在虚拟机里面分析设备管理器中的设备信息，识别到耳机合计有三个驱动需要处理&lt;/strong&gt;입니다. 그중 두 개의 드라이버는 시스템에 내장되어 있고, 하나는 로지텍에서 제공합니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/win11-logitech-g431-headphone-driver-installation/20240605073331.png&#34;
	width=&#34;433&#34;
	height=&#34;904&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;驱动管理器&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;47&#34;
		data-flex-basis=&#34;114px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;위 그림의 두 번째 드라이버는 로지텍에서 제공하는 것으로, 현재 장치 드라이버를 분석하고 가상 머신 내 모든 드라이버 경로를 뒤져서 logi로 시작하는 파일을 먼저 찾아 파일 비교를 하면 드라이버 파일을 찾을 수 있습니다. 전체 폴더를 복사하면 드라이버 설치 패키지를 얻게 됩니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/win11-logitech-g431-headphone-driver-installation/20240605073933.png&#34;
	width=&#34;946&#34;
	height=&#34;645&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;驱动安装包&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;146&#34;
		data-flex-basis=&#34;352px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;드라이버-설치&#34;&gt;드라이버 설치
&lt;/h2&gt;&lt;p&gt;장치 관리자 인터페이스에서 &amp;lsquo;드라이버 업데이트&amp;rsquo;를 클릭한 다음, &amp;lsquo;내 컴퓨터에서 드라이버 찾아보기&amp;rsquo;를 클릭하면 다음과 같은 화면으로 진입합니다&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/win11-logitech-g431-headphone-driver-installation/20240605074130.png&#34;
	width=&#34;528&#34;
	height=&#34;381&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;驱动安装&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;138&#34;
		data-flex-basis=&#34;332px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;물론 열면 드라이버 하나만 보일 텐데, 그것은 일반 USB 드라이버입니다. &amp;ldquo;디스크에서 설치&amp;quot;를 선택하고 경로를 앞서 복사해둔 폴더로 지정하면 됩니다. 설치 후에는 드롭다운 목록에 로지텍 특유의 드라이버가 추가될 것이고, 장치 드라이버를 새로 설치된 드라이버로 전환하면 됩니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/win11-logitech-g431-headphone-driver-installation/20240605074208.png&#34;
	width=&#34;593&#34;
	height=&#34;423&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;磁盘安装&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;140&#34;
		data-flex-basis=&#34;336px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;인체학-장비-드라이버&#34;&gt;인체학 장비 드라이버
&lt;/h2&gt;&lt;p&gt;이 장치의 드라이버 파일은 시스템에서 제공하는 것이므로, 장치 드라이버 앞에 느낌표가 있는지 확인하고, 있다면 드라이버 선택 화면으로 들어가 다른 유형의 드라이버로 임시로 변경한 후 다시 원래대로 돌리면 정상적으로 복구됩니다&lt;/p&gt;
&lt;h2 id=&#34;완료&#34;&gt;완료
&lt;/h2&gt;&lt;p&gt;헤드폰 마이크 음량은 정상으로 돌아왔고, 익숙한 이어모니터 기능도 다시 작동합니다&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/win11-logitech-g431-headphone-driver-installation/20240605074823.png&#34;
	width=&#34;485&#34;
	height=&#34;739&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;侧音&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;65&#34;
		data-flex-basis=&#34;157px&#34;
	
&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>새로 설치한 기가급 광케이블, 속도 측정 시 100메가에 그치는 이유는 무엇인가요?</title>
        <link>https://blog.ttf248.life/ko/p/new-gigabit-fiber-slow-speed/</link>
        <pubDate>Mon, 18 Mar 2024 00:29:02 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/new-gigabit-fiber-slow-speed/</guid>
        <description>&lt;p&gt;집안 네트워크를 번개처럼 빠뜨리고 싶으신가요? 핵심은 랜 케이블 선택, 광모뎀 및 공유기 설정, 그리고 눈에 띄지 않는 작은 디테일을 이해하는 것입니다. 이 블로그는 6급 랜 케이블로 기가비트 네트워크를 구축하고 간단한 장치 점검과 설정을 통해 네트워크 속도를 제약 없이 유지하는 방법을 쉽게 알려드립니다. 함께 탐색하며 집안 인터넷 속도를 높여 봅시다!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/new-gigabit-fiber-slow-speed/image.png&#34;
	width=&#34;1001&#34;
	height=&#34;590&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;手动修复&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;169&#34;
		data-flex-basis=&#34;407px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;제1장-네트워크-전송-매체-심층-분석&#34;&gt;제1장: 네트워크 전송 매체 심층 분석
&lt;/h2&gt;&lt;p&gt;기가비트급 네트워크 접근을 논할 때, 정보를 고속으로 전송하는 매개체인 랜 케이블이 매우 중요한 역할을 합니다. 다음은 5급, 6급 및 7급 랜 케이블에 대한 자세한 설명입니다.&lt;/p&gt;
&lt;h3 id=&#34;죄송합니다-번역할-중국어-텍스트가-제공되지-않았습니다-텍스트를-제공해-주시면-번역해-드리겠습니다&#34;&gt;죄송합니다. 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.
&lt;/h3&gt;&lt;p&gt;다섯 종류의 네트워크 케이블, CAT5라고도 하며, 비교적 초기에 널리 사용된 트위스트 페어 케이블입니다. 각 선 코어는 정밀한 나선 구조 설계로 인한 신호 간섭을 줄입니다. 주로 10/100Mbps의 빠른 이더넷에 적용되며 최대 전송 주파수는 약 100MHz입니다. 과거에는 널리 사용되었지만, 현재 기가비트 이상의 속도를 요구하는 경우 다섯 종류의 네트워크 케이블은 물리적인 한계로 인해 충족하지 못합니다.&lt;/p&gt;
&lt;h3 id=&#34;두-번째&#34;&gt;두 번째
&lt;/h3&gt;&lt;p&gt;기술 발전과 함께 6류 네트워크 케이블이 등장했습니다. 5류 케이블보다 더 엄격한 제조 기준과 첨단 구조 설계로 제작되어, 전반적인 내성능과 데이터 전송 효율을 크게 향상시켰으며, 최대 1Gbps의 전송 속도를 지원합니다. 이상적인 환경에서는 100미터까지 전송이 가능하여, 기가비트 네트워크 접속 요구 사항에 정확히 부합합니다.&lt;/p&gt;
&lt;h3 id=&#34;3&#34;&gt;3
&lt;/h3&gt;&lt;p&gt;7가지 규격의 네트워크 케이블은 현재 트위스트 페어 기술의 최첨단을 나타냅니다. 전송 속도가 획기적으로 향상되었을 뿐만 아니라 이론적으로 최대 10Gbps의 초고속을 지원하며, 각 선 쌍 간 및 전체 외부를 포함한 완벽한 차폐 시스템이 적용되어 외부 전자파 간섭과 근접 교차 누화를 크게 줄여 데이터 전송의 안정성과 정확성을 보장합니다. 하지만 7가지 규격의 네트워크 케이블은 주로 미래의 10기가비트 이더넷 또는 특정 고성능 환경에서 사용됩니다.&lt;/p&gt;
&lt;p&gt;기가비트 가정 네트워크 환경에서 기가 광섬유의 잠재력을 최대한 활용하기 위해서는 6급 랜 케이블을 선택하는 것이 가장 경제적이고 효율적인 방법입니다. 또한, 모든 연결 케이블의 품질이 양호한지 확인하고 표준 접선 방식으로 엄격하게 작업하는 것도 중요한 과정입니다.&lt;/p&gt;
&lt;h2 id=&#34;제2장-네트워크-핵심-장비---광모뎀-라우터-lan-포트-대역폭-영향-심층-분석&#34;&gt;제2장: 네트워크 핵심 장비 - 광모뎀, 라우터 LAN 포트 대역폭 영향 심층 분석
&lt;/h2&gt;&lt;h3 id=&#34;광촉매와-lan-포트-대역폭의-중요성&#34;&gt;광촉매와 LAN 포트 대역폭의 중요성
&lt;/h3&gt;&lt;p&gt;광촉매, 정식 명칭 광섬유 모뎀은 가정용 초고속 인터넷 접속의 핵심 장비이며, 광섬유 내의 광 신호를 디지털 신호로 변환하여 가정 네트워크 장비에서 사용하도록 하는 기능을 수행합니다. 기가급 광섬유 사용자에게 있어 광촉매가 기가 전송을 지원하는지 여부가 특히 중요합니다. 만약 광촉매의 WAN 포트가 100메가를 지원한다면, 입구 광섬유 속도가 아무리 높아도 이 병목 현상으로 인해 100메가 이하로 제한됩니다. 마찬가지로 광촉매의 LAN 포트 또한 기가 출력 능력을 갖춰야 하며, 그렇지 않으면 연결된 라우터나 다른 장비는 진정한 기가 속도를 얻을 수 없습니다.&lt;/p&gt;
&lt;h3 id=&#34;라우터-lan-포트-대역폭의-역할&#34;&gt;라우터 LAN 포트 대역폭의 역할
&lt;/h3&gt;&lt;p&gt;라우터의 LAN 포트는 수신된 데이터를 각 단말 장치로 분배하는 역할을 합니다. 라우터의 LAN 포트가 100Mbps인 경우, 다른 장비 설정이 아무리 좋아도 100Mbps 속도의 로컬 네트워크 통신만 가능합니다. 따라서 기가홈 네트워크를 구축할 때는 라우터의 WAN 포트가 기가 데이터를 수신하고, LAN 포트 또한 기가 수준의 데이터 출력 능력을 제공해야 모든 스마트 기기가 고속 네트워크의 원활한 경험을 누릴 수 있습니다.&lt;/p&gt;
&lt;p&gt;또한, 주의해야 할 점은 일부 구형 또는 저가형 라우터는 LAN 포트 자동 협상 기능이 있을 수 있으며, 이는 라우터 자체는 기가비트를 지원하더라도 케이블, 장치 호환성 등의 이유로 속도가 100Mbps 모드로 낮아질 수 있다는 의미입니다. 따라서 기가비트 네트워크를 구현하기 위해서는 라우터 설정을 올바르게 구성하고 강제 기가비트 모드를 활성화하며 기가비트 스위치나 직접 연결된 장치를 함께 사용하는 것이 중요한 단계 중 하나입니다.&lt;/p&gt;
&lt;p&gt;기가급 광섬유로 업그레이드한 후에는 반드시 기가급 ONT와 기가급 공유기로 교체하고, 모든 장비 인터페이스가 기가급 수준인지 확인하십시오&lt;/p&gt;
&lt;h2 id=&#34;제3장-잠재된-미스터리---끊어진-서브-라인이-어떻게-테라비트급-네트워크-속도에-영향을-미치는가&#34;&gt;제3장: 잠재된 미스터리 - 끊어진 서브 라인이 어떻게 테라비트급 네트워크 속도에 영향을 미치는가
&lt;/h2&gt;&lt;h3 id=&#34;서브-라인-장애-및-네트워크-성능-저하&#34;&gt;서브 라인 장애 및 네트워크 성능 저하
&lt;/h3&gt;&lt;p&gt;측정 기간 동안 네트워크 연결은 안정적이었고, 명백한 단절 현상은 없었습니다. 신규 입주형 광대역 회선이라 분배함 내부가 복잡하고, 가끔씩 광모뎀 배선이나 전원 인터페이스 위치를 조정하다 보니 간혹 기가 속도가 측정된 적도 있습니다.&lt;/p&gt;
&lt;p&gt;앞선 자료를 바탕으로 점검한 결과, 랜 케이블 모델과 광케이블 LAN 포트 속도를 분석했더니, 결국 범인은 랜 케이블 내부의 갈색 서브 라인이 끊어진 것이었습니다&lt;/p&gt;
&lt;p&gt;설치 기사님이 크리스탈 헤드를 설치할 때 이 랜선에 조금 세게 힘을 가했고, 그 결과 한 선이 반쯤 끊어졌습니다. 완전히 끊어지지는 않았지만, 이후 광모뎀 위치를 계속 조정하면서 위치를 옮기니 결국 완전히 끊어졌습니다.&lt;/p&gt;
&lt;h3 id=&#34;6가지-네트워크-케이블-8선-기능-분석&#34;&gt;6가지 네트워크 케이블 8선 기능 분석
&lt;/h3&gt;&lt;p&gt;여섯 종류의 네트워크 케이블은 TIA/EIA-568-B 표준을 따르며, 8개의 트위스트 페어 전선으로 구성되어 있으며, 색상 코딩은 다음과 같습니다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;백청 / 청&lt;/li&gt;
&lt;li&gt;백록 / 녹&lt;/li&gt;
&lt;li&gt;흰색 파란색 / 파란색&lt;/li&gt;
&lt;li&gt;갈색&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;기가비트 이더넷(1000BASE-T) 표준 하에, 이 8개의 선 중 4쌍의 선이 동시에 작동하며, 각 역할은 다음과 같습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;백오렌지와 오렌지 이 두 선(1&amp;amp;2)은 데이터 전송(Tx+/-)에 사용됩니다&lt;/li&gt;
&lt;li&gt;백록과 녹색 이 두 선(3&amp;amp;6)은 데이터 수신(Rx+/-)에 사용됩니다&lt;/li&gt;
&lt;li&gt;백란과 남색 쌍(4&amp;amp;5) 및 백갈색과 갈색 쌍(7&amp;amp;8)은 기가비트 이더넷에서 원래 주 용도로 사용되지는 않지만, 일부 고급 애플리케이션(예: 특정 PoE 전원 공급 또는 향후 기술 확장)에서는 활성화될 수 있습니다. 반면 전통적인 100메가비트 네트워크에서는 1, 2, 3, 6번 선만 사용하는 것으로 충분합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;절단된-서브넷이-네트워크-속도에-미치는-영향&#34;&gt;절단된 서브넷이 네트워크 속도에 미치는 영향
&lt;/h3&gt;&lt;p&gt;위와 같은 상황에서 갈색의 부선(갈색 선 또는 갈색 흰색 선)이 끊어지면 이론적으로는 1Gbps 네트워크 환경에서 속도 저하가 발생할 수 있습니다. 왜냐하면 1Gbps 네트워크는 최대 속도를 달성하기 위해 모든 4쌍의 선이 양방향으로 동시에 전송해야 하기 때문입니다. 하지만 가정용 네트워크 장비는 종종 자동 협상 기능을 가지고 있어 케이블 문제를 감지하면 정상적으로 작동하는 낮은 속도 모드, 즉 100Mbps 모드로 전환합니다. 따라서 부선이 끊어져도 네트워크 연결은 유지되고 100Mbps 속도로 작동하는 이유를 설명합니다.&lt;/p&gt;
&lt;p&gt;간단히 말해서, 단일 갈색 보조 광섬유가 끊어진다고 백메가 비트 네트워크의 기본 작동에는 영향을 미치지 않지만, 기가비트 네트워크 환경에서는 네트워크 속도를 제한하는 주요 요인이 될 수 있습니다. 심층적인 진단과 복구 작업을 거쳐야만 기가 광섬유의 잠재력을 완전히 발휘할 수 있습니다. 이는 유사한 상황에 직면했을 때, 기본적인 연결에는 영향을 미치지 않는 것처럼 보이는 작은 결함이라 할지라도 고속 네트워크 경험을 저해하는 숨겨진 장애물이 될 수 있으므로 잠재적인 네트워크 인프라 문제를 간과해서는 안 된다는 점을 시사합니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>WPF UI 스레드와 멈춤 문제 및 해결책</title>
        <link>https://blog.ttf248.life/ko/p/wpf-ui-thread-and-freezing-issues-solutions/</link>
        <pubDate>Tue, 12 Mar 2024 07:12:21 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/wpf-ui-thread-and-freezing-issues-solutions/</guid>
        <description>&lt;p&gt;데스크톱 애플리케이션을 개발할 때, 특히 Windows Presentation Foundation (WPF) 프레임워크를 사용하여 리치 클라이언트 앱을 구축할 때는 UI 스레드를 올바르게 처리하는 것이 애플리케이션의 원활성과 응답성을 보장하는 데 매우 중요합니다. UI 스레드, 또는 메인 스레드는 창 및 컨트롤 이벤트 처리, 레이아웃 계산, 그리고 인터페이스 렌더링을 담당하는 핵심 스레드입니다. UI 요소와의 모든 상호 작용은 UI 스레드에서 실행되어야 하며, 이는 WPF를 비롯한 대부분의 GUI 프레임워크가 따르는 기본 원칙입니다.&lt;/p&gt;
&lt;h2 id=&#34;ui-스레드가-무엇인가요&#34;&gt;UI 스레드가 무엇인가요?
&lt;/h2&gt;&lt;p&gt;WPF 애플리케이션 시작 시 UI 스레드는 운영체제에 의해 생성되고 애플리케이션 주 창을 초기화합니다. 이 스레드만이 직접적으로 UI 구성 요소를 액세스하고 수정할 수 있으며, 버튼 클릭, 텍스트 상자 입력, 창 크기 변경 등 모든 사용자 인터랙션 이벤트는 이 스레드 컨텍스트 내에서 처리됩니다. 또한 WPF의 종속 속성 시스템, 데이터 바인딩 메커니즘 및 레이아웃 로직도 UI 스레드 위에서 동기적으로 실행됩니다.&lt;/p&gt;
&lt;h2 id=&#34;끊김-현상-및-원인&#34;&gt;끊김 현상 및 원인
&lt;/h2&gt;&lt;p&gt;UI 스레드가 장시간 점유되거나 차단될 때, 예를 들어 시간이 오래 걸리는 계산, 대량 데이터 로딩, 데이터베이스 쿼리 또는 기타 I/O 집약적인 작업을 수행할 경우 사용자 상호 작용 요청에 즉시 응답하지 못하여 화면이 응답하지 않는 것처럼 보이는 &amp;ldquo;멈춤&amp;rdquo; 현상이 발생합니다. 이 경우 사용자는 앱의 지연과 끊김을 느끼며 심각한 경우 &amp;ldquo;응답 없음(ANR)&amp;rdquo; 경고가 표시될 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;ui-스레드의-두-가지-기본-규칙&#34;&gt;UI 스레드의 두 가지 기본 규칙
&lt;/h2&gt;&lt;p&gt;위와 같은 상황을 피하기 위해, WPF 개발자는 다음 두 가지 주요 규칙을 준수해야 합니다&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;UI 스레드가 사용자 입력에 즉시 대응하고 화면 렌더링을 처리할 수 있도록, UI 스레드를 일시 중단할 수 있는 작업은 가능한 한 백그라운드 스레드로 옮겨야 합니다&lt;/li&gt;
&lt;li&gt;WPF의 보안 메커니즘 설계상 UI 스레드만이 UI 요소를 수정할 권한을 가지고 있습니다. 다른 스레드에서 직접 UI 상태를 변경하려고 하면 예외가 발생합니다. 따라서 백그라운드 스레드에서 계산이나 데이터 준비가 완료되더라도 적절한 크로스 스레드 통신 메커니즘을 통해 결과를 UI에 표시해야 합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;비동기-프로그래밍-및-스레드-안전-업데이트&#34;&gt;비동기 프로그래밍 및 스레드 안전 업데이트
&lt;/h2&gt;&lt;p&gt;UI의 응답성을 유지하면서도 시간이 오래 걸리는 작업을 수행하기 위해, WPF는 개발자가 이 목표를 달성하도록 돕기 위한 다양한 비동기 프로그래밍 모델과 도구를 제공합니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WPF의 Dispatcher 클래스는 작업 항목을 UI 스레드의 작업 큐에 배치하여 실행할 수 있습니다. __INLINE_CODE_0BOLD_3&lt;code&gt;Dispatcher.BeginInvoke&lt;/code&gt; 메서드를 사용하여 백그라운드 스레드에서 안전하게 UI를 업데이트할 수 있습니다.&lt;/li&gt;
&lt;li&gt;C# 언어의 비동기 기능을 활용하면 비동기 메서드를 작성하고 그 안에서 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 키워드를 사용하여 백그라운드 작업 완료를 기다린 후, 완료되면 자동으로 UI 스레드에서 후속 UI 업데이트 코드를 실행할 수 있습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;사례&#34;&gt;사례
&lt;/h2&gt;&lt;h3 id=&#34;__inline_code_0__-방법을-사용하여-ui를-업데이트합니다&#34;&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 방법을 사용하여 UI를 업데이트합니다
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private void Button_Click(object sender, RoutedEventArgs e)
{
    // 假设这是一个耗时操作
    Task.Run(() =&amp;gt;
    {
        var result = LongRunningOperation(); // 这里是模拟一个耗时计算的方法
        
        // 当耗时操作完成后，在UI线程上更新UI
        Application.Current.Dispatcher.Invoke(() =&amp;gt;
        {
            LabelStatus.Text = $&amp;quot;计算结果: {result}&amp;quot;;
        });
    });
}

private string LongRunningOperation()
{
    // 模拟耗时操作
    Thread.Sleep(5000);
    return &amp;quot;已完成&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;사용-asyncawaitbold_2taskrun&#34;&gt;사용 &lt;code&gt;async/await&lt;/code&gt;BOLD_2&lt;code&gt;Task.Run&lt;/code&gt;
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private async void Button_ClickAsync(object sender, RoutedEventArgs e)
{
    Button button = sender as Button;
    button.IsEnabled = false; // 防止用户重复点击

    try
    {
        // 开启后台任务
        var result = await Task.Run(() =&amp;gt; LongRunningOperation());

        // 在后台任务完成后，自动切换回UI线程更新UI
        LabelStatus.Text = $&amp;quot;计算结果: {result}&amp;quot;;
    }
    catch (Exception ex)
    {
        MessageBox.Show($&amp;quot;发生错误: {ex.Message}&amp;quot;);
    }
    finally
    {
        button.IsEnabled = true; // 重新启用按钮
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>GCC 버전 업그레이드로 인한 프로그램 충돌: 비표준 코드의 잠재적 위험</title>
        <link>https://blog.ttf248.life/ko/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</link>
        <pubDate>Sun, 10 Mar 2024 23:19:06 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</guid>
        <description>&lt;p&gt;동일한 비즈니스 코드의 경우, CentOS 7 환경에서 컴파일 및 실행은 정상적으로 이루어졌지만, CentOS 8로 전환하고 최신 버전의 GCC를 사용하여 컴파일했을 때 프로그램이 충돌했습니다. 주목할 점은 문제가 &lt;strong&gt;Release 模式&lt;/strong&gt;에서만 발생하며, &lt;strong&gt;Debug 模式&lt;/strong&gt;에서는 전혀 문제가 없다는 것입니다. 이와 같은 상황은 처음 경험했으며, 사흘간의 조사 끝에 문제의 근본 원인을 찾았습니다.&lt;/p&gt;
&lt;h3 id=&#34;문제-파악&#34;&gt;문제 파악
&lt;/h3&gt;&lt;p&gt;일련의 점검 결과, 문제의 근본 원인은 &lt;strong&gt;函数缺少返回值&lt;/strong&gt;에 있습니다. Release 모드에서 GCC 최신 버전은 더 많은 최적화를 수행하며, 이로 인해 명시적인 반환 값이 없는 함수의 실행 과정에서 예상치 못한 로직이 발생하여 충돌을 일으킵니다. 결론으로는, &lt;strong&gt;编译器的警告不容忽视，尤其是在老项目中，部分警告可能被无视，但也应当避免屏蔽所有警告&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;h3 id=&#34;환경-설명&#34;&gt;환경 설명
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CentOS 7 GCC版本：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39)
Copyright © 2015 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CentOS 8 GCC版本：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 8.5.0 20210514 (Red Hat 8.5.0-21)
Copyright (C) 2018 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;붕괴-현상&#34;&gt;붕괴 현상
&lt;/h3&gt;&lt;p&gt;프로그램 충돌 스택을 분석하는 과정에서 다음과 같은 스택 정보를 확인했습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[New LWP 1385902]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib64/libthread_db.so.1&amp;quot;.
Core was generated by `./pstack_main`.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007ffe894b4420 in ?? ()
(gdb) bt
#0  0x00007ffe894b4420 in ?? ()
#1  0x00000000004008e9 in main ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 스택은 직관적이지 않아 보이며, 충돌 함수의 스택 정보가 &lt;code&gt;??&lt;/code&gt;으로 표시되어 문제 해결을 더욱 어렵게 만들고 있습니다&lt;/p&gt;
&lt;h3 id=&#34;코드-예시&#34;&gt;코드 예시
&lt;/h3&gt;&lt;p&gt;문제 이해를 돕기 위해, 재현을 위한 최소 코드 예제는 다음과 같습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int test() {
    std::cout &amp;lt;&amp;lt; &amp;quot;1&amp;quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    test();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;해당 코드에서 &lt;code&gt;__INLINE_CODE_0__ 函数显然没有显式返回一个值，而它的返回类型是 __INLINE_CODE_1__BOLD_4&lt;/code&gt;int`` 유형의 경우, 반드시 반환 값이 있어야 하며, 그렇지 않으면 정의되지 않은 동작이 발생할 수 있습니다&lt;/p&gt;
&lt;h3 id=&#34;컴파일-경고&#34;&gt;컴파일 경고
&lt;/h3&gt;&lt;p&gt;프로젝트에서 CMake 스크립트가 여러 컴파일 경고를 숨겼는데, 그중에는 다음과 같은 경고 메시지도 포함되어 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/root/pstack/main.cpp: In function ‘int test()’:
/root/pstack/main.cpp:7:1: warning: no return statement in function returning non-void [-Wreturn-type]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 경고는 &lt;code&gt;test()&lt;/code&gt; 함수가 반환값을 가지지 않는다는 것을 나타내며, 이것이 문제의 근원입니다. GCC의 높은 버전(예: 8.5.0)은 코드를 최적화할 때 이러한 정의되지 않은 동작에 대해 불안정한 최적화를 수행하여 프로그램 충돌을 일으킬 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;어셈블리-코드-차이&#34;&gt;어셈블리 코드 차이
&lt;/h3&gt;&lt;p&gt;GCC 컴파일러 최적화 동작의 차이를 설명하기 위해, 다양한 버전의 GCC가 생성한 어셈블리 코드를 비교했습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GCC 4.8.5 生成的汇编代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;어셈블리 코드는 다소 장황하며, 표준 출력 스트림(예: &lt;code&gt;std::cout&lt;/code&gt;）的处理逻辑。这表明编译器进行了更保守的优化，未对 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; 함수에서 누락된 반환값 문제)에 대한 과도한 최적화를 포함하고 있어, 이로 인해 런타임 오류를 피했을 가능성이 있습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GCC 8.5.0 生成的汇编代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;새 버전의 GCC는 더 많은 최적화를 수행하여 코드 양을 줄였습니다. 하지만 이러한 최적화로 인해 반환 값이 없는 함수의 실행 동작이 정의되지 않아 프로그램이 충돌할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;결론&#34;&gt;결론
&lt;/h3&gt;&lt;p&gt;이번 문제 해결 과정을 통해 C++에서 &lt;strong&gt;函数返回值必须明确&lt;/strong&gt;, 특히 함수 선언이 &lt;code&gt;int&lt;/code&gt;BOLD_2__일 때, 모든 경고를 숨기지 않고, 특히 반환 값, 타입 매칭 등 흔히 발생하는 문제에 대해 선택적으로 처리해야 한다는 것을 깊이 인식하게 되었습니다&lt;/p&gt;
&lt;p&gt;마침내 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 함수에 반환값을 추가하여 문제를 해결하고 프로그램이 정상적으로 작동하게 되었습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>VMware 가상 머신 CPU 리소스 사용량 이상</title>
        <link>https://blog.ttf248.life/ko/p/vmware-virtual-machine-cpu-resource-usage-anomaly/</link>
        <pubDate>Sun, 10 Mar 2024 22:14:59 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/vmware-virtual-machine-cpu-resource-usage-anomaly/</guid>
        <description>&lt;p&gt;로컬 머신에 배포된 Windows 버전 업무 시스템은 CPU 자원 점유율이 약 5% 정도인데, VMware에 설치된 CentOS8 환경의 Linux 버전 업무 시스템은 자원 점유율이 비정상적입니다&lt;/p&gt;
&lt;h2 id=&#34;문제-설명&#34;&gt;문제 설명
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;호스트 시스템: Win10 기업판&lt;/li&gt;
&lt;li&gt;vmware：17.5&lt;/li&gt;
&lt;li&gt;가상 머신: CentOS 8&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;가상 머신 리소스 할당은 &lt;code&gt;4C8GB&lt;/code&gt;이며, 비즈니스 시스템을 시작합니다. 비즈니스 시스템은 가상 머신 Linux 시스템에 배포되어 있으며, 가상 머신 내부의 top 명령어를 통해 시스템 리소스 사용량을 관찰한 결과 CPU 사용량은 높지 않습니다. 하지만 외부 Windows 시스템에서 작업 관리자를 통해 확인했을 때 CPU 리소스 사용량이 매우 높았고, 프로세스를 확인해 보니 VMware 프로세스가 CPU 리소스를 많이 사용하고 있었습니다.&lt;/p&gt;
&lt;p&gt;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+
|         Windows           |
|                           |
|   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+  |
|   |      VMware        |  |
|   |      Program       |  |
|   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+  |
|                           |
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+&lt;/p&gt;
&lt;h2 id=&#34;핵심-개념&#34;&gt;핵심 개념
&lt;/h2&gt;&lt;p&gt;이 문제 해결은 순탄치 않았는데, 도화선이 비즈니스 시스템 자체가 아니라 가상 머신 자체의 문제였기 때문이다. 어떻게 하면 일반적인 비즈니스 코드에서 벗어나 시스템 부하로 사고를 전환하고, 부하 데이터의 이상 현상을 통해 소프트 인터럽트를 찾아내어 결국 핵심에 다다를 수 있을까? 무엇이 VMware 소프트 인터럽트의 효율성을 저해하는 것일까? 본 글에서는 먼저 관련 지식을 설명하고 마지막으로 해결책을 제시한다.&lt;/p&gt;
&lt;h3 id=&#34;hyper-v&#34;&gt;hyper-v
&lt;/h3&gt;&lt;p&gt;윈도우 운영 체제의 가상화 기술에 큰 변화가 있었습니다. 마이크로소프트가 WSL을 처음 출시했을 때 Hyper-V 서비스를 활성화하면 VMware 가상 머신을 동시에 사용할 수 없었습니다. 이후 버전에서 VMware는 Hyper-V 서비스와 호환되게 되었습니다.&lt;/p&gt;
&lt;h3 id=&#34;시스템-부하&#34;&gt;시스템 부하
&lt;/h3&gt;&lt;p&gt;리눅스 시스템에서 &amp;ldquo;로드(load)&amp;ldquo;는 실행 중이거나 실행을 기다리는 프로세스의 수를 의미합니다. 로드는 일반적으로 1분, 5분, 15분 동안의 실행 대기열에 있는 평균 프로세스 수를 나타내는 세 자리 숫자로 표시됩니다. 이러한 숫자는 &amp;ldquo;uptime&amp;rdquo; 또는 &amp;ldquo;top&amp;rdquo; 명령어를 실행하여 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;구체적으로, 이 세 숫자는 각각을 의미합니다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;1分钟负载&lt;/strong&gt;: 시스템이 지난 1분 동안 실행한 평균 프로세스 수입니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;5分钟负载&lt;/strong&gt;: 시스템은 지난 5분 동안 실행 중인 프로세스 평균 수를 나타냅니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;15分钟负载&lt;/strong&gt;: 시스템은 지난 15분 동안 실행 중인 프로세스 평균 수를 나타냅니다&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;부하란 시스템에서 실행을 기다리는 프로세스 수를 의미합니다. 이 숫자가 시스템의 논리 CPU 수보다 높으면 시스템 부하가 높다는 뜻이며, 많은 프로세스가 프로세서 자원을 기다리고 있음을 나타냅니다. 이는 시스템이 느려지거나 응답하지 않을 수 있으며, 부하 정도와 시스템 구성 및 성능에 따라 달라집니다.&lt;/p&gt;
&lt;p&gt;이상적으로는, 부하가 시스템의 논리 CPU 수 범위 내에 유지되어야 시스템 성능을 최적화할 수 있습니다. 부하가 지속적으로 CPU 수보다 높다면, 시스템 프로세스를 추가적으로 분석하여 높은 부하의 원인을 파악하고, 시스템 리소스 할당 조정 또는 프로세스 실행 방식 최적화를 위한 조치를 취해야 합니다.&lt;/p&gt;
&lt;h3 id=&#34;mpstat-로드-분석&#34;&gt;mpstat 로드 분석
&lt;/h3&gt;&lt;p&gt;부하 분석 절차:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;安装 sysstat&lt;/strong&gt;:
__INLINE_CODE_0__이 설치되어 있지 않다면, 시스템에 적합한 패키지 관리 도구를 사용하여 설치할 수 있습니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;运行 mpstat&lt;/strong&gt;:
자원 사용을 나타냄&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;01:32:33 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
01:32:35 PM  all    0.00    0.00    0.26    0.00    3.73    0.26    0.00    0.00    0.00   95.76
01:32:35 PM    0    0.00    0.00    0.51    0.00    3.57    0.00    0.00    0.00    0.00   95.92
01:32:35 PM    1    0.00    0.00    0.00    0.00    3.59    0.51    0.00    0.00    0.00   95.90
01:32:35 PM    2    0.00    0.00    0.00    0.00    4.15    0.00    0.00    0.00    0.00   95.85
01:32:35 PM    3    0.00    0.00    0.52    0.00    3.61    0.52    0.00    0.00    0.00   95.36
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分析输出&lt;/strong&gt;:
__INLINE_CODE_0__의 출력은 각 CPU 사용률과 시스템 평균 부하를 포함합니다. 평균 부하와 각 CPU 사용률에 특히 주의하면 시스템 부하 상황을 파악하는 데 도움이 됩니다. 부하가 높다면, 어떤 프로세스가 원인인지 추가 분석하고 성능 병목 현상이 있는지 확인할 수 있습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;结合其他工具&lt;/strong&gt;:
다양한 도구들을 활용하여 시스템 성능을 종합적으로 분석합니다. 여러 도구의 결과를 결합하면 시스템 부하 상황을 보다 포괄적으로 파악하고, 성능 문제의 근본 원인을 찾아낼 수 있습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;중단&#34;&gt;중단
&lt;/h3&gt;&lt;p&gt;여기 내용은 너무 자세히 설명하지 않겠습니다
추천: &lt;a class=&#34;link&#34; href=&#34;https://www.codedump.info/post/20200522-sgfap-softirq/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《面向应用开发者的系统指南》CPU篇之软中断&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;잦은 소프트웨어 인터럽트 발생은 시스템 부하에도 반영된다&lt;/p&gt;
&lt;h2 id=&#34;문제-해결&#34;&gt;문제 해결
&lt;/h2&gt;&lt;p&gt;CPU 관점만으로는 문제 위치를 파악하기 어렵다면, 시스템에 이상이 발생했을 가능성을 의심해야 할까요? Linux 운영체제의 과도한 부하로 인해 VMware가 지나치게 많은 CPU 자원을 사용하고 있을 수도 있습니다. &lt;code&gt;mpstat&lt;/code&gt;分析本地虚拟机，我们发现&lt;code&gt;irq&lt;/code&gt;占用异常，单核接近25%，而在正常情况下，启动业务进程空跑时，&lt;code&gt;irq&lt;/code&gt;의 비율은 약 5% 정도여야 합니다.&lt;/p&gt;
&lt;p&gt;팀 내 동료의 개발 환경에서 그의 CentOS 7은 VMware에 배포되었으며, 자원 사용량은 정상적으로 표시됩니다. 반면 상하이 개발 환경에서는 동일하게 VMware이지만 호스트 CPU 자원 상황을 직접 관찰할 수 없습니다. 이 때 우리는 VMware 가상 머신, Linux 운영체제 및 GCC 버전을 포함한 여러 변수를 고려해야 합니다.&lt;/p&gt;
&lt;p&gt;물리 서버에 배포되고, 저 버전 GCC 컴파일 서비스가 실행 중이며, CentOS 8 위에서 운영되는 선전 테스트 환경으로 분석을 전환해 보면, __INLINE_CODE_0__의 사용량은 정상입니다&lt;/p&gt;
&lt;p&gt;문제 해결을 위해 GCC 최신 버전으로 컴파일된 프로그램을 선전 환경에 배포하여 테스트한 결과 모두 정상 작동했습니다&lt;/p&gt;
&lt;p&gt;문제는 좀 더 명확해지는 듯하고, 운영체제에 문제가 있는 건 아닌지 의심하기 시작했습니다. 결국 CentOS 8은 공식 지원이 종료되었으니까요. 하지만 깨끗한 CentOS 7과 CentOS 8을 다시 배포해도 문제는 여전히 발생합니다.&lt;/p&gt;
&lt;p&gt;지금, VMware 가상화 소프트웨어가 유일한 불확실성 요소인 것 같다는 의심이 들기 시작했다. 갑자기 아이디어가 떠올랐다. 혹시 Hyper-V 기술을 이전에 활성화했지만 완전히 종료하지 않아 이런 문제가 발생했을까? 결국, 소프트 인터럽트도 가상화 소프트웨어를 통해 구현되므로, 서로 다른 가상화 기술에 버그가 있을 가능성은 없는지 심층적인 고민과 조사가 필요하다.&lt;/p&gt;
&lt;h2 id=&#34;결론&#34;&gt;결론
&lt;/h2&gt;&lt;p&gt;마이크로소프트 공식 매뉴얼에 따르면, 로컬 Hyper-V 서비스를 완전히 종료한 후 VMware가 호스트에서 정상적으로 복구되었습니다. 덕분에 문제는 마침내 해결되었습니다. 처음 설명했듯이, 이 경험은 굴곡지고 고되었으며 종합적인 분석과 판단이 필요했습니다. 또한, 이번 문제 해결 과정에서 처음으로 VM 수준까지 추적하게 되었습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Disable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V-Hypervisor
bcdedit /set hypervisorlaunchtype off
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/application-management/virtualization-apps-not-work-with-hyper-v&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/application-management/virtualization-apps-not-work-with-hyper-v&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43; 프로그래밍의 함정: `std::map` 오용으로 인한 프로그램 충돌 상세 분석</title>
        <link>https://blog.ttf248.life/ko/p/cpp-programming-traps-std-map-crash-details/</link>
        <pubDate>Sun, 10 Mar 2024 22:03:06 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/cpp-programming-traps-std-map-crash-details/</guid>
        <description>&lt;p&gt;C++ 프로그래밍에서 &lt;code&gt;std::map&lt;/code&gt; 컨테이너를 잘못 사용하면 프로그램이 충돌할 수 있습니다. 대괄호 연산자로 존재하지 않는 키에 접근하려 할 때 자동으로 빈 요소가 추가되기 때문입니다. 이 오해를 자세히 분석하고 예제 코드를 통해 잠재적인 위험을 보여드리겠습니다.&lt;/p&gt;
&lt;p&gt;저장하는 값이 단순한 값이라면 문제가 없지만, 포인터라면 문제가 발생할 수 있습니다. 포인터는 주소이고, 초기화되지 않은 주소는 불확실하기 때문에 프로그램이 충돌할 수 있습니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;C++ 표준 라이브러리에서 __INLINE_CODE_0__是一种关联容器，它按照键（key）的升序存储元素，并提供了高效的关键字查找功能。然而，新手开发者有时会因为对__INLINE_CODE_1__中括号操作符 &lt;code&gt;[]&lt;/code&gt; 的行为理解有误而陷入困境。实际上，当使用 __INLINE_CODE_3__BOLD_8&lt;code&gt;std::map&lt;/code&gt;은 새로운 키-값 쌍을 삽입하고, 기본 생성자를 사용하여 해당 키에 대응하는 값 타입의 초기화를 수행합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int main() {
    std::map&amp;lt;std::string, int&amp;gt; myMap;
    
    // 错误的用法：假设这里试图访问一个不存在的键并认为会得到0
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for &#39;nonexistent_key&#39;: &amp;quot; &amp;lt;&amp;lt; myMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;

    // 实际上，上述行代码创建了一个新的键值对，其中值被默认初始化为int的默认值（通常是0）
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 코드 자체는 프로그램 충돌을 직접적으로 유발하지는 않지만, 이러한 암묵적인 삽입 동작은 특정 상황에서 예상치 못한 부작용(예: 리소스 누수 또는 예기치 않은 상태 변경)을 초래할 수 있습니다. 더 나쁜 경우, 다중 스레드 환경에서 초기화되지 않은 메모리 영역에 대한 동시 접근은 프로그램 충돌로 이어질 수도 있습니다.&lt;/p&gt;
&lt;p&gt;이러한 문제가 발생하는 것을 방지하기 위해, &lt;code&gt;std::map::find()&lt;/code&gt;BOLD_3&lt;code&gt;std::map::count()&lt;/code&gt;BOLD_4&lt;code&gt;std::map::insert()&lt;/code&gt; 요소를 명시적으로 삽입하는 것이 좋습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::map&amp;lt;std::string, int&amp;gt; safeMap;
if (safeMap.count(&amp;quot;nonexistent_key&amp;quot;) == 0) {
    std::cout &amp;lt;&amp;lt; &amp;quot;Key does not exist.&amp;quot; &amp;lt;&amp;lt; std::endl;
} else {
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for existing key: &amp;quot; &amp;lt;&amp;lt; safeMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;
}

// 或者明确插入一个键值对，指定初始值
safeMap.insert({ &amp;quot;new_key&amp;quot;, 0 });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;만약 map 컨테이너 내부에 저장된 객체가 포인터 타입이라면, 자동 삽입 동작은 초기화되지 않은 포인터를 저장하며, 이 포인터를 사용하는 모든 작업은 프로그램 충돌을 야기할 수 있습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>pstack으로 프로세스 멈춤 현상 진단</title>
        <link>https://blog.ttf248.life/ko/p/pstack-troubleshooting-process-hang/</link>
        <pubDate>Sat, 24 Feb 2024 23:55:59 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/pstack-troubleshooting-process-hang/</guid>
        <description>&lt;p&gt;소프트웨어 개발 및 운영 환경에서 프로세스 응답 없음 현상이 자주 발생하는데, 이로 인해 시스템 성능 저하나 서비스 중단이 발생할 수 있습니다. 본 문서에서는 pstack 도구를 사용하여 프로세스 응답 없음 문제를 진단하고, 프로세스 스택 정보를 분석하여 문제 원인을 파악하고 해결하는 방법을 설명합니다.&lt;/p&gt;
&lt;p&gt;배경: 위험 관리 시스템 하위 서비스가 응답하지 않는 상태로 멈춰 위험 관리 서비스를 사용할 수 없게 되었습니다. 서비스 가용성 모니터링 부족으로 인해 프로세스 응답 없음 상황을 즉시 파악하지 못해 시스템이 중단되었습니다.&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;프로세스 응답 없음은 프로세스가 중단되어 응답하지 않지만 종료되지 않은 상태를 의미합니다. 이는 데드락, 리소스 고갈, 예외 등 다양한 원인으로 발생할 수 있습니다. 이러한 문제를 해결하기 위해 pstack 도구를 사용하여 프로세스의 스택 정보를 분석하고 문제의 근본 원인을 파악할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;단계&#34;&gt;단계
&lt;/h2&gt;&lt;p&gt;pstack은 일반적으로 gdb(GNU 디버거)와 함께 제공되는 유용한 도구입니다. 다음 명령어를 통해 설치할 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt-get install gdb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;프로세스 ID 획득: 먼저, 응답하지 않는 프로세스의 프로세스 ID(PID)를 얻어야 합니다. ps 명령어를 사용하여 모든 프로세스를 나열하고, 문제 해결이 필요한 프로세스 ID를 찾을 수 있습니다.
pstack 도구를 사용하여 프로세스 스택을 분석할 수 있습니다. 프로세스 ID를 얻은 후에는 pstack 도구를 사용하여 해당 프로세스의 스택 정보를 가져올 수 있습니다. 다음 명령어를 실행하세요:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pstack &amp;lt;PID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 프로세스의 스택 정보를 출력하여 현재 실행 중인 함수 호출 시퀀스를 보여줍니다. 이러한 정보를 분석하면 프로세스가 멈춘 위치를 파악하고 문제를 진단할 수 있습니다.&lt;/p&gt;
&lt;p&gt;스택 정보를 분석하면 프로세스가 멈추는 원인을 파악할 수 있습니다. 데드락, 무한 루프 또는 기타 예외 상황이 발견될 수 있으며, 잠금 해제나 코드 로직 수정 등 구체적인 상황에 맞는 조치를 취해야 합니다.&lt;/p&gt;
&lt;h2 id=&#34;사례&#34;&gt;사례
&lt;/h2&gt;&lt;p&gt;간단한 데모인데, 메인 함수 실행 후 서브 스레드를 새로 생성하고 실제 실행 함수가 무한 루프에 들어가 프로그램이 정상적으로 종료되지 않고 멈춰버리는 상태입니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cmake_minimum_required(VERSION 3.0.0)
project(pstack_main VERSION 0.1.0 LANGUAGES C CXX)

include(CTest)
enable_testing()

# 查找线程库
find_package(Threads REQUIRED)

add_executable(pstack_main main.cpp)

# 链接线程库
target_link_libraries(pstack_main PRIVATE Threads::Threads)

set(CPACK_PROJECT_NAME ${PROJECT_NAME})
set(CPACK_PROJECT_VERSION ${PROJECT_VERSION})
include(CPack)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;
#include &amp;lt;chrono&amp;gt;

void infiniteLoop() {
    while (true) {
        // 主线程进入死循环
    }
}

int main() {
    std::thread thread(infiniteLoop); // 创建一个线程，执行死循环函数
    thread.join(); // 等待线程结束
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;프로그램 시작, pstack 결과:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Thread 2 (Thread 0x7eff3619b700 (LWP 1315017)):
#0  infiniteLoop () at /root/pstack/main.cpp:6
#1  0x0000000000402ca9 in std::__invoke_impl&amp;lt;void, void (*)()&amp;gt; (__f=@0x2260eb8: 0x4029a6 &amp;lt;infiniteLoop()&amp;gt;) at /usr/include/c++/8/bits/invoke.h:60
#2  0x0000000000402b02 in std::__invoke&amp;lt;void (*)()&amp;gt; (__fn=@0x2260eb8: 0x4029a6 &amp;lt;infiniteLoop()&amp;gt;) at /usr/include/c++/8/bits/invoke.h:95
#3  0x0000000000403150 in std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt;::_M_invoke&amp;lt;0ul&amp;gt; (this=0x2260eb8) at /usr/include/c++/8/thread:244
#4  0x0000000000403126 in std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt;::operator() (this=0x2260eb8) at /usr/include/c++/8/thread:253
#5  0x000000000040310a in std::thread::_State_impl&amp;lt;std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt; &amp;gt;::_M_run (this=0x2260eb0) at /usr/include/c++/8/thread:196
#6  0x00007eff36bceb23 in execute_native_thread_routine () from /lib64/libstdc++.so.6
#7  0x00007eff36ea91ca in start_thread () from /lib64/libpthread.so.0
#8  0x00007eff361d58d3 in clone () from /lib64/libc.so.6
Thread 1 (Thread 0x7eff372e1740 (LWP 1315016)):
#0  0x00007eff36eaa6cd in __pthread_timedjoin_ex () from /lib64/libpthread.so.0
#1  0x00007eff36bceda7 in std::thread::join() () from /lib64/libstdc++.so.6
#2  0x00000000004029d2 in main () at /root/pstack/main.cpp:13
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;프로세스 응결의 원인은 데드루프이며, 메인 스레드가 데드루프에 진입하면 서브 스레드가 종료되지 않아 프로세스가 응결됩니다&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
