<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>네트워크 통신 on 향숙의 수첩</title>
        <link>https://ttf248.life/ko/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%86%B5%EC%8B%A0/</link>
        <description>Recent content in 네트워크 통신 on 향숙의 수첩</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ko</language>
        <lastBuildDate>Sun, 25 May 2025 14:10:37 +0800</lastBuildDate><atom:link href="https://ttf248.life/ko/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%86%B5%EC%8B%A0/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>백그라운드 서비스 TCP 통신 이상 점검</title>
        <link>https://ttf248.life/ko/p/backend-service-tcp-communication-troubleshooting/</link>
        <pubDate>Fri, 14 Feb 2025 22:54:13 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/backend-service-tcp-communication-troubleshooting/</guid>
        <description>&lt;p&gt;비즈니스 모델: 백엔드 서비스는 TCP를 통해 그룹의 시장 게이트웨이와 연결을 맺습니다. 각 연결 시에는 먼저 인증 요청을 보내고, 그 후 지속적으로 하트비트 패킷을 전송하여 연결 상태를 유지합니다.
하지만 어느 날, 서비스 연결 해제 경고 메시지를 받았습니다. 로그를 꼼꼼히 확인해 본 결과, 백엔드 서비스는 계속해서 하트비트 패킷을 전송하고 있었지만 상대방은 전혀 응답하지 않았음에도 불구하고 연결은 끊어지지 않고 있었습니다.&lt;/p&gt;
&lt;h2 id=&#34;현장-간략-설명&#34;&gt;현장 간략 설명
&lt;/h2&gt;&lt;p&gt;원래 회사에서 야근하며 프로젝트 진행을 추진 중이었는데, 업무 그룹 채팅방에 갑자기 경고 메시지가 떴다. 처음에는 예전 문제라고 생각했다. 네트워크 타임아웃으로 인해 하트비트 전송이 실패해서 연결이 끊어진 것 같았다. 하지만 로그를 자세히 확인해 보니 실제 상황은 그렇지 않았다. 백엔드에서 인증 로그인 메시지를 보냈지만 계속 응답을 받지 못했고, 동시에 하트비트는 지속적으로 전송되었지만 상대방은 어떠한 하트비트 데이터도 반환하지 않았다. 로그를 심층적으로 분석한 결과 다음과 같은 몇 가지 주요 문제가 드러났다:&lt;/p&gt;
&lt;p&gt;인가 메시지에 대한 응답이 없으면, 상대방 시스템이 재시동 중이라 인가 메시지가 적시에 처리되지 않았을 가능성이 매우 높습니다
승인되지 않은 상태에서 하트비트 데이터를 전송하는 문제: 조사 결과, 프로그램 로직의 결함이 원인입니다. 하트비트 전송 함수의 판단 로직에 문제가 있어 연결 상태만 확인하고 인증 상태를 확인하지 않았습니다.
서비스 연결이 끊어지면 재연결 메커니즘을 트리거하여 인증 메시지를 다시 보낼 수 있습니다&lt;/p&gt;
&lt;p&gt;현재, 해결해야 할 마지막 문제점은 서비스 연결이 끊어지지 않은 이유입니다. 이 문제의 해결을 위해서는 보다 심층적이고 세밀한 점검 작업이 필요합니다.&lt;/p&gt;
&lt;h2 id=&#34;네트워크-데이터-패킷-분석&#34;&gt;네트워크 데이터 패킷 분석
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;tcpdump&lt;/code&gt;는 매우 강력한 네트워크 패킷 캡처 도구로, 네트워크 데이터 패킷을 포착하는 데 사용할 수 있습니다. 네트워크 데이터 패킷을 분석함으로써 우리는 네트워크 통신의 세부 사항을 보다 직관적으로 이해할 수 있습니다. 여기서는 &lt;code&gt;tcpdump&lt;/code&gt;를 사용하여 네트워크 데이터 패킷을 포착하여 추가 분석을 할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/backend-service-tcp-communication-troubleshooting/20250220151952.png&#34;
	width=&#34;1126&#34;
	height=&#34;202&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;tcpdump&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;557&#34;
		data-flex-basis=&#34;1337px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;데이터를 분석해 보면 심박수는 계속 정상적으로 전송되고 있지만, 상대방 서버로부터는 아무런 데이터도 수신되지 않았고, 단지 &lt;code&gt;ACK&lt;/code&gt;만 받았기 때문에 연결이 자동으로 끊어지지 않고 있습니다&lt;/p&gt;
&lt;h2 id=&#34;일반적인-플래그-설명&#34;&gt;일반적인 플래그 설명
&lt;/h2&gt;&lt;p&gt;TCP 프로토콜에서 &lt;code&gt;PSH&lt;/code&gt;(Push)와 &lt;code&gt;ACK&lt;/code&gt;(Acknowledgment)는 데이터 전송과 흐름 제어를 위해 사용되는 중요한 플래그 비트입니다. 이들의 역할은 다음과 같습니다:&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;1-pshpush-flag&#34;&gt;&lt;strong&gt;1. PSH（Push Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;기능:
PSH 플래그는 &lt;strong&gt;수신 측이 버퍼에 있는 데이터를 상위 애플리케이션으로 즉시 푸시하도록 요청하는 역할&lt;/strong&gt;을 합니다(버퍼가 채워질 때까지 기다리지 않고). 이는 PSH 플래그가 있는 데이터 세그먼트를 받으면 수신 측은 운영체제 버퍼에 저장하기보다는 가능한 한 빨리 처리하여 애플리케이션에 전달합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;전형적인 장면&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP/HTTPS 요청 시(예: &lt;code&gt;GET /index.html&lt;/code&gt;) 클라이언트는 서버가 즉시 응답하기를 바라는 &lt;code&gt;PSH&lt;/code&gt;를 설정합니다&lt;/li&gt;
&lt;li&gt;SSH 프로토콜: 키보드 입력이 있을 때마다 &lt;code&gt;PSH&lt;/code&gt;가 트리거되어 입력 문자가 실시간으로 전송되도록 합니다&lt;/li&gt;
&lt;li&gt;실시간 통신: 비디오 스트리밍, 온라인 게임 등 저지연 시나리오에서는 &lt;code&gt;PSH&lt;/code&gt;를 사용하여 지연을 줄일 수 있습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;주의:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PSH는 필수가 아니며, 수신측은 해당 비트(flag bit)를 무시할 수 있습니다(데이터는 정상적으로 처리해야 합니다)&lt;/li&gt;
&lt;li&gt;보내는 쪽에서 &lt;code&gt;PSH&lt;/code&gt;를 설정하지 않을 수 있으며, 이 경우 받는 쪽은 자체 버퍼링 정책에 따라 데이터를 언제 보낼지 결정합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2-ackacknowledgment-flag&#34;&gt;&lt;strong&gt;2. ACK（Acknowledgment Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;기능:
ACK 플래그는 &lt;strong&gt;이전 데이터 세그먼트가 올바르게 수신되었음을 확인&lt;/strong&gt;합니다. 각 ACK에는 확인 번호(Acknowledgment Number)가 포함되어 있으며, 이는 예상되는 다음 바이트 시퀀스 번호를 나타냅니다. 이는 TCP 신뢰성 있는 전송의 핵심 메커니즘입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;작동 원리:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;송신자는 데이터 세그먼트를 보낼 때, 예상 수신자의 &lt;code&gt;ACK&lt;/code&gt; 값(예: &lt;code&gt;ACK = 시퀀스 번호 + 데이터 길이&lt;/code&gt;)을 함께 전송합니다&lt;/li&gt;
&lt;li&gt;수신 장치가 데이터를 수신하면, 수신 확인(&lt;code&gt;ACK&lt;/code&gt;) 세그먼트를 생성하여 수신된 데이터의 시퀀스 번호를 확인합니다&lt;/li&gt;
&lt;li&gt;송신자는 해당 &lt;code&gt;ACK&lt;/code&gt;를 수신한 후에야만 확인되지 않은 데이터를 재전송합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예시입니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;송신자가 시퀀스 번호가 &lt;code&gt;100~199&lt;/code&gt;인 데이터 세그먼트를 보냈다면, 예상되는 수신자의 &lt;code&gt;ACK&lt;/code&gt;는 &lt;code&gt;200&lt;/code&gt;이어야 한다&lt;/li&gt;
&lt;li&gt;수신자가 &lt;code&gt;100~199&lt;/code&gt; 범위 내의 특정 데이터를 받지 못하면, 송신자에게 재전송을 요청하기 위해 &lt;code&gt;ACK=150&lt;/code&gt;으로 알립니다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;psh와-ack의-조합&#34;&gt;PSH와 ACK의 조합
&lt;/h3&gt;&lt;p&gt;TCP 패킷에서 &lt;code&gt;PSH&lt;/code&gt;와 &lt;code&gt;ACK&lt;/code&gt;가 동시에 나타나는 경우는 다음과 같은 상황에서 흔히 볼 수 있습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;HTTP 요청 응답
클라이언트가 &lt;code&gt;POST&lt;/code&gt; 요청(데이터 포함)을 보낼 때, &lt;code&gt;PSH&lt;/code&gt;와 &lt;code&gt;ACK&lt;/code&gt;(이전 응답 확인)가 설정됩니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Client → Server: SYN, ACK=1 → 建立连接
Client → Server: PSH, ACK=1, 数据 → 发送请求数据
Server → Client: PSH, ACK=数据长度+1 → 返回响应
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SSH 핸드셰이킹 후 명령 전송
클라이언트가 명령을 입력하면 &lt;code&gt;PSH&lt;/code&gt; 및 &lt;code&gt;ACK&lt;/code&gt;가 포함된 데이터 세그먼트를 전송하여 명령이 즉시 전송되고 서버에서 처리되도록 합니다&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;다른-플래그-비트의-연관성&#34;&gt;다른 플래그 비트의 연관성
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;기호&lt;/th&gt;
&lt;th&gt;이름&lt;/th&gt;
&lt;th&gt;간략 설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;동기화&lt;/td&gt;
&lt;td&gt;초기화 연결 (세 번의 악수)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FIN&lt;/td&gt;
&lt;td&gt;종료&lt;/td&gt;
&lt;td&gt;연결 우아하게 닫기&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;재설정&lt;/td&gt;
&lt;td&gt;강제 연결 종료 (비정상 상황)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;URG&lt;/td&gt;
&lt;td&gt;긴급&lt;/td&gt;
&lt;td&gt;긴급 포인터 표시 (거의 사용하지 않음)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h3 id=&#34;요약&#34;&gt;요약
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;데이터가 최대한 빨리 애플리케이션 계층에 도달하도록 하여 지연 시간을 줄이는 데 중점을 두고 있습니다&lt;/li&gt;
&lt;li&gt;데이터의 신뢰성 있는 전송에 중점을 두고, 패킷 손실이나 순서 변경을 방지합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;두 가지는 협력하여 TCP 프로토콜의 효율성과 안정성을 균형 있게 맞췄다&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
