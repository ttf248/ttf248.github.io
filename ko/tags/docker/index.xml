<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Docker on 향숙의 수첩</title>
        <link>https://ttf248.life/ko/tags/docker/</link>
        <description>Recent content in Docker on 향숙의 수첩</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ko</language>
        <lastBuildDate>Sun, 25 May 2025 14:10:37 +0800</lastBuildDate><atom:link href="https://ttf248.life/ko/tags/docker/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>AI 개발 2년: 도커 출시 전과 비슷한 상태</title>
        <link>https://ttf248.life/ko/p/ai-development-two-years-docker-pre-release/</link>
        <pubDate>Thu, 20 Feb 2025 18:16:37 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/ai-development-two-years-docker-pre-release/</guid>
        <description>&lt;p&gt;인공지능(AI)은 최근 몇 년간 기술 분야에서 가장 핫한 논제 중 하나이며, 특히 지난 2년 동안 AI 기술이 비약적으로 발전했습니다. 심층 학습, 자연어 처리는 물론 컴퓨터 비전, 자동화 의사 결정 시스템까지, AI의 적용 사례가 끊임없이 등장하고 있습니다. 하지만 기술이 계속해서 도약을 이루고 있음에도 불구하고, AI는 Docker 출시 이전과 유사한 병목 현상에 직면해 있는데, 이는 시장을 진정으로 폭발시킬 만한 &amp;lsquo;경험 있는 애플리케이션&amp;rsquo;이 부족하기 때문입니다.&lt;/p&gt;
&lt;p&gt;AI가 발전한 지 2년 정도 되었는데, Docker가 처음 공개되기 전과 비슷한 상황입니다. 아직 게임 체인저와 같은 Killer App이 없고, 현재 기술을 기반으로 완벽한 적용 사례를 만들어내야 합니다. Docker는 새로운 기술을 많이 사용하지 않았지만, 전체적인 솔루션이 매우 합리적이었고 운영 및 개발 업무의 워크플로우를 변화시켰습니다.&lt;/p&gt;
&lt;h2 id=&#34;인공지능-발전-현황-기술은-이미-성숙했지만-적용은-아직-돌파구를-찾아야-한다&#34;&gt;인공지능 발전 현황: 기술은 이미 성숙했지만, 적용은 아직 돌파구를 찾아야 한다
&lt;/h2&gt;&lt;p&gt;기술적인 측면에서 볼 때, AI는 지난 2년 동안 상당한 발전을 이루었습니다. OpenAI의 GPT 시리즈 모델이든, Google의 BERT, DeepMind의 Alpha 시리즈든, AI의 처리 능력은 이전 예상보다 훨씬 뛰어넘었습니다. 특히 자연어 처리 분야에서 GPT-4와 같은 모델은 강력한 생성 능력을 갖추는 것은 물론 이해력과 추론 능력에서도 놀라운 성과를 보여주고 있습니다.&lt;/p&gt;
&lt;p&gt;하지만, 기술이 비약적으로 발전하고 있음에도 불구하고 AI의 실제 적용은 일정한 어려움에 직면해 있습니다. Docker 출시 이전과 비슷하게, AI의 잠재력은 매우 크지만 아직 널리 보급되어 산업을 변화시킬 수 있는 진정한 &amp;lsquo;게임 체인저&amp;rsquo; 애플리케이션은 나타나지 않았습니다. 많은 사람들이 AI의 전망에 대해 이야기하지만, 직접적인 혁신적 변화를 가져올 수 있는 적용 사례를 찾기는 어려울 것입니다. 많은 AI 애플리케이션이 여전히 초기 단계에 머물러 있으며, 대부분 추가 통합 및 최적화가 필요합니다.&lt;/p&gt;
&lt;h2 id=&#34;도커와-ai의-유사성-기술-자체가-혁신이-아니라-솔루션이-핵심이다&#34;&gt;도커와 AI의 유사성: 기술 자체가 혁신이 아니라, 솔루션이 핵심이다
&lt;/h2&gt;&lt;p&gt;만약 Docker 출시 이전의 역사를 되돌아보면, 당시 기술 환경과 AI의 발전 현황 사이에 많은 유사점을 발견하기 어렵지 않습니다. Docker가 출시되기 전, 컨테이너 기술은 새로운 것이 아니었고, 초기 LXC(Linux Containers)와 가상화 기술들은 이미 컨테이너화의 기본적인 능력을 갖추고 있었습니다. 하지만 Docker는 기존 기술을 교묘하게 통합하고 최적화하여 더욱 간단하고 직관적이며 효율적인 솔루션을 제시했습니다. 이 솔루션은 획기적인 기술을 도입하지 않았지만, 운영 및 개발 과정에서 많은 어려움을 해결하고 소프트웨어의 배포, 확장 및 관리 프로세스를 크게 단순화했습니다.&lt;/p&gt;
&lt;p&gt;동일하게도 AI 분야 또한 유사한 상황에 직면해 있습니다. 현재의 AI 기술은 더 이상 “새로운 물건”이 아니지만, 진정으로 대규모 적용을 달성하기 위해서는 Docker처럼 기존 기술을 융합하고 최적화하여 합리적인 애플리케이션 방안을 형성하는 완벽한 실행 사례가 여전히 필요합니다. AI의 핵심 애플리케이션은 새로운 기술 돌파구에 의존하기보다는 기존 기술을 통합하여 실제 비즈니스에서 발생하는 문제점과 요구사항을 해결하는 데 달려 있을 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;ai의-도커-순간은-어떻게-찾아야-할까요&#34;&gt;AI의 “도커 순간”은 어떻게 찾아야 할까요?
&lt;/h2&gt;&lt;p&gt;AI 기술이 진정으로 널리 활용되려면 몇 가지 측면에서 노력해야 합니다&lt;/p&gt;
&lt;p&gt;실제 상황에 대한 심층적인 분석
현재 많은 AI의 적용 사례는 아직 실험적인 성격이 강하고 대규모로 실제 적용되지는 못하고 있습니다. 예를 들어, AI 고객 서비스나 지능형 추천과 같은 분야는 널리 사용되고 있지만 기능에 여러 가지 한계가 있으며 업계의 난관을 돌파하지 못했습니다. 진정한 도약은 전통적인 방법으로 오랫동안 어려움을 겪어왔던 의료, 제조업, 물류와 같은 산업에서 발생할 수 있습니다. AI는 더욱 효율적인 데이터 처리 및 예측 분석을 통해 기업이 이러한 복잡한 시나리오에서 효율성을 높이고 비용을 절감하도록 도울 수 있습니다.&lt;/p&gt;
&lt;p&gt;제품화 및 사용 편의성
Docker와 같이 컨테이너화 프로세스를 간소화하여 운영 효율성을 높이는 것처럼, AI 제품의 사용 편의성 또한 매우 중요합니다. AI의 보급은 기술의 보급일 뿐만 아니라, 제품화된 AI의 보급입니다. AI를 일상적인 워크플로우에 통합하고, 사용자가 심도 있는 기술 이해 없이도 이러한 도구를 쉽게 사용할 수 있도록 하는 것이 AI 상용화를 위한 중요한 단계입니다.&lt;/p&gt;
&lt;p&gt;생태 건설과 표준화
어떤 새로운 기술이라도 널리 사용되기 위해서는 생태계 구축이 필수적입니다. Docker가 빠르게 성장할 수 있었던 이유는 바로 개방성과 호환성 덕분이었으며, 개발자들이 다양한 클라우드 플랫폼, 도구 및 서비스와 쉽게 연동할 수 있도록 해주었기 때문입니다. 마찬가지로 AI의 미래 또한 생태계 구축에 달려 있습니다. AI의 표준화, 모델 공유, 데이터 개방, 그리고 기술의 통합성은 AI가 광범위한 산업적 활용을 이룰 수 있는지 여부에 영향을 미칠 것입니다.&lt;/p&gt;
&lt;h2 id=&#34;결론적으로-ai의-미래는-가능성으로-가득-차-있지만-더욱-완벽한-해결책이-필요합니다&#34;&gt;결론적으로, AI의 미래는 가능성으로 가득 차 있지만, 더욱 완벽한 해결책이 필요합니다
&lt;/h2&gt;&lt;p&gt;비록 AI 기술이 지난 2년간 상당한 진전을 이루었지만, 현재는 아직 “획기적인 응용 분야가 없는” 단계에 머물러 있습니다. Docker 출시 전의 컨테이너화 기술과 마찬가지로, AI 역시 합리적인 적용 시나리오를 통해 기존 기술을 비즈니스 요구사항과 심층적으로 융합해야 진정으로 대규모 적용 및 보급이 가능합니다. 기술 혁신은 물론 중요하지만, 프로세스를 간소화하고 효율성을 높이는 솔루션이야말로 기술의 보급과 발전을 더욱 촉진할 수 있습니다.&lt;/p&gt;
&lt;p&gt;미래에는 AI가 Docker처럼 획기적인 기술 돌파구가 아닌 기존 기술을 통합하여 완벽한 애플리케이션 시나리오를 구축함으로써, 결국 우리의 업무와 생활 방식을 바꿀 수 있습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>도커 국내 이미지 프록시 만료</title>
        <link>https://ttf248.life/ko/p/docker-domestic-mirror-failure/</link>
        <pubDate>Sat, 04 Jan 2025 18:29:25 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/docker-domestic-mirror-failure/</guid>
        <description>&lt;p&gt;국내 서버에 도커를 배포하고, 배포 후 회사에서 이미지 센터를 제공하지 않는 경우, 개발자가 먼저 해야 할 일은 국내 이미지 가속 주소를 설정하는 것입니다. 그런데 오늘 우연히 서버 한 대가 있고, 이미지 가속 주소를 설정했는데 이미지를 가져오려고 하면 계속 가져오지 못합니다.&lt;/p&gt;
&lt;p&gt;데몬 오류: &lt;code&gt;https://registry-1.docker.io/v2/&lt;/code&gt;에서 헤더를 기다리는 동안 연결을 기다리던 중 요청이 취소되었습니다(Client.Timeout 초과)&lt;/p&gt;
&lt;p&gt;두 날이 지났지만 모든 서버가 복구되었고, 이 일이 검색어 순위에 오르지 않고, 국내 모든 미러 대리들이 멈췄다&lt;/p&gt;
&lt;h2 id=&#34;오류-해결-및-복구-시도&#34;&gt;오류 해결 및 복구 시도
&lt;/h2&gt;&lt;p&gt;처음에 다른 미러 이미지 주소로 전환을 시도하여 문제를 해결하고자 했지만, 기대와 달리 문제는 여전히 발생했습니다&lt;/p&gt;
&lt;p&gt;곧바로, 로컬 DNS 설정을 수정하기 시작하여 네트워크 해상도 수준에서 돌파구를 찾으려 했지만, 안타깝게도 여러 번의 디버깅 끝에 문제점은 여전히 남아 있었다&lt;/p&gt;
&lt;p&gt;현재, 로컬 네트워크의 안정성이 크게 의심받고 있어 즉시 휴대폰 핫스팟으로 전환하여 가능한 로컬 네트워크 문제점을 우회하려 했지만 결과는 낙담스러웠고, 문제는 전혀 개선될 기미가 보이지 않습니다&lt;/p&gt;
&lt;h2 id=&#34;문제-확산&#34;&gt;문제 확산
&lt;/h2&gt;&lt;p&gt;현재 &lt;strong&gt;국내에 배치된 몇 대의 서버&lt;/strong&gt;가 있으며, 모두 Docker 환경이 설치되어 있습니다. 이러한 서버에서 이미지를 가져오려고 시도했었는데, 다른 방법을 찾을 수 있을 것이라고 생각했지만 결과적으로는 단 한 건도 성공하지 못했고, 보고되는 오류 메시지가 모두 동일했습니다. 이는 문제가 특정 장비에 국한된 것이 아니라는 것을 의미합니다.&lt;/p&gt;
&lt;p&gt;더 자세히 조사해 보니 미러 에이전트가 갑자기 작동하지 않음을 확인했습니다. 이 긴급한 순간에 해외 머신으로 빠르게 전환하여 시도했고, 다행히 이미지 풀링은 여기서 정상적으로 복구되었습니다. 이는 문제의 원인이 국내 네트워크 링크나 관련 설정에 있을 가능성이 높다는 것을 의미합니다.&lt;/p&gt;
&lt;h2 id=&#34;전략-조정-우회-해결&#34;&gt;전략 조정: 우회 해결
&lt;/h2&gt;&lt;p&gt;국내에서 직접 이미지를 가져오는 경로가 여러 차례 막히고 해외 이미지는 정상적으로 접근할 수 있다는 점을 고려하여, 프로젝트를 최대한 빠르게 진행하기 위해 우회적인 전술을 채택합니다. 먼저 해외 서버로 전환하여 필요한 이미지를 성공적으로 가져온 후, 이를 국내 이미지 저장소에 푸시하여 “데이터 다리”를 구축합니다.&lt;/p&gt;
&lt;p&gt;동시에 Dockerfile 파일도 수정하여 이미지 주소를 국내 환경에 적합한 주소로 변경하고, 다시 이미지를 빌드하여 최종적으로 성공적으로 배포했습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>사무실 이전에 서버 접속이 안 됩니다</title>
        <link>https://ttf248.life/ko/p/office-migration-server-unavailable/</link>
        <pubDate>Sat, 11 Mar 2023 01:42:05 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/office-migration-server-unavailable/</guid>
        <description>&lt;p&gt;행정 공지, 사무실 위치 변경, 기존 2층에서 15층으로 이전, 평범한 자리 이동입니다&lt;/p&gt;
&lt;h2 id=&#34;디자인-감각&#34;&gt;디자인 감각
&lt;/h2&gt;&lt;p&gt;사무실 건물&lt;/p&gt;
&lt;h2 id=&#34;이주&#34;&gt;이주
&lt;/h2&gt;&lt;p&gt;퇴근하면서 짐을 정리하고, 익숙하게 자리를 옮겨 새로운 자리에서 컴퓨터 배선을 조정하니 편안한 자세로 일하기 딱 좋네요&lt;/p&gt;
&lt;p&gt;(ÒωÓױ)！ 인터넷 연결했는데, 팀에서 주로 사용하는 서버에 접속이 안 돼요. 무선 네트워크로 바꿔보니 다시 정상적으로 접속되네요.&lt;/p&gt;
&lt;p&gt;처음에는 서버 네트워크 세그먼트 설정 문제라고 생각했습니다. 새로운 작업 공간의 유선 네트워크는 방화벽 구성 목록에 없어서 IT 동료에게 연락해서 조정하면 될 거라고 생각했죠. 그런데 이 네트워크 세그먼트는 여러 대의 서버가 있는데, 다른 서버들에 접속해 보니 모두 정상이었고, 점차 의심이 들기 시작했습니다. 전문적인 일은 전문가에게 맡기는 것이 좋다고 생각하고, 결국 운영 부서 동료들이 문제 해결을 위해 조사한 결과, 해당 서버에 &lt;code&gt;docker&lt;/code&gt;가 배포되어 있어서 서비스의 기본 네트워크 &lt;code&gt;docker0&lt;/code&gt;와 사무실 유선 네트워크 구성 세그먼트 간 충돌이 발생하여 전송된 데이터 패킷이 응답을 받지 못하고 &lt;code&gt;docker&lt;/code&gt; 서비스로 라우팅되었다는 것을 확인했습니다.&lt;/p&gt;
&lt;p&gt;다른 서버에는 &lt;code&gt;docker&lt;/code&gt; 서비스가 배포되어 있지 않아서, 이 서버만 사용하고 있고 가끔 컨테이너로 테스트 서비스를 배포하곤 했는데, 이런 상황을 마주할 줄은 몰랐다. 나중에 생각해보니, 그룹 전체가 같은 사무실 건물에 있고 IT 부서 동료들이 네트워크 세그먼트를 분할하면서 &lt;code&gt;172&lt;/code&gt;로 시작하는 주소를 사용한 것은 이상한 일이 아니라고 생각했다.&lt;/p&gt;
&lt;h2 id=&#34;docker0&#34;&gt;docker0
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# vim /etc/docker/daemon.json
{
    &amp;quot;bip&amp;quot;:&amp;quot;172.200.0.1/24&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;서비스를 재시작하고 새로운 네트워크로 전환하면 서버가 정상적으로 접근 가능해집니다&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;p&gt;도커 입문부터 실전까지 - docker0&lt;/p&gt;</description>
        </item>
        <item>
        <title>도커 두 세 가지 일</title>
        <link>https://ttf248.life/ko/p/docker-two-three-things/</link>
        <pubDate>Thu, 21 Jan 2021 09:26:07 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/docker-two-three-things/</guid>
        <description>&lt;p&gt;오랫동안 일하면서 접해왔던 것은 &lt;code&gt;CentOS&lt;/code&gt; 운영체제였고, &lt;code&gt;Mac&lt;/code&gt; 사용자나 &lt;code&gt;Ubuntu&lt;/code&gt; 사용자의 경우 일부 내용은 적용이 불가능할 수 있습니다&lt;/p&gt;
&lt;p&gt;설치 부분은 칭화대학교의 매뉴얼을 참고하시면 됩니다: &lt;a class=&#34;link&#34; href=&#34;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;설치&#34;&gt;설치
&lt;/h2&gt;&lt;p&gt;알 수 없는 신비한 힘으로 인해 국내 설치 시에는 클라우드 공급업체가 제공하는 저장소 주소를 사용하는 것이 좋으며, 여기서는 **알리바바 클라우드(阿里云)**를 추천합니다&lt;/p&gt;
&lt;h3 id=&#34;저장소-소스-주소를-설정하세요&#34;&gt;저장소 소스 주소를 설정하세요
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install yum-utils device-mapper-persistent-data lvm2 &amp;amp;&amp;amp; \
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;최신-버전을-배포하세요&#34;&gt;최신 버전을 배포하세요
&lt;/h3&gt;&lt;p&gt;도커는 일반적으로 사용되는 백그라운드 서비스이므로, 부팅 시 자동 시작으로 설정하는 것을 권장하며, 현재 명령어는 CentOS 7에 적용 가능합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum install -y docker-ce docker-ce-cli containerd.io &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;버전-배포-지정&#34;&gt;버전 배포 지정
&lt;/h3&gt;&lt;p&gt;쿠버네티스와 도커의 배포는 완전히 동기화되지 않았으므로, 다음으로 쿠버네티스를 배포해야 한다면 쿠버네티스 배포 지침을 참고하여 지정된 버전의 도커를 설치하십시오&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum list docker-ce --showduplicates | sort -r
sudo yum install -y docker-ce-18.09.2-3.el7 docker-ce-cli-18.09.2-3.el7 containerd.io-18.09.2-3.el7 &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;일반-사용자가-docker-권한을-추가합니다&#34;&gt;일반 사용자가 Docker 권한을 추가합니다
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo usermod -aG docker ${USER}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;제거&#34;&gt;제거
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum erase -y docker-ce docker-ce-cli containerd.io
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;일상-사용&#34;&gt;일상 사용
&lt;/h2&gt;&lt;h3 id=&#34;미러-가속&#34;&gt;미러 가속
&lt;/h3&gt;&lt;p&gt;여전히 예측할 수 없는 신비한 힘 때문에 이미지를 가져올 때 속도가 빠르지 않다. 이때 국내 클라우드 공급업체들이 나서서 다양한 가속 서비스를 제공하고 있으므로 &lt;strong&gt;알리바바 클라우드&lt;/strong&gt;를 추천한다.&lt;/p&gt;
&lt;p&gt;가속된 주소는 각자 스스로 등록하여 알리바운드 계정을 얻으세요. 이 서비스는 무료이며, 알리바운드는 또한 무료 이미지 빌드 서비스를 제공합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt; /etc/docker/daemon.json &amp;lt;&amp;lt;EOF
{
  &amp;quot;registry-mirrors&amp;quot;: [
    &amp;quot;https://docker.nju.edu.cn&amp;quot;,
    &amp;quot;https://mirror.baidubce.com&amp;quot;,
    &amp;quot;https://docker.m.daocloud.io&amp;quot;,
    &amp;quot;https://docker.mirrors.sjtug.sjtu.edu.cn&amp;quot;
  ]
}
EOF
systemctl daemon-reload &amp;amp;&amp;amp; \
systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;강력-추천하는-제어판&#34;&gt;강력 추천하는 제어판
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker volume create portainer_data &amp;amp;&amp;amp; \
docker run -d --name=portainer --restart=always -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:2.20.3-alpine
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;자주-사용하는-이미지-가져오기-모음&#34;&gt;자주 사용하는 이미지 가져오기 모음
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker pull rancher/rancher:stable &amp;amp;&amp;amp; docker pull  portainer/portainer-ce:2.0.1 &amp;amp;&amp;amp; \
docker pull centos:7 &amp;amp;&amp;amp; docker pull ubuntu:20.04 &amp;amp;&amp;amp; docker pull ubuntu:18.04 &amp;amp;&amp;amp; \
docker pull redis:5 &amp;amp;&amp;amp; docker pull redis:6 &amp;amp;&amp;amp; \
docker pull alpine:3.11 &amp;amp;&amp;amp; docker pull busybox:1.32 &amp;amp;&amp;amp; \
docker pull rabbitmq:3.7-management &amp;amp;&amp;amp; \
docker pull mariadb:10.2 &amp;amp;&amp;amp; \
docker pull nginx:1.18 &amp;amp;&amp;amp; docker pull nginx:1.19 &amp;amp;&amp;amp; \
docker pull mysql:5.6 &amp;amp;&amp;amp; docker pull mysql:8 &amp;amp;&amp;amp; \
docker pull elasticsearch:6.8.11 &amp;amp;&amp;amp; docker pull logstash:6.8.11 &amp;amp;&amp;amp; docker pull kibana:6.8.11 &amp;amp;&amp;amp; \
docker pull zookeeper:3.4 &amp;amp;&amp;amp; \
docker pull influxdb:1.7 &amp;amp;&amp;amp; docker pull grafana/grafana:7.3.1 &amp;amp;&amp;amp; \
docker pull percona:8 &amp;amp;&amp;amp; docker pull percona:5.6 &amp;amp;&amp;amp; \
docker pull cloverzrg/frps-docker:0.34.3 &amp;amp;&amp;amp; docker pull cloverzrg/frpc-docker:0.34.3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;자주-사용되는-명령어-조합&#34;&gt;자주 사용되는 명령어 조합
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/engine/reference/commandline/docker/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.docker.com/engine/reference/commandline/docker/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;컨테이너 실행 상태를 확인하고 &lt;code&gt;format&lt;/code&gt; 매개변수를 추가하여 자세한 컨테이너 정보를 확인합니다. 이때는 이미지 정보는 무시합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker ps --format &amp;quot;{{.Names}}: {{.Ports}}: {{.Size}}&amp;quot;
#portainer: 0.0.0.0:8000-&amp;gt;8000/tcp, 0.0.0.0:9000-&amp;gt;9000/tcp: 0B (virtual 172MB)
#influxdb: 0.0.0.0:8086-&amp;gt;8086/tcp: 183B (virtual 311MB)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;모든 컨테이너 중지&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker stop $(docker ps -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;모든 미러 삭제&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dokcer rmi $(docker images -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;이미지 내보내기&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; &amp;gt; -o XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이미지 내보내고 압축하기&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; | gzip &amp;gt; XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이미지 가져오기&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker load -i XXX.tar
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>리눅스 기반 Jmeter 압력 테스트 환경 구축</title>
        <link>https://ttf248.life/ko/p/linux-setup-jmeter-testing-environment/</link>
        <pubDate>Tue, 22 Dec 2020 10:12:50 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/linux-setup-jmeter-testing-environment/</guid>
        <description>&lt;p&gt;저자는 하드웨어에 대한 깊은 관심을 가지고 있으며, Jmeter를 사용하여 성능 테스트를 진행하고 CentOS 7에 Jmeter, InfluxDB 및 Grafana를 배포하는 과정을 기록했습니다. Jmeter 설치 및 명령어 사용법, InfluxDB의 특징 및 Docker 설치 방법, 그리고 Grafana의 간단한 배포 및 구성 방법을 공유했습니다. 고성능 프로그램 패턴에 대한 경험과 참고 자료를 정리했습니다.&lt;/p&gt;
&lt;h2 id=&#34;배경&#34;&gt;배경
&lt;/h2&gt;&lt;p&gt;다들 아시다시피 저는 하드웨어에 관심이 많습니다. 우연히 테스트팀에서 &lt;code&gt;Jmeter&lt;/code&gt;로 성능 테스트를 하고 있는데, 성능이 올라가지 않는 것을 발견했습니다. 호기심 많은 저라서 단번에 뛰어들어 회사에서 어떻게 압력 테스트를 하는지 살펴보기로 했습니다. 여기서 잠깐 일화 하나를 덧붙이자면, 아주 먼 옛날 오픈소스 차이나에서 어떤 게시글을 봤는데, 보기에도 더 멋진 성능 압력 테스트 그림을 그리는 방법에 대한 내용이었습니다. 테스트팀은 &lt;code&gt;windows&lt;/code&gt; 버전으로 실행되는 테스트를 지켜봤고, 시각화된 &lt;code&gt;TPS&lt;/code&gt; 데이터 표시가 이미 되어 있었습니다. 게다가 웹 패널을 설정하면 어떤 도움이 있을까요?&lt;/p&gt;
&lt;p&gt;생각은 자기만 생각하는 대로인데, 직접 해봐야 알 수 있어&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Don&amp;rsquo;t use GUI mode for load testing! only for Test creation and Test debuggin.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;공식적으로 권장하는 방법은 명령줄을 통해 부하 테스트 보고서를 얻고 GUI 방식으로 표시하는 것인데, 데이터 오류가 발생할 수 있나요? JMeter에 대한 이해는 깊지 않지만, 적어도 &lt;code&gt;Linux&lt;/code&gt; 버전 콘솔 패널을 굴려볼 만한 이유를 찾았습니다&lt;/p&gt;
&lt;p&gt;오픈소스차이나의 게시글인데, 핵심 컴포넌트 배포 방식이 썩 좋지 않고, 설치에 필요한 파일도 공중계정을 팔로우해야 다운로드할 수 있어서, 새세대 청년으로서 당연히 &lt;code&gt;Docker&lt;/code&gt;로 대체했다. 결국 서버가 국내에 있는 것이고, 국경 간 소스 주소 접근 속도는 매우 느리다. 적어도 이미지 서비스는 알리바이가 무료 가속을 제공한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker&lt;/code&gt; 설치 배포에 대한 내용은 여기서는 더 이상 설명하지 않겠습니다. 이전 기사를 참고하시기 바랍니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;다음 내용은 크게 두 부분으로 나뉩니다: 기본 테스트 환경 구성 요소 구축 및 각 구성 요소에 대한 간단한 설명&lt;/p&gt;
&lt;h2 id=&#34;jmeter&#34;&gt;Jmeter
&lt;/h2&gt;&lt;p&gt;Apache JMeter는 Apache 재단에서 개발한 Java 기반의 성능 테스트 도구입니다. 소프트웨어에 대한 부하 테스트를 위해 설계되었으며, 처음에는 웹 애플리케이션 테스트용으로 만들어졌지만 이후 다른 테스트 영역으로 확장되었습니다. 정적 파일, Java 마이크로 서비스, CGI 스크립트, Java 객체, 데이터베이스, FTP 서버 등과 같은 정적 및 동적 리소스를 테스트하는 데 사용할 수 있습니다. JMeter는 다양한 압력 범주에서 서버, 네트워크 또는 객체에 대한 막대한 부하를 시뮬레이션하여 강도를 테스트하고 전반적인 성능을 분석할 수 있습니다. 또한 JMeter는 어설션을 사용하여 스크립트를 생성하여 프로그램이 예상 결과를 반환하는지 확인하여 기능/회귀 테스트를 수행할 수 있습니다. 최대의 유연성을 위해 JMeter는 정규 표현식을 사용하여 어설션을 만들 수 있습니다.&lt;/p&gt;
&lt;p&gt;Apache JMeter는 정적 및 동적인 리소스(파일, 서블릿, Perl 스크립트, Java 객체, 데이터베이스 쿼리, FTP 서버 등)의 성능을 테스트하는 데 사용될 수 있습니다. 서버, 네트워크 또는 객체에 상당한 부하를 가하여 강도를 테스트하거나 다양한 유형의 압력 하에서 전체적인 성능을 분석할 수 있습니다. 성능의 그래프 분석을 수행하거나 대규모 동시 부하 테스트 시 서버/스크립트/객체를 테스트하는 데 사용할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;jmeter-배포-centos7&#34;&gt;JMeter 배포 CentOS7
&lt;/h3&gt;&lt;p&gt;JDK 실행 환경을 설치하고, Jmeter 설치 패키지를 다운로드합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install java-1.8.0-openjdk -y &amp;amp;&amp;amp; \
wget https://mirrors.bfsu.edu.cn/apache//jmeter/binaries/apache-jmeter-5.4.tgz &amp;amp;&amp;amp; tar -xf apache-jmeter-5.4.tgz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;환경 변수 설정&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export JMETER_HOME=$HOME/jmeter/apache-jmeter-5.4
export PATH=$JMETER_HOME/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;지메터-명령어&#34;&gt;지메터 명령어
&lt;/h3&gt;&lt;p&gt;최종적으로 &lt;code&gt;Grafana&lt;/code&gt; 제어판과 연결하면 &lt;code&gt;-l&lt;/code&gt; 파라미터를 입력하지 않고도 &lt;code&gt;web&lt;/code&gt; 제어대에서 데이터를 관찰할 수 있습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;jmeter -n -t /tmp/order-500-10s.jmx -l /tmp/jmeter-order-report-20200109/order-500-10s.jtl
# 一般不用测试结果和测试报告，简化命令
jmeter -n -t /tmp/order-500-10s.jmx
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;influxdb&#34;&gt;InfluxDB
&lt;/h2&gt;&lt;p&gt;InfluxDB는 Go 언어로 작성된 오픈 소스 분산 시계열, 이벤트 및 지표 데이터베이스이며 외부 의존성이 필요 없습니다. 이 데이터베이스는 현재 DevOps 모니터링 데이터, APP 메트릭, IoT 센서 데이터 및 실시간 분석 데이터와 같이 대량의 타임스탬프 데이터를 저장하는 데 주로 사용됩니다.&lt;/p&gt;
&lt;h3 id=&#34;인플럭스db-특징&#34;&gt;인플럭스DB 특징
&lt;/h3&gt;&lt;p&gt;인플럭스DB의 특징은 다음과 같은 9가지로 요약될 수 있습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;구조(패턴) 없음: 열의 개수가 임의일 수 있습니다&lt;/li&gt;
&lt;li&gt;메트릭 저장 기간을 설정할 수 있습니다&lt;/li&gt;
&lt;li&gt;시간 관련 함수(최소값, 최대값, 합계, 개수, 평균, 중앙값 등)를 지원하여 통계 처리에 용이하도록 합니다&lt;/li&gt;
&lt;li&gt;지원되는 저장 정책: 데이터의 삭제 및 수정에 사용할 수 있습니다.(InfluxDB는 데이터 삭제 및 수정 방법을 제공하지 않습니다)&lt;/li&gt;
&lt;li&gt;연속 쿼리 지원: 데이터베이스에서 자동으로 주기적으로 시작되는 일련의 문이며, 저장 정책과 함께 사용하면 InfluxDB 시스템 점유량을 줄일 수 있습니다&lt;/li&gt;
&lt;li&gt;네이티브 HTTP 지원, 내장된 HTTP API;&lt;/li&gt;
&lt;li&gt;SQL과 유사한 구문을 지원합니다&lt;/li&gt;
&lt;li&gt;클러스터 내 데이터 복제 수를 설정할 수 있습니다&lt;/li&gt;
&lt;li&gt;정기 샘플링 데이터를 지원하고, 다른 measurement에 기록하여 데이터의 세분화된 저장 기능을 제공합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;인플럭스db-도커-설치&#34;&gt;인플럭스DB 도커 설치
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir influxdb &amp;amp;&amp;amp; cd influxdb &amp;amp;&amp;amp; \
docker run -p 8086:8086 -d --name influxdb -v $PWD:/var/lib/influxdb influxdb:1.7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;컨테이너에 진입하여 명령을 실행하고, 수동으로 데이터베이스를 생성합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;root@bce0a55bbc72:/# influx
Connected to http://localhost:8086 version 1.7.10
InfluxDB shell version: 1.7.10
&amp;gt; 交互面板执行命令
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;인플럭스db-데이터베이스-및-사용자-생성&#34;&gt;인플럭스DB 데이터베이스 및 사용자 생성
&lt;/h3&gt;&lt;p&gt;데이터베이스 생성: create database jmeter_t2
데이터베이스 확인:
데이터베이스 전환: use jmeter_t2
사용자 생성: 비밀번호 &amp;lsquo;admin&amp;rsquo;으로 사용자 &amp;ldquo;admin&amp;quot;을 모든 권한으로 생성
사용자 보기&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; show users
user  admin
----  -----
admin true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;사용자 권한 &lt;code&gt;admin&lt;/code&gt;이 &lt;code&gt;true&lt;/code&gt;로 표시되면 데이터베이스 준비 작업은 완료되었습니다&lt;/p&gt;
&lt;h2 id=&#34;grafana&#34;&gt;Grafana
&lt;/h2&gt;&lt;p&gt;테스트 케이스를 작성하다 보니 차트 표시가 크게 필요하지 않다는 것을 알게 되었고, 인터페이스의 &lt;code&gt;tps&lt;/code&gt; 데이터는 명령줄에서 실행할 때 이미 관찰할 수 있으며, 더 중요한 것은 프로그램 내부의 소요 시간을 알고 싶다는 것이었습니다&lt;/p&gt;
&lt;p&gt;간단하게 &lt;code&gt;Grafana&lt;/code&gt; 대시보드 패널을 배포하고, 설정 파일을 가져와서 &lt;code&gt;InfluxDB&lt;/code&gt;에 연결합니다&lt;/p&gt;
&lt;p&gt;콘솔은 태그를 통해 테스트 결과를 필터링할 수 있으며, 일반적으로 &lt;code&gt;InfluxDB&lt;/code&gt; 데이터베이스 하나만 구성하면 됩니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;애플리케이션 이름&lt;/li&gt;
&lt;li&gt;테스트 사례 이름&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/linux-setup-jmeter-testing-environment/Snipaste_2021-03-09_19-44-22.png&#34;
	width=&#34;861&#34;
	height=&#34;357&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;grafana&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;241&#34;
		data-flex-basis=&#34;578px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -d --name=grafana -p 3000:3000 grafana/grafana:7.3.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;웹 버전은 샘플러 간격으로 인해 계산된 &lt;code&gt;TPS&lt;/code&gt; 및 관련 수치와 &lt;code&gt;Jmeter&lt;/code&gt; 집계 보고서가 일치하지 않을 수 있습니다. 참고 링크: &lt;a class=&#34;link&#34; href=&#34;https://www.vinsguru.com/jmeter-real-time-results-influxdb-grafana/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.vinsguru.com/jmeter-real-time-results-influxdb-grafana/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;자료에는 &lt;code&gt;리스너&lt;/code&gt;를 사용자 정의하는 방법도 설명되어 있습니다&lt;/p&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;고성능 프로그램 모드는 필연적으로 단일 루프 스레드이며, 어떠한 락, 대기열에 삽입 및 삭제도 불필요한 성능 손실을 야기한다&lt;/li&gt;
&lt;li&gt;핵심 비즈니스 로직의 처리 시간은 다른 코드 도입에 소요되는 시간보다 길기 때문에, 동시성만이 효율성을 효과적으로 높일 수 있다. 핵심 처리 시간이 충분히 짧다면 다른 코드를 신중하게 도입하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;JMeter 시리즈의 JMeter + Grafana + InfluxDB 실시간 모니터링&lt;/li&gt;
&lt;li&gt;인플럭스DB 공식 이미지&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/r/grafana/grafana&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Grafana 공식 이미지&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://jmeter.apache.org/download_jmeter.cgi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;JMeter 공식 웹사이트&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@jasonli.studio/to-install-apache-jmeter-in-centos7-294bc72a97ba&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;To install Apache JMeter in CentOS7&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        
    </channel>
</rss>
