<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>C&#43;&#43; on 향숙의 수첩</title>
        <link>https://blog.ttf248.life/ko/tags/c-/</link>
        <description>Recent content in C&#43;&#43; on 향숙의 수첩</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ko</language>
        <lastBuildDate>Wed, 28 May 2025 09:47:38 +0800</lastBuildDate><atom:link href="https://blog.ttf248.life/ko/tags/c-/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>C&#43;&#43; 비트 연산 기초: 비트별 값 가져오기 및 플래그 설정</title>
        <link>https://blog.ttf248.life/ko/p/cpp-bitwise-operations-basics-flags/</link>
        <pubDate>Fri, 17 Jan 2025 02:23:56 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/cpp-bitwise-operations-basics-flags/</guid>
        <description>&lt;p&gt;실제 C++ 개발에서 비트 연산은 흔히 사용되는 기술이며, 특히 시스템 상태, 플래그 또는 제어 비트를 처리할 때 매우 효율적인 솔루션을 제공합니다. 본 글에서는 예제를 통해 비트 연산을 사용하여 특정 플래그를 가져오고 설정하는 방법을 설명하겠습니다.&lt;/p&gt;
&lt;h3 id=&#34;비트-연산-기초-개념&#34;&gt;비트 연산 기초 개념
&lt;/h3&gt;&lt;p&gt;컴퓨터에서 데이터는 2진 비트(0과 1)로 저장되며, 비트 연산은 이 2진 비트에 대한 연산입니다. C++에는 몇 가지 일반적인 비트 연산자가 있습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;按位与（&amp;amp;）&lt;/strong&gt;: 특정 비트가 1인지 확인하는 데 사용됩니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按位或（|）&lt;/strong&gt;: 특정 비트를 1로 설정합니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按位异或（^）&lt;/strong&gt;: 특정 비트를 반전시키는 데 사용됩니다&lt;/li&gt;
&lt;li&gt;모든 비트를 반전합니다&lt;/li&gt;
&lt;li&gt;모든 비트를 몇 자리 내립니다&lt;/li&gt;
&lt;li&gt;모든 비트를 몇 자리 오른쪽으로 이동합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 예제에서는 __BOLD_2&lt;code&gt;wInfo&lt;/code&gt;에 대해 일련의 비트 연산을 수행하여 다양한 플래그를 통해 서로 다른 상태를 표현해야 합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;flowchart LR
    A[原始数值: 00010000] --&amp;gt; B[左移: 00010000 &amp;lt;&amp;lt; 1]
    B --&amp;gt; C[结果: 00100000]
    C --&amp;gt; D[右移: 00100000 &amp;gt;&amp;gt; 1]
    D --&amp;gt; E[结果: 00010000]

    subgraph 左移操作
        direction LR
        A --&amp;gt; B --&amp;gt; C
    end

    subgraph 右移操作
        direction LR
        C --&amp;gt; D --&amp;gt; E
    end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;요구-분석&#34;&gt;요구 분석
&lt;/h3&gt;&lt;p&gt;주어진 설명에 따르면, 우리는 다양한 상태를 나타내는 16비트 플래그가 있습니다. 이러한 상태는 각각 다른 이진 비트로 표현되며, 각 이진 비트는 특정 의미를 가집니다. 예를 들어:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실패했나?&lt;/li&gt;
&lt;li&gt;압축 여부&lt;/li&gt;
&lt;li&gt;증분 추가 여부&lt;/li&gt;
&lt;li&gt;후속 패키지 있나요?&lt;/li&gt;
&lt;li&gt;정상 요청 또는 로그아웃&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;비트-연산-구현&#34;&gt;비트 연산 구현
&lt;/h3&gt;&lt;p&gt;이러한 플래그 비트는 비트 연산을 통해 설정하고 가져올 것입니다. 구체적으로:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;按位取值&lt;/strong&gt;: 특정 비트 값(0 또는 1)을 가져옵니다&lt;/li&gt;
&lt;li&gt;설정된 비트를 1로 설정합니다&lt;/li&gt;
&lt;li&gt;설정된 비트를 0으로 만듭니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;우리는 먼저 이러한 플래그를 저장하기 위한 __ 类型的变量 __INLINE_CODE_0__을 정의합니다. 그런 다음 비트 연산을 통해 해당 플래그를 확인하고 설정합니다.&lt;/p&gt;
&lt;h3 id=&#34;c-예제-코드&#34;&gt;C++ 예제 코드
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;bitset&amp;gt;

// 定义标志位常量
const unsigned short BIT_0_FAIL = 1 &amp;lt;&amp;lt; 0;    // bit0 是否失败
const unsigned short BIT_1_COMPRESSED = 1 &amp;lt;&amp;lt; 1; // bit1 是否压缩
const unsigned short BIT_2_INCREMENT = 1 &amp;lt;&amp;lt; 2;  // bit2 是否增量
const unsigned short BIT_3_HAS_MORE = 1 &amp;lt;&amp;lt; 3;   // bit3 是否有后续包
const unsigned short BIT_5_CANCEL = 1 &amp;lt;&amp;lt; 5;     // bit5 正常请求(0)或注销(1)

// 检查某一位是否为1
bool isBitSet(unsigned short wInfo, unsigned short bitMask) {
    return (wInfo &amp;amp; bitMask) != 0;
}

// 设置某一位为1
void setBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo |= bitMask;
}

// 清除某一位（设置为0）
void clearBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo &amp;amp;= ~bitMask;
}

int main() {
    // 假设wInfo的初始值为0
    unsigned short wInfo = 0;

    // 设置bit0（失败标志）
    setBit(wInfo, BIT_0_FAIL);
    
    // 设置bit1（压缩标志）
    setBit(wInfo, BIT_1_COMPRESSED);
    
    // 打印wInfo的二进制值
    std::cout &amp;lt;&amp;lt; &amp;quot;wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    // 检查各个标志位
    std::cout &amp;lt;&amp;lt; &amp;quot;bit0 (是否失败): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_0_FAIL) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit1 (是否压缩): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_1_COMPRESSED) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit2 (是否增量): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_2_INCREMENT) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit3 (是否有后续包): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_3_HAS_MORE) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit5 (是否注销): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_5_CANCEL) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;

    // 清除bit1（压缩标志）
    clearBit(wInfo, BIT_1_COMPRESSED);
    
    // 打印更新后的wInfo
    std::cout &amp;lt;&amp;lt; &amp;quot;Updated wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;코드 실행, 추천 친구: &lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wInfo (in binary): 0000000000000011
bit0 (是否失败): 是
bit1 (是否压缩): 是
bit2 (是否增量): 否
bit3 (是否有后续包): 否
bit5 (是否注销): 否
Updated wInfo (in binary): 0000000000000001
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;코드-설명&#34;&gt;코드 설명
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;변위 연산(시프트 연산, AND 연산, OR 연산, XOR 연산, NOT 연산 등)을 사용하면 각 플래그 비트에 고유한 이진 위치를 할당할 수 있습니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;굵게_4&lt;/strong&gt;: _이탤릭체_8 &lt;strong&gt;굵게_5&lt;/strong&gt;: _이탤릭체_9 &lt;strong&gt;굵게_6&lt;/strong&gt;: _이탤릭체_10 &lt;strong&gt;굵게_7&lt;/strong&gt;: _이탤릭체_11 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특정 비트 위치를 1로 설정합니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특정 비트 위치를 0으로 설정합니다&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;요약&#34;&gt;요약
&lt;/h3&gt;&lt;p&gt;비트 연산을 통해 여러 상태 플래그를 효율적으로 처리할 수 있습니다. 특히 임베디드 개발, 네트워크 프로토콜, 시스템 상태 관리 등 실제 개발 환경에서 유용하며, 여러 이진 상태를 표현하여 공간을 절약하고 효율성을 높이는 데 자주 사용됩니다.&lt;/p&gt;
&lt;p&gt;이 블로그 게시물이 C++에서 비트 연산을 사용하여 비트 값 가져오기 및 설정 방법을 이해하는 데 도움이 되기를 바랍니다. 이러한 기술을 숙달하면 효율적이고 유지 관리하기 쉬운 코드를 작성하는 데 매우 유용합니다!&lt;/p&gt;</description>
        </item>
        <item>
        <title>GCC, GLIBC 및 C&#43;&#43; 프로그램 호환성 문제 심층 이해</title>
        <link>https://blog.ttf248.life/ko/p/deep-understanding-gcc-glibc-cpp-compatibility-issues/</link>
        <pubDate>Mon, 06 Jan 2025 19:51:16 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/deep-understanding-gcc-glibc-cpp-compatibility-issues/</guid>
        <description>&lt;p&gt;C++ 개발 분야에서 GCC와 GLIBC는 피할 수 없는 핵심 요소이며, 프로그램 출시 후 호환성 문제는 개발자를 자주 괴롭힌다. 본 논문에서는 이들의 본질을 심층적으로 분석하고, 호환성 문제의 근원과 대응 전략을 탐구한다.&lt;/p&gt;
&lt;h2 id=&#34;일-gcc-강력한-컴파일러-기반&#34;&gt;일. GCC: 강력한 컴파일러 기반
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;定义与功能&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;GCC는 GNU 컴파일러 컬렉션으로, GNU 프로젝트에서 개발한 오픈 소스 컴파일러 모음입니다. 이는 단순한 컴파일러가 아닌, C, C++, Objective-C, Fortran, Ada, Go 등 다양한 주요 프로그래밍 언어를 지원하며, 여러 언어 간의 통합 개발을 위한 원스톱 솔루션을 제공합니다.&lt;/li&gt;
&lt;li&gt;C++를 예로 들면, GCC는 클래스, 템플릿, 함수 오버로딩과 같은 복잡한 특징을 포함하는 소스 파일을 C++의 엄격한 문법 및 의미 규칙에 따라 분석하여 하위 레벨 기계가 이해하고 실행할 수 있는 명령어 시퀀스로 변환합니다. 이 과정은 어휘 분석, 구문 분석, 의미 분석, 최적화 및 코드 생성과 같은 여러 정교한 단계를 거칩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;编译流程详解&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;GCC는 먼저 소스 파일을 전처리합니다. 이 과정에서 모든 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;, &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt;, &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt;, &lt;strong&gt;INLINE_CODE_3&lt;/strong&gt;, &lt;strong&gt;INLINE_CODE_4&lt;/strong&gt;, &lt;code&gt;PI&lt;/code&gt;, __INLINE_CODE_6__을 처리하고, 전처리 후 소스 파일은 초기 “확장”됩니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编译阶段&lt;/strong&gt;: 전처리된 파일은 컴파일 단계에 진입하며, GCC는 C++ 언어 표준에 따라 소스 파일을 어셈블리 언어 코드로 변환합니다. 클래스 상속, 다형성 구현의 정확성, 함수 호출 인자 일치 여부 등 코드 구조를 꼼꼼히 검사하고, 문법 및 의미 규칙에 위배되는 오류가 발견되면 즉시 에러를 발생시켜 컴파일을 중단합니다. 예를 들어, 함수 선언과 정의의 인자 목록이 불일치하는 경우, GCC는 문제 지점을 정확하게 지적합니다.&lt;/li&gt;
&lt;li&gt;어셈블러는 이전 단계에서 생성된 어셈블리 코드를 기계어로 변환하여 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 확장자를 가진 목적 파일을 생성합니다. 이러한 목적 파일에는 기계가 직접 실행할 수 있는 이진 명령어가 포함되지만, 일반적으로 완전한 프로그램은 여러 모듈로 구성되어 있으며 각 모듈 간의 함수 및 변수 참조 관계는 아직 해결되지 않았기 때문에 독립적으로 실행될 수 없습니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链接阶段&lt;/strong&gt;: 실행 파일 생성의 마지막 단계입니다. 링커는 여러 오브젝트 파일과 필요한 라이브러리 파일(정적 또는 동적 라이브러리)을 통합합니다. 예를 들어, C++ 표준 템플릿 라이브러리의 컨테이너 클래스를 사용할 때 링크 시 해당 라이브러리 구현 코드를 찾아 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;、&lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; 등 컨테이너 기능을 올바르게 호출할 수 있도록 보장하여 완전한 실행 파일을 생성합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;두-번째-glibc-c-프로그램-실행의-숨은-기반&#34;&gt;두 번째, GLIBC: C++ 프로그램 실행의 숨은 기반
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;本质与作用&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;GLIBC는 GNU C Library로, GNU 생태계에서 C 표준 라이브러리를 구체적으로 구현한 것입니다. 이름에 C가 강조되어 있지만, C++ 프로그램 역시 C의 기본 부분을 상속받기 때문에 GLIBC에 크게 의존합니다. 메모리 관리와 같은 방대한 기초 함수들을 제공하며, C++ 초기 개발 및 성능이 중요하고 간결함을 추구하는 환경에서 자주 사용됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;与操作系统的协同&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;GLIBC는 운영체제와 응용 프로그램 간의 핵심적인 연결고리 역할을 합니다. C++ 프로그램이 파일을 열기 위해 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 함수를 사용하는 등 시스템 호출을 시작하면 GLIBC는 이 요청을 운영체제가 규정한 방식으로 캡슐화하여 커널에 전달하고, 커널 처리 후 결과를 응용 프로그램으로 반환합니다. 이를 통해 응용 프로그램은 파일 시스템, 네트워크, 프로세스 관리와 같은 다양한 시스템 리소스를 복잡한 시스템 호출 인터페이스 세부 사항을 몰라도 편리하게 사용할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;세-번째-c-프로그램-배포-후-호환성-문제-분석&#34;&gt;세 번째, C++ 프로그램 배포 후 호환성 문제 분석
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;GLIBC 版本差异引发的兼容困境&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;다양한 Linux 배포판은 종종 서로 다른 버전의 GLIBC를 탑재합니다. C++ 프로그램이 높은 버전의 GLIBC 환경에서 컴파일되면 새로운 기능이나 최적화된 함수 구현에 의존하게 될 수 있습니다. 예를 들어, 새로운 GLIBC 버전의 메모리 할당 알고리즘 개선을 활용하여 성능을 향상시키는 경우가 있습니다. 이러한 프로그램이 낮은 버전의 GLIBC 시스템으로 이식될 경우 해당 기능을 찾을 수 없거나(낮은 버전에서 도입되지 않았기 때문입니다) 함수 동작에 이상이 발생할 수 있으며(구현 로직이 새 버전과 차이가 있기 때문입니다), 이는 프로그램 충돌이나 오류를 유발할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;编译器差异导致的兼容性隐患&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;비록 모두 GCC 컴파일러를 사용하더라도, 서로 다른 버전의 GCC는 코드 생성, 표준 라이브러리 지원 및 C++ 기능 구현 방식에 차이가 있습니다. 최신 GCC 버전은 C++20과 같은 최신 표준의 새로운 기능(예: 모듈, 코루틴 등)을 완벽하게 지원할 수 있지만, 이러한 최첨단 기능을 사용하는 프로그램이 구버전 GCC에서 컴파일하면 컴파일러가 새로운 문법 구조를 인식하지 못해 오류가 발생합니다. 심지어 문법 오류가 없더라도, 각 GCC 버전별 최적화 전략이 다르기 때문에 생성되는 기계 코드의 실행 효율성 및 메모리 사용량에 큰 차이가 있을 수 있으며, 성능이 중요한 환경에서는 프로그램의 동작 양상이 크게 달라질 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;系统架构差异带来的挑战&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;C++ 프로그램은 x86, ARM, PowerPC 등 다양한 하드웨어 시스템 아키텍처에서 실행될 수 있습니다. 각 아키텍처는 고유한 명령어 집합, 메모리 레이아웃 및 데이터 정렬 요구 사항을 가지고 있습니다. 예를 들어 데이터 정렬의 경우, x86 아키텍처에서 정상적으로 작동하는 구조체 데이터 저장 방식이 ARM 아키텍처에서는 정렬 규칙이 다르기 때문에 메모리 접근 이상을 일으켜 프로그램 오류를 유발할 수 있습니다. 또한 GCC는 서로 다른 아키텍처로 컴파일될 때 생성되는 기계 코드의 차이가 매우 크며, 프로그램에 하드 코딩된 아키텍처 관련 명령어 또는 가정이 있는 경우, 여러 아키텍처에서 실행 시 빈번한 장애가 발생합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;네-가지-호환성-문제-대응-전략&#34;&gt;네 가지, 호환성 문제 대응 전략
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;静态链接库的运用&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;정적 링크 라이브러리 사용을 고려해 볼 수 있습니다. 프로그램이 필요로 하는 GLIBC와 같은 라이브러리 코드를 실행 파일에 직접 패키징하는 방식입니다. 이렇게 하면 프로그램 실행 시 대상 시스템의 특정 GLIBC 버전에 의존하지 않으므로, GLIBC 버전 불일치로 인한 문제를 효과적으로 피할 수 있습니다. 하지만 정적 링크는 실행 파일 크기를 크게 증가시키므로 저장 공간이 제한적인 환경에서는 장단점을 신중하게 고려해야 합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;容器化部署&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Docker와 같은 컨테이너화 기술을 활용하여 C++ 프로그램과 필요한 런타임 환경(특정 버전의 GCC, GLIBC 등)을 독립적인 컨테이너 내에 패키징합니다. 컨테이너 내부에서는 개발 환경과의 일관성을 유지하므로 어떤 기본 운영체제로 배포하든 프로그램이 예상대로 실행되며, 이로써 다양한 환경으로의 배포 복잡성이 크게 줄어듭니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;兼容性测试与持续集成&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;다양한 GLIBC 버전, GCC 버전 및 일반적인 시스템 아키텍처를 포괄하는 종합적인 호환성 테스트 체계를 구축한다. 프로그램 개발 과정에서 지속적 통합 도구를 활용하여 다양한 환경에서 정기적으로 자동화된 테스트를 실시하고, 호환성 문제가 발견되면 즉시 수정하여 잠재적인 위험을 초기 단계에서 제거함으로써 프로그램 출시 후 안정성을 확보한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;결론적으로, GCC와 GLIBC의 작동 방식을 깊이 이해하고, C++ 프로그램 호환성 문제의 근원을 정확히 파악하며, 유연하게 대응 전략을 활용하는 것은 모든 C++ 개발자가 안정적이고 플랫폼 간 애플리케이션을 구축하기 위한 필수적인 기술입니다. 그래야만 우리의 C++ 작품은 다양한 기술 생태계에서 자유롭게 이동할 수 있습니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>리눅스 백엔드 서비스 문자열 데이터 처리 - 속도 느림</title>
        <link>https://blog.ttf248.life/ko/p/linux-backend-slow-string-processing/</link>
        <pubDate>Wed, 13 Nov 2024 19:42:59 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/linux-backend-slow-string-processing/</guid>
        <description>&lt;p&gt;C++ 개발 프로젝트에서 사용자 정의 프로토콜을 사용하여 통신했는데, 이 프로토콜은 2차원 배열 패턴을 채택했습니다. 대량의 데이터를 처리할 때 프로토콜 내부에서 배열을 순회하고 시리얼화하여 로그를 생성하는 과정이 비효율적이었고, 이는 고부하 상황에서 시스템 응답 지연을 야기했습니다. 이로 인해 사업 부서로부터 시스템 멈춤 현상에 대한 피드백을 받았습니다.&lt;/p&gt;
&lt;h2 id=&#34;문제-파악&#34;&gt;문제 파악
&lt;/h2&gt;&lt;p&gt;문제 해결 과정에서 우선 시스템 성능을 분석한 결과, 대량의 데이터를 처리할 때 CPU 사용률이 눈에 띄게 증가하고 응답 시간이 길어지는 것을 확인했습니다. 시스템 로그를 분석한 결과, 2차원 배열 처리에 비효율적인 많은 양의 직렬화 작업이 수행되고 있었고, 이로 인해 시스템 성능이 저하되었습니다.&lt;/p&gt;
&lt;p&gt;도구 캡처 서비스의 스레드 정보를 분석한 결과, 로그 스레드는 대부분의 시간을 문자열 연결 처리에 소비하는 것으로 나타났다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;여기 오늘의 핵심인데, 다른 누적 방식에 따라 효율성의 차이가 엄청나다. 기존 코드에서는 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 연산자를 사용했는데, 이 방식은 빈번하게 임시 객체를 생성하므로 효율이 매우 낮다. 얼마나 심각한지 모르는 수준으로 비효율적이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;데모-검증&#34;&gt;데모 검증
&lt;/h2&gt;&lt;p&gt;프로젝트 코드를 기반으로 비즈니스 로직을 분리하고, 문자열 연결 효율성 문제를 검증하기 위한 간단한 데모를 작성했습니다. &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 下的 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; 编译器，__INLINE_CODE_2__BOLD_7&lt;code&gt;gcc8.5&lt;/code&gt; 编译器，&lt;strong&gt;INLINE_CODE_4&lt;/strong&gt; 모드에서 컴파일 및 실행하여 효율성을 비교했습니다.&lt;/p&gt;
&lt;h3 id=&#34;주요-사항-안내&#34;&gt;주요 사항 안내
&lt;/h3&gt;&lt;p&gt;프로젝트는 방법 네 가지를 사용하고 있는데, 테스트 데이터를 받기 전 독자들은 어떤 방식이 가장 효율적이고 어떤 방식이 가장 비효율적인지 먼저 생각해 볼 수 있습니다. 결과를 보고 저는 여전히 놀랐습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;각 필드를 문자열에 직접 연결합니다&lt;/li&gt;
&lt;li&gt;스트림(Stream)을 사용하여 각 필드를 연결하면 더 효율적이며, 특히 대량 데이터를 연결할 때 더욱 그렇습니다&lt;/li&gt;
&lt;li&gt;**方法 3（预分配内存的 &lt;strong&gt;인라인_4&lt;/strong&gt; &lt;em&gt;이탤릭체_3&lt;/em&gt;_： 미리 문자열에 충분한 메모리를 할당하면 메모리 재할당 비용을 줄여 성능을 향상시킬 수 있습니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法 4 (&lt;strong&gt;인라인__이탤릭_3&lt;/strong&gt; __)&lt;/strong&gt;: 매번 연결할 때마다 새로운 임시 문자열 객체를 생성하므로, 특히 대규모 연결 시 성능 저하가 발생합니다. 이는 매번 연결 시 새로운 메모리 할당 및 복사가 수반되기 때문입니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;참고 결과, 프로젝트가 효율이 가장 낮은 방식을 선택한 것을 알 수 있습니다&lt;/p&gt;
&lt;p&gt;더 나아가, 다양한 플랫폼 컴파일러의 최적화 효율을 분석해 보면, 마이크로소프트의 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 一如既往的优秀，针对字符串的优化效率很高，而 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; 컴파일러는 이 부분에서 최적화 효율이 다소 떨어지는 편입니다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;코드 실행 환경이 다른 기기에서 이루어지므로 데이터 간 직접적인 비교는 무의미하며, 각각의 조립 방식별 차이를 비교하는 것이 좋습니다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;windows 平台下的 vs2022 编译器

----------------------------------------
Data Generation Time: 0.054 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.053 seconds.
+ ostringstream Data merging took: 0.054 seconds.
+ Pre-reserved Data merging took: 0.045 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 16.108 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;linux 平台下的 gcc8.5 编译器
----------------------------------------
Data Generation Time: 0.108 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.100 seconds.
+ ostringstream Data merging took: 0.083 seconds.
+ Pre-reserved Data merging took: 0.057 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 29.298 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;전체-코드&#34;&gt;전체 코드
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;random&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;iomanip&amp;gt;

typedef std::vector&amp;lt;std::string&amp;gt; DataRow;
typedef std::vector&amp;lt;DataRow&amp;gt; DataGroup;

struct ResponsePackage
{
    std::string ErrorInfo;
    DataRow Head;
    std::string ClientId;
    std::string UUID;
    std::string MsgID;
    std::string SessionID;
    std::string ExtraInfo1;
    std::string ExtraInfo2;
    DataGroup DataBody;
};

// Generate specified length of random string
std::string generateRandomString(size_t length)
{
    const char charset[] = &amp;quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&amp;quot;;
    const size_t max_index = sizeof(charset) - 1;
    std::string random_string;
    random_string.reserve(length);

    std::random_device rd;
    std::mt19937 generator(rd());
    std::uniform_int_distribution&amp;lt;&amp;gt; distribution(0, max_index);

    for (size_t i = 0; i &amp;lt; length; ++i)
    {
        random_string += charset[distribution(generator)];
    }

    return random_string;
}

void create_large_string()
{
    // Example request package with 50 fields
    ResponsePackage requestPackage;

    requestPackage.Head = {
        &amp;quot;Field1&amp;quot;, &amp;quot;Field2&amp;quot;, &amp;quot;Field3&amp;quot;, &amp;quot;Field4&amp;quot;, &amp;quot;Field5&amp;quot;,
        &amp;quot;Field6&amp;quot;, &amp;quot;Field7&amp;quot;, &amp;quot;Field8&amp;quot;, &amp;quot;Field9&amp;quot;, &amp;quot;Field10&amp;quot;,
        &amp;quot;Field11&amp;quot;, &amp;quot;Field12&amp;quot;, &amp;quot;Field13&amp;quot;, &amp;quot;Field14&amp;quot;, &amp;quot;Field15&amp;quot;,
        &amp;quot;Field16&amp;quot;, &amp;quot;Field17&amp;quot;, &amp;quot;Field18&amp;quot;, &amp;quot;Field19&amp;quot;, &amp;quot;Field20&amp;quot;,
        &amp;quot;Field21&amp;quot;, &amp;quot;Field22&amp;quot;, &amp;quot;Field23&amp;quot;, &amp;quot;Field24&amp;quot;, &amp;quot;Field25&amp;quot;,
        &amp;quot;Field26&amp;quot;, &amp;quot;Field27&amp;quot;, &amp;quot;Field28&amp;quot;, &amp;quot;Field29&amp;quot;, &amp;quot;Field30&amp;quot;,
        &amp;quot;Field31&amp;quot;, &amp;quot;Field32&amp;quot;, &amp;quot;Field33&amp;quot;, &amp;quot;Field34&amp;quot;, &amp;quot;Field35&amp;quot;,
        &amp;quot;Field36&amp;quot;, &amp;quot;Field37&amp;quot;, &amp;quot;Field38&amp;quot;, &amp;quot;Field39&amp;quot;, &amp;quot;Field40&amp;quot;,
        &amp;quot;Field41&amp;quot;, &amp;quot;Field42&amp;quot;, &amp;quot;Field43&amp;quot;, &amp;quot;Field44&amp;quot;, &amp;quot;Field45&amp;quot;,
        &amp;quot;Field46&amp;quot;, &amp;quot;Field47&amp;quot;, &amp;quot;Field48&amp;quot;, &amp;quot;Field49&amp;quot;, &amp;quot;Field50&amp;quot;
    };

    requestPackage.ClientId = &amp;quot;ClientID&amp;quot;;
    requestPackage.UUID = &amp;quot;UUID&amp;quot;;
    requestPackage.MsgID = &amp;quot;MsgID&amp;quot;;
    requestPackage.SessionID = &amp;quot;SessionID&amp;quot;;
    requestPackage.ExtraInfo1 = &amp;quot;ExtraInfo1&amp;quot;;
    requestPackage.ExtraInfo2 = &amp;quot;ExtraInfo2&amp;quot;;

    // Start timing for data generation
    auto start_gen = std::chrono::high_resolution_clock::now();

    // Generate 10,000 rows of data, each with 50 fields
    for (size_t i = 0; i &amp;lt; 10000; ++i)
    {
        DataRow dataRow(50, &amp;quot;This is a test string&amp;quot;);
        requestPackage.DataBody.push_back(dataRow);
    }

    // End timing for data generation
    auto end_gen = std::chrono::high_resolution_clock::now();
    std::chrono::duration&amp;lt;double&amp;gt; duration_gen = end_gen - start_gen;

    // Display result generation time
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Generation Time: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_gen.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    // Data merging using different methods
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Performance:\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    {
        // Method 1: Using &#39;+=&#39; string concatenation
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (+=) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 2: Using ostringstream
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::ostringstream bodys;
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::ostringstream body;
            body &amp;lt;&amp;lt; &amp;quot;This is a test string&amp;quot;;
            for (auto&amp;amp; item : vec)
            {
                body &amp;lt;&amp;lt; item &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            }
            bodys &amp;lt;&amp;lt; body.str() &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ ostringstream Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 3: Pre-allocated memory
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys;
        bodys.reserve(1000 * 50 * 20); // Pre-allocate enough memory
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            body.reserve(50 * 20); // Pre-allocate memory for each row
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Pre-reserved Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 4: Using &#39;bodys = bodys + body + &amp;quot;\n&amp;quot;&#39;
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body = body + item + &amp;quot; &amp;quot;; // Note the use of &#39;body = body + item&#39;
            }
            bodys = bodys + body + &amp;quot;\n&amp;quot;; // Again, using &#39;bodys = bodys + body&#39;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (bodys = bodys + body + \&amp;quot;\\n\&amp;quot;) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Complete.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;
}

int main()
{
    try
    {
        create_large_string();
    }
    catch (const std::exception&amp;amp; e)
    {
        std::cerr &amp;lt;&amp;lt; &amp;quot;Caught exception: &amp;quot; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\nProgram finished.\n&amp;quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43; 람다 표현식 매개변수 생명 주기</title>
        <link>https://blog.ttf248.life/ko/p/cpp-lambda-parameter-lifetime/</link>
        <pubDate>Wed, 13 Nov 2024 19:23:02 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/cpp-lambda-parameter-lifetime/</guid>
        <description>&lt;p&gt;C++에서 람다 표현식은 외부 변수를 캡처하여 사용할 수 있는 편리한 익명 함수입니다. 이는 람다를 유연한 프로그래밍 도구로 만듭니다. 하지만 람다 표현식의 매개변수 생명 주기는 특히 캡처 및 전달 시 특별히 주의해야 할 측면입니다.&lt;/p&gt;
&lt;h3 id=&#34;람다-표현식의-매개변수-생명-주기&#34;&gt;람다 표현식의 매개변수 생명 주기
&lt;/h3&gt;&lt;p&gt;람다 표현식의 매개변수 수명은 일반적으로 다른 C++ 함수와 동일합니다. 함수의 매개변수는 함수 호출 시 존재하며, 호출이 종료되면 수명이 끝납니다. 하지만 람다 표현식이 외부 변수를 캡처할 수 있기 때문에 매개변수의 수명은 캡처 방식에 영향을 받기도 합니다.&lt;/p&gt;
&lt;h3 id=&#34;포획과-매개변수-생명주기의-관계&#34;&gt;포획과 매개변수 생명주기의 관계
&lt;/h3&gt;&lt;h4 id=&#34;21-외부-변수-캡처&#34;&gt;2.1 외부 변수 캡처
&lt;/h4&gt;&lt;p&gt;C++ 람다 표현식은 외부 변수를 두 가지 방식으로 캡처할 수 있습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;값 캡처를 통해 외부 변수의 값이 람다 내부에 복사되고, 람다 내부의 복사본은 람다의 생명주기에 의해 제어됩니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按引用捕获&lt;/strong&gt;: 클로저를 통해 외부 변수 참조가 유지되며, 람다 내부의 참조는 원본 외부 변수를 가리키고, 생명 주기는 외부 변수에 의존합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda_by_value = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };  // 捕获x的副本
auto lambda_by_reference = [&amp;amp;x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };  // 捕获x的引用

lambda_by_value();  // 打印10
lambda_by_reference();  // 打印10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;캡처된 변수는 다음과 같은 수명을 갖습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;按值捕获&lt;/strong&gt;: 캡처된 시점에 외부 변수의 값이 lambda에 복사되고, lambda의 수명이 종료될 때 복사본이 파괴됩니다&lt;/li&gt;
&lt;li&gt;람다가 외부 변수의 참조를 보유합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;람다-매개변수&#34;&gt;람다 매개변수
&lt;/h4&gt;&lt;p&gt;람다 함수의 파라미터는 일반 함수 파라미터와 유사하며, 그 수명은 람다 함수 내에서만 유효합니다. 즉, 람다 호출 시 파라미터가 생성되고, 호출이 끝나면 파라미터의 수명이 종료됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto lambda = [](int a, int b) {
    std::cout &amp;lt;&amp;lt; a + b &amp;lt;&amp;lt; std::endl;
};
lambda(5, 10);  // a和b在这里是lambda的参数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 예제에서 __INLINE_CODE_0__BOLD_2&lt;code&gt;b&lt;/code&gt;은 람다 표현식의 매개변수이며, 람다 호출 시 생성되고 람다 실행 종료 후 파괴됩니다&lt;/p&gt;
&lt;h3 id=&#34;외부-변수-캡처-시-라이프사이클-문제&#34;&gt;외부 변수 캡처 시 라이프사이클 문제
&lt;/h3&gt;&lt;h4 id=&#34;람다-외부에서-캡처된-변수가-유효한가&#34;&gt;람다 외부에서 캡처된 변수가 유효한가?
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;람다 호출 후 외부 변수가 파괴되더라도 람다 내부에서는 여전히 외부 변수의 복사본을 보유합니다. 따라서 외부 변수가 더 이상 존재하지 않더라도 람다 내부의 복사본은 안전하게 사용할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x 在lambda调用后修改
lambda();  // 打印10，捕获的是x的副本
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;按引用捕获&lt;/strong&gt;: 람다가 외부 변수의 참조를 캡처하는 경우, 람다 내부에서 해당 참조에 대한 접근은 외부 변수의 수명 주기(lifetime)에 의존합니다. 만약 외부 변수가 람다 실행 전에 소멸된다면, dangling reference 문제가 발생하여 정의되지 않은 동작을 초래할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [&amp;amp;x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x 在lambda调用前修改
lambda();  // 打印20，捕获的是x的引用
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;람다 함수의 실행 순서가 불확실하다면, 람다 함수가 실행될 때 캡처된 외부 변수가 유효한지 확인하는 것이 중요합니다&lt;/p&gt;
&lt;/blockquote&gt;</description>
        </item>
        <item>
        <title>GCC 버전 업그레이드로 인한 프로그램 충돌: 비표준 코드의 잠재적 위험</title>
        <link>https://blog.ttf248.life/ko/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</link>
        <pubDate>Sun, 10 Mar 2024 23:19:06 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</guid>
        <description>&lt;p&gt;동일한 비즈니스 코드의 경우, CentOS 7 환경에서 컴파일 및 실행은 정상적으로 이루어졌지만, CentOS 8로 전환하고 최신 버전의 GCC를 사용하여 컴파일했을 때 프로그램이 충돌했습니다. 주목할 점은 문제가 &lt;strong&gt;Release 模式&lt;/strong&gt;에서만 발생하며, &lt;strong&gt;Debug 模式&lt;/strong&gt;에서는 전혀 문제가 없다는 것입니다. 이와 같은 상황은 처음 경험했으며, 사흘간의 조사 끝에 문제의 근본 원인을 찾았습니다.&lt;/p&gt;
&lt;h3 id=&#34;문제-파악&#34;&gt;문제 파악
&lt;/h3&gt;&lt;p&gt;일련의 점검 결과, 문제의 근본 원인은 &lt;strong&gt;函数缺少返回值&lt;/strong&gt;에 있습니다. Release 모드에서 GCC 최신 버전은 더 많은 최적화를 수행하며, 이로 인해 명시적인 반환 값이 없는 함수의 실행 과정에서 예상치 못한 로직이 발생하여 충돌을 일으킵니다. 결론으로는, &lt;strong&gt;编译器的警告不容忽视，尤其是在老项目中，部分警告可能被无视，但也应当避免屏蔽所有警告&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;h3 id=&#34;환경-설명&#34;&gt;환경 설명
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CentOS 7 GCC版本：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39)
Copyright © 2015 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CentOS 8 GCC版本：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 8.5.0 20210514 (Red Hat 8.5.0-21)
Copyright (C) 2018 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;붕괴-현상&#34;&gt;붕괴 현상
&lt;/h3&gt;&lt;p&gt;프로그램 충돌 스택을 분석하는 과정에서 다음과 같은 스택 정보를 확인했습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[New LWP 1385902]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib64/libthread_db.so.1&amp;quot;.
Core was generated by `./pstack_main`.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007ffe894b4420 in ?? ()
(gdb) bt
#0  0x00007ffe894b4420 in ?? ()
#1  0x00000000004008e9 in main ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 스택은 직관적이지 않아 보이며, 충돌 함수의 스택 정보가 &lt;code&gt;??&lt;/code&gt;으로 표시되어 문제 해결을 더욱 어렵게 만들고 있습니다&lt;/p&gt;
&lt;h3 id=&#34;코드-예시&#34;&gt;코드 예시
&lt;/h3&gt;&lt;p&gt;문제 이해를 돕기 위해, 재현을 위한 최소 코드 예제는 다음과 같습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int test() {
    std::cout &amp;lt;&amp;lt; &amp;quot;1&amp;quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    test();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;해당 코드에서 &lt;code&gt;__INLINE_CODE_0__ 函数显然没有显式返回一个值，而它的返回类型是 __INLINE_CODE_1__BOLD_4&lt;/code&gt;int`` 유형의 경우, 반드시 반환 값이 있어야 하며, 그렇지 않으면 정의되지 않은 동작이 발생할 수 있습니다&lt;/p&gt;
&lt;h3 id=&#34;컴파일-경고&#34;&gt;컴파일 경고
&lt;/h3&gt;&lt;p&gt;프로젝트에서 CMake 스크립트가 여러 컴파일 경고를 숨겼는데, 그중에는 다음과 같은 경고 메시지도 포함되어 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/root/pstack/main.cpp: In function ‘int test()’:
/root/pstack/main.cpp:7:1: warning: no return statement in function returning non-void [-Wreturn-type]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 경고는 &lt;code&gt;test()&lt;/code&gt; 함수가 반환값을 가지지 않는다는 것을 나타내며, 이것이 문제의 근원입니다. GCC의 높은 버전(예: 8.5.0)은 코드를 최적화할 때 이러한 정의되지 않은 동작에 대해 불안정한 최적화를 수행하여 프로그램 충돌을 일으킬 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;어셈블리-코드-차이&#34;&gt;어셈블리 코드 차이
&lt;/h3&gt;&lt;p&gt;GCC 컴파일러 최적화 동작의 차이를 설명하기 위해, 다양한 버전의 GCC가 생성한 어셈블리 코드를 비교했습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GCC 4.8.5 生成的汇编代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;어셈블리 코드는 다소 장황하며, 표준 출력 스트림(예: &lt;code&gt;std::cout&lt;/code&gt;）的处理逻辑。这表明编译器进行了更保守的优化，未对 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; 함수에서 누락된 반환값 문제)에 대한 과도한 최적화를 포함하고 있어, 이로 인해 런타임 오류를 피했을 가능성이 있습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GCC 8.5.0 生成的汇编代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;새 버전의 GCC는 더 많은 최적화를 수행하여 코드 양을 줄였습니다. 하지만 이러한 최적화로 인해 반환 값이 없는 함수의 실행 동작이 정의되지 않아 프로그램이 충돌할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;결론&#34;&gt;결론
&lt;/h3&gt;&lt;p&gt;이번 문제 해결 과정을 통해 C++에서 &lt;strong&gt;函数返回值必须明确&lt;/strong&gt;, 특히 함수 선언이 &lt;code&gt;int&lt;/code&gt;BOLD_2__일 때, 모든 경고를 숨기지 않고, 특히 반환 값, 타입 매칭 등 흔히 발생하는 문제에 대해 선택적으로 처리해야 한다는 것을 깊이 인식하게 되었습니다&lt;/p&gt;
&lt;p&gt;마침내 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 함수에 반환값을 추가하여 문제를 해결하고 프로그램이 정상적으로 작동하게 되었습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43; 프로그래밍의 함정: `std::map` 오용으로 인한 프로그램 충돌 상세 분석</title>
        <link>https://blog.ttf248.life/ko/p/cpp-programming-traps-std-map-crash-details/</link>
        <pubDate>Sun, 10 Mar 2024 22:03:06 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/cpp-programming-traps-std-map-crash-details/</guid>
        <description>&lt;p&gt;C++ 프로그래밍에서 &lt;code&gt;std::map&lt;/code&gt; 컨테이너를 잘못 사용하면 프로그램이 충돌할 수 있습니다. 대괄호 연산자로 존재하지 않는 키에 접근하려 할 때 자동으로 빈 요소가 추가되기 때문입니다. 이 오해를 자세히 분석하고 예제 코드를 통해 잠재적인 위험을 보여드리겠습니다.&lt;/p&gt;
&lt;p&gt;저장하는 값이 단순한 값이라면 문제가 없지만, 포인터라면 문제가 발생할 수 있습니다. 포인터는 주소이고, 초기화되지 않은 주소는 불확실하기 때문에 프로그램이 충돌할 수 있습니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;C++ 표준 라이브러리에서 __INLINE_CODE_0__是一种关联容器，它按照键（key）的升序存储元素，并提供了高效的关键字查找功能。然而，新手开发者有时会因为对__INLINE_CODE_1__中括号操作符 &lt;code&gt;[]&lt;/code&gt; 的行为理解有误而陷入困境。实际上，当使用 __INLINE_CODE_3__BOLD_8&lt;code&gt;std::map&lt;/code&gt;은 새로운 키-값 쌍을 삽입하고, 기본 생성자를 사용하여 해당 키에 대응하는 값 타입의 초기화를 수행합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int main() {
    std::map&amp;lt;std::string, int&amp;gt; myMap;
    
    // 错误的用法：假设这里试图访问一个不存在的键并认为会得到0
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for &#39;nonexistent_key&#39;: &amp;quot; &amp;lt;&amp;lt; myMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;

    // 实际上，上述行代码创建了一个新的键值对，其中值被默认初始化为int的默认值（通常是0）
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 코드 자체는 프로그램 충돌을 직접적으로 유발하지는 않지만, 이러한 암묵적인 삽입 동작은 특정 상황에서 예상치 못한 부작용(예: 리소스 누수 또는 예기치 않은 상태 변경)을 초래할 수 있습니다. 더 나쁜 경우, 다중 스레드 환경에서 초기화되지 않은 메모리 영역에 대한 동시 접근은 프로그램 충돌로 이어질 수도 있습니다.&lt;/p&gt;
&lt;p&gt;이러한 문제가 발생하는 것을 방지하기 위해, &lt;code&gt;std::map::find()&lt;/code&gt;BOLD_3&lt;code&gt;std::map::count()&lt;/code&gt;BOLD_4&lt;code&gt;std::map::insert()&lt;/code&gt; 요소를 명시적으로 삽입하는 것이 좋습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::map&amp;lt;std::string, int&amp;gt; safeMap;
if (safeMap.count(&amp;quot;nonexistent_key&amp;quot;) == 0) {
    std::cout &amp;lt;&amp;lt; &amp;quot;Key does not exist.&amp;quot; &amp;lt;&amp;lt; std::endl;
} else {
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for existing key: &amp;quot; &amp;lt;&amp;lt; safeMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;
}

// 或者明确插入一个键值对，指定初始值
safeMap.insert({ &amp;quot;new_key&amp;quot;, 0 });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;만약 map 컨테이너 내부에 저장된 객체가 포인터 타입이라면, 자동 삽입 동작은 초기화되지 않은 포인터를 저장하며, 이 포인터를 사용하는 모든 작업은 프로그램 충돌을 야기할 수 있습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43; 함수 호출 시간</title>
        <link>https://blog.ttf248.life/ko/p/cpp-function-call-timing/</link>
        <pubDate>Wed, 24 Jan 2024 14:11:33 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/cpp-function-call-timing/</guid>
        <description>&lt;p&gt;다양한 콜백 함수 구현 방식에 맞춰 설계 시나리오 SDK를 위한 시간 소모적인 테스트를 진행했습니다. 최근 C++ 함수 프로그래밍을 살펴보고 있는데, 함수가 일급 시민이 되어 프로그램 내에서 자유롭게 흐르는 경우 성능 차이가 있을까요?&lt;/p&gt;
&lt;p&gt;이전 링크: &lt;a class=&#34;link&#34; href=&#34;https://blog.ttf248.life/ko/p/compiler-callback-function-performance-testing/&#34; &gt;编译器、回调函数、性能测试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大佬刚好也做了类似的测试，借代码一用。 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 비슷한 테스트를 이미 해 두신 분에게 코드를 빌려 썼다&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;실행 플랫폼은 여전히 우리의 든든한 친구, &lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;cassert&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

int add_one(int input) { return input + 1; }

bool validate_vector_add_one(std::vector&amp;lt;int&amp;gt; const&amp;amp; input_vector,
                             std::vector&amp;lt;int&amp;gt; const&amp;amp; output_vector)
{
    bool is_valid{true};
    for (size_t i{0}; i &amp;lt; input_vector.size(); ++i)
    {
        if (output_vector.at(i) != input_vector.at(i) + 1)
        {
            is_valid = false;
            break;
        }
    }
    return is_valid;
}

void reset_vector(std::vector&amp;lt;int&amp;gt;&amp;amp; input_vector)
{
    for (size_t i{0}; i &amp;lt; input_vector.size(); ++i)
    {
        input_vector.at(i) = 0;
    }
}

template &amp;lt;typename T, typename Func&amp;gt;
void unitary_function_pass_by_lambda_function(T&amp;amp; output, T const&amp;amp; input,
                                              Func const func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_std_function_value(T&amp;amp; output, T const&amp;amp; input,
                                                 std::function&amp;lt;T(T)&amp;gt; const func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_std_function_reference(
    T&amp;amp; output, T const&amp;amp; input, std::function&amp;lt;T(T)&amp;gt; const&amp;amp; func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_function_pointer(T&amp;amp; output, T const&amp;amp; input,
                                               T (*func)(T))
{
    output = func(input);
}

int main()
{
    // Set floating point format std::cout with 3 decimal places.
    std::cout.precision(3);

    size_t const num_elements{10000000};
    std::vector&amp;lt;int&amp;gt; input_vector(num_elements, 0);
    std::vector&amp;lt;int&amp;gt; output_vector(num_elements, 0);

    auto const lambda_function_add_one{[](int const&amp;amp; input) -&amp;gt; int
                                       { return input + 1; }};
    std::function&amp;lt;int(int)&amp;gt; const std_function_add_one{lambda_function_add_one};

    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a function pointer: &amp;quot; &amp;lt;&amp;lt; sizeof(&amp;amp;add_one)
              &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a std::function pointer: &amp;quot;
              &amp;lt;&amp;lt; sizeof(&amp;amp;std_function_add_one) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a std::function: &amp;quot; &amp;lt;&amp;lt; sizeof(std_function_add_one)
              &amp;lt;&amp;lt; std::endl;

    // Call function frequently in a vanilla way.
    // The compiler knows what function to call at compile time and can optimize
    // the code.
    // This is the best performance we could get.
    std::chrono::steady_clock::time_point const time_start_vanilla{
        std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        output_vector.at(i) = add_one(input_vector.at(i));
    }
    std::chrono::steady_clock::time_point const time_end_vanilla{
        std::chrono::steady_clock::now()};
    auto const time_elapsed_vanilla{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(time_end_vanilla -
                                                             time_start_vanilla)
            .count()};
    float const latency_vanilla{time_elapsed_vanilla /
                                static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass Vanilla: &amp;quot; &amp;lt;&amp;lt; latency_vanilla &amp;lt;&amp;lt; &amp;quot; ns&amp;quot;
              &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // Sometimes, we don&#39;t know what function to call at compile time.
    // We can use std::function to pass a function as an argument.
    // In this case, we pass the std::function by value.
    // Because the size of a std::function is 32 bytes, passing by value
    // results in a lot of copying and bad performance.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_std_function_value{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_std_function_value(
            output_vector.at(i), input_vector.at(i), std_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_std_function_value{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_std_function_value{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_std_function_value -
            time_start_pass_by_std_function_value)
            .count()};
    float const latency_pass_by_std_function_value{
        time_elapsed_pass_by_std_function_value /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Std Function Value: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_std_function_value &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // Instead of passing the std::function by value, we can pass it by
    // reference (pointer). In this case, object copying is eliminated. The
    // performance is better than passing the std::function by value. However,
    // the performance is still not as good as the vanilla way.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_std_function_reference{
            std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_std_function_reference(
            output_vector.at(i), input_vector.at(i), std_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_std_function_reference{
            std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_std_function_reference{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_std_function_reference -
            time_start_pass_by_std_function_reference)
            .count()};
    float const latency_pass_by_std_function_reference{
        time_elapsed_pass_by_std_function_reference /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Std Function Reference: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_std_function_reference &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // std::function is a general purpose wrapper for function pointers,
    // callable objects, and lambda functions. Because it&#39;s general purpose,
    // it&#39;s not as efficient as a function pointer. In this case, we pass a
    // function pointer to a function. The performance is better than passing
    // the std::function by reference.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_function_pointer{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_function_pointer(output_vector.at(i),
                                                  input_vector.at(i), &amp;amp;add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_function_pointer{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_function_pointer{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_function_pointer -
            time_start_pass_by_function_pointer)
            .count()};
    float const latency_pass_by_function_pointer{
        time_elapsed_pass_by_function_pointer /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Function Pointer: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_function_pointer &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // We can also pass a lambda function to a function.
    // The compiler knows what function to call at compile time and can optimize
    // the code. The performance is also better than passing the std::function
    // by reference.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_lambda_function{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_lambda_function(
            output_vector.at(i), input_vector.at(i), lambda_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_lambda_function{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_lambda_function{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_lambda_function -
            time_start_pass_by_lambda_function)
            .count()};
    float const latency_pass_by_lambda_function{
        time_elapsed_pass_by_lambda_function /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Lambda Function: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_lambda_function &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 组里常规也就开启 O2 优化，编译选用了 gcc13，不同版本的 gcc 性能耗时略有不同，版本越高 lambda 效果越好
The size of a function pointer: 8
The size of a std::function pointer: 8
The size of a std::function: 32
Latency Pass Vanilla: 0.418 ns
Latency Pass By Std Function Value: 3.47 ns
Latency Pass By Std Function Reference: 1.36 ns
Latency Pass By Function Pointer: 0.396 ns
Latency Pass By Lambda Function: 0.44 ns
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leimao.github.io/blog/CPP-Function-Call-Performance/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://leimao.github.io/blog/CPP-Function-Call-Performance/&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>C11: sleep for vs yield</title>
        <link>https://blog.ttf248.life/ko/p/c11-sleep-for-vs-yield/</link>
        <pubDate>Tue, 20 Sep 2022 20:54:51 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/c11-sleep-for-vs-yield/</guid>
        <description>&lt;p&gt;코드를 살펴보는데, &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 猛的引入眼帘，__INLINE_CODE_1__BOLD_4&lt;code&gt;yield&lt;/code&gt;이 처음 보는 것 같고, 예전엔 눈에 띄지 않았던 것 같아요&lt;/p&gt;
&lt;p&gt;매뉴얼을 확인하지 않고 가장 먼저 떠오르는 것은 비동기 변환과 관련이 있는지인데, __INLINE_CODE_0__boost 라이브러리의 코루틴 구현에 이 단어가 사용되었으므로 여기서는 코루틴과는 상관없고, 제어 로직은 일반 스레드와 관련이 있는 것 같습니다&lt;/p&gt;
&lt;h2 id=&#34;문서&#34;&gt;문서
&lt;/h2&gt;&lt;h3 id=&#34;yield&#34;&gt;yield
&lt;/h3&gt;&lt;p&gt;이 함수의 정확성은 구현에 의존하며, 특히 사용 중인 OS 스케줄러 메커니즘과 시스템 상태에 따라 달라집니다. 예를 들어, 먼저 온(FIFO) 실시간 스케줄러(Linux의 SCHED_FIFO)는 현재 스레드를 일시 중단하고 동일 우선순위의 다른 스레드가 없는 경우 큐의 맨 뒤로 배치합니다 (다른 스레드가 없으면 yield 효과 없음).&lt;/p&gt;
&lt;h3 id=&#34;sleep_for&#34;&gt;sleep_for
&lt;/h3&gt;&lt;p&gt;지정된 sleep_duration 동안 현재 스레드의 실행을 차단합니다
이 함수는 스케줄링 지연이나 리소스 충돌로 인해 sleep_duration보다 오래 블록될 수 있습니다
표준 라이브러리는 안정적인 클럭으로 시간을 측정하는 것을 권장합니다. 구현에서 시스템 시간을 사용하면 대기 시간 또한 클럭 조정에 민감할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;분석&#34;&gt;분석
&lt;/h3&gt;&lt;p&gt;두 함수 모두 현재 스레드를 더 이상 점유하지 않도록 하는 것인데, 실행 결과는 플랫폼에 따라 다를 수 있나? 여기서도 여전히 엉망진창이다. 코드를 실행해서 결과를 확인해 보자.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ThinkPad 노트북(Visual Studio 커뮤니티 에디션 2022), 텐센트 클라우드 S2 표준 서버 (gcc8.5)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;실행 플랫폼&lt;/th&gt;
&lt;th&gt;함수&lt;/th&gt;
&lt;th&gt;1회/μs&lt;/th&gt;
&lt;th&gt;2회/μs&lt;/th&gt;
&lt;th&gt;3회/μs&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;sleep_for&lt;/td&gt;
&lt;td&gt;9872&lt;/td&gt;
&lt;td&gt;1884&lt;/td&gt;
&lt;td&gt;11302&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;yield&lt;/td&gt;
&lt;td&gt;119&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;sleep_for&lt;/td&gt;
&lt;td&gt;171&lt;/td&gt;
&lt;td&gt;168&lt;/td&gt;
&lt;td&gt;167&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;yield&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;td&gt;102&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;운영체제 구현 방식에 따라 고정밀 슬립 모드에서는 __INLINE_CODE_0__稳定性差异巨大，如果想要高精度的休眠，使用__INLINE_CODE_1__이 더 적합합니다&lt;/p&gt;
&lt;p&gt;시간 정밀도가 __INLINE_CODE_0__일 때, 두 차이는 뚜렷하지 않다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;thread&amp;gt;
 
// 建议其他线程运行一小段时间的“忙睡眠”
void little_sleep(std::chrono::microseconds us)
{
    auto start = std::chrono::high_resolution_clock::now();
    auto end = start + us;
    do {
        std::this_thread::yield();
    } while (std::chrono::high_resolution_clock::now() &amp;lt; end);
}
 
int main()
{
    auto start = std::chrono::high_resolution_clock::now();
 
    little_sleep(std::chrono::microseconds(100));
    std::this_thread::sleep_for(std::chrono::microseconds(100));
 
    auto elapsed = std::chrono::high_resolution_clock::now() - start;
    std::cout &amp;lt;&amp;lt; &amp;quot;waited for &amp;quot;
              &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(elapsed).count()
              &amp;lt;&amp;lt; &amp;quot; microseconds\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;참조&#34;&gt;참조
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/header/thread.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/header/thread.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/thread/sleep_for.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/thread/sleep_for.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>새로운 언어를 배워야 하는 이유는 무엇인가?</title>
        <link>https://blog.ttf248.life/ko/p/why-learn-a-new-language/</link>
        <pubDate>Thu, 04 Aug 2022 11:27:30 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/why-learn-a-new-language/</guid>
        <description>&lt;p&gt;학창 시절부터 시작해서 &lt;code&gt;C++&lt;/code&gt;을 접한 지 벌써 10년이 넘었으니, 다른 프로그래밍 언어를 배울 필요가 있을까요?&lt;/p&gt;
&lt;p&gt;세련된 모듈 설계 경험은 부족하지만, 문법은 자유롭고 다른 언어를 학습하면서 더 세련된 설계를 유도할 수 있습니다&lt;/p&gt;
&lt;p&gt;도구들을 만들 때 자주 사용하게 된다&lt;/p&gt;
&lt;p&gt;설계 원칙은 하위 레이어 라이브러리든, 비즈니스 모듈 구현이든 모두 통일되어 있습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>표준 라이브러리 컨테이너의 메모리 할당자: allocator</title>
        <link>https://blog.ttf248.life/ko/p/standard-library-container-memory-allocator/</link>
        <pubDate>Mon, 30 Dec 2019 13:26:19 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/standard-library-container-memory-allocator/</guid>
        <description>&lt;p&gt;사용자 정의 할당자는 성능 향상, 메모리 사용 효율성 증대, 그리고 빈번한 소량 메모리 할당 문제를 해결할 수 있습니다&lt;/p&gt;
&lt;h4 id=&#34;전인&#34;&gt;전인
&lt;/h4&gt;&lt;p&gt;최근 네트워크 데이터 패킷 개발을 진행하면서 빈번하게 작은 메모리 블록을 할당하고 해제해야 하는데, 메모리 풀을 사용하려 했더니 기존 메모리 풀들을 살펴보니 이런 것을 발견했다&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/cacay/MemoryPool&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/cacay/MemoryPool&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;인터페이스를 보니까 좀 이상하다, 이 메모리 풀 구현이 어떻게 이렇게 특이할까. &lt;code&gt;MemoryPool&lt;/code&gt;的实现逻辑，是在申请固定大小的内存空间。看过boost的内存池接口，提供的是一个模板，用的时候进行实例化。正巧这个库已经有文章进行过介绍，提到了&lt;code&gt;allocator&lt;/code&gt; 개념 말이야.&lt;/p&gt;
&lt;h4 id=&#34;wikihttpszhwikipediaorgwikie58886e9858de599a8_c2b2b&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_%28C%2B%2B%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wiki&lt;/a&gt;
&lt;/h4&gt;&lt;p&gt;C++ 프로그래밍에서 할당자(allocator)는 C++ 표준 라이브러리의 중요한 구성 요소입니다. C++ 라이브러리에는 연결 리스트, 집합 등 다양한 “컨테이너” 데이터 구조가 정의되어 있으며, 이 컨테이너들의 공통적인 특징 중 하나는 프로그램 실행 시간에 크기를 변경할 수 있다는 것입니다. 이를 구현하기 위해 동적 메모리 할당이 필수적이므로, 할당자는 컨테이너의 메모리 할당 및 해제 요청을 처리하는 데 사용됩니다. 다시 말해, 할당자는 표준 템플릿 라이브러리(STL) 컨테이너의 메모리 관리에 대한 저수준 세부 사항을 캡슐화합니다. 기본적으로 C++ 표준 라이브러리는 자체 제공하는 범용 할당자를 사용하지만, 필요에 따라 프로그래머는 자신만의 할당자를 정의하여 대체할 수 있습니다.&lt;/p&gt;
&lt;p&gt;분포자는 원래 C++ 표준 템플릿 라이브러리(STL)의 일부로 알렉산드르 스테파노프가 “라이브러리를 더욱 유연하게 만들고, 하위 데이터 모델에 의존하지 않는 방법”을 목표로 발명했지만, C++ 표준 위원회는 STL을 표준으로 채택하는 과정에서 완전한 데이터 모델 추상화가 용납할 수 없는 성능 저하를 야기한다는 것을 깨달았습니다. 이러한 절충안으로 인해 표준에서 할당자에 대한 제약이 더욱 엄격해졌고, 결과적으로 현재 표준에 설명된 할당자의 사용자 정의 가능성은 스테파노프의 원래 구상에 비해 크게 제한되었습니다.&lt;/p&gt;
&lt;p&gt;할당기 사용자 정의는 제한적일 수 있지만, 많은 경우 다양한 메모리 공간(공유 메모리 및 재활용 메모리와 같은)에 대한 접근 방식을 캡슐화하거나 메모리 풀을 사용한 메모리 할당 시 성능을 향상시키기 위해 여전히 사용자 정의 할당기가 필요합니다. 또한, 빈번하게 소량의 메모리를 할당하는 프로그램에서는 메모리 점유 및 실행 시간 측면에서 전용으로 최적화된 할당기를 도입하면 상당한 이점을 얻을 수 있습니다.&lt;/p&gt;
&lt;h4 id=&#34;使用需求httpszhwikipediaorgwikie58886e9858de599a8_c2b2b&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_%28C%2B%2B%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;使用需求&lt;/a&gt;
&lt;/h4&gt;&lt;p&gt;사용자 정의 할당기를 사용하는 주된 이유 중 하나는 성능 향상입니다. 전용 사용자 정의 할당기는 프로그램의 성능을 높이거나, 메모리 사용 효율성을 개선하거나, 이 둘 모두를 달성할 수 있습니다 [4][8]. 기본 할당기는 new 연산자를 사용하여 저장 공간을 할당하는데, 이는 종종 C 언어의 힙 할당 함수(malloc())를 통해 구현됩니다 [9]. 힙 할당 함수는 일반적으로 일시적으로 많은 메모리를 할당하는 데 최적화되어 있으므로, 대량의 메모리를 한 번에 할당해야 하는 컨테이너(예: 벡터, 양방향 큐)의 경우 기본 할당기는 효율적인 경향이 있습니다 [8]. 그러나 연결 리스트와 같이 빈번하게 소량의 메모리를 할당해야 하는 컨테이너의 경우 기본 할당기를 사용하면 일반적으로 효율성이 매우 낮습니다 [4][9]. 또한 malloc() 기반의 기본 할당기는 낮은 지역성[4] 및 메모리 조각화 발생 가능성[4][9]과 같은 여러 가지 문제점을 가지고 있습니다.&lt;/p&gt;
&lt;p&gt;간단히 말해서, 이 부분은 (……)이 해당 표준의 할당기 관련 《나에게 꿈이 있어요》와 같습니다. 꿈이 실현되기 전에는 이식성을 중시하는 프로그래머들은 상태 없는 사용자 정의 할당기를 사용할 수밖에 없을 것입니다.
——스코트 메이스, 《Effective STL》
이러한 점을 감안하여, 이 경우에 사람들은 빈번한 소량 할당 문제를 해결하기 위해 메모리 풀 기반 할당기를 자주 사용한다[8]. 기본 “요청 시 할당” 방식과 달리, 메모리 풀 기반 할당기를 사용하는 경우 프로그램은 미리 대용량 메모리(즉, &amp;ldquo;메모리 풀&amp;rdquo;)를 할당하고, 필요할 때 사용자 정의 할당기는 요청자에게 풀 내 메모리의 포인터를 반환하기만 한다. 객체 소멸 시에는 실제로 메모리를 해제하지 않고, 메모리 풀의 수명이 종료될 때 비로소 해제를 지연시킨다[주 1][8].&lt;/p&gt;
&lt;p&gt;“사용자 정의 할당기”라는 주제에 대해 스콧 메이어스의 “Effective STL”과 안드레이 알렉산더레스쿠의 “Modern C++ Design”과 같이 여러 C++ 전문가 및 관련 저자들이 참여하여 논의해 왔습니다. 메이어스는 특정 타입 T에 대한 모든 할당기 인스턴스가 동일해야 한다면 이식 가능한 할당기 인스턴스는 상태를 포함해서는 안 된다고 지적했습니다. C++ 표준은 라이브러리 구현자가 상태 기반 할당기를 지원하도록 권장하지만[문헌 4], 메이어스는 관련 단락이 “（보이는 듯한）아름다운 관점”이지만 거의 말도 안 되는 소리이며, 할당기 제한이 “지나치게 엄격하다”고 주장했습니다[4]. 예를 들어, STL의 list는 splice 메서드를 허용하는데, 이는 list 객체 A의 노드가 다른 list 객체 B로 직접 이동될 수 있다는 의미입니다. 이는 A의 할당기가 할당한 메모리가 B의 할당기에 의해 해제될 수 있어야 하므로 A와 B의 할당기 인스턴스가 동일해야 함을 시사합니다. 메이어스의 결론은 할당기를 정적 메서드를 사용하는 타입으로 정의하는 것이 가장 좋다는 것입니다. 예를 들어, C++ 표준에 따르면 할당기는 rebind 메서스를 구현한 other 클래스 템플릿을 제공해야 합니다.&lt;/p&gt;
&lt;p&gt;또 다른 예로, Bjarne Stroustrup는 그의 저서 《C++ 프로그램 설계 언어》에서 “각 객체 정보가 다를 수 없도록 할당자를 엄격하게 제한하는 것은 큰 문제가 아니다.”라고 주장하며 대부분의 할당자는 상태를 필요로 하지 않으며, 심지어 상태가 없는 경우 성능이 더 좋을 수도 있다고 지적합니다. 그는 메모리 풀 할당자, 공유 메모리 할당자 및 가비지 컬렉션 할당자의 세 가지 사용자 정의 할당자 사용 사례를 제시하고 내부 메모리 풀을 활용하여 소량의 메모리를 빠르게 할당/해제하는 할당자 구현을 보여줍니다. 하지만 이러한 최적화는 이미 그가 제공한 예시 할당자에서 구현되었을 수도 있다고 언급합니다[3].&lt;/p&gt;
&lt;p&gt;사용자 정의 할당기의 또 다른 용도는 메모리 관련 오류를 디버깅하는 것입니다[10]. 이를 위해 추가 메모리를 할당하여 디버그 정보를 저장하는 할당기를 작성할 수 있습니다. 이러한 할당기는 메모리가 동일한 할당기에서 할당 및 해제되도록 보장할 뿐만 아니라, 캐시 오버플로로부터 프로그램의 안전을 어느 정도 보호할 수도 있습니다[11].&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
