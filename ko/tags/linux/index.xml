<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Linux on 향숙의 수첩</title>
        <link>https://ttf248.life/ko/tags/linux/</link>
        <description>Recent content in Linux on 향숙의 수첩</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ko</language>
        <lastBuildDate>Wed, 28 May 2025 09:47:38 +0800</lastBuildDate><atom:link href="https://ttf248.life/ko/tags/linux/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>atop 도구를 이용한 Linux 시스템 지표 모니터링: 설치, 설정 및 사용법 완벽 가이드</title>
        <link>https://ttf248.life/ko/p/using-atop-to-monitor-linux-system-metrics-installation-configuration-and-usage-guide/</link>
        <pubDate>Thu, 06 Feb 2025 22:48:55 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/using-atop-to-monitor-linux-system-metrics-installation-configuration-and-usage-guide/</guid>
        <description>&lt;p&gt;리눅스 시스템 운영 과정에서 시스템 자원과 프로세스 상태를 실시간으로 종합적으로 모니터링하는 것은 매우 중요합니다. atop 도구는 강력한 모니터링 도구로서, 이를 쉽게 달성하도록 돕습니다. 본 문서에서는 리눅스 인스턴스에 atop 모니터링 도구를 설치, 구성 및 사용하는 방법을 자세히 설명하겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;일반적으로-사용되는-atop-도구-소개&#34;&gt;일반적으로 사용되는 atop 도구 소개
&lt;/h2&gt;&lt;p&gt;atop은 Linux 시스템 리소스 및 프로세스를 모니터링하는 도구로, 시스템과 프로세스의 활동을 기록하고 모든 프로세스의 실행 상태를 보고합니다. 이 도구는 CPU, 메모리, 디스크, 네트워크 등 리소스 사용량 정보와 프로세스 상태 데이터를 수집하며, 로그 파일 형태로 저장할 수 있습니다. 각 프로세스별 CPU 사용률, 메모리 증가량, 디스크 사용률, 우선순위, 사용자 이름, 상태 및 종료 코드 등의 주요 정보를 얻을 수 있으며, atop 설정 파일을 통해 로그 수집 빈도, 로그 파일 저장 경로 및 로테이션 정책 등의 매개변수를 사용자 정의할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;두-번째-atop-도구-설치&#34;&gt;두 번째, atop 도구 설치
&lt;/h2&gt;&lt;p&gt;다양한 Linux 배포판에서 atop 설치 방법은 약간씩 다르므로, 여기서는 일반적인 운영체제를 기준으로 설명하겠습니다&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Alibaba Cloud Linux 3/2、CentOS 7/8、Fedora、Rocky Linux 9&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;설치 명령 실행: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;atop 서비스 시작:&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;Ubuntu / Debian&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;소프트웨어 저장소 목록 업데이트:&lt;/li&gt;
&lt;li&gt;설치 명령 실행: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;atop 서비스 시작:&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;CentOS Stream 9&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;다운로드 및 설치:&lt;/li&gt;
&lt;li&gt;atop 서비스 시작:&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;openSUSE&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;설치 명령 실행: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;atop 서비스 시작:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위에 언급된 운영체제에 사용하시는 배포판이 포함되지 않았다면, atop 공식 웹사이트에서 설치 정보를 확인하실 수 있습니다&lt;/p&gt;
&lt;h2 id=&#34;세-모니터링-주기-및-로그-보존-기간-설정&#34;&gt;세, 모니터링 주기 및 로그 보존 기간 설정
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Alibaba Cloud Linux 3/2, CentOS 7/8 및 Fedora 시스템에서 atop 설정 파일은 __；在Ubuntu、Debian和openSUSE系统中，配置文件是__INLINE_CODE_1__입니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;默认配置参数说明&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;：로그 파일 기록 옵션을 제어하며, 기본값은 비어 있습니다&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LOGINTERVAL&lt;/code&gt;：모니터링 주기, 기본 600초입니다. 과거 로그 추적 문제가 필요한 경우, 실제 요구사항에 따라 해당 주기를 조정하는 것이 좋습니다.&lt;/li&gt;
&lt;li&gt;로그 보관 기간, 기본 28일&lt;/li&gt;
&lt;li&gt;__INLINE_CODE_0__BOLD_2&lt;code&gt;/var/log/atop&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;配置步骤&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;명령 실행하여 설정 파일 열기:&lt;/li&gt;
&lt;li&gt;Alibaba Cloud Linux 3/2, CentOS 7/8, Fedora 시스템에서: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Ubuntu, Debian, openSUSE, CentOS Stream 9, Rocky Linux 9 시스템에서: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;을 눌러 편집 모드로 진입한 다음, 필요에 따라 구성 매개변수를 조정합니다. 예를 들어, 모니터링 주기를 30초로 변경하고, 로그 보존 기간을 7일로 설정하며, 로그 경로는 기본값으로 유지합니다.&lt;/li&gt;
&lt;li&gt;저장하고 편집을 종료합니다&lt;/li&gt;
&lt;li&gt;atop 서비스 재시작 시 설정이 적용됩니다&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;LOGOPTS=&amp;quot;&amp;quot;
LOGINTERVAL=30
LOGGENERATIONS=7
LOGPATH=/var/log/atop 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;네-알겠습니다-네-가지-사용-atop-도구&#34;&gt;네, 알겠습니다. 네 가지 사용 atop 도구
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;常用命令介绍&lt;/strong&gt;: 대화형 명령 모드에서 다음의 일반적인 명령어가 있습니다&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;기본 통합 출력 보기로 전환합니다&lt;/li&gt;
&lt;li&gt;프로세스 목록의 전체 명령줄 표시&lt;/li&gt;
&lt;li&gt;프로세스 메모리 사용량별 내림차순으로 필터링합니다&lt;/li&gt;
&lt;li&gt;프로세스 디스크 사용률을 기준으로 내림차순 정렬합니다&lt;/li&gt;
&lt;li&gt;프로세스 자원 종합 활용률에 따라 내림차순으로 필터링합니다&lt;/li&gt;
&lt;li&gt;프로세스 네트워크 사용률을 기준으로 내림차순 정렬합니다&lt;/li&gt;
&lt;li&gt;다음 모니터링 지점으로 이동합니다&lt;/li&gt;
&lt;li&gt;이전 모니터링 지점으로 이동합니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;：指定时间点，格式为__INLINE_CODE_1__。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;资源监控字段含义介绍&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ATOP&lt;/strong&gt;: 호스트 이름, 정보 샘플링 날짜 및 시간&lt;/li&gt;
&lt;li&gt;프로세스 전체 실행 상황, 커널 모드 및 사용자 모드 실행 시간, 프로세스 총 수, 다양한 상태의 프로세스 수 등을 포함합니다&lt;/li&gt;
&lt;li&gt;CPU 전체 사용률을 나타내며, 각 필드의 숫자 합은 &lt;strong&gt;INLIN_2&lt;/strong&gt;__(N은 CPU 코어 수)이며, 커널 모드, 사용자 모드, 인터럽트, 유휴 상태, 디스크 I/O 대기 등의 시간 비율을 포함합니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPL&lt;/strong&gt;: CPU 사용률 정보, 예를 들어 지난 1분, 5분 및 15분 동안의 실행 중인 프로세스 평균 수, 컨텍스트 스위칭 횟수, 인터럽트 발생 횟수&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MEM&lt;/strong&gt;: 메모리 사용량 정보, 물리 메모리 총량, 유휴 메모리, 페이지 캐시 메모리, 파일 캐시 메모리, 커널 점유 메모리 등을 포함합니다&lt;/li&gt;
&lt;li&gt;스왑 공간 사용량 정보, 스왑 영역 총 용량 및 남은 스왑 공간 크기 포함&lt;/li&gt;
&lt;li&gt;가상 메모리 페이지 상태, 예를 들어 스왑 인/아웃된 페이지 수&lt;/li&gt;
&lt;li&gt;디스크 사용률, 각 디스크 장치별로 표시되며 장치 식별자, 바쁨 상태 시간 비율, 읽기/쓰기 요청 횟수를 나타냅니다&lt;/li&gt;
&lt;li&gt;네트워크 상태를 보여주며, 전송 계층 TCP 및 UDP, IP 계층과 각 활성 네트워크 포트의 송수신 패킷 크기를 표시합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;查看实时系统指标&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;5초마다 시스템 지표 확인: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 시스템 지표를 현재 시간 이후 5분 내(총 30회, 간격 10초)에 확인합니다&lt;/li&gt;
&lt;li&gt;현재 시간 이후 10분 후의 시스템 지표를 확인하고(10회, 60초 간격으로), 결과를 파일에 기록합니다: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;查看历史指标日志&lt;/strong&gt;: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 디렉터리에 기본적으로 저장됩니다. 확인 시 지정된 날짜의 로그 파일이 존재해야 하며, 그렇지 않으면 오류가 발생합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;일별 히스토리 지표 로그 확인: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;어제 기록 지표 로그 확인: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;지정된 날짜의 과거 지표 로그를 확인합니다. 예: 2024년 11월 06일: &lt;code&gt;atop -r 20241106&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;지정된 날짜 및 시간 이후의 과거 지표 로그를 확인합니다. 예: 2024년 11월 6일 14:00부터 &lt;code&gt;atop -r 20241106 -b 14:00&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;지정된 날짜 및 시간 범위 내의 과거 지표 로그를 확인합니다. 예: 2024년 11월 5일 00:04 ~ 00:08: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;查看系统活动报告&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;현재 시스템의 CPU 사용률 보고서를 1분 동안(12회, 간격 5초) 확인합니다: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;해당 날짜 지정 시간대의 메모리 지표 보고서를 확인합니다. 예: 18:00~18:01&lt;/li&gt;
&lt;li&gt;지정된 날짜 및 시간 범위 내의 메모리 지표 보고서 확인 (예: 2024년 11월 5일 18:00~18:01):&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;다섯-기타-작업&#34;&gt;다섯. 기타 작업
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;配置天级别日志轮转策略&lt;/strong&gt;: 매일 atop 지표 로그 파일을 생성하려면 다음 단계를 따르세요&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;(선택 사항) 필요에 따라 모니터링 주기, 로그 보존 기간 및 로그 저장 경로를 조정합니다&lt;/li&gt;
&lt;li&gt;명령 실행하여 매일 로그 로테이션 관련 서비스 자동 시작 및 서비스 시작: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;더 복잡한 로깅 처리가 필요하다면 logrotate나 사용자 정의 스크립트를 활용하여 로그 관리를 구현할 수 있습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;加载可选的netatop内核模块&lt;/strong&gt;: 네트워크 사용률을 모니터링하려면 netatop 모듈(atop에서 기본 설치되지 않음)을 설치할 수 있습니다. Alibaba Cloud Linux 3 시스템을 예로 들면:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;커널 개발 패키지 및 컴파일에 필요한 소프트웨어 환경 설치: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;최신 버전 netatop 소스 코드를 지정된 디렉터리에 다운로드합니다&lt;/li&gt;
&lt;li&gt;소스 코드를 압축 해제하고 소스 코드 디렉토리로 들어갑니다: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;소스 코드 기반으로 모듈과 데몬을 구축 및 설치합니다&lt;/li&gt;
&lt;li&gt;netatop 서비스 시작:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;atop 도구는 기능이 강력하고 사용하기 유연하여, 적절한 설치, 구성 및 활용을 통해 Linux 시스템의 실행 상태를 더 잘 파악하고 잠재적인 문제를 조기에 발견하고 해결할 수 있습니다. 본 문서가 Linux 시스템 모니터링 역량 향상에 도움이 되기를 바랍니다.&lt;/p&gt;
&lt;h2 id=&#34;참고-링크&#34;&gt;참고 링크
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>리눅스 백엔드 서비스 문자열 데이터 처리 - 속도 느림</title>
        <link>https://ttf248.life/ko/p/linux-backend-slow-string-processing/</link>
        <pubDate>Wed, 13 Nov 2024 19:42:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/linux-backend-slow-string-processing/</guid>
        <description>&lt;p&gt;C++ 개발 프로젝트에서 사용자 정의 프로토콜을 사용하여 통신했는데, 이 프로토콜은 2차원 배열 패턴을 채택했습니다. 대량의 데이터를 처리할 때 프로토콜 내부에서 배열을 순회하고 시리얼화하여 로그를 생성하는 과정이 비효율적이었고, 이는 고부하 상황에서 시스템 응답 지연을 야기했습니다. 이로 인해 사업 부서로부터 시스템 멈춤 현상에 대한 피드백을 받았습니다.&lt;/p&gt;
&lt;h2 id=&#34;문제-파악&#34;&gt;문제 파악
&lt;/h2&gt;&lt;p&gt;문제 해결 과정에서 우선 시스템 성능을 분석한 결과, 대량의 데이터를 처리할 때 CPU 사용률이 눈에 띄게 증가하고 응답 시간이 길어지는 것을 확인했습니다. 시스템 로그를 분석한 결과, 2차원 배열 처리에 비효율적인 많은 양의 직렬화 작업이 수행되고 있었고, 이로 인해 시스템 성능이 저하되었습니다.&lt;/p&gt;
&lt;p&gt;도구 캡처 서비스의 스레드 정보를 분석한 결과, 로그 스레드는 대부분의 시간을 문자열 연결 처리에 소비하는 것으로 나타났다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;여기 오늘의 핵심인데, 다른 누적 방식에 따라 효율성의 차이가 엄청나다. 기존 코드에서는 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 연산자를 사용했는데, 이 방식은 빈번하게 임시 객체를 생성하므로 효율이 매우 낮다. 얼마나 심각한지 모르는 수준으로 비효율적이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;데모-검증&#34;&gt;데모 검증
&lt;/h2&gt;&lt;p&gt;프로젝트 코드를 기반으로 비즈니스 로직을 분리하고, 문자열 연결 효율성 문제를 검증하기 위한 간단한 데모를 작성했습니다. &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 下的 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; 编译器，__INLINE_CODE_2__BOLD_7&lt;code&gt;gcc8.5&lt;/code&gt; 编译器，&lt;strong&gt;INLINE_CODE_4&lt;/strong&gt; 모드에서 컴파일 및 실행하여 효율성을 비교했습니다.&lt;/p&gt;
&lt;h3 id=&#34;주요-사항-안내&#34;&gt;주요 사항 안내
&lt;/h3&gt;&lt;p&gt;프로젝트는 방법 네 가지를 사용하고 있는데, 테스트 데이터를 받기 전 독자들은 어떤 방식이 가장 효율적이고 어떤 방식이 가장 비효율적인지 먼저 생각해 볼 수 있습니다. 결과를 보고 저는 여전히 놀랐습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;각 필드를 문자열에 직접 연결합니다&lt;/li&gt;
&lt;li&gt;스트림(Stream)을 사용하여 각 필드를 연결하면 더 효율적이며, 특히 대량 데이터를 연결할 때 더욱 그렇습니다&lt;/li&gt;
&lt;li&gt;**方法 3（预分配内存的 &lt;strong&gt;인라인_4&lt;/strong&gt; &lt;em&gt;이탤릭체_3&lt;/em&gt;_： 미리 문자열에 충분한 메모리를 할당하면 메모리 재할당 비용을 줄여 성능을 향상시킬 수 있습니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法 4 (&lt;strong&gt;인라인__이탤릭_3&lt;/strong&gt; __)&lt;/strong&gt;: 매번 연결할 때마다 새로운 임시 문자열 객체를 생성하므로, 특히 대규모 연결 시 성능 저하가 발생합니다. 이는 매번 연결 시 새로운 메모리 할당 및 복사가 수반되기 때문입니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;참고 결과, 프로젝트가 효율이 가장 낮은 방식을 선택한 것을 알 수 있습니다&lt;/p&gt;
&lt;p&gt;더 나아가, 다양한 플랫폼 컴파일러의 최적화 효율을 분석해 보면, 마이크로소프트의 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 一如既往的优秀，针对字符串的优化效率很高，而 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; 컴파일러는 이 부분에서 최적화 효율이 다소 떨어지는 편입니다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;코드 실행 환경이 다른 기기에서 이루어지므로 데이터 간 직접적인 비교는 무의미하며, 각각의 조립 방식별 차이를 비교하는 것이 좋습니다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;windows 平台下的 vs2022 编译器

----------------------------------------
Data Generation Time: 0.054 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.053 seconds.
+ ostringstream Data merging took: 0.054 seconds.
+ Pre-reserved Data merging took: 0.045 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 16.108 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;linux 平台下的 gcc8.5 编译器
----------------------------------------
Data Generation Time: 0.108 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.100 seconds.
+ ostringstream Data merging took: 0.083 seconds.
+ Pre-reserved Data merging took: 0.057 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 29.298 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;전체-코드&#34;&gt;전체 코드
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;random&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;iomanip&amp;gt;

typedef std::vector&amp;lt;std::string&amp;gt; DataRow;
typedef std::vector&amp;lt;DataRow&amp;gt; DataGroup;

struct ResponsePackage
{
    std::string ErrorInfo;
    DataRow Head;
    std::string ClientId;
    std::string UUID;
    std::string MsgID;
    std::string SessionID;
    std::string ExtraInfo1;
    std::string ExtraInfo2;
    DataGroup DataBody;
};

// Generate specified length of random string
std::string generateRandomString(size_t length)
{
    const char charset[] = &amp;quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&amp;quot;;
    const size_t max_index = sizeof(charset) - 1;
    std::string random_string;
    random_string.reserve(length);

    std::random_device rd;
    std::mt19937 generator(rd());
    std::uniform_int_distribution&amp;lt;&amp;gt; distribution(0, max_index);

    for (size_t i = 0; i &amp;lt; length; ++i)
    {
        random_string += charset[distribution(generator)];
    }

    return random_string;
}

void create_large_string()
{
    // Example request package with 50 fields
    ResponsePackage requestPackage;

    requestPackage.Head = {
        &amp;quot;Field1&amp;quot;, &amp;quot;Field2&amp;quot;, &amp;quot;Field3&amp;quot;, &amp;quot;Field4&amp;quot;, &amp;quot;Field5&amp;quot;,
        &amp;quot;Field6&amp;quot;, &amp;quot;Field7&amp;quot;, &amp;quot;Field8&amp;quot;, &amp;quot;Field9&amp;quot;, &amp;quot;Field10&amp;quot;,
        &amp;quot;Field11&amp;quot;, &amp;quot;Field12&amp;quot;, &amp;quot;Field13&amp;quot;, &amp;quot;Field14&amp;quot;, &amp;quot;Field15&amp;quot;,
        &amp;quot;Field16&amp;quot;, &amp;quot;Field17&amp;quot;, &amp;quot;Field18&amp;quot;, &amp;quot;Field19&amp;quot;, &amp;quot;Field20&amp;quot;,
        &amp;quot;Field21&amp;quot;, &amp;quot;Field22&amp;quot;, &amp;quot;Field23&amp;quot;, &amp;quot;Field24&amp;quot;, &amp;quot;Field25&amp;quot;,
        &amp;quot;Field26&amp;quot;, &amp;quot;Field27&amp;quot;, &amp;quot;Field28&amp;quot;, &amp;quot;Field29&amp;quot;, &amp;quot;Field30&amp;quot;,
        &amp;quot;Field31&amp;quot;, &amp;quot;Field32&amp;quot;, &amp;quot;Field33&amp;quot;, &amp;quot;Field34&amp;quot;, &amp;quot;Field35&amp;quot;,
        &amp;quot;Field36&amp;quot;, &amp;quot;Field37&amp;quot;, &amp;quot;Field38&amp;quot;, &amp;quot;Field39&amp;quot;, &amp;quot;Field40&amp;quot;,
        &amp;quot;Field41&amp;quot;, &amp;quot;Field42&amp;quot;, &amp;quot;Field43&amp;quot;, &amp;quot;Field44&amp;quot;, &amp;quot;Field45&amp;quot;,
        &amp;quot;Field46&amp;quot;, &amp;quot;Field47&amp;quot;, &amp;quot;Field48&amp;quot;, &amp;quot;Field49&amp;quot;, &amp;quot;Field50&amp;quot;
    };

    requestPackage.ClientId = &amp;quot;ClientID&amp;quot;;
    requestPackage.UUID = &amp;quot;UUID&amp;quot;;
    requestPackage.MsgID = &amp;quot;MsgID&amp;quot;;
    requestPackage.SessionID = &amp;quot;SessionID&amp;quot;;
    requestPackage.ExtraInfo1 = &amp;quot;ExtraInfo1&amp;quot;;
    requestPackage.ExtraInfo2 = &amp;quot;ExtraInfo2&amp;quot;;

    // Start timing for data generation
    auto start_gen = std::chrono::high_resolution_clock::now();

    // Generate 10,000 rows of data, each with 50 fields
    for (size_t i = 0; i &amp;lt; 10000; ++i)
    {
        DataRow dataRow(50, &amp;quot;This is a test string&amp;quot;);
        requestPackage.DataBody.push_back(dataRow);
    }

    // End timing for data generation
    auto end_gen = std::chrono::high_resolution_clock::now();
    std::chrono::duration&amp;lt;double&amp;gt; duration_gen = end_gen - start_gen;

    // Display result generation time
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Generation Time: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_gen.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    // Data merging using different methods
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Performance:\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    {
        // Method 1: Using &#39;+=&#39; string concatenation
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (+=) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 2: Using ostringstream
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::ostringstream bodys;
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::ostringstream body;
            body &amp;lt;&amp;lt; &amp;quot;This is a test string&amp;quot;;
            for (auto&amp;amp; item : vec)
            {
                body &amp;lt;&amp;lt; item &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            }
            bodys &amp;lt;&amp;lt; body.str() &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ ostringstream Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 3: Pre-allocated memory
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys;
        bodys.reserve(1000 * 50 * 20); // Pre-allocate enough memory
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            body.reserve(50 * 20); // Pre-allocate memory for each row
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Pre-reserved Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 4: Using &#39;bodys = bodys + body + &amp;quot;\n&amp;quot;&#39;
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body = body + item + &amp;quot; &amp;quot;; // Note the use of &#39;body = body + item&#39;
            }
            bodys = bodys + body + &amp;quot;\n&amp;quot;; // Again, using &#39;bodys = bodys + body&#39;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (bodys = bodys + body + \&amp;quot;\\n\&amp;quot;) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Complete.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;
}

int main()
{
    try
    {
        create_large_string();
    }
    catch (const std::exception&amp;amp; e)
    {
        std::cerr &amp;lt;&amp;lt; &amp;quot;Caught exception: &amp;quot; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\nProgram finished.\n&amp;quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>GCC 버전 업그레이드로 인한 프로그램 충돌: 비표준 코드의 잠재적 위험</title>
        <link>https://ttf248.life/ko/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</link>
        <pubDate>Sun, 10 Mar 2024 23:19:06 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</guid>
        <description>&lt;p&gt;동일한 비즈니스 코드의 경우, CentOS 7 환경에서 컴파일 및 실행은 정상적으로 이루어졌지만, CentOS 8로 전환하고 최신 버전의 GCC를 사용하여 컴파일했을 때 프로그램이 충돌했습니다. 주목할 점은 문제가 &lt;strong&gt;Release 模式&lt;/strong&gt;에서만 발생하며, &lt;strong&gt;Debug 模式&lt;/strong&gt;에서는 전혀 문제가 없다는 것입니다. 이와 같은 상황은 처음 경험했으며, 사흘간의 조사 끝에 문제의 근본 원인을 찾았습니다.&lt;/p&gt;
&lt;h3 id=&#34;문제-파악&#34;&gt;문제 파악
&lt;/h3&gt;&lt;p&gt;일련의 점검 결과, 문제의 근본 원인은 &lt;strong&gt;函数缺少返回值&lt;/strong&gt;에 있습니다. Release 모드에서 GCC 최신 버전은 더 많은 최적화를 수행하며, 이로 인해 명시적인 반환 값이 없는 함수의 실행 과정에서 예상치 못한 로직이 발생하여 충돌을 일으킵니다. 결론으로는, &lt;strong&gt;编译器的警告不容忽视，尤其是在老项目中，部分警告可能被无视，但也应当避免屏蔽所有警告&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;h3 id=&#34;환경-설명&#34;&gt;환경 설명
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CentOS 7 GCC版本：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39)
Copyright © 2015 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CentOS 8 GCC版本：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 8.5.0 20210514 (Red Hat 8.5.0-21)
Copyright (C) 2018 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;붕괴-현상&#34;&gt;붕괴 현상
&lt;/h3&gt;&lt;p&gt;프로그램 충돌 스택을 분석하는 과정에서 다음과 같은 스택 정보를 확인했습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[New LWP 1385902]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib64/libthread_db.so.1&amp;quot;.
Core was generated by `./pstack_main`.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007ffe894b4420 in ?? ()
(gdb) bt
#0  0x00007ffe894b4420 in ?? ()
#1  0x00000000004008e9 in main ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 스택은 직관적이지 않아 보이며, 충돌 함수의 스택 정보가 &lt;code&gt;??&lt;/code&gt;으로 표시되어 문제 해결을 더욱 어렵게 만들고 있습니다&lt;/p&gt;
&lt;h3 id=&#34;코드-예시&#34;&gt;코드 예시
&lt;/h3&gt;&lt;p&gt;문제 이해를 돕기 위해, 재현을 위한 최소 코드 예제는 다음과 같습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int test() {
    std::cout &amp;lt;&amp;lt; &amp;quot;1&amp;quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    test();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;해당 코드에서 &lt;code&gt;__INLINE_CODE_0__ 函数显然没有显式返回一个值，而它的返回类型是 __INLINE_CODE_1__BOLD_4&lt;/code&gt;int`` 유형의 경우, 반드시 반환 값이 있어야 하며, 그렇지 않으면 정의되지 않은 동작이 발생할 수 있습니다&lt;/p&gt;
&lt;h3 id=&#34;컴파일-경고&#34;&gt;컴파일 경고
&lt;/h3&gt;&lt;p&gt;프로젝트에서 CMake 스크립트가 여러 컴파일 경고를 숨겼는데, 그중에는 다음과 같은 경고 메시지도 포함되어 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/root/pstack/main.cpp: In function ‘int test()’:
/root/pstack/main.cpp:7:1: warning: no return statement in function returning non-void [-Wreturn-type]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 경고는 &lt;code&gt;test()&lt;/code&gt; 함수가 반환값을 가지지 않는다는 것을 나타내며, 이것이 문제의 근원입니다. GCC의 높은 버전(예: 8.5.0)은 코드를 최적화할 때 이러한 정의되지 않은 동작에 대해 불안정한 최적화를 수행하여 프로그램 충돌을 일으킬 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;어셈블리-코드-차이&#34;&gt;어셈블리 코드 차이
&lt;/h3&gt;&lt;p&gt;GCC 컴파일러 최적화 동작의 차이를 설명하기 위해, 다양한 버전의 GCC가 생성한 어셈블리 코드를 비교했습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GCC 4.8.5 生成的汇编代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;어셈블리 코드는 다소 장황하며, 표준 출력 스트림(예: &lt;code&gt;std::cout&lt;/code&gt;）的处理逻辑。这表明编译器进行了更保守的优化，未对 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; 함수에서 누락된 반환값 문제)에 대한 과도한 최적화를 포함하고 있어, 이로 인해 런타임 오류를 피했을 가능성이 있습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GCC 8.5.0 生成的汇编代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;새 버전의 GCC는 더 많은 최적화를 수행하여 코드 양을 줄였습니다. 하지만 이러한 최적화로 인해 반환 값이 없는 함수의 실행 동작이 정의되지 않아 프로그램이 충돌할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;결론&#34;&gt;결론
&lt;/h3&gt;&lt;p&gt;이번 문제 해결 과정을 통해 C++에서 &lt;strong&gt;函数返回值必须明确&lt;/strong&gt;, 특히 함수 선언이 &lt;code&gt;int&lt;/code&gt;BOLD_2__일 때, 모든 경고를 숨기지 않고, 특히 반환 값, 타입 매칭 등 흔히 발생하는 문제에 대해 선택적으로 처리해야 한다는 것을 깊이 인식하게 되었습니다&lt;/p&gt;
&lt;p&gt;마침내 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 함수에 반환값을 추가하여 문제를 해결하고 프로그램이 정상적으로 작동하게 되었습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>리눅스 시스템 벤치마크 테스트</title>
        <link>https://ttf248.life/ko/p/linux-system-benchmark-test/</link>
        <pubDate>Tue, 09 Jan 2024 10:56:23 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/linux-system-benchmark-test/</guid>
        <description>&lt;p&gt;윈도우 플랫폼에는 루마스터(유희 마스터)라는 프로그램이 있는데, 데이터가 정확하다고는 할 수 없지만 참고 자료 정도는 된다. 물론 다른 전문 벤치마크 소프트웨어도 있고, 리눅스 시스템에서는 특별히 적합한 벤치마크 프로그램을 찾은 적은 없는 것 같다.&lt;/p&gt;
&lt;p&gt;Sysbench는 CPU, 메모리, 파일 I/O, 스레드 성능 등 다양한 기능을 테스트할 수 있는 다목적 벤치마크 도구입니다. 다양한 성능 테스트 작업을 수행하는 데 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;테스트에 사용할 기기가 세 대 있습니다: 메커니즘 미니 로컬 호스트, 알리바바 클라우드 개발 클라우드 서버, 화웨이 클라우드 개발 서버&lt;/p&gt;
&lt;h2 id=&#34;sysbench-설치&#34;&gt;Sysbench 설치
&lt;/h2&gt;&lt;p&gt;대부분의 Linux 배포판에서 패키지 관리 도구를 사용하여 Sysbench를 설치할 수 있습니다. 예를 들어 CentOS 8에서는 다음 명령어를 사용하여 설치할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo dnf install sysbench
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sysbench-사용-예시&#34;&gt;Sysbench 사용 예시
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CPU 성능 테스트: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;메모리 읽기 성능 테스트: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;테스트 파일 I/O 성능:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysbench --test=fileio --file-test-mode=rndrw prepare
sysbench --test=fileio --file-test-mode=rndrw run
sysbench --test=fileio --file-test-mode=rndrw cleanup
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;멀티스레드 성능 테스트: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;MySQL 데이터베이스 성능 테스트 (최대 연결 수 조정 필요):&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword --oltp-table-size=1000000 prepare
sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword --max-time=60 --oltp-read-only=off --oltp-test-mode=complex --max-requests=0 run
sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword cleanup
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;분포-데이터-보고서&#34;&gt;분포 데이터 보고서
&lt;/h2&gt;&lt;meta http-equiv=&#34;Content-Type&#34; content=&#34;text/html; charset=utf-8&#34;&gt;&lt;link type=&#34;text/css&#34; rel=&#34;stylesheet&#34; href=&#34;resources/sheet.css&#34; &gt;
&lt;style type=&#34;text/css&#34;&gt;.ritz .waffle a { color: inherit; }.ritz .waffle .s0{background-color:#ffffff;text-align:left;color:#000000;font-family:&#39;Arial&#39;;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}&lt;/style&gt;&lt;div class=&#34;ritz grid-container&#34; dir=&#34;ltr&#34;&gt;&lt;table class=&#34;waffle&#34; cellspacing=&#34;0&#34; cellpadding=&#34;0&#34;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th class=&#34;row-header freezebar-origin-ltr&#34;&gt;&lt;/th&gt;&lt;th id=&#34;0C0&#34; style=&#34;width:100px;&#34; class=&#34;column-headers-background&#34;&gt;A&lt;/th&gt;&lt;th id=&#34;0C1&#34; style=&#34;width:421px;&#34; class=&#34;column-headers-background&#34;&gt;B&lt;/th&gt;&lt;th id=&#34;0C2&#34; style=&#34;width:398px;&#34; class=&#34;column-headers-background&#34;&gt;C&lt;/th&gt;&lt;th id=&#34;0C3&#34; style=&#34;width:422px;&#34; class=&#34;column-headers-background&#34;&gt;D&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R0&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;1&lt;/div&gt;&lt;/th&gt;&lt;td&gt;&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;本地机械师&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;阿里云&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;华为云&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R1&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;2&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;系统配置&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;System Information&lt;br&gt;  Operating System              Ubuntu 23.04&lt;br&gt;  Kernel                        Linux 6.2.0-36-generic x86_64&lt;br&gt;  Model                         Machenike Machenike DT Computer&lt;br&gt;  Motherboard                   Machenike Machenike DT Computer&lt;br&gt;  BIOS                          American Megatrends International, LLC.&lt;br&gt;DB19V012&lt;br&gt;&lt;br&gt;CPU Information&lt;br&gt;  Name                          Intel Core i7-12650H&lt;br&gt;  Topology                      1 Processor, 10 Cores, 16 Threads&lt;br&gt;  Identifier                    GenuineIntel Family 6 Model 154 Stepping 3&lt;br&gt;  Base Frequency                4.60 GHz&lt;br&gt;  L1 Instruction Cache          32.0 KB x 8&lt;br&gt;  L1 Data Cache                 48.0 KB x 8&lt;br&gt;  L2 Cache                      1.25 MB x 2&lt;br&gt;  L3 Cache                      24.0 MB&lt;br&gt;&lt;br&gt;Memory Information&lt;br&gt;  Size                          62.6 GB&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;System Information&lt;br&gt;  Operating System              CentOS Stream 8&lt;br&gt;  Kernel                        Linux 4.18.0-513.el8.x86_64 x86_64&lt;br&gt;  Model                         Alibaba Cloud Alibaba Cloud ECS&lt;br&gt;  Motherboard                   N/A&lt;br&gt;  BIOS                          SeaBIOS 449e491&lt;br&gt;&lt;br&gt;CPU Information&lt;br&gt;  Name                          Intel(R) Xeon(R) Platinum&lt;br&gt;  Topology                      1 Processor, 1 Core, 2 Threads&lt;br&gt;  Identifier                    GenuineIntel Family 6 Model 85 Stepping 4&lt;br&gt;  Base Frequency                2.50 GHz&lt;br&gt;  L1 Instruction Cache          32.0 KB&lt;br&gt;  L1 Data Cache                 32.0 KB&lt;br&gt;  L2 Cache                      1.00 MB&lt;br&gt;  L3 Cache                      33.0 MB&lt;br&gt;&lt;br&gt;Memory Information&lt;br&gt;  Size                          1.65 GB&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;System Information&lt;br&gt;  Operating System              Ubuntu 22.04.1 LTS&lt;br&gt;  Kernel                        Linux 5.15.0-60-generic x86_64&lt;br&gt;  Model                         OpenStack Foundation OpenStack Nova&lt;br&gt;  Motherboard                   N/A&lt;br&gt;  BIOS                          SeaBIOS&lt;br&gt;rel-1.10.2-0-g5f4c7b1-20181220_000000-szxrtosci10000&lt;br&gt;&lt;br&gt;CPU Information&lt;br&gt;  Name                          Intel(R) Xeon(R) Gold 6278C CPU @ 2.60GHz&lt;br&gt;  Topology                      1 Processor, 1 Core, 2 Threads&lt;br&gt;  Identifier                    GenuineIntel Family 6 Model 85 Stepping 7&lt;br&gt;  Base Frequency                2.60 GHz&lt;br&gt;  L1 Instruction Cache          32.0 KB&lt;br&gt;  L1 Data Cache                 32.0 KB&lt;br&gt;  L2 Cache                      1.00 MB&lt;br&gt;  L3 Cache                      35.8 MB&lt;br&gt;&lt;br&gt;Memory Information&lt;br&gt;  Size                          3.64 GB&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R2&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;3&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;CPU&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Prime numbers limit: 10000&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;CPU speed:&lt;br&gt;    events per second:  4032.48&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0004s&lt;br&gt;    total number of events:              40330&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.25&lt;br&gt;         avg:                                    0.25&lt;br&gt;         max:                                    0.73&lt;br&gt;         95th percentile:                        0.25&lt;br&gt;         sum:                                 9997.55&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           40330.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9975/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Prime numbers limit: 10000&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;CPU speed:&lt;br&gt;    events per second:  1062.51&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0008s&lt;br&gt;    total number of events:              10628&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.91&lt;br&gt;         avg:                                    0.94&lt;br&gt;         max:                                   22.84&lt;br&gt;         95th percentile:                        1.06&lt;br&gt;         sum:                                 9993.46&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           10628.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9935/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Prime numbers limit: 10000&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;CPU speed:&lt;br&gt;    events per second:  1125.56&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0005s&lt;br&gt;    total number of events:              11258&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.86&lt;br&gt;         avg:                                    0.89&lt;br&gt;         max:                                    1.70&lt;br&gt;         95th percentile:                        0.99&lt;br&gt;         sum:                                 9995.40&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           11258.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9954/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R3&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;4&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;内存&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Running memory speed test with the following options:&lt;br&gt;  block size: 1KiB&lt;br&gt;  total size: 102400MiB&lt;br&gt;  operation: write&lt;br&gt;  scope: global&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;Total operations: 101993199 (10198146.52 per second)&lt;br&gt;&lt;br&gt;99602.73 MiB transferred (9959.13 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0001s&lt;br&gt;    total number of events:              101993199&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.00&lt;br&gt;         max:                                    0.03&lt;br&gt;         95th percentile:                        0.00&lt;br&gt;         sum:                                 4059.50&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           101993199.0000/0.00&lt;br&gt;    execution time (avg/stddev):   4.0595/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Running memory speed test with the following options:&lt;br&gt;  block size: 1KiB&lt;br&gt;  total size: 102400MiB&lt;br&gt;  operation: write&lt;br&gt;  scope: global&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;Total operations: 48418803 (4841004.79 per second)&lt;br&gt;&lt;br&gt;47283.99 MiB transferred (4727.54 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0001s&lt;br&gt;    total number of events:              48418803&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.00&lt;br&gt;         max:                                   25.26&lt;br&gt;         95th percentile:                        0.00&lt;br&gt;         sum:                                 4578.95&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           48418803.0000/0.00&lt;br&gt;    execution time (avg/stddev):   4.5789/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Running memory speed test with the following options:&lt;br&gt;  block size: 1KiB&lt;br&gt;  total size: 102400MiB&lt;br&gt;  operation: write&lt;br&gt;  scope: global&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;Total operations: 57056904 (5704765.11 per second)&lt;br&gt;&lt;br&gt;55719.63 MiB transferred (5571.06 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0001s&lt;br&gt;    total number of events:              57056904&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.00&lt;br&gt;         max:                                    0.06&lt;br&gt;         95th percentile:                        0.00&lt;br&gt;         sum:                                 4556.06&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           57056904.0000/0.00&lt;br&gt;    execution time (avg/stddev):   4.5561/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R4&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;5&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;硬盘&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;2147483648 bytes written in 1.81 seconds (1129.59 MiB/sec).&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Extra file open flags: (none)&lt;br&gt;128 files, 16MiB each&lt;br&gt;2GiB total file size&lt;br&gt;Block size 16KiB&lt;br&gt;Number of IO requests: 0&lt;br&gt;Read/Write ratio for combined random IO test: 1.50&lt;br&gt;Periodic FSYNC enabled, calling fsync() each 100 requests.&lt;br&gt;Calling fsync() at the end of test, Enabled.&lt;br&gt;Using synchronous I/O mode&lt;br&gt;Doing random r/w test&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;File operations:&lt;br&gt;    reads/s:                      3373.41&lt;br&gt;    writes/s:                     2248.94&lt;br&gt;    fsyncs/s:                     7201.80&lt;br&gt;&lt;br&gt;Throughput:&lt;br&gt;    read, MiB/s:                  52.71&lt;br&gt;    written, MiB/s:               35.14&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0127s&lt;br&gt;    total number of events:              128288&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.08&lt;br&gt;         max:                                    5.14&lt;br&gt;         95th percentile:                        0.34&lt;br&gt;         sum:                                 9977.78&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           128288.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9778/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;2147483648 bytes written in 19.29 seconds (106.16 MiB/sec).&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Extra file open flags: (none)&lt;br&gt;128 files, 16MiB each&lt;br&gt;2GiB total file size&lt;br&gt;Block size 16KiB&lt;br&gt;Number of IO requests: 0&lt;br&gt;Read/Write ratio for combined random IO test: 1.50&lt;br&gt;Periodic FSYNC enabled, calling fsync() each 100 requests.&lt;br&gt;Calling fsync() at the end of test, Enabled.&lt;br&gt;Using synchronous I/O mode&lt;br&gt;Doing random r/w test&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;File operations:&lt;br&gt;    reads/s:                      1593.12&lt;br&gt;    writes/s:                     1062.08&lt;br&gt;    fsyncs/s:                     3406.64&lt;br&gt;&lt;br&gt;Throughput:&lt;br&gt;    read, MiB/s:                  24.89&lt;br&gt;    written, MiB/s:               16.60&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0164s&lt;br&gt;    total number of events:              60600&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.16&lt;br&gt;         max:                                   31.32&lt;br&gt;         95th percentile:                        0.54&lt;br&gt;         sum:                                 9956.30&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           60600.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9563/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;2147483648 bytes written in 18.29 seconds (111.98 MiB/sec).&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Extra file open flags: (none)&lt;br&gt;128 files, 16MiB each&lt;br&gt;2GiB total file size&lt;br&gt;Block size 16KiB&lt;br&gt;Number of IO requests: 0&lt;br&gt;Read/Write ratio for combined random IO test: 1.50&lt;br&gt;Periodic FSYNC enabled, calling fsync() each 100 requests.&lt;br&gt;Calling fsync() at the end of test, Enabled.&lt;br&gt;Using synchronous I/O mode&lt;br&gt;Doing random r/w test&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;File operations:&lt;br&gt;    reads/s:                      1665.88&lt;br&gt;    writes/s:                     1110.59&lt;br&gt;    fsyncs/s:                     3563.77&lt;br&gt;&lt;br&gt;Throughput:&lt;br&gt;    read, MiB/s:                  26.03&lt;br&gt;    written, MiB/s:               17.35&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0112s&lt;br&gt;    total number of events:              63355&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.16&lt;br&gt;         max:                                  205.01&lt;br&gt;         95th percentile:                        0.78&lt;br&gt;         sum:                                 9972.64&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           63355.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9726/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R5&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;6&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;多线程&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 4&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0002s&lt;br&gt;    total number of events:              197956&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.16&lt;br&gt;         avg:                                    0.20&lt;br&gt;         max:                                    0.34&lt;br&gt;         95th percentile:                        0.21&lt;br&gt;         sum:                                39970.47&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           49489.0000/5.70&lt;br&gt;    execution time (avg/stddev):   9.9926/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 4&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0174s&lt;br&gt;    total number of events:              18360&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.57&lt;br&gt;         avg:                                    2.18&lt;br&gt;         max:                                   32.77&lt;br&gt;         95th percentile:                        2.61&lt;br&gt;         sum:                                40050.41&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           4590.0000/94.36&lt;br&gt;    execution time (avg/stddev):   10.0126/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 4&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0004s&lt;br&gt;    total number of events:              28536&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.23&lt;br&gt;         avg:                                    1.40&lt;br&gt;         max:                                    3.56&lt;br&gt;         95th percentile:                        1.47&lt;br&gt;         sum:                                39975.16&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           7134.0000/39.87&lt;br&gt;    execution time (avg/stddev):   9.9938/0.01&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ChatGPT&lt;/code&gt;**BOLD_2&lt;code&gt;Markdown&lt;/code&gt;완전히 표 형태로 만들 수 없으며, 그렇게 하지 않으면 효과가 매우 나쁩니다. 사용자 정의 테마는 페이지 최대 너비를 제한하고, 페이지 설정이 동기화되어 너비가 퍼센트 제한으로 변경되었습니다.__&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;간단한 방법은 TablesGenerator와 같은 온라인 도구를 사용하여 HTML 테이블을 생성하는 것입니다(복잡한 내용은 적합하지 않음)&lt;/li&gt;
&lt;li&gt;또는 구글 온라인 문서로 작성한 후 HTML 문서로 다운로드하여 저장하고, 블로그에 바로 복사하는 방법이 있습니다 (간단하고 직접적이며, 최종적으로 이 방법을 사용했습니다)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;config 설정에서 unsafe 옵션이 활성화되어 있는지 확인하고, 페이지별로 너비를 개별적으로 지정하세요&lt;/p&gt;
&lt;p&gt;Hugo에서 페이지별로 너비를 설정할 수 있습니다. 이는 페이지의 프론트 매터에 사용자 지정 파라미터를 추가하여 구현할 수 있습니다. 다음은 예시입니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;마크다운 페이지의 프론트 매터 부분(일반적으로 파일 시작 부분)에 사용자 지정 파라미터를 추가하세요. 예를 들어, &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;---
title: &amp;quot;我的页面&amp;quot;
date: 2024-01-09
custom_width: &amp;quot;800px&amp;quot;  # 设置宽度为 800 像素
---

正文内容...
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;귀하의 Hugo 테마에서 해당 단일 페이지 템플릿 파일(예: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;)을 찾거나 생성하십시오&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;단일 페이지 템플릿에서, 페이지의 프론트 매터에 &lt;code&gt;custom_width&lt;/code&gt;BOLD_2&lt;code&gt;div&lt;/code&gt;가 있는지 확인하세요:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{{ define &amp;quot;main&amp;quot; }}
  &amp;lt;div style=&amp;quot;max-width: {{ with .Params.custom_width }}{{ . }}{{ else }}100%{{ end }}; margin: 0 auto;&amp;quot;&amp;gt;
    {{ .Content }}
  &amp;lt;/div&amp;gt;
{{ end }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 예제에서는 인라인 스타일(&lt;strong&gt;INLINE_CODE_0__属性）为 &lt;code&gt;div&lt;/code&gt; 元素设置了 &lt;code&gt;max-width&lt;/code&gt;BOLD_8__INLINE_CODE_3&lt;/strong&gt; 参数时，宽度默认为100%。&lt;code&gt;margin: 0 auto;&lt;/code&gt; 用于将 &lt;code&gt;div&lt;/code&gt;) 요소들을 가운데 정렬했습니다&lt;/p&gt;
&lt;p&gt;실제 적용 시에는 주제 구조와 CSS 스타일의 세부 사항에 따라 위 예시를 조정해야 할 수 있습니다. 스타일을 조정할 때는 일관성과 가독성을 유지하는 것이 중요합니다.&lt;/p&gt;
&lt;p&gt;활성화된 테마가 약간 달라서, 사이트 사용자 정의의 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 설정을 최종적으로 조정했습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>도커에 대한 몇 가지 이야기</title>
        <link>https://ttf248.life/ko/p/docker-two-three-things/</link>
        <pubDate>Thu, 21 Jan 2021 09:26:07 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/docker-two-three-things/</guid>
        <description>&lt;p&gt;오랫동안 일하면서 접했던 __操作系统，如果是__사용자__用户或者__의 일부 내용이 적용되지 않습니다&lt;/p&gt;
&lt;p&gt;설치 부분은 칭화대학교의 매뉴얼을 참고하세요: &lt;a class=&#34;link&#34; href=&#34;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;설치&#34;&gt;설치
&lt;/h2&gt;&lt;p&gt;알 수 없는 불가사의한 힘으로 인해, 국내 설치 시에는 클라우드 공급업체가 제공하는 저장소 주소를 사용하는 것이 좋습니다. 여기서는 &lt;strong&gt;阿里云&lt;/strong&gt;를 추천합니다.&lt;/p&gt;
&lt;h3 id=&#34;저장소-소스-주소-설정&#34;&gt;저장소 소스 주소 설정
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install yum-utils device-mapper-persistent-data lvm2 &amp;amp;&amp;amp; \
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;최신-버전-배포&#34;&gt;최신 버전 배포
&lt;/h3&gt;&lt;p&gt;도커는 일반적으로 사용되는 백그라운드 서비스이므로, 부팅 시 자동 시작으로 설정하는 것을 권장하며, 현재 명령어는 CentOS 7에 적용 가능합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum install -y docker-ce docker-ce-cli containerd.io &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;지정-버전-배포&#34;&gt;지정 버전 배포
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;kubernetes&lt;/code&gt;和__INLINE_CODE_1__的发布并没与完全同步，如果接下来需要部署&lt;code&gt;kubernetes&lt;/code&gt;，请参考&lt;code&gt;kubernetes&lt;/code&gt;部署说明，安装指定版本的&lt;code&gt;docker&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum list docker-ce --showduplicates | sort -r
sudo yum install -y docker-ce-18.09.2-3.el7 docker-ce-cli-18.09.2-3.el7 containerd.io-18.09.2-3.el7 &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;일반-사용자에-docker-권한-추가&#34;&gt;일반 사용자에 Docker 권한 추가
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo usermod -aG docker ${USER}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;제거&#34;&gt;제거
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum erase -y docker-ce docker-ce-cli containerd.io
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;일상-사용&#34;&gt;일상 사용
&lt;/h2&gt;&lt;h3 id=&#34;미러-가속&#34;&gt;미러 가속
&lt;/h3&gt;&lt;p&gt;여전히 예측할 수 없는 미지의 힘으로 인해 이미지 다운로드 속도가 느리지만, 국내 클라우드 제공업체들이 다양한 가속 서비스를 제공하고 있으므로 &lt;strong&gt;阿里云&lt;/strong&gt;을 추천합니다&lt;/p&gt;
&lt;p&gt;가속된 주소는 직접 알리바바 클라우드 계정을 등록하여 확인하시기 바랍니다. 이 서비스는 무료이며, 알리바바 클라우드는 무료 이미지 빌드 서비스도 제공합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt; /etc/docker/daemon.json &amp;lt;&amp;lt;EOF
{
  &amp;quot;registry-mirrors&amp;quot;: [
    &amp;quot;https://docker.nju.edu.cn&amp;quot;,
    &amp;quot;https://mirror.baidubce.com&amp;quot;,
    &amp;quot;https://docker.m.daocloud.io&amp;quot;,
    &amp;quot;https://docker.mirrors.sjtug.sjtu.edu.cn&amp;quot;
  ]
}
EOF
systemctl daemon-reload &amp;amp;&amp;amp; \
systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;강력-추천-제어판&#34;&gt;강력 추천 제어판
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker volume create portainer_data &amp;amp;&amp;amp; \
docker run -d --name=portainer --restart=always -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:2.20.3-alpine
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;자주-사용하는-이미지-모음&#34;&gt;자주 사용하는 이미지 모음
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker pull rancher/rancher:stable &amp;amp;&amp;amp; docker pull  portainer/portainer-ce:2.0.1 &amp;amp;&amp;amp; \
docker pull centos:7 &amp;amp;&amp;amp; docker pull ubuntu:20.04 &amp;amp;&amp;amp; docker pull ubuntu:18.04 &amp;amp;&amp;amp; \
docker pull redis:5 &amp;amp;&amp;amp; docker pull redis:6 &amp;amp;&amp;amp; \
docker pull alpine:3.11 &amp;amp;&amp;amp; docker pull busybox:1.32 &amp;amp;&amp;amp; \
docker pull rabbitmq:3.7-management &amp;amp;&amp;amp; \
docker pull mariadb:10.2 &amp;amp;&amp;amp; \
docker pull nginx:1.18 &amp;amp;&amp;amp; docker pull nginx:1.19 &amp;amp;&amp;amp; \
docker pull mysql:5.6 &amp;amp;&amp;amp; docker pull mysql:8 &amp;amp;&amp;amp; \
docker pull elasticsearch:6.8.11 &amp;amp;&amp;amp; docker pull logstash:6.8.11 &amp;amp;&amp;amp; docker pull kibana:6.8.11 &amp;amp;&amp;amp; \
docker pull zookeeper:3.4 &amp;amp;&amp;amp; \
docker pull influxdb:1.7 &amp;amp;&amp;amp; docker pull grafana/grafana:7.3.1 &amp;amp;&amp;amp; \
docker pull percona:8 &amp;amp;&amp;amp; docker pull percona:5.6 &amp;amp;&amp;amp; \
docker pull cloverzrg/frps-docker:0.34.3 &amp;amp;&amp;amp; docker pull cloverzrg/frpc-docker:0.34.3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;자주-사용되는-명령어-조합&#34;&gt;자주 사용되는 명령어 조합
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/engine/reference/commandline/docker/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.docker.com/engine/reference/commandline/docker/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;컨테이너 실행 상태를 확인하고 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 매개변수를 추가하여 자세한 컨테이너 정보를 확인합니다. 이때는 이미지 정보는 무시합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker ps --format &amp;quot;{{.Names}}: {{.Ports}}: {{.Size}}&amp;quot;
#portainer: 0.0.0.0:8000-&amp;gt;8000/tcp, 0.0.0.0:9000-&amp;gt;9000/tcp: 0B (virtual 172MB)
#influxdb: 0.0.0.0:8086-&amp;gt;8086/tcp: 183B (virtual 311MB)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;모든 컨테이너 중지&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker stop $(docker ps -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;모든 이미지를 한 번에 삭제합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dokcer rmi $(docker images -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;이미지 내보내기&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; &amp;gt; -o XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이미지 내보내기 및 압축&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; | gzip &amp;gt; XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이미지 가져오기&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker load -i XXX.tar
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>리눅스 기반 Jmeter 부하 테스트 환경 구축</title>
        <link>https://ttf248.life/ko/p/linux-setup-jmeter-testing-environment/</link>
        <pubDate>Tue, 22 Dec 2020 10:12:50 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/linux-setup-jmeter-testing-environment/</guid>
        <description>&lt;p&gt;저자는 하드웨어에 대한 높은 관심을 가지고 있으며, Jmeter를 사용하여 성능 테스트를 진행하고 CentOS 7에 Jmeter, InfluxDB 및 Grafana를 배포하는 과정을 기록했습니다. Jmeter 설치 및 명령어 사용법, InfluxDB의 특징 및 Docker 설치 방법, 그리고 Grafana의 간단한 배포 및 구성 방법을 공유하며, 고성능 프로그램 패턴 경험과 참고 자료를 정리했습니다.&lt;/p&gt;
&lt;h2 id=&#34;배경&#34;&gt;배경
&lt;/h2&gt;&lt;p&gt;데이터 시현 외에 웹 패널을 추가로 구성하는 것이 무슨 소용이 있나요?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;생각은 자기만 생각하는 대로인데, 직접 해봐야 알 수 있어
Don&amp;rsquo;t use GUI mode for load testing! only for Test creation and Test debuggin.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;공식적으로 추천하는 방식은 명령줄을 통해 부하 테스트 보고서를 얻고 GUI 방식으로 표시하는데, 데이터 오류가 발생할 수 있나요? JMeter에 대한 이해는 깊지 않지만, 적어도 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 버전의 콘솔 패널을 굴려볼 만한 이유를 찾았습니다&lt;/p&gt;
&lt;p&gt;오픈소스 차이나 게시글인데, 핵심 컴포넌트 배포 방식이 썩 좋지 않고, 설치에 필요한 파일도 다운로드하려면 공중계정을 팔로우해야 한다. 새세대 사용자로서 당연히 __INLIN_ITALIC_1____으로 대체했다. 결국 서버가 국내에 있어야 하고, 해외 소스 주소 접근 속도는 매우 느리다. 적어도 미러 서비스는 알리바바 클라우드에 무료 가속 기능이 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 설치 배포에 대한 내용은 여기서는 더 이상 다루지 않으며, 이전 자료를 참고하시기를 권장합니다&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;다음 내용은 크게 두 부분으로 나뉩니다: 기본 테스트 환경 구성 요소 구축 및 각 요소에 대한 간단한 설명입니다&lt;/p&gt;
&lt;h2 id=&#34;jmeter&#34;&gt;Jmeter
&lt;/h2&gt;&lt;p&gt;Apache JMeter는 Apache 재단에서 개발한 Java 기반의 성능 테스트 도구입니다. 소프트웨어에 대한 부하 테스트를 위해 설계되었으며, 처음에는 웹 애플리케이션 테스트용으로 만들어졌지만 이후 다른 테스트 영역으로 확장되었습니다. 정적 파일, Java 마이크로 서비스, CGI 스크립트, Java 객체, 데이터베이스, FTP 서버 등 정적 및 동적 리소스를 테스트하는 데 사용할 수 있습니다. JMeter는 다양한 압력 범주에서 서버, 네트워크 또는 객체에 대한 막대한 부하를 시뮬레이션하여 강점을 테스트하고 전체 성능을 분석할 수 있습니다. 또한 JMeter는 어설션을 사용하여 스크립트를 생성하여 프로그램이 예상 결과를 반환하는지 확인하여 기능/회귀 테스트를 수행할 수 있습니다. 최대의 유연성을 위해 JMeter는 정규 표현식을 사용하여 어설션을 만들 수 있습니다.&lt;/p&gt;
&lt;p&gt;Apache JMeter는 정적 및 동적 리소스(파일, 서블릿, Perl 스크립트, Java 객체, 데이터베이스 쿼리, FTP 서버 등)의 성능 테스트에 사용될 수 있습니다. 서버, 네트워크 또는 객체에 과도한 부하를 가하여 강도를 테스트하거나 다양한 압력 유형에서 전체적인 성능을 분석하는 데 활용할 수 있으며, 성능 그래프 분석이나 고동시 부하 테스트에도 적합합니다.&lt;/p&gt;
&lt;h3 id=&#34;jmeter-배포-centos7&#34;&gt;JMeter 배포 CentOS7
&lt;/h3&gt;&lt;p&gt;설치 패키지&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install java-1.8.0-openjdk -y &amp;amp;&amp;amp; \
wget https://mirrors.bfsu.edu.cn/apache//jmeter/binaries/apache-jmeter-5.4.tgz &amp;amp;&amp;amp; tar -xf apache-jmeter-5.4.tgz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;환경 변수 설정&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export JMETER_HOME=$HOME/jmeter/apache-jmeter-5.4
export PATH=$JMETER_HOME/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;지메터-명령어&#34;&gt;지메터 명령어
&lt;/h3&gt;&lt;p&gt;최종적으로 __控制面板，可以不输入&lt;code&gt;Grafana&lt;/code&gt;参数，在__INLINE_CODE_2__제어판 관측 데이터&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;jmeter -n -t /tmp/order-500-10s.jmx -l /tmp/jmeter-order-report-20200109/order-500-10s.jtl
# 一般不用测试结果和测试报告，简化命令
jmeter -n -t /tmp/order-500-10s.jmx
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;influxdb&#34;&gt;InfluxDB
&lt;/h2&gt;&lt;p&gt;InfluxDB는 Go 언어로 작성된 오픈 소스 분산 시계열, 이벤트 및 지표 데이터베이스이며 외부 의존성이 필요 없습니다. 현재 DevOps 모니터링 데이터, APP 메트릭, IoT 센서 데이터 및 실시간 분석 데이터를 포함한 대량의 타임스탬프 데이터를 저장하는 데 주로 사용됩니다.&lt;/p&gt;
&lt;h3 id=&#34;인플럭스db-특징&#34;&gt;인플럭스DB 특징
&lt;/h3&gt;&lt;p&gt;인플럭스DB의 특징은 다음과 같이 9가지로 요약할 수 있습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;구조(패턴) 없음: 열의 개수가 임의일 수 있습니다&lt;/li&gt;
&lt;li&gt;메트릭 저장 기간을 설정할 수 있습니다&lt;/li&gt;
&lt;li&gt;통계 편의를 위해 시간 관련 함수(최소, 최대, 합계, 개수, 평균, 중앙값 등) 지원;&lt;/li&gt;
&lt;li&gt;지원되는 저장 정책: 데이터의 삭제 및 수정에 사용 가능합니다.(InfluxDB는 데이터 삭제 및 수정 방법을 제공하지 않습니다.)&lt;/li&gt;
&lt;li&gt;연속 쿼리 지원: 데이터베이스에서 자동으로 주기적으로 실행되는 일련의 문이며, 저장 정책과 함께 사용하면 InfluxDB 시스템 점유량을 줄일 수 있습니다&lt;/li&gt;
&lt;li&gt;네이티브 HTTP 지원, 내장된 HTTP API;&lt;/li&gt;
&lt;li&gt;SQL과 유사한 구문을 지원합니다&lt;/li&gt;
&lt;li&gt;클러스터 내 데이터 복제본 수를 설정할 수 있습니다&lt;/li&gt;
&lt;li&gt;정기 샘플링 데이터를 지원하고, 별도의 measurement에 기록하여 세분화된 데이터 저장 기능을 제공합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;인플럭스db-도커-설치&#34;&gt;인플럭스DB 도커 설치
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir influxdb &amp;amp;&amp;amp; cd influxdb &amp;amp;&amp;amp; \
docker run -p 8086:8086 -d --name influxdb -v $PWD:/var/lib/influxdb influxdb:1.7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;컨테이너에 진입하여 명령을 실행하고, 수동으로 데이터베이스를 생성합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;root@bce0a55bbc72:/# influx
Connected to http://localhost:8086 version 1.7.10
InfluxDB shell version: 1.7.10
&amp;gt; 交互面板执行命令
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;인플럭스db-데이터베이스-및-사용자-생성&#34;&gt;인플럭스DB 데이터베이스 및 사용자 생성
&lt;/h3&gt;&lt;p&gt;데이터베이스 생성: create database jmeter_t2
데이터베이스 확인:
데이터베이스 전환: use jmeter_t2
관리자 권한으로 비밀번호가 &amp;lsquo;admin&amp;rsquo;인 사용자 &amp;ldquo;admin&amp;quot;을 생성합니다
사용자 보기&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; show users
user  admin
----  -----
admin true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;사용자 권한이 표시되면 데이터베이스 준비가 완료되었습니다&lt;/p&gt;
&lt;h2 id=&#34;grafana&#34;&gt;Grafana
&lt;/h2&gt;&lt;p&gt;테스트 케이스를 작성하다 보니 차트 표시가 크게 필요하지 않다는 것을 알게 되었고, 인터페이스의 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 데이터는 명령줄에서 실행하면 이미 관찰할 수 있으며, 더 중요한 것은 프로그램 내부의 소요 시간이다&lt;/p&gt;
&lt;p&gt;간단한 배포&lt;/p&gt;
&lt;p&gt;테스트 결과를 태그로 필터링할 수 있으며, 일반적으로 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 데이터베이스 하나만 구성하면 됩니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;애플리케이션 이름&lt;/li&gt;
&lt;li&gt;테스트 사례 이름&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/linux-setup-jmeter-testing-environment/Snipaste_2021-03-09_19-44-22.png&#34;
	width=&#34;861&#34;
	height=&#34;357&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;grafana&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;241&#34;
		data-flex-basis=&#34;578px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -d --name=grafana -p 3000:3000 grafana/grafana:7.3.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;웹 버전은 샘플러 간격으로 인해 계산된 __INLINE_CODE_0__和相关数值与__INLINE_CODE_1__聚合报告不相符，参考链接：&lt;strong&gt;링크_2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;자료에서는 __INLINE_CODE_0__을 사용자 정의하는 방법도 설명하고 있습니다&lt;/p&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;고성능 프로그램 모드는 단일 루프 스레드여야 하며, 잠금, 큐에 넣기 및 큐에서 제거하는 작업은 불필요한 성능 저하를 야기한다&lt;/li&gt;
&lt;li&gt;핵심 비즈니스 로직의 처리 시간은 다른 코드 도입에 필요한 시간보다 길기 때문에, 동시성으로 효율을 높이는 것이 효과적이다. 핵심 처리 시간이 충분히 짧다면 다른 코드를 신중하게 도입하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@jasonli.studio/to-install-apache-jmeter-in-centos7-294bc72a97ba&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;To install Apache JMeter in CentOS7&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>레드햇과 CentOS 라이프사이클</title>
        <link>https://ttf248.life/ko/p/redhat-centos-lifecycle/</link>
        <pubDate>Tue, 21 Jul 2020 20:02:35 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/redhat-centos-lifecycle/</guid>
        <description>&lt;p&gt;온라인 생산 환경 운영체제는 Red Hat과 CentOS가 주류 선택입니다. 두 시스템의 라이프사이클에 대한 공식 웹사이트 링크를 기록하고 CentOS 8에서 CentOS 8 Stream으로 업그레이드 경험을 공유합니다.&lt;/p&gt;
&lt;h2 id=&#34;서론&#34;&gt;서론
&lt;/h2&gt;&lt;p&gt;온라인 생산 환경 운영체제는 현재 국내에서 Red Hat과 CentOS가 주류 선택입니다. 지난 2년간 Red Hat 6의 지원 종료를 겪었기에, 두 시스템의 라이프사이클 공식 웹사이트 링크를 기록합니다.&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://access.redhat.com/support/policy/updates/errata&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Red Hat Enterprise Linux Life Cycle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;레드햇 엔터프라이즈 리눅스(RHEL)와 CentOS는 기업용 서버 운영체제에서 널리 사용되는 선택입니다. RHEL은 안정적인 지원 및 업데이트 주기를 제공하여 기업 환경에 적합하며, CentOS는 RHEL의 커뮤니티 버전으로서 유사한 기능과 안정성을 제공하지만 공식 지원은 없습니다.&lt;/p&gt;
&lt;h2 id=&#34;계속-봐&#34;&gt;계속 봐
&lt;/h2&gt;&lt;p&gt;이 글을 게시할 때, 두 년 후 업데이트를 하게 될 줄은 상상도 못 했습니다. 이틀 전까지만 해도 일상적으로 사용하는 가상 머신을 CentOS 8에서 CentOS 8 Stream으로 업그레이드했습니다. 생산 환경에 어떻게 선택할지는 논하지 않겠습니다만, 로컬 환경에서는 최신 버전을 추구합니다.&lt;/p&gt;
&lt;p&gt;CentOS 8 Stream은 지속적인 업데이트를 제공하는 롤링 릴리스 버전으로, 개발 및 테스트 환경에 적합합니다&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
