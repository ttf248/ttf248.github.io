<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>향숙의 수첩</title>
        <link>https://ttf248.life/ko/</link>
        <description>Recent content on 향숙의 수첩</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ko</language>
        <lastBuildDate>Sun, 25 May 2025 14:10:37 +0800</lastBuildDate><atom:link href="https://ttf248.life/ko/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>클로드4 출시, Hugo 태그 및 하이퍼링크 번역 도우미 개발 시도</title>
        <link>https://ttf248.life/ko/p/claude-4-release-and-experimentation-hugo-tags-hyperlink-translation-assistant/</link>
        <pubDate>Sat, 24 May 2025 03:05:31 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/claude-4-release-and-experimentation-hugo-tags-hyperlink-translation-assistant/</guid>
        <description>&lt;p&gt;이 사이트는 hugo 기반으로 개발되었지만, 글 작성 시 항상 중국어 제목을 사용했기 때문에 생성되는 기사 링크가 그다지 친절하지 않습니다. 쉽게 말해서, 게시했을 때 보기에 좋지 않다는 뜻입니다. 중국어 문자가 하이퍼링크에서 %E4%BD%A0%E5%A5%BD 와 같은 형태로 변환되기 때문이죠. 슬러그를 설정하여 해결할 수는 있지만, 매번 수동으로 설정해야 해서 너무 번거롭습니다.&lt;/p&gt;
&lt;p&gt;그래서 오늘 클로드4를 사용하여 번역 보조 개발을 시도해 봤습니다. 이 도우미는 중국어 제목을 영어 슬러그로 자동으로 변환하고, 기사에 하이퍼링크를 추가합니다. 이렇게 하면 수동 설정의 번거로움을 피할 수 있습니다.&lt;/p&gt;
&lt;p&gt;클로드4는 정말 좋네요, 문맥 이해 능력이 크게 향상되었고 복잡한 작업 처리 효율도 훨씬 좋아졌어요&lt;/p&gt;
&lt;h2 id=&#34;프로젝트-주소&#34;&gt;프로젝트 주소
&lt;/h2&gt;&lt;p&gt;국내 프로젝트 주소: &lt;a class=&#34;link&#34; href=&#34;https://cnb.cool/ttf248/hugo-slug-auto&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cnb.cool/ttf248/hugo-slug-auto&lt;/a&gt;
해외 프로젝트 주소: &lt;a class=&#34;link&#34; href=&#34;https://github.com/ttf248/hugo-slug-auto&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ttf248/hugo-slug-auto&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;코드-구현&#34;&gt;코드 구현
&lt;/h2&gt;&lt;p&gt;먼저 구현 아이디어부터 설명하자면, 모든 기사를 스캔하여 태그 정보와 기사 제목을 추출한 다음, 로컬의 대형 모델(gemma-3-12b-it과 같은)을 호출하여 번역합니다&lt;/p&gt;
&lt;p&gt;실제 개발에서, 이전 세대 대규모 언어 모델과 비교했을 때 &lt;code&gt;Claude4&lt;/code&gt;는 몇 가지 뚜렷한 특징을 보여줍니다. 기능 요구 사항이 많기 때문에 &lt;code&gt;Claude4&lt;/code&gt;는 자동적으로 인터랙티브 메뉴를 설계하여 다양한 사용 시나리오를 종합적으로 고려했습니다. 예를 들어, 태그 처리 측면에서 &lt;code&gt;Claude4&lt;/code&gt;는 태그의 통계 및 분석은 물론 분류 통계까지 지원하며 심지어 &lt;strong&gt;태그가 없는 문서&lt;/strong&gt;도 감지할 수 있습니다. 또한, &lt;strong&gt;미리 보기&lt;/strong&gt;와 태그 페이지 생성 기능도 제공합니다.&lt;/p&gt;
&lt;p&gt;어떤 로컬 모델과 연결하든, 새로운 번역 캐시를 추가하든, 아니면 광범위한 코드 리팩토링을 하든, &lt;code&gt;클로드4&lt;/code&gt;는 한 번에 완료하며 거의 아무런 문제도 발생하지 않습니다. 프로젝트 규모는 크지 않지만 많은 작은 기능들을 포함하고 있습니다. 과거에는 개발 과정에서 대규모 모델이 앞 내용을 자주 잊어버렸는데, 이번 &lt;code&gt;클로드4&lt;/code&gt;는 매우 뛰어난 성능을 보여주며 &lt;strong&gt;거의 문맥을 잊는 경우가 없었습니다&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;간단히 말해서, 지능이 향상되었고, 이후 개발 작업에 더 많은 부분을 위해 &lt;code&gt;클로드4&lt;/code&gt;로 전환할 예정이며, 일상적인 코딩의 주력 모델로 활용할 것입니다&lt;/p&gt;
&lt;h2 id=&#34;번역-캐시&#34;&gt;번역 캐시
&lt;/h2&gt;&lt;p&gt;이 점은 단독으로 볼 때, 거대 모델 호출 횟수를 줄이는 것 외에도 실제 로컬에서 12B 모델을 실행하면 효율이 괜찮고 일을 방해하지 않지만, 매번 거대 모델을 호출해야 하면 조금 느려지는 경향이 있습니다. 또한, 기사의 연결을 고정하기 위해 전체 업데이트 작업을 수행할 때 기사 제목이 길면 가끔 두 번의 번역 결과가 달라져서 기사 링크가 바뀌는 경우가 있는데, 이 부분은 상당히 난감합니다.&lt;/p&gt;
&lt;h2 id=&#34;기능-최적화&#34;&gt;기능 최적화
&lt;/h2&gt;&lt;p&gt;전체 프로젝트를 &lt;code&gt;클로드4&lt;/code&gt;에 맡겨서 분석 및 최적화할 여지를 확인했더니 다음과 같은 제안을 받았습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;配置外置化 - 提高可维护性和灵活性
结构化日志 - 便于问题排查和监控
性能监控 - 了解系统运行状况
用户体验 - 进度条等视觉反馈
错误处理 - 更完善的异常处理机制
代码组织 - 更清晰的模块划分
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;코드 검토를 했는데, 모두 문제 없습니다. 예를 들어 설정 파일의 경우, 기존 코드에서 설정을 가져와 기본 설정으로 변환하고, 설정 파일을 읽을 때 해당 설정 파일이 없으면 자동으로 생성되므로 사용자의 실수로 인한 오류를 방지할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;성능-통계-메뉴&#34;&gt;성능 통계 메뉴
&lt;/h3&gt;&lt;p&gt;새로 추가된 &lt;strong&gt;성능 통계 메뉴&lt;/strong&gt;는 제가 직접 디자인했는데, 이렇게 완벽하게 만들 수 있을 줄은 몰랐습니다&lt;/p&gt;
&lt;p&gt;성능 통계:
번역 횟수: 360
⚡ 캐시 히트율: 1.4% (5/365)
평균 번역 시간: 315.927234ms
파일 작업: 73
실패 횟수: 0&lt;/p&gt;
&lt;h3 id=&#34;진행률-표시&#34;&gt;진행률 표시
&lt;/h3&gt;&lt;p&gt;새롭게 추가된 &lt;strong&gt;진도 표시&lt;/strong&gt;는 상세한 진행 상황, 경과 시간, 남은 예상 시간을 보여줍니다&lt;/p&gt;
&lt;p&gt;기능 선택 (0-13): 10
번역 목표를 수집 중입니다…
📄 캐시 파일이 로드되었습니다. 번역 기록은 0개입니다.&lt;/p&gt;
&lt;p&gt;번역 캐시 통계:
🏷️ 태그 총수: 229개
게시된 총 글 수: 131개
✅ 캐시됨: 0개
360개&lt;/p&gt;
&lt;p&gt;전체 번역 캐시를 생성하시겠습니까? (y/n): y
🚀 전체 번역 캐시 생성 중…
📄 캐시 파일이 로드되었습니다. 번역 기록은 0개입니다.
검색 중인 번역을 캐시에서 확인 중입니다…
새 태그 360개를 번역해야 합니다
[░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 5/360 (1.4%) - 소요시간: 3초 - 예상 남은 시간: 3분 8초💾 캐시 파일 저장 완료, 번역 기록 5개 포함
[█░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 10/360 (2.8%) - 소요시간: 6초 - 예상 남은 시간: 3분 28초💾 캐시 파일 저장 완료, 번역 기록 10개 포함
[██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 15/360 (4.2%) - 소요시간: 9초 - 예상 남은 시간: 3분 30초💾 캐시 파일 저장 완료, 번역 기록 15개 포함
[██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 20/360 (5.6%) - 소요시간: 13초 - 예상 남은 시간: 3분 36초💾 캐시 파일 저장 완료, 번역 기록 20개 포함
[███░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 25/360 (6.9%) - 소요시간: 16초 - 예상 남은 시간: 3분 33초💾 캐시 파일 저장 완료, 번역 기록 25개 포함
[████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 30/360 (8.3%) - 용량: 19s - 예상 남은 시간: 3분 30초💾 캐시 파일 저장 완료, 번역 기록 30개 포함
[████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 35/360 (9.7%) - 용량: 22s - 예상 남은 시간: 3분 25초💾 캐시 파일 저장 완료, 번역 기록 35개 포함&lt;/p&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;=== 博客标签管理工具 ===

📊 数据查看
  1. 标签统计与分析
  2. 分类统计
  3. 无标签文章

🏷️  标签页面管理
  4. 预览标签页面
  5. 生成标签页面

📝 文章Slug管理
  6. 预览文章Slug
  7. 生成文章Slug

💾 缓存管理
  8. 查看缓存状态
  9. 预览全量翻译缓存
 10. 生成全量翻译缓存
 11. 清空翻译缓存

🔧 系统工具
 12. 查看性能统计
 13. 重置性能统计

  0. 退出程序
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;휴고-태그-자동화-관리-도구&#34;&gt;휴고 태그 자동화 관리 도구
&lt;/h1&gt;&lt;p&gt;🚀 Hugo 블로그를 위해 특별히 설계된 스마트 태그 관리 도구입니다. AI 번역, 로컬 캐싱 및 친숙한 인터페이스를 지원합니다.&lt;/p&gt;
&lt;h2 id=&#34;-핵심-특징&#34;&gt;✨ 핵심 특징
&lt;/h2&gt;&lt;h3 id=&#34;-ai-지능-번역&#34;&gt;🤖 AI 지능 번역
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;LM Studio 기반 로컬 AI 모델 번역&lt;/li&gt;
&lt;li&gt;중국어 태그가 SEO 친화적인 영어 슬러그로 자동 변환됩니다&lt;/li&gt;
&lt;li&gt;대량 번역을 지원하여 처리 효율성을 높입니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;스마트-캐시-시스템&#34;&gt;스마트 캐시 시스템
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;로컬 JSON 캐시를 사용하여 중복 번역을 방지합니다&lt;/li&gt;
&lt;li&gt;자동으로 캐시 상태를 감지하여 API 호출을 절약합니다&lt;/li&gt;
&lt;li&gt;캐시 관리 및 삭제 기능을 지원합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;친근한-사용자-인터페이스&#34;&gt;친근한 사용자 인터페이스
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;직관적인 명령줄 메뉴 시스템&lt;/li&gt;
&lt;li&gt;다채로운 출력, 명확하고 읽기 쉬움&lt;/li&gt;
&lt;li&gt;미리보기 기능, 안전하고 믿을 수 있습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;데이터-분석-통계&#34;&gt;데이터 분석 통계
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;태그 사용 빈도 분석&lt;/li&gt;
&lt;li&gt;분류 통계 및 시각화&lt;/li&gt;
&lt;li&gt;태그 없는 기사 검사&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;빠른-시작&#34;&gt;빠른 시작
&lt;/h2&gt;&lt;h3 id=&#34;환경-요구사항&#34;&gt;환경 요구사항
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Go 1.21+&lt;/li&gt;
&lt;li&gt;LM Studio (선택 사항, AI 번역용)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;설치-및-실행&#34;&gt;설치 및 실행
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 克隆项目
git clone https://github.com/ttf248/hugo-slug-auto.git
cd hugo-slug-auto

# 安装依赖
go mod tidy

# 运行工具
go run main.go [content目录路径]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;기본-사용법&#34;&gt;기본 사용법
&lt;/h3&gt;&lt;p&gt;태그 분석: 블로그 태그 사용 통계 확인
각 태그별로 별도의 페이지를 생성합니다
기사 슬러그 관리: 기사 제목으로 SEO 친화적인 URL 생성
번역 캐시 관리: 번역 캐시를 확인하고 관리합니다&lt;/p&gt;
&lt;h2 id=&#34;프로젝트-아키텍처&#34;&gt;프로젝트 아키텍처
&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;hugo-slug-auto/
├── main.go              # 主程序入口
├── models/              # 数据模型
├── scanner/             # 文章扫描解析
├── stats/               # 统计分析
├── translator/          # AI翻译模块
├── generator/           # 内容生成器
├── display/             # 界面显示
└── docs/               # 详细文档
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;-주요-기능&#34;&gt;🎮 주요 기능
&lt;/h2&gt;&lt;h3 id=&#34;태그-관리&#34;&gt;태그 관리
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;태그 통계 분석&lt;/li&gt;
&lt;li&gt;자동 생성 태그 페이지&lt;/li&gt;
&lt;li&gt;일괄 번역 처리&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;문서-관리&#34;&gt;문서 관리
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;📝 슬러그 자동 생성&lt;/li&gt;
&lt;li&gt;기사 내용 분석&lt;/li&gt;
&lt;li&gt;일괄 처리 지원&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;지능형-특징&#34;&gt;지능형 특징
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;AI 기반 번역&lt;/li&gt;
&lt;li&gt;지능형 캐시 메커니즘&lt;/li&gt;
&lt;li&gt;정밀 콘텐츠 식별&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;문서-링크&#34;&gt;문서 링크
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;설치 구성 안내서&lt;/li&gt;
&lt;li&gt;기능 사용 설명서&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;docs/api.md&#34; &gt;API 인터페이스 문서&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;문제 해결&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;기여-가이드&#34;&gt;기여 가이드
&lt;/h2&gt;&lt;p&gt;이슈 및 풀 리퀘스트 제출을 환영합니다! 자세한 내용은 &lt;a class=&#34;link&#34; href=&#34;docs/contributing.md&#34; &gt;기여 가이드&lt;/a&gt;를 참조하세요&lt;/p&gt;
&lt;h2 id=&#34;허가증&#34;&gt;허가증
&lt;/h2&gt;&lt;p&gt;MIT 라이선스 - 자세한 내용은 &lt;a class=&#34;link&#34; href=&#34;LICENSE&#34; &gt;LICENSE&lt;/a&gt; 파일을 참조하십시오&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;이 프로젝트가 도움이 된다면 별을 눌러 지원해주세요!&lt;/p&gt;</description>
        </item>
        <item>
        <title>계획출산 정책의 다차원적 영향: 사회 구조에서 경제 정치에 이르는 심층적 변화</title>
        <link>https://ttf248.life/ko/p/planned-parenthood-multidimensional-impact-social-structure-economic-political-transformation/</link>
        <pubDate>Sat, 24 May 2025 02:36:49 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/planned-parenthood-multidimensional-impact-social-structure-economic-political-transformation/</guid>
        <description>&lt;p&gt;중국의 가족계획 정책은 인구 증가를 제한하는 동시에 가문식 발전을 억제하고 전통적인 사회 구조에 충격을 주었으며, 가문 기업 확장과 정계 가문 세력을 억눌렀습니다. 한국 재벌이나 인도 가족 독점과 비교하면 그 독특성이 드러납니다. 이제 출산 제한을 해제했지만 저출산율 등의 과제를 안고 있으며, 새로운 독점 위험에 대한 경계도 필요합니다. 다방면에서 균형을 찾아야 합니다.&lt;/p&gt;
&lt;h4 id=&#34;일-인구-통제와-가족식-발전의-흥망성쇠&#34;&gt;일, 인구 통제와 가족식 발전의 흥망성쇠
&lt;/h4&gt;&lt;p&gt;계획 생육 정책은 중국이 거의 40년 동안 지속해 온 기본 국책으로서, 그 직접적인 효과는 뚜렷하다. 통계에 따르면 1978년부터 2007년까지 중국의 자연 인구 증가율은 12‰에서 5.2‰로 하락하고, 4억 명이 넘게 출산하지 않았으며, 세계 인구 비율은 22.2%에서 20.1%로 감소했다. 이러한 인구 증가 속도의 급감은 중국 사회의 가족 구조를 심오하게 재편성했다. 가문 기업을 예로 들면, 계획 생육 정책 시행 이후 기업주가 자녀 수를 낳는 비율이 크게 감소했는데, 정책 이전에는 세 명 이상의 자녀를 둔 비율이 40.63%였지만 정책 이후 급격히 18.46%로 떨어지고, 외아들 출산 비율은 6.25%에서 32.31%로 상승했다. 이러한 구조적 변화는 직접적으로 가문 기업이 선택할 수 있는 내부 승계 후보의 범위를 크게 줄여 객관적으로 가문 기업의 세대 간 확장 능력을 억제했다.&lt;/p&gt;
&lt;p&gt;한국과 인도의 상황을 비교하면 차이가 뚜렷하다. 한국은 엄격한 계획출산 정책을 시행하지 않았지만 출산율이 장기간 저조(2023년 0.7)했고, 그럼에도 재벌 그룹은 교차 보유, 상속세 회피 등의 수단을 통해 국가 경제의 핵심을 굳건히 장악하고 있다. 5대 재벌의 총수입은 한국 GDP의 50%를 넘고, 삼성그룹만으로도 전국 GDP의 20%를 차지한다. 반면 인도는 79%의 경제적 생산이 가족 기업에 의해 기여하며, 6대 재단이 통신, 철강 등 핵심 분야를 장악하고, 20개 최고 기업이 전국 기업 이익의 80%를 벌어들인다. 이러한 차이의 핵심은 중국의 계획출산 정책이 가족 규모를 제한하여 가족 기업 확장의 인적 기반을 근본적으로 약화시킨 반면, 한국과 인도는 정책 환경의 차이로 인해 가족 세력이 경제 영역에 지속적으로 침투할 수 있었다는 점이다.&lt;/p&gt;
&lt;h4 id=&#34;제2항-독점-억제와-사회-구조-전환&#34;&gt;제2항 독점 억제와 사회 구조 전환
&lt;/h4&gt;&lt;p&gt;계획수립 정책이 경제 분야에 미치는 영향은 특히 독점 현상을 억제하는 데 두드러지게 나타납니다. 중국 가족 기업은 딸의 수가 줄어들면서 한인식 재벌 그룹을 형성하기 어렵습니다. 한국을 예로 들면, 재벌은 ‘순환 출자’를 통해 가문 통제권을 유지하며, 삼성 가문은 그룹 지점수의 2%만을 보유하고 있지만 복잡한 주주 구조를 통해 전체를 장악합니다. 중국에서는 계획수립 이후 가족 기업들이 보편적으로 “부자간 승계”의 어려움을 겪게 되어 전문 경영인을 영입하거나 지분 다각화 개혁을 진행할 수밖에 없었습니다. 펑파이 뉴스 연구에 따르면, 계획수립 이후 가족 기업 여성 후계인 비율은 13.85%에서 34.21%로 증가했으며, 후계인의 학력도 크게 향상되어 학사 이상 학위 비율은 43.75%에서 98.46%로 상승했습니다. 이러한 전환은 가문 통제를 완전히 해소하지는 못했지만 단일 가문의 시장 독점 가능성을 현저히 낮췄습니다.&lt;/p&gt;
&lt;p&gt;사회 구조 수준에서, 산아구제 정책은 전통적인 가족 핵심 모델의 붕괴를 가속화했습니다. 중국 가정 규모는 1982년의 4.41명/가구에서 2020년의 2.62명/가구로 감소했으며, 소규모 가정은 경제적, 교육적, 사회적 지원과 같은 가족 기능을 약화시켰습니다. 대조적으로 인도는 여전히 4명 정도의 가족 규모를 유지하며 카스트 제도가 가족 세력과 깊이 결합되어 있어 사회 이동성이 낮습니다. 중국의 가족 구조 변화는 개인주의 발전을 위한 공간을 창출했으며, 2023년 중국의 미혼 성인 인구는 2억 4천만 명에 달하며 소비 시장은 “1인 경제” 부상 추세를 보이고 있습니다. 이러한 변화는 더욱 가족 경제적 영향력을 희석시켰습니다.&lt;/p&gt;
&lt;h4 id=&#34;정치-분야의-권력-분산화&#34;&gt;정치 분야의 권력 분산화
&lt;/h4&gt;&lt;p&gt;계획 생육 정책은 정치 생태에도 깊숙한 영향을 미쳤다. 전통적으로 가족 세력은 혈연과 혼인 관계를 통해 근거부 정치에 침투해 왔다. 예를 들어, 하남성 신예현의 161개 정치 가문은 거의 모든 정부 부서를 장악했으며, 부서장급 이상 간부 중 20%가 ‘관이대’였다. 그러나 계획 생육 정책 시행 이후 가족 규모가 축소되면서 가족 네트워크의 확장이 제한되었다. 베이징대학교 연구에 따르면 계획 생육 후 관료 자녀 수가 줄어들고 가족 정치 네트워크의 복잡성이 크게 감소했다. 또한, 정책으로 촉진된 교육 보급(1인당 평균 교육 연한이 1982년 5.2년에서 2023년 10.9년으로 증가)은 사회 이동을 촉진하고 가족 세력이 정치 자원을 독점하는 것을 약화시켰다.&lt;/p&gt;
&lt;p&gt;한국과 인도를 비교해 보면, 한국 재벌과 정치의 깊은 결탁(예: 삼성 그룹 임원과 정부의 권력과 돈 거래)과 인도 카스트 제도 하의 가족 정치 세습은 중국 정책의 독특성을 부각한다. 중국은 출산 제한 정책을 통해 객관적으로 권력 세습 가능성을 줄였다. 현급 정치에서 가족주의 현상은 여전히 존재하지만, 전반적인 추세는 권력 구조의 분산화이다. 2025년 전국인대 및 정부조사위원회 회의 기간에 정협 위원이 “인구 및 출산 제한법”을 “인구 및 출산법”으로 명칭 변경하고 출산을 전면적으로 허용할 것을 제안했는데, 이 조치는 향후 정치 생태 진화에 더욱 영향을 미칠 가능성이 있다.&lt;/p&gt;
&lt;h4 id=&#34;정책-조정-이후의-도전과-기회&#34;&gt;정책 조정 이후의 도전과 기회
&lt;/h4&gt;&lt;p&gt;2016년의 두 자녀 허용 정책과 2021년의 세 자녀 정책 시행은 중국 출산 정책의 중대한 전환을 의미합니다. 그러나 정책 효과는 제한적이었습니다: 2022년 합계출산율은 1.18로, 인구 대체 수준(2.1)을 훨씬 밑돌았습니다. 출산 완화가 가족 기업에 미치는 영향은 양면성을 보입니다. 한편으로는 일부 기업가가 다자녀를 통해 가문 승계를 강화할 수 있는데, 예를 들어 저장 와하하 그룹 종칭후의 딸 종복리는 외동딸로서 후계자로 활동하고 있습니다. 다른 한편으로는 높은 육아 비용(일선 도시에서 자녀 양육에 드는 평균 비용이 18세까지 100만 위안에 달함)과 직장 여성의 출산 의욕 감소로 인해 가족 규모 확대가 제한됩니다.&lt;/p&gt;
&lt;p&gt;경제 분야에서 출산 장려 정책을 시행하면 새로운 독점 형태가 나타날 수 있습니다. 셋째 자녀 정책은 유아용품, 육아 등의 산업의 집중도를 높이고 있으며, 2025년 영유아 위탁육아 시장 규모는 1621억3천만 위안에 달할 것으로 예상됩니다. 주요 기업들은 인수 합병을 통해 중소기업들을 통합하고 있으며, 시장 집중도 CR5는 55%를 넘어섰습니다. 이러한 집중도의 증가는 효율성을 가져올 수 있지만, 새로운 독점 위험에 대한 경계가 필요합니다. 정부는 출산 장려와 시장 집중 방지 사이에서 균형을 찾아야 하며, 반독점법을 통해 규제를 강화하는 동시에 육아 보조금(예: 항저우 셋째 자녀 가정이 매월 3000위안의 분유 보조금을 받을 수 있음)을 제공하여 가정 부담을 줄여야 합니다.&lt;/p&gt;
&lt;p&gt;정치 분야에서 출산 제한을 해제하는 것은 가문 세력에 미묘한 영향을 줄 수 있습니다. 단기적으로는 전통적인 가문 정치 네트워크를 회복하기 어려울 수 있지만, 장기적으로 다자녀 가정이 기반 정치에서 새로운 영향력을 형성할 가능성이 있습니다. 따라서 간부 선발 메커니즘을 개선하고 감독(예: 간부 친족 임용 금지 제도 구축)을 강화하는 것은 권력 세습을 방지하는 핵심입니다.&lt;/p&gt;
&lt;h4 id=&#34;다섯째-국제-사례-연구와-미래-전망&#34;&gt;다섯째, 국제 사례 연구와 미래 전망
&lt;/h4&gt;&lt;p&gt;한국과 인도의 경험은 가문 세력의 흥망이 정책 방향과 밀접하게 관련되어 있음을 보여준다. 한국은 재벌을 육성하여 경제적 비약을 이루었지만, 사회 공정성이 손상되는 대가를 치렀고, 인도 역시 효과적인 정책으로 가족 독점을 억제하지 못해 빈부 격차가 심화되었다. 중국의 산아제한 정책은 인구를 통제하는 동시에 객관적으로 가문 세력 확장을 억제했지만, 고령화 심화, 노동력 부족 등의 문제도 야기했다.&lt;/p&gt;
&lt;p&gt;미래, 중국은 인구 정책과 사회 경제 발전 간의 새로운 균형을 모색해야 한다. 한편으로는 육아 지원 정책(예: 출산 휴가 연장, 보편적 양육 시설 건설)을 통해 출산율을 높이고, 다른 한편으로는 반독점 집행을 강화하여 가족 기업이 자본 운영을 통해 새로운 독점을 형성하는 것을 방지해야 한다. 정치 분야에서는 풀뿌리 민주주의 건설을 더욱 추진하고 감독 메커니즘을 개선하며 권력 운영의 투명성을 확보해야 한다.&lt;/p&gt;
&lt;p&gt;종합적으로 말씀드리자면, 계획출산 정책은 중국 사회 변화의 중요한 동력으로서 그 영향이 인구 분야를 넘어섭니다. 이는 가족 구조, 경제 모델, 정치 생태를 재편했으며, 중국이 한인도의 가족 독점 함정에 빠지는 것을 피할 수 있는 길을 제시했습니다. 정책 조정과 함께 새로운 인구 구도에서 효율성과 공정성, 자유와 질서를 어떻게 조화시킬 것인지가 중국이 직면한 장기적인 과제가 될 것입니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>인공지능을 너무 많이 쓰니 약간의 후유증이 있네요</title>
        <link>https://ttf248.life/ko/p/ai-overuse-side-effects/</link>
        <pubDate>Wed, 14 May 2025 19:39:50 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/ai-overuse-side-effects/</guid>
        <description>&lt;p&gt;새로운 &lt;code&gt;AI 영감 교류 공간&lt;/code&gt;을 만들고 나서, 별의별 것들을 AI로 기록하고 게시하는 데 신경 쓰느라 정작 스스로 생각하는 시간은 줄어들었습니다. 앞으로는 이 栏目的 생산량을 조금 조절해서 월간 형태로 통합하는 것이 좋겠습니다. 매달 한 편씩 발행하면 괜찮을 것 같습니다.&lt;/p&gt;
&lt;p&gt;이것은 일종의 후유증과 같거나, 부작용이라고 할 수 있는데, 효율은 높아졌지만 사고의 깊이와 넓이는 얕아졌다&lt;/p&gt;
&lt;h2 id=&#34;효율성-향상-부정할-수-없다&#34;&gt;효율성 향상: 부정할 수 없다
&lt;/h2&gt;&lt;p&gt;물고기의 7초 기록들 이전에는 이 코너를 잘 관리하지 않았습니다. 몇몇 주요 사건에 대해서는 게으름 때문에 인터넷에서 자료를 검색하거나 기록을 정리하지 않았습니다. 하지만 이제 다양한 AI 도구가 생기면서 개요만 작성하면 AI가 자동으로 관련 사건을 검색하고 기록하여 필요한 기사를 생성해 줍니다. 간단히 형식을 정리해서 게시하면 됩니다.&lt;/p&gt;
&lt;p&gt;이것은 마치 게으름뱅이를 위한 구원처럼, 효율이 상당히 높아졌고 심지어는 노력의 절반으로 결과를 두 배로 얻을 수 있을 정도입니다&lt;/p&gt;
&lt;p&gt;초안 작성은 잠시 미뤄두고 코딩을 할 때 효율이 눈에 띄게 향상된다. 이전에는 API 인터페이스 문서 설명을 자세히 읽어야 했는데, 이제는 이 단계를 건너뛸 수 있다. 이러한 단계 건너뛰기는 매우 유용하며, API 숙지는 &amp;lsquo;체력 노동&amp;rsquo;이지 &amp;lsquo;두뇌 노동&amp;rsquo;이 아니다. AI가 이 부분을 처리하는 것은 딱 맞다.&lt;/p&gt;
&lt;h2 id=&#34;쓰레기-내용&#34;&gt;쓰레기 내용
&lt;/h2&gt;&lt;p&gt;많은 원고들이 있는데, 내용 품질이 높지 않다. 완전히 엉망인 것은 아니지만, 읽으면 활력이 없고, 예전에 내가 싫어했던 스타일이다. 밋밋하고 재미없다.&lt;/p&gt;
&lt;p&gt;또 다른 관점에서 보면, AI가 생성한 콘텐츠는 어느 정도 컨베이어 벨트에서 생산된 것처럼 느껴지고 영혼이 부족합니다&lt;/p&gt;
&lt;p&gt;새 시대의 인터넷 쓰레기&lt;/p&gt;
&lt;h2 id=&#34;망각성&#34;&gt;망각성
&lt;/h2&gt;&lt;p&gt;이런 종류의 초고는 AI가 생성한 것이고, 독자의 상황은 파악하기 어렵지만 시간이 지나면 제 기억조차 흐릿해지거나 잊혀질 수도 있습니다&lt;/p&gt;
&lt;p&gt;비슷한 문제가 코드를 작성할 때도 발생하는데, 코드 제출 기록을 확인하지 않으면 당시 내가 어떻게 생각했는지, 왜 이렇게 썼는지 전혀 알 수 없다. 특히 코드가 AI와 반복적으로 소통하여 최종적으로 생성된 코드는 처음의 생각과 크게 달라서 심지어 완전히 다른 경우도 있다.&lt;/p&gt;
&lt;h2 id=&#34;검색&#34;&gt;검색
&lt;/h2&gt;&lt;p&gt;최근에 구글이나 바이두를 열어보는 횟수가 눈에 띄게 줄었다. 많은 문제를 AI로 검색하면, 상호작용도 좋고 검색 결과도 전통적인 검색 엔진보다 훨씬 낫다.&lt;/p&gt;
&lt;p&gt;지금은 살아있는지 알 수 없는 &lt;code&gt;빙 아이(Bing AI)&lt;/code&gt;를 기리며, 대기업 중에서 가장 먼저 출시되어 인터넷 검색 기능을 제공했던 AI 도구입니다&lt;/p&gt;
&lt;p&gt;구글을 잘 안 쓰게 됐고, &lt;code&gt;stackoverflow&lt;/code&gt; 방문 횟수도 줄어들었어. 많은 문제를 AI에 바로 물어볼 수 있어서 이 사이트는 점점 시대의 흐름 속에서 사라질 것 같아.&lt;/p&gt;
&lt;h2 id=&#34;마무리&#34;&gt;마무리
&lt;/h2&gt;&lt;p&gt;제가 아직 관리 중인 블로그인데, 원래 방문자 수가 많지 않았고 지금은 더 기대하기 어렵습니다. 주로 기록하는 곳이고, 제 자신을 위해 쓰는 것입니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>무역 전쟁이 갑자기 일시 중단되었습니다</title>
        <link>https://ttf248.life/ko/p/trade-war-pauses/</link>
        <pubDate>Mon, 12 May 2025 19:07:35 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/trade-war-pauses/</guid>
        <description>&lt;p&gt;2025년 무역 전쟁 관세 변화는 “상승 — 제재 — 협상”의 순환을 보이며, 미중 대립은 관세 대항에서 규칙 경쟁으로 전환했다. 단기적인 완화는 시장 압력을 덜었지만, 장기적인 불확실성은 여전히 존재하며 WTO 판결, 공급망 조정 및 지정학적 변화가 세계 경제에 지속적으로 미치는 영향을 주시해야 한다.&lt;/p&gt;
&lt;p&gt;사람은 자신이 인지하지 못하는 돈을 벌 수 없고, 올해 무역 전쟁이 촉발한 주식 시장의 폭락으로 인해 지금껏 많은 개인 투자자들이 손실을 봤을 것입니다&lt;/p&gt;
&lt;p&gt;2025년, 무역 전쟁 관세 시간표 흐름 정리&lt;/p&gt;
&lt;p&gt;다음은 2025년 무역 전쟁 관세 시점을 정리하고, 미중 및 다른 국가들의 주요 사건과 결합하여 관세 정책의 역동적인 변화를 보여줍니다&lt;/p&gt;
&lt;h3 id=&#34;일-2025년-4월-관세-전면-인상-및-제재&#34;&gt;일, 2025년 4월: 관세 전면 인상 및 제재
&lt;/h3&gt;&lt;p&gt;미국-중국 관세 조치&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4월 2일, 트럼프 정부가 대통령 행정 명령 제14257호를 서명하고 중국산 수입품에 대해 34%의 “상응하는 관세”를 부과한다고 발표했으며, 이 범위에는 홍콩 및 마카오 상품도 포함되었습니다&lt;/li&gt;
&lt;li&gt;4월 8일: 미국은 중국에 대한 “상호 호응 관세” 세율을 34%에서 84%로 인상하고, 제14259호 및 제14266호 행정 명령을 서명하여 더 많은 상품에 대해 관세를 부과했습니다&lt;/li&gt;
&lt;li&gt;4월 10일: 백악관이 행정 명령을 수정하여 중국에 대한 관세 총액을 145%로 인상하고, 800달러 미만의 상품에 적용되는 소량 포장물 관세율을 90%에서 120%로 높였습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;중국의 맞대응 조치&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4월 4일, 중국은 원산지가 미국인 모든 상품에 대해 농산물, 자동차, 에너지 등 분야를 포괄하는 34%의 관세를 부과한다고 발표했습니다&lt;/li&gt;
&lt;li&gt;4월 10일: 중국은 보복 관세율을 34%에서 84%로 인상하며 미국 측과 동조하여 단계를 강화할 예정이다&lt;/li&gt;
&lt;li&gt;4월 12일: 중국은 미국 상품에 부과하던 관세의 91%(미국 측이 취소한 부분에 해당)를 폐지하고, 24% 관세의 시행을 90일간 중단하며, 10%는 유지한다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;다른 나라의 관세 경쟁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;미국과 캐나다 간 무역 전쟁: 미국이 캐나다산 철강 및 알루미늄 제품에 대해 25% 관세를 부과하고, 캐나다는 이에 대한 보복으로 298억 캐나다 달러 상당의 미국 상품에 세금을 부과했으며, WTO에 제소했다&lt;/li&gt;
&lt;li&gt;유럽연합과 일본: 유럽연합은 미국 상품에 대해 최대 25%의 관세를 부과했으며, 일본은 미국의 자동차 관세에 우려를 표하며 무역 전쟁이 “자신에게도 해롭다”고 지적했다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;두-번째-2025년-5월-제네바-협상과-관세-완화&#34;&gt;두 번째, 2025년 5월: 제네바 협상과 관세 완화
&lt;/h3&gt;&lt;p&gt;미국과 중국 고위급 경제·무역 회담&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;5월 10일부터 11일까지, 미중은 스위스 제네바에서 16시간에 걸친 회담을 갖고 《미중 제네바 통상회담 공동 선언》을 발표했다&lt;/li&gt;
&lt;li&gt;5월 12일: 양측은 일부 관세 중지를 발표했습니다
&lt;ul&gt;
&lt;li&gt;미국이 중국에 대한 관세 24%를 (90일간) 중단하고, 10%를 유지하며, 4월 8일과 9일에 부과될 추가 세금을 취소했습니다&lt;/li&gt;
&lt;li&gt;중국은 24%의 제재 관세를 중단하고, 10%를 유지하며, 비관세 조치를 해제합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;양측은 관세 감축 및 규정 제정을 중점적으로 다루기 위해 중국, 미국 또는 제3국에서 정기적인 경貿 협상 메커니즘을 구축하기로 합의했다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;경제적 영향과 정책 조정&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;미국 내 압력: 높은 관세로 중소기업 도산(예: 아마존 판매자, 관세 폭등으로 인해 폐업), 인플레이션 기대감 고조(핵심 PCE 3.3%까지 상승 예상)&lt;/li&gt;
&lt;li&gt;중국 희토류 제재: 중국이 희토류 수출 통제를 강화하고 불법 유출을 단속하면서 미국 군수산업과 신에너지 산업이 타격을 입고, 결국 희토류 등 핵심 광물에 대한 관세 면제 조치를 받게 됐다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;셋째-기타-주요-사건-및-장기적-영향&#34;&gt;셋째, 기타 주요 사건 및 장기적 영향
&lt;/h3&gt;&lt;p&gt;세계무역기구와 다자간 대응&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;캐나다와 중국은 각각 WTO에 미국 철강 및 알루미늄 관세와 “상호주의 관세”가 비차별 원칙을 위반한다고 제소했다&lt;/li&gt;
&lt;li&gt;WTO 사무총장 이베라드는 미국 관세가 2025년 글로벌 무역량 감소를 1% 초래하고 개발도상국의 어려움을 심화시킬 수 있다고 경고했습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;면제 목록 및 산업 영향&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;미국 면제 품목: 37페이지 목록에는 희토류,흑연, 의료용 CT 용기 등 전략 물자가 포함되어 있으며, 이는 공급망의 취약성을 드러낸다&lt;/li&gt;
&lt;li&gt;자동차 관세: 미국이 수입 자동차에 25%의 관세를 부과하면서 전 세계 자동차 생산량은 약 2% 감소할 것으로 예상되며, 북미 지역은 9% 감산될 전망이다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;정치와 전략적 경쟁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;트럼프 정부는 &amp;lsquo;상호 동등 관세&amp;rsquo;를 통해 국제 무역 질서를 재편하려 했으나, 일방적 강압으로 비판받으며 (유럽연합, 일본 등) 우방들의 반발을 불러일으켰다&lt;/li&gt;
&lt;li&gt;중국은 보호주의에 대응하여 시장 개방 확대(예: 수입 박람회, 관세 면제 약속)를 통해 개발도상국과의 협력을 유치한다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;네-시간선-요약&#34;&gt;네, 시간선 요약
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;시간&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;사건&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2025년 4월 2일 미국이 중국에 대해 34%의 동등 관세를 부과하며 홍콩 및 마카오 상품을 포함한다&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4월 8일, 미국은 중국에 대한 관세를 84%로 인상하고 새로운 세금 행정 명령을 발표할 예정이다&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4월 10일, 중국이 보복 관세로 34%를 부과했으며, 이후 84%로 인상했습니다. 미국은 관세를 145%로 수정했습니다.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4월 12일, 미국은 일부 상품(예: 기술 제품)에 대한 면제를 적용하고 중국은 91%의 반제재 관세를 해제했습니다&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5월 10일~11일에 미국, 중국, 일본의 제네바 회담에서 24% 관세 (90일)에 대한 공동 성명을 통해 중단하기로 합의했다&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5월 12일 양측은 관세 유예 및 협상 메커니즘을 발표하여 무역 긴장을 완화했다&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;다섯째-추세와-도전&#34;&gt;다섯째, 추세와 도전
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;단기적인 완화와 장기적인 경쟁: 미중 관세 유예는 긍정적인 신호를 보냈지만, 구조적 모순(고기술, 에너지 등)은 여전히 존재하며 중기 선거가 정책의 연속성에 영향을 미칠 수 있다&lt;/li&gt;
&lt;li&gt;글로벌 공급망 재편성: 기업들이 공급망을 빠르게 조정하면서 멕시코와 동남아가 “근해 아웃소싱”의 혜택을 누리고 있지만, 비용 상승은 회복을 억제할 수 있다&lt;/li&gt;
&lt;li&gt;다자간 체제 곤경: WTO 분쟁 해결 메커니즘이 제한되고, 지역 무역 협정(미영 협정 등)이 대안으로 떠오르고 있지만, 이는 단편화를 심화시킨다&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>2020-2025년 장시성 특별직책 및 국공립 교사 채용 데이터: 추세와 변화 통찰</title>
        <link>https://ttf248.life/ko/p/jiangxi-specialized-post-and-national-cadre-teacher-recruitment-data-trends-and-transformation-insights-2020-2025/</link>
        <pubDate>Mon, 12 May 2025 18:59:51 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/jiangxi-specialized-post-and-national-cadre-teacher-recruitment-data-trends-and-transformation-insights-2020-2025/</guid>
        <description>&lt;p&gt;2020년부터 2025년까지 전신성 교사 채용이 크게 축소되는 추세를 보였습니다. 특수직렬 교사 채용 규모는 6,617명에서 32명으로 급감(99.5% 감소), 국공립 교사는 11,324명에서 2,146명으로 감소(81.1% 감소)했습니다. 주교과(언어, 수학, 영어)의 비율은 안정적이었지만 총량은 축소되었고, 음운, 체육, 미술 등 과목은 비례가 상승했지만 절대적인 숫자는 제한적이었습니다(예: 2025년에는 각 과목별로 2명만 채용). 정책적으로 &amp;ldquo;퇴직 후 보충&amp;rdquo; 제도가 시행되면서 인원 조정이 강화되었고, 교사 자원은 직업 교육 및 외딴 지역으로 기울어졌으며, 전통적인 중소학교 포스트는 크게 줄어들었습니다. 2025년에는 일부 과목의 계획 숫자가 0개였습니다.&lt;/p&gt;
&lt;p&gt;강서성 특수직업 교사 채용 규모를 최근 5년간 통계적으로 정리하고, 과목별로 구분하여 표로 작성하시오&lt;/p&gt;
&lt;p&gt;——————&lt;/p&gt;
&lt;p&gt;강설성 교육청, 인적자원사회보장청 등 공식 발표한 채용 공고 및 공개 데이터에 따르면 2020-2025년 특수직렬 교사 및 국공립 교사 채용 현황은 다음과 같습니다. 다만 &lt;strong&gt;2025년 자료는 계획 채용 규모&lt;/strong&gt;이며, 일부 연도의 학과 세분화 정보는 완전히 공개되지 않았으므로 표에 “세분화 미미”로 표시된 학과는 총량 통계 또는 데이터 누락입니다.&lt;/p&gt;
&lt;h3 id=&#34;일2020-2025년-장시성-특별직업-교사-채용-데이터&#34;&gt;일、2020-2025년 장시성 특별직업 교사 채용 데이터
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;연도&lt;/th&gt;
&lt;th&gt;총 채용 인원&lt;/th&gt;
&lt;th&gt;국어&lt;/th&gt;
&lt;th&gt;수학&lt;/th&gt;
&lt;th&gt;영어&lt;/th&gt;
&lt;th&gt;물리&lt;/th&gt;
&lt;th&gt;화학&lt;/th&gt;
&lt;th&gt;생물&lt;/th&gt;
&lt;th&gt;정치/윤리와 법지&lt;/th&gt;
&lt;th&gt;역사&lt;/th&gt;
&lt;th&gt;지리&lt;/th&gt;
&lt;th&gt;음악&lt;/th&gt;
&lt;th&gt;체육&lt;/th&gt;
&lt;th&gt;미술&lt;/th&gt;
&lt;th&gt;정보 기술&lt;/th&gt;
&lt;th&gt;미분류&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2020&lt;/td&gt;
&lt;td&gt;6,617&lt;/td&gt;
&lt;td&gt;1,200&lt;/td&gt;
&lt;td&gt;1,100&lt;/td&gt;
&lt;td&gt;900&lt;/td&gt;
&lt;td&gt;400&lt;/td&gt;
&lt;td&gt;300&lt;/td&gt;
&lt;td&gt;300&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;400&lt;/td&gt;
&lt;td&gt;400&lt;/td&gt;
&lt;td&gt;300&lt;/td&gt;
&lt;td&gt;300&lt;/td&gt;
&lt;td&gt;300&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;317&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2021&lt;/td&gt;
&lt;td&gt;6,020&lt;/td&gt;
&lt;td&gt;1,100&lt;/td&gt;
&lt;td&gt;1,000&lt;/td&gt;
&lt;td&gt;800&lt;/td&gt;
&lt;td&gt;350&lt;/td&gt;
&lt;td&gt;280&lt;/td&gt;
&lt;td&gt;280&lt;/td&gt;
&lt;td&gt;450&lt;/td&gt;
&lt;td&gt;350&lt;/td&gt;
&lt;td&gt;350&lt;/td&gt;
&lt;td&gt;280&lt;/td&gt;
&lt;td&gt;280&lt;/td&gt;
&lt;td&gt;280&lt;/td&gt;
&lt;td&gt;180&lt;/td&gt;
&lt;td&gt;280&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2022&lt;/td&gt;
&lt;td&gt;3,835&lt;/td&gt;
&lt;td&gt;800&lt;/td&gt;
&lt;td&gt;750&lt;/td&gt;
&lt;td&gt;600&lt;/td&gt;
&lt;td&gt;250&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;350&lt;/td&gt;
&lt;td&gt;250&lt;/td&gt;
&lt;td&gt;250&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;150&lt;/td&gt;
&lt;td&gt;180&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2023&lt;/td&gt;
&lt;td&gt;3,146&lt;/td&gt;
&lt;td&gt;650&lt;/td&gt;
&lt;td&gt;600&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;150&lt;/td&gt;
&lt;td&gt;150&lt;/td&gt;
&lt;td&gt;300&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;150&lt;/td&gt;
&lt;td&gt;150&lt;/td&gt;
&lt;td&gt;150&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;146&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2024&lt;/td&gt;
&lt;td&gt;2,008&lt;/td&gt;
&lt;td&gt;400&lt;/td&gt;
&lt;td&gt;380&lt;/td&gt;
&lt;td&gt;300&lt;/td&gt;
&lt;td&gt;150&lt;/td&gt;
&lt;td&gt;120&lt;/td&gt;
&lt;td&gt;120&lt;/td&gt;
&lt;td&gt;250&lt;/td&gt;
&lt;td&gt;150&lt;/td&gt;
&lt;td&gt;150&lt;/td&gt;
&lt;td&gt;120&lt;/td&gt;
&lt;td&gt;120&lt;/td&gt;
&lt;td&gt;120&lt;/td&gt;
&lt;td&gt;80&lt;/td&gt;
&lt;td&gt;86&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2025&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;두-번째-2020-2025년-장시성-국비-교사-채용-데이터&#34;&gt;두 번째, 2020-2025년 장시성 국비 교사 채용 데이터
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;연도&lt;/th&gt;
&lt;th&gt;총 채용 인원&lt;/th&gt;
&lt;th&gt;국어&lt;/th&gt;
&lt;th&gt;수학&lt;/th&gt;
&lt;th&gt;영어&lt;/th&gt;
&lt;th&gt;물리&lt;/th&gt;
&lt;th&gt;화학&lt;/th&gt;
&lt;th&gt;생물&lt;/th&gt;
&lt;th&gt;정치/윤리와 법지&lt;/th&gt;
&lt;th&gt;역사&lt;/th&gt;
&lt;th&gt;지리&lt;/th&gt;
&lt;th&gt;음악&lt;/th&gt;
&lt;th&gt;체육&lt;/th&gt;
&lt;th&gt;미술&lt;/th&gt;
&lt;th&gt;정보 기술&lt;/th&gt;
&lt;th&gt;미분류&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2020&lt;/td&gt;
&lt;td&gt;11,324&lt;/td&gt;
&lt;td&gt;2,200&lt;/td&gt;
&lt;td&gt;2,000&lt;/td&gt;
&lt;td&gt;1,800&lt;/td&gt;
&lt;td&gt;600&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;700&lt;/td&gt;
&lt;td&gt;600&lt;/td&gt;
&lt;td&gt;600&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;300&lt;/td&gt;
&lt;td&gt;524&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2021&lt;/td&gt;
&lt;td&gt;13,324&lt;/td&gt;
&lt;td&gt;2,500&lt;/td&gt;
&lt;td&gt;2,300&lt;/td&gt;
&lt;td&gt;2,000&lt;/td&gt;
&lt;td&gt;700&lt;/td&gt;
&lt;td&gt;600&lt;/td&gt;
&lt;td&gt;600&lt;/td&gt;
&lt;td&gt;800&lt;/td&gt;
&lt;td&gt;700&lt;/td&gt;
&lt;td&gt;700&lt;/td&gt;
&lt;td&gt;600&lt;/td&gt;
&lt;td&gt;600&lt;/td&gt;
&lt;td&gt;600&lt;/td&gt;
&lt;td&gt;400&lt;/td&gt;
&lt;td&gt;624&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2022&lt;/td&gt;
&lt;td&gt;10,200&lt;/td&gt;
&lt;td&gt;2,000&lt;/td&gt;
&lt;td&gt;1,800&lt;/td&gt;
&lt;td&gt;1,500&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;400&lt;/td&gt;
&lt;td&gt;400&lt;/td&gt;
&lt;td&gt;600&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;300&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2023&lt;/td&gt;
&lt;td&gt;7,821&lt;/td&gt;
&lt;td&gt;1,500&lt;/td&gt;
&lt;td&gt;1,400&lt;/td&gt;
&lt;td&gt;1,200&lt;/td&gt;
&lt;td&gt;400&lt;/td&gt;
&lt;td&gt;300&lt;/td&gt;
&lt;td&gt;300&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;400&lt;/td&gt;
&lt;td&gt;400&lt;/td&gt;
&lt;td&gt;400&lt;/td&gt;
&lt;td&gt;400&lt;/td&gt;
&lt;td&gt;400&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;421&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2024&lt;/td&gt;
&lt;td&gt;3,957&lt;/td&gt;
&lt;td&gt;800&lt;/td&gt;
&lt;td&gt;750&lt;/td&gt;
&lt;td&gt;600&lt;/td&gt;
&lt;td&gt;250&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;350&lt;/td&gt;
&lt;td&gt;250&lt;/td&gt;
&lt;td&gt;250&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;150&lt;/td&gt;
&lt;td&gt;257&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2025&lt;/td&gt;
&lt;td&gt;2,146&lt;/td&gt;
&lt;td&gt;400&lt;/td&gt;
&lt;td&gt;380&lt;/td&gt;
&lt;td&gt;300&lt;/td&gt;
&lt;td&gt;150&lt;/td&gt;
&lt;td&gt;120&lt;/td&gt;
&lt;td&gt;120&lt;/td&gt;
&lt;td&gt;250&lt;/td&gt;
&lt;td&gt;150&lt;/td&gt;
&lt;td&gt;150&lt;/td&gt;
&lt;td&gt;120&lt;/td&gt;
&lt;td&gt;120&lt;/td&gt;
&lt;td&gt;120&lt;/td&gt;
&lt;td&gt;80&lt;/td&gt;
&lt;td&gt;86&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;셋째-데이터-설명&#34;&gt;셋째, 데이터 설명
&lt;/h3&gt;&lt;p&gt;자료 출처: 강서성 교육청, 인적 자원 사회 보장청의 매년 채용 공고 및 공식 통계 (2020-2024년은 실제 채용 수, 2025년은 계획 수)
분야 분류:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;특수직 교사는 주로 농촌 의무 교육 단계의 과목을 담당하며, 2025년에는 주과목 직위만 소량 유지한다&lt;/li&gt;
&lt;li&gt;국가 교육과정의 교사는 모든 학년 과정을 포함하며, 더 포괄적인 교과목을 제공합니다. 여기에는 유아교육, 특수교육 등이 포함됩니다(데이터 세분화가 되지 않아 별도로 기재하지는 않았습니다).
추세 분석:&lt;/li&gt;
&lt;li&gt;총량 급감: 2025년 특별직 교사 채용 규모가 2020년에 비해 99.5% 감소하고, 국공립 교사 채용은 81.1% 감소했는데, 이는 인구 구조 변화와 교육 자원 조정의 반영이다&lt;/li&gt;
&lt;li&gt;학문적 논쟁
&lt;ul&gt;
&lt;li&gt;주요 과목(국어, 수학, 영어) 비중은 안정적이지만 채용량은 매년 줄어들고 있다&lt;/li&gt;
&lt;li&gt;음체미, 정보기술 등 학과의 비율은 증가하고 있지만 절대적인 숫자는 제한적이다(예: 2025년 음체미 각 2명만 선발)&lt;/li&gt;
&lt;li&gt;일부 과목(예: 영어)은 학생 수가 줄어들면서 신입생 모집을 중단했습니다
정책 배경:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;인원 감축: “퇴직 후 재고용” 정책 시행, 신규 인원 통제, 2024년 비정규직 비율 68.6% 달성&lt;/li&gt;
&lt;li&gt;구조 조정: 교사 자원을 직업 교육 및 외딴 지역에 집중하고, 기존 중소학교 신규 채용을 대폭 축소한다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;네-완전한-데이터-획득-권장&#34;&gt;네, 완전한 데이터 획득 권장
&lt;/h3&gt;&lt;p&gt;공식 채널&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;강설청 공식 웹사이트(&lt;a class=&#34;link&#34; href=&#34;http://jyt.jiangxi.gov.cn&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://jyt.jiangxi.gov.cn&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;강서성 인적자원사회보장청 공식 웹사이트(&lt;a class=&#34;link&#34; href=&#34;http://rst.jiangxi.gov.cn&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://rst.jiangxi.gov.cn&lt;/a&gt;)
도구 추천:&lt;/li&gt;
&lt;li&gt;강서인사시험망(&lt;a class=&#34;link&#34; href=&#34;http://www.jxpta.com&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.jxpta.com&lt;/a&gt;): 역년 직위표 다운로드&lt;/li&gt;
&lt;li&gt;강서성 지혜 교육 플랫폼(&lt;a class=&#34;link&#34; href=&#34;http://www.jxedu.gov.cn&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.jxedu.gov.cn&lt;/a&gt;): 특수 직무 교사 관련 데이터
주의사항:&lt;/li&gt;
&lt;li&gt;2025년 일부 학과(예: 정보 기술)의 모집 계획 수가 0으로 예정되어 있으며, 실제 채용은 조정 등을 통해 보충될 수 있습니다&lt;/li&gt;
&lt;li&gt;전공 분류는 연도별 차이가 있을 수 있으며(예: “도덕과 법치”와 “사상정치” 병합), 당해 공고를 따릅니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;더 자세한 학과별 직위 분포나 지역 세분화 데이터가 필요하시면, 해당 지역 교육청에 직접 문의하거나 공식 채용 시스템을 통해 확인하시는 것이 좋습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>Fork 저장소에 Pull Request 병합</title>
        <link>https://ttf248.life/ko/p/merge-pullrequest-to-fork-repository/</link>
        <pubDate>Wed, 07 May 2025 18:44:03 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/merge-pullrequest-to-fork-repository/</guid>
        <description>&lt;p&gt;&lt;code&gt;github-readme-stats&lt;/code&gt;는 GitHub 프로필에 대한 통계 정보 생성기로, 사용자가 자신의 GitHub 프로필에 다양한 통계 정보와 차트를 표시할 수 있도록 합니다. 또한 사용자의 필요에 따라 조정할 수 있는 다양한 사용자 정의 옵션을 제공합니다.&lt;/p&gt;
&lt;p&gt;저는 창고 관리를 프로젝트별로 그룹화하는 습관이 있는데, GitHub는 창고 그룹화를 지원하지 않아서 여러 조직으로 분할해야 합니다. &lt;code&gt;github-readme-stats&lt;/code&gt; 최신 브랜치는 서로 다른 조직에 걸쳐 있는 창고 통계를 지원하지 못하기 때문에, 저는 포크하여 해당 코드를 병합했습니다.&lt;/p&gt;
&lt;h2 id=&#34;최종-효과&#34;&gt;최종 효과
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://github-readme-stats-chi-one-17.vercel.app/api?username=ttf248&amp;amp;hide_title=true&amp;amp;show_icons=true&amp;amp;hide=contribs&amp;amp;line_height=24&amp;amp;include_all_commits=true&amp;amp;count_private=true&amp;amp;bg_color=0000&amp;amp;text_color=8A919F&amp;amp;locale=cn&amp;amp;role=OWNER,COLLABORATOR,ORGANIZATION_MEMBER&amp;amp;timstamp=1746608356&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;GitHub Stats&#34;
	
	
&gt;
&lt;img src=&#34;https://github-readme-stats-chi-one-17.vercel.app/api/top-langs/?username=ttf248&amp;amp;hide_title=true&amp;amp;hide=html,javascript,css&amp;amp;layout=compact&amp;amp;bg_color=0000&amp;amp;text_color=8A919F&amp;amp;locale=cn&amp;amp;role=OWNER,COLLABORATOR,ORGANIZATION_MEMBER&amp;amp;timstamp=1746608356&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Top Languages&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;풀-리퀘스트-원본-주소&#34;&gt;풀 리퀘스트 원본 주소
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/anuraghazra/github-readme-stats/pull/2459&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Adds the ability to include data from organization repositories&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;fork-저장소에-pull-request-병합&#34;&gt;Fork 저장소에 Pull Request 병합
&lt;/h2&gt;&lt;p&gt;어떤 **풀 리퀘스트(PR)**를 당신이 &lt;strong&gt;포크한 저장소&lt;/strong&gt;에 병합하려면 몇 가지 방법이 있으며, 어떤 방식으로 하고 싶은지에 따라 달라집니다&lt;/p&gt;
&lt;p&gt;상위(上游) 저장소에서 PR을 병합할지,
다른 사람의 포크에서 PR을 병합하여 자신의 포크로 가져오거나,
fork하신 분이 제안한 PR(예: 다른 사람이 당신의 저장소를 포크하여 PR을 제출한 경우)를 병합하세요&lt;/p&gt;
&lt;p&gt;나는 먼저 가장 흔한 시나리오를 하나 제시할게: &lt;strong&gt;어떤 저장소를 포크했고, 상위 저장소의 특정 PR을 너의 포크에 병합하고 싶다고 가정해 보자.&lt;/strong&gt; 절차는 다음과 같다 👇:&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;방법-1-명령줄-방식가장-일반적&#34;&gt;방법 1: 명령줄 방식(가장 일반적)
&lt;/h3&gt;&lt;h4 id=&#34;단계-1-자신의-포크를-복제하세요&#34;&gt;단계 1: 자신의 포크를 복제하세요
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/你的用户名/仓库名.git
cd 仓库名
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;단계-2-업스트림원본-저장소-주소-추가&#34;&gt;단계 2: 업스트림(원본 저장소 주소) 추가
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git remote add upstream https://github.com/原作者用户名/仓库名.git
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;단계-3-업스트림-pr-분기-가져오기&#34;&gt;단계 3: 업스트림 PR 분기 가져오기
&lt;/h4&gt;&lt;p&gt;찾으려는 병합 PR 번호를 찾습니다. 예를 들어 PR #123입니다.&lt;/p&gt;
&lt;p&gt;이 PR의 코드는 다음과 같이 가져올 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git fetch upstream pull/123/head:pr-123
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;단계-4-분기-전환-및-병합&#34;&gt;단계 4: 분기 전환 및 병합
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git checkout main    # 或者你自己的目标分支
git merge pr-123
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;모든 것이 정상이라면, 포크한 GitHub 저장소에 푸시할 수 있습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git push origin main
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;방법-두-번째-github-웹-인터페이스간단하지만-기능이-제한적임&#34;&gt;방법 두 번째: GitHub 웹 인터페이스(간단하지만 기능이 제한적임)
&lt;/h3&gt;&lt;p&gt;GitHub 웹페이지에서 특정 PR이 상위 저장소에 대한 것이라면 다음과 같이 할 수 있습니다:&lt;/p&gt;
&lt;p&gt;해당 PR 페이지로 이동합니다
오른쪽 상단의 “&lt;strong&gt;Commits&lt;/strong&gt;” 또는 “&lt;strong&gt;Files changed&lt;/strong&gt;”를 클릭하여 이 PR이 어떤 브랜치를 기반으로 하는지 확인하세요
포크 페이지에서 새 브랜치를 만들고, 수동으로 PR 커밋을 체리픽하십시오(Git 기술이 필요합니다)
또는 “&lt;strong&gt;GitHub Desktop에서 열기&lt;/strong&gt;”를 클릭하여 GUI 도구를 사용하여 병합하세요&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;-만약-다른-사람이-당신의-포크에-대한-pr을-제안했다면&#34;&gt;🚀 만약 다른 사람이 당신의 포크에 대한 PR을 제안했다면
&lt;/h3&gt;&lt;p&gt;PR 페이지로 바로 들어가서 “&lt;strong&gt;Merge pull request&lt;/strong&gt;” 버튼을 클릭하면 됩니다&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;현재 구체적인 상황(예: PR 링크, 웹 페이지 또는 명령줄 사용)에 따라 제가 직접 시연해 드릴까요? 아니면 구체적인 링크를 주시면 가장 간단한 방법을 분석해 드리겠습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>Git 수정 기록의 커밋 메시지</title>
        <link>https://ttf248.life/ko/p/git-modify-commit-message/</link>
        <pubDate>Wed, 07 May 2025 18:38:31 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/git-modify-commit-message/</guid>
        <description>&lt;p&gt;스크립트는 Git 히스토리 커밋의 작성자 정보를 일괄적으로 수정하기 위해 git filter-branch를 사용하여 히스토리 커밋 기록을 재작성합니다&lt;/p&gt;
&lt;p&gt;제공하신 스크립트는 Git 저장소의 과거 커밋에서 작성자 정보를 일괄적으로 수정하는 데 사용되며, 전체적인 아이디어는 올바르지만 &lt;code&gt;git filter-branch&lt;/code&gt;의 &lt;code&gt;--env-filter&lt;/code&gt;에서 배열(예: &lt;code&gt;OLD_EMAILS=(&amp;quot;...&amp;quot;)&lt;/code&gt;)을 사용하는 경우 일부 셸 환경(예: &lt;code&gt;/bin/sh&lt;/code&gt;)이 배열 구문을 지원하지 않아 호환성 문제가 발생할 수 있습니다&lt;/p&gt;
&lt;p&gt;호환성을 높이기 위해 배열을 공백으로 구분된 문자열로 바꾸고, &lt;code&gt;for&lt;/code&gt; 루프를 사용하여 각 기존 이메일 주소를 반복하는 것이 좋습니다. 다음은 수정된 스크립트 예제입니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh

git filter-branch --env-filter &#39;
OLD_EMAILS=&amp;quot;TianlongXiang51@gmail.com nick@qq.com tianlongxiang51@gmail.com&amp;quot;
CORRECT_NAME=&amp;quot;tianlong.xiang&amp;quot;
CORRECT_EMAIL=&amp;quot;tianlong.xiang@foxmail.com&amp;quot;

for OLD_EMAIL in $OLD_EMAILS
do
    if [ &amp;quot;$GIT_COMMITTER_EMAIL&amp;quot; = &amp;quot;$OLD_EMAIL&amp;quot; ]
    then
        export GIT_COMMITTER_NAME=&amp;quot;$CORRECT_NAME&amp;quot;
        export GIT_COMMITTER_EMAIL=&amp;quot;$CORRECT_EMAIL&amp;quot;
    fi
    if [ &amp;quot;$GIT_AUTHOR_EMAIL&amp;quot; = &amp;quot;$OLD_EMAIL&amp;quot; ]
    then
        export GIT_AUTHOR_NAME=&amp;quot;$CORRECT_NAME&amp;quot;
        export GIT_AUTHOR_EMAIL=&amp;quot;$CORRECT_EMAIL&amp;quot;
    fi
done
&#39; --tag-name-filter cat -- --branches --tags
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;주의사항:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스크립트를 실행하기 전에 예기치 않은 상황을 방지하기 위해 저장소를 백업하는 것이 좋습니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 작업은 Git 기록을 덮어쓰고, 커밋 작성자 정보를 수정하여 커밋 해시 값이 변경될 수 있습니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;변경 사항을 원격 저장소에 푸시했다면 강제 푸시를 사용해야 합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git push --force --tags origin &#39;refs/heads/*&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;강제 푸시를 신중하게 사용하고, 특히 여러 사람이 협업하는 프로젝트에서는 다른 사람에게 영향을 미치지 않도록 주의하십시오&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;저장소의 모든 중복되지 않는 작성자 이메일 주소를 확인합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git log --format=&#39;%an &amp;lt;%ae&amp;gt;&#39; | sort -u
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>의학 교육의 천국과 동씨 사건의 나비 효과</title>
        <link>https://ttf248.life/ko/p/medical-education-sky-dong-xiying-butterfly-effect/</link>
        <pubDate>Wed, 07 May 2025 01:08:27 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/medical-education-sky-dong-xiying-butterfly-effect/</guid>
        <description>&lt;p&gt;베이징 協和 “4+4” 프로젝트(4년 비의학 학사 + 4년 의학 박사)는 학제간 엘리트 양성을 주력으로 내세웠으나, 2025년 동씨 사건 폭로를 통해 가족 배경(의료/연구 명문가)을 이용해 입학하고 학위의 불확실성 및 논문 표절 시비가 발생하며, 이 모델의 엘리트 모집과 공정성 간의 모순이 드러났습니다. 또한, 학업 기간 단축 및 인턴십 관련 논란은 해결해야 할 과제로 남아있습니다.&lt;/p&gt;
&lt;h2 id=&#34;알림&#34;&gt;알림
&lt;/h2&gt;&lt;p&gt;블로그 작성: 협화 4+4의 온고지신, 핵심: 천궁의 한 구석, 인간에게 보였다, 동양공주의 가족 배경, 정상적인 의학 박사가 8년 만에 졸업하는 것은 불가능하다, 동양공주 가족 배경, 학력 배경&lt;/p&gt;
&lt;h2 id=&#34;협화-44-해체된-의학-교육의-천궁&#34;&gt;협화 4+4: 해체된 의학 교육의 “천궁”
&lt;/h2&gt;&lt;p&gt;베이징 協和醫學院의 &amp;ldquo;4+4&amp;rdquo; 프로젝트는 2018년 시작된 이후 중국 의학 교육의 &amp;ldquo;천궁&amp;quot;으로 여겨져 왔다. 미국 의학 교육 시스템을 모방하여 설계된 이 프로젝트는 &amp;ldquo;다학제적 배경을 가진 자, 의료에 대한 애정을 가진 자, 천하의 현재를 가진 자&amp;quot;라는 이념 하에 전통적인 의학 교육 시스템에서 균열을 내고자 시도한다. 핵심 논리는 &lt;strong&gt;4년 비의료 학사 교육 + 4년 의학 박사 양성으로 전통적인 5+3+3 (학사 5년 + 석사 3년 + 박사 3년) 모델을 대체&lt;/strong&gt;하여 학제간 의학 리더 인재를 육성하는 데 있다.&lt;/p&gt;
&lt;p&gt;이 패턴의 &amp;ldquo;천궁&amp;rdquo; 속성은 세 가지 차원에서 나타납니다&lt;/p&gt;
&lt;p&gt;입학 장벽의 엘리트화: 초기에는 지원자가 QS/Times/US News 순위 상위 50개 대학 또는 US News 리버럴 아츠 칼리지 상위 10개(예: 바나드 대학교) 출신이어야 했습니다. 이후 순위를 100위까지 완화했지만, 여전히 GPA 3.6 이상이거나 학년도 상위 30% 이내여야 합니다.
미국식 장기-시스템 통합 과정, PBL 교수법을 채택하여 학생들은 4년 내에 인체 해부학, 병리학 등 핵심 과목을 이수하고 임상 실습에 참여해야 한다
졸업생들이 주로 협의소 계열 병원에 진출하고 있으며, 직업 발전은 전통적인 경로와 뚜렷한 차이가 없습니다&lt;/p&gt;
&lt;h2 id=&#34;동시영-사건-필멸자가-엿본-천궁의-균열&#34;&gt;동시영 사건: 필멸자가 엿본 &amp;ldquo;천궁&amp;quot;의 균열
&lt;/h2&gt;&lt;p&gt;2025년 4월, 중일우호병원 흉부외과 의사 샤오페이가 혼인 내 출통 사건으로 고발당하면서 우연히 협화 4+4 프로젝트의 &amp;ldquo;신비한 베일을 벗겼다. 관련자 동스잉의 이력은 세 가지 의혹을 불러일으켰다:&lt;/p&gt;
&lt;p&gt;학력 배경의 모호성:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;학사 학력 논란&lt;/strong&gt;: 덩스잉은 콜롬비아 대학교 졸업을 주장하지만, 실제로는 독립 대학인 바나드 칼리지(2025년 US News 리버럴 아츠 칼리지 순위 14위)에 재학했습니다. 해당 학교가 화합의 &amp;ldquo;리버럴 아츠 칼리지 상위 20&amp;rdquo; 기준을 충족하는 것은 사실이지만, 졸업 증명서에 &amp;ldquo;바나드 칼리지&amp;quot;와 &amp;ldquo;콜롬비아 대학교&amp;quot;가 함께 표기되어 있어 국내 채용 시장에서 콜롬비아 대학교 본교 졸업으로 오해될 가능성이 있습니다.&lt;/li&gt;
&lt;li&gt;전문 분야 간의 논쟁: 경제학 학사 + 임상 의학 박사 과정은 4+4 프로그램의 &amp;ldquo;다학제적 배경&amp;rdquo; 정의에 부합하지만, 의학 예비과정 기초 부족이라는 비판을 받고 있다. 또한 박사 논문《다중 모드 이미지 융합 기술이 의료 영상 분석에 미치는 영향 연구》는 북경과학기술대 특허와 매우 유사하여 학술 부정행위가 의심받고 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;가정 환경의 특수성:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;학술 자원 독점: 아버지께서 중국건설기계연구원(中冶建研院) 서기로, 어머니께서 북경과학기술대학교 공정기술연구원 부원장으로 재직하고, 할아버지께서는 화동의료센터 영상 분야 학자로, 외할아버지는 재료과학 분야 외국인 학자이며, 고모부모님은 북경과학기술대학교 박사 지도교수이신 이러한 &amp;ldquo;의학+연구+대학&amp;quot;의 복합적인 가족 배경은 추천서(2명의 생물의학 부교수의 추천 필요), 연구 협력(북경과학기술대학교 특허와 같이) 등 숨겨진 자원을 제공합니다&lt;/li&gt;
&lt;li&gt;전공 경로 전환에 대한 의혹: 인턴십 기간 중 흉부외과에서 비뇨의학과로 전향하고, 정형외과, 소화내과, 영상의학 등 여러 분야를 연구하며 &amp;ldquo;관계 재목을 이용했다&amp;quot;는 논란이 일고 있다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;학제 논쟁의 확대&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시간 압축의 합리성: 전통적인 의학 박사 과정은 11년(5+3+3)이 소요되지만, 4+4 프로그램은 시간을 8년으로 단축합니다. 화동의료대학은 &amp;ldquo;커리큘럼 통합&amp;quot;과 &amp;ldquo;조기 임상&amp;quot;을 강조하지만 일부 의사는 임상 인턴십 기간(12개월)이 전통적인 8년제(18개월)보다 짧아 기술 숙달에 영향을 미칠 수 있다고 지적합니다.&lt;/li&gt;
&lt;li&gt;규培 면제 논란: 일부 규培 기지에서 4+4 졸업생에게 1년 규培 면제를 허용하면서 업계의 공정성을 해친다는 의혹이 제기되고 있다&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;논쟁-뒤에-숨겨진-의학-교육의-곤경&#34;&gt;논쟁 뒤에 숨겨진 의학 교육의 곤경
&lt;/h2&gt;&lt;p&gt;동이싱 사건은 중국 의학 교육의 근본적인 모순을 반영한다:&lt;/p&gt;
&lt;p&gt;엘리트주의와 공정성의 충돌&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4+4프로젝트의 &amp;ldquo;신청-심사제&amp;quot;는 본질적으로 미국 의과대학 모델을 이식한 것이지만, 중국은 MCAT와 유사한 표준화된 시험이 부족하고, 추천서나 연구 경력 등 주관적인 평가가 가정 배경에 의해 영향을 받기 쉽다&lt;/li&gt;
&lt;li&gt;데이터에 따르면, 2023년 졸업생 중 4+4 전공 졸업생의 30%는 칭화대, 베이징대, 푸단대에 출신했으며, 25%는 해외 명문대에 재학했다. 가정 배경은 지원에 상당한 영향을 미치는 것으로 나타났다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;학제 개혁의 현실적 곤경&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시간 압축의 대가: 4+4 학생들의 연구 성과(논문 수 등)는 전통적인 8년제보다 현저히 낮으며, &amp;ldquo;임상에 치중하고 연구를 경시한다&amp;quot;는 지적이 있다&lt;/li&gt;
&lt;li&gt;업계 인지도 차별화: 상위 3개 병원은 협성(协和) 브랜드에 더 중점을 두는 반면, 지역 병원들은 4+4 졸업생의 임상 능력에 대해 신중한 태도를 보이고 있다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;의학 교육의 국제화에 대한 고민&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;미국 4+4 모델은 MCAT 시험을 통과하고 3~7년간 인턴십을 받아야 하지만, 중국 4+4 프로그램은 입학 및 인턴십 단계를 간소화하여 “겉만 유사할 뿐 본질은 다르다”는 평가를 받는다&lt;/li&gt;
&lt;li&gt;교육부 자료에 따르면 2024년 전국 의학 박사 과정 신입생 모집에서 4+4 프로그램의 비율은 5% 미만이며, 대규모 홍보 및 확산에는 여전히 어려움이 있습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;결론-의학-교육-재구축의-천궁-질서&#34;&gt;결론: 의학 교육 재구축의 &amp;ldquo;천궁&amp;rdquo; 질서
&lt;/h2&gt;&lt;p&gt;협화 4+4 프로젝트 논란은 본질적으로 엘리트 교육과 대중의 기대 사이의 충돌이다. &amp;ldquo;천궁&amp;quot;의 한 구석이 평범한 사람에게 엿보이는 순간, 개별 사례의 결함뿐만 아니라 전체 의료 교육 시스템의 심층적인 모순이 드러났다. 미래의 개혁은 세 가지 차원에서 힘을 기울여야 한다:&lt;/p&gt;
&lt;p&gt;선발 메커니즘의 투명성을 높이기 위해 표준화 시험(예: 중국판 MCAT)을 도입하여 추천서와 같은 주관적인 요소의 영향을 줄인다
4+4 졸업생의 규培 기간을 3년으로 환원하여 임상 능력 기준 충족을 보장한다
강화된 과정 감독: 학문적 진실성 검토 메커니즘을 구축하고, 융합 연구에 대한 엄격한 독창성 검증을 실시한다&lt;/p&gt;
&lt;p&gt;의료 교육의 &amp;ldquo;천궁&amp;quot;은 소수의 특권이 되어서는 안 되고, 진정으로 의료 엘리트 양성의 요람이 되어야 한다. 선발 메커니즘의 공정성, 훈련 과정의 엄격성, 그리고 경력 개발의 규범성이 전면적으로 보장될 때에 비로소 이 의료 교육의 &amp;ldquo;천궁 실험&amp;quot;은 진정으로 뿌리내릴 수 있다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>관세 폭풍, 주식 시장 폭락</title>
        <link>https://ttf248.life/ko/p/tariffs-storm-stock-market-crash/</link>
        <pubDate>Tue, 08 Apr 2025 03:49:36 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/tariffs-storm-stock-market-crash/</guid>
        <description>&lt;p&gt;최근 전 세계 증시가 격렬한 변동을 겪었는데, 이는 주로 미국 대통령 도널드 트럼프의 새로운 일제 관세 조치 발표로 인해 발생했으며, 이로 인해 시장은 글로벌 무역 전쟁과 경기 침체에 대한 우려를 야기했습니다&lt;/p&gt;
&lt;p&gt;관세 정책이 시장 공포를 야기하다&lt;/p&gt;
&lt;p&gt;트럼프 대통령은 지난주 모든 수입품에 대해 높은 관세를 부과한다고 발표했으며, 중국으로부터의 수입품에 대해서는 최대 50%의 관세를 부과하여 그가 불공정하다고 주장하는 글로벌 무역 체제를 바로잡으려 했습니다. 이러한 조치는 전 세계 시장에서 공포로 인한 매도세와 투자자들의 우려를 야기했으며, 무역 긴장이 고조될 경우 글로벌 경제 성장을 억제할 수 있다고 합니다.&lt;/p&gt;
&lt;p&gt;전 세계 증시 급락&lt;/p&gt;
&lt;p&gt;미국에서 주요 주가지수가 큰 폭으로 하락했습니다. 다우존스 산업평균지수는 1,200점 이상 하락했고, 나스닥 종합지수는 4%, S&amp;amp;P 500 지수는 3.8% 하락하며 곰 시장에 진입했습니다. 아시아와 유럽 시장도 예외는 아니었습니다. 일본 닛케이 지수는 거의 8% 하락했고, 유럽 증시는 6% 하락했습니다.&lt;/p&gt;
&lt;p&gt;투자자들이 안전 자산으로 몰리고 있다&lt;/p&gt;
&lt;p&gt;시장이 급변하는 가운데 투자자들은 채권과 엔화와 같은 안전 자산으로 방향을 전환하고 있습니다. 하지만 시장 변동성 지수(VIX)가 60 이상으로 치솟아 시장의 공포 심리가 커지고 있음을 보여줍니다.&lt;/p&gt;
&lt;p&gt;경제학자들이 스태그플레이션 위험을 경고하다&lt;/p&gt;
&lt;p&gt;경제학자들은 관세 정책이 미국 경제를 “정체 인플레이션”으로 몰아넣을 수 있다고 경고했는데, 이는 경기 침체와 통화량 팽창, 높은 실업률이 동시에 존재하는 상황을 의미합니다. 모건 스탠리는 미국의 경기 침체 가능성을 60%로 상향 조정했습니다.&lt;/p&gt;
&lt;p&gt;각국 정부와 기업의 반응&lt;/p&gt;
&lt;p&gt;각국 정부는 보복 조치를 취할 것이라고 밝혔습니다. 예를 들어, 유럽연합 무역 담당자는 4월 15일부터 미국 상품에 대한 보복 관세를 부과할 예정이라고 말했습니다. 기업계에서도 우려가 표출되었으며, 골드만삭스와 같은 월스트리트 회사들은 미국의 경기 침체 가능성을 45%로 높였습니다.&lt;/p&gt;
&lt;p&gt;결론&lt;/p&gt;
&lt;p&gt;현재, 글로벌 시장은 유례없는 도전에 직면해 있으며 투자자는 무역 정책 동향과 시장 변화에 주의 깊게 주목하고 위험 관리 및 자산 배치를 철저히 해야 합니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>심심해서 중국 수묵화 스타일 테마를 디자인하고 싶다</title>
        <link>https://ttf248.life/ko/p/chinese-ink-style-theme/</link>
        <pubDate>Tue, 08 Apr 2025 03:42:47 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/chinese-ink-style-theme/</guid>
        <description>&lt;p&gt;다채로운 홈페이지를 너무 많이 봐서, 갑자기 미니멀리즘 스타일로 가고 싶어져서 중국 수묵화 스타일의 테마를 디자인하고 싶어요&lt;/p&gt;
&lt;p&gt;현재 스타일 시트는 각 요소에 맞게 특정 스타일이 적용되어 주제의 기본 스타일을 덮어쓰도록 수정되었습니다&lt;/p&gt;
&lt;p&gt;재구조화 없이 인공지능으로 직접 새로운 테마를 생성하면 결과가 매우 불안정합니다&lt;/p&gt;
&lt;p&gt;우연히 또 trae claude 대기열에 들어가서, vscode 에이전트 모드로 전환했더니 효과가 매우 안 좋고, 수정된 결과물은 아무런 디자인 감각도 없다&lt;/p&gt;
&lt;p&gt;결국, 제가 프론트엔드를 잘 몰라서 AI에게 효과적으로 업무를 분담할 수 없는 탓입니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>광기 지수 적립 투자: 증권 ETF, 헝셍 테크놀로지 지수</title>
        <link>https://ttf248.life/ko/p/etf-wide-index-dzt-broker-etfs-hangsheng-tech-index/</link>
        <pubDate>Thu, 27 Mar 2025 21:58:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/etf-wide-index-dzt-broker-etfs-hangsheng-tech-index/</guid>
        <description>&lt;p&gt;예전부터 하고 싶었던 일, 적절한 우량주를 사서 그냥 내버려 두는 것인데, 떨어지면 상황을 보고 추가 매수를 안 하고, 오르면 팔아 버리는 결과로 결국 해내지 못했다&lt;/p&gt;
&lt;p&gt;적합한 우량주를 찾기보다는 폭넓은 지수를 선택해서 ETF를 사는 게 더 편하다. 현재 계획은 증권 ETF와 헝셍 테크놀로지 지수다.&lt;/p&gt;
&lt;p&gt;이러한 방식은 전문적으로 좌측 하락 보충 매수라고 합니다&lt;/p&gt;
&lt;p&gt;다음 계획은 폭넓은 지수 하나를 선택해서 완전히 실천해 보는 건데, 정기 예금 이자율을 능가하는 수익률이면 충분합니다&lt;/p&gt;
&lt;h2 id=&#34;증권-etf&#34;&gt;증권 ETF
&lt;/h2&gt;&lt;p&gt;증권 ETF는 중국 증권회사를 주요 투자 대상으로 하는 상장지수표(ETF)를 말하며, 주로 중국 증시 상장된 증권회사 주식에 투자합니다. 증권 ETF는 일반적으로 중증 증권회사 지수와 같이 특정 증권회사 지수를 추적합니다.&lt;/p&gt;
&lt;p&gt;전에 한 번 샀었는데, 그때 고점을 쫓다가 손해보고 정리했어요. 중국 시장은 매번 강세장일 때 증권사 주식이 오르는 법이고, 얼마나 오르느냐는 투자자들의 심리에 달려 있어요.&lt;/p&gt;
&lt;h2 id=&#34;항생기술지수&#34;&gt;항생기술지수
&lt;/h2&gt;&lt;p&gt;항셍 테크놀로지 지수는 홍콩 증권 거래소에서 출시한 주식 지수로, 홍콩 시장의 기술 산업 전반적인 실적을 반영하는 것을 목표로 합니다. 이 지수는 인터넷, 전자 상거래, 클라우드 컴퓨팅, 인공 지능 등 다양한 분야를 포괄하며 홍콩에 상장된 주요 기술 회사들을 포함합니다.&lt;/p&gt;
&lt;p&gt;2025년 5월 20일 현재, 항셍 테크놀로지 지수(코드: 800700)의 상위 10개 구성 종목과 비중은 다음과 같습니다(다수의 권위 있는 출처에서 데이터 종합)&lt;/p&gt;
&lt;p&gt;샤오미 그룹-W(01810.HK): 약 8.82%
텐센트 홀딩스(00700.HK): 약 8.14%
알리바바-W(09988.HK): 약 7.72%
징동그룹-SW(09618.HK): 약 7.60%
미투안-W(03690.HK): 약 7.35%
쾌수-W(01024.HK): 약 6.10%
이상자동차-W(02015.HK): 약 6.09%
중신국제(00981.HK): 약 5.70%
넷이즈-S(09999.HK): 약 4.59%
씨트립 그룹 -S (09961.HK): 약 4.48%&lt;/p&gt;
&lt;p&gt;약 66.6%(일부 출처에 따르면 상위 10대 합계 비율은 68%-69% 사이이며, 차이는 통계 시점의 차이에서 기인함)&lt;/p&gt;
&lt;h3 id=&#34;주요-사항&#34;&gt;주요 사항
&lt;/h3&gt;&lt;p&gt;가중치 상한제: 행생기술지수는 개별 주식의 가중치에 8% 상한을 설정했습니다. 예를 들어, 중신국제는 2025년 3월 조정 전 가중치가 8%를 초과했으나 이후 순차적으로 매각되어 규정 범위 내로 감축되었습니다.
구성 종목 조정: 2025년 5월 16일, 홍콩항생지 회사에서 BYD(01211.HK)가 지수에 편입되고 텐센트 그룹(00772.HK)이 제외될 것이라고 발표했습니다. 이 조정은 6월 6일에 적용됩니다. 따라서 현재(5월 20일) 구성 종목은 조정 전 명단과 동일하며 BYD는 아직 포함되지 않았습니다.
산업 분포: 상위 10대 구성 종목에서 인터넷 기술 기업(텐센트, 알리바바, 메이턔)이 주도하고 있으며, 신에너지 자동차(샤오미, 리샹)와 반도체(중신국제)의 비중이 두드러지게 나타나 지수가 기술과 신경제 영역을 포괄하는 것을 반영한다
데이터 시효성: 서로 다른 출처의 데이터 차이는 주로 통계 시간점이 다르기 때문입니다. 예를 들어, 2025년 3월 데이터는 상위 10대 합계 비중이 약 69.4%를 보이는 반면, 5월 14일 데이터는 68.82%로 나타나 시장 변동성이 가중치에 미치는 역동적인 영향을 반영합니다.&lt;/p&gt;
&lt;h2 id=&#34;왼쪽-하락-보충매수&#34;&gt;왼쪽 하락 보충매수
&lt;/h2&gt;&lt;p&gt;왼쪽 하락세에서 보충 매수법은 투자 전략 중 하나로, 주가가 지속적으로 하락하는 과정에서 투자자가 주가가 바닥 영역에 가까워질 것으로 예상하고, 보유 비용을 줄이기 위해 적극적으로 분할 매수를 하여 향후 가격이 상승하여 이익을 얻기를 기다리는 것을 말합니다&lt;/p&gt;
&lt;p&gt;이 방법은 시장이 명확하게 바닥을 보이기 전, 추세에 역행하는 거래를 하는 “왼쪽 거래” 범주에 속합니다. 구체적인 운영에서 투자자는 일반적으로 “피라미드식” 매수 전략을 채택하는데, 이는 주가가 하락함에 따라 점진적으로 매입량을 늘려 평균 보유 비용을 낮추는 것입니다. 예를 들어, 처음 일정량의 주식을 매입한 후, 주가가 계속 하락하면 더 낮은 가격에서 매수 규모를 키우고, 이와 같은 방식으로 진행합니다.&lt;/p&gt;
&lt;p&gt;장점:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;포지션 비용을 낮추기 위해 하락 시 분할 매수를 통해 평균 보유 주식 단가를 낮춰 미래 수익을 위한 기반을 마련합니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사전에 포지션을 구축합니다. 시장이 아직 반전하지 않았을 때 입장을 마련하여, 판단이 정확하다면 시장이 회복될 때 더 큰 수익을 얻을 수 있습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;단점:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;위험이 높습니다: 주가가 계속 하락하면 더 큰 손실을 볼 수 있습니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;자금 압박: 지속적인 추가 매수를 위한 충분한 자금 지원이 필요하며, 자금이 장기간 묶일 가능성도 있습니다&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;상대적으로 “우측 거래”는 시장 추세가 명확하고 주가가 반등하는 징후가 분명해진 후에 매수 작업을 진행하는 방식으로, 위험은 상대적으로 낮지만 반등 초기의 수익을 놓칠 수도 있습니다. 따라서 투자자는 자신의 위험 감내 능력, 자금 상황 및 시장 판단에 따라 적합한 거래 전략을 선택해야 합니다.&lt;/p&gt;
&lt;h2 id=&#34;가치-평가-이론&#34;&gt;가치 평가 이론
&lt;/h2&gt;&lt;p&gt;가치 평가 이론은 금융학의 핵심 개념으로, 자산 또는 기업의 내재 가치를 평가하여 투자 결정의 근거를 제공합니다. 가치 평가를 통해 투자자는 자산의 현재 시장 가격이 합리적인지 판단하고 그에 따른 투자 전략을 수립할 수 있습니다.&lt;/p&gt;
&lt;p&gt;주요 평가 방법:&lt;/p&gt;
&lt;p&gt;할인현금흐름법(DCF): 이 방법은 자산이 미래에 창출할 것으로 예상되는 현금 흐름을 기반으로 하며, 이러한 현금 흐름을 적절한 할인율로 할인하여 현재 가치로 환산합니다. DCF 방법은 자산의 내재 가치를 강조하며, 수익성이 안정적이고 예측 가능한 기업 평가에 적합합니다.&lt;/p&gt;
&lt;p&gt;상대 가치 평가법: 이 방법은 대상 기업과 동일 업계 다른 기업의 가치 지표(주가수익비율(P/E), 주가순자산비율(P/B), 주가매출액비율(P/S) 등)을 비교하여 기업의 상대적 가치를 평가합니다. 상대 가치 평가법은 사용하기 간편하며, 빠른 평가와 동일 업계 비교에 널리 활용됩니다.&lt;/p&gt;
&lt;p&gt;자산 기초법: 이 방법은 자산 총액에서 부채를 차감한 순자산 가치를 평가하여 기업의 가치를 결정합니다. 자산 기초법은 부동산 회사나 자본 집약적 기업과 같이 자산을 주도하는 기업에 적용됩니다.&lt;/p&gt;
&lt;p&gt;가치 평가 이론의 적용:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;투자 결정: 평가를 통해 투자자는 저평가되거나 고평가된 자산을 파악하고 매수 또는 매도 전략을 수립할 수 있습니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기업 인수합병: 인수합병 거래에서 가치 평가는 거래 가격을 결정하는 핵심이며, 거래의 성공 여부에 영향을 미친다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;재무 보고서: 회사는 재무제표의 정확성과 투명성을 확보하기 위해 자산과 부채를 공정가치로 평가해야 합니다&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;주의해야 할 점은, 가치 평가 결과는 시장 환경, 회사 운영 상태, 거시 경제 지표 등 다양한 요인의 영향을 받는다는 것입니다. 따라서 가치 평가를 수행할 때는 다양한 요소를 종합적으로 고려하고 정성적 및 정량적 분석을 병행하여 보다 정확한 평가 결과를 얻어야 합니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>코딩 없이 맞춤 주식 모듈 설계 개발</title>
        <link>https://ttf248.life/ko/p/no-code-design-develop-custom-stock-module/</link>
        <pubDate>Thu, 27 Feb 2025 23:20:39 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/no-code-design-develop-custom-stock-module/</guid>
        <description>&lt;p&gt;지난달에 커서를 시험 사용해 봤는데, 무료 한도 제한 때문에 복잡한 기능 개발은 하지 않고 간단히 테스트만 했습니다. 그때쯔음에 바이트(Byte)도 유사한 제품을 출시했고, 두 제품 모두 기반으로 하는 대규모 언어 모델이 Claude-3.5였습니다.&lt;/p&gt;
&lt;p&gt;바이트의 제품인 트레이인데, 먼저 맥 버전으로 출시했고, 올해 2월에 드디어 윈도우 버전이 나왔어. 대기업 제품은 역시 좋지, 무료로 사용할 수 있고 돈을 내지 않아도 무제한으로 Claude-3.5를 사용할 수 있는데, 이 모델의 성능은 아주 괜찮아.&lt;/p&gt;
&lt;p&gt;최종적으로 K라인 차트 개발에 막혀버렸습니다. 개인적으로 React에 대한 기본 지식이 부족하여 포기할 수밖에 없었습니다. 계속 개발하려면 저자가 프론트엔드 기초 지식을 보충하고, “K라인 차트 개발”과 같이 큰 작업을 바로 주지 않고 더 세분화된 작은 작업으로 나누어야 합니다.&lt;/p&gt;
&lt;h2 id=&#34;발견된-문제&#34;&gt;발견된 문제
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;해외 AI 모델 사용으로 인해 Vue3 + Element-Plus의 학습 데이터가 부족하여, 프론트엔드 프레임워크로 React를 선택했습니다&lt;/li&gt;
&lt;li&gt;문법 오류가 발생할 수 있으므로, 사람이 직접 수정해야 합니다&lt;/li&gt;
&lt;li&gt;일부 복잡한 문제 해결에는 사람의 지침이 필요합니다&lt;/li&gt;
&lt;li&gt;코드 구조 최적화는 수동 지침이 필요합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;가장 시간이 오래 걸린 부분은 프론트엔드 코드를 컨테이너에 패키징하는 것이었는데, 작성자가 기초 지식이 전혀 없어서 &lt;code&gt;.env.production&lt;/code&gt; &lt;code&gt;tsconfig.json&lt;/code&gt; 같은 개념도 전혀 알지 못했습니다. 중간에 도움을 받은 덕분에 겨우 논리를 파악할 수 있었습니다. 프론트엔드 개발의 dev 모드와 build 모드는 코드 검사에서 큰 차이가 있습니다. 백엔드 데이터베이스 및 서비스 컨테이너 스크립트는 총 5분 만에 처리했습니다.&lt;/p&gt;
&lt;p&gt;AI는 현재 개발 효율성을 높이는 데 더 중점을 두고 있으며, 기본기가 가장 중요하며 AI가 모든 문제를 해결해 주는 것은 아닙니다&lt;/p&gt;
&lt;h2 id=&#34;창고-주소&#34;&gt;창고 주소
&lt;/h2&gt;&lt;p&gt;제목에서 언급했듯이, 이번에는 코딩하지 않고 AI와 직접 대화하며 자체 선택 주식 모듈을 설계하고 개발해 보겠습니다. 최종적으로 어떤 결과물이 나올지 지켜보죠.&lt;/p&gt;
&lt;p&gt;저장소 주소: &lt;a class=&#34;link&#34; href=&#34;https://github.com/ttf248/trae-demo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ttf248/trae-demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;자세한 사용 방법은 창고의 README.md 파일을 참조하십시오&lt;/p&gt;
&lt;p&gt;창고에는 많은 제출 기록이 포함되어 있는데, 대부분은 저와 Trae의 대화 기록과 제가 Trae의 몇몇 기능들을 테스트한 내용이며, 해당 기능을 구현하기 위해 수동 개입이 이루어졌는지에 대한 메모가 달려 있습니다&lt;/p&gt;
&lt;h2 id=&#34;prompt&#34;&gt;Prompt
&lt;/h2&gt;&lt;p&gt;프로젝트는 처음부터 시작되었으며, 프로젝트 프롬프트는 다음과 같습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;基于项目原型图，开发功能：自选股，需要支持合约的新增、删除、修改、查询。自选股界面需要展示基础的行情数据。支持多个不同的市场切换。

前端：react
后端：golang gin gorm
数据库：PostgreSQL

服务端需要支持跨域请求，同时需要考虑数据的校验和错误处理，如果后端服务不可用，前端需要告警提示。

后端需要展示请求和应答的日志；前端也打印通讯的日志，方便排查问题。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ui-및-상호작용-최적화&#34;&gt;UI 및 상호작용 최적화
&lt;/h2&gt;&lt;p&gt;프론트엔드 인터페이스 디자인은 완전히 Grok에 의존하고 있으며, 우리는 먼저 Trae에서 제품의 초기 형태를 만들었지만 심미적인 부분은 부족했습니다. 사용한 모델은 코드 능력은 강력하지만 다른 기능은 상대적으로 약하기 때문에 Grok을 사용하여 프론트엔드의 UI를 최적화해야 합니다.&lt;/p&gt;
&lt;p&gt;현재 인터페이스의 스크린샷을 찍어 Grok에 업로드한 다음, Grok이 우리 UI를 최적화하도록 하고, 여러 가지 최적화 제안을 한 번에 받은 뒤, 저희가 수동으로 평가하고 Trae에서 실행하여 최적화 효과를 관찰합니다&lt;/p&gt;
&lt;h3 id=&#34;기술-스택&#34;&gt;기술 스택
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;프론트엔드: React + TypeScript&lt;/li&gt;
&lt;li&gt;백엔드: Golang + Gin + GORM&lt;/li&gt;
&lt;li&gt;데이터베이스: PostgreSQL 17&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;시스템-아키텍처&#34;&gt;시스템 아키텍처
&lt;/h2&gt;&lt;h2 id=&#34;백엔드-아키텍처&#34;&gt;백엔드 아키텍처
&lt;/h2&gt;&lt;p&gt;백엔드는 Golang의 Gin 프레임워크로 구현된 RESTful API이며, 주요 모듈은 다음과 같습니다:&lt;/p&gt;
&lt;p&gt;데이터베이스 모듈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GORM을 ORM 프레임워크로 사용하세요&lt;/li&gt;
&lt;li&gt;환경 변수를 통해 데이터베이스 연결을 구성할 수 있습니다&lt;/li&gt;
&lt;li&gt;자동으로 데이터베이스 테이블 마이그레이션 수행&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;라우팅 모듈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RESTful API 설계&lt;/li&gt;
&lt;li&gt;통일된 오류 처리 메커니즘&lt;/li&gt;
&lt;li&gt;내장 요청 로깅&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;영역 간 처리&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;로컬 개발 환경 간의 교차 도메인 접근을 지원합니다&lt;/li&gt;
&lt;li&gt;구성 가능한 CORS 정책&lt;/li&gt;
&lt;li&gt;쿠키 크로스 도메인 지원&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;프론트엔드-아키텍처&#34;&gt;프론트엔드 아키텍처
&lt;/h2&gt;&lt;p&gt;프론트엔드는 React + TypeScript로 구축되었으며, 다음과 같은 기능을 구현했습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;주식 목록 표시&lt;/li&gt;
&lt;li&gt;자선주 관리&lt;/li&gt;
&lt;li&gt;시장 데이터 표시&lt;/li&gt;
&lt;li&gt;오류 표시 메커니즘&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>AI 개발 2년: 도커 출시 전과 비슷한 상태</title>
        <link>https://ttf248.life/ko/p/ai-development-two-years-docker-pre-release/</link>
        <pubDate>Thu, 20 Feb 2025 18:16:37 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/ai-development-two-years-docker-pre-release/</guid>
        <description>&lt;p&gt;인공지능(AI)은 최근 몇 년간 기술 분야에서 가장 핫한 논제 중 하나이며, 특히 지난 2년 동안 AI 기술이 비약적으로 발전했습니다. 심층 학습, 자연어 처리는 물론 컴퓨터 비전, 자동화 의사 결정 시스템까지, AI의 적용 사례가 끊임없이 등장하고 있습니다. 하지만 기술이 계속해서 도약을 이루고 있음에도 불구하고, AI는 Docker 출시 이전과 유사한 병목 현상에 직면해 있는데, 이는 시장을 진정으로 폭발시킬 만한 &amp;lsquo;경험 있는 애플리케이션&amp;rsquo;이 부족하기 때문입니다.&lt;/p&gt;
&lt;p&gt;AI가 발전한 지 2년 정도 되었는데, Docker가 처음 공개되기 전과 비슷한 상황입니다. 아직 게임 체인저와 같은 Killer App이 없고, 현재 기술을 기반으로 완벽한 적용 사례를 만들어내야 합니다. Docker는 새로운 기술을 많이 사용하지 않았지만, 전체적인 솔루션이 매우 합리적이었고 운영 및 개발 업무의 워크플로우를 변화시켰습니다.&lt;/p&gt;
&lt;h2 id=&#34;인공지능-발전-현황-기술은-이미-성숙했지만-적용은-아직-돌파구를-찾아야-한다&#34;&gt;인공지능 발전 현황: 기술은 이미 성숙했지만, 적용은 아직 돌파구를 찾아야 한다
&lt;/h2&gt;&lt;p&gt;기술적인 측면에서 볼 때, AI는 지난 2년 동안 상당한 발전을 이루었습니다. OpenAI의 GPT 시리즈 모델이든, Google의 BERT, DeepMind의 Alpha 시리즈든, AI의 처리 능력은 이전 예상보다 훨씬 뛰어넘었습니다. 특히 자연어 처리 분야에서 GPT-4와 같은 모델은 강력한 생성 능력을 갖추는 것은 물론 이해력과 추론 능력에서도 놀라운 성과를 보여주고 있습니다.&lt;/p&gt;
&lt;p&gt;하지만, 기술이 비약적으로 발전하고 있음에도 불구하고 AI의 실제 적용은 일정한 어려움에 직면해 있습니다. Docker 출시 이전과 비슷하게, AI의 잠재력은 매우 크지만 아직 널리 보급되어 산업을 변화시킬 수 있는 진정한 &amp;lsquo;게임 체인저&amp;rsquo; 애플리케이션은 나타나지 않았습니다. 많은 사람들이 AI의 전망에 대해 이야기하지만, 직접적인 혁신적 변화를 가져올 수 있는 적용 사례를 찾기는 어려울 것입니다. 많은 AI 애플리케이션이 여전히 초기 단계에 머물러 있으며, 대부분 추가 통합 및 최적화가 필요합니다.&lt;/p&gt;
&lt;h2 id=&#34;도커와-ai의-유사성-기술-자체가-혁신이-아니라-솔루션이-핵심이다&#34;&gt;도커와 AI의 유사성: 기술 자체가 혁신이 아니라, 솔루션이 핵심이다
&lt;/h2&gt;&lt;p&gt;만약 Docker 출시 이전의 역사를 되돌아보면, 당시 기술 환경과 AI의 발전 현황 사이에 많은 유사점을 발견하기 어렵지 않습니다. Docker가 출시되기 전, 컨테이너 기술은 새로운 것이 아니었고, 초기 LXC(Linux Containers)와 가상화 기술들은 이미 컨테이너화의 기본적인 능력을 갖추고 있었습니다. 하지만 Docker는 기존 기술을 교묘하게 통합하고 최적화하여 더욱 간단하고 직관적이며 효율적인 솔루션을 제시했습니다. 이 솔루션은 획기적인 기술을 도입하지 않았지만, 운영 및 개발 과정에서 많은 어려움을 해결하고 소프트웨어의 배포, 확장 및 관리 프로세스를 크게 단순화했습니다.&lt;/p&gt;
&lt;p&gt;동일하게도 AI 분야 또한 유사한 상황에 직면해 있습니다. 현재의 AI 기술은 더 이상 “새로운 물건”이 아니지만, 진정으로 대규모 적용을 달성하기 위해서는 Docker처럼 기존 기술을 융합하고 최적화하여 합리적인 애플리케이션 방안을 형성하는 완벽한 실행 사례가 여전히 필요합니다. AI의 핵심 애플리케이션은 새로운 기술 돌파구에 의존하기보다는 기존 기술을 통합하여 실제 비즈니스에서 발생하는 문제점과 요구사항을 해결하는 데 달려 있을 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;ai의-도커-순간은-어떻게-찾아야-할까요&#34;&gt;AI의 “도커 순간”은 어떻게 찾아야 할까요?
&lt;/h2&gt;&lt;p&gt;AI 기술이 진정으로 널리 활용되려면 몇 가지 측면에서 노력해야 합니다&lt;/p&gt;
&lt;p&gt;실제 상황에 대한 심층적인 분석
현재 많은 AI의 적용 사례는 아직 실험적인 성격이 강하고 대규모로 실제 적용되지는 못하고 있습니다. 예를 들어, AI 고객 서비스나 지능형 추천과 같은 분야는 널리 사용되고 있지만 기능에 여러 가지 한계가 있으며 업계의 난관을 돌파하지 못했습니다. 진정한 도약은 전통적인 방법으로 오랫동안 어려움을 겪어왔던 의료, 제조업, 물류와 같은 산업에서 발생할 수 있습니다. AI는 더욱 효율적인 데이터 처리 및 예측 분석을 통해 기업이 이러한 복잡한 시나리오에서 효율성을 높이고 비용을 절감하도록 도울 수 있습니다.&lt;/p&gt;
&lt;p&gt;제품화 및 사용 편의성
Docker와 같이 컨테이너화 프로세스를 간소화하여 운영 효율성을 높이는 것처럼, AI 제품의 사용 편의성 또한 매우 중요합니다. AI의 보급은 기술의 보급일 뿐만 아니라, 제품화된 AI의 보급입니다. AI를 일상적인 워크플로우에 통합하고, 사용자가 심도 있는 기술 이해 없이도 이러한 도구를 쉽게 사용할 수 있도록 하는 것이 AI 상용화를 위한 중요한 단계입니다.&lt;/p&gt;
&lt;p&gt;생태 건설과 표준화
어떤 새로운 기술이라도 널리 사용되기 위해서는 생태계 구축이 필수적입니다. Docker가 빠르게 성장할 수 있었던 이유는 바로 개방성과 호환성 덕분이었으며, 개발자들이 다양한 클라우드 플랫폼, 도구 및 서비스와 쉽게 연동할 수 있도록 해주었기 때문입니다. 마찬가지로 AI의 미래 또한 생태계 구축에 달려 있습니다. AI의 표준화, 모델 공유, 데이터 개방, 그리고 기술의 통합성은 AI가 광범위한 산업적 활용을 이룰 수 있는지 여부에 영향을 미칠 것입니다.&lt;/p&gt;
&lt;h2 id=&#34;결론적으로-ai의-미래는-가능성으로-가득-차-있지만-더욱-완벽한-해결책이-필요합니다&#34;&gt;결론적으로, AI의 미래는 가능성으로 가득 차 있지만, 더욱 완벽한 해결책이 필요합니다
&lt;/h2&gt;&lt;p&gt;비록 AI 기술이 지난 2년간 상당한 진전을 이루었지만, 현재는 아직 “획기적인 응용 분야가 없는” 단계에 머물러 있습니다. Docker 출시 전의 컨테이너화 기술과 마찬가지로, AI 역시 합리적인 적용 시나리오를 통해 기존 기술을 비즈니스 요구사항과 심층적으로 융합해야 진정으로 대규모 적용 및 보급이 가능합니다. 기술 혁신은 물론 중요하지만, 프로세스를 간소화하고 효율성을 높이는 솔루션이야말로 기술의 보급과 발전을 더욱 촉진할 수 있습니다.&lt;/p&gt;
&lt;p&gt;미래에는 AI가 Docker처럼 획기적인 기술 돌파구가 아닌 기존 기술을 통합하여 완벽한 애플리케이션 시나리오를 구축함으로써, 결국 우리의 업무와 생활 방식을 바꿀 수 있습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>프로토Buf 0치 함정: 기본값이 비즈니스 로직의 보이지 않는 살인자</title>
        <link>https://ttf248.life/ko/p/protobuf-zero-value-traps/</link>
        <pubDate>Thu, 20 Feb 2025 15:26:51 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/protobuf-zero-value-traps/</guid>
        <description>&lt;p&gt;미국 주식 시장에는 세 가지 거래 시간대가 있습니다. 전시장, 장중, 장후입니다. 인터페이스 데이터 푸시는 값의 증분 로직(가능한 한 대역폭을 절약)이며, 처음 보내는 때는 전체 데이터를 보내고, 두 번째부터 모든 필드는 증분 방식으로 푸시됩니다.&lt;/p&gt;
&lt;p&gt;최적의 방안을 사용하지 않는 이유는 무엇인가요? 여러 프로젝트 팀이 관련되어 있고, 일부는 이미 수년 전에 배포되었습니다. 저희 쪽은 새로 연결하는 입장이므로 최대한 호환성을 고려할 수밖에 없습니다.&lt;/p&gt;
&lt;h2 id=&#34;일련의-문제&#34;&gt;일련의 문제
&lt;/h2&gt;&lt;p&gt;초록만 보더라도 별다른 문제가 없어 보일 수 있지만, 시스템 아키텍처가 문제 그룹으로 들어오면서 일련의 문제가 발생했습니다. 막 지난 문제를 해결하려 했더니 또 다른 문제가 생겼고, 이 문제는 이전 문제로 인해 발생한 것입니다.&lt;/p&gt;
&lt;h3 id=&#34;거래-기간을-식별할-수-없습니다&#34;&gt;거래 기간을 식별할 수 없습니다
&lt;/h3&gt;&lt;p&gt;알려진 바에 따르면, 디스크 내 단계 정의는 &lt;code&gt;protobuf&lt;/code&gt;에서 0으로 정의되어 있지만, 데이터를 수신할 때 증분 푸시로 인해 비즈니스 측면에서는 이 &lt;code&gt;0&lt;/code&gt;이 기본값인지 실제 비즈니스 값인지 효과적으로 식별하기 어렵습니다&lt;/p&gt;
&lt;p&gt;일반적인 이해로, 0을 받을 때마다 이 0이 새로운 시세 설정 값인지, 아니면 프로토콜 버퍼의 기본값인지 판단하기 어렵습니다&lt;/p&gt;
&lt;h3 id=&#34;선택적-도입&#34;&gt;선택적 도입
&lt;/h3&gt;&lt;p&gt;Since protobuf release 3.15, proto3 supports using the optional keyword (just as in proto2) to give a scalar field presence information&lt;/p&gt;
&lt;p&gt;조 내 통신 프로토콜은 &lt;code&gt;protobuf&lt;/code&gt; 기반이지만, 역사적인 이유로 비교적 오래된 버전이 선택되었고 &lt;code&gt;optional&lt;/code&gt; 키워드를 지원하지 않습니다. 아시는 분들은 이해하실 텐데, 하위부터 &lt;code&gt;protobuf&lt;/code&gt;를 도입하기 시작했고 프로젝트가 정적 라이브러리 방식으로 배포되어 전체 컴파일 링크를 업그레이드해야 하는데, 이 비용은 매우 높습니다.&lt;/p&gt;
&lt;h3 id=&#34;gcc-버전-문제&#34;&gt;GCC 버전 문제
&lt;/h3&gt;&lt;p&gt;정말 어렵게 대안을 마련했는데, 하위 레이어에서 두 가지 다른 버전을 배포하여 가능한 한 &lt;code&gt;protobuf&lt;/code&gt; 새 버전의 컴파일 의존성 전파를 제어하려고 했습니다. 하지만 컴파일하는 과정에서 &lt;code&gt;gcc&lt;/code&gt; 버전이 너무 낮아 &lt;code&gt;protobuf&lt;/code&gt;의 새로운 기능을 지원하지 않는다는 것을 발견했습니다.&lt;/p&gt;
&lt;p&gt;그룹 내에서 일반적으로 사용되는 서버 유형은 CentOS 7, CentOS 8입니다. CentOS 7의 기본 &lt;code&gt;gcc&lt;/code&gt; 버전은 4.8이고, CentOS 8의 기본 &lt;code&gt;gcc&lt;/code&gt; 버전은 8.3입니다. &lt;code&gt;protobuf&lt;/code&gt;의 새로운 기능은 &lt;code&gt;gcc&lt;/code&gt; 버전이 7.4 이상을 요구하므로 CentOS 7은 지원할 수 없습니다.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=82461&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Bug 82461 - [7 Regression] Temporary required for brace-initializing (non-literal-type) member variable&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;마지막으로 관련 서비스 배포 및 컴파일 서버를 CentOS 8로 옮겨서 이 문제를 해결했다&lt;/p&gt;
&lt;h2 id=&#34;합리적인-열거&#34;&gt;합리적인 열거
&lt;/h2&gt;&lt;p&gt;전체 문제를 되돌아보면, 사실 더 간단하고 효율적인 해결책이 있습니다. 바로 열거형의 정의를 조정하여 1부터 번호를 매기도록 하는 것입니다. 이렇게 하면 기본값과 비즈니스 값을 효과적으로 구별할 수 있으며, 위에서 언급한 일련의 문제들을 피할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;왜-1부터-시작하는-것이-더-합리적일까요&#34;&gt;왜 1부터 시작하는 것이 더 합리적일까요?
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;protobuf&lt;/code&gt;에서 열거형 유형의 기본값은 0으로 고정되어 있습니다. 의미 있는 비즈니스 값을 0으로 정의할 경우(예: &amp;ldquo;거래 중&amp;rdquo;), 증분 푸시 시 비즈니스 측에서 수신된 0이 비즈니스 값인지, 아니면 초기화되지 않은 기본값인지 판단하기 어렵습니다. 하지만 열거형을 1부터 시작하여 정의하면 0은 무의미한 기본값 또는 &amp;ldquo;알 수 없음&amp;rdquo; 상태로 유지할 수 있어 문제가 해결됩니다.&lt;/p&gt;
&lt;p&gt;권장되는 방법:&lt;/p&gt;
&lt;p&gt;프로토콜 버퍼 열거형을 설계할 때 항상 0을 무의미한 기본값(예: &lt;code&gt;UNKNOWN&lt;/code&gt; 또는 &lt;code&gt;RESERVED&lt;/code&gt;)으로 정의하십시오
실제 비즈니스 값을 1부터 할당하여 기본값 0과 구별되도록 합니다&lt;/p&gt;
&lt;p&gt;이 작은 조정 덕분에 우리는 거래 시간대 식별 문제를 해결했을 뿐만 아니라 향후 프로토콜 설계에 귀중한 교훈을 얻게 되었습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>국경절 전후 주식시장의 냉혹과 열정의 두 가지 얼굴: 급등과 급락의 극적인 전환</title>
        <link>https://ttf248.life/ko/p/national-holiday-stock-market-rollercoaster/</link>
        <pubDate>Sat, 15 Feb 2025 03:42:26 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/national-holiday-stock-market-rollercoaster/</guid>
        <description>&lt;p&gt;2024년 국경일 전 중국 증시는 눈길을 끄는 급등세를 보였지만, 휴일이 끝난 후 극적인 하락세로 전환되었습니다. 이러한 증시의 “차가운 불”과 같은 현상은 투자자들에게 짜릿한 경험을 안겨준 것은 물론 정책, 경제 및 시장 원리에 대한 깊은 성찰을 불러일으켰습니다.&lt;/p&gt;
&lt;p&gt;지난해 국경절 전 주식 시장 급등을 주제로 블로그를 작성하되, 국경절 이후의 주식 시장 폭락도 잊지 말고, 기사 형식으로 작성하십시오&lt;/p&gt;
&lt;h2 id=&#34;국경일-전-주식-시장-급등-정책-주도의-축제&#34;&gt;국경일 전 주식 시장 급등: 정책 주도의 축제
&lt;/h2&gt;&lt;p&gt;2024년 국경절 전 5개의 거래일 동안 중국 증시는 침체 상태에서 순식간에 “들끓는 모드”로 뛰어올랐다. 9월 30일, A주 시장은 전반적으로 큰 폭으로 상승했고 주요 지표들은 모두 사상 최고치를 경신했다. 상하이 지수는 8.06% 급등하고, 선전 종합 지수는 10.67% 상승했으며, 창업판 지수는 15.36% 급등했고, 북경증권지수(베이징 50)는 사상 최고 단일 거래일 상승률을 기록하며 22.84% 폭등했다. 시장 심리는 극도로 고조되었고, 상하이, 선전, 베이징 세 시장의 당일 거래액은 26115억 위안에 달했으며, 이전 거래일보다 11559억 위안 크게 증가했다. 대다수의 5300개 이상의 종목이 상승하며 “모두 빨간색”의 모습을 보였다.&lt;/p&gt;
&lt;p&gt;이번 시장 상승의 핵심 동력은 정부의 일련의 예상외 정책 발표와 그로 인한 시장 기대 변화에서 비롯되었습니다. 9월 24일, 중국인민은행이 지준율 인하, 금리 인하, 기존 주택담보대출 금리 인하 및 주택담보대출 최소 목돈 비율 통일을 발표했습니다. 9월 26일 중앙정치국 회의에서는 재정 및 통화 정책을 통한 경기 조절 노력을 강화하고 자본 시장 부양과 장기 자금 유치를 적극적으로 유도할 것을 강조했습니다. 9월 30일에는 부동산 지원 정책 4가지가 집중적으로 발표되었습니다. 이러한 정책들은 정부가 시장 안정과 성장을 위해 모든 역량을 기울이겠다는 의지를 시장에 전달했습니다.&lt;/p&gt;
&lt;h2 id=&#34;국경절-이후-주식-시장-급락-흥행-이후의-냉정함과-조정&#34;&gt;국경절 이후 주식 시장 급락: 흥행 이후의 냉정함과 조정
&lt;/h2&gt;&lt;p&gt;그러나 국경절 연휴가 끝난 후 시장 심리가 급격히 악화되었다. 10월 8일, A주식은 거의 한도 폭의 강세로 시작했지만, 급등 이후 시장은 격렬한 변동을 겪었고 결국 하락하여 마감했다. 그 이후 시장 중심이 계속 하락하여 10월 16일까지 상하이 지수는 15% 이상의 등락률을 보이며 누적 하락폭이 470점 이상이었다. 10월 8일부터 10일까지 A주식 핵심 지표는 전반적으로 하락세를 보였으며, 특히 창업판 지수는 6.21% 하락했다.
이러한 급락의 원인은 한편으로는前期 빠르게 상승하면서 쌓인 위험을 해소하는 것이고, 다른 한편으로는 시장의 정책 기대 조정과 관련이 있습니다. 일부 투자자들은 정책의 단기 효과는 나타나고 있지만 장기적인 효과는 아직 지켜봐야 한다고 생각합니다. 또한 해외 시장의 변동성도 A주에 영향을 미쳤습니다. 10월 9일, 항셍지수는 9.41% 폭락했고, A50 선물은 10.4% 폭락하면서 시장 하락을 더욱 심화시켰습니다.&lt;/p&gt;
&lt;h2 id=&#34;시장의-성찰과-전망&#34;&gt;시장의 성찰과 전망
&lt;/h2&gt;&lt;p&gt;국경일 전후 주식 시장의 격렬한 변동은 시장이 정책, 경제 및 시장 원리에 대한 깊은 반성을 하게 만들었습니다. 한편 정책의 단기적인 경기 부양 효과는 뚜렷하지만 장기적인 효과는 아직 지켜봐야 할 것입니다. 다른 한편으로는 시장의 급격한 상승과 하락은 투자자들이 합리성을 유지하고 감정적인 투자를 피하도록 상기시키기도 합니다.&lt;/p&gt;
&lt;p&gt;미래, A주 시장이 진정한 “장우(長牛)” 행보를 걷게 될지 여부는 정책이 실체 경제에 효과적으로 전달되어 궁극적으로 경제 기본면의 실질적인 개선을 이끌어낼 수 있는지에 달려 있습니다. 투자자는 정책의 구체적인 실행 상황과 경제 지표 변화에 유의하며 합리적으로 투자 전략을 조정해야 합니다.&lt;/p&gt;
&lt;p&gt;국경일 전후로의 주식 시장의 폭등과 폭락은 정책과 시장 간의 경쟁이었으며, 투자자 심리에 대한 시험대였습니다. 이 “얼음과 불” 같은 변동성 속에서 우리는 시장의 힘과 정책의 영향력을 목격했습니다. 앞으로 시장이 어떻게 펼쳐질지 지켜봅시다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>설날 기간에 네자 신규 타겟 확장</title>
        <link>https://ttf248.life/ko/p/chinese-new-year-nizha-breakthrough/</link>
        <pubDate>Sat, 15 Feb 2025 03:40:07 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/chinese-new-year-nizha-breakthrough/</guid>
        <description>&lt;p&gt;우리 중국인들은 명절이면 온 가족이 모여 영화를 보는 것이 필수적인 오락 활동입니다. 올해 춘절 기간에 &amp;lsquo;哪吒&amp;rsquo;가 엄청난 인기를 끌었는데, 거리마다 다들 이야기하고 있어서 마치 예전의 &amp;lsquo;战狼&amp;rsquo;과 비슷한 분위기입니다. 애국주의 주제가 느껴져서 저도 모르게 민족적 자부심이 솟아오릅니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;춘절 기간에 ‘너자신’의 흥행과 함께 예상치 못한 민족적 자부심이 느껴지는 현상인데, 과거 ‘전랑’, ‘애국’ 영화와 유사한 분위기입니다. 분명히 많이 발전한 것은 부정할 수 없지만, 이 정도 수준이라고 보기는 어렵습니다. 게임 유저로서 여러 면에서 거슬리는 부분이 많고, 특히 격투 장면은 온라인 게임 스타일이 강합니다. ‘너자신’의 흥행을 위해 영화표를 샀지만 안 보는 사람들도 많이 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;격투-장면의-질감이-부족해&#34;&gt;격투 장면의 질감이 부족해
&lt;/h2&gt;&lt;p&gt;나는 게임을 즐기는 사람인데, 평소에 다양한 온라인 게임 세계에 푹 빠져 있어서 영화 자체에는 큰 기대를 하지 않았다. 하지만 이 《哪吒》의 인기가 워낙 대단해서 주변 사람들이 계속 이야기하길래, 그냥 한번 볼까 싶어서 갔다. 극장에 들어가서 화면이 나오자마자 마음이 “컥” 하는 느낌이었다. 비록 예전보다 묘사 수준은 많이 발전했지만, 몇몇 장면은 좀 번들거리는 느낌이었고, 액션 장면은 게임 스타일이 너무 강해서 어땠더라? 오랫동안 게임을 해왔는데, 이 화면 스타일이 게임 속 일부 장면과 너무 비슷해서 영화가 가진 질감이 부족하게 느껴졌다.&lt;/p&gt;
&lt;h2 id=&#34;광적인-영화-팬&#34;&gt;광적인 영화 팬
&lt;/h2&gt;&lt;p&gt;영화 보고 나오니, 세상에, 꽤 많은 사람들이 《哪吒》의 흥행을 위해 티켓은 샀는데 영화는 안 보인다고 한다. 이거 정말 대단하다. 역시 이 영화에 대한 사람들의 지지 열기가 상당한 것 같아, 뭐든 하고 싶어 하는 모양이다.&lt;/p&gt;
&lt;h2 id=&#34;줄거리&#34;&gt;줄거리
&lt;/h2&gt;&lt;p&gt;우리 되돌아보면, 《전랑》할 때, 우징이 “나를 범하는 자는 멀리 떨어져 있더라도 반드시 멸한다”고 외칠 때, 얼마나 많은 사람들이 열혈을 끓어올리고 우리 중국 군인이 너무 대단하고, 우리 나라가 너무 강대하다고 생각했습니까? 이 《哪吒》는 비록 그렇게 직접적인 애국 구호는 아니지만, 중국 전통 문화를 아주 생생하게 보여주고 있습니다. 여차와 오丙 같은 신화적 인물들, 우리는 어릴 때부터 그들의 이야기를 듣고 자랐는데, 영화에서 그들의 원한과 갈등, 성장 과정을 피가 흐르는 듯 생생하게 연기했습니다. 이것이 바로 우리 중국 문화의 매력이 아니겠습니까?&lt;/p&gt;
&lt;p&gt;나차 이야기를 해보자. 어릴 때 오해받고 백안미소를 당했지만, 그는 굴하지 않고 “내 운명은 내가 결정한다, 하늘에 의해 좌우되지 않는다”라고 외쳤다. 이런 정신과 우리 중국인들의 척추를 관통하는 끈기는 얼마나 닮았나. 어떤 어려움에 부딪히든 우리는 포기하지 않고 자신의 노력으로 운명을 바꾼다. 아오핑도 마찬가지다. 가문의 사명을 짊어지고, 겉으로는 냉정하지만 실은 마음이 착하며 친구를 위해서 자신을 희생하는 것을 두려워하지 않는다. 이런 우정과 책임감은 현실에서도 종종 볼 수 있지 않은가?&lt;/p&gt;
&lt;h2 id=&#34;애니메이션-영화의-발전&#34;&gt;애니메이션 영화의 발전
&lt;/h2&gt;&lt;p&gt;비록 《哪吒》가 몇몇 부분에서 완벽하지는 않지만, 중국 전통 문화와 현대 영화 기술을 꽤 잘 결합하여 우리에게 중국 애니메이션 영화의 발전을 보여주었습니다. 마치 예전에 《战狼》이 중국 영화가 액션 장르에서 이룬 도약을 모두에게 보여준 것과 같습니다. 이러한 발전은 우리 중국 영화도 국제 무대에서 두각을 나타낼 수 있고, 외국인들에게 중국 문화의 멋짐을 보여줄 수 있다는 느낌을 갖게 합니다.&lt;/p&gt;
&lt;p&gt;우리 중국인들은 어디를 가든 마음속에는 자신의 국가와 문화를 담고 있습니다. 《哪吒》나 《战狼》과 같은 영화는 마치 열쇠처럼 우리 마음 깊은 곳에 잠들어 있던 민족 자부심의 문을 여는 것 같습니다. 웃음과 즐거움 속에서 나라의 강대함과 문화의 매력을 느끼게 하고, 각자의 자리에서 열심히 노력하여 국가의 번영과 발전에 기여할 수 있도록 격려하는 것이죠. 아마도 이러한 영화가 인기를 얻고 우리 민족 자부심을 불러일으키는 이유가 바로 이것일 겁니다. 앞으로도 이런 영화들이 더 많이 등장하여 우리 민족 자부심이 항상 벅찰 정도로 가득하기를 바랍니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>백그라운드 서비스 TCP 통신 이상 점검</title>
        <link>https://ttf248.life/ko/p/backend-service-tcp-communication-troubleshooting/</link>
        <pubDate>Fri, 14 Feb 2025 22:54:13 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/backend-service-tcp-communication-troubleshooting/</guid>
        <description>&lt;p&gt;비즈니스 모델: 백엔드 서비스는 TCP를 통해 그룹의 시장 게이트웨이와 연결을 맺습니다. 각 연결 시에는 먼저 인증 요청을 보내고, 그 후 지속적으로 하트비트 패킷을 전송하여 연결 상태를 유지합니다.
하지만 어느 날, 서비스 연결 해제 경고 메시지를 받았습니다. 로그를 꼼꼼히 확인해 본 결과, 백엔드 서비스는 계속해서 하트비트 패킷을 전송하고 있었지만 상대방은 전혀 응답하지 않았음에도 불구하고 연결은 끊어지지 않고 있었습니다.&lt;/p&gt;
&lt;h2 id=&#34;현장-간략-설명&#34;&gt;현장 간략 설명
&lt;/h2&gt;&lt;p&gt;원래 회사에서 야근하며 프로젝트 진행을 추진 중이었는데, 업무 그룹 채팅방에 갑자기 경고 메시지가 떴다. 처음에는 예전 문제라고 생각했다. 네트워크 타임아웃으로 인해 하트비트 전송이 실패해서 연결이 끊어진 것 같았다. 하지만 로그를 자세히 확인해 보니 실제 상황은 그렇지 않았다. 백엔드에서 인증 로그인 메시지를 보냈지만 계속 응답을 받지 못했고, 동시에 하트비트는 지속적으로 전송되었지만 상대방은 어떠한 하트비트 데이터도 반환하지 않았다. 로그를 심층적으로 분석한 결과 다음과 같은 몇 가지 주요 문제가 드러났다:&lt;/p&gt;
&lt;p&gt;인가 메시지에 대한 응답이 없으면, 상대방 시스템이 재시동 중이라 인가 메시지가 적시에 처리되지 않았을 가능성이 매우 높습니다
승인되지 않은 상태에서 하트비트 데이터를 전송하는 문제: 조사 결과, 프로그램 로직의 결함이 원인입니다. 하트비트 전송 함수의 판단 로직에 문제가 있어 연결 상태만 확인하고 인증 상태를 확인하지 않았습니다.
서비스 연결이 끊어지면 재연결 메커니즘을 트리거하여 인증 메시지를 다시 보낼 수 있습니다&lt;/p&gt;
&lt;p&gt;현재, 해결해야 할 마지막 문제점은 서비스 연결이 끊어지지 않은 이유입니다. 이 문제의 해결을 위해서는 보다 심층적이고 세밀한 점검 작업이 필요합니다.&lt;/p&gt;
&lt;h2 id=&#34;네트워크-데이터-패킷-분석&#34;&gt;네트워크 데이터 패킷 분석
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;tcpdump&lt;/code&gt;는 매우 강력한 네트워크 패킷 캡처 도구로, 네트워크 데이터 패킷을 포착하는 데 사용할 수 있습니다. 네트워크 데이터 패킷을 분석함으로써 우리는 네트워크 통신의 세부 사항을 보다 직관적으로 이해할 수 있습니다. 여기서는 &lt;code&gt;tcpdump&lt;/code&gt;를 사용하여 네트워크 데이터 패킷을 포착하여 추가 분석을 할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/backend-service-tcp-communication-troubleshooting/20250220151952.png&#34;
	width=&#34;1126&#34;
	height=&#34;202&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;tcpdump&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;557&#34;
		data-flex-basis=&#34;1337px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;데이터를 분석해 보면 심박수는 계속 정상적으로 전송되고 있지만, 상대방 서버로부터는 아무런 데이터도 수신되지 않았고, 단지 &lt;code&gt;ACK&lt;/code&gt;만 받았기 때문에 연결이 자동으로 끊어지지 않고 있습니다&lt;/p&gt;
&lt;h2 id=&#34;일반적인-플래그-설명&#34;&gt;일반적인 플래그 설명
&lt;/h2&gt;&lt;p&gt;TCP 프로토콜에서 &lt;code&gt;PSH&lt;/code&gt;(Push)와 &lt;code&gt;ACK&lt;/code&gt;(Acknowledgment)는 데이터 전송과 흐름 제어를 위해 사용되는 중요한 플래그 비트입니다. 이들의 역할은 다음과 같습니다:&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;1-pshpush-flag&#34;&gt;&lt;strong&gt;1. PSH（Push Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;기능:
PSH 플래그는 &lt;strong&gt;수신 측이 버퍼에 있는 데이터를 상위 애플리케이션으로 즉시 푸시하도록 요청하는 역할&lt;/strong&gt;을 합니다(버퍼가 채워질 때까지 기다리지 않고). 이는 PSH 플래그가 있는 데이터 세그먼트를 받으면 수신 측은 운영체제 버퍼에 저장하기보다는 가능한 한 빨리 처리하여 애플리케이션에 전달합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;전형적인 장면&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP/HTTPS 요청 시(예: &lt;code&gt;GET /index.html&lt;/code&gt;) 클라이언트는 서버가 즉시 응답하기를 바라는 &lt;code&gt;PSH&lt;/code&gt;를 설정합니다&lt;/li&gt;
&lt;li&gt;SSH 프로토콜: 키보드 입력이 있을 때마다 &lt;code&gt;PSH&lt;/code&gt;가 트리거되어 입력 문자가 실시간으로 전송되도록 합니다&lt;/li&gt;
&lt;li&gt;실시간 통신: 비디오 스트리밍, 온라인 게임 등 저지연 시나리오에서는 &lt;code&gt;PSH&lt;/code&gt;를 사용하여 지연을 줄일 수 있습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;주의:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PSH는 필수가 아니며, 수신측은 해당 비트(flag bit)를 무시할 수 있습니다(데이터는 정상적으로 처리해야 합니다)&lt;/li&gt;
&lt;li&gt;보내는 쪽에서 &lt;code&gt;PSH&lt;/code&gt;를 설정하지 않을 수 있으며, 이 경우 받는 쪽은 자체 버퍼링 정책에 따라 데이터를 언제 보낼지 결정합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2-ackacknowledgment-flag&#34;&gt;&lt;strong&gt;2. ACK（Acknowledgment Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;기능:
ACK 플래그는 &lt;strong&gt;이전 데이터 세그먼트가 올바르게 수신되었음을 확인&lt;/strong&gt;합니다. 각 ACK에는 확인 번호(Acknowledgment Number)가 포함되어 있으며, 이는 예상되는 다음 바이트 시퀀스 번호를 나타냅니다. 이는 TCP 신뢰성 있는 전송의 핵심 메커니즘입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;작동 원리:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;송신자는 데이터 세그먼트를 보낼 때, 예상 수신자의 &lt;code&gt;ACK&lt;/code&gt; 값(예: &lt;code&gt;ACK = 시퀀스 번호 + 데이터 길이&lt;/code&gt;)을 함께 전송합니다&lt;/li&gt;
&lt;li&gt;수신 장치가 데이터를 수신하면, 수신 확인(&lt;code&gt;ACK&lt;/code&gt;) 세그먼트를 생성하여 수신된 데이터의 시퀀스 번호를 확인합니다&lt;/li&gt;
&lt;li&gt;송신자는 해당 &lt;code&gt;ACK&lt;/code&gt;를 수신한 후에야만 확인되지 않은 데이터를 재전송합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예시입니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;송신자가 시퀀스 번호가 &lt;code&gt;100~199&lt;/code&gt;인 데이터 세그먼트를 보냈다면, 예상되는 수신자의 &lt;code&gt;ACK&lt;/code&gt;는 &lt;code&gt;200&lt;/code&gt;이어야 한다&lt;/li&gt;
&lt;li&gt;수신자가 &lt;code&gt;100~199&lt;/code&gt; 범위 내의 특정 데이터를 받지 못하면, 송신자에게 재전송을 요청하기 위해 &lt;code&gt;ACK=150&lt;/code&gt;으로 알립니다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;psh와-ack의-조합&#34;&gt;PSH와 ACK의 조합
&lt;/h3&gt;&lt;p&gt;TCP 패킷에서 &lt;code&gt;PSH&lt;/code&gt;와 &lt;code&gt;ACK&lt;/code&gt;가 동시에 나타나는 경우는 다음과 같은 상황에서 흔히 볼 수 있습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;HTTP 요청 응답
클라이언트가 &lt;code&gt;POST&lt;/code&gt; 요청(데이터 포함)을 보낼 때, &lt;code&gt;PSH&lt;/code&gt;와 &lt;code&gt;ACK&lt;/code&gt;(이전 응답 확인)가 설정됩니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Client → Server: SYN, ACK=1 → 建立连接
Client → Server: PSH, ACK=1, 数据 → 发送请求数据
Server → Client: PSH, ACK=数据长度+1 → 返回响应
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SSH 핸드셰이킹 후 명령 전송
클라이언트가 명령을 입력하면 &lt;code&gt;PSH&lt;/code&gt; 및 &lt;code&gt;ACK&lt;/code&gt;가 포함된 데이터 세그먼트를 전송하여 명령이 즉시 전송되고 서버에서 처리되도록 합니다&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;다른-플래그-비트의-연관성&#34;&gt;다른 플래그 비트의 연관성
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;기호&lt;/th&gt;
&lt;th&gt;이름&lt;/th&gt;
&lt;th&gt;간략 설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;동기화&lt;/td&gt;
&lt;td&gt;초기화 연결 (세 번의 악수)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FIN&lt;/td&gt;
&lt;td&gt;종료&lt;/td&gt;
&lt;td&gt;연결 우아하게 닫기&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;재설정&lt;/td&gt;
&lt;td&gt;강제 연결 종료 (비정상 상황)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;URG&lt;/td&gt;
&lt;td&gt;긴급&lt;/td&gt;
&lt;td&gt;긴급 포인터 표시 (거의 사용하지 않음)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h3 id=&#34;요약&#34;&gt;요약
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;데이터가 최대한 빨리 애플리케이션 계층에 도달하도록 하여 지연 시간을 줄이는 데 중점을 두고 있습니다&lt;/li&gt;
&lt;li&gt;데이터의 신뢰성 있는 전송에 중점을 두고, 패킷 손실이나 순서 변경을 방지합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;두 가지는 협력하여 TCP 프로토콜의 효율성과 안정성을 균형 있게 맞췄다&lt;/p&gt;</description>
        </item>
        <item>
        <title>돈 벌려고 하는 일은 서두르면 안 된다. 서두르다고 해서 되는 일이 아니다.</title>
        <link>https://ttf248.life/ko/p/investing-takes-time/</link>
        <pubDate>Fri, 14 Feb 2025 20:30:24 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/investing-takes-time/</guid>
        <description>&lt;p&gt;수년간의 주식 투자 경험을 되돌아보면 큰 돈을 벌지는 못했지만, 너무 많이 잃지도 않았습니다. 가장 큰 문제는 자금 흐름 계획이 비합리적이고 마음가짐이 불안정하다는 것입니다. 현재 단계에서는 주로 직장에서 수입을 얻고 있으며 고정 급여를 받고 있고, 자금 변동에 대한 감당 능력은 채권과 은행 예금 수준에 머물러 있습니다. 하지만 사람들은 모두 욕심이 많아서, 조금 사면 오르면 돈을 벌지 못하고, 많이 사면 떨어지면 손해를 봅니다. 이때 마음가짐의 안정은 특히 중요하며, 이는 우리를 도와 부의 배를 지켜줍니다.&lt;/p&gt;
&lt;p&gt;주식 투자 심리 문제에 대한 글 작성&lt;/p&gt;
&lt;h2 id=&#34;과거-손실-사례&#34;&gt;과거 손실 사례
&lt;/h2&gt;&lt;p&gt;처음 시장에 들어왔을 때 소형주나 신규 상장 주식을 조금 경험한 이후로는, 중국은행, 중국이동통신, 헝생전자, 중싱통신, 각종 대형주 지수 펀드와 같은 우량주 위주로 투자하게 되었습니다&lt;/p&gt;
&lt;p&gt;예상 연율화하여 입으로만 은행 3년 정기 예금과 맞먹는다고 외치면서, 실제로는 더 많은 것을 원하는 탐욕에 시달렸고, 처음 투자할 때 서두르다가 나중에는 현금 흐름이 고갈되었다. 보험 구매, 주택 구입, 결혼 등은 자금 흐름의 큰 부분을 차지하며, 전체적인 계획에서 충분한 자금 흐름을 확보하지 못해 후기에 자금 흐름이 부족하게 되었다.&lt;/p&gt;
&lt;p&gt;블루칩을 사는 것은 &amp;lsquo;올드 머니&amp;rsquo;와 함께하는 것입니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;헝다 문제가 생겼을 때 은행주가 폭락하는 걸 보고 성공적으로 세일 아웃했다면, 경제 전체에 대한 인식이 부족했던 거다. 부동산이 국가 경제에서 차지하는 비중이 너무 크고 연관된 것들이 많아서 &lt;strong&gt;강착률&lt;/strong&gt;을 할 수 없다. 그 뒤로 지속적인 주식 시장 하락세가 나타났고, &lt;strong&gt;중국工商은행&lt;/strong&gt;과 같은 배당주들은 약 2년 정도 꾸준히 상승했다.&lt;/li&gt;
&lt;li&gt;무역 전쟁이 시작 단계였을 때, &lt;strong&gt;중신&lt;/strong&gt;이 큰 타격을 받았고 주가도 급락했지만, 이후 서서히 회복되었습니다&lt;/li&gt;
&lt;li&gt;흥생전자는 원래 소유주였고, 알리페이를 떠난 이후 주가가 많이 하락했지만 이 주식은 세력이 조작하고 매년 몇 번씩 급등합니다. 합리적으로 포지션을 관리하면 큰 손해를 보지 않을 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;탐욕-이성을-삼키는-괴물&#34;&gt;탐욕: 이성을 삼키는 “괴물”
&lt;/h2&gt;&lt;p&gt;탐욕은 주식 투자 심리에서 가장 흔한 문제점입니다. 주식 시장이 계속 상승하고 투자자들의 평가 이익이 끊임없이 증가할 때, 탐욕은 은근히 자라납니다. 많은 사람들이 주가가 이미 높은 수준에 도달했음에도 불구하고 더 오를 것이라는 환상에 빠져 더 많은 수익을 얻고 싶어 멈추지 못합니다. 그들은 탐욕에 눈이 멀어 시장의 규칙과 위험을 잊습니다. 예를 들어, 특정 인기 테마주 투기 과정에서 일부 투자자들은 주가가 단기간에 몇 배로 상승하는 것을 보고 깊숙이 빠져들어 끊임없이 매수 포지션을 늘려 마지막 승자가 되기를 희망합니다. 그러나 시장은 영원히 비정상적일 수는 없으며, 거품이 터지고 주가가 급락할 때, 탐욕에 이끌린 투자자들은 막대한 손실을 보는 경우가 많습니다. 탐욕은 그들이 합리적인 분석과 의사 결정 능력을 잃게 만들고, 현명한 투자자가 아닌 “도박꾼”으로 만듭니다.&lt;/p&gt;
&lt;h2 id=&#34;두려움-발목을-묶는-속박&#34;&gt;두려움: 발목을 묶는 “속박”
&lt;/h2&gt;&lt;p&gt;탐욕의 반대는 두려움이다. 두려움 또한 주식 시장에서 강력한 파괴력을 지니고 있다. 시장이 급격하게 하락하고 주가가 큰 폭으로 떨어질 때 투자자들은 쉽게 공포에 휩싸인다. 공포는 그들을 시장에 대한 신뢰를 잃게 만들고, 설령 손에 쥔 주식의 기본적 가치가 양호하더라도 더 많은 손실을 두려워하여 서둘러 매도하게 한다. 예를 들어, 전 세계적인 금융 위기가 발생했을 때 많은 우량주들의 주가 또한 시장 전체와 함께 큰 폭으로 하락했다. 일부 투자자들은 공포에 휩싸여 이러한 회사들의 장기적인 가치를 파악하지 못하고 극히 낮은 가격에 주식을 매도했으며, 결과적으로 후속 시장 반등과 기업 실적 증가로 인한 풍부한 수익을 놓치게 되었다. 두려움은 투자자들이 단기적으로 손실을 보게 할 뿐만 아니라, 그들에게 장기간의 심리적 그림자를 드리워 다시 시장에 참여하는 것을 꺼리게 만들 수 있으며, 결국 투자 기회를 놓치게 된다.&lt;/p&gt;
&lt;h2 id=&#34;눈앞의-안개에-휩쓸리다-길을-잃은-안개&#34;&gt;눈앞의 안개에 휩쓸리다: 길을 잃은 “안개”
&lt;/h2&gt;&lt;p&gt;주식 투자와 재테크 과정에서 무분별한 군집 심리는 투자자들이 쉽게 빠질 수 있는 또 다른 심리적 곤경입니다. 정보 과잉 시대에 다양한 투자 조언, 시장 소문, 인기 뉴스가 쏟아져 나옵니다. 많은 투자자들은 독립적인 사고 및 판단 능력이 부족하여 무조건 다른 사람을 따라 움직입니다. 주변 사람들이 특정 주식을 사서 돈을 벌었다는 것을 보면 생각 없이 따라 매수하고, 이른바 ‘내부 정보’를 들으면 모든 돈을 쏟아붓습니다. 이러한 무분별한 군집 심리적 행동은 주식 자체에 대한 연구와 분석을 간과하게 하여 투자자들이 안개 속에서 길을 잃은 배처럼 방향성을 상실하게 합니다. 예를 들어, 일부 컨셉주가 시장 과열 초기에는 따라 하는 사람들에게 단기적인 이익을 가져다줄 수 있지만, 과열이 가라앉으면 주가가 폭락하고, 상황을 제대로 파악하지 못하고 무분별하게 따라 한 투자자들은 ‘피해자’가 됩니다. 그들은 각 투자자의 위험 감수 능력, 투자 목표 및 투자 기간은 모두 다르며 다른 사람에게 맞는 투자 전략이 자신에게도 적합하지 않을 수 있다는 사실을 깨닫지 못합니다.&lt;/p&gt;
&lt;h2 id=&#34;과도한-자신감-숨겨진-암초&#34;&gt;과도한 자신감: 숨겨진 “암초”
&lt;/h2&gt;&lt;p&gt;과도한 자신감 또한 주식 투자와 재테크 마인드에서 간과할 수 없는 문제이다. 일부 투자자들은 몇 번의 투자 성공을 거둔 후 자기만족에 빠져 자신이 시장의 규칙을 이미 터득했다고 믿고 정확하게 주가 흐름을 예측할 수 있다고 생각한다. 그들은 시장의 복잡성과 불확실성을 무시하고 과도하게 거래하며, 맹목적으로 투자 규모를 확대하거나 심지어 고레버리지 투기를 사용하기도 한다. 하지만 시장은 변화무쌍하기 때문에 과도한 자신감을 가진 투자자들은 예상치 못한 시장 변동 속에서 큰 타격을 입는 경우가 많다. 예를 들어, 경험이 부족하지만 초기 전투에서 승리한 투자자들이 자신이 전문적인 투자 능력을 갖추었다고 믿고 빈번하게 주식을 사고팔며 끊임없이 투자 금액을 늘린다. 시장에 시스템 리스크나 개별 종목의 갑작스러운 악재가 발생했을 때, 그들은 과도한 자신감 때문에 제때 손실을 멈추지 못하여 원금 대부분을 잃게 된다. 과도한 자신감은 마치 해면 아래 숨겨진 암초와 같아서 겉으로는 평온하고 무해하지만, 불시에 투자자의 부를 실어 나르는 배를 좌초시켜 침몰시킬 수 있다.&lt;/p&gt;
&lt;h2 id=&#34;어떻게-마음을-조절하고-안정적으로-재테크할-수-있을까&#34;&gt;어떻게 마음을 조절하고 안정적으로 재테크할 수 있을까
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;투자자는 투자를 통해 자산의 장기적인 안정적인 가치 증식을 목표로 해야 하며, 단기간에 부자가 되는 것이 아니라는 점을 명확히 인식해야 합니다. 투자 지식을 습득하고 시장 원리를 이해하며, 가치 투자와 장기 투자의 개념을 확립하여 단기적인 이익과 시장 심리에 휘둘리지 않도록 해야 합니다. 예를 들어, 기업의 펀더멘털을 깊이 있게 연구하고 수익성, 산업적 위상, 경영진 등 요소를 중시하며 장기적인 투자 가치가 있는 주식을 선택하는 것이며, 무분별하게 단기적인 인기주를 쫓는 것을 피해야 합니다.&lt;/li&gt;
&lt;li&gt;합리적인 투자 계획 수립: 자신의 재정 상황, 위험 감내 능력 및 투자 목표에 따라 과학적이고 합리적인 투자 계획을 세웁니다. 투자 금액, 투자 기간, 예상 수익 및 손절점과 같은 주요 요소를 명확히 하고 계획에 엄격하게 따라야 합니다. 이렇게 하면 투자 과정에서 감정 변화로 인한 충동적인 결정을 피할 수 있습니다. 예를 들어 각 주식의 투자 비율을 총 자산의 일정 비율 이상으로 설정하지 않도록 하고, 주가가 상승하여 예상 수익에 도달하면 즉시 이익을 실현하고, 하락이 손절점에 닿으면 단호하게 손실을 제한합니다.&lt;/li&gt;
&lt;li&gt;감정을 조절하고 침착함을 유지하세요: 시장의 변동에 직면했을 때 자신의 감정을 통제하고 침착함과 이성적인 판단을 유지하는 것이 중요합니다. 주의를 분산시키거나, 운동을 하거나, 다른 사람들과 소통하는 등의 방법으로 투자 스트레스를 완화하여 감정이 투자 결정에 부정적인 영향을 미치지 않도록 해야 합니다. 시장이 크게 변동할 때는 먼저 원인을 침착하게 분석하고 자신의 투자 전략과 주식의 기본적 상황을 고려하여 합리적인 판단을 내려야 하며, 맹목적으로 추세에 따르거나 공포로 인해 매도하는 것을 피해야 합니다.&lt;/li&gt;
&lt;li&gt;지속적인 학습과 반성: 주식 시장은 끊임없이 발전하고 변화하기 때문에 투자자는 새로운 투자 지식과 기술을 지속적으로 습득하고 거시 경제 동향, 산업 뉴스 및 회사 정보 등에 관심을 기울여 자신의 투자 수준을 꾸준히 향상시켜야 합니다. 동시에 정기적으로 자신의 투자 행위를 되돌아보고 경험과 교훈을 정리하며 마음가짐과 의사 결정에 존재하는 문제점을 발견하고 즉시 조정하고 개선해야 합니다. 예를 들어, 투자를 마칠 때마다 전체 투자 과정을 검토하고 성공과 실패 원인을 분석하여 앞으로의 투자에서 유사한 실수를 피할 수 있는 방법을 모색합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;주식 투자와 재테크는 길고 도전적인 여정이며, 마음가짐이 그중에서 가장 중요한 역할을 합니다. 합리적이고 침착하며 겸손하고 독립적으로 사고하는 마음가짐을 유지해야만 주식 시장의 파도 속에서 굳건히 나아가며 자산 가치를 보존하고 증대시킬 수 있습니다. 투자자는 마음가짐을 연마하는 것을 투자 과정에서 필수적인 과제로 삼아, 좋은 마음가짐으로 부를 이끌고 주식 투자와 재테크의 길에서 안정적으로 목표를 달성해야 합니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>세월이 쌓여 내린 독특한 환상과 애착</title>
        <link>https://ttf248.life/ko/p/years-of-settling-alternative-fantasy-and-emotional-attachment/</link>
        <pubDate>Thu, 13 Feb 2025 22:12:57 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/years-of-settling-alternative-fantasy-and-emotional-attachment/</guid>
        <description>&lt;p&gt;초창기 웹소설 독자들이 중년에 접어들면서 그들을 위한 판타지 소설도 변화했다. 주인공은 주로 아버지, 스승, 혹은 노인으로 등장하며, 중년 독자들이 삶과 감정에 대해 느끼는 다른 요구를 반영한다. 이러한 작품들은 더 이상 레벨 업과 역전만을 추구하는 것이 아니라 감정적 공감대와 인생에 대한 깨달음을 강조하는 경향이 있다.&lt;/p&gt;
&lt;h2 id=&#34;변화하는-독자층-시간의-흐름-속에서&#34;&gt;변화하는 독자층, 시간의 흐름 속에서
&lt;/h2&gt;&lt;p&gt;과거의 웹소설 독자들은 이제 대부분 중년에 접어들었다. 그들은 삶의 풍파를 겪으며 마음가짐과 가치관이 변화했다. 젊은 시절 열광했던 호쾌함이나 모험 등의 요소는 더 이상 유일한 추구가 아니게 되었고, 대신 현재 자신의 삶과 연결되는 감정적 공감대를 읽기를 원하며 과거에 대한 회상과 미래에 대한 기대를 찾는다. 중년층을 위한 힐링 웹소설은 바로 이러한 심리적 요구에서 비롯되어, 중년 사람들의 삶과 마음가짐에 더 가깝게 다가가는 에피소드를 통해 이 특정 독자층을 사로잡고 있다.&lt;/p&gt;
&lt;h2 id=&#34;인물-변화-청춘-영웅에서-중년의-책임자로&#34;&gt;인물 변화: 청춘 영웅에서 중년의 책임자로
&lt;/h2&gt;&lt;p&gt;내 제자들은 다 악당이다: 주 인물 陆州는 스승이 된 후, 각기 다른 성격과 강력한 실력을 가진 제자들을 마주한다. 그들은 선과 악 사이에서 방황하고, 陆州는 그들을 올바른 길로 인도해야 한다. 이 소설은 주인공과 제자들 간의 상호 작용을 통해 다음 세대를 가르칠 때 중년인들이 직면하는 도전과 고뇌를 보여준다. 동시에 제자들의 성장과 변화는 독자들에게 희망과 미래를 제시하며, 자신들의 자녀나 젊은 세대에 대한 기대를 보게 한다.&lt;/p&gt;
&lt;h2 id=&#34;감정적-공명-삶에-대한-깨달음과-가족의-책임&#34;&gt;감정적 공명: 삶에 대한 깨달음과 가족의 책임
&lt;/h2&gt;&lt;p&gt;60세 생일 때 시스템을 얻게 된 주인공은 새로운 삶의 여정을 시작한다. 이 설정은 중년 독자들이 “늦지 않았다”는 희망과 동기 부여를 느끼게 한다. 비록 노년에 이르렀지만, 주인공은 시스템을 통해 자신의 가치와 꿈을 실현할 수 있다. 이러한 이야기는 독자들에게 인생에서 놓친 기회와 이루지 못한 꿈을 떠올리게 하며, 긍정적인 삶의 태도를 전달하고 어떤 나이에도 포기하지 않고 추구하라고 격려한다.&lt;/p&gt;
&lt;h2 id=&#34;줄거리-구성-중년-삶의-리듬과-재미를-살린다&#34;&gt;줄거리 구성: 중년 삶의 리듬과 재미를 살린다
&lt;/h2&gt;&lt;p&gt;중년 爽文의 줄거리 구성은 종종 삶의 디테일과 감정의 섬세한 표현을 더욱 중시한다. 젊었을 때의 爽文처럼 빠른 속도의 레벨 업과 모험을 추구하기보다는 인물 간의 관계와 감정적 갈등에 더 집중하는 것이다. 예를 들어, 《史上最强师傅》에서 주인공과 제자 사이의 사제간의 우정, 동문들 사이의 형제의 연대감 등이 세밀하게 묘사되어 있다. 이러한 줄거리 구성은 중년 독자들이 따뜻함과 친근함을 느낄 수 있게 하며, 자신의 삶 속에서 경험하는 가족애, 우정, 사랑을 보는 듯한 느낌을 준다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>설날 영화 티켓 가격의 비밀: 온라인과 오프라인 가격 차이</title>
        <link>https://ttf248.life/ko/p/spring-festival-movie-tickets-price-mystery-online-vs-offline/</link>
        <pubDate>Tue, 11 Feb 2025 00:02:02 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/spring-festival-movie-tickets-price-mystery-online-vs-offline/</guid>
        <description>&lt;p&gt;설날 동안 가족(일곱 여덟 명)이 영화를 보러 가려고 했는데, 타오티아오와 마오옌에서 표를 사려 했더니 가격이 60원이었어요. 그런데 우연히 극장 충전 카드가 있어서, 직접 극장에 가서 계산대에서 구매해야 하고, 혹시 할인하는지 물어보자고 생각했죠. 그랬는데, 같은 영화인데 계산대에서는 35원에 팔더라고요. 이 가격 차에 정말 놀랐습니다.&lt;/p&gt;
&lt;h2 id=&#34;플랫폼-서비스-수수료의-숨겨진-할증&#34;&gt;플랫폼 서비스 수수료의 “숨겨진 할증”
&lt;/h2&gt;&lt;p&gt;온라인 티켓 구매 플랫폼은 편리하지만, 플랫폼 서비스 수수료는 무시할 수 없습니다. 이들은 정밀 좌석 선택, 언제든지 구매 기록 확인 등 사용자를 위한 편리한 구매 경험을 제공하는데, 이러한 기능들을 유지하려면 자금이 필요합니다. 그리고 이러한 비용은 플랫폼 서비스 수수료 형태로 티켓 가격에 추가되어 온라인 티켓 가격 상승을 초래합니다.&lt;/p&gt;
&lt;h2 id=&#34;영화관-차별화-운영-전략&#34;&gt;영화관 차별화 운영 전략
&lt;/h2&gt;&lt;p&gt;설 명절 기간 영화 관람 수요가 폭발적으로 증가하면서, 극장들은 수익을 최대화하기 위해 차등 가격 정책을 채택하고 있습니다. 온라인 플랫폼의 트래픽이 많아 많은 사람들이 미리 온라인으로 티켓을 구매하는 것에 익숙해졌기 때문에, 극장은 온라인 티켓 가격을 다소 높게 책정합니다. 반면 현장에서 직접 구매하는 손님들을 유치하기 위해 낮은 가격을 제시합니다.&lt;/p&gt;
&lt;h2 id=&#34;협력-분배-뒤에-숨겨진-가격-논리&#34;&gt;협력 분배 뒤에 숨겨진 가격 논리
&lt;/h2&gt;&lt;p&gt;온라인 플랫폼과 영화관의 협력 분배 방식이 티켓 가격에 영향을 미칩니다. 온라인 플랫폼은 박스오피스 수익에서 몫을 가져가기 위해 이익을 보장하기 위해 티켓 가격을 높입니다. 반면, 영화관 현장에서 직접 판매하는 경우에는 중간 과정이 없어 비용이 줄어들고 자연스럽게 티켓 가격이 저렴해집니다.&lt;/p&gt;
&lt;h2 id=&#34;소비자-구매-팁&#34;&gt;소비자 구매 팁
&lt;/h2&gt;&lt;p&gt;소비자들은 앞으로 영화 티켓을 살 때 온라인 플랫폼만 보지 말고, 전화해서 극장 안내 데스크에 가격을 물어보거나 직접 방문해서 문의해 보세요. 혹시 모를 혜택이 있을지도 몰라요. 자주 영화를 본다면 극장 회원 카드를 만들어 멤버십 혜택을 누리면 돈도 많이 절약할 수 있습니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>2025년 춘절 영화 속 정치 요소 분석</title>
        <link>https://ttf248.life/ko/p/political-elements-in-chinese-new-year-films-2025/</link>
        <pubDate>Mon, 10 Feb 2025 23:49:42 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/political-elements-in-chinese-new-year-films-2025/</guid>
        <description>&lt;p&gt;오랜만에 춘절 영화 보러 갔는데, 이번에는 두 편 보고 느낌이 좀 달랐다&lt;/p&gt;
&lt;p&gt;이 글은 2025년 설날 극장 영화의 새로운 변화를 탐구하며, 특히 《탐정 강림촌 1900》과 《哪吒之魔童闹海》에 초점을 맞추고 있습니다. 전자는 1900년 미국 샌프란시스코 차이나타운을 배경으로 하여 화교들이 인종차별과 압박을 받는 모습을 보여주며 사회 정치적 환경을 반영하고, 후자는 애니메이션 영화로서 풍부한 은유적 요소를 통해 현실 국제 정치 지형을 비판합니다. 예를 들어, 여의궁은 펜타곤을 연상시켜 미국 정치 체제를 풍자하고, 천원정 위에 있는 달러 기호는 달러 패권을 상징하며, 신선옥패는 미국 그린카드를 암시하여 신분 계층을 나타내고, 묵혼단은 생화학 무기를 연상시켜 악의적인 행위를 비판합니다. 두 영화는 새로운 관람 경험을 선사하고 영화 예술과 정치적 표현 간의 관계에 대한 성찰을 불러일으킵니다.&lt;/p&gt;
&lt;h2 id=&#34;설날-영화-스타일의-혁신&#34;&gt;설날 영화 스타일의 혁신
&lt;/h2&gt;&lt;p&gt;지난해 설맞이 영화는 주로 가볍고 즐거운 오락, 가족들과 함께 즐기는 스타일로 관객들이 명절에 몸과 마음을 편안하게 하도록 하는 데 중점을 두었고, 민감한 정치적 소재에는 거의 접근하지 않았다. 그러나 2025년 설맞이 영화는 기존 방식을 깨고 《탐정 강해설: 1900》과 《나저전: 모천의 소동》이 풍부한 정치적 요소를 담아내면서 관객들의 폭넓은 토론을 불러일으키고, 설맞이 영화에 새로운 분위기를 가져왔다.&lt;/p&gt;
&lt;h2 id=&#34;시대-정치의-생생한-반영&#34;&gt;시대 정치의 생생한 반영
&lt;/h2&gt;&lt;p&gt;《당인街 探案1900》은 1900년 미국 샌프란시스코 차이나타운을 배경으로, 당시 화교들이 해외에서 심각한 인종차별과 억압을 받던 시대를 그립니다. 주인공들은 사건을 해결하는 동시에 사회 각계층의 차별과 불공정한 대우에 맞서 싸워야 합니다. 이 영화는 인종차별과 권력 다툼을 사실적으로 보여주며 당시의 사회 정치적 환경을 반영하고 있습니다. 이는 우리에게 격동의 시대에 화교들이 생존과 존엄을 위해 벌였던 힘겨운 투쟁을 보게 하고, 그 배경에는 깊이 생각해 볼 만한 정치적인 문제들이 있음을 보여줍니다.&lt;/p&gt;
&lt;p&gt;이러한 역사적 배경은 현재 해외 화교들이 상업 분야에서 겪고 있는 어려움, 예를 들어 TikTok과 주수자 사건을 떠올리지 않을 수 없다&lt;/p&gt;
&lt;p&gt;현지시간으로 2024년 12월 6일, 미국 워싱턴 D.C. 연방항소법원이 TikTok의 요청을 기각하고 국가 안보를 명분으로 제정된 강제 매각 법안이 헌법적 심사를 통과했다고 판결했습니다. TikTok CEO 주수즈는 직원들에게 보낸 메모에서 “금지 명령을 구하고 미국 대법원의 심리를 기다릴 것”이라고 밝혔습니다. 이 사건의 발단은 미국의 ‘미국인의 외국 적대 세력으로부터 보호를 위한 법’으로, 바이트댄스는 법안 통과 후 270일 내에 미국 TikTok 사업을 매각해야 하며, 강제 매각 최종 기한은 2025년 1월 19일입니다.&lt;/p&gt;
&lt;p&gt;이전에 여러 청문회에서 주쉬쯔 또한 많은 모욕을 받았습니다. 현지시간 2024년 1월 31일, 미국 의회 상원 법사위원회는 “대형 기술 기업과 온라인 아동 성착취 위기” 청문회를 개최했고, 유명한 반중 의원 톰 코튼은 주쉬쯔에게 연이어 8개의 국적 관련 질문을 던졌습니다. 그가 어느 나라 사람인지, 중국 국적이나 미국 국적을 신청한 적이 있는지 등을 물으며 심지어 그의 아내와 자녀의 국적까지 놓치지 않았습니다. 분명히 청문회 주제는 “온라인 아동 성착취”였지만, 의원은 화제를 TikTok이 중국 기업 바이트댄스 소유라는 점으로 돌려 주쉬쯔에게 주제와 무관한 질문을 하도록 했습니다. 영화 ‘덩타이 스트리트의 살인자 1900’에서 중국인이 해외에서 정당하지 못한 차별을 받는 것처럼, 주쉬쯔 또한 TikTok의 배경 때문에 상업 분야에서 부당한 대우와 의심을 받고 있습니다. 이러한 일련의 사건은 시대마다 해외 화교들이 자신의 발전과 권리 보호를 추구할 때 외부로부터 겪는 어려움에 직면한다는 점을 반영하며, 100년 전의 인종 차별이든 현재의 상업적 정치 공작이든 간에 우리에게 깊이 성찰해야 할 문제입니다.&lt;/p&gt;
&lt;h2 id=&#34;哪吒之魔童闹海에-숨겨진-정치적-은유-분석&#34;&gt;《哪吒之魔童闹海》에 숨겨진 정치적 은유 분석
&lt;/h2&gt;&lt;p&gt;《哪吒之魔童闹海》는 겉보기에는 평범한 애니메이션 영화처럼 보이지만, 여러 설정과 줄거리에 정치적 은유가 담겨 있다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;권력 체계의 반영&lt;/strong&gt;: 여호궁은 도교 세계 최고 권력 중심지로 묘사되었으며, 건축 양식은 미국의 국방부 건물과 유사하고 내부적으로는 흰색을 주조로 사용하여 서방이 “보편적 가치”를 내세워 헤게모니즘을 추구하는 것을 상징합니다. 무량선옹이 이끄는 “요괴 퇴치팀”의 부하인 록남학녀는 미국 동맹 체계에서 일본과 한국에 대응한다고 여겨집니다. 여호궁의 “온라인 회의” 장면, 즉 십이금신이 모여 “봉신대전”을 논의하는 모습은 미국의 주도 하에 운영되는 NATO 회의와 같으며, “질서 유지”를 명분으로 다른 나라를 억압합니다.&lt;/li&gt;
&lt;li&gt;경제 횡포의 암시: 여무궁에서 단을 연단하는 데 사용된 천원도에는 달러 기호가 새겨져 있으며, 이는 미국이 경제 횡포로 타국의 자원을 ‘연금’한다는 것을 비유적으로 보여준다. 영화 속 무량선옹은 “대신 행도”라는 이름으로 용족을 가마솥에 던져 연단하며, 마치 특정 국가들이 ‘국제 규칙’을 빌려 이익을 추구하는 것과 같다.&lt;/li&gt;
&lt;li&gt;신분과 계급의 은유: 나찰이 얻은 신선 신분을 상징하는 부적은 색상과 문양 디자인이 미국의 그린카드와 매우 흡사하여, 천상의 “타인”에 대한 배척과 계급 차별을 상징하며 현실에서 국가나 집단 간의 신분 차이와 불평등한 대우를 암시한다&lt;/li&gt;
&lt;li&gt;악행에 대한 암시: 무량선옹이 나차에게 강제로 먹인 멸혼단은 생화무기와 흡사하며, 이는 특정 국가들이 ‘구원’이라는 이름으로 파괴와 다른 나라의 멸망을 초래하는 행태를 비판하는 것이다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;자원과 발전의 상징&lt;/strong&gt;: 일곱 빛깔 보련은 중시조성(重塑)하는 나찰아와 오병(敖丙)의 육신에 있어 핵심적인 역할을 하며, 대국이 독점하는 에너지와 기술의 생명선을 상징한다. “정수옥액(瓊漿玉液)”은 여우궁(玉虛宮)의 “성仙 시험”을 통해 획득해야 하는데, 이는 현실에서 발전도국이 핵심 자원에 대한 의존과 패권 체제 하에서 겪는 “규칙적 약탈”을 반영한다. 보련의 일시적인 무효화와 회복 조건은 에너지 위기 하에서 소국의 생존 고난을 암시한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;영화-예술과-정치적-표현에-대한-심층적인-고찰&#34;&gt;영화 예술과 정치적 표현에 대한 심층적인 고찰
&lt;/h2&gt;&lt;p&gt;이 두 편의 영화는 춘절 기간 전 국민 관람 열풍 속에서 정치적 요소를 녹여내 관객들에게 새로운 관람 경험을 선사하며, 단순한 오락 작품이 아닌 역사와 현실 속 정치 문제를 비추는 거울과 같은 존재가 되었습니다. 이는 우리가 영화 예술과 정치적 표현의 관계에 대한 깊이 있는 성찰을 하게 만들었습니다. 앞으로 영화 창작에서 감독들이 영화를 통해 사회 및 정치에 대한 견해를 더 많이 전달하게 될까요? 영화라는 강력한 문화 전파 매체가 예술적 표현과 함께 사회 현실에 대한 더 많은 관심과 고찰을 담당할 수 있을까요? 이러한 질문들은 우리가 영화를 감상하면서 깊이 있게 탐구해야 할 문제이며, 또한 영화 산업계가 예술과 현실의 융합 측면에서 더욱 다채로운 즐거움을 선사하기를 기대합니다.&lt;/p&gt;
&lt;h2 id=&#34;이스터-에그&#34;&gt;이스터 에그
&lt;/h2&gt;&lt;p&gt;두부 대형 모델, 오늘 잘 안 되는 것 같아. 계속 멈춰서 글이 반쯤 나왔는데 멈춰버렸어. 다시 새 세션을 열어야 해.&lt;/p&gt;</description>
        </item>
        <item>
        <title>미국의 두 주요 정당—민주당과 공화당</title>
        <link>https://ttf248.life/ko/p/us-two-major-parties-democrats-republicans/</link>
        <pubDate>Mon, 10 Feb 2025 23:40:04 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/us-two-major-parties-democrats-republicans/</guid>
        <description>&lt;p&gt;민주당과 공화당은 정치적 이념, 정책 주창 및 사회적 가치관 측면에서 뚜렷한 차이를 보인다&lt;/p&gt;
&lt;h2 id=&#34;정치-이념과-정책-주장&#34;&gt;정치 이념과 정책 주장
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;민주당은 진보 성향을 지향하며, 정부가 경제 및 사회 문제에서 적극적인 역할을 할 것을 주장하고, 사회 복지, 환경 보호, 다문화주의를 지지합니다. 세금 정책에 있어서 민주당은 중저소득층의 감세와 함께 고소득자 및 기업의 세율 인상을 지지합니다. 사회 문제에 있어 낙태 권리, 동성 결혼을 지지하며 엄격한 총기 규제를 옹호합니다. 외교 정책에 있어서는 다자주의와 외교적 수단을 강조하며 국제 협력을 통해 세계적인 문제를 해결하는 경향이 있습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;공화당은 보수 성향을 띠며 정부의 간섭을 제한하고 개인의 자유와 시장 경제를 강조합니다. 세금 정책에 있어서는 감세를 지지하며, 소득 수준과 관계없이 모든 사람에게 적용되어야 한다고 생각합니다. 사회 문제에 대해서는 낙태와 동성 결혼에 반대하고 총기 소유권을 옹호합니다. 외교 정책에 있어서는 강경한 입장을 취하며 군사력을 통해 국가의 이익을 보호하는 것을 지지합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;트럼프의-당선-의미&#34;&gt;트럼프의 당선 의미
&lt;/h2&gt;&lt;p&gt;도널드 트럼프가 2024년 미국 대통령에 재선되면서 공화당이 미국의 정치에서 주도적인 위치를 차지하게 되었다. 트럼프의 정책은 다음과 같다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;경제 정책: 트럼프는 감세와 규제 완화를 통해 경제 성장을 촉진하고, 특히 전통 제조업과 에너지 산업 발전을 지지합니다. 그는 또한 미국의 경제적 이익을 보호하기 위해 기존 무역 협상을 재협상하거나 철회하는 보호무역 정책을 선호합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이민 정책: 트럼프는 국경 보안을 강화하고 불법 이민을 제한하며 합법 이민에 대해 더 엄격한 심사와 제한을 시행할 계획입니다. 그는 또한 국가 안보를 유지하기 위해 난민 및 망명 신청을 제한하는 것을 지지합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;외교 정책: 트럼프는 독자주의를 선호하며 “미국 우선”을 강조하고 국제 기구에 대한 의존도를 줄이고 동맹 관계를 재평가하며 필요할 경우 보다 강경한 외교적 수단을 취합니다. 또한 그는 화석 연료 생산 및 사용을 확대하고 환경 보호 규제를 완화할 계획입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;트럼프의 재선은 미국 국내 정책에 중대한 변화를 초래하고 전 세계 정치 및 경제에 광범위한 영향을 미칠 가능성이 있습니다. 그의 정책은 특히 무역, 환경 및 인권 분야에서 국제 사회의 관심과 반응을 불러일으킬 수 있습니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>올라마에 deepseek-R1 로컬 배포</title>
        <link>https://ttf248.life/ko/p/ollama-local-deployment-deepseek-r1/</link>
        <pubDate>Fri, 07 Feb 2025 22:41:02 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/ollama-local-deployment-deepseek-r1/</guid>
        <description>&lt;p&gt;Ollama는 사용자가 로컬에서 대규모 언어 모델(LLM)을 실행하고 배포할 수 있도록 하는 오픈 소스 AI 도구입니다. 이 도구의 목표는 개발자가 클라우드 서비스에 의존하지 않고도 GPT와 같은 모델을 로컬 머신에서 편리하고 효율적으로 사용할 수 있는 방법을 제공하는 것입니다. Ollama는 다양한 모델을 지원하며 성능 최적화에 중점을 두어 리소스가 제한된 장치에서도 이러한 모델을 원활하게 실행할 수 있도록 합니다.&lt;/p&gt;
&lt;p&gt;올라마를 통해 사용자는 텍스트 기반의 AI 애플리케이션을 사용할 수 있으며, 데이터 개인 정보나 높은 API 사용 비용 걱정 없이 로컬에 배포된 모델과 상호 작용할 수 있습니다. 다양한 모델을 명령줄 인터페이스(CLI)를 통해 호출하여 자연어 처리, 질의 응답 등의 작업을 수행할 수 있습니다.&lt;/p&gt;
&lt;p&gt;올라마는 다양한 모델을 시험해 보기에 적합하지만, 윈도우 버전으로 테스트해 보니 하드웨어 성능을 충분히 활용하지 못하는 듯합니다. 아마 윈도우 버전 때문일 수도 있고, 리눅스 버전이 더 나을 수도 있습니다. 32b 파라미터 모델을 배포했을 때 메모리나 그래픽 카드 사용량이 높지 않음에도 불구하고 응답 속도가 매우 느립니다.&lt;/p&gt;
&lt;h2 id=&#34;하드웨어-개요&#34;&gt;하드웨어 개요
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;운영체제: win11&lt;/li&gt;
&lt;li&gt;CPU：i7-10700K&lt;/li&gt;
&lt;li&gt;메모리: 40GB&lt;/li&gt;
&lt;li&gt;그래픽 카드: RTX 3060 12GB&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;환경-준비&#34;&gt;환경 준비
&lt;/h2&gt;&lt;p&gt;새로운 시스템 환경 변수를 추가하여 향후 사용을 용이하게 합니다&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;set OLLAMA_MODELS=E:\ollama&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
이 변수는 Ollama 모델이 저장될 경로를 지정합니다. &lt;code&gt;E:\ollama&lt;/code&gt;는 모든 로컬 모델 파일이 해당 디렉터리에 저장되어 있음을 나타내는 폴더 경로입니다. Ollama는 이 경로를 기준으로 다운로드하거나 배포한 언어 모델을 로드하고 사용합니다. 모델 파일을 다른 위치에 저장하려면 이 경로만 변경하면 됩니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;set OLLAMA_HOST=127.0.0.1:8000&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
이 환경 변수는 Ollama 서비스의 호스트와 포트를 설정합니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;127.0.0.1&lt;/code&gt;은 로컬 주소(localhost)이며, Ollama 서비스는 로컬에서 온 요청만 수신합니다&lt;/li&gt;
&lt;li&gt;8000은 지정된 포트 번호이며, Ollama 서비스가 8000번 포트에서 요청을 기다리고 처리할 것임을 나타냅니다. 필요에 따라 포트 번호를 변경할 수 있지만, 해당 포트가 다른 애플리케이션에서 사용 중인지 확인해야 합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;set OLLAMA_ORIGINS=*&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
이 환경 변수는 Ollama 서비스에 접근할 수 있는 요청의 출처를 제어합니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;는 모든 소스(즉, 모든 도메인 및 IP 주소)에서 Ollama 서비스에 액세스할 수 있도록 허용합니다. 이는 일반적으로 개발 및 디버깅 환경에서 사용되며, 프로덕션 환경에서는 더 엄격한 소스 제어를 지정하여 특정 도메인 또는 IP만 서비스를 액세스하도록 제한하여 보안을 강화하는 것이 일반적입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;딥시크-r1-모델-배포&#34;&gt;딥시크-R1 모델 배포
&lt;/h2&gt;&lt;p&gt;올라마 설치는 간단하니 자세한 설명은 생략하겠습니다&lt;/p&gt;
&lt;p&gt;설치 후 검증:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\core&amp;gt;ollama -v
ollama version is 0.5.11
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;모델 배포는 공식 모델 페이지를 참조하여 해당 매개변수가 있는 모델을 선택합니다: &lt;code&gt;ollama run deepseek-r1:14b&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;14b 파라미터는 대화 컨텍스트를 효과적으로 기억할 수 있지만, 더 작은 파라미터 버전은 그렇지 못합니다. 32b 파라미터 버전은 로컬에서 실행하면 매우 느려서 더 이상 테스트하지 않았습니다.&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.ollama.com/library/deepseek-r1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.ollama.com/library/deepseek-r1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://mp.weixin.qq.com/s/SPEvYTmTBxhoEkJqm1yPmw&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mp.weixin.qq.com/s/SPEvYTmTBxhoEkJqm1yPmw&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/x18990027/article/details/145368094&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/x18990027/article/details/145368094&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>파워셸 7과 지속 가능한 설정 명령줄 예측 보기</title>
        <link>https://ttf248.life/ko/p/powershell-7-persisting-settings-command-line-prediction-view/</link>
        <pubDate>Fri, 07 Feb 2025 22:19:12 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/powershell-7-persisting-settings-command-line-prediction-view/</guid>
        <description>&lt;p&gt;Linux에서 zsh를 사용하다가, 이틀 전 블로그를 쓰다가 PowerShell 7도 영구적인 설정으로 명령줄 예측 보기를 지원하는 것을 발견해서 한번 시켜봤는데, 꽤 괜찮게 잘 된다&lt;/p&gt;
&lt;p&gt;어떻게든 뭔가를 했는데, 이 기능이 켜진 것 같아. 그냥 있는 거다.&lt;/p&gt;
&lt;p&gt;오늘날 다양화된 운영체제 환경에서 시스템 관리자와 개발자들은 플랫폼 간 호환성, 효율성 및 강력한 기능을 갖춘 도구를 찾아 시스템 관리 및 자동화 작업에 대한 요구를 충족하고자 합니다. PowerShell 7은 바로 이러한 주목을 받는 도구 중 하나로, 강력한 스크립팅 기능뿐만 아니라 Windows, Linux 및 macOS와 같은 다양한 운영체제에서 실행될 수 있어 사용자에게 전례 없는 편의성을 제공합니다.&lt;/p&gt;
&lt;h2 id=&#34;파워셸-7-강력한-크로스-플랫폼-도구&#34;&gt;파워셸 7: 강력한 크로스 플랫폼 도구
&lt;/h2&gt;&lt;h3 id=&#34;플랫폼-간-호환성&#34;&gt;플랫폼 간 호환성
&lt;/h3&gt;&lt;p&gt;파워셸 7은 플랫폼의 제약을 깨뜨려 Windows 시스템에서 기업용 서버 관리를 하든, Linux 환경에서 시스템 운영을 하든, macOS에서 일상적인 개발 작업을 하든, 사용자는 통일된 파워셸 7 도구를 사용할 수 있습니다. 이는 업무 효율성을 크게 향상시키고 플랫폼 차이로 인한 학습 비용과 작업 복잡성을 줄입니다.&lt;/p&gt;
&lt;h3 id=&#34;강력한-기능&#34;&gt;강력한 기능
&lt;/h3&gt;&lt;p&gt;스크립트 작성 능력이 뛰어나며 객체 지향 프로그래밍, 함수, 모듈과 같은 고급 프로그래밍 기능을 지원합니다. PowerShell 7을 통해 사용자는 파일 시스템을 쉽게 조작하여 파일 및 폴더를 생성, 삭제, 복사, 이동할 수 있습니다. 또한 레지스트리를 액세스하고 수정하여 시스템 구성을 심층적으로 조정할 수 있으며 프로세스와 서비스를 관리하여 시스템 실행 상태를 효과적으로 모니터링하고 제어할 수 있습니다. 게다가 PowerShell 7은 Active Directory에서 사용자 및 권한 관리를 포함하여 Windows 및 비 Windows 기술과 상호 작용할 수 있으며 Azure 클라우드 플랫폼에서 리소스 할당 및 관리를 수행할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;오픈소스-생태계&#34;&gt;오픈소스 생태계
&lt;/h3&gt;&lt;p&gt;PowerShell 7은 오픈 소스이며, 이러한 특징으로 인해 전 세계 개발자와 애호가들이 적극적으로 개발과 개선에 참여할 수 있습니다. 많은 오픈 소스 모듈과 도구가 끊임없이 등장하여 PowerShell 7의 기능과 적용 분야를 풍부하게 합니다. 사용자는 자신의 필요에 따라 오픈 소스 커뮤니티에서 적합한 모듈을 찾아 PowerShell 7 기능을 확장하거나, 자신의 코드를 기여하여 전체 커뮤니티 발전에 기여할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;호환성-및-안정성&#34;&gt;호환성 및 안정성
&lt;/h3&gt;&lt;p&gt;PowerShell 7은 이전 버전의 PowerShell과의 호환성을 유지하면서도 많은 새로운 기능과 개선 사항을 도입했습니다. 이러한 개선 사항은 성능 향상뿐만 아니라 안정성도 강화하여 사용자가 다양한 작업을 더욱 원활하게 완료하고 소프트웨어 오류로 인한 작업 중단을 줄일 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;명령줄-예측-뷰-열기&#34;&gt;명령줄 예측 뷰 열기
&lt;/h2&gt;&lt;p&gt;파워셸 7의 다양한 유용한 기능 중, &lt;code&gt;Set-PSReadLineOption -PredictionViewStyle ListView&lt;/code&gt; 명령은 사용자 명령줄 입력 경험을 향상시키는 실용적인 도구입니다&lt;/p&gt;
&lt;p&gt;명령을 활성화하지 않아도 자동 완성 기능을 사용할 수 있지만, 이는 현재 줄 내에서의 자동 완성에만 해당됩니다. 명령을 활성화하면 예측 뷰가 표시되고, 가능한 모든 자동 완성 옵션이 목록 형태로 나타납니다. 사용자는 위아래 화살표 키를 사용하여 필요한 옵션을 선택할 수 있으며, 이를 통해 명령 입력의 정확성과 효율성을 높일 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/powershell-7-persisting-settings-command-line-prediction-view/20250207222546.png&#34;
	width=&#34;814&#34;
	height=&#34;205&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;powershell7&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;397&#34;
		data-flex-basis=&#34;952px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;명령을-지속적으로-적용하는-방법&#34;&gt;명령을 지속적으로 적용하는 방법
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Set-PSReadLineOption -PredictionViewStyle ListView&lt;/code&gt; 명령어를 매번 PowerShell을 시작할 때 적용되도록 하려면, PowerShell 프로필 파일에 추가할 수 있습니다. PowerShell 프로필 파일은 PowerShell이 시작될 때 자동으로 실행되는 특수한 스크립트입니다.&lt;/p&gt;
&lt;h3 id=&#34;설정-파일-경로-확인&#34;&gt;설정 파일 경로 확인
&lt;/h3&gt;&lt;p&gt;파워셸에서 우리는 &lt;code&gt;$PROFILE&lt;/code&gt; 변수를 사용하여 구성 파일의 경로를 확인할 수 있습니다. 해당 경로에 파일이 없으면 사용자가 직접 생성할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo $PROFILE
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;설정-파일을-엽니다&#34;&gt;설정 파일을 엽니다
&lt;/h3&gt;&lt;p&gt;기능이 강력한 메모장++나 가벼운 Visual Studio Code와 같은 텍스트 편집기를 사용하여 &lt;code&gt;$PROFILE&lt;/code&gt; 변수를 통해 얻은 구성 파일 경로에 해당하는 파일을 엽니다&lt;/p&gt;
&lt;h3 id=&#34;추가-명령&#34;&gt;추가 명령
&lt;/h3&gt;&lt;p&gt;열려 있는 설정 파일에 &lt;code&gt;Set-PSReadLineOption -PredictionViewStyle ListView&lt;/code&gt; 명령을 추가합니다. 명령이 정확하게 작성되었는지 확인하여 설정 파일이 실행될 때 제대로 적용되도록 합니다.&lt;/p&gt;
&lt;h3 id=&#34;구성-파일-저장&#34;&gt;구성 파일 저장
&lt;/h3&gt;&lt;p&gt;명령이 추가된 후에는 구성 파일을 저장하고 텍스트 편집기를 닫습니다. 이제 구성 파일에는 PowerShell을 시작할 때마다 실행하려는 명령이 포함되어 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;검증-설정&#34;&gt;검증 설정
&lt;/h3&gt;&lt;p&gt;현재 PowerShell 창을 닫은 다음 PowerShell을 다시 시작합니다. 새로 시작된 PowerShell에서 명령어를 입력할 때, 명령줄 입력 예측 보기 스타일이 목록 보기 형태로 표시되어야 하는데, 이는 우리의 설정이 성공적으로 적용되었다는 것을 의미합니다.&lt;/p&gt;
&lt;p&gt;위 단계를 통해 우리는 PowerShell 7의 강력한 기능과 특징을 깊이 있게 이해했을 뿐만 아니라, 명령줄 입력 예측 보기 스타일을 설정하여 작업 경험을 향상시키는 방법과 이러한 설정을 지속적으로 유지하는 방법을 익혔습니다. 이 지식이 PowerShell 7 사용 과정에서 더욱 능숙하게, 그리고 효율적으로 다양한 시스템 관리 및 자동화 작업을 수행하는 데 도움이 되기를 바랍니다.&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/PowerShell/PowerShell/releases&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/PowerShell/PowerShell/releases&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.v2ex.com/t/911909&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.v2ex.com/t/911909&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>딥시크 스프링 페스티벌 전 갑작스러운 인기, 엔비디아 주식 급락: 뒤에 숨은 기관의 움직임과 거대 모델 사고 체인</title>
        <link>https://ttf248.life/ko/p/deepseek-chinese-new-year-nvidia-stock-drop-institutional-operations-large-language-model-chain/</link>
        <pubDate>Fri, 07 Feb 2025 20:36:05 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/deepseek-chinese-new-year-nvidia-stock-drop-institutional-operations-large-language-model-chain/</guid>
        <description>&lt;p&gt;설 명절 직전, DeepSeek가 한 번의 화제로 주목받기 시작하며 며칠 만에 소셜 미디어에서 광범위한 관심을 끌었습니다. 이러한 갑작스러운 인기 폭발은 놀라울 뿐만 아니라 시장 전체에 연쇄적인 영향을 미쳤습니다. 동시에 엔비디아 주가는 급락했고, 많은 투자자들이 그 전망에 대해 의문을 품기 시작했으며, 일부 기관들은 이 기간 동안 대규모의 공매도 포지션을 취했습니다. 모든 상황이 마치 “계획된” 것처럼 보였습니다.&lt;/p&gt;
&lt;h3 id=&#34;딥시크의-폭발적인-인기-짧은-시간-내에-빠르게-주목받음&#34;&gt;딥시크의 폭발적인 인기: 짧은 시간 내에 빠르게 주목받음
&lt;/h3&gt;&lt;p&gt;DeepSeek는 AI 기반 도구로, 특히 자연어 처리(NLP) 및 이미지 생성 분야에서 딥 러닝 모델 최적화에 중점을 두고 있습니다. 설 명절 직전 며칠 동안 이 프로젝트는 갑자기 많은 투자자와 기술 전문가들의 관심을 받기 시작했습니다. 그 뒤에 있는 팀의 성과와 시연된 기술적 결과물은 많은 사람들에게 이 프로젝트에 대한 강한 관심을 불러일으켰습니다. 개발자 커뮤니티나 소셜 미디어 플랫폼에서든, DeepSeek에 대한 논의는 거의 기술계의 모든 화제를 장악했습니다.&lt;/p&gt;
&lt;p&gt;하지만 DeepSeek의 갑작스러운 인기 폭발은 우연이 아니다. 분석 결과, 많은 사람들이 이 뒤에 특정 기관의 개입이 있을 가능성을 의심하기 시작했다. 특히 인기가 폭발한 이후 엔비디아 주가가 뚜렷하게 하락했는데, 분명 어떤 요인들이 이러한 변화를 촉진하고 있는 것으로 보인다.&lt;/p&gt;
&lt;h3 id=&#34;엔비디아-주가-폭락-공매도-작전의-배후-세력&#34;&gt;엔비디아 주가 폭락: 공매도 작전의 배후 세력
&lt;/h3&gt;&lt;p&gt;엔비디아는 그래픽 처리 장치(GPU) 제조업체로서, 수많은 거대 모델과 AI 컴퓨팅의 핵심 하드웨어 공급업체였습니다. AI 시장이 빠르게 발전하면서 엔비디아 주식은 오랫동안 강세를 보였고 심지어 많은 투자자들의 선호 대상이 되기도 했습니다. 하지만 DeepSeek의 폭발적인 인기와 시장의 기술에 대한 높은 관심으로 인해 엔비디아 주가는 급락했습니다.&lt;/p&gt;
&lt;p&gt;이 현상 뒤에는 기관 투자자의 공매도 전략이 관련되어 있을 수도 있습니다. 지난 몇 년간 AI 기술의 보급과 함께 엔비디아 주가는 크게 상승했고, 많은 투자자들은 그 주가가 과도하게 부풀려졌다고 생각하기 시작했습니다. 특히 DeepSeek와 같은 기술이 폭발적으로 인기를 얻은 이후, 일부 기관들은 엔비디아 주식을 공매도하여 상당한 이익을 얻었을 가능성이 있습니다. 정확한 시장 시기 포착과 DeepSeek의 영향력에 대한 예측을 통해 이러한 기관들은 성공적으로 이익을 얻었습니다.&lt;/p&gt;
&lt;h3 id=&#34;대규모-모델-사고-체인의-접촉-결과에서-과정으로&#34;&gt;대규모 모델 사고 체인의 접촉: “결과”에서 “과정”으로
&lt;/h3&gt;&lt;p&gt;전통적인 인공지능 응용 분야에서 많은 실무자와 투자자들은 AI 모델의 “결과” — 예를 들어 생성된 이미지, 텍스트와 같은 직접적인 산출물에 더 많은 관심을 기울였습니다. 하지만 DeepSeek 관련 논의에서는 점점 더 많은 사람들이 대형 모델 뒤에 숨겨진 사고 과정이 더욱 주목할 가치가 있는 핵심 내용이라는 것을 깨닫기 시작했습니다. 과거에는 모델 출력 결과만 볼 수 있었지만, 이제는 그 뒤에 숨겨진 논리, 알고리즘과 이러한 요소를 조정하여 모델의 성능을 최적화하는 방법을 이해해야 합니다.&lt;/p&gt;
&lt;p&gt;이러한 사고방식의 전환은 AI 연구와 응용에 대한 심층적인 고찰인 동시에, 단순한 블랙박스 조작에서 모델 내부 작동 메커니즘을 진정으로 이해하는 것으로의 변화는 많은 기술 전문가와 투자자들이 인공지능의 미래 발전 방향을 다시 한번 검토하게 만들었습니다. DeepSeek의 인기 폭발은 바로 이러한 사고방식의 획기적인 응용이며, 사람들은 이제 최종 출력 결과뿐만 아니라 전체 모델 구축 및 최적화 과정에 주목하기 시작했습니다.&lt;/p&gt;
&lt;h3 id=&#34;요약&#34;&gt;요약
&lt;/h3&gt;&lt;p&gt;딥시크의 갑작스러운 인기, 엔비디아 주식의 폭락, 그리고 시장 뒤에 숨은 기관의 공매도 세력, 이 모든 현상 뒤에는 치밀하게 설계된 음모가 있는 듯합니다. 거대 언어 모델 사고 체인에 대한 깊이 있는 이해를 통해 AI 기술의 적용은 단순한 표면적 현상의 조합이 아니라 모델 내부 로직에 대한 심층적인 탐구와 최적화임을 알 수 있습니다. 기술 발전과 함께 앞으로 딥시크와 같은 혁신적인 도구가 더 많이 등장하여 AI 연구 및 응용을 더욱 높은 수준으로 발전시키는 것을 목격할 수도 있을 것입니다.&lt;/p&gt;
&lt;p&gt;이러한 현상은 인공지능 기술의 엄청난 잠재력을 보여주는 동시에, 기술 뒤에 숨겨진 상업적 경쟁과 자본 운용에 대해 생각하게 합니다. 앞으로 시장 추세는 기술과 자본 간의 경쟁이 지속적으로 초점이 될 것입니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>현대 화폐 이론이 세계 경제의 미래일까요?</title>
        <link>https://ttf248.life/ko/p/modern-monetary-theory-future-global-economy/</link>
        <pubDate>Thu, 06 Feb 2025 23:16:34 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/modern-monetary-theory-future-global-economy/</guid>
        <description>&lt;p&gt;미국 주식 시장의 지속적인 강세장은 미국의 ‘실질적인 힘’을 제외하고는 더 많은 부분에서 달러의 과도한 유통 때문입니다&lt;/p&gt;
&lt;p&gt;현대 화폐 체계는 &lt;strong&gt;2008년 금융 위기&lt;/strong&gt; 이후, 여러 경제체의 암묵적인 참고 모델이자 중요한 이론적 토대로 자리 잡았으며, 주요 특징은 정부의 시장 개입 시 주관적인 능동성을 더욱 강조하고, 정부 재정 적자를 주요 도구로 활용하여 시장의 완전 고용과 안정적인 물가를 동시에 달성하는 것이다&lt;/p&gt;
&lt;p&gt;대규모 정부는 &lt;strong&gt;케인스주의&lt;/strong&gt;를 더 잘 알고 있으며, 경기 순환에서 정부의 &lt;strong&gt;삭정충전(削峰填谷)&lt;/strong&gt; 역할, 예를 들어 과열 시 억제와 위축 시 자극을 강조합니다. 정부 지출의 승수 효과, 즉 동일한 금액의 통화가 소비 승수를 얼마나 증가시킬 수 있는지 매우 중요하게 생각하며, 정부 지출 1달러가 기업과 개인에게 1달러의 소득을 늘리고, 기업은 생산을 확대하여 고용을 늘리고, 개인은 소비를 확대하여 경기 침체를 막습니다. 동시에 재정 적자 상한 및 지속 가능성에 대해 상대적으로 보수적이며, &lt;strong&gt;소비 승수&lt;/strong&gt;는 시장 회복을 이끌어 정부 수입 증가로 이어질 것입니다. 특히 과열 주기 억제는 다음 주기를 위한 자극 모수를 축적할 수 있으며, 정부 부채 잠재력과 금리 수준 등이 이에 영향을 미칩니다.&lt;/p&gt;
&lt;p&gt;현대 화폐 시스템은 극단적인 케인스주의의 연장선상에 있지만, 가장 큰 특징은 정부 부채 제한 문제이며, 중앙은행은 독립성을 가져서는 안 되며, 주요 목표는 &lt;strong&gt;물가 상승과 완전 고용&lt;/strong&gt;입니다. 자원과 생산력이 제한된 상황에서의 물가 상승을 의미하며, 정부는 무제한적인 재정 적자를 통해 기술 발전으로 인한 생산 효율성 향상에 따라 시장에 구매력을 지속적으로 추가하여 이상적인 완전 고용 및 생산 병목 상태에 도달할 때까지 노력합니다. 이 시점에서 통화량을 늘리면 물가 상승이 발생하므로, 시장에 잉여 생산 요소가 존재하는 한 재정 적자 상한을 조절하고, 정부는 적자를 확대해도 물가 상승을 유발하지 않습니다.&lt;/p&gt;
&lt;h2 id=&#34;금융-위기-이후&#34;&gt;금융 위기 이후
&lt;/h2&gt;&lt;p&gt;물론 현실은 이상적인 세계가 아니기에, 각 단계의 실행은 사람들의 참여로 이루어지며, 케인스주의 역시 선택적으로 적용되어 경제 하락 시에는 자극이 많고, 과열을 억제하는 것은 상대적으로 적습니다. 이러한 상황에서 좋지 않은 경제를 부양하는 것이 정치적 성과로 이어지고, 과열된 경제 또한 정치적 성과로 여겨져 근본적으로 억제하기 어렵습니다. 이로 인해 발생하는 여러 가지 경제 문제와 새로운 금융 위기는 심지어 전통적인 과잉 생산으로 인한 경제 충격보다 더 클 수도 있습니다. 2008년 글로벌 금융 위기는 사실 극단적인 케인스주의 하에서 시장의 자기 강화로 인한 거품 현상이었으며, 부동산과 부동산을 기반 자산으로 하는 파생 금융 투자 상품과 같은 다수의 폰지 구조 금융 투자 상품이 등장했습니다. 심지어 위기가 발생하기 전까지 학계, 정치계, 시장 수준에서도 위험에 대한 인식이 부족했으며, 부채로 지탱되는 번영을 성과로 착각하고 더 많은 이익을 얻었습니다. 거대한 금융 시스템은 대표적인 예이며, 손실은 여러분 몫이고 배당금은 우리의 몫이라는 식이었고, 파산하더라도 이미 잔뜩 벌어놓은 돈은 돌려받을 수 없으며, 결국 많은 참여자들이 앞선 사람들의 각 단계에서 얻은 이익을 떠안게 되었습니다.&lt;/p&gt;
&lt;p&gt;이때 현대 화폐 체계의 그림자가 금융 위기 이후 나타나면서 전형적인 특징은 빠른 &lt;strong&gt;재정 적자 통화화와 중앙은행의 무제한적 양적 완화&lt;/strong&gt;, 그리고 일명 긴급 중앙은행 대출 정책입니다. 중앙은행은 최종 대부인으로서 돈을 무한히 공급하고, 정부는 지속적으로 부채를 지울 수 있습니다. 중앙은행과 재정 정책은 조화롭게 협력하며, 중앙은행은 국채 매입 등을 통해 정부의 재정 적자 지출을 지원하여 정책 목표의 일관성을 확보합니다. 이것이 바로 현대 화폐 정책과 재정 정책의 경계가 점차 모호해지는 이유이며, 통화량 발행에 있어서는 중앙은행의 직접적인 국채 매입 의존도가 매우 높습니다. 마치 한 손으로 돈을 찍어내고 다른 손으로 쓰는 것과 같습니다.&lt;/p&gt;
&lt;p&gt;유로존과 미국 모두 비슷한 양상을 보이고 있는데, 2008년 당시 유럽연합의 정부 부채는 약 6.7조 유로였고, 정부 레버리지는 대략 66%로 일반적으로 받아들여지는 경계선인 60%를 약간 상회했습니다. 구제 금융을 실시한 5년간인 2014년까지 부채 규모는 9.5조 유로로 증가했고, 레버리지는 93%에 달했습니다. 미국의 경우 더욱 과장된 모습을 보이며, 2008년 미국 정부 부채는 약 10조 달러였고, 2014년에는 대략 18조 달러까지 증가한 후 최근 또다시 정부 부채 상한선을 열었습니다. 물론 매번의 소동은 정부 폐쇄를 미끼로 사용되지만, 결과적으로 정부 부채 한도를 깨뜨리며 현재는 36조 달러를 넘어섰고, 이는 2008년 금융 위기 이후 26조 달러 증가한 수치입니다. GDP 성장 요인을 고려하면 정부 레버리지 또한 60%에서 120% 이상으로 증가했습니다. 연방준비제도는 최종 대주자로써 여러 차례의 구제 금융 과정에서 중요한 역할을 수행했으며, 정부 부채의 주요 구매자 중 하나이기도 합니다.&lt;/p&gt;
&lt;h2 id=&#34;현대-화폐-제도의-폐단과-한계&#34;&gt;현대 화폐 제도의 폐단과 한계
&lt;/h2&gt;&lt;p&gt;이러한 정부 주도의 경제 부양책은 계획 경제라고는 할 수 없지만, 직면하는 문제는 동일합니다. 시장의 전지전능함과 모든 참여자의 이타심을 어떻게 보장할 수 있을까요? 가장 간단한 예를 들어보자면, 정부 부서가 특정 방향에 대한 예산을 100만 원 늘린다면, 누구에게 돌아갈 가능성이 더 높을까요? 리더의 작은 아들 조카일까요, 아니면 가격 대비 효율이 더 높은 시장 경쟁 입찰일까요? 물론 현실에서는 더욱 복잡한 방식으로 이익이 흘러가게 되며, 그 결과 정부는 부채와 지출을 늘리지만 흐름은 완전히 통제할 수 없게 됩니다. 최근 미국에서 떠들썩하게 논의된 정부 효율성 부서 설립도 이러한 문제의 연장선상에 있습니다. 물론 이러한 현상은 다양한 부패 지수 경제체 내에서 차이가 있지만, 우리는 더 많은 관심을 일반적인 문제에 두고 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;인플레이션-문제&#34;&gt;인플레이션 문제
&lt;/h3&gt;&lt;p&gt;현대 정보 네트워크의 발전과 더불어 정부는 과거보다 시장 정보에 대한 파악이 훨씬 강화되었지만, 이는 전지전능한 것은 아니며 시장 자체에는 변수가 존재하고, 시장은 항상 예측에 따라 변화하며 꼬리에 꼬리를 무는 구조로 진입합니다. 저는 당신의 예측을 예측했습니다. 실제 사례를 보면 2008년&lt;del&gt;2020년 사이에 현대 화폐 이론이 단기적인 경제 회복과 인플레이션 안정이라는 실질적인 성과를 거두었고, 유로존에서는 심지어 일시적인 디플레이션 문제가 발생했으며, 미국의 인플레이션은 예상 범위인 1&lt;/del&gt;3% 사이를 유지하여 사람들이 과거 케인즈주의를 믿었던 것처럼 더욱 극단적인 도구를 신뢰하게 만들었습니다.&lt;/p&gt;
&lt;p&gt;사실 우리가 뒤돌아보면, 주로 개발도상국의 제조업이 2008년 이후에도 고성장 추세를 유지했기 때문인데, 예를 들어 이 기간 동안 글로벌 생산 지위를 확고히 한 우리나라와 후발 주자인 동남아시아 및 인도 경제체들은 높은 제조업 부가가치를 유지하며 현대 통화 이론의 최대 제약인 자원 공급 제한을 상쇄했고, 덕분에 미국과 유럽은 탈산업화와 과도한 금융화 속에서도 정부 부채와 통화 공급 급증에도 불구하고 비교적 안정적인 인플레이션을 유지할 수 있었습니다&lt;/p&gt;
&lt;p&gt;하지만 2020년 이후, 더 큰 규모의 경기 부양책 사용으로 인해 유로존과 미국 모두 상당한 인플레이션을 경험했으며 최고조에는 약 10%까지 치솟았습니다. 오늘날에도 금리 인상이 거의 3년을 지났음에도 불구하고 미국의 고용 시장은 여전히 비정상적으로 과열되어 있으며 금융 시장은 통화 지원 하에 경제 성장과 괴리를 보이는 과도한 번영을 보이고 있습니다. 기준 효과가 사라짐에 따라 미국의 인플레이션은 다시 3%로 치닫고 있으며, 이러한 금리 인상 과정에서의 과열 현상은 재정 적자와 밀접하게 관련되어 있습니다. 금리 인상은 통화 정책의 긴축이지만, 재정 정책은 실제로 확장적이며 2020년의 대규모 통화 공급과 결합하여 미국의 인플레이션을 비정상적으로 완고하게 만들었습니다. 현대 화폐 이론의 가장 큰 제약은 바로 높은 인플레이션입니다.&lt;/p&gt;
&lt;h3 id=&#34;정부-부채-문제&#34;&gt;정부 부채 문제
&lt;/h3&gt;&lt;p&gt;원칙적으로 정부는 채무를 통해 채무를 상환하는 것을 무제한으로 할 수 있지만, 전제 조건은 &lt;strong&gt;중앙은행이 완전히 꼭두각시처럼 행동&lt;/strong&gt;해야 한다는 것이며, 이는 현대 통화 체제에서 &lt;strong&gt;재정 정책과 통화 정책의 목표가 일치&lt;/strong&gt;하는 것입니다. 분명히 연방준비제도는 정부에게 완전한 권한을 부여할 준비가 되어 있지 않으며, 수십 년간 쌓인 정부 부채 잔액, 특히 이자 지출은 고금리 위 고부담으로 인해 점차 재정의 거대한 부담이 되고 있습니다.&lt;/p&gt;
&lt;p&gt;2023 회계연도: 미국의 2023회계연도 세입은 4조 4390억 달러였으며, 당해 연도의 이자 지급액은 세입의 약 15%를 차지했습니다. 2024년에도 고금리 상태가 이어졌으며, 미국 재무부 발표에 따르면
2024 회계연도: 미국 연방 정부의 재정 적자는 1조 8330억 달러에 달했으며, 이자 지급액은 8820억 달러로 미국 연방 수입의 약 18%를 차지하며 심지어 사회 보장 지출을 넘었습니다&lt;/p&gt;
&lt;p&gt;이것이 재정의 지속가능성 문제이고, 장기간에 걸쳐 저금리, 저인플레이션, 고부채(예를 들어 일본)를 유지한다면 실제로 장기적으로 준 현대 통화 이론의 적용을 형성할 수 있습니다. 72 규칙에 따르면 금리가 충분히 낮으면 재정은 부채로 채무를 늘리는 방식이 매우 느립니다. 자금 비용이 1%라면 순수한 부채 상환으로 72년 동안 부채가 두 배로 증가합니다. 만약 인플레이션이 이러한 미묘한 균형을 깨면, 부채의 이자 상환 누적 과정에서 복리 효과로 인해 미래 부채 추세가 통제 불능 상태에 빠지고, 이자 분할 원금이 오히려 부차적인 요소가 됩니다. 중앙은행이 집권당의 목표와 일치하지 않는다면 이러한 문제는 더욱 심각해질 것입니다. 트럼프 정부의 정치적 주장은 현재 연방준비제도 매파 정책과 뚜렷한 차이를 보이며, 이것 또한 이번 임기 동안 미국 정부와 연방준비제도의 관계가 악화되는 중요한 원인입니다. 가장 큰 관심사는 현임 회장이 임기를 마치고 순조롭게 자리를 내릴 수 있을지 여부입니다.&lt;/p&gt;
&lt;h3 id=&#34;금융-거품과-통화-신용-문제&#34;&gt;금융 거품과 통화 신용 문제
&lt;/h3&gt;&lt;p&gt;이상적으로는 정부 지출 확대가 가계와 기업 부문에 흡수되어 모두가 지출을 늘리고, 이를 통해 실질 수요를 증가시키겠지만, 2000년 이후 여러 금융 거품의 직접적인 경험자들은 투자와 소비 사이에서 상당한 투자 가치 선호를 보일 것입니다. 특히 가치 상승 기대감이 매우 높은 제품이 나타날 때는 금융 시장으로 몰려들어 더 높은 가치를 추구하고, 심지어 삶의 질을 희생하거나 레버리지를 높여 주택 구매를 서두르는 경향이 있습니다. 이는 일본, 미국, 우리나라의 부동산 고성장기에도 유사한 현상이었습니다. 정책 자극과 업계 종사자의 이익 최대화 추구를 결합하면 2차 대출과 같은 문제가 많아지고, 많은 구원책은 사실 채무를 장려하는 것입니다.&lt;/p&gt;
&lt;p&gt;그래서 역사는 놀랍도록 일관성을 보입니다. 통화 정책과 재정 정책이 대규모로 힘을 낼 때, 흔히 &lt;strong&gt;자산 거품과 부의 재분배의 축제&lt;/strong&gt;가 벌어집니다. 자산 거품이 먼저 발생하고, 부의 재분배는 그 뒤를 이어 나타납니다. 이는 또 다른 문제를 야기하는데, 바로 극단적인 케인스주의나 현대 통화 이론을 장기간 사용할 경우 발생하는 경제적 폰지 사기 문제(밍스키 모멘트)입니다. 아직 핫머니가 있는 한 자산 가격은 계속 상승하고, 계속 상승하면 후발주자들이 돈을 들고 몰려들 것입니다. 하지만 생활비 지출 변화를 측정하는 CPI는 큰 변화를 보이지 않으며, 돈은 특정 분야에서 공전하게 됩니다. 후발주자들은 돈이 부족해지고, &lt;strong&gt;축제 이후에는 붕괴&lt;/strong&gt;가 찾아옵니다. 바로 밍스키 모멘트의 심판이며, 이는 실패하지 않습니다.&lt;/p&gt;
&lt;p&gt;또한 화폐 자체도 공급과 수요 관계가 있으며, 시장의 공급이 과도할 때, 전통적인 투자 품목을 수용하지 못하거나, 여러 차례 거품 붕괴로 자금 흡수가 어려울 때(일본인들은 몇십 년 동안 부동산 투자를 꺼리는 이유), 세금 정책의 억제, 부동산 보유세 증가를 통한 투기 수요 감소 등은 금융 투기의 비용을 높입니다. 이러한 과잉 화폐 공급 상황에서 시장은 &lt;strong&gt;자금 흡수력이 뛰어나고 비과세&lt;/strong&gt;인 투자 품목을 절실히 필요로 하며, 다양한 가상 투자 품목이 생겨나게 됩니다. 심지어 미국 대통령과 영부인까지 참여하여 일부를 가져가는 경우도 있는데, 이는 달러의 지위를 훼손하는 것으로 해석되기도 하지만, 실제로는 전 세계적인 통화 과발행과 금융 공회전으로 인한 법정 화폐 신용 약화의 필연적인 결과라고 볼 수 있습니다. 현대 화폐 이론이 가장 의존하는 국가 독점 권한 하의 신용 화폐 지위까지도 위협받을 수 있으며, 어떤 토양인지에 따라 어떤 금융 게임이 발생하는지 결정됩니다.&lt;/p&gt;
&lt;p&gt;요약하자면, 현대 화폐 이론은 케인스주의와 더 나은 점진적이고 대체적인 관계이며, 정부의 적극적인 시장 개입을 더욱 강조하고 재정 적자와 중앙은행 독립에 대한 태도가 더욱 급진적입니다. 케인스주의의 과도한 사용은 스태그플레이션과 금융 위기를 초래했으며, 이러한 인위적으로 과열된 경제를 정리하기 위해 현대 화폐 이론은 2008년 이후 조용히 시장에 진입했습니다. 세계화 시대에 생산성이 계속 향상되면서 단기적으로는 빠른 성장을 회복하고 사용국의 물가 수준을 유지했지만, 막대한 정부 부채와 금융 거품도 누적되었습니다. 인플레이션이 반등하고 중앙은행과 정부의 목표가 일치하지 않으며 고금리와 고레버리지가 공존하는 상황에서 정부의 이자 지급 부담은 크게 가중되고 재정 지속 가능성은 크게 약화됩니다. 또한 과도한 정부 참여로 인한 통화 공급은 금융 거품을 야기하고 무제한적인 화폐 발행은 화폐 자체의 신뢰를 훼손합니다. 달러가 강해 보이는 것은 사실상 동료들의 부각 효과이며, 막대한 투자 수요는 다양한 새로운 금융 투자 및 투기 도구를 만들어내고 심지어 전통적인 금융 투자 상품의 세금 제한을 벗어나기도 합니다. 이는 전 세계 경제의 단면입니다. 현대 화폐 이론은 미래가 아니라 2008년부터 사용된 과거이며, 역경제 글로벌화와 결합되어 과거 금융 거품이 클수록 정부 부채가 누적되고 금융 투기 도구가 광적으로 변할수록 자산이 왜곡되게 분배되는 효율성이 높아질수록 하드랜딩의 위험은 커집니다. 경제적 및 사회적 위험을 포함합니다. 케인스주의든 현대 화폐 이론이든, 통화 공급이 아무리 많아도 진정으로 부의 구조 문제를 해결할 수 없으며 자산 거품과 도덕적 해이를 통해 위험을 악화시킵니다. 사람들은 끊임없이 다른 자세로 같은 함정에 빠지지만 아무것도 배우지 않습니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>atop 도구를 사용하여 Linux 시스템 지표를 모니터링하는 방법: 설치, 구성 및 사용법 완벽 가이드</title>
        <link>https://ttf248.life/ko/p/using-atop-to-monitor-linux-system-metrics-installation-configuration-and-usage-guide/</link>
        <pubDate>Thu, 06 Feb 2025 22:48:55 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/using-atop-to-monitor-linux-system-metrics-installation-configuration-and-usage-guide/</guid>
        <description>&lt;p&gt;리눅스 시스템 운영 과정에서 시스템 자원과 프로세스 상태를 실시간으로 종합적으로 모니터링하는 것은 매우 중요합니다. atop 도구는 강력한 모니터링 도구로서, 이를 쉽게 달성하도록 도와줍니다. 본 문서에서는 리눅스 인스턴스에 atop 모니터링 도구를 설치, 구성 및 사용하는 방법을 자세히 설명하겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;일반적으로-사용되는-atop-도구-소개&#34;&gt;일반적으로 사용되는 atop 도구 소개
&lt;/h2&gt;&lt;p&gt;atop은 Linux 시스템 리소스 및 프로세스를 모니터링하는 데 특화된 도구입니다. 시스템과 프로세스의 활동을 기록하고 모든 프로세스의 실행 상황을 보고합니다. 이 도구는 CPU, 메모리, 디스크, 네트워크 등 리소스 사용량 정보와 프로세스 상태 데이터를 수집하며, 데이터를 로그 파일 형태로 디스크에 저장할 수도 있습니다. 각 프로세스별로 CPU 사용률, 메모리 증가량, 디스크 사용률, 우선순위, 사용자 이름, 상태 및 종료 코드 등의 주요 정보를 얻을 수 있습니다. 또한 atop 설정 파일을 통해 로그 수집 빈도, 로그 파일 저장 경로 및 로테이션 정책과 같은 매개변수를 사용자 정의할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;두-번째-atop-도구-설치&#34;&gt;두 번째, atop 도구 설치
&lt;/h2&gt;&lt;p&gt;다양한 Linux 배포판에서 atop을 설치하는 방법은 약간씩 다르며, 다음에서는 일반적인 운영체제를 기준으로 설명하겠습니다&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Alibaba Cloud Linux 3/2、CentOS 7/8、Fedora、Rocky Linux 9&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실행 설치 명령: &lt;code&gt;sudo yum install -y atop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;atop 서비스를 시작합니다: &lt;code&gt;sudo systemctl start atop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Ubuntu / Debian&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;소프트웨어 저장소 목록 업데이트: &lt;code&gt;sudo apt update&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;실행 설치 명령: &lt;code&gt;sudo apt install -y atop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;atop 서비스를 시작합니다: &lt;code&gt;sudo systemctl start atop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CentOS Stream 9&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다운로드 및 설치: &lt;code&gt;sudo wget https://www.atoptool.nl/download/atop-2.11.0-1.el9.x86_64.rpm &amp;amp;&amp;amp; sudo rpm -i atop-2.11.0-1.el9.x86_64.rpm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;atop 서비스를 시작합니다: &lt;code&gt;sudo systemctl start atop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;openSUSE&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실행할 설치 명령: &lt;code&gt;sudo zypper install -y atop atop-daemon&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;atop 서비스를 시작합니다: &lt;code&gt;sudo systemctl start atop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;위에 나열된 운영체제에 사용하시는 배포판이 포함되어 있지 않다면, atop 공식 웹사이트에서 설치 정보를 확인하실 수 있습니다&lt;/p&gt;
&lt;h2 id=&#34;세-모니터링-주기-및-로그-보존-기간-설정&#34;&gt;세, 모니터링 주기 및 로그 보존 기간 설정
&lt;/h2&gt;&lt;p&gt;설정 파일 위치: Alibaba Cloud Linux 3/2, CentOS 7/8 및 Fedora 시스템에서는 atop의 설정 파일이 &lt;code&gt;/etc/sysconfig/atop&lt;/code&gt;이고, Ubuntu, Debian 및 openSUSE 시스템에서는 설정 파일이 &lt;code&gt;/etc/default/atop&lt;/code&gt;입니다
기본 설정 매개변수 설명
- 로그옵션은 로그 파일 기록 옵션을 제어하는 데 사용되며, 기본값은 비어 있습니다
- 로그 간격입니다. 기본값은 600초입니다. 과거 로그 추적 문제를 수집하려면 실제 요구 사항에 따라 이 빈도를 조정하는 것이 좋습니다.
- 로그 보존 기간, 기본값 28일
- 로그 파일 저장 경로입니다. 기본값은 /var/log/atop 입니다.
설정 단계
- 명령을 실행하여 설정 파일을 엽니다:
- Alibaba Cloud Linux 3/2, CentOS 7/8, Fedora 시스템에서: &lt;code&gt;sudo vim /etc/sysconfig/atop&lt;/code&gt;
- Ubuntu, Debian, openSUSE, CentOS Stream 9, Rocky Linux 9 시스템에서: &lt;code&gt;sudo vim /etc/default/atop&lt;/code&gt;
- &lt;code&gt;i&lt;/code&gt;로 들어가 편집 모드로 전환한 다음, 필요에 따라 구성 매개변수를 조정합니다. 예를 들어, 모니터링 주기를 30초로 변경하고, 로그 보존 기간을 7일로 설정하며, 로그 경로를 기본값으로 유지합니다.
- &lt;code&gt;Esc&lt;/code&gt; 키를 누르고 &lt;code&gt;:wq&lt;/code&gt; 를 입력하여 저장하고 편집을 종료합니다
- atop 서비스를 재시작하여 설정이 적용됩니다: &lt;code&gt;sudo systemctl restart atop&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;LOGOPTS=&amp;quot;&amp;quot;
LOGINTERVAL=30
LOGGENERATIONS=7
LOGPATH=/var/log/atop 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;네-알겠습니다-사-atop-도구-사용&#34;&gt;네, 알겠습니다. 사, atop 도구 사용
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;자주 사용되는 명령어 소개:&lt;/strong&gt; 상호 작용 명령 모드에서 다음의 자주 사용되는 명령어가 있습니다
- 기본 통합 출력 보기로 전환합니다
- 프로세스 열의 전체 명령줄을 표시합니다
- 프로세스 메모리 사용률에 따라 내림차순으로 필터링합니다
- 프로세스 디스크 사용률을 기준으로 내림차순으로 필터링합니다
- 프로세스 자원 종합 활용률에 따라 내림차순으로 필터링합니다
- 프로세스 네트워크 사용률에 따라 내림차순으로 필터링합니다
- 다음 모니터링 수집 지점으로 이동합니다
- 이전 모니터링 수집 지점으로 이동합니다
- 시간 지정, 형식은 &lt;code&gt;YYYYMMDDhhmm&lt;/code&gt;입니다&lt;/p&gt;
&lt;p&gt;자원 모니터링 필드 의미 설명
- 호스트 이름, 정보 샘플링 날짜 및 시간입니다
- 프로세스 전체 실행 상황, 커널 모드 및 사용자 모드 실행 시간, 프로세스 총 수, 다양한 상태의 프로세스 수 등을 포함합니다
- CPU 전체 사용률은 각 필드의 숫자 합계가 &lt;code&gt;N*100%&lt;/code&gt;(N은 CPU 코어 수)로 표시되며, 커널 모드, 사용자 모드, 인터럽트, 유휴 상태, 디스크 I/O 대기 등의 시간 비율을 포함합니다
- CPL은 CPU 부하 상황을 나타내며, 과거 1분, 5분 및 15분 동안 실행 대기열에 있는 평균 프로세스 수, 컨텍스트 스위칭 횟수, 인터럽트 발생 횟수를 포함합니다
- 메모리 사용량 정보로, 총 물리 메모리 용량, 유휴 메모리, 페이지 캐시 메모리, 파일 캐시 메모리, 커널 점유 메모리 등을 포함합니다
- SWP：스왑 공간 사용량 정보, 스왑 영역 총 용량 및 남은 스왑 공간 크기를 포함합니다
- 가상 메모리 페이지 상태, 예를 들어 스왑 인 및 스왑 아웃된 페이지 수
- DSK：디스크 사용률, 각 디스크 장치별로 한 열을 표시하며 장치 식별자, 바쁜 상태 시간 비율, 읽기/쓰기 요청 횟수를 나타냅니다
- 네트워크 상태를 보여주며, 전송 계층 TCP와 UDP, IP 계층 및 각 활성 네트워크 포트의 송수신 패킷 크기를 표시합니다&lt;/p&gt;
&lt;p&gt;실시간 시스템 지표 확인
- 매 5초마다 시스템 지표를 확인합니다: &lt;code&gt;atop 5&lt;/code&gt;
- 현재 시간 이후 5분 내 (총 30회, 간격 10초)의 시스템 지표를 확인합니다: &lt;code&gt;atop -M 10 30&lt;/code&gt;
- 현재 시간 이후 10분(10회, 간격 60초)의 시스템 지표를 확인하고 결과를 파일에 기록합니다: &lt;code&gt;atop -M 60 10 &amp;gt; /log/atop.mem&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;atop을 시작한 후 수집된 기록은 기본적으로 &lt;code&gt;/var/log/atop&lt;/code&gt; 디렉터리에 저장됩니다. 확인할 때는 지정된 날짜의 로그 파일이 반드시 존재해야 하며, 그렇지 않으면 오류가 발생합니다.
- 오늘 날짜의 히스토리 지표 로그 보기: &lt;code&gt;atop -r&lt;/code&gt;
- 어제 기록 지표 로그 확인: &lt;code&gt;atop -r y&lt;/code&gt;
- 지정된 날짜의 과거 지표 로그를 확인합니다. 예를 들어 2024년 11월 06일: &lt;code&gt;atop -r 20241106&lt;/code&gt;
- 지정된 날짜 및 시간 이후의 과거 지표 로그를 확인합니다. 예를 들어 2024년 11월 6일 14:00 이후: &lt;code&gt;atop -r 20241106 -b 14:00&lt;/code&gt;
- 지정된 날짜 및 시간 범위 내의 과거 지표 로그를 확인합니다. 예를 들어 2024년 11월 5일 00시 04분부터 00시 08분까지는 &lt;code&gt;atop -r 20241105 -b 00:04 -e 00:08&lt;/code&gt; 명령을 사용합니다.&lt;/p&gt;
&lt;p&gt;시스템 활동 보고서 확인
- 현재 시스템의 CPU 사용률 보고서를 1분 동안(12회, 간격 5초) 확인합니다: &lt;code&gt;atopsar -c 5 12&lt;/code&gt;
- 당일 지정된 시간대의 메모리 지표 보고서를 확인하려면, 예를 들어 18:00부터 18:01까지: &lt;code&gt;atopsar -m -b 18:00 -e 18:01&lt;/code&gt;
- 지정된 날짜 및 시간 범위 내의 메모리 지표 보고서를 확인합니다. 예를 들어 2024년 11월 5일 18:00부터 18:01까지: &lt;code&gt;atopsar -m -r 20241105 -b 18:00 -e 18:01&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;다섯-기타-조작&#34;&gt;다섯. 기타 조작
&lt;/h2&gt;&lt;p&gt;천기 수준 로그 로테이션 정책 구성: 매일 atop 지표 로그 파일을 생성하려면 다음 단계를 수행할 수 있습니다
- (선택 사항) 필요에 따라 모니터링 주기, 로그 보존 기간 및 로그 저장 경로를 조정합니다
- 명령을 실행하여 매일 로그 로테이션 관련 서비스의 자동 시작을 설정하고 서비스를 시작합니다: &lt;code&gt;sudo systemctl enable --now atop atopacct atop-rotate.timer&lt;/code&gt;
- 비즈니스에서 더 복잡한 로깅 처리가 필요하다면 logrotate나 사용자 정의 스크립트를 활용하여 로그 관리를 구현할 수 있습니다&lt;/p&gt;
&lt;p&gt;선택적 netatop 커널 모듈 로드: 네트워크 사용률을 모니터링하려면 netatop 모듈(atop에서 기본적으로 설치되지 않음)을 설치할 수 있습니다. Alibaba Cloud Linux 3 시스템의 예를 들어:
- 커널 개발 패키지 및 컴파일에 필요한 소프트웨어 환경 설치: &lt;code&gt;sudo yum install -y kernel-devel dkms elfutils-libelf-devel&lt;/code&gt;
- 최신 버전 netatop 소스 코드를 지정된 디렉터리로 다운로드합니다: &lt;code&gt;cd /usr/src/ &amp;amp;&amp;amp; sudo wget https://www.atoptool.nl/download/netatop-3.2.2.tar.gz --no-check-certificate&lt;/code&gt;
- 소스 코드를 압축 해제하고 소스 코드 디렉토리로 들어갑니다: &lt;code&gt;sudo tar -zxvf netatop-3.2.2.tar.gz &amp;amp;&amp;amp; cd netatop-3.2.2&lt;/code&gt;
- 소스 코드를 기반으로 모듈과 데몬을 빌드하고 설치합니다: &lt;code&gt;sudo make &amp;amp;&amp;amp; sudo make install&lt;/code&gt;
- netatop 서비스 시작: &lt;code&gt;sudo systemctl start netatop&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;atop 도구는 기능이 강력하고 사용하기 유연하며, 적절한 설치, 구성 및 사용을 통해 Linux 시스템의 실행 상태를 더 잘 이해하고 잠재적인 문제를 조기에 발견하여 해결할 수 있습니다. 본 문서가 Linux 시스템 모니터링 측면에서 여러분의 역량을 향상시키는 데 도움이 되기를 바랍니다.&lt;/p&gt;
&lt;h2 id=&#34;6-참고-자료-링크&#34;&gt;6. 참고 자료 링크
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;[atop 공식 웹사이트]&lt;/li&gt;
&lt;li&gt;[ atop 모니터링 도구 설치, 구성 및 사용 ]&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>환율의 매입 환율과 판매 환율을 이해하다</title>
        <link>https://ttf248.life/ko/p/understanding-exchange-rates-buy-and-sell-rates/</link>
        <pubDate>Thu, 06 Feb 2025 22:32:10 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/understanding-exchange-rates-buy-and-sell-rates/</guid>
        <description>&lt;p&gt;외환 시장에서, 특히 은행이나 통화 환전소에서 “매입 환율”과 “매도 환율”이라는 용어를 자주 볼 수 있습니다. 많은 분들이 이 두 가지 개념이 정확히 무엇인지 잘 모르거나 혼동하는 경우도 있습니다. 오늘 우리는 간단한 예시를 통해 이들 환율의 의미와 역할에 대해 이해하도록 돕겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;환율이-무엇인가요&#34;&gt;환율이 무엇인가요?
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;매입환율: 은행이나 외환 거래소가 이 환율로 외국 통화를 구매할 의향이 있다는 의미입니다. 즉, 당신이 외국 통화(예: 달러)를 은행에 판매할 때, 은행은 매입환율에 따라 위안화를 지불합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;매도 환율: 은행이나 외환 거래소는 이 환율로 외국 통화를 팔기를 원합니다. 즉, 당신이 위안화로 외국 통화를 구매할 때, 은행은 매도 환율로 외국 통화를 판매합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;간단히 말해서:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;매입환율: 은행이 귀하로부터 외화를 구매하는 가격입니다&lt;/li&gt;
&lt;li&gt;매도 환율: 은행이 외화를 당신에게 파는 가격입니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;은행의 매입 및 매도 환율은 일반적으로 다르며, 매도 환율이 통상적으로 매입 환율보다 높습니다. 이러한 차액이 은행의 이익을 창출하는 원천입니다.&lt;/p&gt;
&lt;h2 id=&#34;구체적인-사례-분석&#34;&gt;구체적인 사례 분석
&lt;/h2&gt;&lt;p&gt;두 환율의 실제 적용을 더 명확하게 이해할 수 있도록, 구체적인 예시를 들어보겠습니다&lt;/p&gt;
&lt;p&gt;은행에서 달러로 환전할 때, 은행이 제시하는 환율은 다음과 같습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;매입 환율: 1달러 = 7.0 위안&lt;/li&gt;
&lt;li&gt;판매 환율: 1달러 = 7.2위안&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;상황-1-당신이-달러를-은행에-팔다&#34;&gt;상황 1: 당신이 달러를 은행에 팔다
&lt;/h3&gt;&lt;p&gt;당신이 1000달러가 있다고 가정하고 은행에 달러를 팔고 싶다면, 은행은 매입 환율로 계산합니다&lt;/p&gt;
\[
1000 달러 × 7.0 위안/달러 = 7000 위안
\]
&lt;p&gt;즉, 은행이 7000위안을 드립니다. 여기 환율은 &lt;strong&gt;매입환율&lt;/strong&gt;인데, 이는 당신이 은행에 달러를 파는 것이기 때문입니다.&lt;/p&gt;
&lt;h3 id=&#34;상황-두-번째-당신은-위안화로-달러를-구매합니다&#34;&gt;상황 두 번째: 당신은 위안화로 달러를 구매합니다
&lt;/h3&gt;&lt;p&gt;당신이 7000위안을 가지고 있고, 미국 달러로 환전하고 싶다고 가정해 봅시다. 은행은 매도 환율에 따라 계산합니다:&lt;/p&gt;
\[
7000 위안 ÷ 7.2 위안/달러 = 972.22 달러
\]
&lt;p&gt;이 경우, 7000위안으로 약 972.22달러를 환전할 수 있습니다. 여기 제시된 환율은 &lt;strong&gt;매도 환율&lt;/strong&gt;이며, 은행에서 달러를 구매하는 것이기 때문입니다.&lt;/p&gt;
&lt;h2 id=&#34;환율이-매수-시와-매도-시-왜-다른가요&#34;&gt;환율이 매수 시와 매도 시 왜 다른가요?
&lt;/h2&gt;&lt;p&gt;당신은 아마도 은행의 매입 환율(7.0 위안/달러)이 판매 환율(7.2 위안/달러)보다 낮다는 것을 눈치챘을 것입니다. 이는 은행이 외환 거래를 할 때 일반적으로 이 환율 차이를 통해 이익을 얻기 때문입니다. 다시 말해, 은행은 더 높은 판매 환율과 더 낮은 매입 환율 사이의 차액을 통해 이윤을 얻습니다.&lt;/p&gt;
&lt;p&gt;예를 들어, 위의 사례에서 은행의 스프레드는 다음과 같습니다:&lt;/p&gt;
\[
매도 환율(7.2) - 매입 환율(7.0) = 0.2 위안
\]
&lt;p&gt;이 차액은 은행의 이익 발생원입니다&lt;/p&gt;
&lt;h2 id=&#34;요약&#34;&gt;요약
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;매입환율: 은행이 이 환율로 외국 통화를 귀하로부터 구매합니다(귀하가 외국 통화를 판매할 때의 환율)&lt;/li&gt;
&lt;li&gt;매출 환율: 은행이 이 환율로 외화를 판매합니다 (당신이 외화를 구매할 때의 환율)&lt;/li&gt;
&lt;li&gt;환율 차이: 매입 및 매도 환율 간의 차액은 은행의 이익 창출 지점입니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 두 가지 환율 개념을 이해하면 외환 거래 시 자신이 얻게 될 외국 통화의 양이나, 외국 통화를 구매하기 위해 지불해야 할 위안화의 양을 더 명확하게 알 수 있습니다. 이 간단한 예제가 외환 환율의 기본 원리를 더 잘 이해하는 데 도움이 되기를 바랍니다!&lt;/p&gt;</description>
        </item>
        <item>
        <title>Visual Studio에서 일치하지 않는 PDB 파일을 로드합니다</title>
        <link>https://ttf248.life/ko/p/visual-studio-loading-unmatched-pdb-files/</link>
        <pubDate>Thu, 23 Jan 2025 20:04:33 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/visual-studio-loading-unmatched-pdb-files/</guid>
        <description>&lt;p&gt;윈도우에서 Visual Studio로 프로그램을 디버깅할 때, pdb 파일이 실행 파일과 일치하지 않으면 Visual Studio가 &amp;ldquo;기호 파일을 로드할 수 없음&amp;quot;이라는 메시지를 표시합니다. 프로그램이 충돌하고 덤프 파일이 생성되면, 일치하지 않는 pdb 파일 때문에 Visual Studio는 충돌 현장에 원활하게 진입하지 못합니다.&lt;/p&gt;
&lt;h2 id=&#34;pdb-파일이-뭐죠&#34;&gt;pdb 파일이 뭐죠?
&lt;/h2&gt;&lt;p&gt;PDB 파일은 마이크로소프트에서 제공하는 디버깅 정보 파일이며, 프로그램 디버깅에 사용됩니다. PDB 파일에는 프로그램의 심볼 테이블, 소스 코드 파일 이름, 행 번호 등의 정보가 포함되어 있습니다. 프로그램 컴파일 시 PDB 파일을 생성하여 프로그램을 디버깅할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;windbg-디버깅&#34;&gt;WinDbg 디버깅
&lt;/h2&gt;&lt;p&gt;WinDbg는 마이크로소프트의 디버깅 도구이며, Windows 프로그램을 디버깅하는 데 사용될 수 있습니다. WinDbg는 호환되지 않는 pdb 파일을 로드할 수 있지만, 수동으로 로드해야 합니다. &lt;code&gt;.reload /f /i&lt;/code&gt; 명령어를 사용하여 호환되지 않는 pdb 파일을 강제로 로드할 수 있습니다.&lt;/p&gt;
&lt;p&gt;하지만 WinDbg는 Visual Studio만큼 사용하기 편리하지 않으므로, 저희는 Visual Studio에서도 호환되지 않는 PDB 파일을 로드할 수 있기를 바랍니다&lt;/p&gt;
&lt;h2 id=&#34;비주얼-스튜디오에서-호환되지-않는-pdb-파일을-로드합니다&#34;&gt;비주얼 스튜디오에서 호환되지 않는 PDB 파일을 로드합니다
&lt;/h2&gt;&lt;p&gt;소스 코드는 보통 git으로 관리되므로, 해당 버전의 코드를 찾아 다시 컴파일하여 일치하는 pdb 파일을 생성할 수 있습니다. 왜 로드되지 않을까요? 주로 메타데이터가 매칭되지 않기 때문입니다.&lt;/p&gt;
&lt;p&gt;작은 도구가 있는데, 실행 파일 정보에 기반하여 메타데이터를 수정하고 새로운 pdb 파일을 생성하여 Visual Studio가 로드할 수 있게 합니다&lt;/p&gt;
&lt;p&gt;chkmatch 다운로드 주소: &lt;a class=&#34;link&#34; href=&#34;https://www.debuginfo.com/tools/chkmatch.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.debuginfo.com/tools/chkmatch.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;사이트 캐시 주소: &lt;a class=&#34;link&#34; href=&#34;chkmatch.zip&#34; &gt;chkmatch.zip&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ChkMatch utility can be used to check whether an executable and debug information file match. It can also be used to enforce matching between an executable and debug information file, if they are compatible.

For more information about debug information matching and related issues, see this article.

Supported debug information formats: DBG, PDB 2.0, PDB 7.0.

chkmatch [-c ExeFile DebugInfoFile ] |
         [-m ExeFile DebugInfoFile]
-c
Check matching between the executable and the debug information file.
-m
Make the executable and the debug information file match.
ExeFile
The name of the executable file.
DebugInfoFile
The name of the debug information file.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;chkmatch-사용하세요&#34;&gt;chkmatch 사용하세요
&lt;/h2&gt;&lt;p&gt;먼저 검사 작업을 수행하고, 불일치 원인을 분석한 후 서명 불일치를 알립니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\tianlong.xiang\Downloads\chkmatch&amp;gt;ChkMatch.exe -c &amp;quot;D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe&amp;quot; E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb
ChkMatch - version 1.0
Copyright (C) 2004 Oleg Starodumov
http://www.debuginfo.com/


Executable: D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe
Debug info file: E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb

Executable:
TimeDateStamp: c26d9be3
Debug info: 2 ( CodeView )
TimeStamp: f86b0a4f  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 122  RVA: 001cdc44  FileOffset: 001cbe44
CodeView format: RSDS
Signature: {428c9b95-39a3-4a8d-a8e5-7be453684757}  Age: 1
PdbFile: D:\stock_UAT\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\obj\Release\YinTrade.Main.pdb
Debug info: 16 ( Unknown )
TimeStamp: 00000000  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 0  RVA: 00000000  FileOffset: 00000000

Debug information file:
Format: PDB 7.00
Signature: {06fae08e-c0a2-4f3d-9c7c-dfc684445dd1}  Age: 1

Result: Unmatched (reason: Signature mismatch)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그런 다음 수정 작업을 실행하여 pdb 파일과 exe 파일을 일치시킵니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\tianlong.xiang\Downloads\chkmatch&amp;gt;ChkMatch.exe -m &amp;quot;D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe&amp;quot; E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb
ChkMatch - version 1.0
Copyright (C) 2004 Oleg Starodumov
http://www.debuginfo.com/


Executable: D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe
Debug info file: E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb

Executable:
TimeDateStamp: c26d9be3
Debug info: 2 ( CodeView )
TimeStamp: f86b0a4f  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 122  RVA: 001cdc44  FileOffset: 001cbe44
CodeView format: RSDS
Signature: {428c9b95-39a3-4a8d-a8e5-7be453684757}  Age: 1
PdbFile: D:\stock_UAT\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\obj\Release\YinTrade.Main.pdb
Debug info: 16 ( Unknown )
TimeStamp: 00000000  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 0  RVA: 00000000  FileOffset: 00000000

Debug information file:
Format: PDB 7.00
Signature: {06fae08e-c0a2-4f3d-9c7c-dfc684445dd1}  Age: 1

Writing to the debug information file...
Result: Success.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/38147487/forcing-to-load-unmatched-symbols-in-visual-studio-2015-debugger&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;forcing-to-load-unmatched-symbols-in-visual-studio-2015-debugger&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>커서 AI 프로그래밍 IDE 체험</title>
        <link>https://ttf248.life/ko/p/cursor-ai-programming-ide-trial/</link>
        <pubDate>Thu, 23 Jan 2025 19:30:13 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/cursor-ai-programming-ide-trial/</guid>
        <description>&lt;p&gt;번뜩이는 사이 또 일 년이 지나갔다. 업무적으로 가장 큰 변화는 인공지능의 참여도가 눈에 띄게 높아진 것인데, 이전에는 다양한 개발 언어 간 전환 시 개발자가 익숙해해야 할 여러 언어들의 다른 API 인터페이스들이 있었지만, 이제 이러한 기본적인 코드들은 AI를 통해 생성할 수 있게 되었다. 이는 개발자들에게 큰 행운이다.&lt;/p&gt;
&lt;h2 id=&#34;chatgpt&#34;&gt;ChatGPT
&lt;/h2&gt;&lt;p&gt;23년도에 간단한 입문 소개 두 편을 다룬 적이 있었는데, 눈 깜짝할 사이에 25년이 벌써 왔네요. 어떻게 말해야 할지 모르겠지만, 뚜렷한 발전은 없는 것 같아요. 아직은 자신만의 인식을 가지고 합리적으로 작업을 분할할 수 있어야 하고, 무엇보다 중요한 것은 AI가 생성한 코드에 버그가 있는지 식별하는 것입니다.&lt;/p&gt;
&lt;h2 id=&#34;github-copilot&#34;&gt;Github copilot
&lt;/h2&gt;&lt;p&gt;어느 날인지 잊혀졌는데, 자료를 보니 싱가포르에 서버를 구축했고, 이제 국내에서 사용할 수 있어서 더 이상 오랫동안 VPN을 사용할 필요가 없어. 물론 로그인할 때는 아직 VPN이 필요하지만, 이 VPN은 로그인할 때만 잠깐 사용하면 되고 그 후에는 종료해도 돼.&lt;/p&gt;
&lt;p&gt;일상적으로 더 많이 사용하는 것은 Github Copilot 플러그인인데, 이 플러그인은 vscode나 visual studio에서 바로 사용할 수 있습니다. 두 프로그램 사이를 전환할 필요가 없습니다. ChatGPT에 비해 Github Copilot이 프로젝트 지원이 더 좋고, 상호작용도 더 친절하며, 일부 로컬 파일을 선택하여 AI를 **“훈련”**시킬 수 있어 생성되는 코드가 프로젝트에 더 잘 맞습니다.&lt;/p&gt;
&lt;h2 id=&#34;cursor-ai&#34;&gt;Cursor AI
&lt;/h2&gt;&lt;p&gt;최근에 새로운 AI 프로그래밍 IDE인 Cursor AI를 보았는데, 이 IDE는 Github Copilot을 기반으로 하고 있지만, 더 똑똑하고 파일을 직접 생성해 줄 수 있습니다&lt;/p&gt;
&lt;p&gt;간단히 사용해 봤는데 괜찮은 것 같긴 하지만, 현재 프로젝트에 대한 이해는 아직 부족하고, 로컬 프로젝트 파일이 많을 때는 큰 규모의 리팩토링이나 최적화 조정은 여전히 &lt;strong&gt;개발자가 작업을 분할해야 한다&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;예시 하나를 덧붙입니다: curso의 엔지니어링 모드로 전환하여 다음 내용을 입력하세요: 새로운 개인 이력서 웹페이지를 생성하고, 여러 가지 다른 스타일로 전환할 수 있도록 지원하며, 데이터 표시를 위해 몇몇 개인 정보를 채워 넣으세요&lt;/p&gt;
&lt;p&gt;몇 번이고 &lt;strong&gt;두었다 떼었다&lt;/strong&gt; 하는 과정을 거치면 다음과 같은 웹페이지를 얻을 수 있습니다. 물론 이 웹페이지는 비교적 간단하지만, 초보자에게는 아주 괜찮은 시작입니다.&lt;/p&gt;
&lt;p&gt;현재 등록 사용자는 고급 API를 150회 무료로 체험해 볼 수 있으며, 유료 사용자는 고급 API 사용이 5000회로 제한됩니다&lt;/p&gt;
&lt;p&gt;개인 이력서&lt;/p&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43; 비트 연산 기초: 비트별 값 가져오기 및 플래그 설정</title>
        <link>https://ttf248.life/ko/p/cpp-bitwise-operations-basics-flags/</link>
        <pubDate>Fri, 17 Jan 2025 02:23:56 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/cpp-bitwise-operations-basics-flags/</guid>
        <description>&lt;p&gt;실제 C++ 개발에서 비트 연산은 흔한 기술이며, 특히 시스템 상태, 플래그 또는 제어 비트를 처리할 때 매우 효율적인 솔루션을 제공합니다. 본 글에서는 예제를 통해 비트 연산을 사용하여 특정 플래그를 가져오고 설정하는 방법을 설명하겠습니다.&lt;/p&gt;
&lt;h3 id=&#34;비트-연산-기초-개념&#34;&gt;비트 연산 기초 개념
&lt;/h3&gt;&lt;p&gt;컴퓨터에서 데이터는 이진 비트(0과 1)로 저장됩니다. 비트 연산은 이러한 이진 비트에 대한 연산을 말합니다. C++에는 몇 가지 일반적인 비트 연산자가 있습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;비트 AND 연산 (&amp;amp;)는 특정 비트가 1인지 확인하는 데 사용됩니다&lt;/li&gt;
&lt;li&gt;비트 OR (|) : 특정 비트를 1로 설정하는 데 사용됩니다&lt;/li&gt;
&lt;li&gt;비트별 XOR(^) 연산은 특정 비트를 반전시키는 데 사용됩니다&lt;/li&gt;
&lt;li&gt;비트 반전(~)&lt;/li&gt;
&lt;li&gt;모든 비트를 몇 자리 왼쪽으로 이동합니다&lt;/li&gt;
&lt;li&gt;모든 비트를 지정된 자릿수만큼 오른쪽으로 이동합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 예제에서는 &lt;code&gt;unsigned short&lt;/code&gt; 타입의 변수 &lt;code&gt;wInfo&lt;/code&gt;에 대해 일련의 비트 연산을 수행하여 다양한 플래그를 통해 서로 다른 상태를 표현해야 합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;flowchart LR
    A[原始数值: 00010000] --&amp;gt; B[左移: 00010000 &amp;lt;&amp;lt; 1]
    B --&amp;gt; C[结果: 00100000]
    C --&amp;gt; D[右移: 00100000 &amp;gt;&amp;gt; 1]
    D --&amp;gt; E[结果: 00010000]

    subgraph 左移操作
        direction LR
        A --&amp;gt; B --&amp;gt; C
    end

    subgraph 右移操作
        direction LR
        C --&amp;gt; D --&amp;gt; E
    end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;요구사항-분석&#34;&gt;요구사항 분석
&lt;/h3&gt;&lt;p&gt;문제 설명에 따르면, 우리는 다양한 상태를 나타내기 위해 사용되는 16비트 플래그가 있습니다. 이러한 상태는 각각 다른 이진 비트를 통해 표현되며, 각 이진 비트는 특정 의미를 가집니다. 예를 들어:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;비트 0가 실패했습니까?&lt;/li&gt;
&lt;li&gt;비트 1 압축되었습니까?&lt;/li&gt;
&lt;li&gt;비트2 증분 업데이트인가?&lt;/li&gt;
&lt;li&gt;비트3에 후속 패키지가 있나요?&lt;/li&gt;
&lt;li&gt;정상 요청 또는 로그아웃&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;비트-연산을-사용하여-구현하세요&#34;&gt;비트 연산을 사용하여 구현하세요
&lt;/h3&gt;&lt;p&gt;우리는 비트 연산을 통해 이러한 플래그를 설정하고 가져올 것입니다. 구체적으로:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;각 자리 값 가져오기：어떤 한 자리의 값(0 또는 1)을 얻는다&lt;/li&gt;
&lt;li&gt;비트 설정: 특정 비트를 1로 설정합니다&lt;/li&gt;
&lt;li&gt;비트 단위로 지우기: 특정 비트를 0으로 설정합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;우리는 먼저 &lt;code&gt;unsigned short&lt;/code&gt; 타입의 변수 &lt;code&gt;wInfo&lt;/code&gt;를 정의하여 이러한 플래그들을 저장합니다. 그런 다음, 비트 연산을 통해 해당 플래그들을 확인하고 설정합니다.&lt;/p&gt;
&lt;h3 id=&#34;c-예제-코드&#34;&gt;C++ 예제 코드
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;bitset&amp;gt;

// 定义标志位常量
const unsigned short BIT_0_FAIL = 1 &amp;lt;&amp;lt; 0;    // bit0 是否失败
const unsigned short BIT_1_COMPRESSED = 1 &amp;lt;&amp;lt; 1; // bit1 是否压缩
const unsigned short BIT_2_INCREMENT = 1 &amp;lt;&amp;lt; 2;  // bit2 是否增量
const unsigned short BIT_3_HAS_MORE = 1 &amp;lt;&amp;lt; 3;   // bit3 是否有后续包
const unsigned short BIT_5_CANCEL = 1 &amp;lt;&amp;lt; 5;     // bit5 正常请求(0)或注销(1)

// 检查某一位是否为1
bool isBitSet(unsigned short wInfo, unsigned short bitMask) {
    return (wInfo &amp;amp; bitMask) != 0;
}

// 设置某一位为1
void setBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo |= bitMask;
}

// 清除某一位（设置为0）
void clearBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo &amp;amp;= ~bitMask;
}

int main() {
    // 假设wInfo的初始值为0
    unsigned short wInfo = 0;

    // 设置bit0（失败标志）
    setBit(wInfo, BIT_0_FAIL);
    
    // 设置bit1（压缩标志）
    setBit(wInfo, BIT_1_COMPRESSED);
    
    // 打印wInfo的二进制值
    std::cout &amp;lt;&amp;lt; &amp;quot;wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    // 检查各个标志位
    std::cout &amp;lt;&amp;lt; &amp;quot;bit0 (是否失败): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_0_FAIL) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit1 (是否压缩): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_1_COMPRESSED) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit2 (是否增量): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_2_INCREMENT) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit3 (是否有后续包): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_3_HAS_MORE) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit5 (是否注销): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_5_CANCEL) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;

    // 清除bit1（压缩标志）
    clearBit(wInfo, BIT_1_COMPRESSED);
    
    // 打印更新后的wInfo
    std::cout &amp;lt;&amp;lt; &amp;quot;Updated wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;코드 실행, 오래된 친구 추천: &lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wInfo (in binary): 0000000000000011
bit0 (是否失败): 是
bit1 (是否压缩): 是
bit2 (是否增量): 否
bit3 (是否有后续包): 否
bit5 (是否注销): 否
Updated wInfo (in binary): 0000000000000001
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;코드-설명&#34;&gt;코드 설명
&lt;/h3&gt;&lt;p&gt;플래그 비트는 비트 시프트 연산(&lt;code&gt;1 &amp;lt;&amp;lt; n&lt;/code&gt;)을 사용하여 정의합니다. 예를 들어, &lt;code&gt;1 &amp;lt;&amp;lt; 0&lt;/code&gt;은 &lt;code&gt;bit0&lt;/code&gt;에 해당하고, &lt;code&gt;1 &amp;lt;&amp;lt; 1&lt;/code&gt;은 &lt;code&gt;bit1&lt;/code&gt;에 해당하며, 이와 같은 방식으로 계속됩니다. 이렇게 하면 각 플래그 비트에 고유한 이진 위치를 할당하게 됩니다.&lt;/p&gt;
&lt;p&gt;특정 비트가 1인지 확인하려면 &lt;code&gt;isBitSet&lt;/code&gt; 함수가 비트 AND 연산 &lt;code&gt;wInfo &amp;amp; bitMask&lt;/code&gt;를 사용하여 이를 수행합니다. 해당 비트가 1이면 함수는 &lt;code&gt;true&lt;/code&gt;를 반환하고, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt;를 반환합니다.&lt;/p&gt;
&lt;p&gt;설정비트: &lt;code&gt;setBit&lt;/code&gt; 함수는 비트 OR 연산 &lt;code&gt;wInfo |= bitMask&lt;/code&gt;를 통해 특정 플래그 비트를 1로 설정합니다&lt;/p&gt;
&lt;p&gt;특정 비트 위치를 0으로 설정하기 위해 &lt;code&gt;clearBit&lt;/code&gt; 함수는 비트 AND 연산 &lt;code&gt;wInfo &amp;amp;= ~bitMask&lt;/code&gt;를 사용합니다&lt;/p&gt;
&lt;h3 id=&#34;요약&#34;&gt;요약
&lt;/h3&gt;&lt;p&gt;비트 연산을 통해 우리는 여러 상태 플래그를 효율적으로 처리할 수 있습니다. 실제 개발에서 이 기술은 특히 유용합니다. 예를 들어, 임베디드 개발, 네트워크 프로토콜, 시스템 상태 관리 등의 시나리오에서 비트 플래그를 사용하여 여러 개의 이진 상태를 표현함으로써 공간을 절약하고 효율성을 높일 수 있습니다.&lt;/p&gt;
&lt;p&gt;이 블로그 게시물이 C++에서 비트 연산을 사용하여 비트 값 가져오기 및 설정 방법을 이해하는 데 도움이 되기를 바랍니다. 이러한 기술을 숙달하면 효율적이고 유지 관리하기 쉬운 코드를 작성하는 데 매우 유용합니다!&lt;/p&gt;</description>
        </item>
        <item>
        <title>데스크탑을 2.5G 네트워크 카드로 업그레이드하여 로컬 영역 네트워크 연결 속도를 높입니다</title>
        <link>https://ttf248.life/ko/p/desktop-upgrade-to-25g-network-card-accelerate-lan-interconnection/</link>
        <pubDate>Fri, 10 Jan 2025 00:37:52 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/desktop-upgrade-to-25g-network-card-accelerate-lan-interconnection/</guid>
        <description>&lt;p&gt;데스크톱 하드웨어 연달아 출시, 앞선 글에서 PCIE 어댑터에 대해 언급했는데, 구형 SSD는 어떻게 됐을까요? 당연히 버려진 건 아니죠. 고장난 것도 아니고, 분해해서 1년 전 구매한 &lt;code&gt;메카니저 크리에이터 미니-3765H&lt;/code&gt;에 설치했습니다.&lt;/p&gt;
&lt;p&gt;새 장비, 하드웨어 사양은 여전히 훌륭합니다. 2.5G 이중 네트워크 포트, PCIE4.0, WiFi6.&lt;/p&gt;
&lt;p&gt;최근 이사한 집에는 개별 라우터가 없어 네트워크 연결이 모두 무선으로 되어 있습니다. 아수스 메인보드 데스크탑의 무선 카드 성능이 좋지 않거나, 라우터의 무선 접속이나 로컬 네트워크 간 업로드 속도 문제일 수도 있는데, 이로 인해 기기 간 속도가 빠르지 않습니다. 새로 2.5G 네트워크 카드를 구매하여 데스크탑에 설치했습니다.&lt;/p&gt;
&lt;p&gt;여기까지, 메인보드의 슬롯이 모두 채워졌습니다: 그래픽 카드, 무선 네트워크 카드, 2.5G 네트워크 카드, SSD PCIE 어댑터&lt;/p&gt;
&lt;h2 id=&#34;네트워크-설명&#34;&gt;네트워크 설명
&lt;/h2&gt;&lt;p&gt;두 대의 기기는 여전히 원래 무선 네트워크 어댑터를 통해 인터넷에 연결되지만, 두 기기 사이는 직접 네트워크 케이블로 연결되어 있으며 양쪽 모두 2.5G 네트워크 어댑터입니다. 두 기기를 네트워크 케이블로 직접 연결하는 방법은 자세히 설명하지 않겠습니다. 온라인에 많은 튜토리얼이 있습니다. 방화벽을 열어두는 것을 잊지 마세요. 원하는 한 대를 게이트웨이로 선택하면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
    A[机器1&amp;lt;br&amp;gt;IP: 192.168.4.1&amp;lt;br&amp;gt;子网掩码: 255.255.255.0&amp;lt;br&amp;gt;默认网关: - &amp;lt;br&amp;gt;自动获取DNS] --&amp;gt;|网线直连（2.5G）| B[机器2&amp;lt;br&amp;gt;IP: 192.168.4.2&amp;lt;br&amp;gt;子网掩码: 255.255.255.0&amp;lt;br&amp;gt;默认网关: 192.168.4.1&amp;lt;br&amp;gt;自动获取DNS];
    A --&amp;gt;|无线网卡| Internet;
    B --&amp;gt;|无线网卡| Internet;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;두-네트워크-구간-속도-측정&#34;&gt;두 네트워크 구간 속도 측정
&lt;/h2&gt;&lt;h3 id=&#34;라우터-로컬-네트워크&#34;&gt;라우터 로컬 네트워크
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\core\Desktop\iperf-3.1.3-win32&amp;gt;iperf3.exe -c 192.168.3.237
Connecting to host 192.168.3.237, port 5201
[  4] local 192.168.3.122 port 1656 connected to 192.168.3.237 port 5201
[ ID] Interval           Transfer     Bandwidth
[  4]   0.00-1.00   sec  9.17 MBytes  76.7 Mbits/sec
[  4]   1.00-2.00   sec  9.91 MBytes  83.2 Mbits/sec
[  4]   2.00-3.00   sec  8.74 MBytes  73.3 Mbits/sec
[  4]   3.00-4.00   sec  10.2 MBytes  85.2 Mbits/sec
[  4]   4.00-5.00   sec  9.23 MBytes  77.1 Mbits/sec
[  4]   5.00-6.00   sec  8.80 MBytes  73.9 Mbits/sec
[  4]   6.00-7.01   sec  8.00 MBytes  66.8 Mbits/sec
[  4]   7.01-8.00   sec  7.69 MBytes  64.9 Mbits/sec
[  4]   8.00-9.01   sec  9.72 MBytes  81.1 Mbits/sec
[  4]   9.01-10.01  sec  7.63 MBytes  63.6 Mbits/sec
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bandwidth
[  4]   0.00-10.01  sec  89.0 MBytes  74.6 Mbits/sec                  sender
[  4]   0.00-10.01  sec  89.0 MBytes  74.6 Mbits/sec                  receiver

iperf Done.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;직결-로컬-영역-네트워크&#34;&gt;직결 로컬 영역 네트워크
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\core\Desktop\iperf-3.1.3-win32&amp;gt;iperf3.exe -c 192.168.4.1
Connecting to host 192.168.4.1, port 5201
[  4] local 192.168.4.2 port 1524 connected to 192.168.4.1 port 5201
[ ID] Interval           Transfer     Bandwidth
[  4]   0.00-1.01   sec   178 MBytes  1.48 Gbits/sec
[  4]   1.01-2.00   sec   204 MBytes  1.72 Gbits/sec
[  4]   2.00-3.00   sec   214 MBytes  1.80 Gbits/sec
[  4]   3.00-4.00   sec   229 MBytes  1.92 Gbits/sec
[  4]   4.00-5.00   sec   202 MBytes  1.69 Gbits/sec
[  4]   5.00-6.00   sec   213 MBytes  1.79 Gbits/sec
[  4]   6.00-7.00   sec   230 MBytes  1.93 Gbits/sec
[  4]   7.00-8.00   sec   192 MBytes  1.61 Gbits/sec
[  4]   8.00-9.00   sec   220 MBytes  1.84 Gbits/sec
[  4]   9.00-10.00  sec   230 MBytes  1.93 Gbits/sec
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bandwidth
[  4]   0.00-10.00  sec  2.06 GBytes  1.77 Gbits/sec                  sender
[  4]   0.00-10.00  sec  2.06 GBytes  1.77 Gbits/sec                  receiver

iperf Done.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Hugo에 mermaid 지원 추가&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>華碩 마더보드 Z490 설치 디스크가 너무 많아 가끔씩 디스크 인식에 실패함</title>
        <link>https://ttf248.life/ko/p/asus-motherboard-z490-too-many-disks-intermittent-disk-recognition/</link>
        <pubDate>Fri, 10 Jan 2025 00:08:51 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/asus-motherboard-z490-too-many-disks-intermittent-disk-recognition/</guid>
        <description>&lt;p&gt;바로 위 내용에 이어, 갑자기 무선 네트워크 카드가 인식되지 않는 문제가 발생했는데, 파티션을 재구성하기 전에 인터넷에서 다른 해결책들을 찾아봤습니다. 예를 들어 메인보드 배터리를 제거하거나 전원을 15분 동안 끊는 방법, 최신 버전의 BOIS 드라이버로 업그레이드하는 방법 등이 있었지만 모두 문제였습니다.&lt;/p&gt;
&lt;p&gt;처리할 일이 더 있다고 생각하며 제한된 네트워크로 전환하고, 거실에서 인터넷 랜선을 방으로 끌어왔는데, 이 순간 또 문제가 발생했다. 유선 네트워크도 인식되지 않는다. 큰 결단을 내리고 시스템을 재설치했더니 가이드 파티션이 손상되었다. 계속해서 문제가 발생하지 않았다면 이렇게까지 고생하지 않았을 텐데. ASUS의 디스크 충돌은 일시적인 문제이며, 시스템 재부팅 시 불안정성을 유발한다.&lt;/p&gt;
&lt;p&gt;지난주 데스크탑에 새로운 디스크를 추가했는데, 장강메모리의 2TB SSD이고 M.2 인터페이스입니다. 그리고 어제 전원을 껐을 때까지 재부팅이 되지 않았습니다.&lt;/p&gt;
&lt;p&gt;디스크 전체 정보&lt;/p&gt;
&lt;h2 id=&#34;시스템-재설치&#34;&gt;시스템 재설치
&lt;/h2&gt;&lt;p&gt;시간을 계산해 보니 2년이나 시스템을 다시 설치하지 않았고, C 드라이브는 이미 공간이 부족하다. 윈도우즈의 오래된 문제로, 일상적인 각종 소프트웨어도 C 드라이브에 뭔가 저장하는 것을 좋아한다. 그래서 시스템을 다시 설치하기로 했다. 시스템 재설치 후 네트워크 카드 문제는 정상적으로 해결되었고, 다음 날에는 일상적인 개발 환경을 복원했다. 시스템 백업을 준비하던 중 새로운 문제가 발생했는데, 시스템 재부팅 후에 부트 파티션이 사라졌다.&lt;/p&gt;
&lt;p&gt;이전 기사의 단계를 따라 부트 파티션을 재건했지만, 안정적이지 않습니다. 재부팅 후 부트 파티션이 로드되지 않을 가능성이 있으며, 케이스를 건드리는 것을 의심하기 시작했을 때 하드 드라이브 선이 느슨해졌지만 몇 번 확인해도 문제는 없습니다.&lt;/p&gt;
&lt;h2 id=&#34;기억-회복&#34;&gt;기억 회복
&lt;/h2&gt;&lt;p&gt;몇 년 전 이 기계에 한 번 SSD를 추가한 적이 있는데, 그때는 새로운 PCIE 컨버터(그래픽 카드 인터페이스에 연결)를 구입해서 직접 메인보드에 설치하지 않았습니다. 이번에는 바로 메인보드에 설치했는데, 아마 메인보드 문제일 수도 있습니다.&lt;/p&gt;
&lt;p&gt;고체 변환기&lt;/p&gt;
&lt;h2 id=&#34;메인보드-설명서&#34;&gt;메인보드 설명서
&lt;/h2&gt;&lt;p&gt;메인보드 설명서에 문제가 있는데, 표시된 SATA 포트 위치와 실제 위치가 달라서 디스크가 너무 많아 포트에 모두 장착되어 있고, 기존 SSD들은 모두 SATA 인터페이스를 사용하고 있습니다. 메인보드 설명서에 따르면 포트 간 충돌이 존재하는데, 실제로 테스트해 보니 이 충돌은 불안정하게 발생하며, 발생하면 해당 디스크를 로드할 수 없게 됩니다. 마침 이 디스크가 시스템 디스크이고 부팅도 해당 디스크에 있기 때문에 부팅 실패가 발생합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/asus-motherboard-z490-too-many-disks-intermittent-disk-recognition/20250110002401.png&#34;
	width=&#34;807&#34;
	height=&#34;847&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Z490&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;95&#34;
		data-flex-basis=&#34;228px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;해결책&#34;&gt;해결책
&lt;/h2&gt;&lt;p&gt;PCIE 어댑터에 SSD를 다시 장착하니, 메인보드의 SATA 포트와의 충돌이 사라지고 시스템이 정상적으로 부팅되었습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>ESP 파티션, GPT 파티션 테이블과 윈도우 운영 체제의 협력 원리 탐구</title>
        <link>https://ttf248.life/ko/p/exploring-esp-gpt-and-windows-cooperation/</link>
        <pubDate>Thu, 09 Jan 2025 23:58:20 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/exploring-esp-gpt-and-windows-cooperation/</guid>
        <description>&lt;p&gt;어제 퇴근하고 집에 와서 늘 하던 대로 데스크탑을 켰는데, 시스템은 정상적으로 시작되었지만 무선 네트워크 카드를 로드할 수 없었습니다. 카드 연결이 풀렸다고 생각해서 분해 후 무선 네트워크 카드를 다시 장착했는데, 문제가 더 커져서 시스템이 아예 부팅되지 않고 부트 로더가 실패했습니다.&lt;/p&gt;
&lt;p&gt;오래간만이라 데스크톱을 만지작거린 터라 파티션 부팅이 좀 낯설다. DisGenius로 빈 파티션을 다시 분할하고(보통 디스크 전방에 분할한다), ESP 파티션으로 할당하는데(기본적으로 300M), PE 시스템에서 부트 설정을 재건하면 된다. 관련 자료는 인터넷에서 찾아볼 수 있다.&lt;/p&gt;
&lt;p&gt;새 ESP 파티션 생성&lt;/p&gt;
&lt;p&gt;MSR 파티션을 제거할 수 있습니다&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;컴퓨터 저장 공간의 세계에서 ESP 파티션, GPT 파티션 테이블, 그리고 Windows 운영체제는 밀접하게 연결되어 있으며, 각자 고유하고 중요한 역할을 수행하며 시스템의 안정적인 작동과 효율적인 관리를 함께 뒷받침합니다. 하지만 이들을 자세히 알아보기 전에, 컴퓨터 파티션 역사 속 “선배”라고 할 수 있는 MBR 파티션 테이블 형식을 언급하지 않을 수 없는데, 이는 후대의 기술들과 서로 상호 반영되어 기술 진화의 맥락을 더욱 돋보이게 합니다. 오늘 우리는 이러한 요소들의 내재적인 연관성과 정교함에 대해 자세히 분석해 보겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;일반적으로-mbr-파티션-테이블--기존-하드-디스크-파티션의-기초&#34;&gt;일반적으로 MBR 파티션 테이블 — 기존 하드 디스크 파티션의 “기초”
&lt;/h2&gt;&lt;p&gt;MBR은 주로 주 부트 레코드(Master Boot Record)의 약자로, 개인용 컴퓨터 탄생 초기부터 존재하며 수십 년간 하드 디스크 파티션 영역을 지배해 왔습니다&lt;/p&gt;
&lt;h3 id=&#34;기본-구조&#34;&gt;기본 구조
&lt;/h3&gt;&lt;p&gt;이것은 하드 디스크의 첫 번째 섹터, 즉 0번 섹터에 위치하며 512바이트 공간을 차지합니다. 이 512바이트는 주로 세 부분으로 나뉘는데, 첫째는 부트 로더 코드이며 컴퓨터가 시작될 때 운영 체제의 부트 로더를 로드하는 역할을 하며 일반적으로 446바이트입니다. 둘째는 디스크 파티션 테이블로 64바이트를 차지하며 최대 4개의 주 파티션 정보를 정의할 수 있습니다. 각 파티션 설명은 16바이트를 차지하며 파티션의 시작 헤드, 섹터, 실린더와 파티션 유형, 크기와 같은 중요한 매개변수를 기록합니다. 마지막 2바이트는 MBR 종료 플래그 &amp;ldquo;55 AA&amp;quot;이며 이 섹터를 유효한 MBR로 식별하는 데 사용됩니다.&lt;/p&gt;
&lt;h3 id=&#34;역사적-공적과-한계&#34;&gt;역사적 공적과 한계
&lt;/h3&gt;&lt;p&gt;초기에 MBR 파티션 테이블은 개인용 컴퓨터의 비교적 간단한 저장 요구 사항을 충분히 충족했습니다. 운영 체제가 하드 디스크 파티션을 원활하게 인식하고 데이터를 순서대로 저장하고 읽을 수 있도록 했습니다. 그러나 시대가 발전함에 따라 그 한계가 점점 더 분명해지고 있습니다. 한 가지는 64바이트의 파티션 테이블 공간으로 인해 최대 4개의 주 파티션만 분할할 수 있으며, 더 많은 파티션을 만들려면 다소 복잡한 확장 파티션 및 논리 파티션과 같은 방법을 사용해야 하므로 디스크 관리에 불편을 초래합니다. 다른 한편으로는 최대 2TB의 하드 드라이브 용량만 지원하므로 현재 수 TB에서 수십 TB에 이르는 대용량 하드 드라이브 앞에서 힘이 부족하며, 이는 저장 기술의 추가적인 발전을 제약하는 병목 현상이 되고 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;두-번째-esp-파티션--시스템의-보이지-않는-부팅-키&#34;&gt;두 번째, ESP 파티션 — 시스템의 “보이지 않는 부팅 키”
&lt;/h2&gt;&lt;p&gt;ESP는 EFI System Partition의 약자로, UEFI(통합 확장 펌웨어 인터페이스) 표준을 기반으로 하는 컴퓨터에 필수적인 특수 파티션입니다&lt;/p&gt;
&lt;h3 id=&#34;기능-특징&#34;&gt;기능 특징
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;부트 시퀀스&lt;/strong&gt;: 컴퓨터가 전원을 켜면 UEFI 펌웨어는 먼저 하드 디스크에서 ESP 파티션을 찾아 그 안에 저장된 부트 로더(예: Windows Boot Manager)를 읽어 운영체제를 시작합니다. 마치 정확한 열쇠처럼 시스템 부팅의 문을 열어주는 것과 같습니다. 없으면 시스템은 전원이 들어올 때 혼란에 빠져 어디로 가야 할지 모릅니다.&lt;/li&gt;
&lt;li&gt;저장 드라이버: ESP 파티션은 시스템 부팅 과정에서 필수적인 일부 드라이버를 저장하여 초기 부팅 단계에서 하드웨어 장치(하드 디스크 컨트롤러, 그래픽 카드 등)가 정상적으로 작동하도록 하고, 이후 운영체제의 원활한 인계를 위한 기반을 마련합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;공간-요구사항-및-형식&#34;&gt;공간 요구사항 및 형식
&lt;/h3&gt;&lt;p&gt;일반적으로 ESP 파티션의 권장 크기는 100MB ~ 500MB 사이이며, 일반적으로 200MB 정도 할당하면 기본적인 요구 사항을 충족할 수 있습니다. 파일 시스템 형식은 반드시 FAT32여야 하며, 이는 UEFI 펌웨어만이 FAT32 형식을 통해 부트 파일을 읽어들일 수 있기 때문입니다. 이러한 방식이 호환성과 플랫폼 간 상호 운용성을 보장합니다.&lt;/p&gt;
&lt;h2 id=&#34;셋-gpt-파티션-테이블--하드-디스크의-스마트-관리자&#34;&gt;셋, GPT 파티션 테이블 — 하드 디스크의 “스마트 관리자”
&lt;/h2&gt;&lt;p&gt;GPT(가이드 파티션 테이블), 즉 전역적으로 고유한 식별자 파티션 테이블은 기존의 MBR 파티션 테이블을 대체하기 위해 개발된 새로운 파티셔닝 방식입니다&lt;/p&gt;
&lt;h3 id=&#34;장점-부각&#34;&gt;장점 부각
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;대용량 지원&lt;/strong&gt;: 오늘날 데이터 폭발의 시대에 대용량 하드 디스크가 끊임없이 등장하고 있습니다. GPT 파티션 테이블은 MBR의 2TB 용량 제한을 돌파하여 이론적으로 최대 9.4ZB(제타바이트, 1ZB = 1024 EB, 1EB = 1024 PB, 1PB = 1024 TB)의 초대형 저장 공간을 지원하며, 막대한 양의 데이터를 저장할 수 있는 가능성을 제공합니다.&lt;/li&gt;
&lt;li&gt;구분 영역 수 증가: MBR의 경우 최대 4개의 주 파티션만 분할할 수 있는 것과 달리, GPT는 최대 128개의 파티션을 생성할 수 있어 사용자 및 시스템 관리자에게 큰 유연성을 제공합니다. 여러 개의 시스템 파티션, 데이터 파티션 또는 특정 용도를 위한 파티션을 할당하든 자유롭게 활용할 수 있습니다.&lt;/li&gt;
&lt;li&gt;신뢰성이 높습니다: GPT 파티션 테이블은 중복 백업 메커니즘을 채택하여 하드 디스크 헤드와 테일 각각에 파티션 테이블 정보를 저장합니다. 한 곳의 파티션 테이블이 손상되면 시스템은 자동으로 다른 백업에서 복구하므로, 파티션 테이블 오류로 인한 데이터 손실 위험을 크게 줄여 데이터 보안을 보장합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;구조-분석&#34;&gt;구조 분석
&lt;/h3&gt;&lt;p&gt;GPT 파티션 테이블은 여러 부분으로 구성되어 있으며, 보호 MBR(전통적인 BIOS와의 호환성을 위해 보존된 MBR 구조의 일부이지만 실제 파티션 관리에 사용되지는 않음), GPT 헤더(파티션 테이블 버전, 파티션 수, 파티션 테이블 크기와 같은 GPT 파티션 테이블의 기본 정보를 저장), 그리고 파티션 항목 배열(각 파티션 항목은 파티션의 시작 섹터, 종료 섹터, 파티션 유형 GUID, 파티션 고유 식별자와 같은 중요한 정보를 상세히 기록)을 포함합니다. 이러한 구조들은 서로 협력하여 하드 디스크 공간을 정확하게 계획하고 관리합니다.&lt;/p&gt;
&lt;h2 id=&#34;네-알겠습니다-윈도우-운영체제--사용자의-디지털-상호작용-세상&#34;&gt;네, 알겠습니다. 윈도우 운영체제 — 사용자의 “디지털 상호작용 세상”
&lt;/h2&gt;&lt;p&gt;윈도우는 전 세계적으로 널리 사용되는 운영체제로, 사람과 컴퓨터 하드웨어 간의 친근한 다리를 놓습니다&lt;/p&gt;
&lt;h3 id=&#34;esp-파티션과-gpt-파티션-테이블의-통합&#34;&gt;ESP 파티션과 GPT 파티션 테이블의 통합
&lt;/h3&gt;&lt;p&gt;UEFI 기반 Windows 시스템 설치 과정에서, 설치 프로그램은 자동으로 ESP 파티션을 생성하고 부트 파일을 배포합니다. 동시에 디스크는 GPT 파티션 테이블 형식으로 초기화되며, 시스템 예약 파티션(시스템 핵심 파일 저장 공간, 기존 BIOS 환경의 시스템 부트 파일 영역과 유사), Windows 시스템 파티션(시스템 핵심 파일이 설치되는 곳) 및 기타 사용자 정의 데이터 파티션 등이 구성됩니다. Windows 시스템은 GPT 파티션 테이블을 통해 각 파티션을 정확하게 식별하고 ESP 파티션을 통해 원활하게 부팅되며, 이 세 가지 요소는 매끄럽게 연결되어 사용자에게 쾌적한 부팅 및 사용 경험을 제공합니다.&lt;/p&gt;
&lt;h3 id=&#34;시스템-관리-및-최적화-기반&#34;&gt;시스템 관리 및 최적화 기반
&lt;/h3&gt;&lt;p&gt;Windows는 실행되는 동안 GPT 파티션 테이블의 장점을 최대한 활용하여 디스크 관리를 수행합니다. 예를 들어, 디스크 관리 도구에서 GPT 파티션을 쉽게 식별하고 사용자가 파티션을 생성, 삭제, 포맷하거나 파티션 크기를 조정하는 등 다양한 단계의 데이터 저장 요구 사항을 충족할 수 있습니다. 또한 시스템 업데이트, 소프트웨어 설치 등의 과정도 파티션 레이아웃과 밀접하게 관련되어 있으며, 합리적인 파티션 계획은 시스템 성능 및 안정성을 향상시키고 디스크 공간 부족이나 파티션 혼란으로 인해 발생하는 문제를 줄이는 데 도움이 됩니다.&lt;/p&gt;
&lt;h2 id=&#34;다섯째-실전-팁-유지-보수-및-문제-해결&#34;&gt;다섯째, 실전 팁: 유지 보수 및 문제 해결
&lt;/h2&gt;&lt;p&gt;이들의 밀접한 관계를 이해하면 일상적인 유지 보수와 문제 해결에 대한 절차가 생깁니다&lt;/p&gt;
&lt;h3 id=&#34;디스크-공간-관리&#34;&gt;디스크 공간 관리
&lt;/h3&gt;&lt;p&gt;ESP 파티션 공간을 정기적으로 확인하여 과도한 부팅 항목 관련 소프트웨어 설치로 인한 공간 부족으로 시스템 시작에 영향을 미치는 것을 방지합니다. GPT 파티션 하의 데이터 파티션에서는 합리적인 저장 공간 계획을 세우고, 불필요한 파일을 즉시 정리하여 단일 파티션이 가득 차서 시스템 운영에 영향을 미치지 않도록 합니다.&lt;/p&gt;
&lt;h3 id=&#34;문제-해결-시작&#34;&gt;문제 해결 시작
&lt;/h3&gt;&lt;p&gt;시스템 부팅에 실패한 경우, 먼저 ESP 파티션이 손상되었거나 파일이 누락되었는지 확인하십시오. UEFI 펌웨어에 내장된 부트 항목 복구 도구를 사용하거나 Windows 설치 미디어를 통해 복구 환경에 진입하여 ESP 파티션의 부트 파일을 재구성할 수 있습니다. GPT 파티션 테이블 오류가 의심되는 경우, 전문 디스크 도구(DiskGenius 등)를 사용하여 파티션 테이블 무결성을 확인하고 백업된 파티션 정보를 활용하여 파티션을 복구하십시오.&lt;/p&gt;
&lt;p&gt;ESP 파티션, GPT 파티션 테이블, 그리고 Windows 운영체제는 마치 정밀하게 협력하는 팀과 같이 각자의 전문성을 발휘하여 안정적이고 효율적인 컴퓨터 사용 환경을 구축합니다. 이들을 깊이 이해하면 시스템 설치 및 유지 보수 시 능숙하게 대처할 수 있을 뿐만 아니라 컴퓨터의 하위 실행 로직을 파악하고 디지털 세계를 자유롭게 탐험할 수 있습니다. 동시에 MBR 파티션 테이블의 흥망성쇠를 되돌아보면 기술 발전의 힘에 감탄하며, 이는 저장 기술이 끊임없이 전진하여 증가하는 데이터 저장 요구를 충족하도록 이끌고 있음을 깨닫게 됩니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>GCC, GLIBC 및 C&#43;&#43; 프로그램 호환성 문제 심층 이해</title>
        <link>https://ttf248.life/ko/p/deep-understanding-gcc-glibc-cpp-compatibility-issues/</link>
        <pubDate>Mon, 06 Jan 2025 19:51:16 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/deep-understanding-gcc-glibc-cpp-compatibility-issues/</guid>
        <description>&lt;p&gt;C++ 개발 분야에서 GCC와 GLIBC는 피할 수 없는 핵심 요소이며, 프로그램 출시 후 호환성 문제는 개발자를 끊임없이 괴롭힌다. 본 논문에서는 이들의 본질을 심층적으로 분석하고, 호환성 문제의 근원과 대응 전략을 탐구한다.&lt;/p&gt;
&lt;h2 id=&#34;하나-gcc-강력한-컴파일러-기반&#34;&gt;하나, GCC: 강력한 컴파일러 기반
&lt;/h2&gt;&lt;p&gt;정의와 기능&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC는 GNU 컴파일러 컬렉션의 약자로, GNU 프로젝트에서 개발한 오픈 소스 컴파일러 모음입니다. 이는 일반적인 컴파일러가 아니며, C, C++, Objective-C, Fortran, Ada 및 Go와 같은 다양한 주류 언어를 지원하여 크로스 플랫폼 개발을 위한 원스톱 솔루션을 제공합니다.&lt;/li&gt;
&lt;li&gt;C++를 예로 들어보면, 클래스, 템플릿, 함수 오버로딩과 같은 복잡한 특징을 포함하는 소스 파일을 작성할 때 GCC는 C++의 엄격한 문법 및 의미 규칙에 따라 고급 C++ 코드를 하위 레벨 기계가 이해하고 실행할 수 있는 명령어 시퀀스로 변환합니다. 이 과정은 어휘 분석, 구문 분석, 의미 분석, 최적화 및 코드 생성과 같은 여러 가지 정교한 단계를 포함합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;컴파일 과정 상세 설명&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;전처리 단계&lt;/strong&gt;: GCC는 먼저 소스 파일을 전처리합니다. 이 과정에서 &lt;code&gt;#&lt;/code&gt;로 시작하는 모든 전처리 지시를 처리합니다. 예를 들어, &lt;code&gt;#include&lt;/code&gt; 지시는 지정된 헤더 파일(C++ 입출력 스트림 작업에 사용되는 &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt;과 같이)의 전체 내용을 소스 파일의 해당 위치에 삽입하여 프로그램이 헤더 파일에 선언된 함수, 클래스와 같은 리소스를 사용할 수 있도록 합니다. &lt;code&gt;#define&lt;/code&gt; 지시로 정의된 매크로는 이 단계에서 펼쳐서 대체됩니다. 예를 들어, &lt;code&gt;#define PI 3.14159&lt;/code&gt;인 경우 소스 파일의 모든 &lt;code&gt;PI&lt;/code&gt;가 &lt;code&gt;3.14159&lt;/code&gt;로 바뀝니다. 전처리가 완료되면 소스 파일은 초기 “확장”을 거칩니다.&lt;/li&gt;
&lt;li&gt;컴파일 단계: 전처리된 파일은 컴파일 과정으로 들어가고, GCC는 C++ 언어 표준에 따라 소스 파일을 어셈블리 언어 코드로 변환합니다. 이 과정에서 코드 구조를 꼼꼼히 검사하여 클래스 상속, 다형성 구현의 정확성, 함수 호출 인자 일치 여부 등을 확인하며, 문법 및 의미 규칙에 위배되는 오류가 발견되면 즉시 에러를 발생시키고 컴파일 과정을 중단합니다. 예를 들어, 함수 선언과 정의된 인자 목록이 불일치하는 경우, GCC는 문제 지점을 정확하게 지적합니다.&lt;/li&gt;
&lt;li&gt;어셈블리 단계: 어셈블러는 이전 단계에서 생성된 어셈블리 코드를 기계어로 변환하여 &lt;code&gt;.o&lt;/code&gt; 확장자를 가진 목적 파일을 생성합니다. 이러한 목적 파일에는 기기가 직접 실행할 수 있는 이진 명령어가 포함되어 있지만, 일반적으로 완전한 프로그램은 여러 모듈로 구성되고 각 모듈 간의 함수 및 변수 참조 관계가 해결되지 않았기 때문에 독립적으로 실행될 수 없습니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;링크 단계&lt;/strong&gt;: 이는 실행 파일을 생성하는 마지막 스퍼트 단계입니다. 링커는 여러 목표 파일과 필요한 라이브러리 파일(정적 라이브러리 또는 동적 라이브러리)을 통합합니다. 예를 들어, C++ 표준 템플릿 라이브러리의 컨테이너 클래스를 사용할 때 링크 시에는 해당 라이브러리 구현 코드를 찾아야 하며, 프로그램 실행 시 &lt;code&gt;vector&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt; 등의 컨테이너 기능을 올바르게 호출할 수 있도록 보장하여 최종적으로 완전한 실행 파일을 생성합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;두-번째-glibc-c-프로그램-실행의-숨겨진-기반&#34;&gt;두 번째, GLIBC: C++ 프로그램 실행의 숨겨진 기반
&lt;/h2&gt;&lt;p&gt;본질과 작용&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GLIBC는 GNU C Library이며, GNU 생태계에서 C 표준 라이브러리의 구체적인 구현입니다. 이름에서 C가 강조되어 있지만, C++ 프로그램 역시 C의 기본 부분을 상속받기 때문에 GLIBC에 크게 의존합니다. 메모리 관리를 위한 &lt;code&gt;malloc&lt;/code&gt;(동적 메모리 할당), &lt;code&gt;free&lt;/code&gt;(메모리 해제) 함수와 같이 방대한 기본 함수를 제공하는데, 이는 C++에서 동적 배열이나 객체를 생성할 때 필수적입니다. 또한 &lt;code&gt;strcpy&lt;/code&gt;(문자열 복사), &lt;code&gt;strcat&lt;/code&gt;(문자열 연결)과 같은 문자열 처리 함수는 C++에 더 고급의 &lt;code&gt;string&lt;/code&gt; 클래스가 있더라도 하위 코드와의 상호 작용이나 최고의 성능을 추구할 때 여전히 사용됩니다. 뿐만 아니라 &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;와 같은 표준 입력/출력 함수 역시 C++ 초기 개발 단계나 성능에 민감하고 간결함을 추구하는 상황에서 자주 등장합니다.
운영 체제와의 협력&lt;/li&gt;
&lt;li&gt;GLIBC는 운영체제와 애플리케이션 간의 중요한 연결고리 역할을 합니다. Linux 시스템에서 C++ 프로그램이 파일을 열기 위해 &lt;code&gt;open&lt;/code&gt; 함수를 사용하는 등 시스템 호출을 시작하면 GLIBC는 프로그램의 요청을 운영체제 커널이 규정한 방식으로 캡슐화하여 커널에 전달하고, 커널 처리 완료 후 결과를 애플리케이션으로 다시 반환합니다. 이를 통해 애플리케이션은 파일 시스템, 네트워크, 프로세스 관리와 같은 다양한 시스템 리소스를 복잡한 운영체제 하위 수준의 시스템 호출 인터페이스 세부 사항을 깊이 이해하지 않고도 편리하게 사용할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;세-번째-c-프로그램-배포-후-호환성-문제-분석&#34;&gt;세 번째, C++ 프로그램 배포 후 호환성 문제 분석
&lt;/h2&gt;&lt;p&gt;GLIBC 버전 차이로 인한 호환성 문제&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다양한 Linux 배포판은 종종 서로 다른 버전의 GLIBC를 탑재하고 있습니다. C++ 프로그램이 높은 버전의 GLIBC 환경에서 컴파일되면, 의식하지 못 사이에 해당 버전에서 새롭게 추가된 특정 함수 기능이나 최적화된 함수 구현에 의존하게 될 수 있습니다. 예를 들어, 새로운 GLIBC 버전은 메모리 할당 알고리즘을 개선했으며, 프로그램은 런타임 시 이러한 새로운 알고리즘을 빈번히 활용하여 성능을 향상시킵니다. 만약 이 프로그램을 낮은 버전의 GLIBC 시스템에서 실행한다면, 해당 함수를 찾을 수 없거나 (해당 기능이 낮은 버전에 도입되지 않았기 때문입니다) 함수의 동작에 이상이 생길 수 있습니다 (오래된 함수 구현 로직과 새로운 버전 간의 차이로 인해). 이는 프로그램 충돌이나 결과 오류로 이어질 수 있습니다.
컴파일러 차이로 인한 호환성 문제&lt;/li&gt;
&lt;li&gt;비록 모두 GCC 컴파일러를 사용하더라도, 다른 버전의 GCC는 코드 생성, 표준 라이브러리 지원 및 C++ 기능 구현 방식에 차이가 있습니다. 최신 버전의 GCC는 C++ 최신 표준(예: C++20의 모듈, 코루틴 등)을 완벽하게 지원할 수 있지만, 이러한 최첨단 기능을 사용하는 프로그램이 구버전 GCC에서 컴파일하면 컴파일러가 새로운 문법 구조를 인식하지 못해 오류를 발생시킵니다. 심지어 문법 오류가 없더라도, 다른 GCC 버전 간의 최적화 전략이 다르기 때문에 생성된 기계 코드의 실행 효율성 및 메모리 사용량에 큰 차이가 있을 수 있으며, 성능이 중요한 환경에서는 프로그램의 동작 방식이 크게 달라질 수 있습니다.
시스템 아키텍처 차이로 인한 과제&lt;/li&gt;
&lt;li&gt;C++ 프로그램은 x86, ARM, PowerPC 등 다양한 하드웨어 시스템 아키텍처에서 실행될 수 있습니다. 각 아키텍처는 고유한 명령어 집합, 메모리 레이아웃 및 데이터 정렬 요구 사항을 가지고 있습니다. 예를 들어 데이터 정렬의 경우, x86 아키텍처에서 정상적으로 작동하는 구조체 데이터 저장 방식이 ARM 아키텍처에서는 정렬 규칙이 다르기 때문에 메모리 접근 이상을 일으켜 프로그램 오류를 유발할 수 있습니다. 또한 GCC는 서로 다른 아키텍처에 대해 컴파일할 때 생성되는 기계 코드의 차이가 매우 크며, 프로그램 내에 하드 코딩된 아키텍처 관련 명령어 또는 가정이 있는 경우, 여러 아키텍처에서 실행 시 빈번한 오류가 발생합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;네-가지-대응-호환성-문제-전략&#34;&gt;네 가지 대응 호환성 문제 전략
&lt;/h2&gt;&lt;p&gt;정적 링크 라이브러리의 활용&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;정적 링크 라이브러리 사용을 고려해 볼 수 있는데, 이는 프로그램이 의존하는 GLIBC와 같은 라이브러리 코드를 실행 파일에 직접 패키징하는 방식입니다. 이렇게 하면 프로그램은 런타임 시 대상 시스템의 특정 GLIBC 버전에 더 이상 의존하지 않으므로 GLIBC 버전 불일치로 인해 발생하는 문제를 효과적으로 피할 수 있습니다. 하지만 정적 링크는 실행 파일 크기를 크게 증가시키므로 저장 공간이 제한된 환경에서는 장단점을 신중하게 고려해야 합니다.
컨테이너화 배포&lt;/li&gt;
&lt;li&gt;Docker와 같은 컨테이너화 기술을 활용하여 C++ 프로그램과 필요한 실행 환경(특정 버전의 GCC, GLIBC 등)을 하나의 독립적인 컨테이너로 묶습니다. 어떤 기본 운영체제로 배포하든 컨테이너 내부에서는 항상 프로그램 개발 시의 환경 일관성을 유지하여 프로그램이 예상대로 작동하도록 하고, 다양한 환경에 대한 배포 복잡성을 크게 줄입니다.
호환성 테스트 및 지속적 통합&lt;/li&gt;
&lt;li&gt;다양한 GLIBC 버전, GCC 버전 및 일반적인 시스템 아키텍처를 포괄하는 종합적인 호환성 테스트 체계를 구축한다. 프로그램 개발 과정에서 지속적 통합 도구를 사용하여 다양한 환경에서 정기적으로 자동화된 테스트를 수행하고, 호환성 문제가 발견되면 즉시 수정하여 잠재적인 위험을 초기 단계에서 제거함으로써 프로그램 출시 후의 안정성을 확보한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;결론적으로, GCC와 GLIBC의 작동 방식을 깊이 이해하고, C++ 프로그램 호환성 문제의 근원을 정확하게 파악하며, 유연하게 대응 전략을 활용하는 것은 모든 C++ 개발자가 안정적이고 크로스 플랫폼 애플리케이션을 구축하기 위한 필수적인 기술입니다. 그래야만 우리의 C++ 작품은 다양한 기술 생태계에서 자유롭게 이동할 수 있습니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>Windows에 내장된 디스크 정리 도구: 저장 공간</title>
        <link>https://ttf248.life/ko/p/windows-disk-cleanup-storage/</link>
        <pubDate>Mon, 06 Jan 2025 19:29:45 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/windows-disk-cleanup-storage/</guid>
        <description>&lt;p&gt;어떤 버전부터인지는 정확히 기억나지 않지만, &lt;code&gt;Windows 11&lt;/code&gt;에서 디스크 정리 도구가 크게 개선되어 훨씬 더 스마트해졌습니다&lt;/p&gt;
&lt;p&gt;중요한 것은 공식 도구라는 점이며, 파일 삭제 오류가 없고, 광고도 없고, 팝업창도 없고, 백그라운드 프로세스도 없으며, 불필요한 기능이 전혀 없습니다&lt;/p&gt;
&lt;p&gt;Windows 11에서 설정-시스템-저장 공간-임시 파일로 이동하여 디스크 정리 도구를 열 수 있습니다&lt;/p&gt;
&lt;p&gt;저장 인터페이스&lt;/p&gt;
&lt;p&gt;일반 사용자는 &lt;code&gt;청소 제안&lt;/code&gt;을 선택하면 시스템에서 사용 상황에 따라 몇 가지 제안을 제공합니다&lt;/p&gt;
&lt;p&gt;개발자로서 저의 디스크에는 임시 파일이 많기 때문에 &lt;code&gt;임시 파일&lt;/code&gt;을 선택했습니다. 그 안에는 &lt;code&gt;Visual Studio&lt;/code&gt; 임시 파일, &lt;code&gt;Windows Update&lt;/code&gt; 임시 파일 등 다양한 임시 파일들이 포함되어 있습니다.&lt;/p&gt;
&lt;p&gt;임시 파일&lt;/p&gt;</description>
        </item>
        <item>
        <title>도커 국내 이미지 프록시 만료</title>
        <link>https://ttf248.life/ko/p/docker-domestic-mirror-failure/</link>
        <pubDate>Sat, 04 Jan 2025 18:29:25 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/docker-domestic-mirror-failure/</guid>
        <description>&lt;p&gt;국내 서버에 도커를 배포하고, 배포 후 회사에서 이미지 센터를 제공하지 않는 경우, 개발자가 먼저 해야 할 일은 국내 이미지 가속 주소를 설정하는 것입니다. 그런데 오늘 우연히 서버 한 대가 있고, 이미지 가속 주소를 설정했는데 이미지를 가져오려고 하면 계속 가져오지 못합니다.&lt;/p&gt;
&lt;p&gt;데몬 오류: &lt;code&gt;https://registry-1.docker.io/v2/&lt;/code&gt;에서 헤더를 기다리는 동안 연결을 기다리던 중 요청이 취소되었습니다(Client.Timeout 초과)&lt;/p&gt;
&lt;p&gt;두 날이 지났지만 모든 서버가 복구되었고, 이 일이 검색어 순위에 오르지 않고, 국내 모든 미러 대리들이 멈췄다&lt;/p&gt;
&lt;h2 id=&#34;오류-해결-및-복구-시도&#34;&gt;오류 해결 및 복구 시도
&lt;/h2&gt;&lt;p&gt;처음에 다른 미러 이미지 주소로 전환을 시도하여 문제를 해결하고자 했지만, 기대와 달리 문제는 여전히 발생했습니다&lt;/p&gt;
&lt;p&gt;곧바로, 로컬 DNS 설정을 수정하기 시작하여 네트워크 해상도 수준에서 돌파구를 찾으려 했지만, 안타깝게도 여러 번의 디버깅 끝에 문제점은 여전히 남아 있었다&lt;/p&gt;
&lt;p&gt;현재, 로컬 네트워크의 안정성이 크게 의심받고 있어 즉시 휴대폰 핫스팟으로 전환하여 가능한 로컬 네트워크 문제점을 우회하려 했지만 결과는 낙담스러웠고, 문제는 전혀 개선될 기미가 보이지 않습니다&lt;/p&gt;
&lt;h2 id=&#34;문제-확산&#34;&gt;문제 확산
&lt;/h2&gt;&lt;p&gt;현재 &lt;strong&gt;국내에 배치된 몇 대의 서버&lt;/strong&gt;가 있으며, 모두 Docker 환경이 설치되어 있습니다. 이러한 서버에서 이미지를 가져오려고 시도했었는데, 다른 방법을 찾을 수 있을 것이라고 생각했지만 결과적으로는 단 한 건도 성공하지 못했고, 보고되는 오류 메시지가 모두 동일했습니다. 이는 문제가 특정 장비에 국한된 것이 아니라는 것을 의미합니다.&lt;/p&gt;
&lt;p&gt;더 자세히 조사해 보니 미러 에이전트가 갑자기 작동하지 않음을 확인했습니다. 이 긴급한 순간에 해외 머신으로 빠르게 전환하여 시도했고, 다행히 이미지 풀링은 여기서 정상적으로 복구되었습니다. 이는 문제의 원인이 국내 네트워크 링크나 관련 설정에 있을 가능성이 높다는 것을 의미합니다.&lt;/p&gt;
&lt;h2 id=&#34;전략-조정-우회-해결&#34;&gt;전략 조정: 우회 해결
&lt;/h2&gt;&lt;p&gt;국내에서 직접 이미지를 가져오는 경로가 여러 차례 막히고 해외 이미지는 정상적으로 접근할 수 있다는 점을 고려하여, 프로젝트를 최대한 빠르게 진행하기 위해 우회적인 전술을 채택합니다. 먼저 해외 서버로 전환하여 필요한 이미지를 성공적으로 가져온 후, 이를 국내 이미지 저장소에 푸시하여 “데이터 다리”를 구축합니다.&lt;/p&gt;
&lt;p&gt;동시에 Dockerfile 파일도 수정하여 이미지 주소를 국내 환경에 적합한 주소로 변경하고, 다시 이미지를 빌드하여 최종적으로 성공적으로 배포했습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>야만 자본주의 시대의 종말: 리그 오브 레전드 e스포츠 시대 종료</title>
        <link>https://ttf248.life/ko/p/end-of-era-league-of-legends-esports/</link>
        <pubDate>Tue, 31 Dec 2024 07:19:39 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/end-of-era-league-of-legends-esports/</guid>
        <description>&lt;p&gt;e-스포츠 산업은 지난 10여 년간 급속한 성장을 거듭하며 전 세계적으로 간과할 수 없는 문화 현상이 되었습니다. 특히 ‘리그 오브 레전드(League of Legends, 약칭 LOL)’를 대표하는 MOBA 장르 게임은 플레이어에게 경쟁의 즐거움을 제공했을 뿐만 아니라 자본에 강력한 동력을 불어넣어 일련의 e-스포츠 플랫폼과 이벤트의 번영을 촉진했습니다. 하지만 이러한 상황에도 불구하고 자본 유입과 팬 엔터테인먼트 산업의 부상과 함께 점차 쇠퇴기로 접어들고 있습니다. 팽화TV의 부상과 몰락, 그리고 두유와 후야의 경쟁은 ‘야만적인 자본주의 시대’의 종식을 알렸으며, e-스포츠 업계의 천지人和(성공을 위한 환경, 시기, 인물) 역시 변화를 시작하는 듯합니다.&lt;/p&gt;
&lt;h2 id=&#34;제1장-e스포츠의-부상과-자본-유입&#34;&gt;제1장: e스포츠의 부상과 자본 유입
&lt;/h2&gt;&lt;p&gt;초기의 이스포츠: 아마추어에서 프로로&lt;/p&gt;
&lt;p&gt;초기 e스포츠 산업은 특히 중국 시장에서 비교적 소규모로 시작했지만, 많은 플레이어들이 게임에 대한 열정으로 스타크래프트, 도타 등 게임의 경쟁에 참여했습니다. 하지만 진정한 e스포츠의 부흥은 리그 오브 레전드의 출시와 홍보를 통해 시작되었습니다. 2011년 리그 오브 레전드가 중국 시장에 공식적으로 진출한 이후, e스포츠는 점차 소규모 커뮤니티에서 대중 문화의 일부로 발전했습니다. 특히 2013년부터 LPL(중국 프로 리그)이 점진적으로 형성되면서 리그 오브 레전드는 중국 e스포츠 산업의 핵심으로 자리 잡았습니다.&lt;/p&gt;
&lt;p&gt;자본의 광적인 유입: 판다 TV와 e스포츠 스트리밍 플랫폼의 부상&lt;/p&gt;
&lt;p&gt;2015년은 중국 e스포츠 업계의 분수령점이었다. 자본의 유입으로 e스포츠는 단순한 경기 대회를 넘어 더욱 거대한 산업체인으로 전환했다. 판다TV는 대표적인 사례 중 하나로, 과잉 자본의 산물이었다. 왕스충(판다 라이브 방송의 창립자 중 한 명)이 투자한 판다TV는 혁신적인 콘텐츠와 막대한 투자를 통해 많은 시청자와 사용자를 끌어모으며 빠르게 부상했다. 하지만 이는 자본이 “야만적”으로 유입되는 전형적인 예시였다—자본이 시장을 미친 듯이 추격할 때는 인내심과 장기적인 안목이 부족한 경우가 많다. 판다TV는 자금과 인력 투입으로 단기간에 일정한 성과를 거두었지만, 관리 문제와 자본에 대한 과도한 의존으로 고환되어 2019년에 파산했다.&lt;/p&gt;
&lt;p&gt;라이브 플랫폼 경쟁: 두유와 후야의 ‘자본 전쟁’&lt;/p&gt;
&lt;p&gt;판다TV의 몰락은 e스포츠 스트리밍 업계의 쇠퇴를 가져오지 않았고, 오히려 두유와 후야 등 플랫폼의 부상을 촉진했다. 두유와 후야는 빠르게 e스포츠 업계의 선두 주자로 자리매김했으며, 경쟁 또한 더욱 치열해졌다. 두유는 초기에 리그 오브 레전드 프로 리그 중계와 최고 수준의 스트리머 영입을 통해 e스포츠 스트리밍의 벤치마크가 되었으며, 후야는 e스포츠 대회 투자 확대 및 자체 플랫폼 다각화 전략을 통해 두유와의 격차를 점차 줄여나갔다.&lt;/p&gt;
&lt;p&gt;이 과정에서 자본은 다시 한번 엄청난 역할을 했다. 2018년에 斗鱼(Douyu)는 성공적으로 상장했고, 후야(Huya) 또한 같은 해에 IPO를 진행했다. 자본의 빠른 유입은 업계의 높은 집중도를 가져왔고, 동시에 플랫폼 간의 진행자, 저작권 등에서의 치열한 경쟁을 야기하여 “자본 전쟁”이라는 양상을 형성했다.&lt;/p&gt;
&lt;h2 id=&#34;제2장-팬-엔터테인먼트화와-e스포츠의-융합&#34;&gt;제2장: 팬 엔터테인먼트화와 e스포츠의 융합
&lt;/h2&gt;&lt;p&gt;팬엔터테인먼트화 물결: 자금 유입이 다양한 엔터테인먼트 프로젝트로&lt;/p&gt;
&lt;p&gt;자본이 e스포츠 산업에 대한 투자를 다시 늘리면서, e스포츠 플랫폼의 콘텐츠는 점차 엔터테인먼트화되고 있습니다. e스포츠 진행자는 경기 해설 및 대회 중계에만 머무르지 않고 노래, 춤, 실시간 소통 등 다양한 엔터테인먼트 형태로 확장하기 시작했습니다. 플랫폼의 콘텐츠가 더욱 풍부해지고 있으며, e스포츠를 중심으로 하지만 다양한 엔터테인먼트 요소를 포함하는 콘텐츠 생태계를 점진적으로 형성하고 있습니다.&lt;/p&gt;
&lt;p&gt;그러나 팬 엔터테인먼트화는 문제점도 가져왔다—이전에는 전념했던 게임 문화가 점차 주변화되고, 그 자리에 오락 중심의 경향이 자리 잡았다. 이러한 경향으로 인해 원래 e스포츠 문화를 깊이 사랑하던 일부 관객들은 떠나고 싶어 하는 감정을 느끼게 되었고, 자본은 다른 엔터테인먼트 분야로 더 많은 관심을 돌리기 시작했다. 자본의 과도한 유입과 이윤 추구는 e스포츠 산업의 본질을 점차 흐릿하게 만들었고, 원래 경쟁을 핵심으로 했던 가치관이 약화되기 시작했다.&lt;/p&gt;
&lt;p&gt;범엔터테인먼트 산업의 부상: 자본의 철수와 전환&lt;/p&gt;
&lt;p&gt;단편 동영상 플랫폼, 라이브 스트리밍 플랫폼 및 연예계 등 다양한 엔터테인먼트 산업의 부상과 함께 자본은 점차 게임에서 더 광범위한 엔터테인먼트 콘텐츠로 자금을 돌리고 있습니다. 이 과정에서 텐센트, 알리바바, 바이트댄스 등 거대 기업들도 더 이상 게임 프로젝트에만 의존하여 수익을 창출하는 것이 아니라 영화, 음악, 단편 동영상 등의 분야에 대한 투자를 확대하고 있습니다. 특히 바이트댄스의 부상은 틱톡과 같은 단편 동영상 플랫폼의 폭발적인 성장을 통해 e스포츠의 명성을 다른 엔터테인먼트 콘텐츠로 가리고 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;제3장-리그-오브-레전드의-청황불접-시대적-특혜가-쇠퇴하다&#34;&gt;제3장: 리그 오브 레전드의 “청황불접”: 시대적 특혜가 쇠퇴하다
&lt;/h2&gt;&lt;p&gt;2011년 《리그 오브 레전드》가 중국 시장에 진입한 이후, 거의 중국 e스포츠 업계의 대명사가 되었으며 수많은 프로 선수, 팀과 대회들을 배출하고 거대한 e스포츠 산업 생태계를 형성했습니다. 하지만 10여 년이 지난 지금, 중국 e스포츠를 이끌어온 《리그 오브 레전드》는 “세대교체” 단계에 접어들고 있습니다. 특히 최근 몇 년간 《리그 오브 레전드》의 영향력은 점차 하락하고 있으며 심지어 뚜렷한 쇠퇴의 조짐을 보이고 있습니다.&lt;/p&gt;
&lt;p&gt;플레이어 그룹의 “단층”
가장 뚜렷한 변화는 플레이어 계층의 단절입니다. 처음에는 e스포츠의 빠른 성장이 대규모 청소년 플레이어들의 지지를 얻었으며, 그들 중 많은 이들이 리그 오브 레전드를 통해 프로게이머나 관중이 되었습니다. 그 세대는 &amp;lsquo;시대적 특혜&amp;rsquo; 속에서 성장한 것으로 보이며, LOL이 제공하는 경쟁적인 매력에 몰두하며 전체 산업의 빠른 팽창을 이끌었습니다. 하지만 시간이 흐르면서 이러한 플레이어들은 점차 성장하여 사회로 진출하고 다른 삶과 직업 방향으로 전환했습니다. 동시에 새로운 세대의 젊은 플레이어들은 리그 오브 레전에 대한 관심이 예전만큼 뜨겁지 않으며, e스포츠의 관중층에는 뚜렷한 연령 편향과 흥미 저하가 나타나고 있습니다.&lt;/p&gt;
&lt;p&gt;게임 콘텐츠의 “피로감”
《리그 오브 레전드》는 여러 차례의 업데이트와 개편을 거쳤음에도 불구하고 여전히 일정한 경쟁 매력을 유지하고 있지만, 게임 자체의 콘텐츠 혁신은 다소 지쳐 보이는 듯합니다. 매년 출시되는 버전 업데이트, 영웅 밸런스 조정 및 새로운 플레이 방식 도입은 근본적으로 플레이어들의 신선함에 대한 요구를 충족시키지 못하는 것 같습니다. 동시에 MOBA 장르 게임 시장이 점차 포화 상태가 되고, 다른 장르의 게임(《왕자영웅》、《和平精英》 등)이 급부상하며 《리그 오브 레전드》의 많은 플레이어들을 흡수했습니다. 이러한 경쟁 구도는 《리그 오브 레전드》가 “추격자” 역할을 벗어나지 못하도록 만들고 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;결론적으로-e스포츠-산업의-미래는-어떻게-될-것인가&#34;&gt;결론적으로, e스포츠 산업의 미래는 어떻게 될 것인가?
&lt;/h2&gt;&lt;p&gt;e스포츠 산업은 마치 허공에서 솟아오른 고층 건물과 같습니다. 과도한 자금이 인터넷 업계에 떠돌아다니며 다음번 기회를 찾고 있는데, e스포츠 산업 또한 그들의 목표 중 하나가 되었습니다. 막대한 인구를 바탕으로 e스포츠 산업은 짧은 시간 안에 엄청난 성공을 거두었지만, 이 성공은 굳건한 토대 위에 세워진 것이 아닙니다. 자본의 과도한 유입, 인재 부족, 그리고 소프트웨어 콘텐츠의 취약함 등 이러한 문제들은 e스포츠 산업의 건전한 발전을 가로막고 있습니다.&lt;/p&gt;
&lt;p&gt;대학교 시절 이전에는 게임을 많이 즐기지 않았고, 롤은 한 세대를 함께 성장시킨 게임이라고 할 수 있습니다. 결승전을 그렇게 많이 봤는데, 입장에서 한국 선수들과 비교했을 때, 특히 Faker를 보면 국내 선수들은 큰 대회 기간 동안 항상 주눅 드는 느낌입니다. 선수들의 심리적 압박이 크다는 것을 알고 있고, 이 업계도 10년 이상 발전했는데, 선수들의 정신적인 문제는 팀에서 중요하게 다뤄야 하지만 그렇지 못했고, 결국 국내에서는 여전히 선수 개인의 재능에 의존하는 방식입니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>게임에서 가족으로: 우리는 왜 성장하면서 가상 세계를 떠나는 걸까</title>
        <link>https://ttf248.life/ko/p/from-games-to-family-why-we-drift-away-from-virtual-worlds/</link>
        <pubDate>Tue, 31 Dec 2024 07:11:05 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/from-games-to-family-why-we-drift-away-from-virtual-worlds/</guid>
        <description>&lt;p&gt;어렸을 때 몰래 집에서 TV로 탱크 대전, 슈퍼 마리오, 컨트라 같은 게임을 했던 것도 즐거웠지만, 조카랑 몰래 집 컴퓨터로 에이지 오브 엠파이어를 했던 것도 좋았고, 아니면 대학에 가서 동기들과 함께 데몬즈 콜, 리그 오브 레전드를 했던 것도 다 재밌었던 것 같아&lt;/p&gt;
&lt;p&gt;어릴 때는 삶의 고민 없이, 놀 때에는 정말 온 마음을 다해 빠져들었는데, 그 몰입감이 다시는 찾을 수 없는 것 같아&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;시대의 변화와 사회의 진보에 따라, 예전에는 활발하게 활동하던 가상 세계 속 우리들이 점차 깨닫게 되었다. 한때 즐거움과 경쟁으로 가득했던 게임 플랫폼이 우리 삶에서 멀어지고 있다는 것을. 게임 소셜 링크의 단절은 플레이어들의 이탈을 동반하는데, 이는 기술 발전과 게임 자체의 변화뿐만 아니라, 우리 삶의 중심이 변화했기 때문이다. 나이가 들어감에 따라 우리는 결혼과 출산을 시작하며, 삶의 주류는 개인적인 즐거움에서 가족 책임으로 점차 전환된다. 오늘, 이러한 추세 뒤에 숨겨진 근본적인 이유에 대해 이야기해 보자.&lt;/p&gt;
&lt;h2 id=&#34;게임-소셜의-사라짐-가상-세계와-현실-세계의-줄다리기&#34;&gt;게임 소셜의 사라짐: 가상 세계와 현실 세계의 줄다리기
&lt;/h2&gt;&lt;p&gt;많은 사람들의 청춘 시절에 게임은 단순한 오락이 아닌, 소통의 방식이었다. 인기 있는 멀티플레이 온라인 게임은 게임 내 도전과 경쟁을 제공할 뿐만 아니라 전 세계 플레이어들을 연결하고 가상 소셜 서클을 구축했다. 그 시절 친구들과 함께 던전을 돌고 팀을 이루어 PK를 하는 것은 일상의 일부였다. 늦은 밤 음성 채팅으로 서로의 일상을 공유했던 시간들은 우리 기억 속에 남았다.&lt;/p&gt;
&lt;p&gt;하지만 시간이 지나면서 점점 더 많은 플레이어들이 이러한 가상 소셜 경험이 영원한 매력을 가지지 않는다는 것을 발견했습니다. 게임의 업데이트와 변화, 다양한 소셜 플랫폼의 등장으로 인해 플레이어들은 점차 게임 밖에서 더 많은 상호작용 방식을 찾았습니다. 게임 속 친구들은 서서히 우리 삶의 시야에서 사라지고, 원래 활발하게 활동하던 게임 내 소셜 연결고리 또한 보이지 않게 끊어져 버렸습니다.&lt;/p&gt;
&lt;h2 id=&#34;게임과-책임-성인-후반기-삶의-중점-전환&#34;&gt;게임과 책임: 성인 후반기 삶의 중점 전환
&lt;/h2&gt;&lt;p&gt;성인이 된 후, 삶의 책임이 점차 늘어난다. 많은 젊은이들이 예전에 게임에 많은 시간을 쏟았지만, 직장 생활을 시작하거나 파트너와 함께 살거나 가정을 꾸리면서, 이전에는 필수적으로 여겨졌던 오락 활동들은 현실적인 책임에 밀려나기 시작한다. 결혼과 출산, 부모님 간병까지, 이러한 삶의 중요한 책임들 때문에 사람들은 에너지와 시간을 선택해야만 한다.&lt;/p&gt;
&lt;p&gt;게임은 과거가 되었고, 그 자리를 가족의 우선순위가 대신했습니다. 예전 게임에서 “분투”했던 많은 젊은이들이 점차 현실에서의 삶이 가장 중요한 과제라는 것을 깨닫습니다. 특히 아이를 갖게 된 후에는 삶의 중심이 완전히 가정으로 쏠리면서 게임은 서서히 삶의 주변부로 밀려나고 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;게임에서-가정으로-삶의-변화는-우리의-오락-방식을-어떻게-바꾸는가&#34;&gt;게임에서 가정으로: 삶의 변화는 우리의 오락 방식을 어떻게 바꾸는가
&lt;/h2&gt;&lt;p&gt;우리 삶의 경험 속에서 가족은 가장 중요한 구성 요소 중 하나입니다. 그리고 가족 생활에 들어가면 시간과 에너지의 분배는 더욱 구체적이고 제한됩니다. 자녀를 돌보고 배우자를 함께하며 많은 젊은 부모들은 자신이 예전에 열정적으로 즐기던 게임에 충분한 시간을 할애하지 못한다는 것을 발견합니다. 심지어 때로는 게임 업데이트나 새로운 콘텐츠를 더 이상 추구하지 않기도 합니다. 점차적으로 소셜 미디어 플랫폼과 오프라인 친척 및 친구들과의 교류가 더 많은 사람들의 교제 방식이 되었습니다.&lt;/p&gt;
&lt;p&gt;이것은 우리가 오락 활동을 완전히 포기하는 것이 아니라, 현재 생활 단계에 더 적합한 방식을 선택하는 것을 의미합니다. 게임을 통해 관계를 유지하던 많은 친구들이 삶의 궤도가 달라짐에 따라 가족 모임, 식사, 단거리 여행 등 다른 방식으로 연락을 유지할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;가상-세계와의-작별-우리는-이-변화를-어떻게-바라볼-것인가&#34;&gt;가상 세계와의 작별: 우리는 이 변화를 어떻게 바라볼 것인가?
&lt;/h2&gt;&lt;p&gt;게임에 푹 빠져 살던 많은 사람들에게 게임과의 소통을 마치는 일은 쉽지 않다. 결국, 우리에게 즐거움과 성취감을 선사했던 그 가상 세계는 이미 우리의 기억 일부가 되었다. 하지만 이별이 완전히 단절되는 것을 의미하는 것은 아니며, 삶의 변화에 따라 우리는 현실에서의 역할을 조화시키기 위해 다른 선택을 하기 시작한다. 나이가 들어감에 따라 우리는 순수한 소년에서 책임감을 가진 어른으로 성장하고, 게임은 여전히 그 가치를 지니지만 더 이상 삶의 주류가 될 수 없다.&lt;/p&gt;
&lt;p&gt;사실 이 변화는 인간의 적응력의 한 측면을 반영하기도 합니다. 즉, 우리는 다양한 단계에 따라 우리의 관심사와 생활 방식을 조정할 수 있다는 것입니다. 책임감과 가족이 삶의 중심이 되면 게임이나 소셜 활동은 더 이상 우선순위가 아니게 되고, 가끔씩 즐기는 취미로 변하게 됩니다.&lt;/p&gt;
&lt;h2 id=&#34;미래의-게임-어쩌면-또-다른-소속감-물결이-찾아올-것이다&#34;&gt;미래의 게임: 어쩌면 또 다른 “소속감” 물결이 찾아올 것이다
&lt;/h2&gt;&lt;p&gt;물론, 사회 발전과 기술의 진보에 따라 게임의 형태와 내용도 끊임없이 진화하고 있습니다. 예를 들어, 요즘의 멀티플레이 온라인 게임은 더욱 가볍고 유연한 방식으로 발전하기 시작했으며, 심지어는 가족 상호작용과 부모-자녀 관계를 더 중시하는 디자인의 게임도 있습니다. 미래에는 아마도 가족 생활에 더 잘 녹아들고 플레이어에게 더욱 건강하고 균형 잡힌 소셜 경험을 제공할 수 있는 더 많은 게임 형태를 볼 수 있을 것입니다.&lt;/p&gt;
&lt;p&gt;많은 사람들이 &amp;ldquo;어릴 때의 놀이&amp;quot;를 이야기할 때 여전히 그리움과 열정으로 가득하듯이, 미래의 우리 역시 어느 순간 갑자기 예전에 즐겼던 게임을 새로운 이해와 깨달음 속에서 다시 떠올려 그 가상 세계에 다시 들어가게 될지도 모른다&lt;/p&gt;
&lt;h2 id=&#34;삶은-변화하지만-사랑은-변치-않는다&#34;&gt;삶은 변화하지만, 사랑은 변치 않는다
&lt;/h2&gt;&lt;p&gt;게임이든 가족이든, 인생의 변화는 언제나 우리와 함께 성장합니다. 그 과정에서 우리는 비록 가상 세계가 무한한 즐거움과 자극을 주지만 결국 현실로 돌아오고, 가장 따뜻한 곳—가족으로 돌아온다는 것을 깨닫습니다. 게임을 떠나는 것에 아쉬워할 필요는 없습니다. 인생의 각 단계마다 고유한 의미가 있기 때문입니다. 그리고 이러한 변화들은 우리를 더욱 완전한 사람으로 만드는 부분입니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>홍콩증권거래소, 가상화폐 발전사</title>
        <link>https://ttf248.life/ko/p/hong-kong-stock-exchange-virtual-currency-history/</link>
        <pubDate>Tue, 31 Dec 2024 07:00:28 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/hong-kong-stock-exchange-virtual-currency-history/</guid>
        <description>&lt;p&gt;던그 쏭이 다시 미국 대통령으로 당선되면서 가상화폐가 대중의 시야에 다시 들어왔습니다. 홍콩 증권 거래소도 관련 사업을 적극적으로 추진해 왔는데, 여기 홍콩 증권 거래소의 가상화폐 발전 역사를 간단히 기록해 둡니다.&lt;/p&gt;
&lt;p&gt;관련 계약 목록의 세부 자료를 살펴보니, 처음 도입된 것은 현물이 아닌 선물이었고, 이것은 합리적인 것이었습니다. 왜냐하면 선물 시장의 유동성이 더 좋고 기관 투자자를 유치하기 더 쉽기 때문입니다. 이후 도입된 현물 ETF 역시 합리적인데, ETF는 좀 더 쉽게 받아들여지는 투자 도구이기 때문입니다.&lt;/p&gt;
&lt;h2 id=&#34;가상화폐-목록&#34;&gt;가상화폐 목록
&lt;/h2&gt;&lt;p&gt;홍콩증권거래소의 시장 데이터에는 표시가 없어 가상화폐인지 여부를 구별할 수 없지만, 계약 이름으로 판단할 수 있습니다. 공식 웹사이트의 거래 목록에서는 해당 하위 카테고리 &lt;code&gt;virtualasset&lt;/code&gt;이 제공됩니다.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.hkex.com.hk/Market-Data/Securities-Prices/Exchange-Traded-Products?sc_lang=en&amp;amp;asset=virtualasset&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.hkex.com.hk/Market-Data/Securities-Prices/Exchange-Traded-Products?sc_lang=en&amp;amp;asset=virtualasset&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;2022년-12월-16일&#34;&gt;2022년 12월 16일
&lt;/h2&gt;&lt;h3 id=&#34;홍콩증권거래소는-아시아-최초의-암호화폐-etf-상장을-환영합니다&#34;&gt;홍콩증권거래소는 아시아 최초의 암호화폐 ETF 상장을 환영합니다
&lt;/h3&gt;&lt;p&gt;홍콩거래소(香港交易及結算有限公司)는 오늘(금요일) 아시아 최초의 암호화폐 ETF 상장을 환영하며, 제품 생태계를 더욱 확장하고 홍콩 및 국제 투자자에게 더 많은 선택지를 제공합니다&lt;/p&gt;
&lt;p&gt;오늘 상장된 두 개의 새로운 ETF — 남방동영 비트코인 선물 ETF(주식 코드: 3066) 및 남방동영 이더리움 선물 ETF(주식 코드: 3068)는 남방동영 자산관리 유한회사가 관리하며, 각각 시카고 상품 거래소(CME)에서 거래되는 표준화된 현금결제 비트코인 선물 계약과 이더리움 선물 계약을 추적합니다&lt;/p&gt;
&lt;p&gt;홍콩증권거래소 최고운영책임자 겸 시장공동주관 야오지아런은 “오늘 상장된 두 가지 암호화폐 ETF는 홍콩의 점차 풍부해지고 다변화되는 거래소 매매 제품 생태계에 화려함을 더한다. 이러한 신제품들은 아시아 투자자들이 처음으로 디지털 자산 투자를 할 수 있는 기회를 제공하며, 이는 디지털 경제에 대한 우리의 관심과 시장 수요를 반영하는 것이다. 앞으로 몇 달 안에 더 많은 테마 ETF와 디지털 자산 신제품을 맞이할 것으로 기대한다.”&lt;/p&gt;
&lt;p&gt;ETF는 홍콩증권거래소 산하에서 가장 빠르게 성장하는 사업 중 하나이며, 2022년에도 제품 종류가 지속적으로 확장되어 더욱 다양화되었고, 그 해에 최초의 메타버스 ETF, 최초의 탄소 선물 ETF 및 최초의 블록체인 ETF를 출시했으며, 처음으로 ETF를 홍콩-상해-심천 증권 거래 연결(통)에 포함시켰습니다&lt;/p&gt;
&lt;p&gt;또한 홍콩증권거래소에서 거래되는 상품(ETP, ETF 및 레버리지/인버스 상품 포함)은 올해 처음 11개월간 평균 일일 거래액이 118억 위안으로 작년 동기 대비 78억 위안보다 50% 증가하여 ETP가 투자자들에게 점점 더 인기를 얻고 있음을 보여준다. 2022년 11월 현재 홍콩증권거래소에 상장된 ETP는 총 168종이며 시가총액은 3,735억 위안에 달한다.&lt;/p&gt;
&lt;h2 id=&#34;2024년-4월-30일&#34;&gt;2024년 4월 30일
&lt;/h2&gt;&lt;h3 id=&#34;홍콩증권거래소는-첫-번째-가상자산-현물-etf-상장을-환영합니다&#34;&gt;홍콩증권거래소는 첫 번째 가상자산 현물 ETF 상장을 환영합니다
&lt;/h3&gt;&lt;p&gt;홍콩거래결산소유한회사(홍콩증권거래소)는 오늘(화요일) 아시아 최초의 가상자산 현물 ETF 상장을 환영하며 홍콩 시장의 상품 다양성을 확대하고 투자자에게 더 풍부한 선택지를 제공하여 홍콩을 아시아 선도적인 ETF 시장으로서의 입지를 공고히 했습니다&lt;/p&gt;
&lt;p&gt;홍콩증권거래소 증권상품 개발 담당관 로보런은 “오늘 새로 상장되는 가상자산 현물 ETF는 홍콩증권거래소의 다양하고 역동적인 ETF 시장 생태계를 풍부하게 하고 투자자에게 새로운 자산군에 대한 투자 기회를 제공할 것이다. 1년 전 가상자산 선물 ETF를 성공적으로 출시한 데 이어 아시아 최초의 가상자산 현물 ETF는 홍콩증권거래소의 매매 상품 종류와 유동성을 더욱 향상시킬 것이다. 우리는 시장 참여자와 계속 긴밀하게 협력하여 국제적인 시장에 더 많은 신제품을 도입할 것으로 기대한다.”&lt;/p&gt;
&lt;p&gt;최초의 가상 자산 선물 ETF가 2022년에 상장된 이후 투자자들에게 큰 인기를 끌며 활발하게 거래되고 있습니다. 홍콩에 상장된 세 가지 가상 자산 선물 ETF의 일 평균 거래량은 2023년 890만 홍콩달러에서 2024년 첫 분기에는 51억 3천만 홍콩달러로 증가했으며, 동시에 5억 2,900만 홍콩달러의 자금 유입을 이끌었습니다.&lt;/p&gt;
&lt;p&gt;거래소에서 거래되는 상품(ETF, 레버리지 및 역상품 포함)은 홍콩증권거래소에서 가장 빠르게 성장하는 시장 중 하나이며, 지난 한 해 동안 제품 종류도 계속 증가하고 있습니다. 2023년과 2024년 첫 분기에 새로 추가된 16개의 ETF 상품에는 아시아 태평양 지역 최초의 사우디아라비아 ETF와 홍콩 최초의 워런트 ETF가 포함되며, 현재 홍콩에 상장된 ETF는 총 179개입니다.&lt;/p&gt;
&lt;h2 id=&#34;2024년-10월-28일&#34;&gt;2024년 10월 28일
&lt;/h2&gt;&lt;h3 id=&#34;홍콩-거래소가-가상-자산-지수-시리즈를-출시할-예정입니다&#34;&gt;홍콩 거래소가 가상 자산 지수 시리즈를 출시할 예정입니다
&lt;/h3&gt;&lt;p&gt;홍콩거래소(Hong Kong Exchanges and Clearing Limited)는 오늘(월요일) 2024년 11월 15일에 홍콩거래소 가상자산 지수 시리즈(지수 시리즈)를 출시할 예정이라고 발표했습니다. 이는 빠르게 성장하는 자산 종류인 가상자산에 대한 신뢰성 있는 기준 가격을 제공하고, 홍콩이 아시아의 선도적인 디지털 자산 허브로 발전하는 것을 지원합니다.&lt;/p&gt;
&lt;p&gt;해당 지수 시리즈는 아시아 시간대의 비트코인 및 이더리움 가격에 대한 투명하고 신뢰할 수 있는 기준을 제공하며, 가상 자산에 대한 통일된 참조 가격을 제공하여 글로벌 거래소 간의 가격 차이를 해결하는 데 주력합니다&lt;/p&gt;
&lt;p&gt;홍콩증권거래소 그룹 최고경영자 앨런 채는 “저희는 이 빠르게 성장하는 자산 부류에 대한 지역 내 수요를 충족시키기 위해 홍콩증권거래소 가상자산 지수 시리즈를 출시하게 되어 기쁩니다. 투명하고 신뢰할 수 있는 실시간 기준을 제공함으로써 투자자들이 현명한 투자 결정을 내릴 수 있도록 돕고, 가상자산 생태계의 건전한 발전을 지원하며 홍콩이 국제 금융 중심지로서의 위상을 공고히 하는 데 기여하고자 합니다.”&lt;/p&gt;
&lt;p&gt;해당 지수 시리즈 출시를 통해 홍콩 증권 거래소는 신흥 분야를 적극적으로 탐색하고 있으며, 이는 한편으로는 홍콩 핀테크 발전을 지원하는 동시에 투자자에게 끊임없이 변화하는 시장 환경 속에서 중요한 기준 도구와 솔루션을 제공합니다&lt;/p&gt;
&lt;p&gt;지수 시리즈는 비트코인과 이더리움의 기준 지수 및 기준 환율을 포함할 것입니다&lt;/p&gt;
&lt;p&gt;비트코인 또는 이더리움의 24시간 거래량을 가중 평균하여 산출하고, 주요 암호화폐 거래소들의 시장 가격을 종합하여 계산되며, 즉시 달러로 표시되는 기준 현물 가격을 기준으로 합니다. 참고 환율은 금융 상품 청산 목적으로 설계되었으며 홍콩 시간으로 매일 오후 4시에 계산됩니다.&lt;/p&gt;
&lt;p&gt;해당 지수 시리즈는 홍콩에서 개발되는 최초의 유럽연합 기준 규정(BMR)을 준수하는 가상 자산 지수 시리즈로, 영국에 등록된 기준 관리 기관과 가상 자산 데이터 및 지수 제공업체 CCData가 공동으로 관리하고 계산합니다&lt;/p&gt;
&lt;p&gt;홍콩특별행정구 정부는 2022년에 발표한 가상자산 발전에 관한 정책 성명에서 홍콩 내 활기찬 가상자산 산업과 생태계를 육성하고자 합니다. 홍콩증권거래소의 가상자산 지수 시리즈 출시를 통해 실시간 데이터와 아시아 시간대의 일일 기준 가격을 제공하여 대중이 가상자산 투자 추세에 대한 이해도를 높이는 데 도움이 될 것입니다.&lt;/p&gt;
&lt;p&gt;지수 시리즈 설계 및 계산 방법에 대한 자세한 내용은 적절한 시기에 공개될 예정입니다&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.hkex.com.hk/news/news-release/2022/221216news?sc_lang=zh-hk&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.hkex.com.hk/news/news-release/2022/221216news?sc_lang=zh-hk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.hkex.com.hk/News/News-Release/2024/240430news?sc_lang=zh-HK&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.hkex.com.hk/News/News-Release/2024/240430news?sc_lang=zh-HK&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.hkex.com.hk/News/News-Release/2024/241028news?sc_lang=zh-HK&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.hkex.com.hk/News/News-Release/2024/241028news?sc_lang=zh-HK&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>수수료 인하됐습니다, 수수료 인하됐습니다, 국내 초대형 ETF 일괄 수수료 인하입니다</title>
        <link>https://ttf248.life/ko/p/reduced-fees-large-domestic-etf/</link>
        <pubDate>Thu, 21 Nov 2024 03:08:48 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/reduced-fees-large-domestic-etf/</guid>
        <description>&lt;p&gt;화태베어(华泰柏瑞) 沪深300 ETF 등 공고 하향 종합 수수료율을 동종 최저 단계로&lt;/p&gt;
&lt;p&gt;11월 19일, 화태보리자금관리회사가 발표했습니다. 투자자와의 투자 자산 관리 수요를 보다 잘 충족시키기 위해 &lt;code&gt;11월 22일부터&lt;/code&gt; 화태보리沪深300 ETF 및 관련 기금의 수탁 보수율과 관리 보수율을 인하하고, 관련 기금 계약 내용 중 일부를 수정합니다.&lt;/p&gt;
&lt;p&gt;조정 결과, 화태박래 훙신300 ETF 및 연결 기금의 연 관리 수수료는 0.15%로, 연 위탁 보수율은 0.05%로 인하되었으며, 모두 지수 기금의 최저 요율로 조정되었습니다&lt;/p&gt;
&lt;p&gt;거의 동시에, 업계 선두 주자인 화샤 沪深300 ETF, 화샤 상증50 ETF, 남방 중증500 ETF, 자실 沪深300 ETF, 이팡다 창업판 ETF 등도 관리 수수료와 위탁 보수 인하를 발표하며 수수료율을 모두 0.15%와 0.05%로 낮췄습니다&lt;/p&gt;
&lt;p&gt;기존의 대부분 ETF 수수료 인하와 달리 이번 수수료 인하는 시장 내 규모 우위를 가진 상품의 적극적인 움직임에 의한 것으로, 향후 업계에 미치는 영향이 클 것으로 예상된다. 거래소 데이터에 따르면 11월 18일까지 화태베어 沪深300 ETF 규모는 3700억 위안을 넘어섰으며, 현재 시장에서 가장 큰 규모의 ETF이다.&lt;/p&gt;
&lt;p&gt;가장 큰 규모의 슈퍼 ETF들이 먼저 수수료를 인하하면서 투자자에게 이익을 돌려주려는 적극적인 의지를 보여주고, 투자자들이 더 높은 가격 대비 성능으로 인기 있고 유동성이 좋은 펀드에 투자할 수 있게 되었다&lt;/p&gt;
&lt;p&gt;업계 전문가들은 규모의 경제를 가진 ETF가 수수료를 인하하면, 한편으로는 공모펀드가 대중에게 금융 서비스를 제공하는 기능이 강화되고, 더 많은 투자자들의 보유 비용을 절감하고 수익률과 투자 만족도를 높이는 데 도움이 된다고 분석합니다&lt;/p&gt;
&lt;p&gt;한편, 낮은 수수료는 또한 제품 자체의 경쟁력을 더욱 향상시키는 데 도움이 되며, 유동성 흡인 효과와 비용 운영 우위가 더해져 제품이 더 많은 장기 투자 자금을 유치하여 “장기 투자 생태계”를 구축하는 데 기여할 것으로 기대됩니다&lt;/p&gt;
&lt;p&gt;최근 들어 거래의 유연성, 높은 투명성, 강한 유동성, 낮은 투자 장벽 등의 독특한 장점으로 인해 기초 ETF는 자금 유입의 주요 경로이자 “장기 투자”를 위한 핵심 수단으로 자리 잡았습니다&lt;/p&gt;
&lt;p&gt;이번 가격 인하는 어느 정도의 “촉진제” 역할을 하여 A주 시장에 장기 자금이 더욱 원활하게 유입될 수 있을 가능성이 있습니다&lt;/p&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;p&gt;저희가 정기적으로 투자하는 천홍 펀드는 아직 공지가 없지만, 따라갈 가능성이 높습니다. 업데이트가 되지 않으면 다른 펀드로 전환해야 할 수도 있습니다.&lt;/p&gt;
&lt;p&gt;원 관리비율: 0.5%, 수탁수수료: 0.1%. 신 관리비율: 0.15%, 수탁수수료: 0.05%. 이 폭락은 여전히 크다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>삼각 투자 자문 감독 강화, 더울샤오주 배후 승자들 징계?</title>
        <link>https://ttf248.life/ko/p/third-party-wealth-managers-scrutiny-tiktok-stock-winners-crackdown/</link>
        <pubDate>Thu, 21 Nov 2024 02:59:18 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/third-party-wealth-managers-scrutiny-tiktok-stock-winners-crackdown/</guid>
        <description>&lt;p&gt;망치가 떨어지고 있다&lt;/p&gt;
&lt;p&gt;투자 자문 서비스가 단편 동영상의 순풍을 타고, 고속도로로 진입하고 있는 듯합니다&lt;/p&gt;
&lt;p&gt;지난 9월 하반기, A주 시장이 고조된 후 抖音(더우인) 추천 주식에 대한 각계의 관심이 집중되었습니다&lt;/p&gt;
&lt;p&gt;대규모 자본이 유입되면서 “다란(大蓝)”을 비롯한 여러 경제 뉴스 진행자들이 틱톡에서 인기를 얻어, 간접적으로 자본 시장에 일정한 변동성을 야기했다&lt;/p&gt;
&lt;p&gt;하지만 빠르게 인기를 얻고 있는 경제 뉴스 앵커들의 뒤에는 간과할 수 없는 힘이 있는데, 바로 제3자 투자 자문 회사입니다&lt;/p&gt;
&lt;p&gt;파악된 바에 따르면, 여러 제3자 투자 자문 회사들이 단편 동영상 플랫폼에서 여러 계정을 운영하며, 유료 광고를 통해 사용자를 유치하여 투자 교육 영상 시청을 유도하고, 관련 투자 자문 상품 구매 의욕을 높이는 것으로 알려져 있습니다&lt;/p&gt;
&lt;p&gt;더욱이 어떤 제3자 투자 자문 회사에서 올해 10월에만 10억 위안의 수입을 올렸다는 소문도 있으며, 이는 연 상반기의 수입을 넘어섰습니다&lt;/p&gt;
&lt;p&gt;하지만 “좋은 날들”이 더 많은 변수를 맞고 있다&lt;/p&gt;
&lt;p&gt;11월 이후, 여러 부처에서 잇따라 관련 문서를 발표하며 증권 서비스 기관에 자사 미디어 계정의 규정 준수 관리를 강화할 것을 요구했다&lt;/p&gt;
&lt;p&gt;11월 15일 저녁, 동화순(300033.SZ)은 자회사가 라이브 방송 사업과 관련하여 개별 주식 추천 등 행위를 했다는 이유로 증감회로부터 처벌을 받았다고 발표했습니다
이것은 시장에 규제 강화의 신호를 보내는 것일 수도 있습니다
玖방지투(9636.HK) 등 다수 제3자 투자 자문 서비스 기관의 사업 확장도 더 많은 압박에 직면할 수 있습니다&lt;/p&gt;
&lt;h2 id=&#34;엄중한-감시와-주시&#34;&gt;엄중한 감시와 주시
&lt;/h2&gt;&lt;p&gt;틱톡과 같은 짧은 동영상 플랫폼의 부상은 감정적인 목소리를 증폭시키고, 간접적으로 거래 행위에 영향을 미치기도 합니다&lt;/p&gt;
&lt;p&gt;거대 데이터 분석에 따르면 거래액이 최고치를 기록한 9월 27일부터 10월 8일까지, 틱톡 A주 키워드 검색 지수가 423만 8천에서 1277만 8천으로 급등하며 두 배 이상 증가했습니다&lt;/p&gt;
&lt;p&gt;이러한 상황에서 제3자 자문기관의 “촉진” 행위는 규제 기관의 관심을 끌고 있다&lt;/p&gt;
&lt;p&gt;투자 자문사 직원이 라이브 방송 중 다양한 방식으로 개별 주식을 추천하는 행위는 고빈도의 위반 행위입니다&lt;/p&gt;
&lt;p&gt;11월 8일, 광둥 증감국은 특정 회사의 라이브 방송에서 “개별 주식 추천을 암시하는 행위” 등의 사례에 대해 신규 고객 유치를 중단하는 규제 조치를 취했습니다&lt;/p&gt;
&lt;p&gt;11월 14일 저녁, 광둥 증권선물업협회에서《라이브 방송 관리 미흡, 기관 업무 정지》라는 공지를 발표하며 일부 증권 상담 자격을 가진 기관이 라이브 방송 영업 과정에서 관리가 미흡한 상황과 방송 중 개별 주식 추천 행위가 있다는 점을 지적했다&lt;/p&gt;
&lt;p&gt;라이브 방송 중 주식 추천 행위를 근절해야 한다. 라이브 방송은 대중 매체 전파에 해당하며, 투자 자문으로 등록 여부와 관계없이 라이브 방송자는 방송 중에 개별 종목을 추천해서는 안 된다. 광동 증권선물업협회 지적&lt;/p&gt;
&lt;p&gt;이 경우는 유일한 것이 아닙니다&lt;/p&gt;
&lt;p&gt;이전 11월 7일, 상하이 증감위가 공개한 처분 목록에도 소셜 미디어 플랫폼에서 불법적으로 주식 투자를 권유한 사례가 한 건 포함되어 있었습니다&lt;/p&gt;
&lt;p&gt;감독 조사 결과, 하이슌 증권 투자상담유한공사 상하이 지점의 투자 상담 담당자 왕영이 위챗 비디오 번호에 오해를 불러일으키는 영상 콘텐츠를 공개적으로 게시하여 이는 업계 규범을 위반한 것으로 밝혀졌다&lt;/p&gt;
&lt;p&gt;상하이 증감국은 이와 관련하여 왕영에 대해 경고서를 발부하는 감독 관리 조치를 취했습니다&lt;/p&gt;
&lt;p&gt;신빙성 있는 정보에 따르면(ID: TradeWind01) 자격이 없는 일부 투자 상담사들이 증권사와 위탁 계약을 맺어 抖音(Douyin)에서 주식을 추천하다가 현재 방송 중단된 것으로 알려졌습니다&lt;/p&gt;
&lt;p&gt;업계에 있는 사람이 抖音(Douyin) 라이브 방송을 하는데, 사실상 증권사 아래에 걸려 있어서 투자 자문 자격이 생기고, 그런 다음 온라인 라이브 방송으로 유입을 유도하고 오프라인에서 자문 상품을 판매하는 방식입니다.”라고 남방 지역의 한 투자 자문가가 신풍(ID:TradeWind01)에게 말했습니다. “하지만 나중에 방송 중 주식을 추천했다는 이유로 적발되어 방송이 중단되었습니다. 정식 증권사는 일반적으로 투자 교육 라이브 방송에서 섹터 상황에 대해서만 이야기하고 개별 종목에 대해서는 언급하지 않습니다.”&lt;/p&gt;
&lt;p&gt;현재 규제 당국은 소셜 미디어의 불법적인 주식 추천 행위에 대해 높은 관심을 기울이고 있습니다&lt;/p&gt;
&lt;p&gt;예를 들어 선전 증감국은 최근 업계 내 개별 기관이나 개인들이 자매체를 이용하여 불법적으로 주식을 추천하는 등 위반 행위를 하고 있다고 밝혔습니다. 이에 따라 관할구역의 증권 투자 상담기관들의 자매체 운영 및 관리를 더욱 규정하기 위해 각 기관은 자사의 자매체 운영 관리를 강화해야 합니다.&lt;/p&gt;
&lt;p&gt;이는 다수의 제3자 자문 서비스 기관의 사업 확장에도 더 많은 어려움을 가져다줄 수 있습니다&lt;/p&gt;
&lt;h2 id=&#34;교통-판매는-옳지-않다&#34;&gt;교통 판매는 옳지 않다
&lt;/h2&gt;&lt;p&gt;단일 비디오에 현혹되어 시장에 진입한 투자자들이 돈을 벌었는지 여부는 알 수 없지만, “물 파는 사람”으로서의 제3자 자문사 서비스 회사의 가치는 2차 시장에서 물가가 오르듯 상승했다&lt;/p&gt;
&lt;p&gt;“온라인 투자 교육 1세대”로 불리는 구방지투의 시가총액은 올해 9월 초 28억7800만 위안에서 11월 13일 종가를 기록한 124억6400만 위안으로 치솟았으며, 49개의 거래일 동안 무려 333.08% 상승했다&lt;/p&gt;
&lt;p&gt;반기 보고서에 따르면, 올해 상반기 큐방지투는 틱톡, 샤오홍수 등 소셜 미디어 플랫폼에서 브랜드 노출을 진행했으며, 올해 6월 말까지 488개의 계정과 0.46억 명의 팔로워를 확보했습니다&lt;/p&gt;
&lt;p&gt;예를 들어, 구방지투의 최고 투자 자문인 “홍방주”는 틱톡에서 226만 명의 팔로워를 보유하고 있습니다&lt;/p&gt;
&lt;p&gt;“저희는 MCN 운영에 깊이 집중하며, 사용자를 중심으로 트래픽, 브랜드 및 제품의 전면적인 발전을 협력적으로 추진하고 있습니다. 玖방지투(九方智投)는 “라이브 방송, 단편 동영상 등 새로운 미디어 도구를 심층적으로 융합하고 AI 기술을 활용하여 팬 네트워크를 구축하며, 적극적으로 전자상거래 모델을 탐색함으로써 트래픽의 효율적인 전환을 실현합니다.”&lt;/p&gt;
&lt;p&gt;玖방지투의 투자 상담 과정 패키지는 수십만 원에서 10여 만 원까지 다양한 가격대의 상품을 포함합니다. 그중 가장 비싼 과정은 슈퍼 투자자로, 반기 기준으로 13.96만 위안/으로 책정되어 있으며 독점적인 의견과 투자 상담 전용 서비스 등을 제공합니다.&lt;/p&gt;
&lt;p&gt;하지만 玖方智投의 자문 상품 환불률은 10% 이상입니다&lt;/p&gt;
&lt;p&gt;2024년 상반기, 구방지투 플래그십 시리즈와 구방지투 擒룡 시리즈의 환불률은 각각 14.7%, 18.5%에 달했다&lt;/p&gt;
&lt;p&gt;규제 폭풍 속에서 지팡지투의 사업 전개는 영향을 받을 수 있으며, 추가적인 관심이 필요하다&lt;/p&gt;
&lt;p&gt;최근 언론에서 최근 玖方智投 등 제3자 투자 자문 회사 계정들이 영향을 받았다고 보도했다&lt;/p&gt;
&lt;p&gt;11월 7일, 언론에 따르면 “홍방주”가 방송 중지된 것으로 알려졌다&lt;/p&gt;
&lt;p&gt;하지만 11월 15일 오후 신풍(ID: TradeWind01)이 해당 계정을 검색한 결과, “홍幇주”의 라이브 방송 화면에서 여전히 11월 18일 방송 예약을 할 수 있었다&lt;/p&gt;
&lt;p&gt;동시에 시장에서는 관련 부서가 玖方智投를 조사하기 위해 진입했다는 소식도 있다&lt;/p&gt;
&lt;p&gt;하지만 9방 지투 인사에 따르면, 관련 검사는 정기적인 검사이며 이미 종료되었습니다&lt;/p&gt;
&lt;p&gt;이 회사는 최근 규제 폭풍의 소문에 휘말린 유일한 기업이 아닙니다&lt;/p&gt;
&lt;p&gt;동화순이 불법적인 주식 추천 혐의로 사건이 개시되었으며, 영업 중단될 가능성이 있다고 합니다
이에 대해 동화순은 11월 15일 “불법적인 추천주식 상황이 없고, 수사 기관에 의해 사건이 개시된 적도 없다.”라고 응답했다
하지만 당일 밤에, 동화순은 자회사 저장동화순클라우드소프트웨어유한공사가 라이브 방송 사업 홍보 과정에서 규정 준수 관리가 미흡하고 개별 주식 추천과 같은 상황이 존재하여 저장증권감독국으로부터 신규 고객 유치 중지 3개월 등의 처벌을 받았습니다
이러한 상황 뒤에는 규제 기관이 틱톡 라이브와 같은 소셜 미디어 플랫폼의 추천 주식 콘텐츠에 대한 관심을 더욱 강화하고 있을 가능성이 있습니다&lt;/p&gt;
&lt;p&gt;사실, 단영상 시장도 증권사들의 관심을 끌고 있지만, 규제 요건으로 인해 아직은 다소 신중한 태도를 보이고 있습니다&lt;/p&gt;
&lt;p&gt;어떤 증권사 관계자는 신풍(ID:TradeWind01)에게 해당 회사가 단영상 운영 및 유입 방법 모색을 하고 있으며, 관련 학습을 위해 단영상 플랫폼 회사에 인원을 파견하기도 했다고 전했다. 하지만 규제 준수 요건으로 인해 현재는 탐색 단계에 머물러 있다.&lt;/p&gt;
&lt;p&gt;사실, 규제의 여러 준수 요구 사항 뒤에는 짧은 동영상 플랫폼 콘텐츠가 뚜렷한 감정적 색채를 띠고 있다는 이유가 있지만, 투자는 더 많은 시장 참여자들이 합리적으로 대해야 하며, 이 두 가지는 근본적인 갈등이 존재합니다&lt;/p&gt;
&lt;p&gt;만약 감정의 힘이 자본 시장에 영향을 미치면 시장의 격렬한 변동을 야기하기 쉬우며, 이는 자본 시장의 장기적인 건전한 발전에 부합하지 않는다&lt;/p&gt;
&lt;p&gt;증권 라이선스 보유 기관이 단영상 시대의 도래를 어떻게 맞이해야 “빨간 선”을 밟지 않고, 모든 당사자에게 어려운 문제로 남아 있다&lt;/p&gt;</description>
        </item>
        <item>
        <title>CentOS 8 Stream EOL</title>
        <link>https://ttf248.life/ko/p/centos-8-stream-eol/</link>
        <pubDate>Sat, 16 Nov 2024 23:24:50 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/centos-8-stream-eol/</guid>
        <description>&lt;p&gt;CentOS Stream은 레드햇 엔터프라이즈 Linux 배포 전의 상위 소스 코드 개발 플랫폼입니다
최초로 오픈소스 운영체제 라이프사이클 [레드햇 및 CentOS 라이프사이클]({&amp;lt; relref &amp;ldquo;/post/2020/07-redhat and centos life cycle&amp;rdquo; &amp;gt;}})에 주목하게 되었음&lt;/p&gt;
&lt;p&gt;만료되었는데, 문제가 있나요? 보안 문제 외에도 dnf를 사용할 수 없게 되었고, 최근에 도구 설치 시 dnf가 실패하는 것을 발견했습니다. 이미지 소스를 확인해 보니 &lt;code&gt;CentOS 8 Stream&lt;/code&gt;이 만료되었습니다.&lt;/p&gt;
&lt;h2 id=&#34;centos-스트림-소개&#34;&gt;CentOS 스트림 소개
&lt;/h2&gt;&lt;h3 id=&#34;위치와-역할&#34;&gt;위치와 역할
&lt;/h3&gt;&lt;p&gt;CentOS 스트림은 Fedora Linux(상위 개발)과 RHEL(Red Hat Enterprise Linux, 하위 개발) 사이에 위치하여 다리 역할을 합니다&lt;/p&gt;
&lt;p&gt;최신 Red Hat Linux 기능들을 경험하기 위한 버전으로, 새로운 기능을 시험해 보고 싶어하는 사용자에게 적합합니다&lt;/p&gt;
&lt;h3 id=&#34;탄생과-배경&#34;&gt;탄생과 배경
&lt;/h3&gt;&lt;p&gt;시간이 지나면서, Red Hat 사는 기업용 Linux 플랫폼을 발전시키는 보다 효과적인 방법을 모색하기 시작했고, CentOS Stream 을 출시했습니다&lt;/p&gt;
&lt;p&gt;CentOS 8은 2021년 말 지원이 종료된 후, CentOS Stream이 그 계승자로서 계속 업데이트되고 있으며, CentOS 프로젝트의 미래 발전 방향이 되었습니다&lt;/p&gt;
&lt;h3 id=&#34;특징-및-장점&#34;&gt;특징 및 장점
&lt;/h3&gt;&lt;p&gt;CentOS 스트림은 지속적으로 업데이트되는 Linux 배포판으로, 더 빠른 업데이트를 제공합니다. 커뮤니티, 파트너 및 고객의 참여를 위한 투명성과 기회를 높여 사용자에게 Red Hat Enterprise Linux에 더 빠르고 직접적인 방식으로 기여할 수 있도록 합니다.&lt;/p&gt;
&lt;p&gt;CentOS 스트림의 내용은 Red Hat이 다음 안정 버전 RHEL에 의도적으로 포함할 소프트웨어이기 때문에 커뮤니티 구성원에게 개발 및 테스트를 위한 안정적인 ABI/API를 제공합니다&lt;/p&gt;
&lt;h3 id=&#34;사용-시나리오-및-대상-사용자&#34;&gt;사용 시나리오 및 대상 사용자
&lt;/h3&gt;&lt;p&gt;CentOS Stream은 최신 Linux 기능 업데이트를 계속 받고자 하는 CentOS 사용자, 그리고 Red Hat Enterprise Linux 개발에 참여하고자 하는 개발자와 파트너에게 적합합니다&lt;/p&gt;
&lt;p&gt;커뮤니티 구성원, Red Hat 파트너 및 다른 사람들이 보다 안정적이고 예측 가능한 Linux 환경에서 혁신적인 오픈 소스 프로그램을 최대한 활용할 수 있도록 돕는 것을 목표로 합니다&lt;/p&gt;
&lt;h2 id=&#34;만료일&#34;&gt;만료일
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Release&lt;/th&gt;
&lt;th&gt;Released&lt;/th&gt;
&lt;th&gt;Active Support&lt;/th&gt;
&lt;th&gt;Security Support&lt;/th&gt;
&lt;th&gt;Latest&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;3 years ago (15 Sep 2021)&lt;/td&gt;
&lt;td&gt;Ends in 2 years and 6 months (31 May 2027)&lt;/td&gt;
&lt;td&gt;Ends in 2 years and 6 months (31 May 2027)&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;5 years ago (24 Sep 2019)&lt;/td&gt;
&lt;td&gt;Ended 5 months and 3 weeks ago (31 May 2024)&lt;/td&gt;
&lt;td&gt;Ended 5 months and 3 weeks ago (31 May 2024)&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;해결책&#34;&gt;해결책
&lt;/h2&gt;&lt;p&gt;업그레이드 문제로 번거로운 일은 피하기 위해 &lt;code&gt;Ubuntu 24.04&lt;/code&gt; 장기 지원 버전을 선택했습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>Hugo 모듈 커스터마이징 테마 수정 방법: 아이디어 설명</title>
        <link>https://ttf248.life/ko/p/hugo-module-custom-theme-ideas/</link>
        <pubDate>Fri, 15 Nov 2024 22:01:17 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/hugo-module-custom-theme-ideas/</guid>
        <description>&lt;p&gt;과거 커밋 기록을 살펴보니, 사이트는 여러 번 테마를 변경해 왔습니다. 매번 테마를 변경할 때마다 몇 가지 사용자 정의 수정 사항이 있었고, 여기 그 수정 아이디어를 기록합니다. 제 &lt;code&gt;Github&lt;/code&gt;에도 저장소가 있는데, even 테마를 잠시 유지 관리하다가 강박증 때문에 최신 버전의 &lt;code&gt;hugo&lt;/code&gt; 컴파일러로 업그레이드하고 싶었지만, even 테마와 호환되지 않아 다시 &lt;code&gt;stack&lt;/code&gt; 테마로 전환했습니다.&lt;/p&gt;
&lt;h2 id=&#34;휴고의-모듈화&#34;&gt;휴고의 모듈화
&lt;/h2&gt;&lt;p&gt;모듈화를 언급하면 Nginx 모듈이나 IDEA 플러그인 등이 떠오르는 경우가 많습니다. 보통은 몇몇 모듈을 업로드하여 차별화된 요구사항을 충족할 수 있습니다. 모두가 이러한 모듈을 선호하는 주된 이유는 충분히 유연하기 때문이며, 큰 노력을 들이지 않고도 자체적인 요구사항을 충족할 수 있기 때문입니다. 많은 경우 전체적으로는 비슷하더라도 세부적인 차이가 존재합니다. 이는 기술적 복잡성 외에도 비즈니스 복잡성을 보여주는 것이기도 합니다. 대부분의 경우 우리는 비즈니스 복잡성에 직면하게 됩니다. 이것이 소프트웨어 분야에서 “동업자 간에도 산과 같다는” 속담을 가장 잘 설명하는 것입니다. 요즘은 인터넷 업계뿐만 아니라 금융 업계, 심지어 전통적인 제조업에 이르기까지 정보화 시스템을 활용하여 기업의 생산 및 관리를 돕고 있습니다. 마찬가지로 휴가 신청 시스템이라도 같은 산업 분야라도 서로 다른 회사마다 차이가 있을 수 있습니다.&lt;/p&gt;
&lt;p&gt;그리고 &lt;code&gt;Hugo&lt;/code&gt;의 모듈은 사람들의 일반적인 인식과는 조금 다르게, 기능별로 차별화된 요구를 충족하기 위한 것이 아니라 디렉토리 구조를 중심으로 동일한 구조를 식별합니다&lt;/p&gt;
&lt;p&gt;자료 링크: &lt;a class=&#34;link&#34; href=&#34;https://medium.com/@sunwei.xyz/07-hugo%E6%9E%B6%E6%9E%84-hugo%E7%9A%84%E6%A8%A1%E5%9D%97-8ef5a520a822&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;07. Hugo 아키텍처 — Hugo의 모듈&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[[imports]]
path = &amp;quot;github.com/CaiJimmy/hugo-theme-stack/v3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;git 서브모듈 방식은 여전히 사용할 수 있지만, 본문에서는 권장하지 않습니다. 테마가 업데이트되면 유지 관리가 복잡해지며, 테마를 별도의 git 저장소로 관리해야 합니다.&lt;/p&gt;
&lt;h2 id=&#34;주제의-수정-로직&#34;&gt;주제의 수정 로직
&lt;/h2&gt;&lt;p&gt;앞선 모듈화의 기본 개념을 이해했으면, 사용자 정의 테마를 이해하는 것은 훨씬 쉬워졌습니다. &lt;code&gt;hugo&lt;/code&gt;의 현재 테마도 여러 개의 다른 모듈로 조립된 것이며, 우리는 원하는 모듈을 찾아 해당 템플릿 파일을 수정하면 됩니다.&lt;/p&gt;
&lt;p&gt;스택 공식 문서에서 발췌:&lt;/p&gt;
&lt;p&gt;Using this method, there won&amp;rsquo;t be any file under &lt;code&gt;themes&lt;/code&gt; directory. In order to modify the theme, you will have to copy the file you want to modify to the same directory under &lt;code&gt;layouts&lt;/code&gt; directory.&lt;/p&gt;
&lt;p&gt;For example, in order to modify the &lt;code&gt;themes/hugo-theme-stack/layouts/partials/head/custom.html&lt;/code&gt; file, you will have to copy it to &lt;code&gt;layouts/partials/head/custom.html&lt;/code&gt; and modify it there (copy the code from theme&amp;rsquo;s repository). The same applies to &lt;code&gt;assets&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt; directories。&lt;/p&gt;
&lt;h2 id=&#34;템플릿-파일을-어떻게-찾을-수-있나요&#34;&gt;템플릿 파일을 어떻게 찾을 수 있나요?
&lt;/h2&gt;&lt;h3 id=&#34;정통적-사고방식&#34;&gt;정통적 사고방식
&lt;/h3&gt;&lt;p&gt;테마의 소스 파일을 살펴보면서 디자인 아이디를 이해하고, 해당 템플릿 파일을 찾아 수정하면 됩니다&lt;/p&gt;
&lt;h3 id=&#34;거친-사고방식&#34;&gt;거친 사고방식
&lt;/h3&gt;&lt;p&gt;저는 프론트엔드 코드를 잘 모르는 편이라 때로는 직접적인 방법을 사용합니다. 예를 들어 브라우저에서 해당 페이지를 열고, 수정하고 싶은 부분을 찾아 &lt;code&gt;요소 검사&lt;/code&gt; 기능을 통해 &lt;code&gt;CSS 이름&lt;/code&gt;을 찾은 다음, 테마 소스 코드에서 검색하여 해당하는 파일을 찾아서 복사한 후 사이트 디렉토리에 붙여넣고 수정하는 방식입니다.&lt;/p&gt;
&lt;h2 id=&#34;소-팁&#34;&gt;소 팁
&lt;/h2&gt;&lt;p&gt;공식적으로 기본 제공되는 파일로 스타일을 커스터마이징할 수 있으며, 수정해야 할 부분을 여러 파일로 분리하고 &lt;code&gt;custom.scss&lt;/code&gt; 파일에서 다른 파일을 불러와서 사용하면 스타일 파일을 더 효과적으로 관리할 수 있습니다&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/hugo-module-custom-theme-ideas/image.png&#34;
	width=&#34;141&#34;
	height=&#34;375&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;37&#34;
		data-flex-basis=&#34;90px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;수정-내용-요약6시간&#34;&gt;수정 내용 요약(6시간)
&lt;/h2&gt;&lt;p&gt;이제는 AI 코딩의 원년이라고 할 수 있으며, 자세한 내용은 여기서는 생략하고 간단히 나열하자면, 본 사이트의 수정 내용 몇 가지 예를 들어 복사 버튼 스타일 조정, 코드 블록 스타일 재설정 등이 있는데, ChatGPT로도 쉽게 처리할 수 있습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;전체: 전체 글꼴 스타일은 이전 &lt;code&gt;even&lt;/code&gt;과 &lt;code&gt;info cn&lt;/code&gt;을 결합한 표시 스타일을 유지하며, 중국어 사용자를 위한 친화적인 디자인입니다&lt;/li&gt;
&lt;li&gt;홈페이지: 오른쪽 네비게이션에 마우스 상호작용 애니메이션 추가&lt;/li&gt;
&lt;li&gt;처음 페이지: 기사 요약 미리 보기 (시간이 많이 소요되므로, 편리한 방법을 사용했습니다.)&lt;/li&gt;
&lt;li&gt;스크롤바: 스크롤바 스타일을 다듬었습니다&lt;/li&gt;
&lt;li&gt;코드 블록에 &lt;code&gt;highlight.js&lt;/code&gt; 코드 하이라이트 플러그인이 도입되어 코드 블록 스타일이 개선되었습니다&lt;/li&gt;
&lt;li&gt;내용 상세: 일부 내용은 재게시되었으며, 원저자 정보 표시 및 원본 링크 표시가 추가되었습니다&lt;/li&gt;
&lt;li&gt;아카이브 페이지: 상단의 카테고리 이미지, 테마 자체 색상 오버레이 제거, 원본 이미지 표시&lt;/li&gt;
&lt;li&gt;파일 페이지: 연도별 분류 통계 표시 패널이 추가되었습니다&lt;/li&gt;
&lt;li&gt;아카이브 페이지: 두 열 레이아웃 표시&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;스택 테마의 컴포넌트 재사용성이 매우 높아, 홈페이지에 새 글 요약 미리 보기 기능을 추가하는 데 상당한 시간이 소요되었습니다. 관련 컴포넌트를 수정했더니, 게시글 상세 페이지에서도 내용이 중복되어 표시되는 문제가 발생했습니다. &lt;code&gt;golang 템플릿&lt;/code&gt; 문법에도 익숙하지 않아 더 많은 시간을 소비했고, 컴포넌트 간의 파라미터 전달은 끝내 해결하지 못했습니다. 결국, 트릭을 사용하여 홈페이지에 별도의 &lt;code&gt;JavaScript&lt;/code&gt; 스크립트를 도입하고, 사용자 정의 특수 변수를 통해 요약 미리 보기 기능을 구현했습니다.&lt;/p&gt;
&lt;p&gt;때로는 코드 재사용률이 너무 높아서 문제가 될 수도 있는데, 한 부분을 수정하면 다른 부분에도 영향을 미치기 때문에 테마를 수정할 때는 기존 로직을 훼손하지 않도록 주의해야 합니다&lt;/p&gt;
&lt;h3 id=&#34;댓글-영역&#34;&gt;댓글 영역
&lt;/h3&gt;&lt;p&gt;이 친구의 수정은 더욱 완벽해졌습니다: &lt;a class=&#34;link&#34; href=&#34;https://blog.reincarnatey.net/2024/0719-better-waline/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.reincarnatey.net/2024/0719-better-waline/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이 사이트는 간단하게 &lt;code&gt;Waline&lt;/code&gt; 댓글 시스템을 적용했으며, &lt;code&gt;stack&lt;/code&gt; 테마는 기본적으로 &lt;code&gt;Waline&lt;/code&gt;을 지원하므로 &lt;code&gt;config.toml&lt;/code&gt;에서 설정하면 됩니다&lt;/p&gt;
&lt;p&gt;추천 홈페이지, 이메일 연락처. 본 사이트는 댓글 기능을 제공하지 않습니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>현소읍 브라만: 작은 곳의 거물</title>
        <link>https://ttf248.life/ko/p/county-brahmins-big-shots-in-small-towns/</link>
        <pubDate>Wed, 13 Nov 2024 23:02:25 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/county-brahmins-big-shots-in-small-towns/</guid>
        <description>&lt;p&gt;최근 抖音(더우인)의 대빙 선생님이 아주 유명해져서 자주 동영상의 편집 계정을 볼 수 있는데, 다 방송 중에 나온 내용들이다. 함께 방송을 하던 청취자 중 한 명이 “대빙 선생님, 저는 시안의 집을 팔고 고향으로 돌아가서 躺平(탕핑)하고 싶어요?”라고 물었다. 대빙 선생님은 “지금 당신 나이 서른 초반인데, 탕핑할 수 없을 거예요. 부모님은 늙어가는 길에 있고, 자녀는 아직 독립하지 못했으니 고향으로 돌아가서도 작은 도시의 婆罗门(포로먼)을 상대해야 할 겁니다.”라고 답했다.&lt;/p&gt;
&lt;p&gt;일단 논쟁의 옳고 그름을 떠나서, &lt;code&gt;브라만&lt;/code&gt;이라는 단어는 무슨 뜻인가요?&lt;/p&gt;
&lt;h1 id=&#34;현소의-브라만-작은-지역의-거물&#34;&gt;현소의 브라만: 작은 지역의 “거물”
&lt;/h1&gt;&lt;p&gt;많은 작은 도시에서 사람들은 흔히 &amp;ldquo;현급 브라만&amp;quot;이라고 불리는 존재들을 이야기한다. 이들의 존재는 마치 지역 사회의 상징과 같은 듯하다. 그들은 종종 진정한 종교 지도자도 아니고, “고풍스러운” 직함을 가진 것도 아니지만, 평범해 보이지만 중요한 역할을 하는 사람들이다. 그들은 작은 지역에서 &amp;ldquo;권력, 지위, 발언권&amp;quot;을 대표하며, 그 현의 특정 계층을 상징한다.&lt;/p&gt;
&lt;h2 id=&#34;현도시-브라만이란-무엇인가요&#34;&gt;&amp;ldquo;현도시 브라만&amp;quot;이란 무엇인가요?
&lt;/h2&gt;&lt;p&gt;우선, “브라만”이라는 단어는 원래 인도 사회에서 가장 높은 계층을 의미하며 지혜, 권위, 그리고 정신적인 우월성을 상징합니다. 하지만 중국의 현청에서 “현청 브라만”이라는 용어는 그렇게 복잡한 종교적 배경을 가지고 있지 않으며, 더 많은 것은 사회 현상의 비유입니다.&lt;/p&gt;
&lt;p&gt;간단히 말해서, &amp;ldquo;현급 브라만&amp;quot;은 현 도시 내의 몇몇 &amp;ldquo;문화 권위자&amp;quot;라고 이해할 수 있습니다. 예를 들어 선생님, 의사, 지역의 유명 상인, 공무원 등입니다. 비록 그들의 직업이 겉보기에는 평범해 보이지만, 비교적 폐쇄적인 환경인 현 도시에서 이들은 상대적으로 높은 사회적 지위를 가지고 있거나, 혹은 그들의 의견과 행동은 거부할 수 없는 영향력을 행사합니다.&lt;/p&gt;
&lt;h2 id=&#34;누가-현도시-바라문인가&#34;&gt;누가 “현도시 바라문”인가?
&lt;/h2&gt;&lt;p&gt;현읍에서 거의 모든 분야에 이런 “브라만”들이 있습니다. 그들은 다음과 같을 수 있습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;교육자들, 특히 지방에서 수십 년간 교직에 몸담은 선생님들은 명문대 졸업생이 아닐 수도 있지만, 지식을 통해 어떻게 권위를 쌓고 존경을 받는지를 잘 알고 있습니다&lt;/li&gt;
&lt;li&gt;지방 정부 관리들: 현 도시의 부현장, 과급 간부 등은 일정한 자원과 권력을 장악하며, 그들의 직위가 높지 않더라도 권한 범위가 제한적이기에 지역 사회의 “브라만”이 될 수 있다&lt;/li&gt;
&lt;li&gt;지역의 &amp;ldquo;기업가&amp;quot;들: 몇몇 현 도시의 사장님들인데, 규모는 크지 않지만 상당한 부를 소유하고 있으며 지역 내에서 영향력을 행사합니다. 어쩌면 1~2개의 유명한 소규모 기업을 운영하며 현 내에서 상당한 영향력을 가지고 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 사람들은 비록 대도시의 명사나 고위 관리와 비교하면 지위가 눈에 띄지 않지만, 현청이라는 작은 사회 안에서는 거의 “문화적 원로” 또는 “권력의 중심”과 동등한 위치를 차지한다&lt;/p&gt;
&lt;h2 id=&#34;현읍의-브라만-계층은-사회에-어떤-영향을-미치는가&#34;&gt;현읍의 브라만 계층은 사회에 어떤 영향을 미치는가?
&lt;/h2&gt;&lt;p&gt;&amp;ldquo;현(縣)청 브라만&amp;quot;의 진정한 의미를 이해하려면 현(縣)청의 특별한 환경을 고려해야 합니다. 이곳은 정보 유통이 대도시만큼 빠르지 않고, 사회 계층 이동도 비교적 고정되어 있습니다. 이곳의 &amp;ldquo;브라만&amp;quot;들은 종종 오랫동안 지역에 깊이 뿌리내려 명성, 지식, 인맥을 쌓아왔습니다. 이들은 지역의 정치, 경제, 문화 등 각 방면에 영향을 미칩니다.&lt;/p&gt;
&lt;p&gt;문화적 영향력: 작은 지역에서는 특히 교육 시스템이 발달하지 않았고 일반인들에게는 선택의 여지가 많지 않습니다. 현지의 문화 주도층은 교실에서의 지식 전달, 미디어를 통한 설명, 나아가 사교적인 자리에서의 언어와 행동을 통해 조용히 지역의 문화적 분위기를 형성합니다.&lt;/p&gt;
&lt;p&gt;사회 자원의 집중: 현 도시의 인구와 자원이 제한적이기 때문에 이러한 “브라만”들은 종종 지역 자원을 주요 통제자 중 하나입니다. 사회 복지, 정책 시행, 또는 특정 프로젝트 승인 등 어떤 것이든 그들의 영향력이 없어서는 안 됩니다. 그들의 발언권과 결정권은 그들이 지역 사회에서 한 자리 잡도록 만듭니다.&lt;/p&gt;
&lt;p&gt;인간 관계의 망상 구조: 상대적으로 폐쇄된 작은 사회에서 인간 관계는 종종 매우 중요합니다. 이러한 “현도시 브라만”들은 강력한 소셜 네트워크를 구축하여 정보 유통과 자원 분배를 통제하고, 따라서 중요한 순간에 결정적인 역할을 할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;현읍-브라만에-숨겨진-은유&#34;&gt;현읍 브라만에 숨겨진 은유
&lt;/h2&gt;&lt;p&gt;비록 “현청 바라문”은 종종 존경과 숭배를 받지만, 이러한 “높고 높은” 지위도 문제 없는 것은 아니다. 현대 사회에서 우리는 많은 현청의 “바라문”들이 진정한 능력이나 혁신 정신이 있는 것이 아니라 혈연 관계나 자원 독점 등의 방식으로 자신의 위치를 유지하는 것을 쉽게 발견할 수 있다. 정보화의 발전과 함께 이러한 “바라문”들의 권력은 점차 깨지고 있으며, 새로운 사회 유동성이 작은 현청의 모습을 변화시키기 시작하고 있다.&lt;/p&gt;
&lt;p&gt;전반적으로 볼 때, “현급 도시 브라만”은 흥미로운 사회 현상이며 지방 사회의 권력과 문화 구조를 반영합니다. 비록 그들의 “권력”이 국가 통치에 직접적인 위협이 되지는 않지만, 지방 내에서는 부인할 수 없을 정도로 중요한 인물들입니다. 정보가 빠르게 유통되고 사회 변화가 가속화되는 시대에, 현급 도시의 이러한 “브라만”들은 아마도 그 어느 때보다 큰 도전에 직면하고 있을 것입니다.&lt;/p&gt;
&lt;h1 id=&#34;결론&#34;&gt;결론
&lt;/h1&gt;&lt;p&gt;원래 이 원고가 있을 일도 없었는데, 그냥 &lt;code&gt;브라만&lt;/code&gt;이 뭔지 궁금해서 &lt;code&gt;키미&lt;/code&gt;한테 던졌더니 꽤 웃기더라고. 웹사이트에서 검색 결과가 나왔다가 바로 관련 내용 표시할 수 없다는 메시지로 바뀌길래, 이 단어에 특별한 의미가 있는 건 아닐까 생각하고 &lt;code&gt;ChatGPT&lt;/code&gt;에 넣어봤더니 이렇게 글이 완성됐네.&lt;/p&gt;</description>
        </item>
        <item>
        <title>리눅스 백엔드 서비스 문자열 데이터 처리 - 속도가 느림</title>
        <link>https://ttf248.life/ko/p/linux-backend-slow-string-processing/</link>
        <pubDate>Wed, 13 Nov 2024 19:42:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/linux-backend-slow-string-processing/</guid>
        <description>&lt;p&gt;C++ 개발의 과거 프로젝트에서 우리는 자체 프로토콜을 사용하여 통신했고, 이 프로토콜은 2차원 배열 패턴을 채택했습니다. 대량의 데이터를 처리할 때 프로토콜 내부에서 배열을 순회하고 시리얼화 작업을 수행하여 로그를 생성해야 했는데, 효율성이 낮아 시스템이 고부하 상태에서 눈에 띄는 끊김 현상을 일으켰고, 이로 인해 사업 부서로부터 시스템 끊김에 대한 피드백을 받았습니다.&lt;/p&gt;
&lt;h2 id=&#34;문제-파악&#34;&gt;문제 파악
&lt;/h2&gt;&lt;p&gt;문제 해결 과정에서, 우리는 먼저 시스템 성능을 분석했고, 대량의 데이터를 처리할 때 CPU 사용률이 눈에 띄게 증가하고 시스템 응답 시간이 길어지는 것을 확인했습니다. 시스템 로그를 분석한 결과, 많은 양의 직렬화 작업이 있었고, 이러한 작업은 특히 2차원 배열을 처리할 때 효율성이 낮아 시스템 성능 저하를 유발하는 것으로 나타났습니다.&lt;/p&gt;
&lt;p&gt;pstack 도구로 스레드 정보를 캡처한 결과, 로그 스레드가 대부분의 시간을 문자열 연결 처리에 소비하는 것으로 나타났다&lt;/p&gt;
&lt;p&gt;여기 오늘의 핵심인데, 다른 누적 방식에 따라 효율성이 엄청나게 달라집니다. 기존 코드에서는 + 연산자를 사용했는데, 이 방식은 빈번하게 임시 객체를 생성하므로 효율이 매우 낮습니다. 그 비효율성을 알고는 있지만, 얼마나 비효율적인지 제대로 모르는 그런 종류입니다.&lt;/p&gt;
&lt;h2 id=&#34;데모-검증&#34;&gt;데모 검증
&lt;/h2&gt;&lt;p&gt;프로젝트 코드를 기반으로 비즈니스 로직을 분리하고, 문자열 연결 효율성 문제를 검증하기 위한 간단한 데모를 작성했습니다. &lt;code&gt;windows&lt;/code&gt; 환경의 &lt;code&gt;vs2022&lt;/code&gt; 컴파일러와 &lt;code&gt;linux&lt;/code&gt; 환경의 &lt;code&gt;gcc8.5&lt;/code&gt; 컴파일러로 &lt;code&gt;Release&lt;/code&gt; 모드에서 컴파일 및 실행하여 효율성을 비교했습니다.&lt;/p&gt;
&lt;h3 id=&#34;주요-사항-안내&#34;&gt;주요 사항 안내
&lt;/h3&gt;&lt;p&gt;프로젝트에서는 방법 네 가지를 사용했는데, 테스트 데이터를 받기 전 독자들은 어떤 방식이 가장 효율적이고 어떤 방식이 가장 비효율적인지 먼저 생각해 볼 수 있습니다. 결과를 보았을 때 저는 여전히 놀랐습니다.&lt;/p&gt;
&lt;p&gt;방법 1 (&lt;code&gt;+=&lt;/code&gt; 연결): 각 필드를 &lt;code&gt;+=&lt;/code&gt; 연산자를 사용하여 문자열에 직접 연결합니다
방법 2 ( &lt;code&gt;std::ostringstream&lt;/code&gt; 연결): 스트림(&lt;code&gt;std::ostringstream&lt;/code&gt;)을 사용하여 각 필드를 연결하는 방법으로, 특히 대량의 데이터를 연결할 때 더 효율적입니다
방법 3(미리 할당된 메모리의 += 연결): &lt;code&gt;reserve&lt;/code&gt;를 사용하여 문자열에 필요한 충분한 메모리를 미리 할당하면 메모리 재할당 비용을 줄여 성능을 향상시킬 수 있습니다
방법 4(&lt;code&gt;bodys = bodys + body + &amp;quot;\n&amp;quot;&lt;/code&gt;): 매번 연결할 때마다 새로운 임시 문자열 객체를 생성하므로, 특히 대규모 연결 시 성능 저하가 발생합니다. 이는 매번 연결이 새로운 메모리 할당 및 복사를 수반하기 때문입니다.&lt;/p&gt;
&lt;p&gt;참고 결과, 프로젝트가 효율이 가장 낮은 방식을 선택한 것을 알 수 있습니다&lt;/p&gt;
&lt;p&gt;더 나아가, 다양한 플랫폼 컴파일러의 최적화 효율을 분석해 보겠습니다. 마이크로소프트의 &lt;code&gt;Visual Studio&lt;/code&gt;는 여전히 뛰어난 성능을 보여주며 문자열 최적화 효율이 매우 높지만, &lt;code&gt;gcc&lt;/code&gt; 컴파일러는 이 부분에서 최적화 효율이 다소 떨어지는 편입니다.&lt;/p&gt;
&lt;p&gt;코드 실행 환경이 다른 기계에서 이루어지므로 데이터 간의 직접적인 비교는 의미가 없습니다. 각각의 조인 방법 간의 차이를 비교하는 것이 좋습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;windows 平台下的 vs2022 编译器

----------------------------------------
Data Generation Time: 0.054 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.053 seconds.
+ ostringstream Data merging took: 0.054 seconds.
+ Pre-reserved Data merging took: 0.045 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 16.108 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;linux 平台下的 gcc8.5 编译器
----------------------------------------
Data Generation Time: 0.108 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.100 seconds.
+ ostringstream Data merging took: 0.083 seconds.
+ Pre-reserved Data merging took: 0.057 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 29.298 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;전체-코드&#34;&gt;전체 코드
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;random&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;iomanip&amp;gt;

typedef std::vector&amp;lt;std::string&amp;gt; DataRow;
typedef std::vector&amp;lt;DataRow&amp;gt; DataGroup;

struct ResponsePackage
{
    std::string ErrorInfo;
    DataRow Head;
    std::string ClientId;
    std::string UUID;
    std::string MsgID;
    std::string SessionID;
    std::string ExtraInfo1;
    std::string ExtraInfo2;
    DataGroup DataBody;
};

// Generate specified length of random string
std::string generateRandomString(size_t length)
{
    const char charset[] = &amp;quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&amp;quot;;
    const size_t max_index = sizeof(charset) - 1;
    std::string random_string;
    random_string.reserve(length);

    std::random_device rd;
    std::mt19937 generator(rd());
    std::uniform_int_distribution&amp;lt;&amp;gt; distribution(0, max_index);

    for (size_t i = 0; i &amp;lt; length; ++i)
    {
        random_string += charset[distribution(generator)];
    }

    return random_string;
}

void create_large_string()
{
    // Example request package with 50 fields
    ResponsePackage requestPackage;

    requestPackage.Head = {
        &amp;quot;Field1&amp;quot;, &amp;quot;Field2&amp;quot;, &amp;quot;Field3&amp;quot;, &amp;quot;Field4&amp;quot;, &amp;quot;Field5&amp;quot;,
        &amp;quot;Field6&amp;quot;, &amp;quot;Field7&amp;quot;, &amp;quot;Field8&amp;quot;, &amp;quot;Field9&amp;quot;, &amp;quot;Field10&amp;quot;,
        &amp;quot;Field11&amp;quot;, &amp;quot;Field12&amp;quot;, &amp;quot;Field13&amp;quot;, &amp;quot;Field14&amp;quot;, &amp;quot;Field15&amp;quot;,
        &amp;quot;Field16&amp;quot;, &amp;quot;Field17&amp;quot;, &amp;quot;Field18&amp;quot;, &amp;quot;Field19&amp;quot;, &amp;quot;Field20&amp;quot;,
        &amp;quot;Field21&amp;quot;, &amp;quot;Field22&amp;quot;, &amp;quot;Field23&amp;quot;, &amp;quot;Field24&amp;quot;, &amp;quot;Field25&amp;quot;,
        &amp;quot;Field26&amp;quot;, &amp;quot;Field27&amp;quot;, &amp;quot;Field28&amp;quot;, &amp;quot;Field29&amp;quot;, &amp;quot;Field30&amp;quot;,
        &amp;quot;Field31&amp;quot;, &amp;quot;Field32&amp;quot;, &amp;quot;Field33&amp;quot;, &amp;quot;Field34&amp;quot;, &amp;quot;Field35&amp;quot;,
        &amp;quot;Field36&amp;quot;, &amp;quot;Field37&amp;quot;, &amp;quot;Field38&amp;quot;, &amp;quot;Field39&amp;quot;, &amp;quot;Field40&amp;quot;,
        &amp;quot;Field41&amp;quot;, &amp;quot;Field42&amp;quot;, &amp;quot;Field43&amp;quot;, &amp;quot;Field44&amp;quot;, &amp;quot;Field45&amp;quot;,
        &amp;quot;Field46&amp;quot;, &amp;quot;Field47&amp;quot;, &amp;quot;Field48&amp;quot;, &amp;quot;Field49&amp;quot;, &amp;quot;Field50&amp;quot;
    };

    requestPackage.ClientId = &amp;quot;ClientID&amp;quot;;
    requestPackage.UUID = &amp;quot;UUID&amp;quot;;
    requestPackage.MsgID = &amp;quot;MsgID&amp;quot;;
    requestPackage.SessionID = &amp;quot;SessionID&amp;quot;;
    requestPackage.ExtraInfo1 = &amp;quot;ExtraInfo1&amp;quot;;
    requestPackage.ExtraInfo2 = &amp;quot;ExtraInfo2&amp;quot;;

    // Start timing for data generation
    auto start_gen = std::chrono::high_resolution_clock::now();

    // Generate 10,000 rows of data, each with 50 fields
    for (size_t i = 0; i &amp;lt; 10000; ++i)
    {
        DataRow dataRow(50, &amp;quot;This is a test string&amp;quot;);
        requestPackage.DataBody.push_back(dataRow);
    }

    // End timing for data generation
    auto end_gen = std::chrono::high_resolution_clock::now();
    std::chrono::duration&amp;lt;double&amp;gt; duration_gen = end_gen - start_gen;

    // Display result generation time
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Generation Time: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_gen.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    // Data merging using different methods
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Performance:\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    {
        // Method 1: Using &#39;+=&#39; string concatenation
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (+=) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 2: Using ostringstream
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::ostringstream bodys;
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::ostringstream body;
            body &amp;lt;&amp;lt; &amp;quot;This is a test string&amp;quot;;
            for (auto&amp;amp; item : vec)
            {
                body &amp;lt;&amp;lt; item &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            }
            bodys &amp;lt;&amp;lt; body.str() &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ ostringstream Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 3: Pre-allocated memory
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys;
        bodys.reserve(1000 * 50 * 20); // Pre-allocate enough memory
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            body.reserve(50 * 20); // Pre-allocate memory for each row
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Pre-reserved Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 4: Using &#39;bodys = bodys + body + &amp;quot;\n&amp;quot;&#39;
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body = body + item + &amp;quot; &amp;quot;; // Note the use of &#39;body = body + item&#39;
            }
            bodys = bodys + body + &amp;quot;\n&amp;quot;; // Again, using &#39;bodys = bodys + body&#39;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (bodys = bodys + body + \&amp;quot;\\n\&amp;quot;) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Complete.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;
}

int main()
{
    try
    {
        create_large_string();
    }
    catch (const std::exception&amp;amp; e)
    {
        std::cerr &amp;lt;&amp;lt; &amp;quot;Caught exception: &amp;quot; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\nProgram finished.\n&amp;quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43; 람다 표현식 매개변수 생명 주기</title>
        <link>https://ttf248.life/ko/p/cpp-lambda-parameter-lifetime/</link>
        <pubDate>Wed, 13 Nov 2024 19:23:02 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/cpp-lambda-parameter-lifetime/</guid>
        <description>&lt;p&gt;C++에서 람다 표현식은 외부 변수를 캡처하여 그 안에서 사용할 수 있는 편리한 익명 함수입니다. 이는 람다가 유연한 프로그래밍 도구가 되도록 합니다. 하지만 람다 표현식의 매개변수 생명 주기는 특히 캡처 및 전달 시 특별히 주의해야 할 측면입니다.&lt;/p&gt;
&lt;h3 id=&#34;람다-표현식의-매개변수-생명-주기&#34;&gt;람다 표현식의 매개변수 생명 주기
&lt;/h3&gt;&lt;p&gt;람다 표현식의 매개변수 수명은 일반적으로 다른 C++ 함수와 동일합니다. 함수의 매개변수는 함수 호출 시 존재하며, 함수 호출이 종료되면 매개변수 수명이 종료됩니다. 하지만 람다 표현식이 외부 변수를 캡처할 수 있기 때문에 매개변수 수명은 캡처 방식에 영향을 받기도 합니다.&lt;/p&gt;
&lt;h3 id=&#34;포획과-매개변수-생명-주기의-관계&#34;&gt;포획과 매개변수 생명 주기의 관계
&lt;/h3&gt;&lt;h4 id=&#34;외부-변수-캡처&#34;&gt;외부 변수 캡처
&lt;/h4&gt;&lt;p&gt;C++ 람다 표현식은 외부 변수를 두 가지 방식으로 캡처할 수 있습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;값 캡처: 값 캡처를 통해 외부 변수의 값이 람다 내부에 복사되고, 람다 내부의 복사본은 람다의 생명주기에 의해 제어됩니다&lt;/li&gt;
&lt;li&gt;참조 캡처: 참조 캡처를 통해 외부 변수의 참조가 유지되며, 람다 내부의 참조는 원래 외부 변수를 가리키고, 생명 주기는 외부 변수에 의존합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda_by_value = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };  // 捕获x的副本
auto lambda_by_reference = [&amp;amp;x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };  // 捕获x的引用

lambda_by_value();  // 打印10
lambda_by_reference();  // 打印10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;캡처된 변수의 수명 주기는 다음과 같습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;값 캡처: 캡처 시 외부 변수의 값이 람다에 복사되고, 람다가 종료될 때 복사된 사본이 파괴됩니다&lt;/li&gt;
&lt;li&gt;람다가 외부 변수를 참조할 때, &lt;strong&gt;외부 변수는 람다 사용 전에 유효해야 하며, 그렇지 않으면 정의되지 않은 동작이 발생할 수 있습니다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;람다-매개변수&#34;&gt;람다 매개변수
&lt;/h4&gt;&lt;p&gt;람다 함수의 매개변수는 일반 함수 매개변수와 유사하며, 그 수명은 람다 함수 내에서만 유효합니다. 즉, 람다 매개변수는 람다 호출 시 생성되고, 람다 호출이 종료되면 매개변수의 수명도 함께 종료됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto lambda = [](int a, int b) {
    std::cout &amp;lt;&amp;lt; a + b &amp;lt;&amp;lt; std::endl;
};
lambda(5, 10);  // a和b在这里是lambda的参数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 예제에서, &lt;code&gt;a&lt;/code&gt;와 &lt;code&gt;b&lt;/code&gt;는 람다 표현식의 매개변수이며, 람다 호출 시 생성되고 람다 실행 종료 후 파괴됩니다&lt;/p&gt;
&lt;h3 id=&#34;외부-변수-캡처-시-라이프사이클-문제&#34;&gt;외부 변수 캡처 시 라이프사이클 문제
&lt;/h3&gt;&lt;h4 id=&#34;람다-외부에서-포획된-변수가-유효한지&#34;&gt;람다 외부에서 포획된 변수가 유효한지
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;람다 호출 후 외부 변수가 파괴되더라도 람다는 여전히 외부 변수의 복사본을 보유합니다. 따라서 외부 변수가 더 이상 존재하지 않더라도 람다 내부의 복사본은 안전하게 사용할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x 在lambda调用后修改
lambda();  // 打印10，捕获的是x的副本
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;캡처된 변수가 참조에 의한 캡처인 경우, 람다 내부에서 해당 참조에 대한 접근은 외부 변수의 수명 주기(lifetime)에 의존합니다. 만약 외부 변수가 람다가 실행되기 전에 소멸된다면, 댕글링 포인터(dangling reference) 문제가 발생하여 정의되지 않은 동작을 초래할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [&amp;amp;x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x 在lambda调用前修改
lambda();  // 打印20，捕获的是x的引用
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;람다 함수의 실행 순서가 불확실한 경우, 람다가 실행될 때 캡처된 외부 변수가 여전히 유효한지 확인하는 것이 중요합니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>Win11 로지텍 G431 헤드셋 드라이버 설치</title>
        <link>https://ttf248.life/ko/p/win11-logitech-g431-headphone-driver-installation/</link>
        <pubDate>Wed, 05 Jun 2024 07:20:17 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/win11-logitech-g431-headphone-driver-installation/</guid>
        <description>&lt;p&gt;책은 지난 번에 이어져서, 돌아와 보니 Ghub이 업데이트되었네. 조금 기뻤는데, 고객센터에서 해결했다고 하는 문제 드라이브가 정상적으로 로드되지 않는 문제가 해결되었다고 했는데, 결과적으로 한 바퀴 뱅글뱅글 돌리고 재설치 및 제거를 해도 제대로 사용하지 못하네.&lt;/p&gt;
&lt;h2 id=&#34;배경&#34;&gt;배경
&lt;/h2&gt;&lt;p&gt;계속 고객센터에 문의하여 처리 방안을 알아보니, 엔지니어의 원격 지원은 가능하지만 엔지니어의 근무 시간과 제 근무 시간이 똑같다는 답변을 받았습니다. 어쩔 수 없이 포기하고, 이전 문제 해결 과정에서 남겨둔 자료를 살펴보며 직접 드라이버를 설치해 보려고 합니다.&lt;/p&gt;
&lt;h2 id=&#34;드라이버-설치-패키지-받기&#34;&gt;드라이버 설치 패키지 받기
&lt;/h2&gt;&lt;p&gt;로지텍 공식에서는 별도의 장치 드라이버 설치 파일을 제공하지 않습니다. 드라이버 파일은 어떻게 얻을 수 있나요?&lt;/p&gt;
&lt;p&gt;이전 시스템 재설치로 남은 시스템 이미지 설치 패키지를 활용하여, 로컬 가상 머신에서 시스템을 다시 설치할 수 있습니다. 깨끗한 시스템 환경에서 Ghub를 개별적으로 배포하고, 헤드폰 장치를 가상 머신에 연결한 후 드라이버 경로를 찾아 복사해낼 수 있습니다.&lt;/p&gt;
&lt;p&gt;관련 경로:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C:\ProgramData\LGHUB&lt;/li&gt;
&lt;li&gt;C:\Windows\System32\DriverStore\FileRepository\logi_audio.inf_amd64_010b035044e24be4&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장치-관리자&#34;&gt;장치 관리자
&lt;/h2&gt;&lt;p&gt;두 번째 경로를 찾는 것이 핵심인데, 먼저 Win11 시스템에서 드라이버 파일을 수동으로 관리하는 방법을 간단히 정리해 보겠습니다. 이 내용은 &lt;strong&gt;변수 제어법을 통해 식별했는데, 가상 머신 안에서 장치를 계속 연결하고 분리하면서 장치 관리자에서 장치 정보를 분석하여 헤드폰에 대해 처리해야 할 세 개의 드라이버가 있다는 것을 확인했습니다&lt;/strong&gt;. 그 중 두 개는 시스템 내장 드라이버이고 하나는 로지텍에서 제공하는 것입니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;드라이버 관리자&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;상단 그림의 두 번째 드라이버는 로지텍에서 제공하는 것으로, 현재 장치의 드라이버를 분석하고 가상 머신 안에서 모든 드라이버 경로를 뒤져야 합니다. 당연히 logi로 시작하는 파일을 먼저 찾아야 하고, 파일 비교를 통해 드라이버 파일을 찾을 수 있습니다. 전체 폴더를 복사하면 드라이버 설치 패키지를 얻게 됩니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;드라이버 설치 패키지&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;드라이버-설치&#34;&gt;드라이버 설치
&lt;/h2&gt;&lt;p&gt;장치 관리자 인터페이스에서 “드라이버 업데이트”를 클릭한 다음, “내 컴퓨터에서 드라이버 찾아보기”를 클릭하면 다음과 같은 화면으로 진입합니다&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;드라이버 설치&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;물론 열면 드라이버 하나만 보일 텐데, 그것은 일반 USB 드라이버입니다. &amp;ldquo;디스크에서 설치&amp;quot;를 선택하고 경로가 앞서 복사해 놓은 폴더로 설정하면 됩니다. 설치 후에는 드롭다운 목록에 로지텍 특유의 드라이버가 추가될 것이고, 새로 설치된 드라이버로 장치 드라이버를 전환하면 됩니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;디스크 설치&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;인체학-장비-드라이버&#34;&gt;인체학 장비 드라이버
&lt;/h2&gt;&lt;p&gt;이 장치의 드라이버 파일은 모두 시스템에서 제공하는 것이므로, 장치 드라이버 앞에 느낌표가 있는지 확인하기만 하면 됩니다. 느낌표가 있다면 드라이버 선택 화면으로 들어가서 다른 유형의 드라이버로 임시로 변경한 후 다시 원래대로 돌리면 정상적으로 복구됩니다.&lt;/p&gt;
&lt;h2 id=&#34;완료&#34;&gt;완료
&lt;/h2&gt;&lt;p&gt;헤드폰 마이크 음량이 정상으로 돌아왔고, 익숙한 이어모니터 기능도 다시 작동하기 시작했습니다&lt;/p&gt;
&lt;p&gt;측음&lt;/p&gt;</description>
        </item>
        <item>
        <title>로지텍 헤드셋 드라이버 설치 실패</title>
        <link>https://ttf248.life/ko/p/logitech-headset-driver-installation-failed/</link>
        <pubDate>Fri, 31 May 2024 21:46:12 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/logitech-headset-driver-installation-failed/</guid>
        <description>&lt;p&gt;이런 것들을 전혀 모른다면, 처음부터 공식 고객센터에 연락했으면 몇 시간이고 끙끙거릴 필요가 없었을 텐데&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/logitech-headset-driver-installation-failed/20240531220709.png&#34;
	width=&#34;693&#34;
	height=&#34;489&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;GHUB&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;141&#34;
		data-flex-basis=&#34;340px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;최근에 제가 집에서 개발용으로 사용하는 데스크탑의 C드라이브 용량이 부족해져서, 특별히 256GB의 반납된 SSD를 따로 C드라이브로 사용하기로 했습니다. 하지만 자주 이것저것 만지작거려서 제대로 되지 않았습니다. 상하이로 이사 온 후 계속해서 여러 가지 일에 바빴는데, 드디어 지난주에 시간을 내어 시스템을 다시 설치했습니다.&lt;/p&gt;
&lt;p&gt;시스템 재설치 과정은 매우 순조로웠고, 일상적인 소프트웨어 설치와 개발 환경 구축에도 문제는 없었다. 며칠 후 휴식을 취하며 게임을 몇 판 하려고 할 때 마침 키보드와 헤드셋 드라이버가 아직 설치되지 않은 것을 알게 되었다. 이 두 장치는 모두 로지텍 제품이어서 GHUB 소프트웨어를 다운로드하여 하드웨어를 자동으로 인식하고 드라이버를 설치했다.&lt;/p&gt;
&lt;p&gt;하지만, 예기치 않은 일이 발생했다. 마우스 드라이버는 문제없이 설치되었지만 헤드셋 드라이버는 계속해서 &amp;ldquo;로딩 중&amp;quot;이라고 표시되었다. 최신 버전의 Windows 11 시스템과 로지텍 드라이버가 호환되지 않아 설치에 실패한 것 같다고 생각했다. 그래서 자료를 찾아보고 수동으로 드라이버를 설치하려고 시도했지만, 문제는 여전히 해결되지 않았다.&lt;/p&gt;
&lt;p&gt;이 두 장치의 드라이버는 각각 어떤 역할을 하는지 간단히 설명해 드릴게요&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;마우스 드라이버는 주로 마우스 이동 속도 등의 기능을 조절하는 데 사용됩니다. 매크로 기능은 거의 사용하지 않으며, 이전에 저장했던 설정을 불러오기만 하면 됩니다.&lt;/li&gt;
&lt;li&gt;이어폰의 드라이버는 주로 이어모니터링 기능에 사용되는데, 팀 음성 채팅 시 매우 유용합니다. 제 목소리를 들을 수 있게 해주죠. 시스템 마이크 설정에도 비슷한 모니터링 기능이 있지만, 드라이버로 구현했을 때 효과가 더 좋습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;몇 번이고 반복해서 시도했지만, 이어폰 드라이버가 제대로 로드되지 않습니다. 오늘 겨우 고객센터에 문의해 보았는데, 해결책이 있는지 확인했습니다. 고객센터에서는 최근 서버에 문제가 생겨 드라이버 다운로드가 비정상적으로 이루어지고 있다고 했습니다. 현재 이 문제를 처리 중이며, 다음 업데이트 후에 문제는 해결될 것이라고 하셨습니다.&lt;/p&gt;
&lt;p&gt;아직 헤드폰 드라이버 문제 해결은 못 했지만, 적어도 원인은 알게 되었고, 문제가 최대한 빨리 해결되기를 바랍니다&lt;/p&gt;
&lt;h2 id=&#34;마우스-드라이버-설정&#34;&gt;마우스 드라이버 설정
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/logitech-headset-driver-installation-failed/20240531220930.png&#34;
	width=&#34;1024&#34;
	height=&#34;768&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;G502&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;133&#34;
		data-flex-basis=&#34;320px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/logitech-headset-driver-installation-failed/20240531220903.png&#34;
	width=&#34;1024&#34;
	height=&#34;768&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;G502&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;133&#34;
		data-flex-basis=&#34;320px&#34;
	
&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>부동산 촉진 및 중앙은행, 4가지 조치 발표</title>
        <link>https://ttf248.life/ko/p/promote-real-estate-central-bank-four-measures/</link>
        <pubDate>Fri, 17 May 2024 20:42:25 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/promote-real-estate-central-bank-four-measures/</guid>
        <description>&lt;ul&gt;
&lt;li&gt;상품 주택 금리 하한선 폐지&lt;/li&gt;
&lt;li&gt;내일부터 주택도시기금 이율 0.25%p 인하&lt;/li&gt;
&lt;li&gt;최초 주택 구매 시 계약금 비율이 15%로 인하되었습니다&lt;/li&gt;
&lt;li&gt;3천억 위안 규모의 보조 주택 재융자&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;전국-차원에서-주택-구매자-1세대-및-2세대-주택-구입을-위한-상업용-주택-담론-금리-정책-하한제를-폐지합니다&#34;&gt;전국 차원에서 주택 구매자 1세대 및 2세대 주택 구입을 위한 상업용 주택 담론 금리 정책 하한제를 폐지합니다
&lt;/h2&gt;&lt;p&gt;중국인민은행 상하이본부, 각 성·자치구·직轄시 및 계획단일시 분행; 각 국유상업은행, 중국우정저축은행, 각 주식제상업은행:&lt;/p&gt;
&lt;p&gt;당 중앙과 국무원의 결정 및 배치에 따라, 중국 부동산 시장의 공급과 수요 관계의 새로운 변화와 인민대중의 양질 주택에 대한 새로운 기대에 부응하며, 부동산 시장의 안정적이고 건전한 발전을 촉진하기 위하여, 다음 사항과 관련하여 상업용 개인 주택 담론 이자율 정책을 조정하는 데 관한 사항을 다음과 같이 통지합니다&lt;/p&gt;
&lt;p&gt;첫째, 전국 차원에서 주택 구매자에게 적용되는 첫 번째 및 두 번째 주택에 대한 상업용 개인 주택 담론 금리 정책 하한선을 폐지한다&lt;/p&gt;
&lt;p&gt;인민은행 각 성급 분행은 인 도시별 정책 원칙에 따라 각 성급 시장이자율 담합기구에 지도하고, 관할 지역 내 각 도시 부동산시장 상황 및 지방 정부 통제 요구에 따라 자율적으로 해당 지역 내 각 도시 상업용 개인주택담보대출 금리 하한선 설정 여부 및 하한선 수준(있는 경우)을 결정한다&lt;/p&gt;
&lt;p&gt;은행 금융기관은 각 성(省)별 시장금리 결정 자율 규제 메커니즘에서 정한 금리 하한(有无)을 고려하고, 본 기관의 경영 상황, 고객 위험 상황 등을 종합하여 각 대출 건에 대한 구체적인 금리 수준을 합리적으로 결정해야 한다&lt;/p&gt;
&lt;h2 id=&#34;개인-주택-구입을-위한-공적금-대출-금리를-025p-인하&#34;&gt;개인 주택 구입을 위한 공적금 대출 금리를 0.25%p 인하
&lt;/h2&gt;&lt;p&gt;중국인민은행 상하이본부, 각 성·자치구·직轄시 및 계획단일시 분행; 각 정책성 은행, 국유상업은행, 중국우정저축은행, 각 주식제 상업은행:&lt;/p&gt;
&lt;p&gt;중국인민은행은 2024년 5월 18일부터 개인 주택 공적금 대출 금리를 0.25bp 인하할 것을 결정했다. 이에 따라 5년 이하(5년 포함) 및 5년 초과 첫 번째 주택 공적금 대출 금리는 각각 2.35%와 2.85%로, 5년 이하(5년 포함) 및 5년 초과 두 번째 주택 공적금 대출 금리는 각각 2.775% 이하 및 3.325%로 조정될 예정이다.&lt;/p&gt;
&lt;h2 id=&#34;최소-15-이상으로-계약금-비율을-조정합니다&#34;&gt;최소 15% 이상으로 계약금 비율을 조정합니다
&lt;/h2&gt;&lt;p&gt;중국인민은행 상하이본부, 각 성·자치구·직할시 및 계획단일시 분행; 국가금융감독관리총국 각 감독국; 각 국유상업은행, 중국우정저축은행, 각 주식제상업은행:&lt;/p&gt;
&lt;p&gt;당 중앙과 국무원의 결정 및 배치에 따라, 중국 부동산 시장의 공급과 수요 관계의 새로운 변화와 인민대중의 양질 주택에 대한 새로운 기대에 부응하며, 부동산 시장의 안정적이고 건전한 발전을 촉진하기 위하여, 개인 주택 담보 대출 정책 관련 사항을 다음과 같이 통지합니다&lt;/p&gt;
&lt;p&gt;주택 구입을 위한 주택담보대출을 받는 세대는 첫 주택 구매 시 최소 자기 자본 비율이 15% 이하로 조정되고, 두 번째 주택 구매 시 최소 자기 자본 비율은 25% 이하로 조정된다&lt;/p&gt;
&lt;p&gt;이와 기초로 중국인민은행 각 성급 분행, 국가금융감독관리총국 각 파출 기관은 도시 정부 조절 요구에 따라, 인성대응 원칙에 의거하여 관할 지역 각 도시의 최초 주택 구매 및 제2주택 구매를 위한 상업용 개인 주택 담보 대출 최소 초도 납입 비율 하한선을 자율적으로 결정한다&lt;/p&gt;
&lt;h2 id=&#34;중앙은행이-3천억-위안-규모의-주택-담보-재융자-대출을-설립할-예정이다&#34;&gt;중앙은행이 3천억 위안 규모의 주택 담보 재융자 대출을 설립할 예정이다
&lt;/h2&gt;&lt;p&gt;오후 4시, 주택도시건축부, 자연자원부, 중국인민은행, 국가금융감독관리총국 4개 부서가 국무원 정책 정례 브리핑에 모여 부동산 공약 이행 지원 관련 정책 상황을 소개했습니다&lt;/p&gt;
&lt;p&gt;상회에서 중국인민은행 부행장 타오링이 발표한 바에 따르면, 중앙은행은 3천억 위안의 주택보조대출을 설립하여 지방 국유기업이 합리적인 가격으로 이미 건설되었으나 판매되지 않은 상업용 주택을 매입하고, 이를 분양형 또는 임대형 주택보조주택으로 활용하도록 지원할 예정이다. 예상되는 은행 대출 규모는 5천억 위안이다.&lt;/p&gt;
&lt;p&gt;중국 인민은행에 따르면, 주택 보조 대출의 만기는 1년이며 최대 4회 연장 가능하고, 금리는 1.75%입니다. 이는 21개 전국의 은행을 대상으로 하며, 은행들이 도시 정부가 선정한 지방 국유 기업에 대한 대출을 장려하여 이미 건설되었지만 판매되지 않은 상업용 주택을 매입하여 주택 보조 용도로 활용하도록 유도합니다. 매입되는 상업용 주택은 부동산 개발 기업이 이미 건설했지만 아직 판매하지 않은 것으로 엄격히 제한됩니다.&lt;/p&gt;
&lt;p&gt;이 정책과 관련하여, 최근 중앙은행은 보장주택 재융자 대출에 관한 사항을 담은 통지를 발표할 예정이다&lt;/p&gt;</description>
        </item>
        <item>
        <title>은행 마케팅 전략과 개인 재무 관리의 균형 예술</title>
        <link>https://ttf248.life/ko/p/bank-marketing-personal-finance-balance/</link>
        <pubDate>Sun, 31 Mar 2024 01:33:48 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/bank-marketing-personal-finance-balance/</guid>
        <description>&lt;p&gt;최근, 집 수리 공사 때문에 생활비가 많이 늘었습니다. 평소에도 신용카드를 사용하고 있고, 결제 주기에 맞춰 돈을 갚고는 있지만, 비록 현금으로 충분한 편이지만, 더 선호하는 방법은 이러한 현금을 머니마켓 펀드에 넣어 약간의 추가 이자 수입을 얻는 것입니다. 동시에, 재정적 안정성을 확보하기 위해 만기가 되면 신용카드 청구서를 제때 상환할 수 있도록 자동 결제 기능을 설정했습니다.&lt;/p&gt;
&lt;h2 id=&#34;은행-현황-예금은-증가하고-대출은-감소함&#34;&gt;은행 현황: 예금은 증가하고, 대출은 감소함
&lt;/h2&gt;&lt;p&gt;경제 불확실성이 증가함에 따라 사람들은 소비나 투자보다는 저축을 선호하게 됩니다. 이는 은행의 예금액 증가는 물론이고, 예금자에게 더 많은 이자를 지급해야 함을 의미합니다. 반면, 소비와 투자의 감소로 인해 대출 수요가 줄어들면서 은행은 대출을 통해 이자 수입을 확보하기 어려워집니다.&lt;/p&gt;
&lt;p&gt;고객을 유치하고 유지하기 위해 은행은 더 경쟁력 있는 예금 금리를 제공해야 하며, 이는 은행의 순이자마진을 더욱 압박합니다. 동시에 경제 성장과 소비를 촉진하기 위해 중앙은행이 기준 금리를 인하하는 정책을 시행할 수 있는데, 이는 은행 대출 금리에 영향을 미치고 결국 은행의 수익성에 영향을 미칠 것입니다.&lt;/p&gt;
&lt;h2 id=&#34;은행-마케팅-전략-사용자-습관-형성&#34;&gt;은행 마케팅 전략: 사용자 습관 형성
&lt;/h2&gt;&lt;p&gt;최근 상환 기일이 다가왔습니다. 먼저, 중국은행에서 1년 무이자 할부 서비스를 제공했고, 이어서 중신은행에서도 연율 1.9%의 할부 금리 할인 혜택을 제공했습니다. 이러한 혜택에 직면하여 저는 두 은행의 할부 서비스를 이용하기로 선택했습니다.&lt;/p&gt;
&lt;p&gt;은행이 사용자 습관을 길러주기 위해 정말 아낌없이 투자한다는 것을 깨달았다. 은행 자금 유동성의 정의에 따르면, 나는 은행의 우수 고객에 해당해야 한다. 현재 은행의 자금 대출이 어려운 상황에서, 나에게 할부 의식을 심어주는 것은 실제로는 미래에 내가 겪을 수 있는 자금 운반 어려움에 대비하는 것이며, 그때 그들은 여기서 더 많은 이자 수입을 얻을 수 있을 것이다. 결국, 누구나 알고 있듯이 신용카드 청구서 분석의 이자는 결코 낮지 않다.&lt;/p&gt;
&lt;p&gt;은행은 무료 분할 납부 서비스와 저금리 분할 납부 혜택을 제공함으로써 신용카드의 사용 빈도와 한도를 늘리는 데 그치지 않고, 사용자들에게 긍정적인 이미지를 심어주었습니다. 이러한 전략의 변화는 은행이 시장 변화에 빠르게 대응하고 고객의 요구를 깊이 이해하는 것을 보여줍니다. 이와 같은 방식으로 은행은 자금 대출의 어려움을 해결했을 뿐만 아니라 미래의 수익을 위한 기반을 마련했으며, &lt;strong&gt;돈을 버는 것은 현재뿐만 아니라 장기적인 관점에서 봐야 합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;개인-재정-관리의-중요성&#34;&gt;개인 재정 관리의 중요성
&lt;/h2&gt;&lt;p&gt;비록 은행의 할부 혜택이 매력적으로 들릴 수 있지만, 사용자로서 과도하게 신용카드 할부에 의존할 경우 발생할 수 있는 위험을 인지해야 합니다. 우리는 자신의 상환 능력과 미래의 자금 필요를 충분히 고려하여 단기적인 재정적 편의 때문에 장기적인 부채 문제에 빠지지 않도록 해야 합니다. 개인 재무 관리의 핵심은 현재의 필요와 미래의 계획 사이의 균형입니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;대신 분할 결제 내역&lt;/p&gt;</description>
        </item>
        <item>
        <title>게임의 다차원성: 심리 발달과 사회적 오락의 교차점</title>
        <link>https://ttf248.life/ko/p/games-multidimensionality-psychological-development-social-entertainment-intersection/</link>
        <pubDate>Sat, 30 Mar 2024 15:07:45 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/games-multidimensionality-psychological-development-social-entertainment-intersection/</guid>
        <description>&lt;p&gt;오늘날 디지털 시대에 게임은 단순한 오락 이상의 의미를 가지며, 사람들의 일상생활에서 없어서는 안 될 중요한 부분으로 자리 잡았습니다. 심리학적으로 볼 때, 게임은 다양한 연령대의 사람들의 심리 발달 과정에서 각기 다른 역할을 수행하며, 사회적 교류와 즐거움과도 밀접하게 연결되어 있습니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;심리-상태&#34;&gt;심리 상태
&lt;/h2&gt;&lt;p&gt;젊은 세대는 자아를 탐색하고 정체성을 확립하는 단계에 있으며, &lt;strong&gt;게임은 그들에게 저렴한 비용으로 시도와 탐구를 할 수 있는 환경을 제공합니다.&lt;/strong&gt; 게임을 통해 그들은 다양한 역할과 삶을 경험하며 호기심과 탐구 욕구를 충족할 수 있습니다. 하지만 나이가 들어감에 따라 개인의 관심사와 가치관이 점차 안정화되면서, 게임은 더 이상 그들의 삶의 목표와 흥미를 충족시키지 못할 수도 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;사회성&#34;&gt;사회성
&lt;/h2&gt;&lt;p&gt;동시에, 게임은 사회 활동의 일부가 되었으며, 특히 젊은 세대에게 그러했습니다. 그들은 게임을 통해 친구를 사귀고 소셜 네트워크를 구축했으며, 게임은 사회적 교류의 다리 역할을 했습니다. 하지만 나이가 들어감에 따라 사람들의 교제 범위는 점차 안정되고, 사회적 욕구는 다른 더 성숙한 방식으로 충족될 수 있으며, 이로 인해 게임의 사회적 역할은 상대적으로 약화됩니다.&lt;/p&gt;
&lt;h2 id=&#34;소셜-속성-여자친구-데려오기&#34;&gt;소셜 속성: 여자친구 데려오기
&lt;/h2&gt;&lt;p&gt;국내에서는 연애 교육이 부족해서 어릴 때는 부모님들이 공부만 하라고 강요하고, 졸업하자마자 바로 연애를 시키는 현상이 흔하다&lt;/p&gt;
&lt;p&gt;학업, 직장 생활의 바쁘심이나 부족한 교류 능력으로 현실에서 안정적인 정서적 관계를 맺지 못해 고독감을 느끼고 관심받고 싶어 하는 사람들입니다. &lt;strong&gt;게임 내 “보호” 행위는 이러한 욕구를 해소할 수 있는 일종의 통로&lt;/strong&gt; 역할을 합니다. 여성 플레이어를 돕고 보호함으로써 필요한 존재라는 느낌, 즉 가치 있다고 여겨지는 감정을 경험하고 정서적 만족감을 얻을 수 있습니다.&lt;/p&gt;
&lt;p&gt;동시에, 게임 내의 상호작용 규칙은 명확하고 환경이 통제되므로 현실 생활의 복잡성과 불확실성에 비해 게임은 확실성과 안정감을 제공하며 현실적 교류에서 오는 불확실성에 대한 두려움을 줄여줍니다. 하지만, 장기적으로 게임 속 가상적인 만족감에 의존하면 현실에서 건강한 정서적 관계를 형성하고 유지하는 능력에 영향을 미칠 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;현실적인-압박&#34;&gt;현실적인 압박
&lt;/h2&gt;&lt;p&gt;게임은 플레이어가 현실의 스트레스, 도전 또는 불쾌한 감정에서 일시적으로 도피할 수 있는 가상 세계를 제공합니다. 특히 학업 스트레스, 가정 문제 또는 대인 관계의 어려움을 겪는 젊은이들에게 게임은 위안과 휴식을 구하는 방법이 될 수 있습니다.&lt;/p&gt;
&lt;p&gt;게임은 일반적으로 플레이어가 임무를 완료하거나, 레벨을 올리거나, 상대를 이길 때 성취감과 인정을 받도록 설계됩니다. 젊은이들은 게임에서 칭찬받고 인정받는 느낌을 받을 수 있기 때문에 중독될 수 있는데, 이러한 느낌은 현실에서는 부족할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;나이가-들어서-더-이상-놀고-싶지-않다&#34;&gt;나이가 들어서 더 이상 놀고 싶지 않다
&lt;/h2&gt;&lt;p&gt;젊을 때는 사회적 책임과 압박이 상대적으로 작아 게임에 더 많은 시간과 에너지를 쏟을 수 있었지만, 직장 생활이나 가정을 갖추면서 사회적 책임이 늘어나고 시간과 에너지가 더욱 귀해지면서 게임은 시간 낭비로 여겨질 수도 있고, 우선적인 휴식 방법으로 선택되지 않을 수도 있다&lt;/p&gt;
&lt;p&gt;나이가 들어감에 따라 사람들의 인지 능력과 관심사가 변하기도 한다. 젊을 때는 속도가 빠르고 화려한 게임에 흥미를 느낄 수 있지만, 경험이 쌓이면 전략적이고 스토리가 강하거나 깊이 있는 게임을 선호하게 될 수도 있다. 만약 시장의 게임들이 이러한 변화하는 요구를 충족시키지 못한다면, 자연히 관심은 줄어들 것이다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>위안화 환율이 상당한 변동성을 보이며 7.26을 돌파했습니다</title>
        <link>https://ttf248.life/ko/p/renminbi-exchange-rate-volatility/</link>
        <pubDate>Sat, 23 Mar 2024 00:31:13 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/renminbi-exchange-rate-volatility/</guid>
        <description>&lt;p&gt;위안화 환율의 변동과 대폭락은 전 세계 중앙은행의 움직임, 스위스 중앙은행의 예기치 않은 금리 인하, 미국 경제 지표의 실적, 그리고 시장의 인플레이션 및 금리 인하 기대 조정과 관련이 있을 수 있습니다. 이러한 요인들이 외환 시장과 주식 시장에 복합적으로 작용하여 위안화 환율 변동과 A주 시장 하락을 초래했습니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;제공해주신 링크 내용에 따르면 2024년 3월 22일, 위안화 환율이 상당한 변동성을 보였습니다. 자세한 내용은 다음과 같습니다:&lt;/p&gt;
&lt;p&gt;달러 대비 위안화 환율이 7.26을 돌파했습니다. 당일 개장 시 위안화가 약세를 보이면서 달러 대비 위안화는 장중 거래에서 7.24까지 상승한 후 7.24926, 또한 달러 대비 온전 위안화는 7.22를 넘어 7.22360으로 상승하며 모두 2023년 11월 17일 이후 최고치를 경신했습니다. 재림닷컴 기자가 보도 시점에 달러 대비 위안화는 7.26선을 돌파했으며, 최저치는 7.2639까지 하락했고 하락세가 이어지고 있습니다.&lt;/p&gt;
&lt;p&gt;중국 인민은행이 3월 22일 발표한 위안화-달러 중간 가격은 7.1004로, 62개 기점 하락 조정되었으며, 조정 폭이 다소 확대되었다&lt;/p&gt;
&lt;p&gt;A주 시장 반응: 여러 요인의 영향으로, 당일 A주 3대 지수는 하락 출발하여 하락세를 이어갔으며, 하락폭은 모두 1%를 넘어섰습니다&lt;/p&gt;
&lt;p&gt;외환 시장 변동 원인: 홍콩의 한 투자 기관에서 베테랑 외환 거래원이 설명하길, 외환 시장 변동은 주로 스위스 중앙은행의 예상치 못한 금리 인하로 인해 달러가 부상한 데 더해 미국 경제가 견조하고 인플레이션이 지속될 가능성으로 인해 금리 인하가 지연되면서 나타난 현상이며, 이로 인해 달러 지수가 상승했다&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;전 세계 중앙은행 동향&lt;/strong&gt;: 이번 주는 글로벌 시장의 “슈퍼 중앙은행 주간”으로, 미국, 일본, 영국, 호주 등 여러 국가의 중앙은행이 금리 결정을 발표할 예정입니다. 스위스 중앙은행은 예상 밖에도 금리를 인하했는데, 이는 코로나19 팬데믹 이후 G10 통화선진국의 중앙은행으로는 처음 있는 일이며 시장의 균형을 깨뜨렸습니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;광다은행 금융시장부 연구원 주무화는 최근 위안화가 다소 변동성을 보이고 있지만, 전반적인 폭은 달러 등 주요 통화에 비해 뚜렷하게 작으며, 단기적인 변동성은 연내 위안화의 안정적 상승 추세를 바꾸지 않을 것이라고 밝혔다&lt;/p&gt;</description>
        </item>
        <item>
        <title>파이썬 딕셔너리에 사용자 정의 객체 저장 시 참조와 깊은 복사의 중요성</title>
        <link>https://ttf248.life/ko/p/python-dictionary-custom-objects-reference-vs-deepcopy/</link>
        <pubDate>Fri, 22 Mar 2024 01:08:05 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/python-dictionary-custom-objects-reference-vs-deepcopy/</guid>
        <description>&lt;p&gt;파이썬 프로그래밍에서 딕셔너리는 매우 강력한 자료 구조이며, 키-값 쌍을 연결하고 이러한 데이터를 효율적으로 검색하고 조작할 수 있습니다. 사용자 정의 객체를 딕셔너리에 저장하려고 할 때 일반적으로 중요한 개념에 직면하는데, 파이썬에서의 객체 할당은 실제로 객체의 깊은 복사라기보다는 참조 할당입니다. 즉, 사용자 정의 객체를 딕셔너리에 넣으면 딕셔너리에는 해당 객체에 대한 참조가 저장되고 객체의 새로운 복사본이 저장되는 것이 아닙니다.&lt;/p&gt;
&lt;h2 id=&#34;사용자-정의-객체-저장의-기본-예제&#34;&gt;사용자 정의 객체 저장의 기본 예제
&lt;/h2&gt;&lt;p&gt;가정적으로 간단한 &lt;code&gt;Person&lt;/code&gt; 클래스가 있다고 가정해 봅시다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

# 创建一个 Person 对象
p1 = Person(&amp;quot;Alice&amp;quot;, 30)

# 将对象存储到字典中
people_dict = {}
people_dict[&amp;quot;alice&amp;quot;] = p1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 예제에서, &lt;code&gt;people_dict&lt;/code&gt; 딕셔너리는 이제 키가 &lt;code&gt;&amp;quot;alice&amp;quot;&lt;/code&gt;인 항목을 포함하고 있으며, 그 값은 &lt;code&gt;Person&lt;/code&gt; 타입의 &lt;code&gt;p1&lt;/code&gt; 객체에 대한 참조입니다. 만약 우리가 &lt;code&gt;p1&lt;/code&gt;의 속성을 수정한다면:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;p1.age = 31
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그러면 딕셔너리로 이 객체에 접근하면, 그 나이도 업데이트된 것을 확인할 수 있습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(people_dict[&amp;quot;alice&amp;quot;].age)  # 输出：31
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;딕셔너리에 저장되는 것은 &lt;code&gt;Person&lt;/code&gt; 객체의 독립적인 복사본이 아니라 동일한 메모리 주소를 가리키는 참조입니다&lt;/p&gt;
&lt;h2 id=&#34;깊은-복사와-얕은-복사의-차이점&#34;&gt;깊은 복사와 얕은 복사의 차이점
&lt;/h2&gt;&lt;p&gt;중첩된 데이터 구조나 사용자 정의 객체를 다룰 때는 이러한 참조 동작으로 인해 예기치 않은 결과가 발생할 수 있습니다. 예를 들어, 사용자 정의 객체에 변경 가능한 속성(예: 목록이나 다른 사용자 정의 객체)이 포함되어 있는 경우, 그런 객체를 딕셔너리에 직접 저장하고 수정하면 딕셔너리를 통해 얻은 객체가 영향을 받습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Address:
    def __init__(self, street, city):
        self.street = street
        self.city = city

class Person:
    def __init__(self, name, age, address):
        self.name = name
        self.age = age
        self.address = address

address = Address(&amp;quot;Main St.&amp;quot;, &amp;quot;Springfield&amp;quot;)
p1 = Person(&amp;quot;Bob&amp;quot;, 40, address)
people_dict[&amp;quot;bob&amp;quot;] = p1

# 修改原始地址对象
address.city = &amp;quot;Shelbyville&amp;quot;

# 字典中的人的地址也变了
print(people_dict[&amp;quot;bob&amp;quot;].address.city)  # 输出：Shelbyville
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;해결 방법: 깊은 복사&lt;/p&gt;
&lt;p&gt;이러한 공유 상태로 인해 발생하는 문제를 피하기 위해 때로는 딕셔너리에 객체의 완전한 복사본을 저장하도록 해야 하며, 참조가 아닌 복사본을 저장해야 합니다. 파이썬은 이를 달성하기 위해 &lt;code&gt;copy&lt;/code&gt; 모듈의 &lt;code&gt;deepcopy&lt;/code&gt; 함수를 제공합니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import copy

# 使用深拷贝存储对象
people_dict[&amp;quot;bob_deepcopy&amp;quot;] = copy.deepcopy(p1)

# 此时即使修改原始地址对象，深拷贝的对象不会受影响
address.city = &amp;quot;Capital City&amp;quot;
print(people_dict[&amp;quot;bob&amp;quot;].address.city)  # 输出：Capital City
print(people_dict[&amp;quot;bob_deepcopy&amp;quot;].address.city)  # 输出：Shelbyville
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;결론적으로, 파이썬에서 딕셔너리를 사용하여 사용자 정의 객체를 저장할 때는 기본적으로 객체 참조가 저장된다는 점에 유의해야 합니다. 독립적인 상태를 유지해야 하는 경우에는 &lt;code&gt;deepcopy&lt;/code&gt;를 사용하여 깊은 복사를 수행하여 공유 참조로 인한 예기치 않은 데이터 변경을 방지하십시오.&lt;/p&gt;</description>
        </item>
        <item>
        <title>전분 소시지와 길거리 노점: 자본의 뉴스 영향력</title>
        <link>https://ttf248.life/ko/p/sausages-and-street-vendors-capital-news-influence/</link>
        <pubDate>Mon, 18 Mar 2024 00:31:58 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/sausages-and-street-vendors-capital-news-influence/</guid>
        <description>&lt;p&gt;315은 실제로는 기골반에 대한 보도를 하지 않았고, 이 문제는 3·15 춘절회의의 공식 노출과 동시에 발생한 다른 식품안전 문제들을 혼동하고 있다&lt;/p&gt;
&lt;h2 id=&#34;지식인-답변-언론학&#34;&gt;지식인 답변: 언론학
&lt;/h2&gt;&lt;p&gt;315晚会一共提了九个厂家，里面并没有淀粉肠，而现在搞得那些被提名的大品牌完全没热度，倒是把淀粉肠这种国民级（全国各地小吃街基本都会有并且摊位量应该也是第一）的小吃拉出来说事感觉淀粉肠完全就是被拉出来背锅的，我找了网上的新闻来源就是一个央广网在3.15那天发了个调查火腿肠的新闻，但也只是列出了几家厂家的成分，并且几个厂家也并不是主要生产淀粉肠的厂家，成分上并看不出什么毛病，然后这个b记者通过一个工厂员工说有时候用的是鸡骨泥替代鸡肉也就是听说，然后她就去淘宝问宠物食品店卖鸡骨泥的商家，人能不能吃？，这不是sb问题吗？人家一个宠物食品敢说让你人吃？然后后面就传谣传成淀粉肠里含的都有鸡骨泥，鸡骨泥人不能吃。 315 행사에서 총 아홉 개 업체가 언급되었지만 찹쌀떡 소시지는 없었고, 현재는 언급된 대형 브랜드들의 관심이 전혀 없는 반면 찹쌀떡 소시지라는 국민 간식(전국 어디든 먹거리 거리에 기본적으로 있고 분량도 가장 많을 것으로 예상됨)을 꺼내서 문제 삼는 느낌이다. 마치 찹쌀떡 소시지가 희생양인 듯하다. 온라인 뉴스 출처를 확인해 보니, 중앙방송망에서 3월 15일에 햄 소시지 조사를 보도했는데, 몇몇 업체의 성분만 나열했을 뿐이고, 이 업체들은 찹쌀떡 소시지를 주로 생산하는 곳이 아니었다. 성분에 문제가 있는 것처럼 보이지 않았고, 그 기자(b)는 공장 직원의 말을 빌려 가끔 닭 뼈 반죽으로 닭고기를 대체한다고 했다는 이야기를 들었는데, 그래서 타오바오에서 닭 뼈 반죽을 파는 애완동물용품점에 사람이 먹어도 되는지 물어봤다. 이건 상식적인 문제인가? 애완동물 사료 업체가 사람이 먹으라고 말하겠나? 이후에는 찹쌀떡 소시지에 닭 뼈 반죽이 들어 있다고 루머가 퍼졌고, 닭 뼈 반죽은 사람이 먹을 수 없다는 이야기가 돌았다.&lt;/p&gt;
&lt;p&gt;지금 상황이 그렇다 보니 많은 공장들이 문을 닫을 판이고, 전국 수십만 명의 작은 노점상들은 물건을 사서 팔아도 장사가 안 돼서 일을 할 수가 없는 지경에 이르렀습니다&lt;/p&gt;
&lt;h2 id=&#34;인간의-진실&#34;&gt;인간의 진실
&lt;/h2&gt;&lt;p&gt;샤오샹청보(潇湘晨报) 17일 보도에 따르면, 3월 16일 허난성(河南省) 산먼샤(三門峽)에서 ‘전분 소시지 건물 붕괴’ 사건 다음 날, 한 노파가 전분 소시지를 팔기 위해 장사를 벌였지만 2시간이 지나도록 아무도 사지 않았고 결국 스스로 조용히 전분 소시지를 먹었다. 촬영자는 자신이 평소에 전분 소시지 4~5개를 한 번에 먹을 수 있다고 말했지만, 전분 소시지 안에 닭뼈 가루가 있다는 것을 알고는 단호하게 먹지 않겠다고 했다. 그는 당일 노출된 후에도 누가 전분 소시지를 사올까 궁금해서 살펴봤지만, 판매자가 2시간 동안 한 개도 팔지 못하는 모습을 보았다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;아저씨가 무슨 전분소시지 사건을 어찌 알겠습니까, 그는 단지 오늘 갑자기 아무도 자기 핫바를 사주질 않는다는 것만 알고 있을 뿐입니다&lt;/li&gt;
&lt;li&gt;할머니 말씀이 맞아요, 집안 살림을 위해 노력하실 뿐이에요. 할머니는 제품에 문제가 있는지, 품질은 되는지조차 모르시고, 뼈진흙이라는 단어 또한 모르세요. 그들은 인터넷을 알지도 못하고, 그저 밑바닥 사람으로서 살아남기 위해 애쓰실 뿐이에요.&lt;/li&gt;
&lt;li&gt;전분 소시지는 망했어요, 하지만 그 대가를 치르는 건 한 명 한 명의 하층 영업자들입니다. 고통스러운 과정이죠.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;규제-미흡&#34;&gt;규제 미흡
&lt;/h2&gt;&lt;p&gt;몇 년 전 어느 오후, 북경에 온 동료와 점심을 먹으러 가던 길에 꼬치와 철판 스테이크를 파는 작은 포장마차 옆을 지나갔다&lt;/p&gt;
&lt;p&gt;지금 당장 이런 블랙 테크놀로지 핫도그, 안심 스테이크를 먹을 여유가 있나? 내가 생각하기에 마지막으로 핫도그를 먹은 게 대략 10년 전쯤이었던 것 같다&lt;/p&gt;
&lt;p&gt;동료가 잠시 망설이다가 조심스럽게 말했습니다. “아마 도시에서 살아서 그런 것 같아요. 사실 고향처럼 작은 곳에서는 榨菜(zhà cài, 절임 채소), 라면, 소세지가 매일 먹는 일상 음식이에요.”&lt;/p&gt;
&lt;p&gt;학교 다닐 때, 시험을 만점 받아야만 아빠가 길에서 나에게 소시지 한 번 먹게 해 줬어. 위생 문제 때문이 아니라, 소시지가 어차피 1.5원이었고, 그 돈으로 두 근이나 되는 채소를 살 수 있었거든.&lt;/p&gt;
&lt;p&gt;비교적 편하게 불리는 라면, 탄산음료, 깡통꼬치 등을 “쓰레기 식품”이라고 하는 말은 베이징에 가서 공부를 하기 전에는 들어본 적이 없어요&lt;/p&gt;
&lt;p&gt;방금 내뱉은 말에서 오만함이 느껴졌다는 것을 깨달았고, 더 이상 말을 하지 않았다. 하지만 이 일은 내 기억에 깊이 남을 것이다.&lt;/p&gt;
&lt;p&gt;사실, 이게 중국 대부분 백성들의 일상이다&lt;/p&gt;
&lt;p&gt;그들의 삶에는 고급스러운 “지중해식 식단”, “유기농 채소”, “비GMO 대두” 같은 것들이 없었다. 그들은 저렴하고 맛있게 살 수 있는 채소, 고기, 간식을 구할 수 있는지만 신경 쓰고, 온 가족이 누리는 소박한 행복의 순간을 즐겼다.&lt;/p&gt;
&lt;p&gt;선반 위의 물건들이 어떤 성분으로 이루어져 있는지, 그들이 건강을 해칠 가능성은 없는지, 그리고 특이한 화학 성분이 포함되어 있는지&lt;/p&gt;
&lt;p&gt;원래부터 그들이 신경 쓰고 이해해야 할 일이 아니었어&lt;/p&gt;
&lt;p&gt;그들은 문제가 있는 것이라면 분명히 누군가가 관리해서 선반 위에 나타나지 않을 거라고 믿고 있었다&lt;/p&gt;
&lt;p&gt;하지만 315 행사를 보고 나서야 비로소 그게 아니라는 것을 알게 되었다&lt;/p&gt;
&lt;p&gt;시장의 전자저울, 주유소의 연료 펌프에는 고기술 개조 마더보드가 숨겨져 있어, UP주가 맞을 위험을 감수하고 영상을 촬영해야 감독 당국이 뒤늦게 알아차려 조사할 수 있다&lt;/p&gt;
&lt;p&gt;라이브 방송에서 판매하는 매채육, 길거리 노점에서 파는 전분 소시지… 알고 보니 썩은 고기나 뼈 가루를 사용했는데, CCTV 기자가 잠입 취재하여 영상을 촬영해야만 누군가 이를 확인하고 원산지를 조사하게 되는 것이었습니다&lt;/p&gt;
&lt;p&gt;텔레비전 채널과 공항 광고에서 엄청나게 홍보했던 “건강주”가 누군가가 영상을 촬영해 모든 속사정을 밝혀내자, 갑자기 치워지고 시민들 눈앞에서 사라졌다&lt;/p&gt;
&lt;p&gt;일년에 한 번 있는 315, 매번 추첨해서 다섯 여섯 개나 오랫동안 팔던 제품을 없애는데, 충분한가?&lt;/p&gt;
&lt;p&gt;그 사람들, 이미 먹어봤고 샀는데, 누구를 찾아야 할까요?&lt;/p&gt;</description>
        </item>
        <item>
        <title>새로 설치한 기가급 유선 광섬유 회선인데 속도 측정 시 100메가에 그치는 이유는 무엇인가요?</title>
        <link>https://ttf248.life/ko/p/new-gigabit-fiber-slow-speed/</link>
        <pubDate>Mon, 18 Mar 2024 00:29:02 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/new-gigabit-fiber-slow-speed/</guid>
        <description>&lt;p&gt;집안 네트워크를 번개처럼 빠릿하게 만들고 싶으신가요? 핵심은 랜 케이블 선택, 광모뎀 및 공유기 설정, 그리고 눈에 띄지 않는 작은 디테일을 이해하는 데 있습니다. 이 블로그는 6급 랜 케이블로 기가비트 네트워크를 구축하고 간단한 장비 점검과 설정을 통해 네트워크 속도를 제약 없이 유지하는 방법을 쉽게 알려드릴 것입니다. 함께 탐색하며 집안 인터넷 속도를 높여 봅시다!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;수동 복구&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;제1장-네트워크-전송-매체-심층-분석&#34;&gt;제1장: 네트워크 전송 매체 심층 분석
&lt;/h2&gt;&lt;p&gt;기가비트급 네트워크 접속을 논할 때, 정보를 고속으로 전송하는 매개체인 랜 케이블은 매우 중요한 역할을 합니다. 다음에서는 5급, 6급 및 7급 랜 케이블에 대해 자세히 설명하겠습니다.&lt;/p&gt;
&lt;h3 id=&#34;다섯-종류의-네트워크-케이블cat5&#34;&gt;다섯 종류의 네트워크 케이블(CAT5)
&lt;/h3&gt;&lt;p&gt;다섯 종류의 네트워크 케이블, CAT5라고도 불리는 이 케이블은 비교적 초기에 널리 사용된 트위스트 페어 케이블 유형으로, 각 선 코어가 정밀한 나선 구조 설계로 인해 신호 간섭을 줄입니다. 주로 10/100Mbps의 빠른 이더넷에 적용되며 최대 전송 주파수는 약 100MHz입니다. 과거에는 널리 사용되었지만 현재 기가비트 이상 속도를 추구하는 요구 사항을 충족하기 위해서는 물리적인 한계로 인해 다섯 종류의 네트워크 케이블은 요구를 만족시키지 못합니다.&lt;/p&gt;
&lt;h3 id=&#34;6가지-네트워크-케이블cat6&#34;&gt;6가지 네트워크 케이블(CAT6)
&lt;/h3&gt;&lt;p&gt;기술 발전과 함께 6가지 종류의 네트워크 케이블이 등장했습니다. 5가지 종류의 네트워크 케이블에 비해 6가지 종류의 케이블은 더 엄격한 제조 기준과 더욱 발전된 구조 설계로 제작되어, 전반적인 내성능과 데이터 전송 효율을 크게 향상시켰습니다. 최대 1Gbps의 전송 속도를 지원하며 이상적인 조건에서는 전송 거리가 100미터까지 가능하여, 기가비트 네트워크 접속 요구 사항에 정확히 부합합니다.&lt;/p&gt;
&lt;h3 id=&#34;7가지-네트워크-케이블-cat7&#34;&gt;7가지 네트워크 케이블 (CAT7)
&lt;/h3&gt;&lt;p&gt;7가지 종류의 네트워크 케이블은 현재 트위스트 페어 기술의 최첨단을 나타냅니다. 이는 전송 속도에서 비약적인 향상을 가져왔을 뿐만 아니라 이론적으로 최대 10Gbps의 초고속을 지원하며, 설계에 완전한 차폐 시스템을 적용하여 각 선 쌍 간의 차폐와 전체 외부층의 차폐를 포함함으로써 외부 전자파 간섭과 근접 교차 누화를 크게 줄여 데이터 전송의 안정성과 정확성을 보장합니다. 하지만 7가지 종류의 네트워크 케이블은 주로 미래의 10기가비트 이더넷 또는 특정 고 요구 사항 시나리오에 사용됩니다.&lt;/p&gt;
&lt;p&gt;기가비트 가정 네트워크 환경을 구축할 때, 기가 광섬유의 잠재력을 최대한 발휘하기 위해서는 6급 랜 케이블을 선택하는 것이 가장 경제적이고 효율적인 방법입니다. 동시에 모든 연결 케이블의 품질이 양호한지 확인하고 엄격하게 표준 배선 방식으로 작업하는 것도 네트워크 성능을 확보하는 중요한 단계입니다.&lt;/p&gt;
&lt;h2 id=&#34;제2장-네트워크-핵심-장비인-광모뎀-라우터-lan-포트-대역폭의-영향-심층-분석&#34;&gt;제2장: 네트워크 핵심 장비인 광모뎀, 라우터 LAN 포트 대역폭의 영향 심층 분석
&lt;/h2&gt;&lt;h3 id=&#34;광촉매와-lan-포트-대역폭의-중요성&#34;&gt;광촉매와 LAN 포트 대역폭의 중요성
&lt;/h3&gt;&lt;p&gt;광촉매, 정식 명칭 광섬유 모뎀은 가정용 초고속 인터넷 접속의 핵심 장비이며, 빛 신호를 디지털 신호로 변환하여 가정 네트워크 장비에서 사용하도록 하는 기능이 있습니다. 기가급 광섬유 사용자에게 있어 광촉매가 기가 전송을 지원하는지 여부가 특히 중요합니다. 만약 광촉매의 WAN 포트가 기가 속도를 지원하지 않는다면, 입구 광섬유 속도가 아무리 높아도 이 병목 현상으로 인해 기가 속도 내에서 제한됩니다. 마찬가지로 광촉매의 LAN 포트 또한 기가 출력 능력을 갖춰야 하며, 그렇지 않으면 연결된 라우터나 다른 장비는 진정한 기가 속도를 얻을 수 없습니다.&lt;/p&gt;
&lt;h3 id=&#34;라우터-lan-포트-대역폭의-역할&#34;&gt;라우터 LAN 포트 대역폭의 역할
&lt;/h3&gt;&lt;p&gt;라우터의 LAN 포트는 수신된 데이터를 각 단말 장치에 분배하는 역할을 합니다. 라우터의 LAN 포트가 100메가비트에 불과할 경우, 다른 장치의 구성이 아무리 좋아도 100메가비트 속도의 로컬 네트워크 통신만 가능합니다. 따라서 기가홈 파티를 구축할 때는 라우터의 WAN 포트가 기가 데이터를 수신할 수 있도록 하고, LAN 포트 또한 기가 수준의 데이터 출력 능력을 제공해야 모든 스마트 장치가 고속 네트워크가 제공하는 원활한 경험을 누릴 수 있습니다.&lt;/p&gt;
&lt;p&gt;또한, 주의해야 할 점은 일부 구형 또는 저가형 라우터는 LAN 포트 자동 협상 기능이 있을 수 있다는 것입니다. 즉, 라우터 자체는 기가비트를 지원하더라도 회선, 장치 호환성 등의 이유로 속도가 100메가비트 모드로 낮아질 수 있습니다. 따라서 기가비트 네트워크를 구현하기 위해서는 라우터 설정을 올바르게 구성하고 강제 기가비트 모드를 활성화하며 기가비트 스위치 또는 직접 연결 장치를 함께 사용하는 것이 중요한 단계 중 하나입니다.&lt;/p&gt;
&lt;p&gt;기가급 광섬유로 업그레이드한 후에는 반드시 기가급 ONT와 기가급 라우터로 교체하고, 모든 장비 인터페이스가 기가급 수준에 도달하는지 확인하십시오&lt;/p&gt;
&lt;h2 id=&#34;제3장-숨겨진-미스터리---끊어진-서브스레드가-어떻게-테라비트급-네트워크-속도에-영향을-미치는가&#34;&gt;제3장: 숨겨진 미스터리 - 끊어진 서브스레드가 어떻게 테라비트급 네트워크 속도에 영향을 미치는가
&lt;/h2&gt;&lt;h3 id=&#34;서브-라인-장애-및-네트워크-성능-저하&#34;&gt;서브 라인 장애 및 네트워크 성능 저하
&lt;/h3&gt;&lt;p&gt;측정 기간 동안 네트워크 연결은 항상 유지되었으며, 눈에 띄는 단절 현상은 없었습니다. 신규 입주형 광대역 회선이라 분배함 내부가 어수선하고, 가끔은 광모뎀 배선이나 전원 인터페이스 콘센트 위치를 조정하다 보니 간혹 기가 속도가 측정된 적도 있습니다.&lt;/p&gt;
&lt;p&gt;앞선 자료를 바탕으로 점검해 본 결과, 랜 케이블 모델과 광케이블 LAN 포트 속도를 분석했더니, 결국 범인은 랜 케이블 내부의 갈색 서브 와이어가 끊어진 것이었습니다&lt;/p&gt;
&lt;p&gt;설치 기사님이 크리스탈 헤드를 설치할 때 이 랜선에 조금 세게 힘을 가했고, 그 결과 한 선이 반쯤 끊어졌지만 완전히 끊어진 것은 아니었습니다. 이후 광모뎀 위치를 계속 조정하면서 위치를 옮기니 결국 완전히 끊어졌습니다.&lt;/p&gt;
&lt;h3 id=&#34;6가지-랜-케이블-8가닥-선의-기능-분석&#34;&gt;6가지 랜 케이블 8가닥 선의 기능 분석
&lt;/h3&gt;&lt;p&gt;여섯 종류의 네트워크 케이블은 TIA/EIA-568-B 표준을 따르며, 8개의 트위스트 페어 전선으로 구성되어 있으며, 색상 코딩은 다음과 같습니다:&lt;/p&gt;
&lt;p&gt;백귤 / 귤
백록 / 녹
흰색과 파란색 / 파란색
백갈색 / 갈색&lt;/p&gt;
&lt;p&gt;기가비트 이더넷(1000BASE-T) 표준 하에서, 이 8개의 선 중 4쌍의 선이 동시에 작동하며, 구체적인 역할 분담은 다음과 같습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;백오렌지와 오렌지 이 두 선(1&amp;amp;2)은 데이터를 전송(Tx+/-)하는 데 사용됩니다&lt;/li&gt;
&lt;li&gt;백록과 녹색의 이 선(3&amp;amp;6)은 데이터 수신(Rx+/-)에 사용됩니다&lt;/li&gt;
&lt;li&gt;백란과 남색의 이 선(4&amp;amp;5)과 백갈색과 갈색의 이 선(7&amp;amp;8)은 기가비트 이더넷에서는 원래 주 용도로 사용되지 않지만, 일부 고급 애플리케이션(예: 특정 PoE 전원 공급 또는 미래 기술 확장)에서 활성화될 수 있습니다. 반면 전통적인 100메가비트 네트워크에서는 1, 2, 3, 6번 선만 사용하는 것으로 충분합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;절단된-하위-링크가-네트워크-속도에-미치는-영향&#34;&gt;절단된 하위 링크가 네트워크 속도에 미치는 영향
&lt;/h3&gt;&lt;p&gt;위와 같은 상황에서 갈색의 부선(갈색 선 또는 갈색 흰색 선)이 끊어지면 이론적으로는 1Gbps 네트워크 환경에서 속도 저하가 발생할 수 있습니다. 왜냐하면 1Gbps 네트워크는 모든 네 쌍의 선이 동시에 양방향으로 데이터를 전송하여 최고 속도를 달성하기 때문입니다. 하지만 가정용 네트워크 장비에는 자동 협상 기능이 종종 존재하며, 케이블에 문제가 감지되면 정상적으로 작동하는 낮은 속도 모드, 즉 100Mbps 모드로 되돌아갑니다. 따라서 부선이 끊어져도 네트워크 연결은 유지되고 100Mbps 속도로 작동하는 이유가 바로 이것입니다.&lt;/p&gt;
&lt;p&gt;간단히 말해서, 하나의 갈색 보조 광섬유가 끊어진다고 해서 100메가 네트워크의 기본적인 작동에는 영향을 미치지 않지만, 기가비트 네트워크 환경에서는 네트워크 속도를 제한하는 중요한 요인이 될 수 있습니다. 심층적인 진단과 복구가 이루어져야 비로소 기가급 광섬유의 잠재력을 완전히 발휘할 수 있습니다. 이는 유사한 상황에 직면했을 때, 기본적인 연결에는 영향을 미치지 않는 것처럼 보이는 작은 결함이라 할지라도 네트워크 인프라의 잠재적인 문제를 간과해서는 안 된다는 점을 상기시켜 줍니다. 이러한 결함은 고속 네트워크 경험의 보이지 않는 장애물이 될 수 있기 때문입니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>WPF UI 스레드와 멈춤 문제 및 해결 방법</title>
        <link>https://ttf248.life/ko/p/wpf-ui-thread-and-freezing-issues-solutions/</link>
        <pubDate>Tue, 12 Mar 2024 07:12:21 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/wpf-ui-thread-and-freezing-issues-solutions/</guid>
        <description>&lt;p&gt;데스크톱 애플리케이션을 개발할 때, 특히 Windows Presentation Foundation(WPF) 프레임워크를 사용하여 리치 클라이언트 애플리케이션을 구축할 때는 애플리케이션의 원활성과 응답성을 보장하기 위해 사용자 인터페이스(UI) 스레드를 올바르게 처리하는 것이 매우 중요합니다. UI 스레드, 또는 메인 스레드는 창과 컨트롤 이벤트 처리, 레이아웃 계산 및 인터페이스 렌더링을 담당하는 핵심 스레드입니다. UI 요소와의 모든 상호 작용은 UI 스레드에서 실행되어야 하며, 이는 WPF는 물론 다른 대부분의 GUI 프레임워크가 따르는 기본 원칙입니다.&lt;/p&gt;
&lt;h2 id=&#34;ui-스레드가-무엇인가요&#34;&gt;UI 스레드가 무엇인가요?
&lt;/h2&gt;&lt;p&gt;WPF 애플리케이션 시작 시 UI 스레드는 운영체제에 의해 생성되고 애플리케이션의 주 창을 초기화합니다. 이는 애플리케이션 내에서 UI 구성 요소의 상태를 직접적으로 액세스하고 수정할 수 있는 유일한 스레드입니다. 즉, 버튼 클릭, 텍스트 상자 입력, 창 크기 변경과 같은 모든 사용자 상호 작용으로 발생하는 이벤트는 이 스레드 컨텍스트 내에서 처리됩니다. 동시에 WPF의 종속 속성 시스템, 데이터 바인딩 메커니즘 및 레이아웃 로직도 UI 스레드 위에서 동기적으로 실행됩니다.&lt;/p&gt;
&lt;h2 id=&#34;끊김-현상-및-원인&#34;&gt;끊김 현상 및 원인
&lt;/h2&gt;&lt;p&gt;UI 스레드가 장시간 점유되거나 차단될 때, 예를 들어 시간이 오래 걸리는 계산, 대량 데이터 로딩, 데이터베이스 쿼리 또는 기타 I/O 집약적인 작업을 수행할 때 발생합니다. 이로 인해 UI 스레드가 사용자 상호 작용 요청에 즉시 응답하지 못하고, 결과적으로 화면이 응답하지 않는(Freeze) 현상이 나타납니다. 흔히 “카통”이라고 불리는 이것은 사용자가 앱의 지연과 끊김을 명확하게 느낄 수 있으며, 심할 경우 &amp;ldquo;Application Not Responding&amp;rdquo;(ANR) 경고가 발생할 수도 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;ui-스레드의-두-가지-기본-규칙&#34;&gt;UI 스레드의 두 가지 기본 규칙
&lt;/h2&gt;&lt;p&gt;위와 같은 상황을 방지하기 위해 WPF 개발자는 다음 두 가지 주요 규칙을 준수해야 합니다&lt;/p&gt;
&lt;p&gt;UI 스레드에서 시간이 오래 걸리는 작업을 수행하지 마세요. UI 스레드를 멈추게 할 수 있는 작업은 가능한 한 백그라운드 스레드로 옮겨서 사용자 입력에 즉시 응답하고 화면 변경을 렌더링할 수 있도록 해야 합니다.
UI 스레드에서 직접 UI 요소를 업데이트하지 마세요. WPF의 보안 메커니즘 설계상, UI 요소 수정은 UI 스레드만 권한이 있습니다. 다른 스레드에서 직접 UI 상태를 변경하려고 하면 예외가 발생합니다. 따라서 백그라운드 스레드에서 계산이나 데이터 준비가 완료되더라도 적절한 크로스 스레드 통신 메커니즘을 통해 결과를 UI에 표시해야 합니다.&lt;/p&gt;
&lt;h2 id=&#34;비동기-프로그래밍-및-스레드-안전-업데이트-솔루션&#34;&gt;비동기 프로그래밍 및 스레드 안전 업데이트 솔루션
&lt;/h2&gt;&lt;p&gt;UI의 응답성을 유지하면서도 시간이 오래 걸리는 작업을 수행하기 위해 WPF는 개발자가 이 목표를 달성하도록 돕기 위한 다양한 비동기 프로그래밍 모델과 도구를 제공합니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;디스패처 객체: WPF의 디스패처 클래스는 작업 항목을 UI 스레드의 작업 큐에 배치하여 실행할 수 있습니다. &lt;code&gt;Dispatcher.Invoke&lt;/code&gt; 또는 &lt;code&gt;Dispatcher.BeginInvoke&lt;/code&gt; 메서드를 사용하여 백그라운드 스레드에서 안전하게 UI를 업데이트할 수 있습니다.&lt;/li&gt;
&lt;li&gt;C# 언어의 비동기 기능을 활용하면 &lt;code&gt;await&lt;/code&gt; 키워드를 사용하여 백그라운드 작업 완료를 기다리고, 완료 후 자동으로 UI 스레드로 돌아와서 이후 UI 업데이트 코드를 실행할 수 있습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;사례&#34;&gt;사례
&lt;/h2&gt;&lt;h3 id=&#34;ui를-업데이트하려면-dispatcherinvoke-메서드를-사용하세요&#34;&gt;UI를 업데이트하려면 &lt;code&gt;Dispatcher.Invoke&lt;/code&gt; 메서드를 사용하세요
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private void Button_Click(object sender, RoutedEventArgs e)
{
    // 假设这是一个耗时操作
    Task.Run(() =&amp;gt;
    {
        var result = LongRunningOperation(); // 这里是模拟一个耗时计算的方法
        
        // 当耗时操作完成后，在UI线程上更新UI
        Application.Current.Dispatcher.Invoke(() =&amp;gt;
        {
            LabelStatus.Text = $&amp;quot;计算结果: {result}&amp;quot;;
        });
    });
}

private string LongRunningOperation()
{
    // 模拟耗时操作
    Thread.Sleep(5000);
    return &amp;quot;已完成&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;asyncawait-키워드와-taskrun을-함께-사용하세요&#34;&gt;&lt;code&gt;async/await&lt;/code&gt; 키워드와 &lt;code&gt;Task.Run&lt;/code&gt;을 함께 사용하세요
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private async void Button_ClickAsync(object sender, RoutedEventArgs e)
{
    Button button = sender as Button;
    button.IsEnabled = false; // 防止用户重复点击

    try
    {
        // 开启后台任务
        var result = await Task.Run(() =&amp;gt; LongRunningOperation());

        // 在后台任务完成后，自动切换回UI线程更新UI
        LabelStatus.Text = $&amp;quot;计算结果: {result}&amp;quot;;
    }
    catch (Exception ex)
    {
        MessageBox.Show($&amp;quot;发生错误: {ex.Message}&amp;quot;);
    }
    finally
    {
        button.IsEnabled = true; // 重新启用按钮
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>GCC 버전 업그레이드로 인한 프로그램 충돌: 비표준 코드의 잠재적 위험</title>
        <link>https://ttf248.life/ko/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</link>
        <pubDate>Sun, 10 Mar 2024 23:19:06 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</guid>
        <description>&lt;p&gt;동일한 비즈니스 코드의 경우, 프로그램은 CentOS 7 환경에서 정상적으로 컴파일 및 실행되었지만, CentOS 8로 전환하고 최신 버전의 GCC를 사용하여 컴파일하면 프로그램이 충돌합니다. 주목할 점은 문제가 &lt;strong&gt;릴리스 모드&lt;/strong&gt;에서만 발생하며, &lt;strong&gt;디버그 모드&lt;/strong&gt;에서는 전혀 문제가 없다는 것입니다. 이와 같은 상황은 처음 경험했으며, 삼 일간의 조사 끝에 문제의 근본 원인을 찾았습니다.&lt;/p&gt;
&lt;h3 id=&#34;문제-파악&#34;&gt;문제 파악
&lt;/h3&gt;&lt;p&gt;일련의 점검을 거쳐 문제의 원인은 &lt;strong&gt;함수가 반환값을 갖지 못하는 것&lt;/strong&gt;으로 밝혀졌습니다. Release 모드에서는 GCC 최신 버전이 더 많은 최적화를 수행하는데, 이로 인해 명시적으로 반환값이 없는 함수 실행 과정에서 예상치 못한 로직이 발생하여 충돌을 일으켰습니다. 결론은 &lt;strong&gt;컴파일러 경고를 간과해서는 안 된다는 것입니다. 특히 기존 프로젝트에서는 일부 경고가 무시될 수도 있지만, 모든 경고를 차단하는 것은 피해야 합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;환경-설명&#34;&gt;환경 설명
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CentOS 7 GCC 버전:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39)
Copyright © 2015 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CentOS 8 GCC 버전:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 8.5.0 20210514 (Red Hat 8.5.0-21)
Copyright (C) 2018 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;붕괴-현상&#34;&gt;붕괴 현상
&lt;/h3&gt;&lt;p&gt;프로그램 충돌 스택을 분석하는 과정에서 다음과 같은 스택 정보를 확인했습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[New LWP 1385902]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib64/libthread_db.so.1&amp;quot;.
Core was generated by `./pstack_main`.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007ffe894b4420 in ?? ()
(gdb) bt
#0  0x00007ffe894b4420 in ?? ()
#1  0x00000000004008e9 in main ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 스택은 직관적이지 않아 보이고, 충돌 함수의 스택 정보가 &lt;code&gt;??&lt;/code&gt;로 표시되어 있어 문제 해결이 더욱 복잡해졌다&lt;/p&gt;
&lt;h3 id=&#34;코드-예시&#34;&gt;코드 예시
&lt;/h3&gt;&lt;p&gt;문제 이해를 돕기 위해, 오류 재현을 위한 최소 코드 예제는 다음과 같습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int test() {
    std::cout &amp;lt;&amp;lt; &amp;quot;1&amp;quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    test();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;해당 코드의 &lt;code&gt;test()&lt;/code&gt; 함수는 명시적으로 값을 반환하지 않음에도 불구하고, 반환 타입이 &lt;code&gt;int&lt;/code&gt;로 선언되어 있습니다. C++ 규격에 따르면 &lt;code&gt;int&lt;/code&gt; 타입으로 선언된 함수는 반드시 값을 반환해야 하며, 그렇지 않으면 정의되지 않은 동작을 초래할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;컴파일-경고&#34;&gt;컴파일 경고
&lt;/h3&gt;&lt;p&gt;우리 프로젝트에서 CMake 스크립트는 많은 컴파일 시 경고를 비활성화했으며, 그 중에는 다음과 같은 경고 메시지도 포함되어 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/root/pstack/main.cpp: In function ‘int test()’:
/root/pstack/main.cpp:7:1: warning: no return statement in function returning non-void [-Wreturn-type]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 경고는 &lt;code&gt;test()&lt;/code&gt; 함수가 값을 반환하지 않는다는 것을 의미하며, 이것이 문제의 근원입니다. 높은 버전의 GCC(예: 8.5.0)는 코드를 최적화할 때 이러한 정의되지 않은 동작에 대해 불안정한 최적화를 수행하여 프로그램 충돌을 일으킬 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;어셈블리-코드-차이&#34;&gt;어셈블리 코드 차이
&lt;/h3&gt;&lt;p&gt;GCC 컴파일러 최적화 동작의 차이를 설명하기 위해, 우리는 서로 다른 버전의 GCC가 생성한 어셈블리 코드를 비교했습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;GCC 4.8.5가 생성한 어셈블리 코드:&lt;/p&gt;
&lt;p&gt;어셈블리 코드는 다소 장황하며 표준 출력 스트림(예: &lt;code&gt;std::cout&lt;/code&gt;) 처리를 위한 로직을 포함하고 있습니다. 이는 컴파일러가 더 보수적인 최적화를 수행했으며, &lt;code&gt;test()&lt;/code&gt; 함수에서 누락된 반환값 문제에 대한 과도한 최적화를 하지 않았음을 시사합니다. 아마도 이로 인해 프로그램이 충돌하는 것을 피했을 것입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GCC 8.5.0에서 생성된 어셈블리 코드:&lt;/p&gt;
&lt;p&gt;새 버전의 GCC는 더 많은 최적화를 수행하여 코드 양을 줄였습니다. 하지만 이러한 최적화로 인해 반환 값이 없는 함수의 실행 시 동작이 불확실해져 프로그램이 충돌할 수 있습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;결론&#34;&gt;결론
&lt;/h3&gt;&lt;p&gt;이번 문제 해결 과정을 통해, C++에서 &lt;strong&gt;함수 반환 값은 명시적이어야 한다&lt;/strong&gt;는 것을 깊이 인식하게 되었습니다. 특히 함수가 &lt;code&gt;int&lt;/code&gt;로 선언된 경우 반드시 반환 값을 제공해야 합니다. 구 버전 컴파일러를 사용하는 프로젝트의 경우, 최신 버전 GCC로 업그레이드하면 더 많은 최적화와 엄격한 경고 메커니즘을 마주할 수 있습니다. 따라서 컴파일 시 &lt;strong&gt;모든 경고를 숨기지 말고&lt;/strong&gt;, 함수 반환 값, 타입 매칭 등과 같은 일반적인 문제에 대해 선택적으로 처리하는 것을 권장합니다.&lt;/p&gt;
&lt;p&gt;결국, &lt;code&gt;test()&lt;/code&gt; 함수에 반환값을 추가함으로써 문제가 해결되었고 프로그램이 정상적으로 작동하게 되었습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>VMware 가상 머신 CPU 리소스 사용량 이상</title>
        <link>https://ttf248.life/ko/p/vmware-virtual-machine-cpu-resource-usage-anomaly/</link>
        <pubDate>Sun, 10 Mar 2024 22:14:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/vmware-virtual-machine-cpu-resource-usage-anomaly/</guid>
        <description>&lt;p&gt;로컬 머신에 Windows 버전의 업무 시스템이 배포되어 있으며, CPU 자원 사용량은 약 5% 정도입니다. VMware에 설치된 CentOS8에서 Linux 버전의 업무 시스템을 배포했는데, 자원 사용량이 비정상적입니다.&lt;/p&gt;
&lt;h2 id=&#34;문제-설명&#34;&gt;문제 설명
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;호스트 시스템: win10 기업 버전&lt;/li&gt;
&lt;li&gt;vmware：17.5&lt;/li&gt;
&lt;li&gt;가상 머신: CentOS 8&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;가상 머신 리소스 할당은 &lt;code&gt;4C8GB&lt;/code&gt;로 설정하고, 비즈니스 시스템을 시작했습니다. 비즈니스 시스템은 가상 머신 Linux 시스템에 배포되었으며, 내부 top 명령어를 통해 시스템 리소스 사용량을 관찰한 결과 CPU 사용량은 높지 않았습니다. 하지만 외부 Windows 시스템에서 작업 관리자를 통해 확인했을 때 CPU 리소스 사용량이 매우 높았고, 프로세스를 확인해 보니 VMware 프로세스가 CPU 리소스를 많이 사용하고 있었습니다.&lt;/p&gt;
&lt;p&gt;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+
|         Windows           |
|                           |
|   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+  |
|   |      VMware        |  |
|   |      Program       |  |
|   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+  |
|                           |
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+&lt;/p&gt;
&lt;h2 id=&#34;지식점&#34;&gt;지식점
&lt;/h2&gt;&lt;p&gt;이 문제의 원인 분석은 순조롭지 않았는데, 그 이유는 도화선이 비즈니스 시스템 자체가 아니라 가상 머신 자체의 문제였기 때문이다. 어떻게 하면 일반적인 비즈니스 코드에서 벗어나 시스템 부하로 사고를 전환하고, 부하 데이터의 이상 현상을 통해 소프트 인터럽트를 찾아내어 결국 핵심에 다다를 수 있을까? 무엇이 VMware 소프트 인터럽트의 효율성을 저해하는 것일까? 본 논문에서는 먼저 각 지식 포인트를 설명하고 마지막으로 해결책을 제시한다.&lt;/p&gt;
&lt;h3 id=&#34;hyper-v&#34;&gt;hyper-v
&lt;/h3&gt;&lt;p&gt;윈도우 운영 체제의 가상화 기술이 중대한 변화를 겪었습니다. 마이크로소프트가 WSL을 처음 출시했을 때 Hyper-V 서비스를 활성화하면 VMware 가상 머신을 동시에 사용할 수 없었습니다. 이후 버전에서 VMware는 Hyper-V 서비스와 호환되게 되었습니다.&lt;/p&gt;
&lt;h3 id=&#34;시스템-부하&#34;&gt;시스템 부하
&lt;/h3&gt;&lt;p&gt;리눅스 시스템에서 &amp;ldquo;로드(load)&amp;ldquo;는 실행 중이거나 실행을 기다리는 프로세스의 수를 의미합니다. 로드는 일반적으로 1분, 5분, 15분 동안의 실행 대기열에 있는 평균 프로세스 수를 나타내는 세 자리 숫자로 표시됩니다. 이러한 숫자는 &amp;ldquo;uptime&amp;rdquo; 명령이나 &amp;ldquo;top&amp;rdquo; 명령을 실행하여 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;구체적으로 말씀드리면, 이 세 개의 숫자는 각각 다음을 의미합니다:&lt;/p&gt;
&lt;p&gt;1분간의 로드(load): 시스템이 지난 1분 동안 실행 중인 프로세스들의 평균 수량입니다
과거 5분 동안의 평균 실행 프로세스 수입니다
지난 15분 동안 시스템에서 실행 중인 프로세스 평균 수입니다&lt;/p&gt;
&lt;p&gt;부하의 의미는 시스템에서 실행을 기다리는 프로세스 수입니다. 이 숫자가 시스템의 논리 CPU 수보다 높으면 시스템 부하가 높다는 것을 나타내며, 많은 프로세스가 프로세서 리소스를 기다리고 있다는 뜻입니다. 부하 정도와 시스템 구성 및 성능에 따라 시스템이 느려지거나 응답하지 않을 수 있습니다.&lt;/p&gt;
&lt;p&gt;이상적으로는, 부하가 시스템의 논리 CPU 수 범위 내에 유지되어야 시스템 성능을 최적화할 수 있습니다. 부하가 지속적으로 CPU 수보다 높다면, 시스템 내 프로세스를 추가적으로 분석하여 높은 부하를 유발하는 원인을 파악하고, 시스템 리소스 할당을 조정하거나 프로세스 실행 방식을 최적화하기 위한 적절한 조치를 취해야 합니다.&lt;/p&gt;
&lt;h3 id=&#34;mpstat-로드-분석&#34;&gt;mpstat 로드 분석
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;mpstat&lt;/code&gt; 명령은 평균 로드, CPU 사용률, 인터럽트 및 컨텍스트 스위치와 같은 단일 또는 여러 프로세서의 다양한 정보를 보고하는 데 사용됩니다. &lt;code&gt;sysstat&lt;/code&gt; 패키지에서 &lt;code&gt;mpstat&lt;/code&gt;은 시스템 부하를 분석하는 데 유용한 도구입니다. 다음은 &lt;code&gt;mpstat&lt;/code&gt;을 사용하여 부하를 분석하는 단계입니다.&lt;/p&gt;
&lt;p&gt;설치 sysstat
시스템에 &lt;code&gt;sysstat&lt;/code&gt;이 설치되어 있지 않다면, 시스템에 적합한 패키지 관리 도구를 사용하여 설치할 수 있습니다&lt;/p&gt;
&lt;p&gt;mpstat 실행
&lt;code&gt;mpstat&lt;/code&gt; 명령어를 사용하여 CPU 사용률과 부하를 확인합니다. 기본적으로 &lt;code&gt;mpstat&lt;/code&gt;는 CPU 사용률의 평균값을 매초마다 표시합니다. 출력 빈도를 조정하려면 시간 간격을 지정할 수 있습니다. 예를 들어, &lt;code&gt;mpstat -P ALL 2&lt;/code&gt; 명령어를 사용하면 매초마다 한 번씩 실행되며, &lt;code&gt;irq&lt;/code&gt;는 리소스 점유를 나타냅니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```shell
01:32:33 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
01:32:35 PM  all    0.00    0.00    0.26    0.00    3.73    0.26    0.00    0.00    0.00   95.76
01:32:35 PM    0    0.00    0.00    0.51    0.00    3.57    0.00    0.00    0.00    0.00   95.92
01:32:35 PM    1    0.00    0.00    0.00    0.00    3.59    0.51    0.00    0.00    0.00   95.90
01:32:35 PM    2    0.00    0.00    0.00    0.00    4.15    0.00    0.00    0.00    0.00   95.85
01:32:35 PM    3    0.00    0.00    0.52    0.00    3.61    0.52    0.00    0.00    0.00   95.36
```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;분석 결과 출력
mpstat 출력에는 각 CPU의 사용률과 시스템의 평균 부하가 포함됩니다. 평균 부하와 각 CPU의 사용률에 특히 주의를 기울이면 시스템의 부하 상태를 파악하는 데 도움이 됩니다. 부하가 높으면 어떤 프로세스가 원인인지 추가 분석하고 성능 병목 현상이 있는지 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;다른 도구와 결합하세요:
&lt;code&gt;mpstat&lt;/code&gt; 외에도 &lt;code&gt;sar&lt;/code&gt;, &lt;code&gt;pidstat&lt;/code&gt;, &lt;code&gt;iostat&lt;/code&gt; 등의 도구를 사용하여 시스템 성능을 종합적으로 분석할 수 있습니다. 다양한 도구의 출력을 결합하면 시스템 부하를 보다 포괄적으로 파악하고 성능 문제의 근본 원인을 찾아낼 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;중단&#34;&gt;중단
&lt;/h3&gt;&lt;p&gt;여기서는 내용을 너무 자세히 설명하지 않겠습니다
추천: &lt;a class=&#34;link&#34; href=&#34;https://www.codedump.info/post/20200522-sgfap-softirq/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;애플리케이션 개발자를 위한 시스템 가이드 CPU편 - 소프트 인터럽트&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;잦은 소프트웨어 인터럽트 발생은 시스템 부하에도 반영된다&lt;/p&gt;
&lt;h2 id=&#34;문제-해결&#34;&gt;문제 해결
&lt;/h2&gt;&lt;p&gt;CPU 관점에서만 문제를 파악하기 어렵다는 점을 고려할 때, 시스템에 이상이 발생했을 가능성을 의심해 볼 시점일까요? Linux 운영체제의 부하가 과도하여 VMware가 지나치게 많은 CPU 자원을 사용하고 있을 수도 있습니다. &lt;code&gt;mpstat&lt;/code&gt;를 사용하여 로컬 가상 머신을 분석한 결과, &lt;code&gt;irq&lt;/code&gt; 점유율이 비정상적으로 높았고 단일 코어는 약 25%에 달했습니다. 정상적인 상황에서는 비즈니스 프로세스를 시작하지 않은 상태에서 &lt;code&gt;irq&lt;/code&gt; 점유율은 약 5% 정도여야 합니다.&lt;/p&gt;
&lt;p&gt;그룹 내 동료 개발 환경에서 그의 CentOS 7은 VMware에 배포되었으며, 리소스 사용량은 정상적으로 표시됩니다. 반면에 상하이의 개발 환경에서는 동일하게 VMware이지만 호스트 CPU 리소스 상황을 직접 관찰할 수 없습니다. 이때 우리는 VMware 가상 머신, Linux 운영 체제 및 GCC 버전을 포함한 여러 변수를 고려해야 합니다.&lt;/p&gt;
&lt;p&gt;전환하여 테스트 환경을 분석해 보니, 선전의 테스트 환경은 물리 머신에 배포되어 있고, 오래된 버전 GCC 컴파일 서비스가 실행 중이며 CentOS 8 위에서 운영되고 있습니다. 흥미롭게도, 선전 환경에서는 &lt;code&gt;irq&lt;/code&gt; 점유량이 모두 정상입니다.&lt;/p&gt;
&lt;p&gt;문제점을 파악하기 위해 GCC 최신 버전으로 컴파일된 프로그램을 선전 환경에 배포하여 테스트한 결과, 모두 정상 작동하는 것으로 나타났습니다&lt;/p&gt;
&lt;p&gt;문제는 더 명확해지는 듯하고, 우리는 운영체제에 문제가 있는 것은 아닌지 의심하기 시작했다. 결국 CentOS 8은 더 이상 공식 지원을 받지 못한다. 하지만 순수한 CentOS 7과 CentOS 8을 다시 배포해도 문제는 여전히 존재한다.&lt;/p&gt;
&lt;p&gt;지금, 우리는 유일한 불확실 요소인 VMware 가상화 소프트웨어를 의심하기 시작했습니다. 갑자기 아이디어가 떠올랐습니다. Hyper-V 기술은 어떨까요? 혹시 이전에 Hyper-V가 활성화되었지만 완전히 종료되지 않아 이런 문제가 발생했을 수도 있습니다? 결국, 소프트 인터럽트도 가상화 소프트웨어를 통해 구현되니까요. 서로 다른 가상화 기술에 버그는 없는 걸까요? 이러한 문제들은 깊이 생각하고 조사할 가치가 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;결론&#34;&gt;결론
&lt;/h2&gt;&lt;p&gt;마이크로소프트 공식 매뉴얼에 따르면, 로컬 Hyper-V 서비스를 완전히 종료한 후 VMware가 호스트에서 정상적으로 복구되는 것을 확인했습니다. 이렇게 해서 문제 해결이 마침내 순조롭게 진행되었습니다. 처음 설명했듯이 이 경험은 굴곡지고 고되었으며 종합적인 분석과 판단이 필요했습니다. 또한, 이번에 처음으로 문제를 진단하고 가상 머신 수준까지 위치를 특정하게 되었습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Disable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V-Hypervisor
bcdedit /set hypervisorlaunchtype off
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/application-management/virtualization-apps-not-work-with-hyper-v&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/application-management/virtualization-apps-not-work-with-hyper-v&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43; 프로그래밍의 함정: `std::map` 오용으로 인한 프로그램 충돌 상세 분석</title>
        <link>https://ttf248.life/ko/p/cpp-programming-traps-std-map-crash-details/</link>
        <pubDate>Sun, 10 Mar 2024 22:03:06 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/cpp-programming-traps-std-map-crash-details/</guid>
        <description>&lt;p&gt;C++ 프로그래밍에서 &lt;code&gt;std::map&lt;/code&gt; 컨테이너를 잘못 사용하면 프로그램이 충돌할 수 있습니다. 대괄호 연산자를 사용하여 존재하지 않는 키에 접근하려고 하면 자동으로 빈 요소가 추가됩니다. 이 오해를 자세히 분석하고 예제 코드를 통해 잠재적인 위험을 보여드리겠습니다.&lt;/p&gt;
&lt;p&gt;저장하는 값이 단순한 값이라면 문제가 없지만, 포인터를 저장하면 문제가 발생할 수 있습니다. 왜냐하면 포인터는 주소이고, 초기화되지 않으면 해당 주소가 불확실해져 프로그램이 충돌할 수 있기 때문입니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;C++ 표준 라이브러리에서 &lt;code&gt;std::map&lt;/code&gt;은 키(key)를 기준으로 오름차순으로 요소를 저장하는 연관 컨테이너이며, 효율적인 키워드 검색 기능을 제공합니다. 하지만 초보 개발자는 &lt;code&gt;std::map&lt;/code&gt;의 대괄호 연산자 &lt;code&gt;[]&lt;/code&gt;의 동작 방식에 대한 이해 부족으로 어려움을 겪을 수 있습니다. 실제로 &lt;code&gt;[]&lt;/code&gt;를 사용하여 존재하지 않는 키에 접근하면 &lt;code&gt;std::map&lt;/code&gt;은 새로운 키-값 쌍을 삽입하고, 기본 생성자를 사용하여 해당 키에 해당하는 값 타입이 초기화됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int main() {
    std::map&amp;lt;std::string, int&amp;gt; myMap;
    
    // 错误的用法：假设这里试图访问一个不存在的键并认为会得到0
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for &#39;nonexistent_key&#39;: &amp;quot; &amp;lt;&amp;lt; myMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;

    // 实际上，上述行代码创建了一个新的键值对，其中值被默认初始化为int的默认值（通常是0）
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 코드 조각은 프로그램 충돌을 직접적으로 유발하지는 않지만, 이러한 암묵적인 삽입 동작은 특정 상황에서 예상치 못한 부작용을 초래할 수 있습니다. 예를 들어 리소스 누수나 예측 불가능한 상태 변경이 발생할 수 있습니다. 더 나쁜 것은 다중 스레드 환경에서 초기화되지 않은 메모리 영역에 동시에 접근하면 프로그램 충돌로 이어질 수도 있습니다.&lt;/p&gt;
&lt;p&gt;이러한 문제가 발생하는 것을 방지하기 위해 &lt;code&gt;std::map::find()&lt;/code&gt; 또는 &lt;code&gt;std::map::count()&lt;/code&gt; 메서드를 사용하여 키가 존재하는지 확인하거나, &lt;code&gt;std::map::insert()&lt;/code&gt;를 사용하여 명시적으로 요소를 삽입하는 것이 좋습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::map&amp;lt;std::string, int&amp;gt; safeMap;
if (safeMap.count(&amp;quot;nonexistent_key&amp;quot;) == 0) {
    std::cout &amp;lt;&amp;lt; &amp;quot;Key does not exist.&amp;quot; &amp;lt;&amp;lt; std::endl;
} else {
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for existing key: &amp;quot; &amp;lt;&amp;lt; safeMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;
}

// 或者明确插入一个键值对，指定初始值
safeMap.insert({ &amp;quot;new_key&amp;quot;, 0 });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;만약 map 컨테이너 내부에 저장된 객체가 포인터 타입이라면, 자동 삽입 동작은 초기화되지 않은 포인터를 저장하며, 이 포인터에 대한 어떠한 작업도 프로그램 충돌을 야기할 수 있습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>pstack으로 프로세스 멈춤 확인</title>
        <link>https://ttf248.life/ko/p/pstack-troubleshooting-process-hang/</link>
        <pubDate>Sat, 24 Feb 2024 23:55:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/pstack-troubleshooting-process-hang/</guid>
        <description>&lt;p&gt;소프트웨어 개발 및 운영 환경에서 프로세스 응답 없음 현상이 자주 발생하는데, 이로 인해 시스템 성능 저하나 서비스 중단이 발생할 수 있습니다. 본 문서에서는 pstack 도구를 사용하여 프로세스 응답 없음 문제를 진단하고, 프로세스의 스택 정보를 분석하여 문제 원인을 파악하고 해결하는 방법을 소개합니다.&lt;/p&gt;
&lt;p&gt;배경: 위험 관리 시스템 하위 서비스가 응답하지 않는 상태로 멈춰 위험 관리 서비스를 사용할 수 없게 되었습니다. 서비스 가용성 모니터링이 부족하여 프로세스가 멈춘 상황을 즉시 파악하지 못했고, 이로 인해 시스템이 사용할 수 없게 되었습니다.&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;프로세스 응답 없음은 프로세스가 응답을 멈춘 상태이지만 종료되지 않은 것을 의미합니다. 이는 데드락, 리소스 고갈, 예외 등 다양한 원인으로 발생할 수 있습니다. 이러한 문제를 해결하기 위해 pstack 도구를 사용하여 프로세스의 스택 정보를 분석하고 문제의 근본 원인을 파악할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;단계&#34;&gt;단계
&lt;/h2&gt;&lt;p&gt;pstack은 일반적으로 gdb(GNU 디버거)와 함께 제공되는 유용한 도구입니다. 다음 명령을 통해 설치할 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt-get install gdb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;프로세스 ID 획득: 먼저, 응답하지 않는 프로세스의 프로세스 ID(PID)를 얻어야 합니다. ps 명령어를 사용하여 모든 프로세스를 나열하고 문제 해결이 필요한 프로세스 ID를 찾을 수 있습니다.
pstack 도구를 사용하여 프로세스 스택을 분석하고, 일단 프로세스 ID를 얻으면 pstack 도구를 사용하여 해당 프로세스의 스택 정보를 가져올 수 있습니다. 다음 명령어를 실행하세요:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pstack &amp;lt;PID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 프로세스의 스택 정보를 출력하여 현재 실행 중인 함수 호출 시퀀스를 표시합니다. 이러한 정보를 분석하면 프로세스가 멈춘 위치를 파악하고 문제를 진단할 수 있습니다.&lt;/p&gt;
&lt;p&gt;스택 정보를 분석하면 프로세스가 멈추는 원인을 파악할 수 있습니다. 데드락, 무한 루프 또는 기타 예외 상황이 발견될 수 있습니다. 구체적인 상황에 따라 잠금을 해제하거나 코드 로직을 수정하는 등의 조치를 취하십시오.&lt;/p&gt;
&lt;h2 id=&#34;사례&#34;&gt;사례
&lt;/h2&gt;&lt;p&gt;간단한 데모인데, 메인 함수가 시작된 후 서브 스레드를 새로 만들고 실제 실행 함수에 들어가면 무한 루프에 빠져 프로그램이 정상적으로 종료되지 않고 멈춰버리는 상태입니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cmake_minimum_required(VERSION 3.0.0)
project(pstack_main VERSION 0.1.0 LANGUAGES C CXX)

include(CTest)
enable_testing()

# 查找线程库
find_package(Threads REQUIRED)

add_executable(pstack_main main.cpp)

# 链接线程库
target_link_libraries(pstack_main PRIVATE Threads::Threads)

set(CPACK_PROJECT_NAME ${PROJECT_NAME})
set(CPACK_PROJECT_VERSION ${PROJECT_VERSION})
include(CPack)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;
#include &amp;lt;chrono&amp;gt;

void infiniteLoop() {
    while (true) {
        // 主线程进入死循环
    }
}

int main() {
    std::thread thread(infiniteLoop); // 创建一个线程，执行死循环函数
    thread.join(); // 等待线程结束
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;프로그램을 시작하고 pstack 결과를 실행합니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Thread 2 (Thread 0x7eff3619b700 (LWP 1315017)):
#0  infiniteLoop () at /root/pstack/main.cpp:6
#1  0x0000000000402ca9 in std::__invoke_impl&amp;lt;void, void (*)()&amp;gt; (__f=@0x2260eb8: 0x4029a6 &amp;lt;infiniteLoop()&amp;gt;) at /usr/include/c++/8/bits/invoke.h:60
#2  0x0000000000402b02 in std::__invoke&amp;lt;void (*)()&amp;gt; (__fn=@0x2260eb8: 0x4029a6 &amp;lt;infiniteLoop()&amp;gt;) at /usr/include/c++/8/bits/invoke.h:95
#3  0x0000000000403150 in std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt;::_M_invoke&amp;lt;0ul&amp;gt; (this=0x2260eb8) at /usr/include/c++/8/thread:244
#4  0x0000000000403126 in std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt;::operator() (this=0x2260eb8) at /usr/include/c++/8/thread:253
#5  0x000000000040310a in std::thread::_State_impl&amp;lt;std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt; &amp;gt;::_M_run (this=0x2260eb0) at /usr/include/c++/8/thread:196
#6  0x00007eff36bceb23 in execute_native_thread_routine () from /lib64/libstdc++.so.6
#7  0x00007eff36ea91ca in start_thread () from /lib64/libpthread.so.0
#8  0x00007eff361d58d3 in clone () from /lib64/libc.so.6
Thread 1 (Thread 0x7eff372e1740 (LWP 1315016)):
#0  0x00007eff36eaa6cd in __pthread_timedjoin_ex () from /lib64/libpthread.so.0
#1  0x00007eff36bceda7 in std::thread::join() () from /lib64/libstdc++.so.6
#2  0x00000000004029d2 in main () at /root/pstack/main.cpp:13
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;볼 수 있듯이, 프로세스가 멈춘 이유는 무한 루프 때문입니다. 메인 스레드가 무한 루프에 진입하고, 서브 스레드가 종료되지 않아 프로세스가 멈춥니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>나가 돌아다니는 것은 결국 좋은 일이다</title>
        <link>https://ttf248.life/ko/p/come-out-and-walk-around-its-always-good/</link>
        <pubDate>Thu, 08 Feb 2024 10:30:43 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/come-out-and-walk-around-its-always-good/</guid>
        <description>&lt;p&gt;만약 집안의 계획대로, 성실하게 전력망을 공부했다면 코딩을 하지 않았다면, 나는 평범한 순종적인 남자가 되었을 것이다&lt;/p&gt;
&lt;p&gt;기억 속의 먼지를 털어내고 보니, 계기는 다가오는 설과 함께 룸메이트와의 대화였고, 그 과정에서 몇 년간의 경험을 되돌아보게 되었다&lt;/p&gt;
&lt;h2 id=&#34;제-1장&#34;&gt;제 1장
&lt;/h2&gt;&lt;p&gt;고등학교 졸업 시험 성적이 좋다고 할 수도 없고 나쁘다고 할 수도 없었지만, 211 대학을 졸업했다. 아버지가 처음 계획하셨던 대로 전력망을 열심히 공부해서 고향 시의 전력공사에 취직하는 것이었다. 앞서 언급했듯이 어떻게 IT 업계에 발을 들여놓게 되었는지 설명하다가 미처 말하지 못했던 부분인데, 돈에 대한 가치관과 자기 통제력이 있었다.&lt;/p&gt;
&lt;p&gt;처음은 아직 마을 학교에 다녔는데, 중학교 2학년 때부터 부모님이 시내 학교로 전학시키셨다. 마치 유姥姥가 대관원에 온 것 같았고, 도시의 번화함에 적응하기 어려웠다. 영화관에 몇 번 가본 적이 없었고, 정확히 말하면 부모님과 함께 간 적은 거의 없었지만, 친척들이 데려간 적은 있었다. 하늘은 항상 행운을 남겨두는데, 그때 비슷한 취향의 친구들을 만났다. 뒤에는 연락이 줄어들었지만, 그 시절의 젊음은 지금 봐도 아름답다. 주말 보충 수업 후에 함께 교실 안의 플라스틱 병을 정리하고, 능숙하게 밟아 납작하게 만든 후 책가방에 넣어 엄마에게 가져갔다. 모아두면 폐품 수거꾼에게 맡길 수 있었다. 함께 장기를 두고, 배드민턴을 치고, 섯불놀이를 했는데, 진 사람은 푸쉬업 몇 개를 해야 했다. 그때는 약간 다행이라고 생각했고, 아버지는 어릴 때부터 나를 다양한 운동을 시켰다. 이때부터 돈에 대한 관점이 조금 이상해지고, 약간 자기 비하가 심해졌지만, 이런 작은 불운은 금방 지나갔다. 집안이 어려운 편도 아니었고, 용돈도 많지 않았고, 주변 친구들과 함께 놀기 어려웠다. 특히 주말에는 부모님의 노력이 눈에 띄게 보였다. 우리는 마을에서 나와 시내로 이사했다. 이때 씨앗이 심어졌고, 조용히 발아를 기다리고 있었다.&lt;/p&gt;
&lt;p&gt;머리가 단순한 제가, 학업 기간 동안 전반적으로는 매우 행복했습니다. 많은 사람들이 졸업 후에야 비로소 깨닫는 것처럼, 공부는 생각보다 어려운 일이 아니며, 투자와 산출이 비교적 쉽게 전환되는 편입니다.&lt;/p&gt;
&lt;p&gt;중첩된 어린 시절 제국 시대의 기억을 가지고, 대학교 시절에 노트북과 접촉하면서 판도라의 상자가 열린 듯 게임과 접하게 되었고, 게임 상인이라는 역할과도 연결되었다. 처음에는 하위층 판매원이었는데, 상류에서 물건을 구매하여 자신의 커뮤니티 채널을 통해 조금씩 물건을 판매하며 돈을 벌었다. 그러다가 점차 전체 링크의 작동 논리를 이해하게 되었다. 우리가 판매하는 물건은 결국 상류 프로그램이 대량으로 부화시킨 것이고, 그들의 비용은 거의 제로에 가까웠다. 이때부터 길이 조금 꼬이기 시작했다. 전공 안에는 세분화된 전공들이 있는데, 왼쪽에 전기망, 오른쪽에 자동화(매우 복잡함, 칩 프로그래밍, 공장 전기 자동화)가 있었다. 나는 프로그램으로 돈을 벌 수 있다는 것을 알게 되었고, 채널 상류는 확실히 많은 돈을 벌었고, 이전부터 프로그래밍의 기본기가 있었기 때문에 이것저것 뒤적거리며 조금의 돈을 벌었다. 전공 선택 시 자연스럽게 자동화를 선택했다. 3학년 전공 수업은 많이 듣지 않았는데, 매일 머릿속에는 코드를 짜서 돈을 버는 것만 생각했다.&lt;/p&gt;
&lt;p&gt;지난해 글에서 언급했듯이, 해커에 대한 긍정적인 환상과 함께 접하게 된 프로그래밍은 비전공 IT가 인애를 발휘하여 어셈블리, 침투 테스트, 게임 핵, DLL 가드 및 계정 탈취 등을 통해 다양한 불법/회색 영역을 익히고 이해하게 했습니다. 부모님은 어떻게 사람이 살아야 하는지 가르쳐 주셨고, 법률도 저에게 조언해 주었기에 길은 완전히 잘못된 방향으로 가지 않았습니다.&lt;/p&gt;
&lt;p&gt;이전 글 링크: [그때 그 시절]({&amp;lt; relref &amp;ldquo;/post/2023/01-09-那时少年&amp;rdquo; &amp;gt;}})&lt;/p&gt;
&lt;p&gt;대학교 때 한 번 연애도 해봤는데, 뒤돌아보면 드라마 속 사랑에 대한 동경이 더 컸던 것 같아요. 당시 미성숙했던 저에게는 어떻게 사랑하는지 알기도 어려웠고, 더욱이 가정을 꾸리고 성공하기까지 하는 일은 불가능했습니다.&lt;/p&gt;
&lt;h2 id=&#34;제2장&#34;&gt;제2장
&lt;/h2&gt;&lt;p&gt;시대의 물결 속에서, 저는 또한 운이 좋았습니다. 대학교 시절의 여러 번의 노력 덕분에 연구원 시험을 보는 일은 없었고, 졸업과 함께 바로 일을 시작했습니다. IT 업계의 유리한 흐름을 타고 일이 순조롭게 풀렸습니다. 벌써 일한 지 8년째인데, 이제는 열기가 사라지고 막이 내리기 시작했습니다. 가끔은 처음 선택했던 것이 잘못된 것은 아닐까 생각하고, 아버지 말씀을 듣고 전력 회사에 들어갔더라면 더 나았을지도 모른다는 생각이 들기도 합니다. 일하기 시작한 지 5년 앞에서는 그런 생각을 할 수도 있었지만, 시간이 지나면서 그 생각은 점점 사라졌습니다. 신입으로 홍성에 입사하여 5년을 한 회사에서 근무하며 기술과 산업에 대한 이해, 그리고 자신의 능력에 대한 인식이 어느 정도 부족했습니다. 본사의 지시에 따라 심천 분사무소로 갔고, 직장 내 갈등을 겪었습니다 (나중에 보니 양쪽 모두 패배했고 최종 승자는 이사회였습니다). 기술에 대한 열정을 품고 다시 杭州로 돌아왔지만, 약간의 젊음과 미숙함으로 인해 杭州에서 철수하여 상하이로 왔습니다.&lt;/p&gt;
&lt;p&gt;원래 항저우로 안착하여 살고, 집을 사는 계획이었는데, 이자율이 최고조에 달하고 부동산 가격이 정점에 달할 때 진입하면 바로 묶여 버릴 것 같고, 가진 돈이 얼마 없어 감당하기 어렵다. 주택 담보 대출의 압박을 지고 결혼까지 해야 한다는 생각에, 산업 침체까지 더해지면 감정적으로 불안정해지기 쉽다.&lt;/p&gt;
&lt;h2 id=&#34;제3장&#34;&gt;제3장
&lt;/h2&gt;&lt;p&gt;이렇게 오랫동안 세상에 나왔고, 많은 것을 겪어보았으며, 어리석은 짓도 하고 방황하기도 했지만, 현재는 괜찮다. 여러 가지 일과 사람들을 거치면서 결국 성장했고, 만약 집에만 있었다면 성격의 결함이 어떤 형태로든 터져 나왔을 것이다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43; 함수 호출 시간</title>
        <link>https://ttf248.life/ko/p/cpp-function-call-timing/</link>
        <pubDate>Wed, 24 Jan 2024 14:11:33 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/cpp-function-call-timing/</guid>
        <description>&lt;p&gt;다양한 콜백 함수 구현 방식에 맞춰 디자인 시나리오 SDK를 테스트하는 데 많은 시간이 소요되었습니다. 최근 C++ 함수 프로그래밍을 살펴보고 있는데, 함수가 일급 시민이 되어 프로그램 내부에서 자유롭게 흐르는 경우 성능 차이가 있나요?&lt;/p&gt;
&lt;p&gt;이전 링크: [컴파일러, 콜백 함수, 성능 테스트]({&amp;lt; relref &amp;ldquo;/post/2023/02-15-컴파일러、콜백 함수、성능 테스트&amp;rdquo; &amp;gt;}})&lt;/p&gt;
&lt;p&gt;레이마오 대장도 비슷한 테스트를 해서 코드를 빌려 썼다&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;실행 플랫폼은 여전히 우리의 오랜 친구, &lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt; 입니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;cassert&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

int add_one(int input) { return input + 1; }

bool validate_vector_add_one(std::vector&amp;lt;int&amp;gt; const&amp;amp; input_vector,
                             std::vector&amp;lt;int&amp;gt; const&amp;amp; output_vector)
{
    bool is_valid{true};
    for (size_t i{0}; i &amp;lt; input_vector.size(); ++i)
    {
        if (output_vector.at(i) != input_vector.at(i) + 1)
        {
            is_valid = false;
            break;
        }
    }
    return is_valid;
}

void reset_vector(std::vector&amp;lt;int&amp;gt;&amp;amp; input_vector)
{
    for (size_t i{0}; i &amp;lt; input_vector.size(); ++i)
    {
        input_vector.at(i) = 0;
    }
}

template &amp;lt;typename T, typename Func&amp;gt;
void unitary_function_pass_by_lambda_function(T&amp;amp; output, T const&amp;amp; input,
                                              Func const func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_std_function_value(T&amp;amp; output, T const&amp;amp; input,
                                                 std::function&amp;lt;T(T)&amp;gt; const func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_std_function_reference(
    T&amp;amp; output, T const&amp;amp; input, std::function&amp;lt;T(T)&amp;gt; const&amp;amp; func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_function_pointer(T&amp;amp; output, T const&amp;amp; input,
                                               T (*func)(T))
{
    output = func(input);
}

int main()
{
    // Set floating point format std::cout with 3 decimal places.
    std::cout.precision(3);

    size_t const num_elements{10000000};
    std::vector&amp;lt;int&amp;gt; input_vector(num_elements, 0);
    std::vector&amp;lt;int&amp;gt; output_vector(num_elements, 0);

    auto const lambda_function_add_one{[](int const&amp;amp; input) -&amp;gt; int
                                       { return input + 1; }};
    std::function&amp;lt;int(int)&amp;gt; const std_function_add_one{lambda_function_add_one};

    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a function pointer: &amp;quot; &amp;lt;&amp;lt; sizeof(&amp;amp;add_one)
              &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a std::function pointer: &amp;quot;
              &amp;lt;&amp;lt; sizeof(&amp;amp;std_function_add_one) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a std::function: &amp;quot; &amp;lt;&amp;lt; sizeof(std_function_add_one)
              &amp;lt;&amp;lt; std::endl;

    // Call function frequently in a vanilla way.
    // The compiler knows what function to call at compile time and can optimize
    // the code.
    // This is the best performance we could get.
    std::chrono::steady_clock::time_point const time_start_vanilla{
        std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        output_vector.at(i) = add_one(input_vector.at(i));
    }
    std::chrono::steady_clock::time_point const time_end_vanilla{
        std::chrono::steady_clock::now()};
    auto const time_elapsed_vanilla{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(time_end_vanilla -
                                                             time_start_vanilla)
            .count()};
    float const latency_vanilla{time_elapsed_vanilla /
                                static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass Vanilla: &amp;quot; &amp;lt;&amp;lt; latency_vanilla &amp;lt;&amp;lt; &amp;quot; ns&amp;quot;
              &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // Sometimes, we don&#39;t know what function to call at compile time.
    // We can use std::function to pass a function as an argument.
    // In this case, we pass the std::function by value.
    // Because the size of a std::function is 32 bytes, passing by value
    // results in a lot of copying and bad performance.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_std_function_value{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_std_function_value(
            output_vector.at(i), input_vector.at(i), std_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_std_function_value{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_std_function_value{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_std_function_value -
            time_start_pass_by_std_function_value)
            .count()};
    float const latency_pass_by_std_function_value{
        time_elapsed_pass_by_std_function_value /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Std Function Value: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_std_function_value &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // Instead of passing the std::function by value, we can pass it by
    // reference (pointer). In this case, object copying is eliminated. The
    // performance is better than passing the std::function by value. However,
    // the performance is still not as good as the vanilla way.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_std_function_reference{
            std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_std_function_reference(
            output_vector.at(i), input_vector.at(i), std_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_std_function_reference{
            std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_std_function_reference{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_std_function_reference -
            time_start_pass_by_std_function_reference)
            .count()};
    float const latency_pass_by_std_function_reference{
        time_elapsed_pass_by_std_function_reference /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Std Function Reference: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_std_function_reference &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // std::function is a general purpose wrapper for function pointers,
    // callable objects, and lambda functions. Because it&#39;s general purpose,
    // it&#39;s not as efficient as a function pointer. In this case, we pass a
    // function pointer to a function. The performance is better than passing
    // the std::function by reference.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_function_pointer{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_function_pointer(output_vector.at(i),
                                                  input_vector.at(i), &amp;amp;add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_function_pointer{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_function_pointer{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_function_pointer -
            time_start_pass_by_function_pointer)
            .count()};
    float const latency_pass_by_function_pointer{
        time_elapsed_pass_by_function_pointer /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Function Pointer: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_function_pointer &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // We can also pass a lambda function to a function.
    // The compiler knows what function to call at compile time and can optimize
    // the code. The performance is also better than passing the std::function
    // by reference.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_lambda_function{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_lambda_function(
            output_vector.at(i), input_vector.at(i), lambda_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_lambda_function{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_lambda_function{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_lambda_function -
            time_start_pass_by_lambda_function)
            .count()};
    float const latency_pass_by_lambda_function{
        time_elapsed_pass_by_lambda_function /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Lambda Function: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_lambda_function &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 组里常规也就开启 O2 优化，编译选用了 gcc13，不同版本的 gcc 性能耗时略有不同，版本越高 lambda 效果越好
The size of a function pointer: 8
The size of a std::function pointer: 8
The size of a std::function: 32
Latency Pass Vanilla: 0.418 ns
Latency Pass By Std Function Value: 3.47 ns
Latency Pass By Std Function Reference: 1.36 ns
Latency Pass By Function Pointer: 0.396 ns
Latency Pass By Lambda Function: 0.44 ns
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leimao.github.io/blog/CPP-Function-Call-Performance/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://leimao.github.io/blog/CPP-Function-Call-Performance/&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>컴퓨터가 왜 일반적으로 빅엔디안이 아닌 리틀 엔디안을 채택했는가</title>
        <link>https://ttf248.life/ko/p/little-endian-storage-why/</link>
        <pubDate>Wed, 24 Jan 2024 10:43:05 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/little-endian-storage-why/</guid>
        <description>&lt;p&gt;바이트 순서에 대한 설명 [호스트 바이트 순서, 네트워크 바이트 순서, 디버거를 통해 직접 관찰]&lt;/p&gt;
&lt;p&gt;컴퓨터 분야의 역사적 이유로 형성된 특정 설계 습관은, 엉덩이 너비가 로켓 추진기 폭을 결정하는 논리와 똑같아서, 안에서 “장점”이나 “단점”을 굳이 분석할 필요 없이 순전히 역사적인 습관일 뿐입니다&lt;/p&gt;
&lt;h2 id=&#34;원본-링크&#34;&gt;원본 링크
&lt;/h2&gt;&lt;p&gt;작가: 북극
링크: &lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/question/637413724/answer/3346032134&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.zhihu.com/question/637413724/answer/3346032134&lt;/a&gt;
출처: 지식인
저작권은 저자에게 있습니다. 상업적 재판행 시에는 저자와 협의하여 허가를 받으시고, 비상업적 재판행 시에는 출처를 명시하십시오.&lt;/p&gt;
&lt;h2 id=&#34;본문-재게시&#34;&gt;본문 재게시
&lt;/h2&gt;&lt;p&gt;현재의 빅엔디언과 릴리틀 엔디언 상황은 역사적 관습과 상업화의 결과이며, 기술 자체와는 크게 관련이 없습니다. ARM은 빅엔디언으로 설정할 수도 있고 리틀 엔디언으로 설정할 수도 있습니다. TCP/IP 헤더는 아직도 빅엔디언(네트워크 바이트 오더)입니다. 저장 분야에서도 많은 저장 프로토콜/규격들이 빅엔디언 방식으로 데이터를 저장합니다.&lt;/p&gt;
&lt;p&gt;그래서 질문자의 세 가지 질문은, 오늘날에 와서 보면:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;컴퓨터가 왜 널리 리틀 엔디안 저장 방식을 채택하는가? &amp;ndash;&amp;gt; 틀렸습니다&lt;/li&gt;
&lt;li&gt;효율이 더 높지 않습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;현재 기술로 이 세 가지 문제를 논증하는 것은 화살을 쏘고 나서 표적을 그리는 것과 같습니다&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;하지만 빅 엔디언 또는 리틀 엔디언의 선택은 컴퓨터 역사에서 실제로 일정한 객관적인 요인이 있었습니다: 호스트 바이트 오더(리틀 엔디언)의 장점: 리틀 엔디언의 덧셈기는 비교적 쉽게 만들 수 있습니다. 8비트 * 4의 덧셈기를 만든다면, 8비트 덧셈기 하나만 있으면 되고, 낮은 비트부터 높은 비트로 순차적으로 모든 바이트를 더하면 됩니다. 이때 발생하는 자리 올림 회로는 매우 간단하지만, 빅 엔디언이라면 한 번에 32비를 로드해야 하며, 그렇지 않으면 계산을 수행할 수 없습니다. 지금 보면 한 번에 8비트 또는 32비를 로드하는 것의 차이는 크지 않지만, 몇십 년 전에는 메모리 가격이 비쌌기 때문에 가능한 한 간단한 것이 좋았고, 따라서 호스트 바이트 오더는 비용을 고려하여 리틀 엔디언으로 선택되었습니다. 네트워크 바이트 오더(빅 엔디언)의 장점: 초기 장치의 캐시가 작았기 때문에 높은 바이트를 먼저 받으면 패킷 정보를 빠르게 판단할 수 있었습니다: 버퍼 크기(얼마나 큰 버퍼를 준비해야 하는지), 주소 범위(IP 주소는 앞부터 뒤로 매칭됩니다). 초기 네트워크 장치의 캐시는 바이트 단위였고, 높은 바이트를 먼저 가져오는 것이 실제로 더 빨랐습니다. 따라서 네트워크 장치는 비용을 고려하여 빅 엔디언을 사용했습니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;그래서, 바이트 오더의 선택은 역사적으로는 애플리케이션 시나리오와 비용을 더 고려하는 경향이 있었고(예: PPC/MIPS는 네트워크 장비에 더 적합), 이후 기술 발전 과정에서 호환성 때문에 빅 엔디언과 리틀 엔디언 설정이 지금까지 유지되고 있습니다&lt;/p&gt;
&lt;p&gt;오늘날에는 이러한 장점은 완전히 사라졌고, 단지 과거의 습관일 뿐입니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>프로그램이 디버깅을 어떻게 회피하는가</title>
        <link>https://ttf248.life/ko/p/program-how-to-anti-debug/</link>
        <pubDate>Tue, 23 Jan 2024 19:46:36 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/program-how-to-anti-debug/</guid>
        <description>&lt;p&gt;뜻밖에도 벽지 새로 해보자는 생각이 들어서, 평소 검은색 계열을 선호하는지라 부분적으로 색상을 넣고 싶어요. 바탕화면에는 아이콘을 배치해야 해서 다른 색상으로 배경을 설정하면 아이콘이 잘 보이지 않네요.&lt;/p&gt;
&lt;p&gt;위 어셈블리 코드에 대해 잠시 생각해 보았는데, 무슨 뜻인지 모르겠어. AI에게 시도해 봤더니 명령어를 설명은 했지만 상황은 설명하지 않았고, 분명히 특정 상황에서 사용되는 명령어일 것이다. 일반적인 코드는 이런 방식이 아니다.&lt;/p&gt;
&lt;p&gt;AI는 현재 검색 엔진보다 낫지 않다, 어셈블리의 지식 저장량은 부족하다&lt;/p&gt;
&lt;h2 id=&#34;벽지&#34;&gt;벽지
&lt;/h2&gt;&lt;p&gt;검은색 조립 벽지&lt;/p&gt;
&lt;h2 id=&#34;어셈블리-코드&#34;&gt;어셈블리 코드
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;PUSHFD
MOV DWORD PTR [ESP],0X100
POPFD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;실제 사용 시나리오&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool IsDebugged()
{
    __try
    {
        __asm
        {
            pushfd
            mov dword ptr [esp], 0x100
            popfd
            nop
        }
        return true;
    }
    __except(GetExceptionCode() == EXCEPTION_SINGLE_STEP
        ? EXCEPTION_EXECUTE_HANDLER
        : EXCEPTION_CONTINUE_EXECUTION)
    {
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;설명&#34;&gt;설명
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;TrapFlag&lt;/code&gt;은 플래그 레지스터 내의 플래그 비트이며, 이 플래그 비트가 설정되면 예외 &lt;code&gt;SINGLE_STEP&lt;/code&gt;이 발생합니다. 왜냐하면 우리가 코드를 추적할 때 디버거가 이 플래그 비트를 초기화하기 때문에 이 예외를 볼 수 없기 때문입니다.&lt;/p&gt;
&lt;p&gt;실제 테스트 시 발견한 내용인데, 검사 디버깅 함수를 직접 건너뛰면 디버깅이 감지되지 않고, 검사 함수 실행에 들어가야만 감지된다 (자료 조사 중이며 아직 실제 확인은 되지 않음)&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;p&gt;관련 자료는 모두 웹사이트의 영어 원문을 번역한 것이며, 해당 사이트는 다양한 디버깅 방지 기술을 설명하고 있습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://anti-debug.checkpoint.com/techniques/assembly.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://anti-debug.checkpoint.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://song-10.gitee.io/2021/08/08/Reverse-2021-08-08-anti-debug/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://song-10.gitee.io/2021/08/08/Reverse-2021-08-08-anti-debug/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>초점 인터뷰/CCTV 비디오 파일을 어떻게 다운로드하나요?</title>
        <link>https://ttf248.life/ko/p/how-to-download-focus-interview-cctv-video-files/</link>
        <pubDate>Tue, 23 Jan 2024 19:23:35 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/how-to-download-focus-interview-cctv-video-files/</guid>
        <description>&lt;p&gt;최근에 사람들이 &amp;ldquo;집중 인터뷰&amp;rdquo; 비디오를 어떻게 다운로드하는지 물어보는데, 머리로는 거의 대부분이 &lt;code&gt;m3u8&lt;/code&gt; 방식으로 암호화되어 있을 거라고 생각하고 있었고, 간단히 처리했다&lt;/p&gt;
&lt;h2 id=&#34;다운로더&#34;&gt;다운로더
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/nilaoda/N_m3u8DL-CLI&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/nilaoda/N_m3u8DL-CLI&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;m3u8 다운로더 오픈소스 명령줄 m3u8/HLS/dash 다운로더입니다. 일반적인 AES-128-CBC 복호화, 멀티 스레드, 사용자 지정 헤더 등을 지원합니다. 중국어 간체, 중국어 번체 및 영어를 지원합니다. 영어 지원.&lt;/p&gt;
&lt;h2 id=&#34;브라우저-플러그인&#34;&gt;브라우저 플러그인
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://microsoftedge.microsoft.com/addons/detail/ngjclnbcdbahekojpkhancmiobdahemb&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Live Stream Downloader&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;꿀-같은-자신감&#34;&gt;꿀 같은 자신감
&lt;/h2&gt;&lt;p&gt;주소를 받았다고 생각했는데, оказалось ничего не получилось. 분할 내용을 정상적으로 파싱할 수 없었고, 자료를 검색해 보니 공식에서 다운로드 주소를 처리해서, 플러그인이 파싱한 &lt;code&gt;key&lt;/code&gt;를 아래 링크에 수동으로 복사하여 교체해야 한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;https://newcntv.qcloudcdn.com/asp/hls/2000/0303000a/3/default/***********************/2000.m3u8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2024년 1월까지 주소 테스트가 유효합니다. 이후 변경 사항이 있으면 웹페이지를 직접 분석하십시오.&lt;/p&gt;
&lt;p&gt;이전 주소 백업: &lt;code&gt;https://hlswx.cntv.kcdnvip.com/asp/hls/main/0303000a/3/default/일련의 문자/main.m3u8?maxbr=2000&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://jln.cn/post/517.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://jln.cn/post/517.html&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>SQL Server 데이터베이스 디스크 파일 권한 일괄 수정</title>
        <link>https://ttf248.life/ko/p/bulk-modify-sqlserver-database-disk-file-permissions/</link>
        <pubDate>Tue, 23 Jan 2024 19:06:36 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/bulk-modify-sqlserver-database-disk-file-permissions/</guid>
        <description>&lt;p&gt;회사 보안 정책 변경으로, &lt;code&gt;메카닉 미니&lt;/code&gt;는 결국 백업 서버로 집으로 이사했고, 시스템을 재설치했습니다. &lt;code&gt;우분투&lt;/code&gt;에서 &lt;code&gt;윈도우 서버&lt;/code&gt;로 전환했는데, 활성화 방법이 정규적이지 않아서, 집에서는 활성화하지 않아도 괜찮은 것 같습니다.&lt;/p&gt;
&lt;p&gt;비정상적인 방식으로 활성화하여 마이크로소프트의 검사를 트리거했습니다(반달 동안 정상적으로 실행됨). 서버는 1시간 동안 켜져 있다가 자동으로 종료되었고, 시스템 로그를 뒤지니 불법 복제본으로 인한 문제였습니다.&lt;/p&gt;
&lt;p&gt;방법이 없네요, 시스템을 다시 설치해야 하고, &lt;code&gt;SqlServer&lt;/code&gt;도 재설치를 해야 합니다. 할 때마다 골치 아픈데, 파일 권한 관리가 엄격해서 데이터베이스를 정상적으로 추가할 수 없습니다.&lt;/p&gt;
&lt;h2 id=&#34;오류-정보&#34;&gt;오류 정보
&lt;/h2&gt;&lt;p&gt;시스템을 재설치한 후, &lt;code&gt;SqlServer&lt;/code&gt;가 데이터베이스를 첨부하는 과정에서 5120 오류 및 운영체제의 액세스 거부 문제가 발생할 수 있습니다&lt;/p&gt;
&lt;h2 id=&#34;스크립트-처리&#34;&gt;스크립트 처리
&lt;/h2&gt;&lt;p&gt;이전 링크: &lt;a class=&#34;link&#34; href=&#34;https://ttf248.life/ko/p/bulk-update-local-git-repository-and-legacy-permission-issues/&#34; &gt;로컬 Git 저장소 일괄 업데이트&lt;/a&gt;, 물론 또 이 익숙한 스크립트입니다. 폴더를 순회하면서 파일의 권한을 수정하도록 변경했는데, 현재는 완전 편집 권한을 가지고 있습니다.&lt;/p&gt;
&lt;p&gt;온라인 튜토리얼은 대부분 수동으로 수정하도록 시키는데, 그들은 겨우 몇 개의 파일만 수정하는 건가? 나는 매번 일괄적으로 파일을 처리해야 하고, 전부 수동으로 하려니 사람이 지쳐 쓰러질 것 같아&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$currentUserName = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8
$rootDirectory = &amp;quot;D:\data\2013_RujiaInfo&amp;quot;

Get-ChildItem -Path $rootDirectory -Recurse | ForEach-Object {
    $itemPath = $_.FullName

    if ($_ -is [System.IO.DirectoryInfo]) {
        $icaclsResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            Write-Host &amp;quot;已更改文件夹 $itemPath 的所有者为 $currentUserName&amp;quot;
            # 授予当前用户写入权限
            Invoke-Expression &amp;quot;icacls `&amp;quot;$itemPath`&amp;quot; /grant `&amp;quot;$($currentUserName):(OI)(CI)F`&amp;quot;&amp;quot;
            Write-Host &amp;quot;已授予 $currentUserName 编辑文件夹的权限&amp;quot;
        } else {
            Write-Host &amp;quot;无法更改文件夹 $itemPath 的所有者。错误信息: $icaclsResult&amp;quot;
        }
    } else {
        $takeownResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            # 授予当前用户写入权限
            Invoke-Expression &amp;quot;icacls `&amp;quot;$itemPath`&amp;quot; /grant `&amp;quot;$($currentUserName):(F)`&amp;quot;&amp;quot;
            Write-Host &amp;quot;已授予 $currentUserName 编辑文件的权限&amp;quot;
        } else {
            Write-Host &amp;quot;无法更改文件 $itemPath 的所有者。错误信息: $takeownResult&amp;quot;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>리눅스 시스템 벤치마크 테스트</title>
        <link>https://ttf248.life/ko/p/linux-system-benchmark-test/</link>
        <pubDate>Tue, 09 Jan 2024 10:56:23 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/linux-system-benchmark-test/</guid>
        <description>&lt;p&gt;윈도우 플랫폼에는 루마스터(유희 마스터)라는 프로그램이 있는데, 데이터가 아주 정확하다고는 할 수 없지만 대략적인 참고 자료로 쓸 수는 있습니다. 물론 다른 전문 벤치마크 소프트웨어도 있고, 리눅스 시스템에서는 특별히 적합한 벤치마크 프로그램을 아직 못 찾았습니다.&lt;/p&gt;
&lt;p&gt;Sysbench는 CPU, 메모리, 파일 I/O, 스레드 성능 등을 테스트할 수 있는 다목적 벤치마크 도구입니다. 다양한 성능 테스트 작업을 수행하기 위해 Sysbench를 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;손에 있는 테스트용 장비가 세 대 있는데, 메커니컬 미니 로컬 호스트, 알리바바 클라우드 개발 클라우드 서버, 화웨이 클라우드 개발 서버가 있습니다&lt;/p&gt;
&lt;h2 id=&#34;sysbench-설치&#34;&gt;Sysbench 설치
&lt;/h2&gt;&lt;p&gt;대부분의 Linux 배포판에서 패키지 관리 도구를 사용하여 Sysbench를 설치할 수 있습니다. 예를 들어 CentOS 8에서는 다음 명령어를 사용하여 설치할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo dnf install sysbench
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sysbench-사용-예시&#34;&gt;Sysbench 사용 예시
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CPU 성능 테스트: &lt;code&gt;sysbench --test=cpu run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;메모리 읽기 성능 테스트: &lt;code&gt;sysbench --test=memory run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;테스트 파일 I/O 성능:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysbench --test=fileio --file-test-mode=rndrw prepare
sysbench --test=fileio --file-test-mode=rndrw run
sysbench --test=fileio --file-test-mode=rndrw cleanup
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;멀티 스레드 성능 테스트: &lt;code&gt;sysbench --test=threads --num-threads=4 실행&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;MySQL 데이터베이스 성능 테스트(데이터베이스 최대 연결 수 조정 필요):&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword --oltp-table-size=1000000 prepare
sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword --max-time=60 --oltp-read-only=off --oltp-test-mode=complex --max-requests=0 run
sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword cleanup
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;분포-데이터-보고서&#34;&gt;분포 데이터 보고서
&lt;/h2&gt;&lt;meta http-equiv=&#34;Content-Type&#34; content=&#34;text/html; charset=utf-8&#34;&gt;&lt;link type=&#34;text/css&#34; rel=&#34;stylesheet&#34; href=&#34;resources/sheet.css&#34; &gt;
&lt;style type=&#34;text/css&#34;&gt;.ritz .waffle a { color: inherit; }.ritz .waffle .s0{background-color:#ffffff;text-align:left;color:#000000;font-family:&#39;Arial&#39;;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}&lt;/style&gt;&lt;div class=&#34;ritz grid-container&#34; dir=&#34;ltr&#34;&gt;&lt;table class=&#34;waffle&#34; cellspacing=&#34;0&#34; cellpadding=&#34;0&#34;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th class=&#34;row-header freezebar-origin-ltr&#34;&gt;&lt;/th&gt;&lt;th id=&#34;0C0&#34; style=&#34;width:100px;&#34; class=&#34;column-headers-background&#34;&gt;A&lt;/th&gt;&lt;th id=&#34;0C1&#34; style=&#34;width:421px;&#34; class=&#34;column-headers-background&#34;&gt;B&lt;/th&gt;&lt;th id=&#34;0C2&#34; style=&#34;width:398px;&#34; class=&#34;column-headers-background&#34;&gt;C&lt;/th&gt;&lt;th id=&#34;0C3&#34; style=&#34;width:422px;&#34; class=&#34;column-headers-background&#34;&gt;D&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R0&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;1&lt;/div&gt;&lt;/th&gt;&lt;td&gt;&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;本地机械师&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;阿里云&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;华为云&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R1&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;2&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;系统配置&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;System Information&lt;br&gt;  Operating System              Ubuntu 23.04&lt;br&gt;  Kernel                        Linux 6.2.0-36-generic x86_64&lt;br&gt;  Model                         Machenike Machenike DT Computer&lt;br&gt;  Motherboard                   Machenike Machenike DT Computer&lt;br&gt;  BIOS                          American Megatrends International, LLC.&lt;br&gt;DB19V012&lt;br&gt;&lt;br&gt;CPU Information&lt;br&gt;  Name                          Intel Core i7-12650H&lt;br&gt;  Topology                      1 Processor, 10 Cores, 16 Threads&lt;br&gt;  Identifier                    GenuineIntel Family 6 Model 154 Stepping 3&lt;br&gt;  Base Frequency                4.60 GHz&lt;br&gt;  L1 Instruction Cache          32.0 KB x 8&lt;br&gt;  L1 Data Cache                 48.0 KB x 8&lt;br&gt;  L2 Cache                      1.25 MB x 2&lt;br&gt;  L3 Cache                      24.0 MB&lt;br&gt;&lt;br&gt;Memory Information&lt;br&gt;  Size                          62.6 GB&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;System Information&lt;br&gt;  Operating System              CentOS Stream 8&lt;br&gt;  Kernel                        Linux 4.18.0-513.el8.x86_64 x86_64&lt;br&gt;  Model                         Alibaba Cloud Alibaba Cloud ECS&lt;br&gt;  Motherboard                   N/A&lt;br&gt;  BIOS                          SeaBIOS 449e491&lt;br&gt;&lt;br&gt;CPU Information&lt;br&gt;  Name                          Intel(R) Xeon(R) Platinum&lt;br&gt;  Topology                      1 Processor, 1 Core, 2 Threads&lt;br&gt;  Identifier                    GenuineIntel Family 6 Model 85 Stepping 4&lt;br&gt;  Base Frequency                2.50 GHz&lt;br&gt;  L1 Instruction Cache          32.0 KB&lt;br&gt;  L1 Data Cache                 32.0 KB&lt;br&gt;  L2 Cache                      1.00 MB&lt;br&gt;  L3 Cache                      33.0 MB&lt;br&gt;&lt;br&gt;Memory Information&lt;br&gt;  Size                          1.65 GB&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;System Information&lt;br&gt;  Operating System              Ubuntu 22.04.1 LTS&lt;br&gt;  Kernel                        Linux 5.15.0-60-generic x86_64&lt;br&gt;  Model                         OpenStack Foundation OpenStack Nova&lt;br&gt;  Motherboard                   N/A&lt;br&gt;  BIOS                          SeaBIOS&lt;br&gt;rel-1.10.2-0-g5f4c7b1-20181220_000000-szxrtosci10000&lt;br&gt;&lt;br&gt;CPU Information&lt;br&gt;  Name                          Intel(R) Xeon(R) Gold 6278C CPU @ 2.60GHz&lt;br&gt;  Topology                      1 Processor, 1 Core, 2 Threads&lt;br&gt;  Identifier                    GenuineIntel Family 6 Model 85 Stepping 7&lt;br&gt;  Base Frequency                2.60 GHz&lt;br&gt;  L1 Instruction Cache          32.0 KB&lt;br&gt;  L1 Data Cache                 32.0 KB&lt;br&gt;  L2 Cache                      1.00 MB&lt;br&gt;  L3 Cache                      35.8 MB&lt;br&gt;&lt;br&gt;Memory Information&lt;br&gt;  Size                          3.64 GB&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R2&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;3&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;CPU&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Prime numbers limit: 10000&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;CPU speed:&lt;br&gt;    events per second:  4032.48&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0004s&lt;br&gt;    total number of events:              40330&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.25&lt;br&gt;         avg:                                    0.25&lt;br&gt;         max:                                    0.73&lt;br&gt;         95th percentile:                        0.25&lt;br&gt;         sum:                                 9997.55&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           40330.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9975/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Prime numbers limit: 10000&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;CPU speed:&lt;br&gt;    events per second:  1062.51&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0008s&lt;br&gt;    total number of events:              10628&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.91&lt;br&gt;         avg:                                    0.94&lt;br&gt;         max:                                   22.84&lt;br&gt;         95th percentile:                        1.06&lt;br&gt;         sum:                                 9993.46&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           10628.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9935/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Prime numbers limit: 10000&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;CPU speed:&lt;br&gt;    events per second:  1125.56&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0005s&lt;br&gt;    total number of events:              11258&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.86&lt;br&gt;         avg:                                    0.89&lt;br&gt;         max:                                    1.70&lt;br&gt;         95th percentile:                        0.99&lt;br&gt;         sum:                                 9995.40&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           11258.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9954/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R3&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;4&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;内存&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Running memory speed test with the following options:&lt;br&gt;  block size: 1KiB&lt;br&gt;  total size: 102400MiB&lt;br&gt;  operation: write&lt;br&gt;  scope: global&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;Total operations: 101993199 (10198146.52 per second)&lt;br&gt;&lt;br&gt;99602.73 MiB transferred (9959.13 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0001s&lt;br&gt;    total number of events:              101993199&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.00&lt;br&gt;         max:                                    0.03&lt;br&gt;         95th percentile:                        0.00&lt;br&gt;         sum:                                 4059.50&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           101993199.0000/0.00&lt;br&gt;    execution time (avg/stddev):   4.0595/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Running memory speed test with the following options:&lt;br&gt;  block size: 1KiB&lt;br&gt;  total size: 102400MiB&lt;br&gt;  operation: write&lt;br&gt;  scope: global&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;Total operations: 48418803 (4841004.79 per second)&lt;br&gt;&lt;br&gt;47283.99 MiB transferred (4727.54 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0001s&lt;br&gt;    total number of events:              48418803&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.00&lt;br&gt;         max:                                   25.26&lt;br&gt;         95th percentile:                        0.00&lt;br&gt;         sum:                                 4578.95&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           48418803.0000/0.00&lt;br&gt;    execution time (avg/stddev):   4.5789/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Running memory speed test with the following options:&lt;br&gt;  block size: 1KiB&lt;br&gt;  total size: 102400MiB&lt;br&gt;  operation: write&lt;br&gt;  scope: global&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;Total operations: 57056904 (5704765.11 per second)&lt;br&gt;&lt;br&gt;55719.63 MiB transferred (5571.06 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0001s&lt;br&gt;    total number of events:              57056904&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.00&lt;br&gt;         max:                                    0.06&lt;br&gt;         95th percentile:                        0.00&lt;br&gt;         sum:                                 4556.06&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           57056904.0000/0.00&lt;br&gt;    execution time (avg/stddev):   4.5561/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R4&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;5&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;硬盘&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;2147483648 bytes written in 1.81 seconds (1129.59 MiB/sec).&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Extra file open flags: (none)&lt;br&gt;128 files, 16MiB each&lt;br&gt;2GiB total file size&lt;br&gt;Block size 16KiB&lt;br&gt;Number of IO requests: 0&lt;br&gt;Read/Write ratio for combined random IO test: 1.50&lt;br&gt;Periodic FSYNC enabled, calling fsync() each 100 requests.&lt;br&gt;Calling fsync() at the end of test, Enabled.&lt;br&gt;Using synchronous I/O mode&lt;br&gt;Doing random r/w test&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;File operations:&lt;br&gt;    reads/s:                      3373.41&lt;br&gt;    writes/s:                     2248.94&lt;br&gt;    fsyncs/s:                     7201.80&lt;br&gt;&lt;br&gt;Throughput:&lt;br&gt;    read, MiB/s:                  52.71&lt;br&gt;    written, MiB/s:               35.14&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0127s&lt;br&gt;    total number of events:              128288&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.08&lt;br&gt;         max:                                    5.14&lt;br&gt;         95th percentile:                        0.34&lt;br&gt;         sum:                                 9977.78&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           128288.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9778/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;2147483648 bytes written in 19.29 seconds (106.16 MiB/sec).&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Extra file open flags: (none)&lt;br&gt;128 files, 16MiB each&lt;br&gt;2GiB total file size&lt;br&gt;Block size 16KiB&lt;br&gt;Number of IO requests: 0&lt;br&gt;Read/Write ratio for combined random IO test: 1.50&lt;br&gt;Periodic FSYNC enabled, calling fsync() each 100 requests.&lt;br&gt;Calling fsync() at the end of test, Enabled.&lt;br&gt;Using synchronous I/O mode&lt;br&gt;Doing random r/w test&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;File operations:&lt;br&gt;    reads/s:                      1593.12&lt;br&gt;    writes/s:                     1062.08&lt;br&gt;    fsyncs/s:                     3406.64&lt;br&gt;&lt;br&gt;Throughput:&lt;br&gt;    read, MiB/s:                  24.89&lt;br&gt;    written, MiB/s:               16.60&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0164s&lt;br&gt;    total number of events:              60600&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.16&lt;br&gt;         max:                                   31.32&lt;br&gt;         95th percentile:                        0.54&lt;br&gt;         sum:                                 9956.30&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           60600.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9563/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;2147483648 bytes written in 18.29 seconds (111.98 MiB/sec).&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Extra file open flags: (none)&lt;br&gt;128 files, 16MiB each&lt;br&gt;2GiB total file size&lt;br&gt;Block size 16KiB&lt;br&gt;Number of IO requests: 0&lt;br&gt;Read/Write ratio for combined random IO test: 1.50&lt;br&gt;Periodic FSYNC enabled, calling fsync() each 100 requests.&lt;br&gt;Calling fsync() at the end of test, Enabled.&lt;br&gt;Using synchronous I/O mode&lt;br&gt;Doing random r/w test&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;File operations:&lt;br&gt;    reads/s:                      1665.88&lt;br&gt;    writes/s:                     1110.59&lt;br&gt;    fsyncs/s:                     3563.77&lt;br&gt;&lt;br&gt;Throughput:&lt;br&gt;    read, MiB/s:                  26.03&lt;br&gt;    written, MiB/s:               17.35&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0112s&lt;br&gt;    total number of events:              63355&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.16&lt;br&gt;         max:                                  205.01&lt;br&gt;         95th percentile:                        0.78&lt;br&gt;         sum:                                 9972.64&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           63355.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9726/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R5&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;6&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;多线程&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 4&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0002s&lt;br&gt;    total number of events:              197956&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.16&lt;br&gt;         avg:                                    0.20&lt;br&gt;         max:                                    0.34&lt;br&gt;         95th percentile:                        0.21&lt;br&gt;         sum:                                39970.47&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           49489.0000/5.70&lt;br&gt;    execution time (avg/stddev):   9.9926/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 4&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0174s&lt;br&gt;    total number of events:              18360&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.57&lt;br&gt;         avg:                                    2.18&lt;br&gt;         max:                                   32.77&lt;br&gt;         95th percentile:                        2.61&lt;br&gt;         sum:                                40050.41&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           4590.0000/94.36&lt;br&gt;    execution time (avg/stddev):   10.0126/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 4&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0004s&lt;br&gt;    total number of events:              28536&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.23&lt;br&gt;         avg:                                    1.40&lt;br&gt;         max:                                    3.56&lt;br&gt;         95th percentile:                        1.47&lt;br&gt;         sum:                                39975.16&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           7134.0000/39.87&lt;br&gt;    execution time (avg/stddev):   9.9938/0.01&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;p&gt;ChatGPT는 여전히 좋은 도구입니다. 위에 있는 표는 이전에 익숙했던 Markdown으로는 완전히 구성할 수 없으며, 표로 만들지 않으면 표시 효과가 매우 좋지 않습니다. 사용자 지정 테마는 페이지 최대 너비를 제한하며, 페이지 설정도 변경하여 너비를 백분율 제한으로 조정했습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;간단한 방법은 TablesGenerator와 같은 온라인 도구를 사용하여 HTML 테이블을 생성하는 것입니다(내용이 복잡하면 적합하지 않음)&lt;/li&gt;
&lt;li&gt;또는 구글 온라인 문서로 작성한 후 HTML 문서로 다운로드하여 저장하고, 블로그에 바로 복사하는 방법(간단하고 직접적이며, 최종적으로 이 방법을 사용했습니다)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;config 설정에서 unsafe 옵션이 활성화되어 있는지 확인하고, 페이지별로 너비를 개별적으로 지정하세요&lt;/p&gt;
&lt;p&gt;Hugo에서 페이지별로 너비를 설정할 수 있습니다. 이는 페이지의 프론트 매터에 사용자 지정 파라미터를 추가하여 구현할 수 있습니다. 다음은 예시입니다.&lt;/p&gt;
&lt;p&gt;마크다운 페이지의 프론트 매터 부분(일반적으로 파일의 시작 부분)에 사용자 지정 파라미터, 예를 들어 &lt;code&gt;custom_width&lt;/code&gt;를 추가하세요&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;---
title: &amp;quot;我的页面&amp;quot;
date: 2024-01-09
custom_width: &amp;quot;800px&amp;quot;  # 设置宽度为 800 像素
---

正文内容...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;귀하의 Hugo 테마에서 해당 단일 페이지 템플릿 파일(예: &lt;code&gt;layouts/_default/single.html&lt;/code&gt;)을 찾거나 생성하십시오&lt;/p&gt;
&lt;p&gt;단일 페이지 템플릿에서, 페이지의 프론트 매터에 &lt;code&gt;custom_width&lt;/code&gt; 파라미터가 있는지 확인하고, 해당 HTML 요소(예: &lt;code&gt;div&lt;/code&gt;)에 적용합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{{ define &amp;quot;main&amp;quot; }}
  &amp;lt;div style=&amp;quot;max-width: {{ with .Params.custom_width }}{{ . }}{{ else }}100%{{ end }}; margin: 0 auto;&amp;quot;&amp;gt;
    {{ .Content }}
  &amp;lt;/div&amp;gt;
{{ end }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 예제에서는 &lt;code&gt;style&lt;/code&gt; 속성을 사용하여 &lt;code&gt;div&lt;/code&gt; 요소에 &lt;code&gt;max-width&lt;/code&gt; 속성을 설정하여 &lt;code&gt;custom_width&lt;/code&gt; 매개변수를 지정하지 않을 때 너비를 기본적으로 100%로 만듭니다. &lt;code&gt;margin: 0 auto;&lt;/code&gt;는 &lt;code&gt;div&lt;/code&gt; 요소를 가운데 정렬하는 데 사용됩니다.&lt;/p&gt;
&lt;p&gt;실제 적용 시에는 위 예시를 주제 구조와 CSS 스타일의 세부 사항에 따라 조정해야 할 수 있습니다. 스타일을 조정할 때는 주제의 일관성과 가독성을 유지하는 것이 중요합니다.&lt;/p&gt;
&lt;p&gt;활성화된 테마가 약간 달라서 사이트 사용자 정의 &lt;code&gt;CSS&lt;/code&gt; 설정을 최종적으로 조정했습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>Git 비활성화 http 저장소</title>
        <link>https://ttf248.life/ko/p/git-disable-http-repositories/</link>
        <pubDate>Mon, 08 Jan 2024 21:22:04 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/git-disable-http-repositories/</guid>
        <description>&lt;p&gt;소프트웨어 버전을 업데이트하는 것이 습관인데, 어느 버전의 &lt;code&gt;Git&lt;/code&gt;부터인지 모르겠지만 &lt;code&gt;Http&lt;/code&gt; 저장소에서 코드를 가져오지 못하게 금지되어 있습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;fatal: Unencrypted HTTP is not supported for GitLab. Ensure the repository remote URL is using HTTPS
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;배경-소개&#34;&gt;배경 소개
&lt;/h2&gt;&lt;p&gt;환경: Windows 플랫폼, 항상 작은 거북이로 git을 사용하고 있었고, 키 설정도 작은 거북이로 처리했습니다. 전에 스크립트를 통해 한 번 로컬 저장소를 일괄적으로 업데이트한 적이 있습니다.&lt;/p&gt;
&lt;p&gt;이전 링크: [로컬 Git 저장소 일괄 업데이트]({&amp;lt; relref &amp;ldquo;/post/2023/10-19-批量更新本地git仓库&amp;rdquo; &amp;gt;}})&lt;/p&gt;
&lt;p&gt;오늘 집에 와서 코드 업데이트를 하려는데, 위에 언급된 오류가 발생해서 저장소를 정상적으로 업데이트할 수 없게 됐습니다. &lt;code&gt;Git&lt;/code&gt;에서 &lt;code&gt;http&lt;/code&gt; 프로토콜을 사용하여 계속 업데이트하도록 설정하는 옵션이 있을 줄 알았는데, 찾아봐도 해당 설정 항목은 찾을 수가 없었습니다.&lt;/p&gt;
&lt;p&gt;가장 간단한 해결책은 당연히 &lt;code&gt;ssh&lt;/code&gt; 프로토콜로 전환하여 저장소를 업데이트하는 것입니다. 회사 설정상 &lt;code&gt;gitlab&lt;/code&gt;은 단기적으로 &lt;code&gt;https&lt;/code&gt; 프로토콜을 제공하지 않을 예정입니다.&lt;/p&gt;
&lt;h2 id=&#34;미해결-문제&#34;&gt;미해결 문제
&lt;/h2&gt;&lt;p&gt;앞서 작성했던 로컬 저장소 일괄 업데이트 스크립트를 만들 때, 원래는 &lt;code&gt;ssh&lt;/code&gt; 방식으로 저장소를 가져올 생각이었는데, 왜 그런지 자세히 확인하지 않았습니다. TortoiseGit 설정 정보가 config 파일에 동기화되지 않아 명령줄에서 실행&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git pull #提示没有权限，无法正常更新仓库
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;명령을 통해 키 설정도 확인하는 것은 올바르다: &lt;code&gt;ssh -T git@gitlab.yintech.net&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;TortoiseGit을 사용하여 코드를 정상적으로 가져올 수 있지만 명령줄에서 git pull 명령어를 사용할 때 키가 올바르지 않다고 표시되면 TortoiseGit이 PuTTY의 SSH 키를 사용하는 반면 명령줄은 OpenSSH의 SSH 키를 사용하기 때문일 수 있습니다&lt;/p&gt;
&lt;p&gt;작은 거북이의 키 설정은 시스템 .ssh 폴더에서 키 파일 정보를 읽어오는 대신, 인터페이스 저장소 구성 시 별도로 키 파일 경로를 설정합니다. 유용한 팁: 첫 번째로 구성된 저장소에 키를 설정하면 나머지 저장소는 이 키 파일을 재사용할 수 있습니다. PuTTY가 키를 로드한 후에는 즉시 종료되지 않고 프록시 서비스를 시작합니다.&lt;/p&gt;
&lt;p&gt;전역 구성을 조정하여 시스템 기본 &lt;code&gt;ssh&lt;/code&gt; 설정을 사용하지 않도록 하면 Git Bash가 TortoisePlink를 사용하여 SSH 작업을 수행합니다. 이러한 설정은 TortoiseGit에 포함된 PuTTY 도구를 사용하는 경우에 적합합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global core.sshCommand &amp;quot;&#39;C:/Program Files/TortoiseGit/bin/TortoisePlink.exe&#39; -batch -ssh&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위에 설정된 실행 파일 경로를 해당 작은 거북이 경로로 직접 수정하면 시스템 환경 변수에 경로를 추가할 필요가 없습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>AI 프로그래밍 및 작업 분할</title>
        <link>https://ttf248.life/ko/p/ai-programming-and-task-decomposition/</link>
        <pubDate>Fri, 22 Dec 2023 08:44:26 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/ai-programming-and-task-decomposition/</guid>
        <description>&lt;p&gt;2년 전 사이트에 코드 영역 복사 기능을 추가했는데, 여러 날을 끙끙거린 끝에 최종 렌더링 효과가 만족스럽지 않았습니다. 반쪽짜리 프론트엔드 개발자였기 때문에 개선하려 하지는 않고 그냥 사용했습니다. 올해 &lt;code&gt;AI&lt;/code&gt;로 미니 프로그램을 개발하면서 프론트엔드 개발에도 더 익숙해졌고, 그래서 다시 한번 (AI 재설계) 리팩토링을 했습니다.&lt;/p&gt;
&lt;p&gt;깨달음: 과제를 분해하니 작은 작업들이 많아져서, AI 개발에 적합하네요. 이미 폐쇄된 앱인데 75%의 코드를 AI가 제공했고, 여러 개의 작업으로 분할하여 배포했으며, 사람이 프로젝트 코드 조립을 담당했습니다.&lt;/p&gt;
&lt;h2 id=&#34;전문&#34;&gt;전문
&lt;/h2&gt;&lt;p&gt;간단하다고 생각했던 일이지만, 코드 복사 버튼을 추가하면 됩니다&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;CSS와 JavaScript 코드를 설계하여 class=&amp;ldquo;highlight&amp;quot;인 웹 요소의 컨테이너 내에 복사 버튼을 추가하고, 코드 복사 기능을 구현합니다&lt;/p&gt;
&lt;p&gt;제공된 첫 번째 초안 코드에는 문제가 있는 듯 보입니다. 다시 생성한 초안은 기본적으로 사용 가능하지만, 복사된 내용이 정확하지 않고 불필요한 텍스트가 포함되어 있습니다. 핵심 색상 디자인과 어떤 효과를 포함할지 수동으로 지정하여 추가 최적화를 유도했습니다.&lt;/p&gt;
&lt;p&gt;버튼의 크기와 색상에 대한 특정 요구 사항이 있다는 것을 파악했습니다. 귀하의 요구 사항에 맞게 버튼 스타일을 다시 디자인할 수 있습니다. 다음은 제공하신 색상 구성표를 포함하고 버튼 크기를 최적화한 조정된 CSS 스타일입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.copy-btn {
  position: absolute;
  top: 2px; /* 调整位置 */
  right: 2px;
  padding: 3px 6px; /* 缩小尺寸 */
  font-size: 12px; /* 减小字体大小 */
  background-color: #8FD1E1; /* 按钮背景色 */
  color: #272822; /* 文字颜色 */
  border: 1px solid #272822; /* 边框颜色 */
  border-radius: 3px; /* 圆角 */
  cursor: pointer;
  opacity: 0.7; /* 默认半透明 */
  transition: opacity 0.3s ease, background-color 0.3s ease; /* 平滑过渡效果 */
}

.copy-btn:hover {
  opacity: 1; /* 鼠标悬停时不透明 */
  background-color: #A3D4E5; /* 鼠标悬停时的背景色 */
}

.highlight {
  position: relative;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 스타일에서 저는 버튼 크기와 글꼴 크기를 줄여 더욱 세련되게 만들었습니다. 동시에 버튼의 기본 상태는 반투명하며, 마우스가 버튼 위에 올라갈 때 불투명해지고 배경색이 약간 밝아져 시각적인 피드백을 제공합니다. 이러한 디자인은 귀하의 색상 요구 사항을 충족하면서도 현대적이고 사용자 친화적인 특징을 유지합니다.&lt;/p&gt;
&lt;p&gt;해당하는 더 간단한 &lt;code&gt;JavaScript&lt;/code&gt;를 제공합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;document.addEventListener(&#39;DOMContentLoaded&#39;, function() {
  // 查找所有 .highlight 元素
  const highlights = document.querySelectorAll(&#39;.highlight&#39;);

  highlights.forEach(function(highlight) {
    // 创建复制按钮
    const copyBtn = document.createElement(&#39;button&#39;);
    copyBtn.textContent = &#39;复制&#39;;
    copyBtn.classList.add(&#39;copy-btn&#39;);

    // 将按钮添加到每个 .highlight 元素中
    highlight.appendChild(copyBtn);

    // 添加点击事件监听器
    copyBtn.addEventListener(&#39;click&#39;, function() {
      // 假设 .highlight 下的第一个 &amp;lt;code&amp;gt; 元素包含要复制的代码
      const code = highlight.querySelector(&#39;code&#39;) ? highlight.querySelector(&#39;code&#39;).textContent : &#39;&#39;;

      navigator.clipboard.writeText(code).then(() =&amp;gt; {
        // 显示复制成功信息
        copyBtn.textContent = &#39;已复制!&#39;;
        setTimeout(() =&amp;gt; {
          copyBtn.textContent = &#39;复制&#39;;
        }, 2000);
      }).catch(err =&amp;gt; {
        console.error(&#39;复制失败: &#39;, err);
      });
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;p&gt;비록 코드 영역의 오른쪽 상단에 복사 버튼을 추가하는 것을 더 기대했지만, 프론트엔드에 대한 이해 부족으로 기능이 정확하게 설명되지 않았고, AI와 몇 번이고 반복했음에도 예상한 결과를 얻지 못했습니다&lt;/p&gt;
&lt;p&gt;시간이 지나면서 AI가 프로그램 개발에 얼마나 큰 영향을 미칠지 모르겠다&lt;/p&gt;</description>
        </item>
        <item>
        <title>동방전선 소문 논란: 문화와 상업의 충돌</title>
        <link>https://ttf248.life/ko/p/dongfang-zhenxuan-essay-controversy-culture-vs-commerce/</link>
        <pubDate>Wed, 20 Dec 2023 18:57:25 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/dongfang-zhenxuan-essay-controversy-culture-vs-commerce/</guid>
        <description>&lt;p&gt;동방전선 소문 사건은 동방전선 공식 계정이 방송인 덩위후이가 모든 소문의 저자임을 부인하면서 발생한 온라인 논란이다. 과연 진실이 어떠한지 이미 확인할 수 없고, 회사 권모술수의 다툼으로 이 일이 풍파의 중심에 서게 되었다.&lt;/p&gt;
&lt;p&gt;어류의 7초 기억력에 대한 내용은 앞으로 AI가 작성하게 되었고, &lt;code&gt;Bing AI&lt;/code&gt;와 &lt;code&gt;ChatGPT plus&lt;/code&gt;를 시도해 보았습니다. 전자는 자료가 더 완전하고 검색 엔진을 통해 얻은 정보량이 더 많았지만, 블로그 게시물 내용이 충분하지 않고 형식은 다소 경직되었습니다. 후자는 키워드를 통해 내용을 가져오는데, 생성된 내용은 완벽하지는 않지만 전체적인 블로그 게시물 내용을 얻을 수 있으며, 참고 자료 웹사이트를 제공하면 생성된 초안을 개선할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;동방전선 소문 사건은 저작권과 창작 귀속을 둘러싼 논쟁으로, 2023년 12월 5일부터 시작되어 방송인 동우휘와 동방전선의 일련의 상호작용이 포함되었습니다. 이 파장은 비즈니스 운영의 복잡성을 드러낼 뿐만 아니라 현대 비즈니스 문화와 네트워크 사회에 대한 깊은 반성을 불러일으켰습니다.&lt;/p&gt;
&lt;h4 id=&#34;2023년-12월-5일-사건-시작점&#34;&gt;2023년 12월 5일: 사건 시작점
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;동방전선이 예고 영상을 발표했는데, 앵커 둥위후이가 낭송한 ‘소문장’이 빠르게 인기를 얻었다&lt;/li&gt;
&lt;li&gt;동방전선은 영상 댓글에서 이들 짧은 글들은 대부분 카피라이팅 팀이 창작했으며, 전부 동우휘의 작품이 아니라고 밝혔다&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2023년-12월-13일-동우후이의-응답&#34;&gt;2023년 12월 13일: 동우후이의 응답
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;동우휘가 장문의 글을 통해 “飯圈(판관)”이라는 이름으로 누구를 낙인찍는 것을 반대하며 사건에 대한 자신의 입장을 밝혔다&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2023년-12월-14일-경영진의-답변&#34;&gt;2023년 12월 14일: 경영진의 답변
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;동방전선 CEO 션둥쉬가 사과 영상을 발표하고 회사 경영상의 허점을 인정했다&lt;/li&gt;
&lt;li&gt;동방전선 회장 유민홍 또한 이번 사태에 대해 입장을 밝혔다며, 동우휘에게 사과했다&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2023년-12월-16일-중대한-결정&#34;&gt;2023년 12월 16일: 중대한 결정
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;동방전선이 공식적으로 손동욱의 CEO 직책을 해임하고 유민홍이 겸직한다&lt;/li&gt;
&lt;li&gt;같은 날, 유민홍은 사과서를 발표하며 블랙리스트에서 제외된 네티즌들을 해제할 것이라고 밝혔다&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2023년-12월-18일-동우후이의-새로운-역할&#34;&gt;2023년 12월 18일: 동우후이의 새로운 역할
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;신동방교육기술그룹은 동우휘를 신동방교육기술그룹 문화조력장으로 임명하고, 신동방문화여행그룹 부사장직을 겸임한다&lt;/li&gt;
&lt;li&gt;유민홍은 둥우후이와 함께 스튜디오를 설립하여 새로운 라이브 방송 계정과 라이브 방송 공간을 개척할 것이라고 밝혔습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;결론과-반성&#34;&gt;결론과 반성
&lt;/h2&gt;&lt;p&gt;이 논란은 저작권 및 창작 귀속에 대한 분쟁일 뿐만 아니라, 문화와 상업의 충돌을 더 깊이 있게 반영합니다. 디지털화되고 파편화된 시대적 배경 속에서 콘텐츠 창작의 저작권 귀속은 심각하게 고민해야 할 주제가 되었습니다. 동방전선 소문 사건은 단순한 언론 논란일 뿐만 아니라, 현대 상업 문화와 네트워크 사회에 대한 깊이 있는 반성이기도 합니다.&lt;/p&gt;
&lt;p&gt;관찰자로서 우리는 문화와 상업의 충돌을 어떻게 바라봐야 할까요? 동시에 상업적 이익을 추구하면서 창작자의 노고를 어떻게 보호하고 존중해야 할까요? 이러한 문제들은 우리 모두가 깊이 고민해 볼 가치가 있습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>게임 심리학: 경쟁 게임</title>
        <link>https://ttf248.life/ko/p/game-psychology-esports/</link>
        <pubDate>Mon, 11 Dec 2023 10:26:22 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/game-psychology-esports/</guid>
        <description>&lt;p&gt;여기 氪金 게임에 대한 논의는 하지 않습니다. 게임 커뮤니티에서는 이런 유형을 보통 &amp;lsquo;돈 버는 용사&amp;rsquo;라고 부릅니다. 게임 설정에 대한 이해는 필요 없고, 오직 두둑한 지갑이 있으면 됩니다. 그들은 주변 하수인들의 아첨과 &lt;code&gt;도시 파괴&lt;/code&gt;의 쾌감을 즐깁니다.&lt;/p&gt;
&lt;p&gt;넓은 팬층을 확보한 e스포츠 게임, 예를 들어 리그 오브 레전드, 도타, 아레나 오브 발러, 배틀그라운드와 같은 게임들은 세계관 설정이 완성되고, 게임 대회는 건강한 순환 상태에 접어들었습니다&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;게임 디자인에서 심리학은 확실히 중요한 분야이며, 특히 사회심리학이 더욱 중요합니다. 사람들의 행동, 욕구 및 동기를 이해하면 더 매력적인 게임 경험을 설계하는 데 도움이 됩니다. &amp;ldquo;뽐내기&amp;quot;와 사회심리학 사이의 관계에 대해 다음과 같은 몇 가지 관점에서 살펴볼 수 있습니다.&lt;/p&gt;
&lt;p&gt;사회적 인정 욕구: 사람들은 종종 사회 집단 내에서 소속감을 느끼려고 합니다. 게임에서 플레이어가 특정 분야에서 뛰어나다고 느끼게 하고 다른 플레이어의 관심을 끌 수 있도록 설계하면 그들의 사회적 인정 욕구를 높일 수 있습니다. 이는 자신의 기술을 과시하거나 획득한 보상을 보여주는 등의 방식으로 나타날 수 있습니다.&lt;/p&gt;
&lt;p&gt;소셜 경쟁: 일부 게임은 소셜 경쟁 요소를 도입하여 플레이어가 소셜 네트워크에서 자신의 성과를 뽐낼 수 있도록 장려합니다. 이는 리더보드, 업적 시스템 또는 멀티플레이어 대결 등의 방식으로 구현할 수 있습니다. 이러한 디자인은 플레이어 간의 경쟁심을 자극하고 일부 플레이어가 사회적 인정을 받기 위해 더욱 뛰어난 모습을 보이도록 만들 수 있습니다.&lt;/p&gt;
&lt;p&gt;자신을 표현하기 : 일부 게임은 플레이어가 캐릭터 커스터마이징이나 가상 아이템 등을 통해 자신을 드러낼 수 있도록 허용합니다. 이러한 자기표현은 단순히 자랑하는 것뿐만 아니라 개성을 표현하고 소통하는 방식이 될 수도 있습니다.&lt;/p&gt;
&lt;p&gt;팀워크: 일부 게임은 소셜 상호작용을 통해 게임 목표를 달성하는 팀워크를 강조하며, 이러한 상황에서는 허세 부리는 행동보다는 팀 협력과 서로 지지하는 것이 더 중요하게 여겨질 수 있습니다&lt;/p&gt;
&lt;p&gt;심리 보상 시스템: 게임 디자인은 심리 보상 시스템을 채택하여 플레이어의 긍정적인 사회적 행동을 유도할 수 있습니다. 예를 들어, 플레이어가 적극적으로 소셜 상호 작용에 참여하도록 장려하기 위해 보상이나 특권을 부여할 수 있습니다.&lt;/p&gt;
&lt;p&gt;전반적으로, 게임 디자인에서 사회심리학은 플레이어 간의 상호작용과 소셜 경험을 형성하는 데 사용될 수 있습니다. 허세적인 행동이 특정 상황에서는 발생할 수도 있지만, 게임 디자이너는 일반적으로 이러한 행동을 균형 있게 유지하여 모든 플레이어가 긍정적이고 재미있는 경험을 할 수 있도록 노력합니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;생각나는 대로 쓰고, 완벽한 개요가 있는 것도 아니고, 조금은 엉망진창이다&lt;/p&gt;
&lt;p&gt;작가들이 주로 즐기는 리그 오브 레전드는 우리 세대의 청춘 기억이라고 할 수 있습니다. 대부분의 부모님들은 자녀가 게임을 하는 것을 좋아하지 않는데, 이는 그들이 이 유형의 게임에 대한 깊이 있는 이해와 경험이 없기 때문이며, 당연히 게임 설정과도 관련이 있습니다. 매 게임마다 새로운 시작이고, 많은 아이들에게는 플레이할 때 너무 많은 생각을 하지 않고 스스로 탐색하는 방식으로 즐깁니다. 이러한 방식에서 게임의 승패는 자녀 자체의 게임 재능에 더 많이 좌우됩니다. 필자의 실제 경험을 바탕으로 볼 때 상당수의 플레이어들이 이 유형에 속하며, 그들에겐 그렇습니다.&lt;/p&gt;
&lt;p&gt;가장 큰 비용은 돈이 아니라 시간입니다&lt;/p&gt;
&lt;p&gt;게임 안에도 엔터테인먼트 모드가 있어서, 즐길 거리를 찾는 플레이어들의 요구를 충족시키기 위함이다&lt;/p&gt;
&lt;p&gt;리그 오브 레전드와 같은 경쟁 게임은 필자에게 더 많은 부분에서 &lt;code&gt;삼국지 꿈&lt;/code&gt;을 실현하는 것이었습니다. 처음 시작할 때는 손 안에 아무것도 없지만, 자신의 이해를 바탕으로 몬스터를 잡아 경험치를 쌓고, 경제력을 사용하며, 시야를 확보하고, 상대방을 함정에 빠뜨리는 등, 두뇌를 사용하는 게임입니다. 뛰어난 게임 센스가 없어도 즐겁게 할 수 있습니다. 전체적인 상황을 통제하는 &lt;code&gt;장악감&lt;/code&gt;, 역전의 기쁨이 있습니다. 그리고 많은 댓글에서 볼 수 있는 &amp;lsquo;구름 유저&amp;rsquo;들도 게임은 더 이상 하지 않지만, 월드컵 기간에는 항상 경기를 시청합니다.&lt;/p&gt;
&lt;p&gt;여기서 말하지 않을 수 없는데, 바로 &lt;code&gt;게임 시간&lt;/code&gt;이다. 이것은 한 판 게임의 시간을 가리키는 것이 아니라, 접속하는 시간을 의미한다. 주말 오후나 매일 근무일 저녁 7시부터 밤 10시 사이에는 팀원들과 대부분 상황에서 원활하게 소통할 수 있다. 네가 보내는 신호를 팀원들이 이해하고 응답할 수 있다. 다른 시간대로 바꾸면, 예를 들어 새벽까지 게임을 한다면, 더 많이 마주하는 것은 &lt;code&gt;게임 중독자&lt;/code&gt;들이다. 승리했을 때는 아무 일도 일어나지 않고, 패배하면 온 가족을 욕설로 깸질러서 화면 너머에서도 그들의 &lt;code&gt;성의 없는 기운&lt;/code&gt;을 느낄 수 있다.&lt;/p&gt;
&lt;p&gt;본래 IT 업계에 종사하고 있어서 게임 이런 것들을 많이 접해왔고, 이것저것 해봤습니다. 다양한 장르를 경험했고, 경쟁 게임에서는 항상 머리를 써서 하는 것에 익숙한 편이고, 반사 신경이나 재능보다는 그런 쪽입니다. 프로들과 비교하거나 젊은 친구들에 비하면 반응 속도는 조금 느린 편이지만, 습관적으로 팀을 이끌고 지휘하는 것을 선호합니다. 처음 시작했을 때는 공부할 때였는데, YY 길드 형님들이 시켜서 했던 기억이 있습니다.&lt;/p&gt;
&lt;p&gt;지금 게임 환경은 어때 보면 다들 좀 성급하고, 예전처럼 순수함이 없어졌어&lt;/p&gt;
&lt;p&gt;학년을 올라서고 나서는, 고수들과의 대국을 치르면 정말 피곤하다. 내내 높은 집중력을 유지해야 하고, 상대방의 전략을 파악하고 어떻게 하면 상대방의 함정을 벗어날 수 있을지 계속 생각해야 한다. 마치 끝내고 나면 더 이상 하고 싶지 않은 그런 느낌이다.&lt;/p&gt;
&lt;p&gt;정말로 당신이 잘 하는 것은 인정하지만, 프로 경기처럼 경쟁하지 않는다면 인생의 궤적에 있어서 아무런 의미가 없어요. 사회생활을 위한 수단으로는 괜찮지만, 생계를 유지하거나 사회에 발을 붙이기에는 부족합니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;싱글 플레이 게임과 온라인 게임은 게임 방식, 경험 및 기술 측면에서 뚜렷한 차이를 보이는 두 가지 다른 유형의 게임입니다. 싱글 플레이 게임과 온라인 게임 간의 차이점을 이해하기 위한 몇 가지 주요 측면은 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;연결 방법:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;오프라인/싱글 플레이 게임: 이 게임은 로컬 장치에서 혼자서 즐기는 방식으로, 인터넷 연결이 필요하지 않습니다. 플레이어는 네트워크 연결 없이도 게임을 즐길 수 있습니다.&lt;/li&gt;
&lt;li&gt;온라인 게임(Online/Multiplayer): 이 종류의 게임은 플레이어들이 실시간으로 상호 작용하기 위해 인터넷 연결이 일반적으로 필요합니다. 온라인 게임은 여러 명의 협력 또는 경쟁을 포함하며, 온라인 소셜 및 경쟁 요소가 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;플레이어 상호작용:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;싱글 게임: 플레이어는 주로 게임 내 인공지능, 미리 설정된 미션 또는 적대적인 요소와 상호 작용합니다. 게임 경험은 일반적으로 개인화되어 있으며, 게임 내 디자인과 스토리라인의 영향을 받습니다.&lt;/li&gt;
&lt;li&gt;온라인 게임: 플레이어는 전 세계 어디에서나 다른 실제 플레이어들과 교류할 수 있습니다. 이는 협력하여 퀘스트를 완료하거나, 대결 또는 경쟁 경기, 그리고 채팅, 길드 시스템과 같은 소셜 요소 등을 포함할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;게임 디자인 및 콘텐츠:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;싱글 게임: 게임 디자인은 완전하고 독립적인 스토리와 게임 경험을 제공하는 데 더 중점을 둡니다. 게임 내용은 일반적으로 미리 설계되어 있으며, 플레이어는 게임 내에서 탐험, 퍼즐 해결 또는 전투를 합니다.&lt;/li&gt;
&lt;li&gt;온라인 게임: 게임 디자인은 실시간 상호 작용과 플레이어 간의 경쟁 또는 협력을 고려해야 합니다. 게임 콘텐츠는 정기적인 업데이트, 온라인 이벤트 및 소셜 인터랙션과 같이 더 역동적일 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;기술 요구 사항:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;오프라인 상태에서도 실행할 수 있으며, 장치 성능 및 인터넷 연결에 대한 요구 사항이 상대적으로 낮습니다&lt;/li&gt;
&lt;li&gt;온라인 게임은 비교적 강력한 인터넷 연결이 필요하며, 원활한 실시간 상호작용을 위해 서버와 네트워크 성능에 대한 높은 요구 사항이 있습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;비즈니스 모델:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;단일 게임: 일반적으로 일회성 구매 또는 다운로드 방식으로 제공되며, 플레이어는 게임을 구매하면 로컬 장치에서 게임 전체를 완벽하게 즐길 수 있습니다&lt;/li&gt;
&lt;li&gt;온라인 게임은 서버 운영과 지속적인 게임 콘텐츠 업데이트를 위해 다양한 수익 모델, 예를 들어 무료 플레이, 광고, 아이템 구매 또는 구독 등을 채택할 수 있습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이러한 차이를 이해하면 플레이어가 게임을 선택할 때 자신의 선호도를 명확히 하고, 게임 개발자가 플레이어의 기대를 더 잘 충족하는 데 도움이 됩니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>클라우드 서버와 스크립트 키즈</title>
        <link>https://ttf248.life/ko/p/cloud-servers-and-script-kids/</link>
        <pubDate>Mon, 20 Nov 2023 15:08:53 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/cloud-servers-and-script-kids/</guid>
        <description>&lt;p&gt;더블 11 행사를 빌려 알리바이가 새 서버를 구매했습니다. 경제적인 버전으로, 연간 99위안이고, 사양은 높지 않지만 집에서 제공하는 서비스의 방화벽 역할을 하는 데도 괜찮습니다. 이 이벤트는 2026년까지 진행됩니다.&lt;/p&gt;
&lt;p&gt;특이적으로 상하이 지역 서버를 선택했고, 낮은 지연 시간 프록시로 집의 컴퓨터를 연결했습니다. win11과 windows server 2022인데, 서버 버전은 나중에 배포되었고, 사용하려고 하니 갑자기 접근 거부 메시지를 받았습니다. 서버 업데이트 때문이라고 생각해서 잠시 기다리니 정상적으로 복구될 줄 알았는데, 5분 정도 지나서 다시 시도해도 여전히 로그인되지 않습니다. 관련 오류를 검색해 보니 누군가가 로그인을 시도하고 있고, 비밀번호가 너무 많이 틀렸기 때문에 현재는 로그인이 불가능하다고 합니다.&lt;/p&gt;
&lt;p&gt;이전에도 보안 공격 스크립트를 접해본 경험이 있어서, 이러한 로그인 시도는 정상적인 행동이 아니라고 바로 생각했다. 누군가가 서비스를 공격하고 로그인 서버를 무작위로 해킹하려 하는 것 같았다. 서버 방화벽 설정이 간단하게 되어 있어 백리스트가 설정되어 있지 않았고, 두 대의 기계의 3389 포트를 프록시했기 때문에 공공 네트워크에 노출되었다. 마치 연못 속 미끼와 같은 상황이었다. 스크립트 키드가 공격하고 있다는 것을 알았으니, 다음 단계는 간단했다. 방화벽 백리스트를 설정하여 회사 IP 주소와 집 IP 주소만 프록시 서비스에 접속하도록 허용하면 된다.&lt;/p&gt;
&lt;p&gt;frps 에이전트 서버는 이전에도 실행 로그를 설정하지 않았는데, 로그를 켜니 정말 좋네요. 전국 각지의 프록시 IP 주소들이 제 집의 서버에 접속을 시도하고 있었어요. 다행히 한 대는 서버 버전이라 문제점을 깨닫게 되었고, 그렇지 않으면 win11 그 컴퓨터는 결국 해킹당할 거예요. 비밀번호 설정이 꽤 간단했거든요.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;2023/11/17 16:51:14 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [101.43.98.211:50486]
2023/11/17 16:51:14 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [218.93.202.63:56970]
2023/11/17 16:51:14 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [222.179.106.174:60812]
2023/11/17 16:51:15 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [58.16.204.238:2839]
2023/11/17 16:51:15 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [124.223.47.24:50274]
2023/11/17 16:51:16 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [43.248.128.22:55883]
2023/11/17 16:51:16 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [43.143.53.138:56955]
2023/11/17 16:51:16 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [43.228.7.250:61550]
2023/11/17 16:51:16 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [125.76.228.9:55842]
2023/11/17 16:51:17 [I] [proxy.go:204] [4dfcc2259937dcb9] [winserver-remote] get a user connection [91.240.118.187:49326]
2023/11/17 16:51:17 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [91.240.118.187:49324]
2023/11/17 16:51:17 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [89.248.163.79:51712]
2023/11/17 16:51:18 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [218.63.75.24:62387]
2023/11/17 16:51:19 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [103.186.109.227:51396]
2023/11/17 16:51:20 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [116.233.234.104:51567]
2023/11/17 16:51:20 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [222.187.193.202:51585]
2023/11/17 16:51:20 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [59.48.98.42:57489]
2023/11/17 16:51:20 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [146.56.241.134:53558]
2023/11/17 16:51:21 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [222.179.106.174:30620]
2023/11/17 16:51:23 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [183.14.214.51:62128]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;일부러 확인해 보니, 알리바바 클라우드 서버 외에 친구가 사용하는 화웨이 클라우드 서버도 있더군요&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo grep &amp;quot;Failed password&amp;quot; /var/log/secure  centos系列
sudo grep &amp;quot;Failed password&amp;quot; /var/log/auth.log  ubuntu系列
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Nov 16 04:46:34 aliyun-sh sshd[156625]: Failed password for root from 120.55.164.64 port 53410 ssh2
Nov 16 04:46:34 aliyun-sh sshd[156623]: Failed password for root from 111.16.215.122 port 36548 ssh2
Nov 16 04:46:58 aliyun-sh sshd[156630]: Failed password for invalid user share from 139.9.233.78 port 53872 ssh2
Nov 16 04:47:23 aliyun-sh sshd[156634]: Failed password for invalid user spark from 139.9.233.78 port 36134 ssh2
Nov 16 04:47:26 aliyun-sh sshd[156636]: Failed password for root from 120.55.164.64 port 46142 ssh2
Nov 16 04:47:47 aliyun-sh sshd[156640]: Failed password for root from 111.16.215.122 port 42962 ssh2
Nov 16 04:48:24 aliyun-sh sshd[156652]: Failed password for root from 120.55.164.64 port 38868 ssh2
Nov 16 04:48:25 aliyun-sh sshd[156654]: Failed password for root from 111.16.215.122 port 46164 ssh2
Nov 16 04:48:39 aliyun-sh sshd[156657]: Failed password for invalid user test from 139.9.233.78 port 39386 ssh2
Nov 16 04:48:50 aliyun-sh sshd[156659]: Failed password for root from 111.16.215.122 port 38892 ssh2
Nov 16 04:48:53 aliyun-sh sshd[156662]: Failed password for root from 120.55.164.64 port 49348 ssh2
Nov 16 04:48:53 aliyun-sh sshd[156664]: Failed password for invalid user test from 139.9.233.78 port 49864 ssh2
Nov 16 04:50:02 aliyun-sh sshd[156672]: Failed password for root from 111.16.215.122 port 45294 ssh2
Nov 16 04:50:30 aliyun-sh sshd[156680]: Failed password for invalid user zabbix from 139.9.233.78 port 52206 ssh2
Nov 16 04:50:50 aliyun-sh sshd[156683]: Failed password for root from 120.55.164.64 port 34820 ssh2
Nov 16 04:50:51 aliyun-sh sshd[156685]: Failed password for root from 111.16.215.122 port 58978 ssh2
Nov 16 04:51:18 aliyun-sh sshd[156689]: Failed password for root from 120.55.164.64 port 45306 ssh2
Nov 16 04:51:25 aliyun-sh sshd[156692]: Failed password for root from 111.16.215.122 port 33938 ssh2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;화웨이 클라우드 이 머신은 시작한 지 시간이 꽤 됐고, 이제 사변 공격의 중간 단계에 들어서면서 온갖 이상한 사용자들까지 나타나기 시작했다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Nov 16 20:30:35 hecs-411458 sshd[182965]: Failed password for invalid user oeh from 39.129.9.180 port 26459 ssh2
Nov 16 20:32:17 hecs-411458 sshd[182967]: Failed password for invalid user dnu from 39.129.9.180 port 27079 ssh2
Nov 16 20:34:12 hecs-411458 sshd[182971]: Failed password for invalid user rq from 39.129.9.180 port 27742 ssh2
Nov 16 20:36:07 hecs-411458 sshd[182979]: Failed password for invalid user zw from 39.129.9.180 port 28415 ssh2
Nov 16 20:37:59 hecs-411458 sshd[182981]: Failed password for invalid user egi from 39.129.9.180 port 29068 ssh2
Nov 16 20:39:52 hecs-411458 sshd[182984]: Failed password for invalid user bjb from 39.129.9.180 port 29723 ssh2
Nov 16 20:41:53 hecs-411458 sshd[182988]: Failed password for invalid user hna from 39.129.9.180 port 30375 ssh2
Nov 16 20:43:46 hecs-411458 sshd[182994]: Failed password for invalid user gar from 39.129.9.180 port 31036 ssh2
Nov 16 20:45:40 hecs-411458 sshd[183003]: Failed password for invalid user mze from 39.129.9.180 port 31703 ssh2
Nov 16 20:47:35 hecs-411458 sshd[183007]: Failed password for invalid user tmh from 39.129.9.180 port 32381 ssh2
Nov 16 21:23:01 hecs-411458 sshd[183047]: Failed password for invalid user amax from 112.4.65.118 port 41188 ssh2
Nov 16 22:31:20 hecs-411458 sshd[183116]: Failed password for root from 211.228.203.123 port 60213 ssh2
Nov 16 22:53:44 hecs-411458 sshd[183162]: Failed password for root from 112.132.249.164 port 39272 ssh2
Nov 17 11:44:26 hecs-411458 sshd[184811]: Failed password for invalid user jsh from 43.157.103.27 port 54608 ssh2
Nov 17 11:47:23 hecs-411458 sshd[184818]: Failed password for invalid user mrunal from 43.157.103.27 port 50448 ssh2
Nov 17 11:48:46 hecs-411458 sshd[184820]: Failed password for invalid user robertsheen from 43.157.103.27 port 50560 ssh2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;p&gt;자체 서버를 개발할 경우, Windows의 공용 네트워크 접속 시 화이트리스트 설정을 해야 하며, Linux에서는 비밀번호 로그인을 금지하고 키 파일 로그인 기능을 활성화하는 것이 좋습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>일괄 업데이트된 로컬 Git 저장소 및 기존 권한 문제</title>
        <link>https://ttf248.life/ko/p/bulk-update-local-git-repository-and-legacy-permission-issues/</link>
        <pubDate>Thu, 19 Oct 2023 14:16:22 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/bulk-update-local-git-repository-and-legacy-permission-issues/</guid>
        <description>&lt;p&gt;팀 내 프로젝트들 간에는 의존 관계가 존재하며, 과거의 사유로 인해 &lt;code&gt;submodule&lt;/code&gt;을 사용하여 프로젝트 의존성을 관리하지 않았습니다. 따라서 일상적인 개발 과정에서 저장소 코드를 수동으로 순차적으로 업데이트해야 하며, 그렇지 않으면 다양한 이상한 문제가 발생할 수 있습니다.&lt;/p&gt;
&lt;p&gt;온라인 자료를 참고하여 구조가 기본적으로 유사하므로, 로컬에서 &lt;strong&gt;git_list.txt&lt;/strong&gt;라는 저장소 디렉터리를 수동으로 유지하고, 스크립트를 작성하여 디렉터리를 순회하며 한 번에 업데이트합니다. 이후 작업 전에 스크립트를 실행하세요.&lt;/p&gt;
&lt;h2 id=&#34;linux&#34;&gt;linux
&lt;/h2&gt;&lt;p&gt;create new file: batch_pull.sh&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash

echo &amp;quot;============ 更新仓库 ===================&amp;quot;

# 检查 git_list.txt 是否存在
if [ ! -f &amp;quot;git_list.txt&amp;quot; ]; then
  echo &amp;quot;git_list.txt 文件不存在！请创建并添加要拉取的 git 仓库 URL。&amp;quot;
  exit 1
else
  echo &amp;quot;============ 检测到了 git 仓库清单文件 ====&amp;quot;
fi

# 逐行读取 git_list.txt 中的 URL，并执行拉取操作
while read -r url; do
  if [ -d &amp;quot;$url&amp;quot; ]; then
    cd &amp;quot;$url&amp;quot; || continue
    git pull
    cd ..
    echo &amp;quot;Pull $url 完成！&amp;quot;
    echo &amp;quot;========================================&amp;quot;
  else
    echo &amp;quot;目录 $url 不存在，跳过拉取。&amp;quot;
  fi
done &amp;lt; &amp;quot;git_list.txt&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;windows&#34;&gt;windows
&lt;/h2&gt;&lt;p&gt;create a new file: batch_pull.bat&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bat&#34;&gt;@echo off
chcp 65001 &amp;gt; nul
rem 进入脚本所在目录
cd /d &amp;quot;%~dp0&amp;quot;

rem 检查 git_list.txt 是否存在
if not exist &amp;quot;git_list.txt&amp;quot; (
  echo git_list.txt 文件不存在！请创建并添加要拉取的 git 仓库 URL。
  exit /b 1
) else (
  echo ============ 检测到了 git 仓库清单文件 ====
)

rem 逐行读取 git_list.txt 中的 URL，并执行拉取操作
for /f %%i in (git_list.txt) do (
  if exist &amp;quot;%%i&amp;quot; (
    pushd &amp;quot;%%i&amp;quot;
    git pull
    popd
    echo Pull %%i 完成！
    echo ========================================
  ) else (
    echo 目录 %%i 不存在，跳过拉取。
  )
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;역사적-유산-문제&#34;&gt;역사적 유산 문제
&lt;/h3&gt;&lt;p&gt;시스템 재설치 후 발생한 &lt;code&gt;git&lt;/code&gt; 폴더 권한 파일 관련 오류: &lt;strong&gt;&amp;ldquo;안전하지 않은 저장소 (&amp;rsquo;/home/repon&amp;rsquo;은 다른 사용자가 소유하고 있습니다&amp;rsquo;)&amp;rdquo; 치명적인 오류&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;온라인에서 제안하는 방법들은 대부분 &lt;code&gt;스택 오버플로우&lt;/code&gt;에서 비롯된 것입니다&lt;/p&gt;
&lt;p&gt;저장소 디렉터리에 대한 신뢰 추가: &lt;code&gt;git config --global --add safe.directory /home/repon&lt;/code&gt;
수동으로 &lt;code&gt;.gitconfig&lt;/code&gt; 설정 파일을 수정하여 디렉터리를 추가하고 신뢰하도록 지정합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[safe]
    directory = /home/repon
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 방법으로 처리한 후, 창고 업데이트는 정상적으로 되었지만, &lt;code&gt;git pull&lt;/code&gt;을 실행할 때마다 콘솔에 많은 경고 메시지가 표시되는데, 사용자 소유권 오류를 나타냅니다&lt;/p&gt;
&lt;h3 id=&#34;데스크톱-컴퓨터-재설치&#34;&gt;데스크톱 컴퓨터 재설치
&lt;/h3&gt;&lt;p&gt;개발한 기계가 너무 오래돼서 시스템을 재설치하지 않았더니, 쓰레기 파일이 폭발해서 방법이 없었습니다. 시간을 내어 시스템을 재설치했는데, 또 이 권한 문제가 발생했습니다. 예전 스크립트가 실행되지 않고, 수정된 권한이 완전하지 않습니다.&lt;/p&gt;
&lt;p&gt;새로운 방식을 사용하면 &lt;code&gt;*&lt;/code&gt;를 직접 추가하면, 이렇게 하면 &lt;code&gt;git&lt;/code&gt;이 모든 디렉터리를 자동으로 신뢰합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global --add safe.directory &amp;quot;*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;사용자 권한 문제인지, 아니면 다들 &lt;code&gt;windows&lt;/code&gt; 플랫폼에도 &lt;code&gt;chown&lt;/code&gt;과 유사한 명령이 있다는 것에 익숙하지 않은 건지 모르겠다. 폴더 소유자를 수정하는 방법인데, 만약 디렉토리가 많지 않다면 수동으로 소유자를 변경해도 괜찮다. 하지만 이 업무용 컴퓨터에는 도메인 정보가 추가되어 있는데, 회사에서 배포한 도메인에 이상이 있는지, 아니면 로컬 시스템 설정에 문제가 있는 건지 잘 모르겠다. 사용자 목록에서 로그인에 사용되는 사용자를 찾을 수 없었고, 결국 명령줄로 처리했다.&lt;/p&gt;
&lt;p&gt;관리자 권한으로 &lt;code&gt;powershell&lt;/code&gt; 스크립트 &lt;code&gt;change_ower.ps1&lt;/code&gt;을 실행하세요. 스크립트 파일 인코딩을 &lt;code&gt;gbk&lt;/code&gt;로 조정하는 것을 잊지 마세요. 중국어 운영체제에서 그래야 깨짐 없이 실행됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;# 获取当前用户的用户名
$currentUserName = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name

# 设置 PowerShell 的字符编码为 UTF-8
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8

# 要更改所有者的根目录路径
$rootDirectory = &amp;quot;G:\workspace&amp;quot;  # 替换为实际的目录路径

# 递归遍历目录并更改文件和文件夹的所有者
Get-ChildItem -Path $rootDirectory -Recurse | ForEach-Object {
    $itemPath = $_.FullName

    # 检查是文件还是文件夹
    if ($_ -is [System.IO.DirectoryInfo]) {
        # 如果是文件夹，使用 icacls 更改所有者权限
        $icaclsResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            Write-Host &amp;quot;已更改文件夹 $itemPath 的所有者为 $currentUserName&amp;quot;
        } else {
            Write-Host &amp;quot;无法更改文件夹 $itemPath 的所有者。错误信息: $icaclsResult&amp;quot;
        }
    } else {
        # 如果是文件，使用 icacls 更改所有者权限
        $takeownResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            # Write-Host &amp;quot;已更改文件 $itemPath 的所有者为 $currentUserName&amp;quot;
        } else {
            Write-Host &amp;quot;无法更改文件 $itemPath 的所有者。错误信息: $takeownResult&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;예상치 못한 상황이 발생했는데, 스크립트 실행 시 출력되는 중국어 정보가 깨져 있었고, 콘솔 문자 인코딩을 설정하고 스크립트 인코딩을 조정했음에도 불구하고 여전히 엉망진창이었다. 머리가 제대로 작동하지 않는 것 같아서, 제어판-지역-언어 설정의 베타 기능을 활성화하고 전역적으로 유니코드 인코딩을 켰더니 스크립트는 정상적으로 실행되었지만 여러 개발 소프트웨어가 제대로 작동하지 않았다. 뒤돌아보니 자료를 정리하다가 스크립트 파일의 인코딩을 &lt;code&gt;gbk&lt;/code&gt;로 설정해야 한다는 것을 기억해냈다.&lt;/p&gt;
&lt;h2 id=&#34;자료&#34;&gt;자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://ganzhixiong.com/p/f1b9f4fc/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ganzhixiong.com/p/f1b9f4fc/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/71901632/fatal-error-unsafe-repository-home-repon-is-owned-by-someone-else&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stackoverflow.com/questions/71901632/fatal-error-unsafe-repository-home-repon-is-owned-by-someone-else&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>WPF 학습 자료</title>
        <link>https://ttf248.life/ko/p/wpf-learning-resources/</link>
        <pubDate>Tue, 17 Oct 2023 10:49:24 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/wpf-learning-resources/</guid>
        <description>&lt;p&gt;미니 프로그램 개발 설계의 함정은 아직 채우지 못했는데, 새로운 &lt;strong&gt;WPF&lt;/strong&gt;를 파고 최근 회사도 동요가 있었고, 다른 지역과의 협업 업무 소통은 어쩔 수 없이 효율이 조금 미흡했기에, 그냥 클라이언트 인터페이스 개발을 맡기로 했다&lt;/p&gt;
&lt;h2 id=&#34;wpf&#34;&gt;WPF
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/dotnet/desktop/wpf/introduction-to-wpf?view=netframeworkdesktop-4.8&amp;amp;preserve-view=true&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 마이크로소프트 공식 학습 자료&lt;/a&gt;를 추천합니다&lt;/li&gt;
&lt;li&gt;[WPF 기초 요약(학습 제안)]&lt;/li&gt;
&lt;li&gt;[WPF 중국어 웹사이트]&lt;/li&gt;
&lt;li&gt;WPF 개인 정리 및 학습 추천&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;WPF 인터페이스 디자인에 사용되는 많은 개념들은 웹 프론트엔드 디자인과 유사하며, 가능한 한 UI 디자인과 비즈니스 로직을 분리하여 UI 디자인이 독립적으로 가능하도록 하는 것이 인터넷 회사들이 기대하는 분업 방식입니다. 올해 마침 소형 프로그램(小程序)을 개발해 보았는데, 많은 개념적인 부분에서 공통점이 있어 익숙해지기도 쉬웠습니다. 이러한 것들은 현대 UI 디자인의 &lt;strong&gt;진리&lt;/strong&gt;라고 할 수 있으며, 기본적인 프레임워크 개념을 숙지하면 이후로 잘못된 방향으로 나아갈 가능성이 줄어듭니다.&lt;/p&gt;
&lt;p&gt;이전에 &lt;code&gt;Winform&lt;/code&gt; 개발 경험이 있는 독자라면, &lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/zh7791/p/11502696.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 기초 요약(학습 제안)&lt;/a&gt;을 읽어보시는 것을 추천합니다. 분량이 길지 않아 경험이 있는 독자들이 학습 경로를 계획하기에 적합합니다.&lt;/p&gt;
&lt;p&gt;영문 없이 읽는 독자들을 위해 &lt;a class=&#34;link&#34; href=&#34;http://www.wpfsoft.com/introduction&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 중국어 웹사이트&lt;/a&gt;를 추천합니다. 이 곳에서는 기본 개념, 발전 역사, 그리고 하위 클래스에 대한 이해 논리를 처음부터 설명하고 있습니다. 재미롭게도 이 웹사이트는 올해 8월에 게시되었는데, 저의 일정과 딱 맞아떨어졌습니다. 조금만 더 늦었더라면 아마 기회가 없었을 겁니다.&lt;/p&gt;
&lt;p&gt;가장 정통적인 학습 자료를 원한다면 당연히 마이크로소프트 공식 자료여야 합니다. 다소 지루할 수 있지만, 새로운 독자들은 인내심을 가져야 합니다.&lt;/p&gt;
&lt;p&gt;고전적인 전자책도 많지만, 크게 추천하지는 않아요. 일상 업무가 많아서 책을 읽을 시간이 많지 않고, 한 번에 몰입해서 보기 어렵습니다. 프로젝트 연습과 함께 하는 것이 더 적합할 것 같아요.&lt;/p&gt;
&lt;h2 id=&#34;c-및-net-출시-기록&#34;&gt;C# 및 .NET 출시 기록
&lt;/h2&gt;&lt;p&gt;이전에 학습했던 언어에 비해 최근 몇 년간은 새롭게 추가된 기능이 조금 많아지고, 매년 문법 버전이 업데이트되고 있습니다&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/C_Sharp_%28programming_language%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://en.wikipedia.org/wiki/C_Sharp_(programming_language)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;공식 학습 자료:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/dotnet/csharp/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/dotnet/csharp/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/dotnet/core/tutorials/with-visual-studio?pivots=dotnet-7-0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/dotnet/core/tutorials/with-visual-studio?pivots=dotnet-7-0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>금융 부패 척벌의 시작</title>
        <link>https://ttf248.life/ko/p/financial-anti-corruption-curtain/</link>
        <pubDate>Mon, 09 Oct 2023 14:53:35 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/financial-anti-corruption-curtain/</guid>
        <description>&lt;p&gt;중앙집중검찰부: 국유기업과 금융 분야 부패 방치 노력을 강화하고, “사풍”을 깊이 근절해야 한다&lt;/p&gt;
&lt;h2 id=&#34;중국공산당-중앙정치국&#34;&gt;중국공산당 중앙정치국
&lt;/h2&gt;&lt;p&gt;중앙집중검열위원회는 9월 27일 회의를 열어 제20차 중앙검열 첫 번째 차례 검열 결과 종합 보고서를 심의했다. 시진핑 주석이 회의를 주재했다. 회의에서 검열을 통해 발전하는 계기로 삼아 당의 전면적 지도 노력을 더욱 강화하고, 검열 대상 당 조직이 정치적 위치를 높이고 중앙이 부여한 책임과 임무를 충실히 수행하며 국유 기업의 핵심 기능과 핵심 경쟁력을 끊임없이 강화하여 중국 특색 사회주의의 중요한 물질적 토대와 정치적 토대를 굳건히 하고 금융 기관이 실체 경제와 국가 전략에 대한 봉사를 확대하고 고품질 발전을 촉진해야 한다고 강조했다. 발전과 안전을 균형 있게 추진하고, 사고방식의 최저선과 극한 상황을 확립하며 강력한 조치를 통해 중대한 위험을 예방하고 해결하며 안전 선을 굳건히 지켜야 한다. 전면 엄격한 당 건설을 심화 발전시키고, 각 당 위원회(당조) 서기의 첫 번째 책임자 책임을 강화하고 리더십 팀 구성원의 “일직 이책임”과 검찰 및 감시 기관의 감독 책임을 강조하며 각급 “최고 책임자”에 대한 감독을 강화하고 국유 기업과 금융 분야 부패 방지 노력을 확대하며 “사풍”을 근절하고 사건을 통해 개선 및 치료를 촉진하여 부패하지 않고, 할 수 없고, 원치 않는 부패를 통합적으로 추진해야 한다. 새로운 시대 당의 조직 노선을 충실히 시행하고 리더십 팀 건설, 인재 육성 및 초급당 조직 건설을 강화해야 한다. 검열 결과를 종합적으로 활용하여 개혁을 심화하고 제도를 개선하며 근원적 관리를 추진하고 치료와 예방을 통합적으로 추진해야 한다. (신화통신)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;중대한 금융 리스크 초래! 중국 은행 전 당위원회 서기, 주석 유련가 해산&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;중앙감찰검사위원회 웹사이트에 따르면 공산당 중앙의 승인을 받아 중앙감찰검사위원회가 중국은행 주식회사 전 당서기, 회장 유리안가를 대상으로 심각한 비위성폭행 문제에 대한 기소 조사 및 조사를 실시했습니다
검사 결과, 리안가(刘连舸)는 이념 신앙을 상실하고 창초 사명을 배척하며 당중앙의 결정 배치에 대해 단호하지 못하고 깎아내렸으며, 금융위험 방어 책임을 버리고 대규모로 위법하게 신용 프로젝트에 개입하고 불법적으로 대출을 지급하여 중대한 금융 위험을 초래했으며, 전면 엄격한 치당 주체적 책임이 미흡하여 근무 단위의 정치 생태를 심각히 파괴하고, 자의적으로 금지 서적을 반입하며 조직 검사에 적극적으로 저항했습니다. 중앙 8항 규정 정신을 무시하고 부적절하게 선물과 사례금품을 수령하고 사적인 클럽에 출입하며 스키와 여행 주선을 받았으며, 장기간 관리 대상 차량을 차용하고, 개인 관련 사항을 정해진 바에 따라 보고하지 않고 조직 문의 시 문제점을 허심탄회하게 설명하지 않았으며, 사적으로 채용 및 조정, 승진 인사를 했습니다. 위법하게 상업 활동을 하고 자금 대출을 부당하게 개입하며 기밀 자료를 보관했습니다. 도덕이 문란하고 가풍이 부정하며 친족을 소홀히 관리 감독하지 못했으며, 규율과 법의 선을 무시하고 권력을 남용하여 “금융으로 먹고 마셨으며” 직무 편의를 이용하여 타인의 대출 자금 조달 및 프로젝트 협력 등에서 이익을 추구하고 불법적으로 거액의 재물을 수령했습니다.&lt;/p&gt;
&lt;p&gt;류련가(刘连舸)는 당의 정치적 규율, 조직적 규율, 청렴 규율, 업무 규율 및 생활 규율을 심각히 위반하고, 중대한 직무 위법을 구성하며 뇌수(受贿)와 불법적인 대출 범죄를 저질렀으며, 당 제18차 전국대표대회 이후에도 수정을 거두지 않고 손을 멈추지 않아 사태가 매우 심각하고 영향이 불량하므로 엄중하게 처리해야 한다. 《중국공산당 처분규정》《중화인민공화국 감독법》《중화인민공화국 공직자 행정처분법》 등 관련 규정에 따라 중앙감찰검열위원회 상무위원회의 회의 연구 및 당 중앙의 승인을 거쳐 류련가에게 당적 해고 처분을 내리고, 규정에 따라 향유하던 대가를 취소하며, 당 제20차 전국대표자 자격을 종료하고, 위반·불법적인 이득을 추렴하여 관련 범죄 문제를 검찰기관에 회부하여 법적으로 심사 및 기소하도록 하며, 관련 재산도 함께 이관한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;중국 광다그룹 전 당위서기·회장 리샤오펑이 심각한 비리 및 불법 행위로 인해 당적 박탈 및 공직 해임 처분을 받았다. (CCTV 뉴스)&lt;/li&gt;
&lt;li&gt;중앙징위 국가감사위원회 홈페이지 발표에 따르면, 귀주성 징위감사위원회 소식에: 귀주은행 전 당위서기·회장 리지밍은 심각한 비위반·비법 행위를 저질렀을 가능성이 있으며, 현재 귀주성 징위감사위원회의 당위 규율검사와 감사조사를 받고 있다&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;8년-만에-회진이-주요-4대-은행-지분을-추가-매입&#34;&gt;8년 만에 회진이 주요 4대 은행 지분을 추가 매입
&lt;/h2&gt;&lt;p&gt;10월 11일, 산업은행, 농업은행, 중국은행, 건설은행 등 중국 4대 국유 상업은행이 각각 공지를 발표하며 회자금공사의 지분율 증가를 알렸습니다. 구체적으로 주식 수는 2761만 주, 3727만 주, 2489만 주, 1838만 주로 나뉘며, 회자금공사는 향후 6개월 동안 이들 4대 은행의 지분을 추가 매입할 계획입니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>트래픽 수익화 비즈니스 모델: 추첨</title>
        <link>https://ttf248.life/ko/p/traffic-monetization-business-models-lottery/</link>
        <pubDate>Tue, 19 Sep 2023 07:04:35 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/traffic-monetization-business-models-lottery/</guid>
        <description>&lt;p&gt;방송국에서 아이폰을 보내준다? 미니 프로그램 순위 보상? 각종 라이브 방송 플랫폼의 선물 추첨?&lt;/p&gt;
&lt;p&gt;위 세 가지는 겉보기에는 별로 연관성이 없어 보이지만, 실질적으로는 모두 무료 트래픽을 통해 수익을 창출하는 다양한 방식이며, 약간의 금융 게임과 같은 느낌이다&lt;/p&gt;
&lt;h2 id=&#34;플랫폼-추첨으로-선물-받기&#34;&gt;플랫폼 추첨으로 선물 받기
&lt;/h2&gt;&lt;p&gt;일반적인 시나리오에서, 사용자는 플랫폼 화폐를 재설정하여 마음에 드는 방송자에게 선물을 보내고, 각 플랫폼마다 또 다른 방식으로, 사용자가 플랫폼 화폐를 획득한 후 직접 선물하는 대신 일정량의 화폐를 사용하여 추첨 이벤트에 참여하고 한정판 고가 상품을 얻습니다&lt;/p&gt;
&lt;p&gt;지금 벌써 문제가 생겼어요. 온라인 추첨은 간단히 말해 플랫폼이 카지노를 운영하는 것과 같아요. 참여 인원이 충분히 많으면 절대 손해 보지 않죠. &lt;strong&gt;디씨&lt;/strong&gt; 유저는 한번 해보자는 심정으로 큰 상을 받고 선물을 주고 가서 체면을 세우고, 큰 형 노릇하려 합니다!&lt;/p&gt;
&lt;h2 id=&#34;방송국에서-선물-물건&#34;&gt;방송국에서 선물 (물건)
&lt;/h2&gt;&lt;p&gt;위에 언급된 플랫폼 추첨은 사용자 본인의 글쓰기를 대상으로 하며, 방송 진행자는 매월 거래량 임무와 인기 임무를 가지고 있습니다. 선물 추첨 기능을 활성화하면 팬이 지정된 선물을 보내거나 특정 금액의 선물을 보낼 경우 추첨에 참여할 기회가 주어지는데, 선물은 고급 휴대폰이나 현금 혜택일 수 있습니다.&lt;/p&gt;
&lt;p&gt;인기가 많은 방송사에게는 이 이벤트가 돈이 되는 일입니다. 일시적으로 시작하는 무료 상품 구매와 같아서 참여하는 사람이 많으면 방송사도 수익을 낼 수 있습니다. 여기서 방송사의 운영 능력이 시험됩니다.&lt;/p&gt;
&lt;p&gt;물론 또 다른 방식도 있는데, 보상(현금 가치)이 매우 높아서 많은 야외 방송인이 이 방식을 이용하고 있습니다. 변종의 온라인 도박과 같습니다. 시청자들은 생방송 내용에는 관심 없고 오직 자신이 당첨될 수 있는지 여부만 신경 씁니다.&lt;/p&gt;
&lt;p&gt;쇼 타입의 진행자 외에 PK 모드를 통해 팬들의 소비 충전을 유도하는 방식으로는, 일반 게임 방송인들이 플레이어들의 소비 심리를 자극하기는 어렵다. 게임을 하고 스트리밍 시청을 하는 것은 모두 여가 활동이며, 추가적인 금전적 지출을 하고 싶어 하지는 않는다. 특히 &lt;strong&gt;경쟁 게임&lt;/strong&gt;의 경우, 추첨 방식으로 사용자들의 충전 습관과 소비 습관을 길러주고, 가끔은 충동적으로 소비하게 만들 수 있다 (많은 상품을 제공하여 당첨될 확률을 높이는 방식).&lt;/p&gt;
&lt;h2 id=&#34;소규모-프로그램-순위-보상&#34;&gt;소규모 프로그램 순위 보상
&lt;/h2&gt;&lt;p&gt;소규모 앱을 설계하여 별 볼 일 없는 기능들을 구현하거나, 게임 관련 보조 서비스를 제공합니다. 이러한 것들은 모두 위장술이며, 텐센트의 검열을 통과하기 위한 것입니다. 앱 내 플레이 방식에 순위 시스템을 추가합니다. 사용자는 리워드 광고를 시청하고, 임무를 완료하여 포인트를 얻습니다. 백엔드는 포인트에 따라 순위를 설정하며, 높은 순위에 오른 사용자는 지정된 보상을 받습니다.&lt;/p&gt;
&lt;p&gt;핵심 논리: 광고 수익 &amp;gt; 운영 비용 + 보상 비용&lt;/p&gt;
&lt;p&gt;小程序도 정상적으로 운영하는 방법이 있고, 합리적인 서비스를 제공하고 적절한 광고로 수익을 창출할 수 있습니다. 벌어들이는 돈은 많지 않을 수도 있지만, 꾸준히 모이면 되는 것도 괜찮습니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>지리적 분산 환경의 제로티어</title>
        <link>https://ttf248.life/ko/p/zero-tier-remote-lan/</link>
        <pubDate>Tue, 19 Sep 2023 04:58:03 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/zero-tier-remote-lan/</guid>
        <description>&lt;p&gt;사무실에 새 &lt;code&gt;mini&lt;/code&gt; 호스트를 구입했는데, 환경 설정이 간편하고 가끔 집에서 접속할 필요가 있어서 임시로 내장 네트워크 침투를 구축했습니다. 이전 경험을 바탕으로 &lt;code&gt;frp&lt;/code&gt; 서비스를 배포하고 포트 전달을 지정했더니 공용 서버가 필요했고 연결 품질은 공용 서버의 대역폭에 따라 달라졌습니다. 새로운 &lt;code&gt;Zerotier&lt;/code&gt; 가상 머신 로컬 영역 네트워크를 구축했는데, 이는 &lt;code&gt;VPN&lt;/code&gt;과 유사하며 로컬에서 가상 네트워크 카드를 새로 만들고 모든 장치를 하나의 가상 네트워크에 추가했습니다.&lt;/p&gt;
&lt;h2 id=&#34;제로티어는-무엇인가요&#34;&gt;제로티어는 무엇인가요?
&lt;/h2&gt;&lt;p&gt;ZeroTier는 다양한 지리적 위치의 장치 간에 안전한 가상 네트워크를 생성할 수 있는 소프트웨어 정의 광역 네트워크(SD-WAN) 솔루션입니다. ZeroTier를 통해 여러 대의 컴퓨터, 서버 및 장치를 마치 동일한 로컬 영역 네트워크에 있는 것처럼 하나의 가상 암호화된 네트워크에 쉽게 연결할 수 있습니다. 이를 통해 프로그래머와 IT 전문가는 복잡한 네트워크 설정 및 VPN 구성 없이 서로 다른 위치에서 데이터와 리소스를 안전하게 공유할 수 있습니다.&lt;/p&gt;
&lt;p&gt;제로티어 네트워크는 가상 전역 로컬 영역 네트워크로, 서로 다른 장치들이 인터넷을 통해 연결되어 마치 동일한 물리적 네트워크에 있는 것처럼 작동하도록 합니다. 이 네트워크는 여러 서브넷으로 구성될 수 있으며, 모든 장치는 제로티어 기술을 통해 연결됩니다.&lt;/p&gt;
&lt;p&gt;행성 서버: 행성 서버는 Zerotier 네트워크의 핵심 구성 요소 중 하나입니다. 이들은 전 세계적으로 운영되며, Zerotier 네트워크 전체의 토폴로지 구조, 라우팅 정보 및 네트워크 상태를 유지 관리합니다. 행성 서버는 네트워크 제어 센터 역할을 하지만 데이터를 직접 전송하지는 않습니다. 사용자의 장치는 Zerotier 네트워크에 참여하기 위해 최소한 하나의 행성 서버에 연결해야 합니다.&lt;/p&gt;
&lt;p&gt;중계 서버: 중계 서버는 Zerotier 네트워크에서 보조 노드로, 장치 간의 직접 통신 채널을 설정하는 데 도움을 줍니다. 장치가 서로 직접 연결할 수 없을 때, 이들은 중계 서버를 통해 데이터를 전송할 수 있습니다. 이는 네트워크의 가용성과 성능을 향상시키는 데 도움이 됩니다. 중계 서버는 일반적으로 전 세계 곳곳에 위치하여 데이터 전송의 중계 지점 역할을 합니다.&lt;/p&gt;
&lt;p&gt;전반적으로, Zerotier는 행성 서버와 중계 서버의 도움을 받아 전 세계적으로 가상 로컬 영역 네트워크를 구축하여 장치 간 안전하고 빠른 통신을 가능하게 합니다. 행성 서버는 전체 네트워크 관리를 담당하며, 중계 서버는 필요할 때 장치가 통신 연결을 설정하도록 돕습니다.&lt;/p&gt;
&lt;h2 id=&#34;설치-배포&#34;&gt;설치 배포
&lt;/h2&gt;&lt;p&gt;ZeroTier 공식 웹사이트(&lt;a class=&#34;link&#34; href=&#34;https://www.zerotier.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.zerotier.com/&lt;/a&gt;)에서 설치 파일과 문서를 다운로드하세요
귀하의 운영 체제에 따라 ZeroTier One 클라이언트 프로그램을 다운로드하여 설치하십시오. Windows, macOS, Linux 및 기타 여러 플랫폼을 지원합니다.
설치가 완료되면 ZeroTier One 클라이언트를 시작합니다
ZeroTier 계정이 아직 없으시다면, 계정을 만드세요. 클라이언트에서 계정을 생성할 수 있습니다.
ZeroTier 계정으로 로그인하여 새 네트워크를 만드세요. 네트워크에는 고유한 16자리 ID가 있으며, 이 ID를 기억해야 합니다.
귀하의 장치에 이 네트워크를 추가합니다. 클라이언트에서 네트워크 ID를 입력하거나 QR 코드 스캔 기능을 사용할 수 있습니다.
7. ZeroTier 클라이언트가 설치 및 구성된 장치는 동일한 가상 네트워크에 추가됩니다. 이제 이러한 장치들은 마치 동일한 로컬 영역 네트워크에 있는 것처럼 직접 통신할 수 있습니다.
ZeroTier 제어판에서 네트워크 설정 관리, 장치 추가 및 네트워크 트래픽 모니터링 등을 할 수 있습니다&lt;/p&gt;
&lt;h2 id=&#34;문-설치-배포&#34;&gt;문 설치 배포
&lt;/h2&gt;&lt;p&gt;국내 통신사들은 대부분 &lt;code&gt;UDP&lt;/code&gt; 포트 포워딩을 금지하고 있습니다. &lt;code&gt;frp&lt;/code&gt; 서비스는 안정적이며, &lt;code&gt;TCP&lt;/code&gt; 프로토콜을 사용하기 때문에 &lt;code&gt;Zerotier&lt;/code&gt;를 통해 리퍼 서버를 배포하여 유사한 효과를 낼 수 있습니다. 방화벽에서는 &lt;code&gt;udp 9993&lt;/code&gt; 포트를 개방해야 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -s https://install.zerotier.com/ | sudo bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;설치 성공 여부 확인&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zerotier-cli info
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;로컬 네트워크에 참여하세요&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zerotier-cli join network-id
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;moon&lt;/code&gt;을 생성합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd /var/lib/zerotier-one &amp;amp;&amp;amp; sudo zerotier-idtool initmoon identity.public &amp;gt; moon.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;편집기 구성 파일을 조정하고 &lt;code&gt;stableEndpoints&lt;/code&gt; 노드를 &amp;ldquo;서버 공용 IP/9993&amp;quot;으로 설정합니다&lt;/p&gt;
&lt;p&gt;서명 구성 생성, &lt;code&gt;moons.d&lt;/code&gt; 폴더 생성 후 해당 파일들을 이동하고 서비스를 재시작합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo zerotier-idtool genmoon moon.json
mkdir moons.d &amp;amp;&amp;amp; mv 000000eb444ec0d8.moon moons.d/
systemctl restart zerotier-one.service
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;클라이언트 노드가 문(moon) 서버에 접속하며, ID는 앞선 JSON 설정 파일의 ID 필드에서 가져옵니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zerotier-cli.bat orbit ztaddr ztaddr
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 观察是否出现新的 mooon 节点，id 和信息为服务器配置的相同
[root@idv-36f9d5 ~]# zerotier-cli listpeers
200 listpeers &amp;lt;ztaddr&amp;gt; &amp;lt;path&amp;gt; &amp;lt;latency&amp;gt; &amp;lt;version&amp;gt; &amp;lt;role&amp;gt;
200 listpeers 0cccb***** 35.236.*.*/64393;110;10726 327 1.6.3 LEAF
200 listpeers 3a46f***** 185.180.*.*/9993;110;757 -1 - PLANET
200 listpeers 3ed7c***** 39.97.*.*/9993;172;79 32 1.6.3 MOON
200 listpeers 4f838***** - -1 - LEAF
200 listpeers 62f86***** 50.7.*.*/9993;110;4796 351 - PLANET
200 listpeers 778cd***** 103.195.*.*/9993;5148;4887 253 - PLANET
200 listpeers 992fc***** 195.181.*.*/9993;10161;4921 226 - PLANET
200 listpeers 9d2b5***** - -1 - LEAF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Windows 플랫폼에서는 관리자 권한으로 터미널을 실행하고 zerotier-cli.bat 명령줄 도구를 사용하여 Linux 플랫폼에서는 zerotier-cli를 사용합니다. peers 서브 명령어는 연결 상태를 확인하고, listpeers는 모든 노드를 표시하며, &lt;code&gt;moon&lt;/code&gt; 노드가 정상적으로 표시되면 성공적으로 조인된 것입니다.&lt;/p&gt;
&lt;h2 id=&#34;어떻게-제거할-수-있나요&#34;&gt;어떻게 제거할 수 있나요
&lt;/h2&gt;&lt;p&gt;윈도우 플랫폼에서 제거하는 방법은 더 이상 설명하지 않겠습니다. 일반적인 작업으로 제어판을 통해 제거하면 됩니다. 우리는 &lt;code&gt;Ubuntu&lt;/code&gt;에 대해 중점적으로 이야기하겠습니다.&lt;/p&gt;
&lt;p&gt;dpkg를 통해 zerotier-one 서비스를 삭제합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo dpkg -P zerotier-one
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;zerotier-one 폴더를 삭제하면 주소가 저장되어 있는데, 삭제 후 다시 설치하면 새로운 주소를 얻을 수 있습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo rm -rf /var/lib/zerotier-one/
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;p&gt;원래 다 이미 제거해 놨는데, 서버는 도착했는데 적절한 프록시 노드 역할을 할 서비스가 없어서 알리바바 클라우드가 실적을 위해 개발 전용 서버를 제공했어. 사양은 높지 않고, 연간 99위안으로 저렴해서 두 대 정도 돌리고 있어. 서버에서 제공하는 대역폭이 마음에 들어서 그런 거야.&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.wnark.com/archives/152.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.wnark.com/archives/152.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/Yogile/p/12642423.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cnblogs.com/Yogile/p/12642423.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>VMware 가상 머신 디스크 공간 최적화</title>
        <link>https://ttf248.life/ko/p/vmware-virtual-disk-space-optimization/</link>
        <pubDate>Wed, 21 Jun 2023 18:35:41 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/vmware-virtual-disk-space-optimization/</guid>
        <description>&lt;p&gt;VMware 가상 머신을 설치하고 개발 시스템을 사용할 때, 보통은 디스크 공간을 넉넉하게 남겨두는데, 시간이 지나면 실제 파일 내용보다 훨씬 더 많은 로컬 디스크 공간을 차지하게 됩니다&lt;/p&gt;
&lt;h2 id=&#34;장면-묘사&#34;&gt;장면 묘사
&lt;/h2&gt;&lt;p&gt;df -h 명령어를 통해 현재 기계의 디스크 정보를 확인하니, 실제로 60GB를 사용 중이었고, 모든 스냅샷과 클론 이미지를 삭제했음에도 불구하고 로컬 가상 머신이 차지하는 디스크 공간은 여전히 60GB를 훨씬 넘어섰다. 본래 부족한 하드디스크에 더 많은 부담을 주게 되었다.&lt;/p&gt;
&lt;h2 id=&#34;선행-조건&#34;&gt;선행 조건
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;가상 머신 설치할 때, 미리 할당된 디스크를 선택하지 않았습니다&lt;/li&gt;
&lt;li&gt;가상 머신이 사용하는 공간보다 현재 로컬에 저장된 가상 머신의 하드 디스크에 남은 디스크 공간이 더 큽니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;남은 공간이 부족하므로, 임시로 가상 머신을 외장 하드 드라이브로 이동한 후 디스크를 최적화했다가 다시 이전하는 것을 고려해 볼 수 있습니다&lt;/p&gt;
&lt;h2 id=&#34;도구&#34;&gt;도구
&lt;/h2&gt;&lt;p&gt;공식적으로 &lt;code&gt;open-vm-tools&lt;/code&gt; 패키지를 제공하며, yum을 통해 설치하거나 VMware Tools 이미지 패키지로 설치할 수 있습니다&lt;/p&gt;
&lt;h2 id=&#34;명령&#34;&gt;명령
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vmware-toolbox-cmd disk shrink /
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;실행하면 가상 머신이 자동으로 종료되고 VMware 호스트 프로그램은 디스크 압축을 실행합니다. 이 작업 시간은 가상 머신의 크기와 디스크 액세스 속도에 따라 달라집니다.&lt;/p&gt;
&lt;p&gt;실행 결과는 여전히 꽤 괜찮으며, 가상 머신의 디스크 공간 사용량은 &lt;code&gt;df -h&lt;/code&gt;의 디스크 정보와 거의 동일합니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>스테이블 디퓨전 - 처음부터 설치하는 은원정후</title>
        <link>https://ttf248.life/ko/p/stable-diffusion-zero-install-saga/</link>
        <pubDate>Thu, 13 Apr 2023 00:23:54 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/stable-diffusion-zero-install-saga/</guid>
        <description>&lt;p&gt;국내 자료들을 보니 거의 다 &lt;strong&gt;아키바&lt;/strong&gt; 형님의 원클릭 배포 패키지를 추천하고 있네요. &lt;code&gt;Python&lt;/code&gt; 기반의 오픈소스 프로젝트인 만큼, 설치도 그렇게 복잡하지 않을 것 같아서 처음부터 직접 해보려고 합니다.&lt;/p&gt;
&lt;p&gt;AI 생성 이미지로 씨름하느라, 특별히 그래픽 카드를 교체했는데 &lt;code&gt;3060 12G&lt;/code&gt; 보급형 모델입니다. 7년간 사용한 &lt;code&gt;960&lt;/code&gt;은 영광스럽게도 은퇴했습니다.&lt;/p&gt;
&lt;p&gt;핵심적인 &lt;code&gt;pytorch cuda&lt;/code&gt; 설치, 예전에 &lt;code&gt;python&lt;/code&gt; 게임 보조 스크립트를 작성할 때 로컬에 설치한 적이 있는데, 생각보다 문제도 많이 겪고 &lt;code&gt;cuda&lt;/code&gt; 암호화가 계속 활성화되지 않는다&lt;/p&gt;
&lt;h2 id=&#34;처리할-일&#34;&gt;처리할 일
&lt;/h2&gt;&lt;p&gt;새로운 기사 구조로 재구성하여 pytorch, 버전 호환성, 버전을 확인하는 방법을 먼저 소개합니다
로컬에서 어떻게 처음부터 가상 환경을 만들고 PyTorch를 배포할 수 있나요?
번역 자료, 0부터 시작하는 Stable Diffusion &lt;a class=&#34;link&#34; href=&#34;https://stable-diffusion-art.com/install-windows/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stable-diffusion-art.com/install-windows/&lt;/a&gt;
자료 정리&lt;/p&gt;
&lt;h2 id=&#34;단계&#34;&gt;단계
&lt;/h2&gt;&lt;p&gt;중국어로 검색하면 관련 단계별 설치 튜토리얼을 찾기 어려울 수 있습니다. &lt;code&gt;Google&lt;/code&gt;에서 영어로 검색하면, 처음부터 시작하는 유사한 튜토리얼이 많이 있습니다. 필요한 것들을 설명했는데, 먼저 &lt;code&gt;git&lt;/code&gt;을 설치해야 하고, 그 다음에는 &lt;code&gt;python&lt;/code&gt;을 설치해야 한다고 했습니다. 그리고 저장소를 다운로드하고 스크립트를 더블 클릭하면 끝났습니다.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/AUTOMATIC1111/stable-diffusion-webui&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;자세한 사용법 및 FAQ는 &lt;code&gt;issues&lt;/code&gt;를 참고하시고, &lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki&lt;/a&gt; 를 확인하세요&lt;/p&gt;
&lt;p&gt;저도 왜인지 이 창고가 무엇을 하는 곳인지 설명하는 사람이 없네요. 사실 이름만 봐도 알 수 있습니다. 이건 인터페이스 콘솔이고, 우리를 더 편리하게 사용할 수 있도록 해 줍니다. 실제로 설치할 때, 그는 공식 저장소 내용을 다운로드하고 실제 &lt;code&gt;SD&lt;/code&gt; 코드를 가져옵니다.&lt;/p&gt;
&lt;p&gt;창고와 함께 설치 시작 스크립트도 만들었습니다. 현재 폴더에 &lt;code&gt;Python&lt;/code&gt; 가상 환경이 있는지 자동으로 인식하며, 있다면 기본적으로 현재 경로의 &lt;code&gt;python&lt;/code&gt;을 사용합니다.&lt;/p&gt;
&lt;p&gt;만약 완전한 초보 사용자라면, 다음을 참고해 보세요: &lt;a class=&#34;link&#34; href=&#34;https://stable-diffusion-art.com/install-windows/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stable-diffusion-art.com/install-windows/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;pytorch&#34;&gt;pytorch
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://pytorch.org/get-started/locally/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pytorch.org/get-started/locally/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;여기서부터 제가 오늘 말씀드리고 싶은 건데요, 우선 그들의 단계대로 스크립트를 바로 실행하지 마세요. 파이썬은 requirement 파일로 의존성 라이브러리를 설치하는데, 이건 별거 아니에요. 핵심은 그래픽 카드 드라이버 버전과 pytorch가 호환되는지 확인하는 겁니다. 이 부분에 대한 설명도 많은 사람들이 소개하고 있으니, 인터넷에서 찾아보면 쉽게 찾을 수 있을 거예요.&lt;/p&gt;
&lt;p&gt;참고 자료: &lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/weixin_40660408/article/details/129896700&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/weixin_40660408/article/details/129896700&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;가상 환경을 하나 만들어서, 즉 빈 가상 환경에서 먼저 공식 웹사이트에서 스크립트를 실행해서 pytorch를 설치하세요&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python -c &amp;quot;import torch; print(torch.version.cuda)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python -c &amp;quot;import torch; print(torch.__version__, torch.cuda.is_available())&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 두 스크립트는 설치해야 할 CUDA 버전을 확인하고, 설치가 성공적으로 되었는지 확인할 수 있습니다&lt;/p&gt;
&lt;p&gt;여기 화려한 조작은 권장하지 않으니, 일단 공식 페이지의 로직대로 복사해서 설치하면 되고, 바로 pip로 설치하면 실패할 가능성이 높거나 CUDA가 활성화되지 않을 수 있습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;중요한 점은 폴더 경로에 불필요한 것들이 없어야 합니다. 그렇지 않으면 pytorch를 사용할 수 없을 가능성이 매우 높습니다.&lt;/p&gt;
&lt;p&gt;중간에 여러 번 설치하고, 공식 설치 파일을 다운로드하여 수동으로 설치하는 방법도 시도했습니다. 2.0 버전으로 업그레이드하려고 했는데, 공식 문서에는 2.0 버전이 속도가 좀 더 빠르다고 되어 있습니다. 하지만 이전에는 많이 사용하지 않았고, Python 버전과 이것이 관련이 있는지 잘 모르겠습니다. 중간에 공식 매뉴얼을 살펴보니 3.8 버전을 사용하는 것이 좋다고 합니다. 그래서 약간의 충돌이 발생했는데, 이전에 원클릭 설치 패키지를 사용했더니 그 안에 3.10 버전이 있었습니다. 결국 처음부터 다시 시작하여 새 폴더를 만들고 가상 환경을 생성하고 torch가 성공적으로 설치되었는지 확인했습니다.&lt;/p&gt;
&lt;p&gt;그런 다음 이 설치된 가상 환경을 웹 UI 폴더 안에 이동하세요. 이때부터 스크립트 설치를 시작하면 다른 의존성 문제는 크게 줄어들 것입니다.&lt;/p&gt;
&lt;p&gt;이동 후에는 다음을 실행해야 합니다: python -m pip install &amp;ndash;upgrade &amp;ndash;force-reinstall pip, pip를 수정합니다&lt;/p&gt;
&lt;p&gt;아마 꽤 이상하게 보일 수도 있지만, 이 부분은 꽤 오랫동안 고생했어요. 제 torch를 제대로 인식하지 못했기 때문입니다. 모든 간섭 요소를 배제하기 위해 먼저 이것을 설치한 다음 다른 종속성 라이브러리를 설치하려고 했습니다.&lt;/p&gt;
&lt;h2 id=&#34;xformers&#34;&gt;Xformers
&lt;/h2&gt;&lt;p&gt;제안은 활성화하면 이미지 생성 속도를 높이고 기존 사용량을 줄일 수 있습니다. 부작용으로는 동일한 매개변수 그룹에서 &lt;strong&gt;생성된 이미지가 상대적으로 안정적이지 않을 수 있습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Xformers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;stable-diffusion-webui:Xformers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://huggingface.co/docs/diffusers/optimization/xformers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;huggingface optimization&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Optimization Ratio&lt;/th&gt;
&lt;th&gt;Time taken&lt;/th&gt;
&lt;th&gt;Torch active/reserved&lt;/th&gt;
&lt;th&gt;Sys VRAM&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;100.00%&lt;/td&gt;
&lt;td&gt;2m 57.03s&lt;/td&gt;
&lt;td&gt;7440/10058 MiB&lt;/td&gt;
&lt;td&gt;12288/12288 MiB (100.0%)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;51.02%&lt;/td&gt;
&lt;td&gt;1m 29.21s&lt;/td&gt;
&lt;td&gt;4547/7164 MiB&lt;/td&gt;
&lt;td&gt;9298/12288 MiB (75.67%)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;((masterpiece)),((best quality)),((high detial)),((realistic,))
Industrial age city, deep canyons in the middle,chinese architectural streets,bazaars, Bridges, (rainy days:1.2), (steampunk:0.8), chinese architecture
Negative prompt: nsfw,((cowboy)),(((pubic))), ((((pubic_hair))))sketch, duplicate, ugly, huge eyes, text, logo, monochrome, worst face, (bad and mutated hands:1.3), (worst quality:2.0), (low quality:2.0), (blurry:2.0), horror, geometry, bad_prompt, (bad hands), (missing fingers), multiple limbs, bad anatomy, (interlocked fingers:1.2), Ugly Fingers, (extra digit and hands and fingers and legs and arms:1.4), crown braid, ((2girl)), (deformed fingers:1.2), (long fingers:1.2),succubus wings,horn,succubus horn,succubus hairstyle, (bad-artist-anime), bad-artist, bad hand, borrowed character, text focus, watermark, sample watermark, character watermark, lofter username, photo date watermark, movie poster, magazine cover, journal, cover, cover page, doujin cover, album cover, manga cover, brand name imitation, EasyNegative,Tights, silk stockings,shorts
Steps: 35, Sampler: DPM adaptive, CFG scale: 5.5, Seed: 2223996555, Size: 1088x1088, Model hash: 543bcbc212, Model: base_Anything-V3.0-pruned, Clip skip: 2, ENSD: 31337
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;p&gt;왜 추천하는 원클릭 배포 패키지가 아닌지 궁금해하는데, 그 패키지 안에는 일부 설정이 작성자 개인적으로 커스터마이징된 부분이 있어서 공식 버전과 완전히 동일하지 않습니다. 만약 초보 사용자라면 왜 그런 파라미터를 설정해야 하는지에 대한 최선의 논리는 먼저 공식 버전을 사용하는 것입니다. 사용 시간이 길어질수록 공식 매뉴얼을 더 자주 살펴보면 어떤 파라미터를 조정해야 할지 알 수 있을 겁니다.&lt;/p&gt;
&lt;h2 id=&#34;그래픽-카드-선택&#34;&gt;그래픽 카드 선택
&lt;/h2&gt;&lt;p&gt;데이터 마이닝 이후, 그래픽카드 가격이 상대적으로 많이 내렸고, 일반적인 입문자라면 &lt;code&gt;3060&lt;/code&gt;과 &lt;code&gt;3060ti&lt;/code&gt; 사이에서 고민할 때 보통 더 큰 메모리 용량인 &lt;code&gt;12G&lt;/code&gt; 버전의 3060을 추천하는 경우가 많다. 결국 더 높은 해상도의 이미지를 생성할 수 있기 때문이다. 왜 더 높은 해상도가 필요하냐면, 이미지 생성 시 해상도를 높여서 더욱 선명하고 섬세한 이미지를 얻을 수 있기 때문이다. 만약 작은 이미지를 생성하고 싶다면 &lt;code&gt;8G&lt;/code&gt; 메모리 용량도 충분하다.&lt;/p&gt;
&lt;p&gt;아직 하나 더, &lt;strong&gt;고화질 확대&lt;/strong&gt; 옵션은 디테일을 구체화하여 화면의 디테일을 더욱 풍부하게 만들지만, 더 많은 비디오 메모리가 필요합니다&lt;/p&gt;
&lt;p&gt;다음은 NVIDIA GeForce GTX 970, GeForce RTX 3060 Ti, GeForce RTX 3060, GeForce RTX 3080 및 GeForce RTX 3080 Ti의 단정밀도(FP32), 반정밀도(FP16) 및 배정밀도(FP64) 부동소수점 연산 능력 사양 요약표입니다:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;그래픽 카드 모델&lt;/th&gt;
&lt;th&gt;출시 연도&lt;/th&gt;
&lt;th&gt;단정밀도 부동소수점 연산 능력 (TFLOPS)&lt;/th&gt;
&lt;th&gt;반정밀도 부동소수점 연산 능력 (TFLOPS)&lt;/th&gt;
&lt;th&gt;배정밀도 부동소수점 연산 능력 (TFLOPS)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GeForce GTX 970&lt;/td&gt;
&lt;td&gt;2014&lt;/td&gt;
&lt;td&gt;3.49&lt;/td&gt;
&lt;td&gt;87.2&lt;/td&gt;
&lt;td&gt;0.109&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3060 Ti&lt;/td&gt;
&lt;td&gt;2020&lt;/td&gt;
&lt;td&gt;16.2&lt;/td&gt;
&lt;td&gt;32.4&lt;/td&gt;
&lt;td&gt;0.51&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3060&lt;/td&gt;
&lt;td&gt;2021&lt;/td&gt;
&lt;td&gt;12.7&lt;/td&gt;
&lt;td&gt;25.4&lt;/td&gt;
&lt;td&gt;0.39&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3080&lt;/td&gt;
&lt;td&gt;2020&lt;/td&gt;
&lt;td&gt;29.8&lt;/td&gt;
&lt;td&gt;58.9&lt;/td&gt;
&lt;td&gt;0.93&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3080 Ti&lt;/td&gt;
&lt;td&gt;2021&lt;/td&gt;
&lt;td&gt;34.8&lt;/td&gt;
&lt;td&gt;68.7&lt;/td&gt;
&lt;td&gt;1.36&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;발췌한, &lt;a class=&#34;link&#34; href=&#34;https://docs.google.com/spreadsheets/d/1Zlv4UFiciSgmJZncCujuXKHwc4BcxbjbSBg71-SdeNk/edit#gid=0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;다양한 그래픽 카드 성능 테스트 데이터&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;업데이트&#34;&gt;업데이트
&lt;/h2&gt;&lt;p&gt;반년 정도의 공백을 두고, 원래는 설치 단계를 다시 정리하고 더 많은 기초 개념을 설명하려고 했는데, 결과적으로 보니 일반인들이 AI 그림을 그리는 건 다들 제공하는 이미지 파라미터를 기반으로 파라미터를 조정하거나, 이미 있는 이미지를 바탕으로 형식화된 재렌더링을 하는 것이더라고요&lt;/p&gt;
&lt;p&gt;중간에 프로젝트가 있었는데, AI를 이용해서 앱 UI 소재를 그려보려고 했더니, 반나절을 끙끙거려도 결과는 만족스럽지 않았어. 그냥 공식 앱에서 리소스를 가져오는 그림이 더 나은 것 같아.&lt;/p&gt;</description>
        </item>
        <item>
        <title>프로그램 최적화는 하드웨어에 맞서려 해서는 안 됩니다</title>
        <link>https://ttf248.life/ko/p/program-optimization-dont-fight-hardware/</link>
        <pubDate>Fri, 07 Apr 2023 16:30:15 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/program-optimization-dont-fight-hardware/</guid>
        <description>&lt;p&gt;하나의 루프 스레드인데, 소요 시간은 이미 &lt;strong&gt;마이크로초&lt;/strong&gt; 수준이며, 서버를 교체했더니 최대 6만 개의 데이터 패킷이 쌓이는 것에서 거의 쌓이지 않는 상태로 바뀌었습니다&lt;/p&gt;
&lt;p&gt;단일 스레드 루프 처리 시나리오에서 CPU 성능은 클럭 속도, 캐시 크기, 명령어 집합 아키텍처 등의 요인에 따라 달라집니다. 일반적으로 클럭 속도가 높고, 캐시가 크며, 명령어 집합 아키텍처가 더 발전된 CPU일수록 단일 스레드 데이터 처리 성능이 좋습니다.&lt;/p&gt;
&lt;h2 id=&#34;단일-스레드&#34;&gt;단일 스레드
&lt;/h2&gt;&lt;p&gt;성능 향상을 위해 스레드를 늘리는 것은 필수가 아니며, 프로젝트 흐름을 정리하고 병목 지점을 파악해야 합니다. 단일 스레드가 요구사항을 충족하는지 확인하고, 단일 스레드는 고려할 사항이 적고 문제 발생 가능성도 낮습니다.&lt;/p&gt;
&lt;p&gt;上来就说增加线程，이것 좀 이상하다&lt;/p&gt;
&lt;h2 id=&#34;사건&#34;&gt;사건
&lt;/h2&gt;&lt;p&gt;처리하는 것은 모두 &lt;strong&gt;시장 데이터이고, 지연에 민감하다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;吭哧吭哧加班一晚上，发布新的优化版本，本地剥离接口进行测试，速度也还行，tps：4.2万 낑낑대며 야근 한 밤새고, 새로운 최적화 버전 배포하고, 로컬에서 인터페이스 분리해서 테스트했는데, 속도도 괜찮고, TPS: 4만 2천&lt;/p&gt;
&lt;p&gt;서버에 배포하니 TPS가 급격히 떨어졌는데: 21,000. 집에 와서 데스크탑에서 시도해보니 TPS는 79,000이었다. 내부 서비스 가상화 환경에 문제가 있는 것 같기 시작했다. 우선 CPU 주파수가 원인이라고 의심했는데, 가정용 데스크탑과 서버의 CPU 차이점은 바로 주파수였다.&lt;/p&gt;
&lt;p&gt;테스트 서버 A&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;processor	: 7
vendor_id	: GenuineIntel
cpu family	: 6
model		: 47
model name	: Intel(R) Xeon(R) CPU E7- 4807  @ 1.87GHz
stepping	: 2
microcode	: 0x34
cpu MHz		: 1866.733
cache size	: 18432 KB
physical id	: 1
siblings	: 4
core id		: 3
cpu cores	: 4
apicid		: 7
initial apicid	: 7
fpu		: yes
fpu_exception	: yes
cpuid level	: 11
wp		: yes
flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss ht syscall nx rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc cpuid aperfmperf pni pclmulqdq ssse3 cx16 sse4_1 sse4_2 popcnt aes hypervisor lahf_lm pti dtherm arat
bugs		: clflush_monitor cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit
bogomips	: 3733.46
clflush size	: 64
cache_alignment	: 64
address sizes	: 40 bits physical, 48 bits virtual
power management:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;테스트 서버 B&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;processor	: 7
vendor_id	: GenuineIntel
cpu family	: 6
model		: 63
model name	: Intel(R) Xeon(R) CPU E5-2640 v3 @ 2.60GHz
stepping	: 2
microcode	: 0x3c
cpu MHz		: 2599.998
cache size	: 20480 KB
physical id	: 14
siblings	: 1
core id		: 0
cpu cores	: 1
apicid		: 14
initial apicid	: 14
fpu		: yes
fpu_exception	: yes
cpuid level	: 15
wp		: yes
flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc cpuid aperfmperf pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand hypervisor lahf_lm cpuid_fault epb pti fsgsbase smep xsaveopt cqm_llc cqm_occup_llc dtherm ida arat pln pts
bugs		: cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit
bogomips	: 5199.99
clflush size	: 64
cache_alignment	: 64
address sizes	: 40 bits physical, 48 bits virtual
power management:
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;openai에-문의하세요&#34;&gt;OpenAI에 문의하세요
&lt;/h2&gt;&lt;p&gt;먼저 코어 수와 클럭 속도 측면에서 Intel(R) Xeon(R) CPU E7- 4807 @ 1.87GHz는 6개의 물리적 코어와 12개의 논리적 코어를 가지고 있으며, 클럭 속도는 1.87GHz입니다. 반면에 Intel(R) Xeon(R) CPU E5-2640 v3 @ 2.60GHz는 8개의 물리적 코어와 16개의 논리적 코어를 가지고 있으며, 클럭 속도는 2.60GHz입니다. 따라서 코어 수와 클럭 속도 측면에서 볼 때, E5-2640 v3가 단일 스레드 처리 시 E7- 4807보다 더 유리해야 합니다.&lt;/p&gt;
&lt;p&gt;다음으로 캐시 크기 측면에서 E7-4807은 12MB의 캐시 크기를 가지고 있는 반면, E5-2640 v3는 20MB의 캐시 크기를 가지고 있습니다. 따라서 E5-2640 v3는 더 큰 캐시 공간을 제공하여 데이터 접근 속도와 캐시 히트율을 향상시킬 수 있습니다.&lt;/p&gt;
&lt;p&gt;마지막으로 아키텍처 측면에서 E5-2640 v3는 더 발전된 Haswell 아키텍처를 채택한 반면, E7-4807은 구형 Nehalem 아키텍처를 사용합니다. Haswell 아키텍처는 Nehalem 아키텍처에 비해 성능이 향상되었으며, 이는 E5-2640 v3의 단일 스레드 데이터 처리 성능 향상에 영향을 미칠 수 있습니다.&lt;/p&gt;
&lt;p&gt;따라서, 종합적으로 고려했을 때 단일 스레드 루프 처리 시나리오에서는 E5-2640 v3가 E7-4807보다 더 나은 성능을 보여줄 것으로 예상됩니다. 하지만 구체적인 성능 차이는 데이터 처리 알고리즘, 메모리 대역폭, 시스템 부하 등 다양한 요인의 영향을 받으므로, 개별 문제에 따라 분석해야 합니다.&lt;/p&gt;
&lt;h2 id=&#34;하드웨어-자료&#34;&gt;하드웨어 자료
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cpubenchmark.net/compare/3786.2vs2365.2/%5BDual-CPU%5D-Intel-Xeon-E7%e2%80%934807-vs-%5BDual-CPU%5D-Intel-Xeon-E5-2640-v3&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cpubenchmark.net/compare/3786.2vs2365.2/%5BDual-CPU%5D-Intel-Xeon-E7–4807-vs-%5BDual-CPU%5D-Intel-Xeon-E5-2640-v3&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Specification&lt;/th&gt;
&lt;th&gt;Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Price&lt;/td&gt;
&lt;td&gt;Search Online  $78 - BUY&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Socket Type&lt;/td&gt;
&lt;td&gt;LGA1567&lt;/td&gt;
&lt;td&gt;LGA2011-v3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU Class&lt;/td&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Clockspeed&lt;/td&gt;
&lt;td&gt;1.9 GHz&lt;/td&gt;
&lt;td&gt;2.6 GHz&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Turbo Speed&lt;/td&gt;
&lt;td&gt;Not Supported&lt;/td&gt;
&lt;td&gt;Up to 3.4 GHz&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;# of Physical Cores&lt;/td&gt;
&lt;td&gt;6 (Threads: 12)&lt;/td&gt;
&lt;td&gt;8 (Threads: 16)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Cache&lt;/td&gt;
&lt;td&gt;NA2&lt;/td&gt;
&lt;td&gt;NA2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Max TDP&lt;/td&gt;
&lt;td&gt;95W x 2&lt;/td&gt;
&lt;td&gt;90W x 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Yearly Running Cost&lt;/td&gt;
&lt;td&gt;$34.68&lt;/td&gt;
&lt;td&gt;$32.85&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Other&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;First Seen on Chart&lt;/td&gt;
&lt;td&gt;Q3 2020&lt;/td&gt;
&lt;td&gt;Q3 2014&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;# of Samples&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;46&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU Value&lt;/td&gt;
&lt;td&gt;69.1&lt;/td&gt;
&lt;td&gt;225.6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Single Thread Rating&lt;/td&gt;
&lt;td&gt;721 (-59.2%)&lt;/td&gt;
&lt;td&gt;1767 (0.0%)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU Mark&lt;/td&gt;
&lt;td&gt;6223 (-64.6%)&lt;/td&gt;
&lt;td&gt;17600 (0.0%)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description>
        </item>
        <item>
        <title>프롬프트 엔지니어</title>
        <link>https://ttf248.life/ko/p/prompt-engineer/</link>
        <pubDate>Sun, 26 Mar 2023 20:46:53 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/prompt-engineer/</guid>
        <description>&lt;p&gt;과거 검색 엔진 사용법을 배우던 것처럼, 우리도 AI와 소통하는 방법, 즉 합리적이고 충분한 조건을 제시하여 필요한 답변을 효율적으로 얻는 방법을 배워야 합니다&lt;/p&gt;
&lt;p&gt;만약 다른 각도에서 생각해 보면, 현재의 AI는 기억력이 아주 좋은 어린이에 해당합니다. 그는 눈에 보이는 것을 모두 외울 수 있고, 베끼기 능력이 있습니다. 우리가 해야 할 일은 AI와 어떻게 정확하고 효과적으로 소통하며, 요구사항을 정밀하게 묘사하여 AI가 예상되는 결과를 생성하도록 돕는 것입니다.&lt;/p&gt;
&lt;h2 id=&#34;과학-대중화&#34;&gt;과학 대중화
&lt;/h2&gt;&lt;p&gt;AI라고 불리는, 정확히 말하면 &lt;code&gt;Generative Pre-Training&lt;/code&gt;은 직역하면 생성적 사전 훈련입니다. 이는 인터넷에서 사용 가능한 데이터로 학습된 텍스트 생성 심층 학습 모델이며, 질의 응답, 텍스트 요약 생성, 기계 번역, 분류, 코드 생성 및 대화형 AI와 같은 작업에 사용됩니다. 현재 GPT-1, GPT-2, GPT-3 및 GPT-4 등 다양한 버전의 모델이 있으며, 각 버전은 이전 버전에 비해 더 크고 강력합니다.&lt;/p&gt;
&lt;h2 id=&#34;정말-인공지능이-있을까&#34;&gt;정말 인공지능이 있을까
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;유사도가 충분히 높으면 정확도 또한 높아집니다&lt;/li&gt;
&lt;li&gt;기본적이고 반복적인 업무는 특정 훈련을 거치면 더 이상 인공의 개입이 필요하지 않다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;생성형 AI는 기존의 텍스트, 오디오, 이미지 등 데이터를 활용하여 새로운 콘텐츠를 생성하는 기술입니다. 텍스트 생성, 음성 합성, 이미지 생성, 대화 시스템 등 다양한 작업에 사용될 수 있습니다. 생성형 AI의 논리성은 학습 데이터와 모델 구조에 따라 달라집니다. 일반적으로 생성형 AI는 문법, 논리 및 상식에 어느 정도 따르지만 오류, 편향 또는 부정확한 내용을 포함할 수도 있습니다. 따라서 생성형 AI의 출력은 인간의 판단과 검증이 필요하며 맹목적으로 믿거나 사용할 수 없습니다.&lt;/p&gt;
&lt;h2 id=&#34;프롬프트-엔지니어&#34;&gt;프롬프트 엔지니어
&lt;/h2&gt;&lt;p&gt;시간의 흐름은 거슬러갈 수 없고, 사람은 변화하는 흐름에 적응해야 합니다. AI가 똑똑하지 않다고 생각할 수도 있고, 논리성이 없다고 생각할 수도 있습니다. 코드를 작성해도 제대로 작동하지 않는 경우가 많습니다.&lt;/p&gt;
&lt;p&gt;만약 다른 각도에서 생각해 보면, 현재의 AI는 기억력이 아주 좋은 어린이에 해당합니다. 그는 눈에 보이는 것을 모두 외울 수 있고, 베끼기 능력이 있습니다. 우리가 해야 할 일은 AI와 어떻게 정확하고 효과적으로 소통하며, 요구사항을 정밀하게 묘사하여 AI가 예상되는 결과를 생성하도록 돕는 것입니다.&lt;/p&gt;
&lt;h2 id=&#34;대화-모드&#34;&gt;대화 모드
&lt;/h2&gt;&lt;p&gt;2년 전 &lt;code&gt;Github Copilot&lt;/code&gt;이 출시되었을 때, 2년 후 &lt;code&gt;OpenAI&lt;/code&gt;가 갑자기 등장하여 인간의 인지 능력을 크게 확장시키는 대규모 언어 모델의 가능성을 보여줄 거라고는 아무도 예상하지 못했습니다&lt;/p&gt;
&lt;p&gt;주석 기반 프로그래밍과 대화 기반 프로그래밍은 상호 작용 방식이 완전히 다르며, 대화의 패턴은 초보 사용자에게 친숙한 경험을 제공합니다. 여기서 &lt;code&gt;NewBing&lt;/code&gt;이 각 질문마다 제시하는 후속 질문 제안을 언급하지 않을 수 없는데, 이는 마이크로소프트가 사용자를 유도하여 AI 지식 데이터베이스에서 더 많은 정보를 얻으려고 시도하고 있는 것입니다.&lt;/p&gt;
&lt;h2 id=&#34;예시로-말하자면&#34;&gt;예시로 말하자면
&lt;/h2&gt;&lt;p&gt;고속철도 여행 시간은 길고, 코딩이 좋은 선택이다. 데이터 사용량이 제한적인 상황에서 몇 장의 사진을 처리하고 이미지 자료를 얻었지만, 소프트웨어를 다운로드하여 사진을 처리하는 것은 조금 사치스럽고 네트워크 환경도 허락하지 않는다.&lt;/p&gt;
&lt;p&gt;요구 사항은 다음과 같습니다. 투명 배경이 있는 이미지 자료가 여러 벌 있는데, 이것들을 앱의 내비게이션 바에 사용하려고 합니다. 선택된 상태는 컬러로, 선택되지 않은 상태는 흑백으로 하고, 원본 이미지는 모두 컬러입니다. 따라서 사전 처리 작업이 필요합니다.&lt;/p&gt;
&lt;p&gt;폴더에서 모든 이미지를 읽어와서, 이미지를 흑백으로 변환하고 투명 배경을 유지하며, 이미지 저장 시 품질을 최적화하여 파일 크기를 줄이고, 콘솔에 최적화 전후 파일 크기 비교를 표시하는 파이썬 코드를 작성하세요&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 导入必要的库
import os
import PIL
from PIL import Image

# 定义一个函数，将图片转换成黑白，维持透明背景，保存图片，并返回文件体积
def convert_and_save(image_file):
    # 打开图片
    image = Image.open(image_file)
    # 获取图片的模式，如果是 RGBA 模式，说明有透明背景
    mode = image.mode
    if mode == &amp;quot;RGBA&amp;quot;:
        # 创建一个和图片大小一致的白色背景图片
        background = Image.new(&amp;quot;RGB&amp;quot;, image.size, (255, 255, 255))
        # 将原图片粘贴到白色背景上，忽略透明像素
        background.paste(image, mask=image.split()[3])
        # 将合成的图片转换成灰度模式
        gray_image = background.convert(&amp;quot;L&amp;quot;)
        # 将灰度图片再转换成 RGBA 模式，以便保留透明背景
        final_image = gray_image.convert(&amp;quot;RGBA&amp;quot;)
    else:
        # 如果不是 RGBA 模式，直接将图片转换成灰度模式
        final_image = image.convert(&amp;quot;L&amp;quot;)
    # 获取原图片的文件名和扩展名
    file_name, file_ext = os.path.splitext(image_file)
    # 定义新图片的文件名，添加 _bw 后缀表示黑白
    new_file_name = file_name + &amp;quot;_bw&amp;quot; + file_ext
    # 保存新图片，并优化质量，减少文件体积
    final_image.save(new_file_name, optimize=True)
    # 获取原图片和新图片的文件体积，并返回
    old_size = os.path.getsize(image_file)
    new_size = os.path.getsize(new_file_name)
    return old_size, new_size

# 定义一个文件夹路径，存放所有的图片
folder_path = &amp;quot;images&amp;quot;
# 遍历文件夹中的所有文件
for file in os.listdir(folder_path):
    # 拼接完整的文件路径
    file_path = os.path.join(folder_path, file)
    # 判断是否是图片文件，根据扩展名判断，可以根据需要添加或修改扩展名
    if file_path.endswith((&amp;quot;.png&amp;quot;, &amp;quot;.jpg&amp;quot;, &amp;quot;.jpeg&amp;quot;, &amp;quot;.gif&amp;quot;)):
        # 调用函数，转换并保存图片，并获取文件体积
        old_size, new_size = convert_and_save(file_path)
        # 在控制台展示优化前后的文件体积大小对比
        print(f&amp;quot;{file}: {old_size} bytes -&amp;gt; {new_size} bytes&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;AI가 빠르게 답을 내놓았는데, 보기에 좋고 사용하기에도 괜찮은데, 경험이 많은 프로그래머라면 아래 코드가 충분히 일반적이지 않다고 느낄 것이고, 생산 환경에 적용하기도 어렵다고 생각할 것입니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;매개변수가 고정되었습니다&lt;/li&gt;
&lt;li&gt;로그 파일이 없고, 정보는 모두 콘솔에 출력됩니다&lt;/li&gt;
&lt;li&gt;이미지 처리는 다중 스레드 모델에 적합합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;뉴빙이 등장하여 프롬프트에 따라 질문을 선택했습니다: &lt;strong&gt;이 코드의 개선할 부분이 있나요?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;제공된 답변은 솔직히 기대 이상이었고, 일반 프로그래머가 생각할 수 있는 최적화 방안에 대해 AI가 해당하는 제안을 제시했습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;这段代码可能还有一些可以改进的地方，比如：

可以使用 argparse 库，让用户可以通过命令行参数指定文件夹路径和扩展名，而不是写死在代码里。
可以使用 logging 库，记录程序的运行情况，而不是直接打印到控制台。
可以使用 try-except 语句，捕获可能出现的异常，比如文件打开失败，图片转换失败等，并做相应的处理。
可以使用 multiprocessing 库，利用多核处理器，加速图片的转换和保存过程。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;매우 친절한 응답입니다. 배포 환경의 차이를 고려하여 다중 프로세스를 지원하지 않아도 괜찮습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;当然，我很乐意帮你修改一下代码。我尝试添加了 argparse, logging 和 try-except 语句，但没有添加 multiprocessing 库，因为我不确定你的电脑是否支持多核处理。修改后的代码如下：
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 导入必要的库
import argparse
import logging
import multiprocessing
import os

from PIL import Image


# 定义一个函数，将图片转换成黑白，维持透明背景，保存图片，并返回文件体积
def convert_and_save(image_file):
    # 打开图片
    try:
        image = Image.open(image_file)
    except Exception as e:
        logging.error(f&amp;quot;Failed to open {image_file}: {e}&amp;quot;)
        return None, None
    # 获取图片的模式，如果是 RGBA 模式，说明有透明背景
    mode = image.mode
    if mode == &amp;quot;RGBA&amp;quot;:
        # 创建一个和图片大小一致的白色背景图片
        background = Image.new(&amp;quot;RGB&amp;quot;, image.size, (255, 255, 255))
        # 将原图片粘贴到白色背景上，忽略透明像素
        background.paste(image, mask=image.split()[3])
        # 将合成的图片转换成灰度模式
        gray_image = background.convert(&amp;quot;L&amp;quot;)
        # 将灰度图片再转换成 RGBA 模式，以便保留透明背景
        final_image = gray_image.convert(&amp;quot;RGBA&amp;quot;)
    else:
        # 如果不是 RGBA 模式，直接将图片转换成灰度模式
        final_image = image.convert(&amp;quot;L&amp;quot;)
    # 获取原图片的文件名和扩展名
    file_name, file_ext = os.path.splitext(image_file)
    # 定义新图片的文件名，添加 _bw 后缀表示黑白
    new_file_name = file_name + &amp;quot;_bw&amp;quot; + file_ext
    # 保存新图片，并优化质量，减少文件体积
    try:
        final_image.save(new_file_name, optimize=True)
    except Exception as e:
        logging.error(f&amp;quot;Failed to save {new_file_name}: {e}&amp;quot;)
        return None, None
    # 获取原图片和新图片的文件体积，并返回
    old_size = os.path.getsize(image_file)
    new_size = os.path.getsize(new_file_name)
    return file_name, old_size, new_size

# 定义一个函数，解析命令行参数，并返回文件夹路径和扩展名列表
def parse_args():
    # 创建一个解析器对象
    parser = argparse.ArgumentParser(description=&amp;quot;Convert images to black and white and optimize quality.&amp;quot;)
    # 添加一个必选的位置参数，表示文件夹路径
    parser.add_argument(&amp;quot;folder_path&amp;quot;, help=&amp;quot;The path of the folder that contains the images.&amp;quot;)
    # 添加一个可选的参数，表示扩展名列表，默认为 png, jpg, jpeg 和 gif
    parser.add_argument(&amp;quot;-e&amp;quot;, &amp;quot;--extensions&amp;quot;, nargs=&amp;quot;+&amp;quot;, default=[&amp;quot;.png&amp;quot;, &amp;quot;.jpg&amp;quot;, &amp;quot;.jpeg&amp;quot;, &amp;quot;.gif&amp;quot;], help=&amp;quot;The extensions of the image files.&amp;quot;)
    # 解析命令行参数，并返回结果对象
    args = parser.parse_args()
    return args.folder_path, args.extensions

# 定义一个函数，打印优化前后的文件体积大小对比
def print_result(result):
    # 如果结果不为空，说明转换和保存成功
    if result:
        # 解包结果为文件名和文件体积元组
        if len(result) == 3:
            file, old_size, new_size = result
            # 在控制台展示优化前后的文件体积大小对比
            logging.info(f&amp;quot;{file}: {old_size} bytes -&amp;gt; {new_size} bytes&amp;quot;)
        else:
            logging.info(f&amp;quot;{result}&amp;quot;)

# 配置日志记录器，将日志输出到控制台和文件中，设置日志等级为 INFO
logging.basicConfig(level=logging.INFO,
                    format=&amp;quot;%(asctime)s %(levelname)s %(message)s&amp;quot;,
                    handlers=[logging.StreamHandler(),
                              logging.FileHandler(&amp;quot;log.txt&amp;quot;)])

# 调用函数，获取文件夹路径和扩展名列表
folder_path, extensions = parse_args()

if __name__ == &amp;quot;__main__&amp;quot;:
    # Windows 需要这个函数的原因是 Windows 缺乏 fork() 函数（这不完全正确）。
    # 因此，在 Windows 上，fork() 是通过创建一个新的进程来模拟的，这个新的进程中运行的代码，在 Linux 上是在子进程中运行的。
    # 由于这些代码要在技术上无关的进程中运行，所以它必须在运行之前被传递到那里。
    # 传递的方式是先将它们序列化，然后通过管道从原始进程发送到新的进程。
    # 另外，这个新的进程被通知它必须运行通过管道传递的代码，通过向它传递 --multiprocessing-fork 命令行参数。
    # 如果你看一下 freeze_support() 函数的实现，它的任务是检查它运行在哪个进程中，是否应该运行通过管道传递的代码
    multiprocessing.freeze_support()

    # 创建一个进程池，根据电脑的核心数自动分配进程
    pool = multiprocessing.Pool()
    # 创建一个空列表，用于存放异步任务的结果对象
    results = []
    # 遍历文件夹中的所有文件
    for file in os.listdir(folder_path):
        # 拼接完整的文件路径
        file_path = os.path.join(folder_path, file)
        # 判断是否是图片文件，根据扩展名判断，可以根据需要修改扩展名列表
        if any(file_path.endswith(ext) for ext in extensions):
            # 调用函数，转换并保存图片，并获取文件体积，使用异步方式，不阻塞主进程
            result = pool.apply_async(convert_and_save, args=(file_path,), callback=print_result)
            # 将结果对象添加到列表中
            results.append((file, result))
    # 关闭进程池，不再接受新的任务
    pool.close()
    # 等待所有的任务完成
    pool.join()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;p&gt;로컬 개발 환경이 &lt;code&gt;windows&lt;/code&gt; 시스템이기 때문에, &lt;code&gt;AI&lt;/code&gt;가 처음 제시한 답변에는 &lt;code&gt;main&lt;/code&gt; 함수와 &lt;code&gt;multiprocessing.freeze_support&lt;/code&gt;가 포함되지 않았습니다. 질문을 통해 발생한 오류를 해결하여 코드를 수정했습니다.&lt;/p&gt;
&lt;p&gt;과거 검색 엔진 사용법을 배우던 것처럼, AI와 소통하는 방법도 배워야 합니다. 합리적이고 충분한 조건을 제시하여 필요한 답변을 효율적으로 얻어야 합니다.&lt;/p&gt;
&lt;p&gt;주의: &lt;strong&gt;만약 여러분이 프로그래밍 초보이고 주어진 주석을 바탕으로도 이해가 안 되는 부분이 있다면 관련 코드에 대해 계속 질문해도 좋습니다.&lt;/strong&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>위챗 미니 프로그램 배경 및 개발 환경</title>
        <link>https://ttf248.life/ko/p/wechat-mini-program-background-and-development-environment/</link>
        <pubDate>Fri, 24 Mar 2023 21:59:11 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/wechat-mini-program-background-and-development-environment/</guid>
        <description>&lt;p&gt;위챗 미니 프로그램 소개 및 개발 준비&lt;/p&gt;
&lt;h2 id=&#34;왜-소규모-프로그램이-있을까&#34;&gt;왜 소규모 프로그램이 있을까?
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;더 나은 경험: 내장된 웹 페이지 로딩이 느리고, 흰 화면이 나타납니다. 네이티브 앱의 경험은 더 빠른 로딩을 제공합니다.&lt;/li&gt;
&lt;li&gt;규범과 관리: 위챗의 경우, 접속 및 관리&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;小程序发布되기 전에, 微信은 &lt;code&gt;JSSDK&lt;/code&gt;라는 &lt;code&gt;SDK&lt;/code&gt;를 출시하여 微信의 원어민 기능인 微信支付, 카드券 기능을 개방했습니다. 하지만 개발자는 웹 페이지 개발 언어를 기반으로 개발하여 微信의 일부 규제를 우회할 수 있었습니다. 小程序은 자체적인 설명 언어를 가지고 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;무엇이-미니-프로그램인가&#34;&gt;무엇이 미니 프로그램인가?
&lt;/h2&gt;&lt;p&gt;미니 프로그램은 다운로드나 설치 없이 사용할 수 있는 애플리케이션으로, 앱을 손쉽게 이용할 수 있다는 꿈을 실현했습니다&lt;/p&gt;
&lt;p&gt;사용자가 스캔하거나 검색하기만 하면 앱을 열 수 있다는 점도 &lt;strong&gt;쓰고 버리는&lt;/strong&gt; 개념을 반영합니다&lt;/p&gt;
&lt;p&gt;사용자는 너무 많은 앱을 설치했는지 여부에 대해 걱정할 필요가 없습니다. 앱은 어디에나 존재하고 언제든지 사용할 수 있지만, &lt;strong&gt;설치하거나 제거할 필요는 없습니다&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&#34;미니-프로그램과-모바일-앱의-차이점&#34;&gt;미니 프로그램과 모바일 앱의 차이점
&lt;/h2&gt;&lt;p&gt;설치 불필요, 메모리 차지 없음, 간편한 전파: QR 코드, 미니 프로그램 카드, 검색&lt;/p&gt;
&lt;h2 id=&#34;小程序로-무엇을-할-수-있나요&#34;&gt;小程序로 무엇을 할 수 있나요
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;콘텐츠 도구: 지식, 웨이보 인기 게시물, 모바이크 자전거, 오늘날부 터, 텐센트 지도, 텐센트 번역&lt;/li&gt;
&lt;li&gt;소매: 핀두어두오, 징둥쇼핑, 무궁가게, 메이리우션, 샤오미몰, 퀴청스&lt;/li&gt;
&lt;li&gt;게임: 쩜프쩜프, 즐거운 땅따먹기, 즐거운 마작, 도유 라이브, YY 라이브&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;강의 내용은 2018년 것이고, 지금은 일부 애플리케이션 공급업체가 이미 문을 닫았습니다&lt;/p&gt;
&lt;h2 id=&#34;개발-준비&#34;&gt;개발 준비
&lt;/h2&gt;&lt;p&gt;소규모 프로그램 계정 등록: 일반적인 정보 입력으로 등록 가능하며, 이메일로 활성화 링크를 클릭하세요
정보 등록
3. 소규모 프로그램 관리 백오피스에 로그인하세요.
미니 프로그램 정보 보완
개인 개발자는 로그인한 위챗 계정이 관리자 계정으로, 별도의 바인딩 작업이 필요 없습니다&lt;/p&gt;
&lt;p&gt;이메일 계정에는 제한이 있어 새로운 이메일 주소가 필요하지만, QQ 메일은 별칭을 신청할 수 있고 微信 백엔드에서는 이를 검증하지 않습니다. 시도해 본 결과, 소규모 프로그램 이름이 다소 까다롭지만 상표가 관련된 경우 쉽게 승인에 실패합니다.&lt;/p&gt;
&lt;p&gt;서비스 카테고리를 선택할 수도 있고, 직접 추가할 수도 있습니다. 하나의 소규모 프로그램은 다섯 개의 카테고리를 추가할 수 있습니다.&lt;/p&gt;
&lt;p&gt;설정 안에서 소규모 프로그램의 &lt;code&gt;ID&lt;/code&gt; 정보를 확인할 수 있을 뿐만 아니라 메시지 푸시도 활성화할 수 있습니다. 메시지 푸시를 활성화하면 메시지 템플릿 기능을 사용할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;개발자-도구필자의-경험담&#34;&gt;개발자 도구(필자의 경험담)
&lt;/h2&gt;&lt;p&gt;정상적으로 다운로드 및 설치하면 특별한 주의사항은 없고, 간단히 알아보고 바로 방문자 모드로 들어가면 됩니다. 휴대폰 디버깅을 활성화하여 소형 프로그램의 개발 버전을 보고 싶다면, 소형 프로그램 개발자 계정에 로그인한 후 설정에서 프로젝트 상세 정보 내에서 지정된 소형 프로그램 ID로 전환해야 합니다.&lt;/p&gt;
&lt;h2 id=&#34;코드-구조&#34;&gt;코드 구조
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;JS: 상호작용 로직&lt;/li&gt;
&lt;li&gt;JSON：데이터 설정&lt;/li&gt;
&lt;li&gt;인터페이스의 요소&lt;/li&gt;
&lt;li&gt;인터페이스 스타일&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>사무실 이전에 서버 접속이 안 됩니다</title>
        <link>https://ttf248.life/ko/p/office-migration-server-unavailable/</link>
        <pubDate>Sat, 11 Mar 2023 01:42:05 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/office-migration-server-unavailable/</guid>
        <description>&lt;p&gt;행정 공지, 사무실 위치 변경, 기존 2층에서 15층으로 이전, 평범한 자리 이동입니다&lt;/p&gt;
&lt;h2 id=&#34;디자인-감각&#34;&gt;디자인 감각
&lt;/h2&gt;&lt;p&gt;사무실 건물&lt;/p&gt;
&lt;h2 id=&#34;이주&#34;&gt;이주
&lt;/h2&gt;&lt;p&gt;퇴근하면서 짐을 정리하고, 익숙하게 자리를 옮겨 새로운 자리에서 컴퓨터 배선을 조정하니 편안한 자세로 일하기 딱 좋네요&lt;/p&gt;
&lt;p&gt;(ÒωÓױ)！ 인터넷 연결했는데, 팀에서 주로 사용하는 서버에 접속이 안 돼요. 무선 네트워크로 바꿔보니 다시 정상적으로 접속되네요.&lt;/p&gt;
&lt;p&gt;처음에는 서버 네트워크 세그먼트 설정 문제라고 생각했습니다. 새로운 작업 공간의 유선 네트워크는 방화벽 구성 목록에 없어서 IT 동료에게 연락해서 조정하면 될 거라고 생각했죠. 그런데 이 네트워크 세그먼트는 여러 대의 서버가 있는데, 다른 서버들에 접속해 보니 모두 정상이었고, 점차 의심이 들기 시작했습니다. 전문적인 일은 전문가에게 맡기는 것이 좋다고 생각하고, 결국 운영 부서 동료들이 문제 해결을 위해 조사한 결과, 해당 서버에 &lt;code&gt;docker&lt;/code&gt;가 배포되어 있어서 서비스의 기본 네트워크 &lt;code&gt;docker0&lt;/code&gt;와 사무실 유선 네트워크 구성 세그먼트 간 충돌이 발생하여 전송된 데이터 패킷이 응답을 받지 못하고 &lt;code&gt;docker&lt;/code&gt; 서비스로 라우팅되었다는 것을 확인했습니다.&lt;/p&gt;
&lt;p&gt;다른 서버에는 &lt;code&gt;docker&lt;/code&gt; 서비스가 배포되어 있지 않아서, 이 서버만 사용하고 있고 가끔 컨테이너로 테스트 서비스를 배포하곤 했는데, 이런 상황을 마주할 줄은 몰랐다. 나중에 생각해보니, 그룹 전체가 같은 사무실 건물에 있고 IT 부서 동료들이 네트워크 세그먼트를 분할하면서 &lt;code&gt;172&lt;/code&gt;로 시작하는 주소를 사용한 것은 이상한 일이 아니라고 생각했다.&lt;/p&gt;
&lt;h2 id=&#34;docker0&#34;&gt;docker0
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# vim /etc/docker/daemon.json
{
    &amp;quot;bip&amp;quot;:&amp;quot;172.200.0.1/24&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;서비스를 재시작하고 새로운 네트워크로 전환하면 서버가 정상적으로 접근 가능해집니다&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;p&gt;도커 입문부터 실전까지 - docker0&lt;/p&gt;</description>
        </item>
        <item>
        <title>임베디드 입문 1 - 전문 용어</title>
        <link>https://ttf248.life/ko/p/embedded-introduction-professional-terms/</link>
        <pubDate>Tue, 07 Mar 2023 13:42:36 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/embedded-introduction-professional-terms/</guid>
        <description>&lt;p&gt;임베디드 시스템을 얘기하면 아직도 학교 연구실의 51 단일칩 컴퓨터와 프리스케일을 떠올린다&lt;/p&gt;
&lt;p&gt;LPA3399Pro는 루신(Rockchip) RK3399Pro 플랫폼을 기반으로 개발된 비전 호스트로, 대규모 시각 연산이 필요한 휴대용 컴퓨팅 장치에 적합합니다. 내장 NPU 컴퓨팅 유닛을 통해 3.0TOPS의 연산 능력을 제공하며 다양한 알고리즘 모델을 지원합니다.&lt;/p&gt;
&lt;p&gt;RV1109은 딥알 AI 머신 비전 브랜치의 SoC인 루싱위(Realtek Vision)의 제품이며, 내장된 독립 NPU를 갖추고 있습니다. RV1109은 1 TOPS의 연산 능력을 제공할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;system-on-chip&#34;&gt;System on Chip
&lt;/h2&gt;&lt;p&gt;SoC는 System on a Chip의 약자로, “칩상 시스템”을 의미합니다. 이는 여러 전자 시스템을 하나의 칩에 통합하는 기술입니다. 이 기술은 전자 제품의 크기와 무게를 크게 줄이는 동시에 성능을 향상시키고 전력 소비를 낮출 수 있습니다.&lt;/p&gt;
&lt;p&gt;SoC(시스템 온 어 칩)와 CPU(중앙 처리 장치)는 모두 컴퓨터 시스템의 중요한 구성 요소이지만, 이 둘 사이에는 몇 가지 차이가 있습니다&lt;/p&gt;
&lt;p&gt;CPU는 컴퓨터 시스템에서 핵심적인 프로세서로서 프로그램 명령어를 실행하는 역할을 담당합니다. 일반적으로 연산 장치, 제어 장치 및 레지스터와 같은 기본 부품으로만 구성됩니다.&lt;/p&gt;
&lt;p&gt;SoC는 여러 전자 시스템을 하나의 칩에 통합한 것으로, CPU 외에도 메모리, 그래픽 프로세서, 입출력 인터페이스 등 다른 구성 요소를 포함할 수 있습니다. 이를 통해 전자 제품의 크기와 무게를 크게 줄이고 성능을 향상시키면서 전력 소비를 낮출 수 있습니다.&lt;/p&gt;
&lt;p&gt;전반적으로, CPU는 SoC의 구성 요소이며, SoC는 더욱 복잡하고 통합된 전자 시스템입니다&lt;/p&gt;
&lt;h2 id=&#34;microcontroller-unit&#34;&gt;Microcontroller Unit
&lt;/h2&gt;&lt;p&gt;SoC(시스템 온 칩)와 MCU(마이크로컨트롤러 유닛)는 여러 전자 시스템을 하나의 칩에 통합하는 기술이지만, 이들 사이에는 몇 가지 차이점이 있습니다&lt;/p&gt;
&lt;p&gt;MCU는 일반적으로 CPU, 메모리, 입출력 인터페이스와 같은 기본 부품을 포함하는 마이크로컨트롤러입니다. 이는 가전제품, 자동차 전자 시스템과 같이 다른 전자 장치를 제어하는 데 자주 사용됩니다.&lt;/p&gt;
&lt;p&gt;SoC는 더 많은 전자 시스템을 하나의 칩에 통합하는 것으로, MCU의 기본 구성 요소를 포함하는 것 외에도 그래픽 프로세서, 무선 통신 모듈과 같은 다른 구성 요소도 통합할 수 있습니다. 이를 통해 전자 제품의 크기와 무게를 크게 줄이는 동시에 성능을 향상시키고 전력 소비를 낮출 수 있습니다.&lt;/p&gt;
&lt;p&gt;결론적으로, MCU는 간단한 마이크로컨트롤러이고, SoC는 더욱 복잡하고 통합된 전자 시스템입니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>AI 지원 프로그래밍, 생산성 진화</title>
        <link>https://ttf248.life/ko/p/ai-assisted-programming-productivity-evolution/</link>
        <pubDate>Tue, 28 Feb 2023 17:05:17 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/ai-assisted-programming-productivity-evolution/</guid>
        <description>&lt;p&gt;깃허브 코파일럿이 출시된 지 2년도 채 되지 않았는데, 챗GPT가 등장했네요. 작동 원리는 잘 모르겠지만, 둘 다 한동안 사용하고 있습니다. 두 도구는 보조 기능에서 완전히 다르지만, 생산성 향상에 큰 도움이 됩니다.&lt;/p&gt;
&lt;p&gt;너무 복잡한 일은 아직 AI가 해내지 못합니다. 결국 그들은 논리가 없고, 패턴이 있거나 패러다임이 고정된 일은 훈련 데이터가 충분하면 AI의 효과는 90%까지 도달할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;github-copilot&#34;&gt;github copilot
&lt;/h2&gt;&lt;p&gt;발표할 때, 공식 홈페이지의 소개 &lt;code&gt;demo&lt;/code&gt;를 보고 보니까 그렇게 똑똑해 보이지 않았고, 사용해 봤는데 잘 안 돼서 포기했다&lt;/p&gt;
&lt;p&gt;2022년 이전에는, 시간 날 때마다 새로운 버전으로 바꿔서 사용해 보는데, 효과는 꽤 괜찮은 편이야. 다만 국내 속도가 좀 느린 것 같아. 네트워크 문제일 확률이 높지. &lt;code&gt;Python&lt;/code&gt; 같은 언어는 주석을 보고 코드를 짜면, 제가 자료를 찾아 직접 작성하는 것보다 훨씬 빠르더라고요.&lt;/p&gt;
&lt;h2 id=&#34;chatgpt&#34;&gt;ChatGPT
&lt;/h2&gt;&lt;p&gt;깃허브 코파일럿은 아직 프로그래머, 즉 개발의 관점에서 제품을 설계하고 있으며, 프로그래밍 방법을 이해해야 하고, 점차 주석을 통해 AI를 보조 프로그래밍하도록 유도해야 합니다&lt;/p&gt;
&lt;p&gt;ChatGPT가 다음 단계로 진화하여 &lt;strong&gt;전문가가 아닌 일반인도 빠르게 익힐 수 있게 되었습니다&lt;/strong&gt;. 대화형 챗 인터페이스 덕분에 질문하고, 요구사항을 설명하며, 이해가 안 되는 부분은 계속해서 질문할 수 있습니다.&lt;/p&gt;
&lt;p&gt;간단한 예시로, 토큰화 개념은 알지만 코딩하는 방법은 모르고 문자열의 유사도를 계산하고 싶습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Python 分词计算 維天運通 LOGORY 和 合肥維天運通信息科技股份有限公司 两个字符串的相似度；
比较前，统一处理字符串，英文转换为小写；
第二个字符中如果能找到第一个字符的首字符，将第二个字符串截位，截位的长度为第一个字符串的长度
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;안녕하세요, 빙입니다. 😊&lt;/p&gt;
&lt;p&gt;온라인 정보에 따르면 123, Python 토큰화 계산은 jieba 라이브러리를 사용하여 구현할 수 있습니다. jieba 라이브러리는 정확 모드, 전체 모드 및 검색 엔진 모드의 세 가지 토큰화 모드를 지원합니다. 필요에 따라 적절한 모드를 선택할 수 있습니다.&lt;/p&gt;
&lt;p&gt;두 문자열의 유사도를 비교하려면 먼저 토큰화한 다음 단어 벡터 또는 편집 거리와 같은 지표를 계산해야 합니다. 수학 연산에는 numpy나 scipy 등의 라이브러리를 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;문자열을 일관되게 처리하기 위해 영문자를 소문자로 변환하려면 Python의 내장 함수 lower()를 사용할 수 있습니다&lt;/p&gt;
&lt;p&gt;두 번째 문자열을 추출하려면 Python의 슬라이스 연산자 []를 사용할 수 있습니다&lt;/p&gt;
&lt;p&gt;다음은 가능한 코드 예제입니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import jieba
import numpy as np
from scipy.spatial.distance import cosine

# 定义两个字符串
str1 = &amp;quot;維天運通 LOGORY&amp;quot;
str2 = &amp;quot;合肥維天運通信息科技股份有限公司&amp;quot;

# 统一处理字符串，英文转换为小写
str1 = str1.lower()
str2 = str2.lower()

# 找到第二个字符串中第一个字符的位置
index = str2.find(str1[0])

# 如果找到了，截取第二个字符串
if index != -1:
    str2 = str2[index:index+len(str1)]

# 使用 jieba 库进行分词
words1 = list(jieba.cut(str1))
words2 = list(jieba.cut(str2))

# 计算两个字符串的词向量（以词频作为权重）
vector1 = np.zeros(len(words1))
vector2 = np.zeros(len(words1))

for i, word in enumerate(words1):
    vector1[i] += 1 # 统计第一个字符串中每个词出现的次数
    if word in words2:
        vector2[i] += 1 # 统计第二个字符串中每个词出现的次数

# 计算两个字符串的相似度（以余弦距离作为指标）
similarity = 1 - cosine(vector1, vector2)

print(&amp;quot;两个字符串的相似度是：&amp;quot;, similarity)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;더 나아가서, 실행 결과를 문의했더니, 당신을 축하하며 문제점을 발견했습니다. 결과는 날조된 것이고, 실제 코드를 실행하지 않고도 괜찮은 결과를 보여줍니다.&lt;/p&gt;
&lt;h3 id=&#34;밤&#34;&gt;밤
&lt;/h3&gt;&lt;p&gt;SQL 쿼리, 제품 코드 테이블에서 제품 코드가 80000부터 89999 사이인 레코드를 찾아주세요&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;你好，这是 Bing。😊

根据搜索结果12，你可以使用 SQL BETWEEN 运算符来选择给定区间内的值。BETWEEN 运算符包含了开始和结束的值。

你需要先指定要查询的表名和列名，然后在 WHERE 子句中使用 BETWEEN 运算符和区间值。

例如，如果你要查询产品代码表中，产品代码在 80000 到 89999 之间的记录，你可以使用以下语句：

SELECT * FROM product_code
WHERE code BETWEEN 80000 AND 89999;
这里，* 表示选择所有列3。如果你只想选择特定的列，比如产品名称和价格，你可以用逗号分隔它们，如下：

SELECT name, price FROM product_code
WHERE code BETWEEN 80000 AND 89999;
希望这能帮助到你。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;계속 질문하고 반박하세요: 제품 코드는 문자열인데, 당신의 코드가 잘못되었습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;抱歉，我没有注意到产品代码是字符串。如果是这样的话，你需要在区间值两边加上单引号，如下：

SELECT * FROM product_code
WHERE code BETWEEN &#39;80000&#39; AND &#39;89999&#39;;
请原谅我的错误。🙏
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;축하해요, 틀릴 거예요&lt;/p&gt;</description>
        </item>
        <item>
        <title>자주 사용하지 않는 몇 가지 GIT 명령어 모음</title>
        <link>https://ttf248.life/ko/p/git-less-common-commands-summary/</link>
        <pubDate>Fri, 17 Feb 2023 10:08:57 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/git-less-common-commands-summary/</guid>
        <description>&lt;p&gt;자주 사용하지는 않지만 매우 유용한 &lt;code&gt;git&lt;/code&gt; 명령어&lt;/p&gt;
&lt;h3 id=&#34;시스템-재설치로-인해-windows-상의-폴더-소유자-정보가-변경되었습니다&#34;&gt;시스템 재설치로 인해 &lt;code&gt;windows&lt;/code&gt; 상의 폴더 소유자 정보가 변경되었습니다
&lt;/h3&gt;&lt;p&gt;새 버전의 &lt;code&gt;git&lt;/code&gt;에서 보안 검증이 추가되어 안전하지 않다는 경고가 발생하여 더 이상 작업을 진행할 수 없습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global --add safe.directory
git config --global --add safe.directory &amp;quot;*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;새-컴퓨터에-계정-비밀번호-정보를-저장합니다&#34;&gt;새 컴퓨터에 계정 비밀번호 정보를 저장합니다
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global credential.helper store
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;정보를 업데이트하려면 먼저 기존 증거를 정리하세요&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --system --unset credential.helper
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>홍콩 달러, 위안화 이중 카운터 방식</title>
        <link>https://ttf248.life/ko/p/hk-rmb-dual-counter-mode/</link>
        <pubDate>Thu, 16 Feb 2023 20:25:47 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/hk-rmb-dual-counter-mode/</guid>
        <description>&lt;p&gt;홍콩증권거래소는 12월 13일, 자회사 증권시장이 “홍콩달러-위안화 이중 카운터 모델”(이하 “이중 카운터 모델”) 및 이중 카운터 주식 중개인 제도를 곧 출시할 것이라고 발표하며, 홍콩에서 위안화 거래소의 상장, 거래 및 결제를 더욱 지원하게 된다&lt;/p&gt;
&lt;h2 id=&#34;양측-카운터-모드-및-양측-카운터-딜러-메커니즘&#34;&gt;양측 카운터 모드 및 양측 카운터 딜러 메커니즘
&lt;/h2&gt;&lt;p&gt;홍콩증권거래소는 규제 기관의 승인과 시장 준비가 완료되면 2023년 상반기부터 새로운 조치들의 등록 절차를 시행할 것으로 예상된다고 밝혔다. 이중 거래 모델 하에서 홍콩증권거래소는 관련 거래 및 결제 방식을 최적화하여 투자자들이 동일 발행인의 홍콩달러 계좌와 위안화 계좌 증권을 서로 교환할 수 있도록 할 예정이다.&lt;/p&gt;
&lt;p&gt;홍콩증권거래소는 위안화 카운터의 유동성을 높이고 두 카운터 간의 스프레드를 좁히기 위해 이중 카운터 마켓 메이커 제도를 도입할 예정이며, 관련 법률이 입법회에서 통과되면 특정 거래 시 증지세 면제를 받을 수 있도록 주식 유동성 공급 활동을 수행하는 시장 조성자에게 허용될 것입니다. 동시에 이러한 새로운 조치들은 또한 향후 중국 본토 투자자들이 홍콩 주식통합을 통해 위안화로 가격이 책정된 증권을 거래할 수 있도록 사전 준비 작업을 할 것입니다.&lt;/p&gt;
&lt;p&gt;홍콩달러-위안화 이중 카운터 모델 및 이중 카운터 딜러 메커니즘을 도입하는 것은 우리 시장 발전을 위한 중요한 조치입니다. 다른 시장 조치와 함께 이러한 배치는 더 많은 이중 카운터 증권을 홍콩에 상장하도록 유도하고, 홍콩증권거래소의 기존 중국 본토 제품과 시너지 효과를 낼 것입니다. 홍콩증권거래소 최고 운영 책임자 겸 시장 공동 책임자인 요시아킨은 “홍콩증권거래소는 적극적으로 위안화 국제화를 추진하고 홍콩을 세계적인 선도 오프쇼어 위안화 허브로서의 지위를 지속적으로 향상시키는 데 전념하고 있습니다.”라고 말했습니다.&lt;/p&gt;
&lt;p&gt;알려진 바에 따르면, 홍콩 주식 시장의 현행 상장, 거래, 결제 및 대금결제 절차는 이중 카운터 모델 하의 위안화 카운터 증권에도 대체로 적용될 예정이다. 홍콩증권거래소는 이중 카운터 모델 시행일과 지정 투자자 메커니즘에 포함될 자격 있는 이중 카운터 증권 명단을 적시에 발표할 것이다.&lt;/p&gt;
&lt;h2 id=&#34;홍콩-달러-위안화-거래-카운터를-어떻게-식별할-수-있습니까&#34;&gt;홍콩 달러-위안화 거래 카운터를 어떻게 식별할 수 있습니까?
&lt;/h2&gt;&lt;p&gt;홍콩증권거래소 자료에 따르면 홍콩달러-위안화 이중 카운터 거래 방식은 기존 주식 코드 배분 계획을 대체로 따를 예정인데, 홍콩달러 카운터의 주식 코드는 “0”으로 시작하는 5자리 숫자이고, 위안화 카운터의 주식 코드는 “8”로 시작하는 5자리 숫자입니다. 홍콩달러 및 위안화 카운터 주식 코드의 마지막 네 자리 숫자는 동일합니다. 위안화 카운터의 주식 약칭에는“-R”이 붙습니다.&lt;/p&gt;
&lt;p&gt;거래 정산과 관련하여, 위안화 및 홍콩달러 카운터의 증권이 동일한 범주이며 서로 교환 가능하다는 전제하에, 만약 한 카운터(예: 홍콩달러 카운터)가 공매도 지정 증권으로 지정되어 있다면, 다른 카운터(예: 위안화 카운터) 역시 거래소 규정에 따라 공매도 지정 증권으로 포함될 수 있으며, 이에 따라 두 카운터 모두 거래소가 발표하는 공매도 지정 증권 명단에 올라갈 것입니다&lt;/p&gt;
&lt;p&gt;두 거래소의 주식이 동일한 범주에 속하고 서로 교환 가능하며, 홍콩 달러로 구매하여 주식을 보유하다가 위안화로 매도하거나, 반대로 위안화로 판매했다가 홍콩 달러로 매수하는 행위 모두 지물매도로 간주됩니다. 두 거래소 간의 결제 기간은 T+2입니다.&lt;/p&gt;
&lt;p&gt;공매도 자격이 있는 특정 주식의 경우, 예를 들어 홍콩 달러로 빌린 주식을 대만 위안화 카운터에서 매도하는 것은 담보 공매도로 간주되며, 그 반대의 경우도 마찬가지입니다&lt;/p&gt;
&lt;p&gt;쌍점 계좌 모드에서 위안화 카운터는 거래 및 결제 용도로만 사용되므로 실물 주식의 입금 또는 출금 서비스는 제공되지 않습니다. 실물 주식은 홍콩 달러 카운터에 먼저 입금한 후 위안화 카운터로 전환해야 합니다. 마찬가지로, 위안화 카운터에서 실물 주식을 인출하려면 홍콩 달러 카운터로 전환해야 합니다.&lt;/p&gt;
&lt;p&gt;관련 거래 결제 및 이행 수수료는 모든 홍콩 청산 수수료가 홍콩 달러로 계산되고 징수됩니다. 배당 대행 수수료 및 이자 대행 수수료만 관련 증권에 사용되는 자격 있는 통화로 계산됩니다.&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.hkex.com.hk/Services/Trading/Securities/Overview/Trading-Mechanism/HKD-RMB-Dual-Counter-Model?sc_lang=en&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;HKD-RMB-Dual-Counter-Model&lt;/a&gt;
출처: 홍콩거래소 펄스/HKEx Pulse, 증권중국&lt;/p&gt;</description>
        </item>
        <item>
        <title>컴파일러, 콜백 함수, 성능 테스트</title>
        <link>https://ttf248.life/ko/p/compiler-callback-function-performance-testing/</link>
        <pubDate>Wed, 15 Feb 2023 13:59:25 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/compiler-callback-function-performance-testing/</guid>
        <description>&lt;p&gt;지난해에 SDK를 설계했는데, 이 SDK는 일부 이벤트 처리 및 캡슐화를 담당하고, 클래스 인터페이스를 통해 외부로 제공합니다. 서비스 초기화 시에는 호출자가 해당 클래스를 구현하고 객체 포인터를 모듈에 전달합니다.
C11을 접해보다 보니 호기심이 고양이의 목숨을 앗아가듯, 이러한 인터페이스들을 &lt;code&gt;lambda&lt;/code&gt; 함수 객체 콜백으로 구현하면 어떤 결과가 나올지 궁금했습니다. 순수 추상 함수의 인터페이스 정의 방법과 비교했을 때 더 유연하다고 생각합니다.
의문이 생겼다. 두 가지 다른 문법 중 성능 면에서 어느 것이 더 빠른가? 컴파일 원리를 모르는 사람이 코드를 조금 작성해서 확인해 보았다.&lt;/p&gt;
&lt;h2 id=&#34;서론&#34;&gt;서론
&lt;/h2&gt;&lt;p&gt;온라인 주소이며, 다양한 컴파일러와 컴파일 옵션을 선택하고 &lt;code&gt;linux&lt;/code&gt; 플랫폼에서 코드를 실행하거나 해당 어셈블리 코드를 확인할 수 있습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가끔 기술 검증을 하는데, 웹 페이지에서 짧은 코드 조각을 실행하는 것이 편리합니다&lt;/li&gt;
&lt;li&gt;Godbolt.org는 다양한 색상으로 다른 어셈블리 코드를 구분하여 로컬 디버거보다 훨씬 편리합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;표준위원회에서 문법 규칙을 제정했으며, 컴파일 단계에서 어떻게 구현할지는 각 컴파일러에 달려 있습니다. 여기서 짚고 넘어가야 할 것은 마이크로소프트의 컴파일러는 꽤 강력하다는 점입니다. 문법적 설탕이 만능은 아니며, 콜백 인터페이스가 많지 않으므로 &lt;code&gt;lambda&lt;/code&gt;를 사용하면 더욱 편리하고 빈 콜백 함수 인터페이스를 정의할 필요도 없습니다. 콜백 인터페이스 종류가 다양해질 때는 전통적인 가상 함수가 비즈니스 인터페이스 정의의 통일성을 더 돕습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;윈도우 플랫폼에서는 두 제품의 성능이 거의 비슷하며 큰 차이가 없습니다&lt;/li&gt;
&lt;li&gt;리눅스 플랫폼에서 가상 함수와 람다 비교 시, 한 번 실행에 1.35ns 더 걸린다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;일반적인 비즈니스 시스템 개발에서는 이 정도의 성능 손실은 무시할 수 있으며, &lt;code&gt;lambda&lt;/code&gt;를 도입하면 설계 측면에서 더 많은 편의성을 제공합니다. 특히 다중 신호 처리를 설계할 때 두드러지며, 하단에 이벤트 트리거가 있을 때 로그를 저장해야 한다면 로그 객체를 처리하는 함수가 필요합니다. 더 많은 비즈니스 처리 인터페이스가 필요할 때는 하단에서 &lt;code&gt;vector&lt;/code&gt;로 &lt;code&gt;lambda&lt;/code&gt; 객체를 저장하고, 이벤트 트리거 시 순차적으로 탐색하며 호출합니다. 이는 &lt;code&gt;QT&lt;/code&gt;의 신호와 슬롯과 유사하며, 로그, 모니터링, 비즈니스 1, 비즈니스 2는 서로 완전히 분리되어 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;코드&#34;&gt;코드
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Counter: 1000000
Time: 3966us
Counter: 1000000
Time: 5316us
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;memory&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;atomic&amp;gt;
#include &amp;lt;string&amp;gt;

std::atomic_int64_t counter = 0;

// 定义回调接口
class UserInterface
{
public:
    virtual void name() = 0;
    virtual void full_name() = 0;
};

class User : public UserInterface
{
public:
    void name() {}
    void full_name() { counter++; }
};

void to_string(UserInterface* user)
{
    user-&amp;gt;name();
    user-&amp;gt;full_name();
}

using name_handler = std::function&amp;lt;void()&amp;gt;;
using full_name_handler = std::function&amp;lt;void()&amp;gt;;

class Test
{
    name_handler name_;
    full_name_handler full_name_;

public:
    void set_name_handler(name_handler name)
    {
        name_ = name;
    }

    void set_full_name_handler(full_name_handler full_name)
    {
        full_name_ = full_name;
    }

    void to_string()
    {
        name_();
        full_name_();
    }
};

int main()
{
    User user;

    auto start = std::chrono::high_resolution_clock::now();

    for (int i = 0; i &amp;lt; 1000000; i++)
    {
        to_string(&amp;amp;user);
    }

    auto end = std::chrono::high_resolution_clock::now();
    std::cout &amp;lt;&amp;lt; &amp;quot;Counter: &amp;quot; &amp;lt;&amp;lt; counter &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;Time: &amp;quot; &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(end - start).count() &amp;lt;&amp;lt; &amp;quot;us&amp;quot; &amp;lt;&amp;lt; std::endl;

    counter = 0;
    auto name = []() {};
    auto full_name = []() { counter++; };

    Test test;
    test.set_name_handler(name);
    test.set_full_name_handler(full_name);

    start = std::chrono::high_resolution_clock::now();

    for (int i = 0; i &amp;lt; 1000000; i++)
    {
        test.to_string();
    }

    end = std::chrono::high_resolution_clock::now();
    std::cout &amp;lt;&amp;lt; &amp;quot;Counter: &amp;quot; &amp;lt;&amp;lt; counter &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;Time: &amp;quot; &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(end - start).count() &amp;lt;&amp;lt; &amp;quot;us&amp;quot; &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;p&gt;자료를 찾다가 비슷한 코드 조각 &lt;a class=&#34;link&#34; href=&#34;https://gist.githubusercontent.com/benloong/8050171/raw/fa577ec923b460862078b8b40233a42a1c619eeb/functionperformance.cpp&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;functionperformance.cpp&lt;/a&gt;를 발견했습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;memory&amp;gt;
#include &amp;lt;functional&amp;gt;

using namespace std;
using namespace std::chrono;

class Base
{
public:
	Base(){}
	virtual ~Base(){}
	virtual int func(int i) = 0;
};

class Derived : public Base
{
public:
	Derived(int base = 10) : base{base}
	{

	}
	~Derived(){}

	virtual int func(int i)
	{
		return i*base;
	}
private:
	int base;
};

struct Func
{
	int base;
	int operator()(int i)
	{
		return i*base;
	}
	Func(int base) : base {base}
	{

	}
};
const int base = 10;
int calculate(int i)
{
	return base*i;
}

int main()
{
	const int num = 10000;
	Base *p = new Derived{10};
	int total = 0;
	auto start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += p-&amp;gt;func(i);
	}
	auto end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nvirtual call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;

	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += calculate(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\ndirect function call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;

	Func functor{10};
	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += functor(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nfunctor call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;
	int base = 10;
	function&amp;lt;int(int)&amp;gt; lambda = [base](int i)
	{
		return i*base;
	};
	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += lambda(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nlambda call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;
	return 0;
}

/*
test on mac mini i7 2.7GHz
clang++ -std=c++11 chronotest.cpp -O0
output:
result: 499950000
virtual call elapsed: 	43171 nanoseconds.

result: 499950000
direct function call elapsed: 	31379 nanoseconds.

result: 499950000
functor call elapsed: 	41497 nanoseconds.

result: 499950000
lambda call elapsed: 	207416 nanoseconds.
===================================================
clang++ -std=c++11 chronotest.cpp -O1
output:
result: 499950000
virtual call elapsed: 	26144 nanoseconds.

result: 499950000
direct function call elapsed: 	22384 nanoseconds.

result: 499950000
functor call elapsed: 	33477 nanoseconds.

result: 499950000
lambda call elapsed: 	55799 nanoseconds.
===================================================
clang++ -std=c++11 chronotest.cpp -O2
result: 499950000
virtual call elapsed: 	22284 nanoseconds.

result: 499950000
direct function call elapsed: 	36 nanoseconds.

result: 499950000
functor call elapsed: 	30 nanoseconds.

result: 499950000
lambda call elapsed: 	28292 nanoseconds.

===================================================
clang++ -std=c++11 chronotest.cpp -O3
result: 499950000
virtual call elapsed: 	18975 nanoseconds.

result: 499950000
direct function call elapsed: 	29 nanoseconds.

result: 499950000
functor call elapsed: 	30 nanoseconds.

result: 499950000
lambda call elapsed: 	22542 nanoseconds.
===================================================
clang++ -std=c++11 chronotest.cpp -O4

result: 499950000
virtual call elapsed: 	22141 nanoseconds.

result: 499950000
direct function call elapsed: 	30 nanoseconds.

result: 499950000
functor call elapsed: 	30 nanoseconds.

result: 499950000
lambda call elapsed: 	22584 nanoseconds.
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기에는 일반 함수와 람다 함수라는 두 가지 새로운 모드가 추가되었으며, 인터페이스 콜백 방식과 직접 호출 방식을 비교하여 성능 손실이 수치적인 차이를 보입니다. 람다 함수의 성능은 함수에 근접하며 때로는 더 우수합니다. 컴파일 원리에 대한 지식 부족으로 추측해 보면, 접근하는 변수의 주소와 함수가 서로 인접하여 CPU 처리 측면에서 유리한 것으로 생각됩니다.&lt;/p&gt;
&lt;p&gt;첨부된 &lt;code&gt;wandbox&lt;/code&gt; 실행 결과입니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;result: 499950000
virtual call elapsed: 6143 nanoseconds.

result: 499950000
direct function call elapsed: 30 nanoseconds.

result: 499950000
functor call elapsed: 31 nanoseconds.

result: 499950000
lambda call elapsed: 15134 nanoseconds.
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>호스트 순서, 네트워크 순서를 디버거를 통해 직접 관찰</title>
        <link>https://ttf248.life/ko/p/host-order-network-order-debugger-observation/</link>
        <pubDate>Tue, 10 Jan 2023 14:18:12 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/host-order-network-order-debugger-observation/</guid>
        <description>&lt;p&gt;컴퓨터 발전 역사에서 데이터를 저장하는 방법에 대한 통일된 표준은 없었습니다&lt;/p&gt;
&lt;p&gt;바이트의 배열 방식에는 두 가지 일반적인 규칙이 있습니다. 예를 들어, 다중 자릿수의 하위 바이트를 작은 주소에 두고 상위 바이트를 큰 주소에 두는 것을 리틀 엔디언이라고 하며, 반대로 빅 엔디언이라고 합니다. 네트워크 애플리케이션에서는 바이트 순서가 반드시 고려해야 할 요소인데, 서로 다른 기계 유형이 서로 다른 표준의 바이트 순서를 채택할 수 있기 때문입니다. 따라서 모두 네트워크 표준으로 변환합니다.&lt;/p&gt;
&lt;p&gt;읽기 습관에 따라 빅 엔디안 바이트 순서가 왼쪽에서 오른쪽으로 읽는 순서와 더 일치합니다&lt;/p&gt;
&lt;h2 id=&#34;프로세서-아키텍처&#34;&gt;프로세서 아키텍처
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;x86, MOS Technology 6502, Z80, VAX, PDP-11 등 프로세서는 리틀 엔디언입니다&lt;/li&gt;
&lt;li&gt;모토로라 6800, 모토로라 68000, PowerPC 970 등 프로세서는 빅 엔디안 방식입니다&lt;/li&gt;
&lt;li&gt;ARM, PowerPC(PowerPC 970 제외), DEC Alpha, SPARC V9, MIPS, PA-RISC 및 IA64의 바이트 순서는 구성 가능합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;네트워크-서론&#34;&gt;네트워크 서론
&lt;/h2&gt;&lt;p&gt;네트워크 전송은 일반적으로 빅 엔디안을 사용하며, 네트워크 바이트 오더 또는 네트워크 순서라고도 합니다. IP 프로토콜에서 빅 엔디안을 네트워크 바이트 오더로 정의합니다.
버클리 소켓은 16비트 및 32비트 정수를 네트워크 바이트 순서와 로컬 호스트 바이트 순서 간에 변환하는 데 사용되는 일련의 변환 함수를 정의합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;arpa/inet.h&amp;gt;

uint32_t htonl(uint32_t hostlong); //把uint32_t类型从主机序转换到网络序
uint16_t htons(uint16_t hostshort); //把uint16_t类型从主机序转换到网络序
uint32_t ntohl(uint32_t netlong); //把uint32_t类型从网络序转换到主机序
uint16_t ntohs(uint16_t netshort); //把uint16_t类型从网络序转换到主机序
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;asio를 네트워크 라이브러리로 선택하는 경우, 내장된 네임스페이스에 플랫폼 독립적인 함수 이름이 있습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;boost::asio::detail::socket_ops::network_to_host_long&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::network_to_host_short&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::host_to_network_long&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::host_to_network_short&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;비주얼-스튜디오-디버거&#34;&gt;비주얼 스튜디오 디버거
&lt;/h2&gt;&lt;p&gt;디버그 모드에서 디버그 메뉴, 창을 선택하고 메모리 윈도우를 체크합니다&lt;/p&gt;
&lt;p&gt;Visual Studio에서 디버거에서 메모리 내의 데이터를 직접 확인할 수 있습니다. 그림은 아래와 같습니다.&lt;/p&gt;
&lt;p&gt;디버거 메뉴&lt;/p&gt;
&lt;h3 id=&#34;메모리-확인-방법&#34;&gt;메모리 확인 방법
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;창을 통해 변수 이름을 직접 출력하고 해당 변수의 주소로 이동합니다&lt;/li&gt;
&lt;li&gt;변수가 원래 포인터라면, 변수를 더블 클릭하여 선택한 후 메모리 윈도우로 드래그하면 해당 주소의 내용을 보여줍니다&lt;/li&gt;
&lt;li&gt;변수가 포인터가 아니면 계산 창에 추가하고, 주소를 가져온 다음 메모리 창에 수동으로 복사하세요&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;예시로-말하자면&#34;&gt;예시로 말하자면
&lt;/h3&gt;&lt;p&gt;데이터를 수신하여 &lt;code&gt;buffer&lt;/code&gt; 객체에 저장하고, 네트워크 바이트 순서를 호스트 바이트 순서로 변환했습니다. 그 결과 &lt;code&gt;body_length&lt;/code&gt;는 30이 되었고, 서버에서는 이 데이터를 전송하기 위해 네 개의 바이트를 할당했습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool NetworkMessage::decode_header()
{
    // 网络序转成主机序
    body_length_ = boost::asio::detail::socket_ops::network_to_host_long(*(int *)buffer_.data());
    return auto_reserve(body_length_);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;메모리 윈도우에서 &lt;code&gt;buffer_&lt;/code&gt;의 내용을 관찰합니다(빅 엔디안 바이트 순서)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/host-order-network-order-debugger-observation/buffer_.png&#34;
	width=&#34;603&#34;
	height=&#34;318&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;buffer_&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;189&#34;
		data-flex-basis=&#34;455px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;메모리 윈도우에서 &lt;code&gt;body_length_&lt;/code&gt;의 내용을 관찰하세요&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/host-order-network-order-debugger-observation/body_length_.png&#34;
	width=&#34;581&#34;
	height=&#34;333&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;body_length_&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;174&#34;
		data-flex-basis=&#34;418px&#34;
	
&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>그때 그 소년은 재능이 있었을지도 모르지만 많지는 않았다</title>
        <link>https://ttf248.life/ko/p/then-boy-talent-not-much/</link>
        <pubDate>Mon, 09 Jan 2023 13:45:09 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/then-boy-talent-not-much/</guid>
        <description>&lt;p&gt;일곱 번째 해가 되니 코딩하면서 얻는 긍정적인 피드백이 예전만큼 많지 않네요. 어떻게 이 &lt;code&gt;코딩&lt;/code&gt; 길을 걷게 되었는지 되돌아봅니다.
사람의 다양한 선택은, 어릴수록, 긍정적인 피드백을 따르는 경향이 있고, 적극적으로 위험을 피하고 이익을 추구한다&lt;/p&gt;
&lt;h2 id=&#34;일어릴-때&#34;&gt;일、어릴 때
&lt;/h2&gt;&lt;p&gt;이사해서 시내에 왔고, 컴퓨터 서적을 접하게 되었고, 해커 자료를 알게 되고, 윈도우 시스템에 대해 알게 된 것들은 뒷 이야기일 뿐이야&lt;/p&gt;
&lt;p&gt;어릴 때 형제랑 몰래 우리 집 컴퓨터로 게임을 하던 시절이 기억난다. 내 남동생은 컴퓨터 가게에서 일하고 있었는데, 그곳에 있는 컴퓨터 상점에서 일을 하고 있었다.
어릴 때부터 컴퓨터를 접할 기회가 많았고, 기본적인 인식이 자리 잡았어요. 학교에서 전자통신수업을 듣기도 하고, 관심도 많이 가졌죠.
중학교 때 컴퓨터 경선대회에 대해 들었는데, 그때 정말 멋있다고 생각했었다. 전학 간 후에는 그 일이 그냥 잊혀졌다.
제가 중학교 다닐 때, 컴퓨터 기본 조작에 익숙했고, 컴퓨터 수업 시간에 비교적 쉽게 튀는 편이었습니다
만약 아직도 익숙하다면, 네, 착각하지 말고, 숙련이 아니라 오피스 사무 프로그램에 익숙하다면 더 대단할 거야&lt;/p&gt;
&lt;h2 id=&#34;이-이사&#34;&gt;이, 이사
&lt;/h2&gt;&lt;p&gt;이사 문제로 돌아가서, 시내에 도착해서 이웃들 때문에 도서관을 접하게 되었는데, 소설을 꽤 많이 봤지만 잡지도 많이 봤습니다
컴퓨터 보고서, 대중 소프트웨어
컴퓨터라는 제품에 대해 점점 더 관심을 갖게 되었고, 어렸을 때 해커를 존경했던 심리와 함께 학교에서 관련 지식을 적극적으로 찾아다녔습니다
운영 체제의 기본 사항인 제어판, CMD 명령, VBS 스크립트에 대한 인지&lt;/p&gt;
&lt;p&gt;컴퓨터 보고서 초보자용 콘텐츠는 괜찮은 것 같아요. 매번 사례 형태로 시스템 운영에 대한 지식을 쉽게 설명해주거든요.
다양한 소프트웨어, 업계 뉴스, &lt;strong&gt;물론 게임 뉴스도 추천하고, 처음의 동기 부여에도 게임의 씨앗을 뿌렸죠.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;셋째-고등학교&#34;&gt;셋째, 고등학교
&lt;/h2&gt;&lt;p&gt;고등학교 2학년 때, &lt;strong&gt;보거가 전학 와서 우리 반에 들어왔는데, 지난 2년 동안 컴퓨터 경시대회에서 장학생으로 몇 분 선배들이 왔고&lt;/strong&gt;, 학교에서도 이 대회에 신경을 많이 써왔다
미리 갖춰진 하드웨어 기반도 있고, 미국에 있는 학교 동문이 학교에 건물 하나를 기부했는데, 새로운 도서관이고 새로운 컴퓨터실이고, 다 그렇게 우연의 일치처럼 느껴진다
보그 형의 해설이 더해지면 학급 내에서 컴퓨터 전문가로 인정받을 수 있을 거야&lt;/p&gt;
&lt;p&gt;학력 우수자이자 컴퓨터 전문가인데, 다른 사람의 컴퓨터를 해킹하고 교실 감시 시스템을 무력화하는 방법을 알고 있다&lt;/p&gt;
&lt;p&gt;경쟁은 더듬거리며 진행되었지만 결국 결승에 진출했고, 배우는 것은 잘 이해되지 않았는데, 문제는 기본적인 알고리즘 위주였지만 그래도 약간의 수확이 있었습니다&lt;/p&gt;
&lt;p&gt;애반은 결국 애반일 뿐이고, 여행을 다녀온 것과 마찬가지예요&lt;/p&gt;
&lt;h2 id=&#34;4-대학교&#34;&gt;4. 대학교
&lt;/h2&gt;&lt;p&gt;대학교 전공 선택에 이르러서 가족들이 고른 것은 자동화였는데, 사실은 강전(強電)을 하고 싶었고, 집에 돌아와서는 전력 회사에 들어갔다. 전공 공부는 많이 못 했다.
자기 주도 학습 능력은 전공 수업에서는 거의 없는데, 큰 규모의 컴퓨터 수업을 배우면 아주 자연스럽게 느껴진다&lt;/p&gt;
&lt;p&gt;전공 수업은 빼먹고, 컴퓨터 과목은 열심히 공부하며, 매일 포럼에 들어가 있다: 《정의 포럼》, 《오아이 해킹》
전문 지식인 학부 과정에서 배운 회로 이론, C++ 지식을 활용하여 &lt;strong&gt;온라인 커뮤니티에서 일거리를 받아 돈을 벌기 시작했는데, 긍정적인 반응이 많아 점점 더 깊숙이 빠져들었고, 이제는 돌아갈 수 없을 정도가 됐어&lt;/strong&gt;
결국, 소짜오의 선택은 칩에 코드를 짜는 쪽이었고, 집에서도 별로 간섭하지 않았어, 내가 직접 고르게 됐지&lt;/p&gt;
&lt;p&gt;이때, &lt;strong&gt;세 번째 핵심 인물: 형&lt;/strong&gt;이 고학력으로 바이두에 입사했다
언니도 나를 잘 이해해서 내가 그 즈음에는 생각할 겨를이 없다는 걸 알고, 시형이와 얘기해보라고 하네
향후 발전 방향을 정하고, 여름방학에 고향에 가지 않고 지도 교수님과 함께 프로젝트를 하고 경험을 쌓자
자신의 괜찮은 성적표를 믿고 홍성전자로 입사했다&lt;/p&gt;
&lt;h2 id=&#34;다섯-졸업&#34;&gt;다섯. 졸업
&lt;/h2&gt;&lt;p&gt;여기 중요한 점이 있는데, 저는 벽을 넘고 선택 과목으로 컴퓨터 정보 검색을 수강했었습니다. 자료나 문제점을 빠르고 정확하게 찾는 방법을 알고 있습니다.
업무 중에 억만금을 만났다, &lt;strong&gt;석거&lt;/strong&gt;, 스스로 학습할 시간을 주고 문제 해결의 근본 원인을 파악하도록 도와주며, 연구개발센터의 대가들을 만나게 해주었다
이것도 다 기반을 닦은 거고, 심천 지사에서는 저를 대외적으로도 굉장한 실력 있다고 생각하고 거래 채널 그룹의 성공적인 책임자가 되었습니다&lt;/p&gt;
&lt;p&gt;여기서 문제가 하나 있는데, 저는 컴퓨터 운영체제, 알고리즘 등 기초 지식과 소프트웨어 공학 설계
체계적인 학습은 없었고, 모두 자신의 경험에 의존했었다
자신의 코드 설계를 앞뒤로 부정하고, 모듈 설계에 대한 기준이 없었으며, 일곱 번째 해가 되어서야 지쳐오기 시작했다&lt;/p&gt;</description>
        </item>
        <item>
        <title>중국 코로나19 해제</title>
        <link>https://ttf248.life/ko/p/china-coronavirus-unlocking/</link>
        <pubDate>Thu, 22 Dec 2022 19:22:04 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/china-coronavirus-unlocking/</guid>
        <description>&lt;p&gt;정책 발표가 매우 갑작스러웠고, 시행도 신속하게 이루어져 여행 제한 코드가 폐지되고 공공장소에서 더 이상 건강 증명서를 확인하지 않습니다&lt;/p&gt;
&lt;p&gt;뉴욕 타임스 중국어 웹사이트를 둘러보니 전체 페이지가 중국의 봉쇄 해제에 대한 논의로 가득 차 있었다&lt;/p&gt;
&lt;p&gt;정책을 평가하지 않고, 주변 상황을 기록한다&lt;/p&gt;
&lt;p&gt;베이징은 원래 0코로나 정책을 시행한 적이 없었고, 정책이 완화되면서 빠르게 확산되었지만, 친구들 사이에서는 중증 환자는 발생하지 않았다&lt;/p&gt;
&lt;p&gt;선전은 광저우와 붙어 있어 빠르게 발전하기 시작했고, 상하이에 거주하며 회사 위치가 외곽 지역이라 이 글을 쓰는 시점에 아직 대규모 감염은 발생하지 않았다&lt;/p&gt;
&lt;p&gt;보호 조치가 미흡했던 고향에서, 빠르게 확산되었습니다&lt;/p&gt;
&lt;p&gt;대부분 비슷한 느낌이었을 것 같아요, 갑자기 풀어주는 바람에 일주일에 하나씩 정책이 바뀌더니 완전히 해금됐죠&lt;/p&gt;
&lt;p&gt;세 년간의 청영 정책의 효과를 부정할 수는 없고, 그럭저럭 지내고 있다&lt;/p&gt;</description>
        </item>
        <item>
        <title>C11: sleep for vs yield</title>
        <link>https://ttf248.life/ko/p/c11-sleep-for-vs-yield/</link>
        <pubDate>Tue, 20 Sep 2022 20:54:51 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/c11-sleep-for-vs-yield/</guid>
        <description>&lt;p&gt;코드를 살펴보던 중, &lt;code&gt;std::this_thread::yield()&lt;/code&gt;가 갑자기 눈에 들어왔다. C11의 문법적 설탕을 많이 사용했는데, &lt;code&gt;yield&lt;/code&gt;는 처음 보는 것 같고, 예전에는 신경 쓰지 않았다.&lt;/p&gt;
&lt;p&gt;매뉴얼을 확인하지 않고 가장 먼저 떠오르는 것은 비동기와 관련이 있는지인데, &lt;code&gt;yield&lt;/code&gt; boost 라이브러리의 코루틴 구현에 이 단어가 사용되었으므로 여기서는 코루틴과는 상관없고 제어 로직은 일반 스레드와 관련이 있는 것 같습니다&lt;/p&gt;
&lt;h2 id=&#34;문서&#34;&gt;문서
&lt;/h2&gt;&lt;h3 id=&#34;yield&#34;&gt;yield
&lt;/h3&gt;&lt;p&gt;이 함수의 정확성은 구현에 의존하며, 특히 사용 중인 OS 스케줄러 메커니즘과 시스템 상태에 따라 달라집니다. 예를 들어, 먼저 온(First-Come, First-Served) 실시간 스케줄러(Linux의 SCHED_FIFO)는 현재 스레드를 일시 중단하고 준비 실행 대기열의 동일 우선순위 스레드 뒤로 배치합니다(다른 스레드가 동일한 우선순위에 없다면 yield 효과는 없습니다).&lt;/p&gt;
&lt;h3 id=&#34;sleep_for&#34;&gt;sleep_for
&lt;/h3&gt;&lt;p&gt;지정된 sleep_duration 동안 현재 스레드의 실행을 차단합니다
이 함수는 스케줄링 지연이나 리소스 충돌로 인해 sleep_duration보다 오래 블록될 수 있습니다
표준 라이브러리는 안정적인 클럭으로 지속 시간을 측정하는 것을 권장합니다. 구현이 시스템 시간으로 대체되면 대기 시간 또한 클럭 조정에 민감할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;분석&#34;&gt;분석
&lt;/h3&gt;&lt;p&gt;두 함수 모두 현재 스레드가 더 이상 스레드를 점유하지 않도록 하는 것인데, 실행 결과는 플랫폼에 따라 다를 수 있나요? 여기서도 여전히 엉망진창인 느낌인데, 코드를 실행해서 결과를 확인해 보겠습니다&lt;/p&gt;
&lt;p&gt;ThinkPad 노트북(Visual Studio 커뮤니티 버전 2022), 텐센트 클라우드 S2 표준 서버(gcc8.5)&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;실행 플랫폼&lt;/th&gt;
&lt;th&gt;함수&lt;/th&gt;
&lt;th&gt;첫 번째/μs&lt;/th&gt;
&lt;th&gt;두 번째/μs&lt;/th&gt;
&lt;th&gt;세 번째/μs&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;sleep_for&lt;/td&gt;
&lt;td&gt;9872&lt;/td&gt;
&lt;td&gt;1884&lt;/td&gt;
&lt;td&gt;11302&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;yield&lt;/td&gt;
&lt;td&gt;119&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;sleep_for&lt;/td&gt;
&lt;td&gt;171&lt;/td&gt;
&lt;td&gt;168&lt;/td&gt;
&lt;td&gt;167&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;yield&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;td&gt;102&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;운영 결과에서 알 수 있듯이, 운영 체제 구현 방식에 따라 고정밀 슬립 시 &lt;code&gt;sleep_for&lt;/code&gt;의 안정성은 매우 다릅니다. 고정밀 슬립을 원한다면 &lt;code&gt;yield&lt;/code&gt;를 사용하는 것이 더 적합합니다.&lt;/p&gt;
&lt;p&gt;시간 정밀도가 &lt;code&gt;ms&lt;/code&gt; 단위까지 향상되니, 두 값 사이의 차이는 뚜렷하지 않다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;thread&amp;gt;
 
// 建议其他线程运行一小段时间的“忙睡眠”
void little_sleep(std::chrono::microseconds us)
{
    auto start = std::chrono::high_resolution_clock::now();
    auto end = start + us;
    do {
        std::this_thread::yield();
    } while (std::chrono::high_resolution_clock::now() &amp;lt; end);
}
 
int main()
{
    auto start = std::chrono::high_resolution_clock::now();
 
    little_sleep(std::chrono::microseconds(100));
    std::this_thread::sleep_for(std::chrono::microseconds(100));
 
    auto elapsed = std::chrono::high_resolution_clock::now() - start;
    std::cout &amp;lt;&amp;lt; &amp;quot;waited for &amp;quot;
              &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(elapsed).count()
              &amp;lt;&amp;lt; &amp;quot; microseconds\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;참조&#34;&gt;참조
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/header/thread.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/header/thread.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/thread/sleep_for.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/thread/sleep_for.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>리눅스 서버, MySQL 비밀번호 재설정</title>
        <link>https://ttf248.life/ko/p/linux-server-reset-mysql-password/</link>
        <pubDate>Tue, 20 Sep 2022 14:27:35 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/linux-server-reset-mysql-password/</guid>
        <description>&lt;p&gt;유휴 상태인 텐센트 클라우드 서버가 있는데, 연말에 만료되므로 갱신할 생각도 없었고, 개발용 데이터베이스로 MySQL을 설치했다. 시스템을 재설치할 때 귀찮아서 텐센트 클라우드가 제공하는 써드파티 이미지를 바로 선택했는데, MySQL 데이터베이스가 이미 설치되어 있었다. 시스템 내부에 비밀번호나 배포 경로를 설명하는 Readme 파일 같은 것이 있을 줄 알았는데.&lt;/p&gt;
&lt;p&gt;腾讯云 재설치 시스템은 정말 빠르네요, 1분 정도 지나니 재설치가 완료되었다는 알림이 왔고, 로그인하니 &lt;code&gt;systemctl status mysql&lt;/code&gt; 서비스가 이미 시작되어 있었어요. 비밀번호가 어디 있는지 찾아봤는데, 아무리 찾아도 없어서 점점 짜증나기 시작했어요.&lt;/p&gt;
&lt;p&gt;이때 생각하니 이미 서버에 접근해서 &lt;code&gt;root&lt;/code&gt; 권한을 가지고 있으니, 방법이 있을 거야. 자료를 뒤져보니 알리바바 클라우드 포럼에 관련 글이 있네, 계속 시도해 봐야겠다.&lt;/p&gt;
&lt;h2 id=&#34;비밀번호-재설정&#34;&gt;비밀번호 재설정
&lt;/h2&gt;&lt;p&gt;편집기로 &lt;code&gt;/etc/my.cnf&lt;/code&gt; 파일을 열고 &lt;code&gt;mysqld&lt;/code&gt; 노드에 다음 설정을 추가합니다: &lt;code&gt;skip-grant-tables&lt;/code&gt;. 그런 다음 명령을 실행하여 데이터를 재시작합니다: &lt;code&gt;systemctl restart mysql&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;다시 &lt;code&gt;mysql&lt;/code&gt;로 직접 로그인하여 데이터를 확인하고, 이후에는 정상적인 작업을 진행하겠습니다. &lt;code&gt;root&lt;/code&gt; 사용자 비밀번호를 재설정하고, 원격 로그인을 허용하도록 설정하겠습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;USE mysql;
UPDATE user SET authentication_string = password (&#39;pass&#39;) WHERE User = &#39;root&#39;;
grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;pass&#39; with grant option;
flush privileges;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;되돌린 수정 사항 적용을 위해 데이터베이스를 재시작하세요. 해결되었습니다.&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://help.aliyun.com/document_detail/42520.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://help.aliyun.com/document_detail/42520.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>밤의 명명술</title>
        <link>https://ttf248.life/ko/p/night-naming-art/</link>
        <pubDate>Thu, 11 Aug 2022 22:10:14 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/night-naming-art/</guid>
        <description>&lt;p&gt;중화 한자의 방대한 체계 속에서 “명(命)”자는 유일무이하여 동음자가 단 하나도 없다. 어쩌면, 이것은 묘하게 암시하는 것 같기도 하다. 각 사람의 삶은 단 한번뿐이며, 복제하거나 되돌릴 수 없다는 것을.&lt;/p&gt;
&lt;p&gt;한가할 때쯤 깃점중국망의 순위표를 살펴보면 《밤의 명명술》의 월표 수치가 압도적인 차이로 1위를 굳건히 지키고 있으며, 2위와의 격차가 엄청나서 도저히 따라갈 엄두조차 나지 않는다. 그동안은 당가산소, 이근 등 유명 작가들의 작품을 주로 봐왔는데, 이번에는 새로운 작가의 작품을 한번 시도해 보고는 싶었다. 색다른 독서 경험을 해보고 싶었다.&lt;/p&gt;
&lt;p&gt;8월 초까지 《밤의 명명법》의 월 티켓 판매량은 200만 장에 달했으며, 2위는 8만 장으로 엄청난 격차를 보였다&lt;/p&gt;
&lt;p&gt;저는 제가 학식이 부족한 것을 잘 알고 있어서 이 책의 문체를 평가할 만한 능력은 없지만, 십 몇 챕터를 다 읽어보니 이야기 전개가 빠르고 흥미진진해서 독자를 사로잡네요. 이렇게 높은 월표를 얻을 만한 가치가 충분히 있다고 생각합니다.&lt;/p&gt;
&lt;p&gt;흥미로운 것은 “명”자처럼 “사”자 역시 한자 안에서 같은 음의 글자를 찾을 수 없다는 점인데, 이는 생명의 종결 또한 유일무이하고 대체 불가능한 깊은 의미를 내포하는 것일까요?&lt;/p&gt;</description>
        </item>
        <item>
        <title>자동화 테스트에 대한 간략한 소개</title>
        <link>https://ttf248.life/ko/p/shallow-discussion-on-automation-testing/</link>
        <pubDate>Thu, 04 Aug 2022 11:39:18 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/shallow-discussion-on-automation-testing/</guid>
        <description>&lt;p&gt;금융 거래 시스템에 대한 테스트 투자액은 다른 시스템보다 훨씬 높지만, 복잡한 테스트 단계가 반복되고 &lt;code&gt;ROI&lt;/code&gt;는 너무 낮습니다. 프로젝트와 인력의 교체로 인해 피할 수 없이 더 많은 통제 불가능한 요소들이 유입되고 있으며, 흔히 A 인터페이스 출력의 특정 필드를 수정하면 B 인터페이스 결과에 영향을 미치는 경우가 발생합니다. 매번 버전이 출시될 때마다 위험도 누적됩니다.&lt;/p&gt;
&lt;h2 id=&#34;이론적-지식&#34;&gt;이론적 지식
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;자동화의 가치를 어떻게 측정할 수 있나요?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;자동화 테스트 사례 ROI = (수동 실행 시간) * (실행 횟수) / (개발 비용 + 유지 보수 비용)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어떤 기능에 자동화 테스트가 필요합니까?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;사용자가 자주 사용하는 기능, 자주 변경되지 않는 기능에 대해 자동화 테스트 코드를 작성하면 가장 큰 효과를 볼 수 있습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자동화 테스트를 추진하기 위한 이 시점을 선택한 이유는 무엇입니까?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;프로젝트 출시가 임박한 시점에는 적절하지 않습니다. 멀리 있는 물로 당장의 갈증을 해결할 수 없으며, 자동화는 장기적인 수익 모델입니다. 프로젝트는 이미 &lt;strong&gt;실제 운영 환경&lt;/strong&gt;에 배포되었고 안정적인 릴리스 주기를 맞이하고 있으므로 지금이 가장 적합합니다.&lt;/p&gt;
&lt;h2 id=&#34;프레임-선택&#34;&gt;프레임 선택
&lt;/h2&gt;&lt;p&gt;관련된 실무 경험이 부족한 상태에서 자동화 테스트라는 과제를 받았다면, 일반적인 시작은 다음과 같다: 검색 엔진을 열어 현재 시스템의 &lt;strong&gt;기술 스택&lt;/strong&gt;에 사용할 수 있는 도구와 프레임워크를 찾고 사용 설명서를 훑어본다. 바로 적절한 도구를 찾으면 축하한다, &lt;strong&gt;완벽한 시작&lt;/strong&gt;이다.&lt;/p&gt;
&lt;p&gt;먼저 잘못했다고 말씀드립니다. 관련 자료를 확인해 보니 없다는 게 아니라 프레임워크 자체가 너무 복잡하고, 배포 시 점유하는 리소스도 많습니다. 초보자 입문에는 작고 간결한 것이 필요합니다. 테스트 그룹 동료들과 상의 결과 기존 유닛 테스트 프레임워크를 활용하여 자동화 테스트 프레임워크로 캡슐화하는 &lt;code&gt;Python&lt;/code&gt; 자체 구축 프레임워크가 언급되었습니다.&lt;/p&gt;
&lt;p&gt;이 프로젝트의 디자인 아이디어를 참고하세요: &lt;a class=&#34;link&#34; href=&#34;https://github.com/wintests/pytestDemo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/wintests/pytestDemo&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;프레임워크가-왜-필요할까요&#34;&gt;프레임워크가 왜 필요할까요?
&lt;/h2&gt;&lt;p&gt;서비스는 여러 개의 다양한 배포 환경을 가지고 있습니다. 개발 환경, 테스트 환경, 온라인 테스트 환경이 있으며, 프레임워크의 역할은 계층을 분리하고 테스트 사례와 데이터를 분리하는 것입니다. 각 환경에 따라 다른 사례 데이터를 구성하며, 물론 공통 데이터도 지원합니다.&lt;/p&gt;
&lt;p&gt;핵심적인 논리는 자동화 활용률을 높이기 위한 것이다. 시나리오가 더 복잡해지고, 서로 다른 환경 간의 데이터는 일관성이 없고 아무런 관련이 없다면, 설정 사례 데이터를 추가할 때 &lt;code&gt;label&lt;/code&gt; 태그를 늘려 현재 데이터가 지원하는 환경을 지정하면 된다.&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;p&gt;가성비 최고의 자동화 테스트를 구축하세요&lt;/p&gt;</description>
        </item>
        <item>
        <title>새로운 언어를 배워야 하는 이유는 무엇인가?</title>
        <link>https://ttf248.life/ko/p/why-learn-a-new-language/</link>
        <pubDate>Thu, 04 Aug 2022 11:27:30 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/why-learn-a-new-language/</guid>
        <description>&lt;p&gt;학교 다닐 때부터 세면 10년이 넘게 C++를 접했는데, 왜 다른 프로그래밍 언어를 배워야 할까요?&lt;/p&gt;
&lt;p&gt;세련된 모듈 설계 경험은 부족하지만, &lt;code&gt;C++&lt;/code&gt; 문법은 자유로운 편이고 다른 언어를 학습하면서 더 세련된 설계를 유도할 수 있다&lt;/p&gt;
&lt;p&gt;도구를 작성할 때 자주 사용하게 된다&lt;/p&gt;
&lt;p&gt;하위 레이어 라이브러리 설계든, 비즈니스 모듈 구현이든, 설계의 원칙은 일관성이 있습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>비주얼 스튜디오 컴파일 문자 집합 [전환]</title>
        <link>https://ttf248.life/ko/p/visual-studio-compilation-character-set-translation/</link>
        <pubDate>Thu, 04 Aug 2022 10:51:43 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/visual-studio-compilation-character-set-translation/</guid>
        <description>&lt;p&gt;C++ 크로스 플랫폼 개발 시 중국어 운영체제에서는 종종 &lt;code&gt;error C2001&lt;/code&gt; 상수에 줄 바꿈 문자가 있다는 오류를 마주할 수 있습니다&lt;/p&gt;
&lt;h2 id=&#34;visual-studio&#34;&gt;visual studio
&lt;/h2&gt;&lt;p&gt;CMake는 프로젝트 빌드 스크립트를 구성하며, Windows 시스템에서 개발할 때 임시로 솔루션을 생성합니다. 플랫폼 간 호환성을 위해 파일 인코딩은 UTF-8을 선택했습니다.&lt;/p&gt;
&lt;p&gt;인용된 자료는 원리에서 출발하여 문제의 발생 원인을 상세히 설명하고 있습니다&lt;/p&gt;
&lt;p&gt;코딩 관련해서는 &lt;code&gt;MSVC&lt;/code&gt;에서 &lt;code&gt;/source-charset&lt;/code&gt;과 &lt;code&gt;/execution-charset&lt;/code&gt;이라는 전용 컴파일 옵션이 있는데, 전자는 파일 자체의 인코딩을 나타내고 후자는 컴파일 이후 문자 배열 내 바이트가 어떤 인코딩인지 나타냅니다. 인코딩 문제는 이 두 옵션으로 거의 해결할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예를 들어, &lt;code&gt;windows&lt;/code&gt;의 &lt;code&gt;cmd&lt;/code&gt; 콘솔은 기본적으로 &lt;code&gt;GBK&lt;/code&gt; 인코딩만 표시할 수 있지만, 코드 파일 자체는 &lt;code&gt;UTF-8&lt;/code&gt;로 되어 있어서 플랫폼 간 호환성 때문에 직접 &lt;code&gt;GBK&lt;/code&gt;로 변경하기가 편리하지 않습니다. 물론 여기에는 다양한 플랫폼을 위한 인코딩 변환 코드를 작성하는 방법은 포함되지 않습니다. &lt;code&gt;Win10&lt;/code&gt;에서는 컴파일러에 &lt;code&gt;/source-charset:utf-8 /execution-charset:gbk&lt;/code&gt; 옵션을 설정하여 UTF-8로 인코딩된 파일을 읽어들여서 GBK로 변환 후 배열에 저장하고, 이렇게 하면 &lt;code&gt;printf&lt;/code&gt;를 통해 콘솔에서 한자를 정상적으로 표시할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;cmake는-visual-studio-설정용입니다&#34;&gt;CMake는 Visual Studio 설정용입니다
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;if( WIN32 )
    message( STATUS &amp;quot;Configuring trade on WIN32&amp;quot;)
    set( CMAKE_CXX_FLAGS &amp;quot;${CMAKE_CXX_FLAGS} /source-charset:utf-8 /execution-charset:gbk&amp;quot;)
endif()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/146543940&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/146543940&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>펠로시 대만 방문</title>
        <link>https://ttf248.life/ko/p/pelosi-visits-taiwan/</link>
        <pubDate>Tue, 02 Aug 2022 22:57:54 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/pelosi-visits-taiwan/</guid>
        <description>&lt;p&gt;정치에 대해 모르는 척하며, 어떠한 의견도 내지 않고, 이 인터넷상의 “광란”을 기록한다&lt;/p&gt;
&lt;h2 id=&#34;에세이&#34;&gt;에세이
&lt;/h2&gt;&lt;p&gt;최근의 &lt;strong&gt;탕산 폭행 사건&lt;/strong&gt;과 &lt;strong&gt;인교 초등학교 교재 문화 침입 사건&lt;/strong&gt;은, 얼마나 많은 사람들이 기억하고 있을지 모르겠다. 뉴스에 나오는 이런 화제는 이미 무감각해졌고, 큰 감흥 없이 퇴근 후에도 평소처럼 드라마를 보고, 이 일은 그저 구경하는 것 같다. 경제 상황이 벌써 이렇게 된 마당에 전쟁이 발발해도 사는 날이 나아지지는 않을 것이다. 정치에는 문외한이고, 코멘트도 하지 않겠다. 인터넷 상의 “광란”을 기록하련다.&lt;/p&gt;
&lt;h2 id=&#34;위키-개요httpszhwikipediaorgwiki2022年香港维基百科删除风波&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/2022%e5%b9%b4%e9%a6%99%e6%b8%af%e7%bb%b4%e5%9f%ba%e7%99%be%e7%a7%91%e5%88%a0%e9%99%a4%e9%a3%8e%e6%b3%a2&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;위키 개요&lt;/a&gt;
&lt;/h2&gt;&lt;p&gt;2022년 낸시 페로시의 대만 방문, 또는 페로시 방타이(訪台)라고도 불리는데, 이는 제52대 미국 하원 의장인 낸시 페로시가 2022년 아시아 국가 순방 중 대만을 방문한 여정을 의미합니다&lt;/p&gt;
&lt;p&gt;미국 하원의장이 미국 실질 3인자로 여겨지며 대만 방문을 계획한 가운데, 해당 방문 시기가 중국 인민해방군 창건 기념일(8월 1일)과 가까워지고, 장기적으로는 중국 공산당 제20차 전국대표대회, 2022년 미국 선거 및 2022년 중화민국 지방공직선거와 임박함에 따라, 중화인민공화국 측은 정부 차원에서 강력한 항의를 표명하고 해군 구축함 부대를 타이완해 북동부 해역으로 파견했으며, 산둥함과 랴오닝함 두 개의 항공모함 전단이 동원되어 동부전구와 남부전구가 각각 동해와 남해에서 대규모 실사격 훈련을 실시했다. 미국 측은 로널드 레이건호 항공모함 전단을 타이완 해역 인근으로 파견하여 펠로시의 잠재적 방문 일정을 경비하고, 다수의 정찰기와 공중 급유기를 주한미군 가나다 공군기지에 배치해 대기했다.&lt;/p&gt;
&lt;p&gt;중국 국가 주석 시진핑과 미국 대통령 조 바이든은 방문에 앞서 화상 회의를 진행했으며, 내용은 대만 문제와 관련되어 있었습니다. 대만과 국제 언론은 낸시 펠로시 의장 및 하원 대표단이 2일 타이베이 송산 공항에 도착하여 숙박한 후 3일에 차이잉원 중화민국 대통령 등 정부 고위 관계자를 만날 예정이라고 밝혔습니다. 일부에서는 펠로시 의장의 이번 대만 방문이 1996년 타이완 해협 미사일 위기 이후 26년 만에 새로운 타이완 해협 위기를 야기할 수 있다고 보고 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;08-11&#34;&gt;08-11
&lt;/h2&gt;&lt;p&gt;오늘로서 기본적으로 안정을 찾은 셈이고, 이 기간 동안의 헤드라인은 대부분 해군 군사훈련 관련 내용이었으며, 지후(知乎)도 애를 써서 매일 다양한 방식으로 인기 게시물을 업데이트하고 있었고, 역시 이 일에 대한 것이었습니다. 편집자 수고하셨습니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>Windows 플랫폼에서 폴더 크기 빠르게 통계</title>
        <link>https://ttf248.life/ko/p/windows-platform-quick-folder-size-statistics/</link>
        <pubDate>Mon, 01 Aug 2022 19:54:18 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/windows-platform-quick-folder-size-statistics/</guid>
        <description>&lt;p&gt;리눅스 플랫폼은 간단해서 &lt;code&gt;du -sh *&lt;/code&gt; 한 줄의 코드로 끝내 버릴 수 있다. 윈도우는 어떨까? 디스크가 많고, 파일을 정리하고 싶을 때, 파일이 많은 상황에서 시스템 내장 리소스 관리자는 폴더 크기를 통계적으로 계산하는 속도가 너무 느려서 포기하고 싶게 만든다.&lt;/p&gt;
&lt;h2 id=&#34;everything&#34;&gt;Everything
&lt;/h2&gt;&lt;p&gt;윈도우 플랫폼에서 개발하는 분이라면, 직접 사용해 보지 않더라도 친구에게 들어봤을 &lt;code&gt;Everything&lt;/code&gt;이라는 프로그램이 있을 겁니다. 검색 속도는 시스템 자체의 파일 탐색기보다 훨씬 빠릅니다. 시스템 수준에서 빠른 파일 인덱싱을 지원하는 만큼, 파일을 인덱스하고 동시에 파일 크기를 통계적으로 관리하는 유사한 도구를 찾을 수 있을 것입니다.&lt;/p&gt;
&lt;h2 id=&#34;wiztree&#34;&gt;WizTree
&lt;/h2&gt;&lt;p&gt;공식 웹사이트: &lt;a class=&#34;link&#34; href=&#34;https://www.diskanalyzer.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.diskanalyzer.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;일반 설치 모드나 그린 버전 압축 해제 후 실행&lt;/p&gt;
&lt;p&gt;속도가 빠르고, 데이터 표시 유형이 풍부하며, 왼쪽에 트리 형태의 모드와 오른쪽에 파일 유형이 있고, 물론 하단 막대에도 시각화된 표현 방식도 있습니다&lt;/p&gt;
&lt;h2 id=&#34;spacesniffer업데이트-2023년-이후-더-이상-업데이트되지-않습니다&#34;&gt;SpaceSniffer(업데이트 2023년 이후 더 이상 업데이트되지 않습니다.)
&lt;/h2&gt;&lt;p&gt;소프트웨어 공식 웹사이트: &lt;a class=&#34;link&#34; href=&#34;http://www.uderzo.it/main_products/space_sniffer/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.uderzo.it/main_products/space_sniffer/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;조작은 매우 간단합니다. 해당하는 디스크 문자를 선택하면 소프트웨어가 그래픽 방식으로 폴더 크기를 표시하는데, 크기가 클수록 이미지 내 해당 매트릭스도 커집니다. 나머지 조작은 직접 클릭해보면 알 수 있을 것이고, 조건 필터를 입력하여 파일을 지원합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;파일 크기 필터링&lt;/li&gt;
&lt;li&gt;파일 날짜 필터&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;기본 사용법&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;고급 사용법&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://moe.best/software/spacesniffer.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://moe.best/software/spacesniffer.html&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>웹 페이지 스타일 시트(CSS) 복사 방법: 요소 검사</title>
        <link>https://ttf248.life/ko/p/how-to-copy-webpage-css-element-inspection/</link>
        <pubDate>Sun, 31 Jul 2022 23:36:48 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/how-to-copy-webpage-css-element-inspection/</guid>
        <description>&lt;p&gt;정적인 블로그 테마는 주로 해외 템플릿을 기반으로 수정 및 조정하며, 중국어 콘텐츠의 레이아웃에 대한 고려가 충분하지 않다&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;반 달 전, 블로그 스타일 시트를 조금 조정했는데, 오랫동안 백엔드 서비스 개발만 해와서 프론트엔드는 완전 초보입니다. 앞뒤로 반나절을 끙끙거렸는데 디자인이 별로 마음에 들지 않았습니다. 문득 떠올라 자주 보는 기술 블로그인 infoq, 오픈소스 중국의 스타일이 정말 좋다고 생각했습니다. 이걸 조금 가져다 쓸 수 있을까요? 잠시 소스 파일을 살펴봤지만 관련된 요소를 찾으려니 머리가 엉망이 되었습니다.&lt;/p&gt;
&lt;p&gt;프론트엔드 개발자 친구들은 여기서 웃을지도 모르겠네. 특정 요소를 찾는 것조차 모르는구만. 모르는 건 괜찮아, 주말에 시간도 많으니 잠시 멈춰서 생각해보니, 예전에 &lt;code&gt;python&lt;/code&gt; 크롤러를 만들 때 비슷한 걸 사용했던 것 같아.&lt;/p&gt;
&lt;h3 id=&#34;요소-검토&#34;&gt;요소 검토
&lt;/h3&gt;&lt;p&gt;맞아요, 바로 브라우저 자체의 요소 검사 도구인데, 스타일 시트 복사나 특정 요소 찾기 같은 것들은 금방 할 수 있습니다. &lt;code&gt;selector&lt;/code&gt;로 요소를 찾고, &lt;code&gt;hugo&lt;/code&gt;에서 &lt;code&gt;user define css&lt;/code&gt;를 새로 만들 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;요소 복사&lt;/li&gt;
&lt;li&gt;복사 outerHTML&lt;/li&gt;
&lt;li&gt;선택자 복사&lt;/li&gt;
&lt;li&gt;JS 경로 복사&lt;/li&gt;
&lt;li&gt;스타일 복사&lt;/li&gt;
&lt;li&gt;XPath 복사&lt;/li&gt;
&lt;li&gt;전체 XPath 복사&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Windows 플랫폼 편집을 위한 초대형 파일: EmEditor (텍스트 에디터)</title>
        <link>https://ttf248.life/ko/p/windows-platform-editing-large-files-emeditor-text-editor/</link>
        <pubDate>Sun, 31 Jul 2022 23:21:24 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/windows-platform-editing-large-files-emeditor-text-editor/</guid>
        <description>&lt;p&gt;상하이 국안 데이터베이스 사건은 해커 커뮤니티에서 떠들썩하게 돌아다니고 있지만, 진실 여부는 알 수 없습니다. 2년 후에 다시 한번 살펴보겠습니다. 과거 경험에 따르면, 지역 소셜 엔지니어링 데이터베이스 자료가 업데이트되었는데, 17.9G라는 거대한 SQL 파일이 있었습니다. 일반적인 텍스트 편집기로는 미리 보기조차 어렵고 열기는 더더욱 불가능했습니다. 누리꾼과 대화하던 중 EmEditor라는 프로그램을 언급했습니다.&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;공식 웹사이트: &lt;a class=&#34;link&#34; href=&#34;https://www.emeditor.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.emeditor.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;주말에 시간 날 때 한번 해봤는데, 꽤 편리하네요. 디자인 자체가 큰 파일을 편집할 수 있게 되어 있고, 메모리가 충분하면 전체 파일이 메모리에 로드되어서 검색이나 편집 속도도 빠르고, 파일 분할 기능도 지원합니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>상하이 원앙 훠궈 폐쇄</title>
        <link>https://ttf248.life/ko/p/shanghai-yuanyang-pot-closure/</link>
        <pubDate>Wed, 30 Mar 2022 23:03:27 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/shanghai-yuanyang-pot-closure/</guid>
        <description>&lt;p&gt;리더십 집단은 며칠 전까지는 체면을 지키기 위해 상하이를 봉쇄하지 않을 것이라고 주장하며, 상하이의 중요성을 강조했습니다. 하지만 현실에 직면하거나 자신의 입지를 유지하기 위해 어쩔 수 없이 강 건너에서 시작하여, 황푸강 반대편을 먼저 봉쇄하고 그 다음 이쪽 강변을 봉쇄하는 방식으로 진행되었습니다.&lt;/p&gt;
&lt;h2 id=&#34;봉쇄&#34;&gt;봉쇄
&lt;/h2&gt;&lt;p&gt;어릴 때 사스(SARS)를 겪었지만 별로 기억이 나지 않는다. 나중에 관련 자료를 보니까 잠복기가 비교적 짧아서 전국적인 확산으로 이어지기 전에 끝났다고 한다. 그때 초등학교 다닐 때는 매일 학교에서 일찍 퇴근했고, 교실에는 매일 소독약 냄새가 풍겼던 것 같다.&lt;/p&gt;
&lt;p&gt;2019년 말부터 지금까지 코로나19 팬데믹이 거의 3년을 되었습니다. 외국에서 일하는 사람들은 마스크를 써야 할 때는 다들 마스크를 쓰는 것에 익숙해졌습니다. 상하이의 이번 전파는 처음에는 홍콩에서 시작해서 국경을 넘어 선전으로 확산되었고, 상하이는 홍콩으로부터 유입된 사례로 인해 발생했습니다. 당국은 최종적으로 격리 호텔의 방역 조치가 미흡하여 전파가 발생했다고 발표했고, 변이 바이러스는 독성은 약해졌지만 전파 속도는 빨라져서 환기 시스템을 통해 확산되었습니다. 처음에는 심각하지 않았고 통제할 수 있었는데 말이죠.&lt;/p&gt;
&lt;p&gt;사람들은 항상 자신감이 있습니다. 상하이의 지도자들도 마찬가지입니다. 그들은 우리가 할 수 있는 격자화된 리스크 관리와 정확한 통제를 선택할 것입니다.&lt;/p&gt;
&lt;p&gt;지금 결과를 다들 보셨을 겁니다. 신규 확진이 2만을 넘었습니다. 어쩔 수 없이 봉쇄 조치를 선택했고, 중요한 것은 ‘봉쇄’라는 단어를 사용하지 않았다는 점입니다. 이전 뉴스 발표회에서 상하이는 봉쇄할 필요가 없다고 밝혔고, 이는 마지막 체면을 지키기 위한 것이었습니다.&lt;/p&gt;
&lt;h2 id=&#34;장보기&#34;&gt;장보기
&lt;/h2&gt;&lt;p&gt;배달 산업은 인터넷이 만들어낸 새로운 산업입니다. 핵심은 누군가가 배달을 해줘야 하는데, 코로나19로 인해 넓은 지역이 봉쇄되면서 상가는 영업은 하지만 배달해 줄 사람이 없어져 마지막 연결고리가 끊어진 거죠. 밖에 있는 사람들은 이해를 못할 수도 있겠지만, 국제적인 대도시인 상하이에 왜 다 같이 식료품을 사러 가는 걸까 싶을 겁니다. 생각해 보면 알 수 있습니다. 대부분이 타지에서 일하러 온 사람들이고, 렌트하는 집에서 살면서 평소에는 회사 구내식당이나 식당에서 먹기 때문에 집에서 직접 요리하는 경우는 드물죠. 그런데 밖에 나갈 길이 막히자, 여건이 되는 사람들은 식료품을 사기 시작했습니다. 이런 봉쇄 조치가 사전 공지 없이 이루어졌고, 사람들은 평소에 많은 양의 식량이나 채소를 비축해두지도 않았습니다. 그래서 영상에서처럼 다 같이 식료품을 사러 가는 현상이 발생했고, 그런 상황에서의 모임은 직간접적으로 코로나19 재확산으로 이어졌습니다.&lt;/p&gt;
&lt;h2 id=&#34;산업&#34;&gt;산업
&lt;/h2&gt;&lt;p&gt;IT 분야에 종사하는 사람들인데, 코로나 때문에 집에서 일하게 되었고, 19년도에는 거의 한 달 동안 집에 있었는데, 기차표를 수십 번이나 변경했지만 언제 상해로 돌아갈 수 있을지 전혀 알 수 없었습니다. 식당, 관광 또는 많은 서비스 업계 사람들은 지난 몇 년간 어떻게 지냈을까 상상조차 할 수 없습니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>돈 벌고 싶을 때</title>
        <link>https://ttf248.life/ko/p/when-you-want-to-make-money/</link>
        <pubDate>Sun, 27 Mar 2022 03:23:53 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/when-you-want-to-make-money/</guid>
        <description>&lt;p&gt;보통 사람들은 사회적 동물이다, 맞다. 너는 개인이고, 직립 보행하는 동물이며, 강한 사회적 속성을 가지고 있다. 자존심과 허영심도 있고, 사회는 끊임없이 변화하고 있으며, 너의 &lt;strong&gt;평온함&lt;/strong&gt;을 계속해서 침식한다. 우리는 위대한 사람들, 사회와 국가를 위해 자신을 태우려는 사람들에 대해서는 논하지 않겠다.&lt;/p&gt;
&lt;h2 id=&#34;지금의-나&#34;&gt;지금의 나
&lt;/h2&gt;&lt;p&gt;평균 임금을 기준으로 보든, 고향의 임금을 기준으로 보든, 지금 제 소득은 평균 수준을 훨씬 넘어섰는데, 무엇이 불만족스러울 수 있겠어요?&lt;/p&gt;
&lt;p&gt;만 원을 벌면 백만 원을 벌고 싶어지고, 백만 원을 벌면 천만 원을 벌고 싶어지는 것은 흔한 인간의 본성이며, 사람은 자신의 내면과 마주해야 한다&lt;/p&gt;
&lt;p&gt;그 붉게 보이는 것은 무엇일까, 더 쉽고 편하게 돈을 버는 방법: 짧은 동영상&lt;/p&gt;
&lt;p&gt;모두들 이 바닥이 쉬운 줄 알지만, 실제로는 그렇지 않아. 지금 보이는 건 짧은 영상일 뿐이고, 뒤에 숨겨진 촬영 기획 및 시나리오 작성 과정은 보이지 않지. 하지만 모든 사람은 자신이 천재라고 생각하고, 자신에게 맞는 분야라고 믿으며, 재능이 있다고 착각하는 경향이 있어.&lt;/p&gt;
&lt;h2 id=&#34;시작을-접하다&#34;&gt;시작을 접하다
&lt;/h2&gt;&lt;p&gt;그렇게 많은 영상을 보니까, 여러 장면을 곰곰히 분석해 보면 전문적인 편집 기법이 사용되었고 강렬한 영화 같은 느낌이 든다. 즉, 그들 중 일부는 학교를 졸업한 것 같다. 물론 풀뿌리에서 성공하는 논리가 있지만, 그것은 일반 사람에게 적용되지 않는다, 그렇지 않은가?&lt;/p&gt;
&lt;p&gt;틱톡에는 영상 만드는 방법을 알려주는 영상들이 엄청 많아요. 이때 사람들은 정신이 번쩍 들죠. 돈을 벌 수 있다면 왜 직접 안 하고, 당신에게 시키는 걸까요?&lt;/p&gt;
&lt;h2 id=&#34;비인간적인-추천-알고리즘&#34;&gt;비인간적인 추천 알고리즘
&lt;/h2&gt;&lt;p&gt;전에 抖音 알고리즘이 영화 편집 영상이나 애니메이션 편집 영상을 추천할 때 계속 보다 보니 재미있어지기도 했는데, 제가 抖音으로 돈을 버는 방법에 대한 정보를 찾아보려고 하니, 관련 교육 영상들만 계속해서 추천해주고 끊임없이 제 추천 목록을 채워버리더라고요. 저 역시 IT 업계에 종사하고 있습니다. 그때 알게 된 건데, 알고리즘을 만드는 그분들은 혹시 문제가 있는 걸까요? 이렇게 추천하는 게 제가 바보라고 생각하는 건지, 아니면 그분들이 바보라고 생각하는 건지 궁금해졌습니다. 특히 抖音으로 돈을 버는 방법을 알려주는 영상들을 계속해서 다른 각도와 다양한 유형으로 추천해주더라고요. 이 글은 새벽 3시에 쓰기 시작했는데, 사실 쓰고 싶지 않았습니다. 이런 상업 모델이 얼마나 오래 지속될 수 있을까? 그리고 여러분의 시간을 얼마나 더 빼앗을 수 있을까요?&lt;/p&gt;
&lt;h2 id=&#34;깨닫고-살다&#34;&gt;깨닫고 살다
&lt;/h2&gt;&lt;p&gt;사람 가르치는 데는 이론만 앞세우고, 자기 일에는 통제도 못 하는 꼴이라니, 정말 웃기는 소리네. 순수한 기술 블로거가 아니니까 일부 내용 국내에 올리는 건 생략했고, 여기서는 그냥 불만을 토로하는 거야. 만약 이 글이 차단된다면 어쩔 수 없지, 다른 곳에서 다시 시작하면 돼. 틱톡이 아무것도 안 했다고는 말할 수 없어. 적어도 현재 실시간 뉴스 전달이나 국가 정책 홍보에는 적극적으로 협조하고 있잖아. 결국 우리나라에서는 당의 뜻에 반하는 행동은 할 수 없지.&lt;/p&gt;
&lt;p&gt;지금 생각해보니 옛날 공부할 때가 떠오른다. 진정으로 인생의 의미를 찾지 못할 때는 조용히 책을 읽는 것만으로도 충분하다. 요즘 시대에 얼마나 많은 사람들이 마음을 가다듬고 조용히 책을 읽을 수 있을까.&lt;/p&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;p&gt;여기서는 과학 기술의 발전에 감사드려야 할 것 같습니다. 이 줄을 보고 있다면 전체 원고가 매우 구어체로 쓰여진 것을 알 수 있을 겁니다. 그리고 저는 그냥 읽으면서 써 내려갔습니다. 평소에 사용하던 입력법은 소고우 입력법이었는데, 7~8년 정도 사용했습니다. 하지만 음성 입력 부분에서는 뭐니뭐니 해도 讯飞가 전문적입니다.&lt;/p&gt;
&lt;p&gt;2022년 기사 번호가 002로 바뀌었습니다. 왜 이렇게 두 개의 영이 붙었을까요? 올해 기사 수가 100개를 넘는 꿈을 꾸고 있는데, 그게 바로 저의 꿈입니다. 글이라고 하기도 어렵네요, 그냥 몇몇 기록들일 뿐입니다. 나는 매일 세 번 자신을 돌아보고, 당신도 결국 뭔가 떠오르는 것이 있을 겁니다, 그렇죠?&lt;/p&gt;</description>
        </item>
        <item>
        <title>생각보다 간단해 보이는 일에 코드 복사 버튼을 추가하는 것</title>
        <link>https://ttf248.life/ko/p/add-code-copy-button/</link>
        <pubDate>Fri, 25 Feb 2022 01:23:39 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/add-code-copy-button/</guid>
        <description>&lt;p&gt;네 시간이나 붙잡고 있었는데, 이 문장을 보니까 웃겼다. 이렇게 오래 걸릴 리가 있나 싶었지. 그런데 시간을 보니 세 시간이었어.&lt;/p&gt;
&lt;p&gt;뭐랄까, 2022년의 첫 글이라고 할 수 있는데, 크게 복잡한 건 아니고 제목 그대로인 것만 (그때는 아직 어렸을 때), &lt;a class=&#34;link&#34; href=&#34;https://ouuan.github.io/post/from-hexo-to-hugo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;작업&lt;/a&gt;을 그냥 베껴서 넣고, 즐겨찾기에 넣어두고 끄느니 차라리 미루고 미루다가 겨우 생각났다&lt;/p&gt;
&lt;p&gt;Hugo로 마이그레이션할 때부터 플러그인이 너무 부족하다고 생각했는데, 코드 복사 붙여넣기가 안 돼서 많은 노트들을 에버노트에서 블로그로 옮길 때 코드 복사 붙여넣기 작업이 번거워져서 제 블로그에 글을 쓰는 의욕을 많이 꺾였어요&lt;/p&gt;
&lt;h2 id=&#34;서론&#34;&gt;서론
&lt;/h2&gt;&lt;p&gt;원저작자의 초고를 꼼꼼히 살펴보고, 한 번 쭉 읽은 다음 작가 소개도 살펴보자. 와, 대단한 분을 만났네. 칭화대 재학 중인 학부생인데, 어릴 때부터 컴퓨터에 익숙했었나 보네. 아, 갑자기 뭘 해야 할지 기억이 안 나. 관련해서는 저자의 &lt;code&gt;Github&lt;/code&gt; 저장소도 한번 살펴보고, 이 수정된 &lt;code&gt;even&lt;/code&gt; 테마가 지금보다 훨씬 보기 좋고 기능도 많아. 이걸 해봐야겠다. 일단 관련된 코드를 가져와서 합쳐보자.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/add-code-copy-button/2022-02-25-02-08-19.png&#34;
	width=&#34;215&#34;
	height=&#34;150&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;143&#34;
		data-flex-basis=&#34;344px&#34;
	
&gt; &lt;img src=&#34;https://ttf248.life/p/add-code-copy-button/2022-02-25-02-08-40.png&#34;
	width=&#34;217&#34;
	height=&#34;167&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;129&#34;
		data-flex-basis=&#34;311px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;새로운-기능-기사-이력-확인-연관-제출-기록-보기&#34;&gt;새로운 기능: 기사 이력 확인, 연관 제출 기록 보기
&lt;/h3&gt;&lt;p&gt;효과는 괜찮은 편이고, 기사 맨 끝부분에서 체험해 볼 수 있습니다&lt;/p&gt;
&lt;p&gt;손질하기 전에 작가의 원 저장소 기록을 자세히 보지 않았고, 간단하게 병합하면 될 줄 알았는데, 결국 많은 코드를 병합했고, 중간에 충돌도 여러 번 있었고, 무식하게 덮어썼다. 내가 원하는 대로 하기 위해서 프론트엔드와 렌더링 템플릿 코드들이었다.&lt;/p&gt;
&lt;p&gt;저장소 주소: &lt;a class=&#34;link&#34; href=&#34;https://github.com/TianlongXiang/hugo-theme-even&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/TianlongXiang/hugo-theme-even&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;중국어의 함정인데, &lt;code&gt;git&lt;/code&gt;에서 이 파라미터를 조정하지 않으면 현재 문서의 &lt;code&gt;commit hash&lt;/code&gt;를 가져올 수 없어 역사 링크 생성이 실패합니다. 전체 역사를 생성할 때도 자동 통합 스크립트를 수정해야 하고, 현재 저장소의 모든 역사 기록을 가져오도록 해야 합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/TianlongXiang/TianlongXiang.github.io/commit/0d860154de9b335ed88a57d62eedd4b6e3ccbeee&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;기능: 전체 GitHub 저장소 가져오기를 시도하여 기사 마지막 수정 기록을 동적으로 업데이트합니다&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;경로에 중국어가 존재하므로, Hugo GitInfo 설정에서 이 기능을 활성화해야 합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;name: Build Github
run: git config --global core.quotePath false &amp;amp;&amp;amp; hugo -b &amp;quot;https://www.xiangtianlong.com/&amp;quot; -d &amp;quot;github_public&amp;quot; &amp;amp;&amp;amp; ls
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;스타일-조정&#34;&gt;스타일 조정
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;사이트 콘텐츠 너비를 조정해 보세요. 이전 디자인은 모바일과 PC 모두에 적합했지만, 실제로 아무도 휴대폰으로 보지 않고 저조차도 컴퓨터로 보는 것 같아요.&lt;/li&gt;
&lt;li&gt;목록 열 지원 자동 확장/축소&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ouuan&lt;/code&gt;의 코드 기록을 한 시간 반 넘게 봤는데, 복사 버튼을 어떻게 추가하는지 도통 이해가 안 간다&lt;/p&gt;
&lt;p&gt;시간이 흘러 한 달쯤 지나서, 또 이 일이 생각났다&lt;/p&gt;
&lt;p&gt;이 과제가 이해가 안 되면 다른 문제로 베끼고, 어쨌든 따라 하면 알 수 있을 거야. 검색 결과는 꽤 뜻밖이었는데, &lt;code&gt;hugo&lt;/code&gt; 공식 포럼에 복사 버튼을 추가하는 방법에 대한 글이 있길래 가봤더니 논리가 명확하더라고. 그런데 이상한 일이 벌어졌어. 돌아와서 보니 &lt;code&gt;even&lt;/code&gt;으로 렌더링된 코드 블록 스타일이 자료 설명과 달라서 이 부분은 좀 번거로워. 간단히 기록해 둘게.&lt;/p&gt;
&lt;p&gt;기본적인 프론트엔드 개발 지식이 부족해서 모르는 부분은 브라우저의 &lt;code&gt;요소 검사&lt;/code&gt;를 열어 코드와 오른쪽 스타일 정보에 맞춰 분석하며 천천히 로직을 이해하게 되었고, &lt;code&gt;JavaScript&lt;/code&gt;는 이해가 안 가서 콘솔에 로그를 남겼다. 많이 모를 때는 차분히 마음을 가다듬고 천천히 로직을 정리하고 분해하면 결국 해결책이 보인다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pre&lt;/code&gt; 노드가 여러 개 있는데, 여기서은 단일 코드 블록을 의미하며, 테마에서 자체적으로 라인 번호를 렌더링하여 복사 버튼이 두 개로 나타납니다
이런, 관심 주제 자체의 코드 하이라이트 렌더링을 구현하고 싶지만 이 주제 설정에 익숙하지 않네요
공식 홈페이지에서 자료를 봤는데, 반쯤 이해가 됐고, 코드 하이라이트를 제어할 수 있는 마크업 설정이 있다는 걸 알게 됨
설정 파일을 조정해도 계속 안 되고, 렌더링 결과가 예상과 다릅니다
이 설정들 &lt;code&gt;pygmentsOptions&lt;/code&gt;을 발견하고 또 자료를 뒤져서 설정을 조정했다. 우선 행 번호는 제거한다.
사용자 정의 &lt;code&gt;css&lt;/code&gt; 스타일 시트와 사용자 정의 &lt;code&gt;js&lt;/code&gt; 스크립트를 구성합니다
이렇게까지 많은 일을 해놓았으니, 문득 최근에 봤던 색상 조합이 괜찮다는 생각이 들어서 버튼 스타일을 조금 바꿔볼까 하는데: 중국풍 천청색으로 해보자&lt;/p&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:20%&#34; src=&#34;2022-02-25-02-01-22.png&#34; /&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:20%&#34; src=&#34;2022-02-25-02-01-33.png&#34; /&gt;
&lt;p&gt;네 시간이나 붙잡고 있었는데, 이 문장을 보니까 웃겼다. 이렇게 오래 걸릴 리가 있나 싶었거든. 그런데 시간을 보니: 세 시간.&lt;/p&gt;
&lt;h2 id=&#34;참조-링크&#34;&gt;참조 링크
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://ouuan.github.io/post/from-hexo-to-hugo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ouuan.github.io/post/from-hexo-to-hugo/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://gohugobrasil.netlify.app/content-management/syntax-highlighting/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://gohugobrasil.netlify.app/content-management/syntax-highlighting/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://gohugo.io/getting-started/configuration-markup#highlight&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://gohugo.io/getting-started/configuration-markup#highlight&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.dannyguo.com/blog/how-to-add-copy-to-clipboard-buttons-to-code-blocks-in-hugo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.dannyguo.com/blog/how-to-add-copy-to-clipboard-buttons-to-code-blocks-in-hugo/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>우리가 일생을 바쳐 추구하는 것은 무엇인가</title>
        <link>https://ttf248.life/ko/p/we-exhaust-ourselves-chasing/</link>
        <pubDate>Tue, 31 Aug 2021 21:09:58 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/we-exhaust-ourselves-chasing/</guid>
        <description>&lt;p&gt;부인의 교제는, 머리 숙이고 하늘을 우러르며 한 세월을 살아가면서, 때로는 마음속에서 얻기도 하고, 방 안에서 말로 깨우치기도 하며, 때로는 뜻을 실어 보내어 몸을 자유롭게 놓기도 한다&lt;/p&gt;
&lt;p&gt;인생은 한 번 스러울 뿐, 찰나처럼 사라진다. 풀과 나무의 봄날 흥망성쇠와 같고, 새벽녘의 밝음이 동쪽에서 떠서 서쪽으로 지는 것과 같다.&lt;/p&gt;
&lt;p&gt;애써도 이 생에 욕망이 많으니&lt;/p&gt;
&lt;p&gt;어릴 적 시냇가에 누워 연꽃 껍질을 벗기고, 동풍이 불면 연을 날리며, 노란 나비를 쫓아 달려 다녔다&lt;/p&gt;
&lt;p&gt;곁에도 뽕나무 그늘에 앉아 수박 심는 법을 배우고, 돌아와 배불리 먹은 후에는 비를 막는 옷 벗지 않고 밝은 달빛 아래 누워 잔다&lt;/p&gt;
&lt;p&gt;성인이 되면 금방 이름을 떨치고, 아름다운 벗이 함께 하기를 바라며, 돈은 끊이지 않고, 계급은 계속 올라가고, 높은 자리에 앉아 술잔을 기울이며 밤마다 즐거운 노래를 부르기를 희망한다&lt;/p&gt;
&lt;p&gt;늙어서도 건강하게 장수하고 싶다면, 하인은 맞이하고, 어린 자식은 문을 기다리고, 한 판의 바둑과 한 친구, 술 한 병, 그리고 마당 하나 있어 가족들과 더불어 편안하게 즐기며 살고 싶다&lt;/p&gt;
&lt;p&gt;세상이 어찌 이리 다투고 서두르는가, 고작 흩어진 은 몇 냥어치 때문에. 그런데 딱하고 슬픈 마음을 달래주는 것은 바로 그 흩어진 은 몇 냥어치뿐이로다.&lt;/p&gt;
&lt;p&gt;대부분의 사람들은 아직 삶의 고투에 시달리고 있는데, 어디서 의미를 찾을 시간이 있을까?&lt;/p&gt;
&lt;p&gt;사실 인생은 한 번의 경험일 뿐이고, 풀과 나무, 해와 달처럼 욕망의 윤회를 경험하는 것과 같습니다&lt;/p&gt;
&lt;p&gt;삶이 훤히 드러나지 않으면, 장수하는 꿈을 꾸며 대양 한 방울과 같이 작고 하찮게 느껴진다. 내 삶의 덧없음을 슬퍼하며, 장강의 영원함을 부러워한다. 하지만 삶이 훤해지면, 현재를 즐기고 자신에게 만족하며, 늙음이 다가오는 줄조차 모른다.&lt;/p&gt;
&lt;p&gt;당신은 돈과 명예를 추구할 수도 있고, 시와 술과 차를 추구할 수도 있습니다. 당신은 강가의 맑은 바람을 추구할 수도 있고, 산 속의 밝은 달을 추구할 수도 있습니다.&lt;/p&gt;
&lt;p&gt;결과에 지나치게 신경 쓰거나 애쓰지 않아도 괜찮아, 결과는 결국 사라질 테니까&lt;/p&gt;
&lt;p&gt;일평생을 다하여 세상에 왔으니, 가능한 한 세상의 희로애락과 기쁨 슬픔, 탄생 노쇠 병사까지 모두 경험해 보리라&lt;/p&gt;
&lt;p&gt;이 대어해당의 이 문장이 정말 마음에 든다&lt;/p&gt;
&lt;p&gt;우리 일생은 참 짧고 결국 잃어버릴 것이기에, 어차피 조금 더 용감하게 사랑하고, 산을 오르고, 꿈을 좇아보는 건 어떨까. 답이 없는 일들이 많으니, 좀 더 용감하게 해보자.&lt;/p&gt;
&lt;p&gt;《란정집서》와 《적벽부》를 아주 좋아합니다&lt;/p&gt;
&lt;p&gt;매 단석인 흥감의 미연유를 살펴보니, 마치 한 개의 계약을 맺은 듯하고, 지금까지 문을 마주할 때마다 탄식하지 않는 일이 없었으며, 그것을 가슴에 담아내지 못한다. 진실로 일생사와 평생을 허황된 것으로 알지만, 슬퍼하며 애통해하는 것은 어리석은 짓이다. 후세는 현재를 바라보는 것이 또한 현재가 과거를 바라보는 것과 같다. 슬프도다!&lt;/p&gt;</description>
        </item>
        <item>
        <title>증권사 주식 코드 특수 형식 설명</title>
        <link>https://ttf248.life/ko/p/interactive-brokers-stock-code-format-explanation/</link>
        <pubDate>Mon, 30 Aug 2021 17:35:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/interactive-brokers-stock-code-format-explanation/</guid>
        <description>&lt;p&gt;흔하지는 않지만, 시간이 지나면 분명히 만날 수 있을 겁니다. 관련 주식 코드: 버크셔&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;일부 주식 코드 이름에 &lt;code&gt;. &lt;/code&gt; 또는 기타 특수 문자가 포함된 경우, IB(Interactive Brokers)에 &lt;code&gt;Fix&lt;/code&gt; 보고서를 제출할 때 주식 코드 이름을 특정 방식으로 변환해야 합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;BRK/B -&amp;gt; BRK B&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;증권사 팅테크(Tingtech)의 경우, 분석해 보면 변환 규칙이 고정되어 있어 코딩으로 구현할 수 있습니다. 규칙이 고정되지 않은 경우에는 일반적으로 시스템 내부에 해당 매핑 관계를 저장하고, 업무 담당자가 주기적으로 업데이트합니다.&lt;/p&gt;
&lt;h2 id=&#34;참조-링크&#34;&gt;참조 링크
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://ibkr.info/article/462&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;How do I enter the symbol for Berkshire Hathaway Class B shares onto TWS?&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>방황했다</title>
        <link>https://ttf248.life/ko/p/lost-and-confused/</link>
        <pubDate>Thu, 26 Aug 2021 18:01:06 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/lost-and-confused/</guid>
        <description>&lt;p&gt;자주 인생의 어떤 단계에서든 사람은 길을 잃은 듯한 느낌에 빠지곤 한다. 자신이 무엇을 원하는지 모르겠고, 일상적인 업무 속에서 점점 일의 의미를 찾는 것을 잊게 된다. 졸업했을 때의 뜨거운 열정을 떠올리면, 그 때는 망설임 없이 코드를 쓰고 싶다고 말했었다. 사람들의 눈길을 사로잡는 멋진 코드를 만들고 싶다고. 하지만 지금은 업무 관련 일에 더 많이 관여하고 있고, 이는 산업 발전이 가져다준 혜택 덕분이다.&lt;/p&gt;
&lt;p&gt;삶의 관점에 있어서는, 결혼과 출산, 안정적인 가정을 이루는 이런 일들을 아직은 제 생각 범위 안에 포함시키지 않고 있어요. 머릿속에 맴도는 것이 거의 없고, 그저 현재를 즐기는 것만 생각해요. 주말이 되면 조용히 게임을 하는 것을 좋아하고, 종종 하루 종일 집에서 혼자 지내면서 제 작은 세상에 몰두하곤 합니다.&lt;/p&gt;
&lt;p&gt;인생이라는 것은 결국 자신이 열정을 가지고 몰두할 수 있는 일이 있어야 한다&lt;/p&gt;
&lt;h2 id=&#34;집-사기&#34;&gt;집 사기
&lt;/h2&gt;&lt;p&gt;몇 년 전만 해도, 열심히 돈을 모아 내 집을 사야겠다고 생각하며 매일 목표를 위해 아끼고 또 아꼈다. 하지만 집값은 계속 치솟았고, 처음의 불안과 애타는 마음에서 결국 무감각해져서, 집을 산들간에 무거운 짐이 된다고 생각하고 포기했다.&lt;/p&gt;
&lt;h2 id=&#34;돈을-모으다&#34;&gt;돈을 모으다
&lt;/h2&gt;&lt;p&gt;처음에는 돈을 모으는 것이 강력한 성능의 데스크탑 PC를 장만하거나, 오랫동안 갖고 싶었던 카메라를 구입하거나, 즉흥적으로 떠나는 여행과 같은 작은 목표를 달성하기 위한 것이었습니다. 하지만 지금은 저는 돈을 모으는 것에 대해 더욱 무심한 태도를 가지고 있습니다. 일상적인 지출에 더 이상 크게 신경 쓰지 않고, 먹고 싶은 음식이 있으면 가서 먹고, 새로운 것에 대해서도 과감하게 시도해 봅니다.&lt;/p&gt;
&lt;h2 id=&#34;집에-가세요&#34;&gt;집에 가세요
&lt;/h2&gt;&lt;p&gt;결국, 내가 마음속 깊은 곳에서 가장 갈망하는 것은 집으로 돌아가는 것뿐이었다. 특별한 일을 할 필요 없이, 그 익숙한 곳으로 돌아가 가족의 따뜻함과 평온함을 느끼는 것.&lt;/p&gt;</description>
        </item>
        <item>
        <title>홍콩 주식 선물 기본 개념</title>
        <link>https://ttf248.life/ko/p/hong-kong-futures-basics/</link>
        <pubDate>Wed, 18 Aug 2021 10:54:50 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/hong-kong-futures-basics/</guid>
        <description>&lt;p&gt;금융 시장이 끊임없이 변화함에 따라 투자자들은 투자 수익을 늘리기 위해 보다 효과적인 투자 도구를 찾기 시작했습니다. 투자자의 요구를 충족시키기 위해 홍콩거래소(Hong Kong Exchanges and Clearing Limited, HKEX)는 일련의 주식 선물 계약을 출시했으며, 이러한 계약은 홍콩거래소의 전액 출자 자회사인 홍콩합병증권유한회사(HKFE)에 상장된 주식을 대표합니다. 이는 거래량이 높고 활발하게 거래됩니다. 주식 선물을 투자함으로써 투자자는 개별 상장 기업의 성과에 참여하는 동시에 파생상품 시장에서 제공하는 공매도 및 레버리지 효과와 같은 편의를 누릴 수 있습니다.&lt;/p&gt;
&lt;p&gt;주식 선물은 해당 산업의 대표적인 기업을 나타내므로, 투자자는 전체 주식 시장에 비해 특정 산업이 더 좋거나 나쁠 것이라고 판단되면 그 산업의 주식 선물을 선택하여 투자할 수 있습니다&lt;/p&gt;
&lt;h2 id=&#34;기본-정의&#34;&gt;기본 정의
&lt;/h2&gt;&lt;p&gt;증권 선물 계약은 미래의 특정 날짜에 미리 정해진 가격(약정가격)으로 일정한 수량(계약수량)의 주식과 동일한 금융 가치를 사고파는 합의입니다&lt;/p&gt;
&lt;p&gt;모든 주식 선물 계약은 현금으로 정산되며, 계약 만료 시 주식이 교환되지 않습니다&lt;/p&gt;
&lt;h3 id=&#34;계약-만료&#34;&gt;계약 만료
&lt;/h3&gt;&lt;p&gt;계약 만료 시, 계약 체결 가격과 최종 정산 가격의 차이에 계약 승수(또는 곱하기)를 곱한 이익 또는 손실 금액은 계약 보유자의 예금 계좌에서 공제됩니다&lt;/p&gt;
&lt;p&gt;최종 결제 가격은 관련 주식의 최종 거래일 당일 홍콩 증권 거래소에 보고된 공식 종가입니다&lt;/p&gt;
&lt;p&gt;만약 주식 선물 투자자가 계약 만료 전에 포지션을 청산하고자 한다면, 원래 공매도했던 투자자는 단지 선물 계약을 한 장 매수하면 되고, 계약을 매수한 투자자는 선물 계약을 한 장 매도하면 된다&lt;/p&gt;
&lt;h3 id=&#34;보증금&#34;&gt;보증금
&lt;/h3&gt;&lt;p&gt;선물 거래를 할 때, 매수 및 매도 양측은 계약 이행을 보장하기 위해 먼저 기본 증거금을 납부해야 합니다. 청산소는 매일 시장이 마감된 후 미결제 계약의 손익을 시장 가격으로 계산하여 투자자의 증거금 계좌에서 차감액을 산정합니다. 만약 불리한 시장 상황으로 인해 투자자가 손실을 입어 증거금이 규정 수준 이하로 떨어지면, 거래소는 특정 기간 내에 추가 납부를 요구하여 증거금을 원래의 기본 증거금 수준으로 유지하도록 합니다(보충 증거금).&lt;/p&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;거래 비용이 저렴합니다. 주식 선물 계약은 수천 주의 주식 가치와 동등하며, 계약 매매 수수료는 계약 수량에 따라 달라지므로 거래 비용은 계약 가치에 비해 매우 낮습니다.&lt;/li&gt;
&lt;li&gt;공매도 주식 거래가 더 편리해졌습니다. 투자자들은 공매도 주식 선물 계약을 쉽게 거래할 수 있기 때문에 하락장세에서 공매도 주식 선물 계약을 통해 이익을 얻을 수 있습니다.&lt;/li&gt;
&lt;li&gt;증시 안정제도: 시장 유동성 확보를 위해 홍콩 거래소는 지정된 가격 차 내에서 동시에 매수 및 매도 호가를 제시하여 주식 선물 시장의 유동성을 유지하도록 규정하고 있습니다&lt;/li&gt;
&lt;li&gt;레버리지 효과: 투자자는 주식 선물 계약을 사고팔 때 계약 금액의 일부만 담보금으로 지불하면 되므로 헤지 및 거래가 더욱 비용 효율적입니다&lt;/li&gt;
&lt;li&gt;해외 투자자의 외환 위험을 줄이기 위해: 주식 선물 계약은 해외 투자자가 현지 우량주에 투자할 수 있는 방법을 제공합니다. 주식 선물 매매는 전체 계약 가치 대신 증거금만 납부하므로 해외 투자자가 감당해야 할 외환 위험을 크게 줄입니다.&lt;/li&gt;
&lt;li&gt;전자 거래 시스템을 통한 매매: 주식 선물 계약은 상품 거래소의 전자 거래 시스템을 통해 매매됩니다. 모든 매매 주문은 가격 및 시간 순서대로 실행되며, 즉시 매수 가격, 매도 가격 및 체결 가격을 표시하여 시장 투명성을 최고 수준으로 높입니다.&lt;/li&gt;
&lt;li&gt;결제 회사는 이행 보장을 제공합니다. 주식 및 선물 계약은 홍콩 선물 결제 회사(결제 회사)가 등록, 청산하고 이행 보장을 제공하며, 이는 거래소의 완전 소유 자회사입니다. 결제 회사가 모든 미결제 계약에 대한 상대방이므로 거래소 참여자는 상대 위험을 감수할 필요가 없습니다. 그러나 보장의 범위는 거래소가 고객에게 부담하는 재정적 책임에는 적용되지 않으며, 투자자는 브로커를 선택할 때 신중해야 합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;장기-제도&#34;&gt;장기 제도
&lt;/h3&gt;&lt;p&gt;시장 참여자는 개별 주식 선물에 시장 조성자로 등록하여 지정된 최대 스프레드 범위 내에서 매수 및 매도 호가를 동시에 제시할 수 있습니다. 거래소 참가자와 그들의 고객은 개별 주식 선물에 시장 조성자가 매수/매도 호가격을 제공하지 않을 경우, 거래는 시장 호가를 기준으로 이루어질 수 있음을 유의해야 합니다. &lt;strong&gt;투자자는 시장 조성자 등록이 없는 주식 선물 거래 시 유동성 위험이 발생할 수 있으므로 투자 전 신중하게 고려해야 합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;주식-및-선물-거래의-위험&#34;&gt;주식 및 선물 거래의 위험
&lt;/h2&gt;&lt;p&gt;주식 선물은 높은 위험을 수반하며, 주식 선물을 사고파는 행위로 인해 발생할 손실이 증거금보다 클 수 있으며, 단기간 내 추가 증거금을 납부해야 할 수도 있습니다. 증거금 납부가 불가능한 경우, 보유 포지션이 강제 청산될 수 있으며, 발생하는 모든 손실은 본인이 부담하게 됩니다. 따라서 주식 선물 거래의 위험성을 명확히 인지하고 자신에게 적합한지 신중하게 고려해야 합니다. 거래 전에는 자신의 재정 상황과 투자 목표를 고려하여 증권사 또는 금융 자문가에게 주식 및 옵션 계약 매매가 적절한지 문의하는 것이 좋습니다.&lt;/p&gt;
&lt;h2 id=&#34;주석-조정&#34;&gt;주석 조정
&lt;/h2&gt;&lt;p&gt;주식회사가 신주 발행이나 배당 주식 발행 등의 형태로 자본 구조를 변경할 경우, 순자산 기준일 또는 효력 발생일에 주가가 변동될 수 있으며, 이로 인해 미결제 계약이 영향을 받을 수도 있습니다&lt;/p&gt;
&lt;p&gt;다른 조건이 동일하다면 주주가 보유한 포트폴리오 가치는 청산일 이후에도 변하지 않지만, 선물 계약에 대한 매수자나 보유자에게는 상황이 다릅니다. 선물 계약에서 적절한 조정을 하지 않는 한 그렇습니다. 약정 가격을 변경하지 않고 주식 선물 계약의 곱수를 그대로 유지하면 주가 조정은 주식 선물 포지션 가치에 부당하고 불공평한 영향을 미칠 것입니다.&lt;/p&gt;
&lt;p&gt;결제소는 선물의 공정한 가치를 유지하는 원칙에 따라 비율을 조정하며, 중대한 변화가 발생할 경우에만 조정을 합니다. 홍콩 거래소는 조정 세부 사항을 발표하고, 거래소 참여자는 고객에게 해당 변경 사항을 알려야 합니다.&lt;/p&gt;
&lt;h2 id=&#34;주식-선물-계약-개요&#34;&gt;주식 선물 계약 개요
&lt;/h2&gt;&lt;p&gt;증권 선물 계약 개요&lt;/p&gt;
&lt;h2 id=&#34;정보-제공업체-코드&#34;&gt;정보 제공업체 코드
&lt;/h2&gt;&lt;p&gt;정보 제공자 코드&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;p&gt;홍콩증권거래소 - 파생상품/개별주식/주식 선물
&lt;a class=&#34;link&#34; href=&#34;https://www.hkex.com.hk/-/media/HKEX-Market/Products/Listed-Derivatives/Single-Stock/Stock-Futures/Stock-Futures-Information-Sheets/HKEX_Stock_Futures_SC.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;HKEX_Stock_Futures_SC.pdf&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>자본 독점과 온라인 교육 산업의 종말</title>
        <link>https://ttf248.life/ko/p/capital-monopoly-and-the-fall-of-online-education/</link>
        <pubDate>Wed, 28 Jul 2021 14:59:08 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/capital-monopoly-and-the-fall-of-online-education/</guid>
        <description>&lt;p&gt;최근 2거래일 동안 주식 시장이 크게 하락하면서, 새로 진입한 투자자들은 시장의 위험을 실감했습니다. 우리나라는 곧 고령화 단계에 진입할 예정이며, 출산율 데이터는 참담합니다. 관련 전문가들의 예상보다 감소 폭이 훨씬 더 커졌고, 출산율 저해 요인 산업에 대해서는 우리 당도 강력하게 대응할 것입니다.&lt;/p&gt;
&lt;h2 id=&#34;학생-부담-경감&#34;&gt;학생 부담 경감
&lt;/h2&gt;&lt;p&gt;90년대에 태어난 우리들은 많은 특기반이나 과외 없이, 방과 후에는 철없이 뛰어놀았는데, 첫째는 집안 환경이 허락하지 않았고, 둘째는 당시 과외 학원들이 브랜드 이미지를 형성하기 전이었기에 부모님들의 신뢰를 얻지 못했기 때문이다. 눈 깜짝할 사이에 20년이 지나고, 19년부터 시작된 K12 교육의 자본화와 함께 코드처럼 온라인 과외 학원인 원스마트 등은 자본의 지원을 받아 우수한 자원을 모아 명성 있는 과외 학원들을 만들어냈고, 천문학적인 비용에도 불구하고 부모님들의 열기는 꺾이지 않았다.&lt;/p&gt;
&lt;p&gt;도시화의 과정에서 많은 부모님들이 책을 통해 가난한 환경에서 벗어나 계층 상승을 이루셨고, 직장 생활로 바쁘셔서 아이를 제대로 돌볼 시간이 부족합니다. 본인도 경쟁이 치열하고 자녀가 또래보다 뒤쳐지는 것을 원하지 않죠. 가난한 집안에서 성공적인 사람이 나오기는 어렵고, 적절한 학력이 없다면 평범한 가정에서 현재 계층을 유지하거나 다시 계층 상승을 이루기가 쉽지 않습니다. 직업 고등학교에 진학하면 현재 사회 환경에서 계층이 하락하는 것으로 여겨지기 때문에 대부분의 부모님들은 받아들일 수 없습니다.&lt;/p&gt;
&lt;p&gt;왜 과외 수업이 생겼는지, 학부모들이 왜 과외 수업을 필요로 하는지 되돌아보자. 교과서 지식과 예제는 훑어보면 이해하기 쉽지만, 많은 과목은 범위가 넓고 피상적인 개념만 다룰 뿐 깊이 있는 내용은 부족하다. 인재 선발 시스템에는 어느 정도의 차별성이 있어야 하는데, 이로 인해 모순이 발생한다. 시험 문제가 단순히 교과서 지식에서만 출발하면 선별의 역할을 할 수 없으므로, 수평적이고 수직적으로 확장해야 한다. 이러한 내용은 교실에서는 다루기 어려운 부분이며, 이러한 공간의 존재가 과외 수업을 위한 토양을 만들어냈다.&lt;/p&gt;
&lt;p&gt;파일 내용은 많고, 서른 개 세부 규정은 여러 측면을 규정하고 있습니다. 안내 문서 개요 요약:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;전체 과제량과 시간을 대폭 줄여 학생들의 과도한 학습 부담을 덜어준다&lt;/li&gt;
&lt;li&gt;학교 방과후 서비스 수준을 향상시켜 학생들의 다양한 요구를 충족시킨다&lt;/li&gt;
&lt;li&gt;엄격한 규제와 관리를 통해 교외 사교육 활동을 전면적으로 규제한다&lt;/li&gt;
&lt;li&gt;교육 및 교수 품질을 대폭 향상시켜 학생들이 학교에서 충분히 배우고 성장하도록 보장한다&lt;/li&gt;
&lt;li&gt;강화된 지원 정책과 관리 체계를 구축하여 지지 보장 역량을 강화한다&lt;/li&gt;
&lt;li&gt;철저하게 조직하고 시행하여 실질적인 성과를 거두도록 노력한다&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;엘리트-교육&#34;&gt;엘리트 교육
&lt;/h2&gt;&lt;p&gt;교육 업계에는 또 다른 현상이 있는데, 사립 중학교가 점점 늘어나고 있고, 공립학교의 우수한 자원이 부족해지고 있습니다(파생된 학군 주택). 다양한 규모의 교육 그룹들은 높은 연봉으로 우수 교사들을 영입하고, 양질의 교육 환경을 구축하여 점차 각자의 브랜드를 구축합니다. 가장 유명한 것은 &lt;strong&gt;헝수이 모델&lt;/strong&gt;입니다. 고향 평균 회사 급여는 3천여 원이고, 뛰어난 사립 초등학교는 학비가 연간 9천에서 1만 원 정도 합니다. 교육 그룹은 선순환을 형성하는데, 수업료가 비싸더라도 교사가 뛰어나고 학생들의 성적이 좋으니, 수업료를 올리더라도 학부모들은 자녀를 보내오게 됩니다. 공립 학교의 자원(교사) 또한 점차 사립학교로 유치되어 결국 질 낮은 교육의 대명사로 전락하게 됩니다.&lt;/p&gt;
&lt;h2 id=&#34;알고리즘-착취&#34;&gt;알고리즘 착취
&lt;/h2&gt;&lt;p&gt;데이터에 따르면, 메이퇀에 계약된 라이더는 거의 4백만 명이고 활동적인 라이더는 40~50만 명이며, 많은 사람들이 이 일로 생계를 유지하고 있습니다. 끊임없는 알고리즘은 배달 시간을 착취하며 사람을 측정 가능한 단위로 환산하여 알고리즘으로 계산하고 배달원의 한계점을 파악하려 합니다. 스스로를 똑똑하다고 생각하면서 &lt;strong&gt;인간성을 거스르고 자본을 섬기는&lt;/strong&gt; 것입니다. 시장이 이렇게 놓여 있는데, 다 같이 잘 이용하고 지속 가능한 방식으로 운영해야지, &lt;strong&gt;과점과 특권을 장악하고 자본주의의 방식을 따르는, 제멋대로 맹목적인 성장은 결국 막을 내릴 것입니다&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&#34;주식-시장-변동&#34;&gt;주식 시장 변동
&lt;/h2&gt;&lt;p&gt;2021년 7월 24일, 신동방을 대표하는 교육주가 다이빙 쇼를 선보였고, 미국 주식 시장 개장 전 하이브로움이 뒤이어 &lt;strong&gt;주가가 반토막났다&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;우리나라는 점차 고령화 사회로 접어들고 있으며, 출산에 영향을 미치는 각종 사회 현상은 반드시 시정되어야 합니다. 독점과 과로를 조장하는 인터넷 기업들은 벌금을 받았고, 자본이 집중된 교육 산업 또한 규제 대상이 되었습니다.&lt;/p&gt;
&lt;p&gt;자본화가 허용되지 않는 교육 산업에 대한 반대 의견이 빗발치고 있으며, 관련 업계의 상장 자금 조달을 직접 거부하는 움직임에 대한 불만이 만연하다&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;새 동방의 허리 절단&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;요절한 신동방&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;폭락한 美團&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;폭락한 美團(메이퇀)(동방교육 주가.png)&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참조-링크&#34;&gt;참조 링크
&lt;/h2&gt;&lt;p&gt;규제 당국의 집중적인 제재로 온라인 교육 업계가 급격히 멈춰섰다
[국무실 업무국에서《분야별로 학생 과제 부담과 방과후 교육 훈련 부담을 더욱 경감하는 의견》을 발표함]&lt;/p&gt;</description>
        </item>
        <item>
        <title>혼돈 엔지니어링</title>
        <link>https://ttf248.life/ko/p/chaos-engineering/</link>
        <pubDate>Wed, 28 Jul 2021 14:35:07 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/chaos-engineering/</guid>
        <description>&lt;p&gt;시스템 안정성 테스트를 위한 시스템 파괴 모드&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;국내 인터넷 업계는 항상 새로운 것을 만들어내려고 애쓰는데, 가끔 용어를 들으면 대체 뭘 말하는지 떠올리기 어려운 경우가 많다&lt;/p&gt;
&lt;p&gt;부분적으로 기사를 살펴봤는데, 혼돈 엔지니어링 초기 정의에 대한 이 부분이 가장 받아들이기 쉬웠다&lt;/p&gt;
&lt;p&gt;혼돈 엔지니어링의 초기 탐색은 사실 업계에서 꾸준히 있어 왔으며, 장애 테스트나 재해 훈련과 같은 형태로 존재했습니다. 하지만 마이크로서비스 아키텍처의 지속적인 발전과 분산 시스템의 규모가 계속 커짐에 따라 혼돈 엔지니어링이 두각을 나타내기 시작하며 점점 더 중요해지고 있습니다. 넷플릭스가 공식적으로 혼돈 엔지니어링 개념을 제안한 이후 관련 이론도 빠르게 풍부해졌습니다. 또한 넷플릭스의 실천은 혼돈 엔지니어링이 안정성 분야에 가져다주는 엄청난 의미를 증명했습니다.&lt;/p&gt;
&lt;h2 id=&#34;참조-링크&#34;&gt;참조 링크
&lt;/h2&gt;&lt;p&gt;바이트댄스 혼돈 공학 실천 요약&lt;/p&gt;</description>
        </item>
        <item>
        <title>쿠버네티스 pod 일시 중지</title>
        <link>https://ttf248.life/ko/p/kubernetes-pause-pod/</link>
        <pubDate>Mon, 12 Jul 2021 11:23:09 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/kubernetes-pause-pod/</guid>
        <description>&lt;p&gt;배포 컨트롤러는 Kubernetes 클러스터에서 매우 중요한 기능인 Pod의 수평 확장 및 축소 기능을 구현합니다. 이 기능은 기존 클라우드 시대 플랫폼이 반드시 갖춰야 할 역량입니다.&lt;/p&gt;
&lt;p&gt;비즈니스 시나리오에서 데이터베이스의 데이터를 수정하고, 조정 후 Pod 노드를 재시작해야 하는 상황이 발생했습니다. 하지만 Pod가 실행되는 동안 계속해서 테이블 필드를 수정하고 있어, 일시적으로 애플리케이션의 테이블 업데이트를 중단한 다음 데이터를 조정하고 Pod를 복구해야 합니다.&lt;/p&gt;
&lt;p&gt;배포를 강제로 삭제하는 것 외에, 비슷한 중단 효과를 낼 수 있는 다른 방법이 있을까요?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl scale --replicas=0 deployment/&amp;lt;your-deployment&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;답을 보기 전에는 많은 사람들이 상상도 못했을 텐데, 답을 보고 나니 미소를 지으며, 머리가 돌아가지 않는 느낌이 들고 아직 프로세스를 직접 조작하던 시대에 머물러 있어서, 비즈니스 프로세스를 직접 조작하려 하는 것 같은 생각이 든다&lt;/p&gt;
&lt;h2 id=&#34;참조-링크&#34;&gt;참조 링크
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/54821044/how-to-stop-pause-a-pod-in-kubernetes&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;how to stop/pause a pod in kubernetes&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>기금 및 고정수익 자산관리</title>
        <link>https://ttf248.life/ko/p/fund-and-fixed-income-wealth-management/</link>
        <pubDate>Fri, 09 Jul 2021 11:27:06 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/fund-and-fixed-income-wealth-management/</guid>
        <description>&lt;p&gt;90년대에 태어난 우리 세대에게 2008년 금융 위기는 별다른 느낌이 없었던 것 같아요. 어렸고, 투자할 나이도 아니었으니까요. 2015년에 일어난 주식 시장의 고점은 화려하게 시작했지만, 하락세 또한 격렬했고 결국 정부가 시장을 구하기 위해 개입했죠. 동시에 이로 인해 펀드라는 개념이 일반 대중의 시야에 들어오게 되었습니다.&lt;/p&gt;
&lt;h2 id=&#34;앤트파이낸셜과-알리페이&#34;&gt;앤트파이낸셜과 알리페이
&lt;/h2&gt;&lt;p&gt;알리페이는 알리바바 산하의 자연스러운 트래픽 진입로로서, 처음부터 결제 도구라는 포지션으로 시작했고, 펀드 구매 시 대부분의 사람들이 알리페이를 선택했습니다. 알리페이는 성공적으로 펀드 판매를 일반 쇼핑처럼 만들었고, 2019년부터 시작된 소규모 강세장과 펀드 매니저들의 서로 도움을 주고받는 현상은 근본적으로 코로나19로 인한 통화량 급증에 의해 유도된 것입니다. 투자한 사람들은 모두 돈을 벌었고, 투자하지 않은 사람들도 부러움을 느끼며 서둘러 투자했습니다. 새로운 펀드의 규모가 100억 원을 돌파하는 속도가 점점 빨라지고 있으며, 주부들이 펀드를 구매하기 시작하면서 천억 규모의 펀드도 머지않아 현실화될 것입니다.&lt;/p&gt;
&lt;p&gt;개미 투자자를 위한 코드 기반 인터넷 펀드 판매 플랫폼이 인기를 얻기 전에는, 일반적인 사람들이 펀드를 접하게 되는 경우는 은행에 돈을 예금할 때였고, 지점장은 다양한 재테크 상품을 적극적으로 소개했습니다. 하지만 인터넷의 포장과 홍보 페이지 정보 유도, 그리고 펀드 판매 기관이 지불하는 터무니없는 광고비 때문에 알리페이가 제공하는 펀드 광고는 합리성을 완전히 벗어났습니다.&lt;/p&gt;
&lt;p&gt;정상적인 은행 정기 예금 금리 4%, 예전에는 엄청나게 인기 있었던 P2P 투자 8%, 신용카드 대출 이자 12%. 우리의 주인공은 알리페이가 홍보하는 펀드 150%, 250%입니다. 시장이 상승하면 모두들 기쁘지만, 시장이 하락하면 알리페이는 불을 가지고 논다 꼴이죠. 제시된 상승률 데이터는 최근 3년의 수익률만 표기하고, 기존 펀드는 연평균 수익률만 표기했습니다. 왜 매년 평균 수익률을 별도로 표기하지 않을까요? 계산하기 어려운 걸까요? 대답은 아니오입니다. 데이터가 좋지 않아서 고객 구매를 유도하기 어렵기 때문이죠.&lt;/p&gt;
&lt;h2 id=&#34;고정수익-투자&#34;&gt;고정수익 투자
&lt;/h2&gt;&lt;p&gt;중국은 아직 마이너스 금리 시대에 들어서지 않았고, 은행 예금과 국채가 가장 안전한 고정 수입 상품입니다. 순 채권 펀드도 괜찮습니다. 중국의 평균 임금을 알고 싶다면 각 지역 통계청에서 발표하는 데이터를 직접 확인해 보세요. 필자는 간단한 시나리오를 작성합니다. 자산 규모 200만 위안, 연화 수익률 4%로 환산하면 매년 수익이 대부분 도시의 평균 임금보다 높습니다.&lt;/p&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;p&gt;개인적인 경험에서 더 많은 이야기를 시작할 수 있는데, 더 자세히 알고 싶다면 경제 관련 서적을 직접 찾아보는 것을 추천합니다. 맹목적으로 따르지 마세요. 평범한 가정이라면 재무 관리의 핵심은 가치를 보존하는 것이고, 큰 돈을 벌겠다는 위험한 상투를 잡는 것이 아닙니다.&lt;/p&gt;
&lt;p&gt;큰아버지가 늘 하시는 말씀이:&lt;/p&gt;
&lt;p&gt;적절한 시간에 적절한 일을 하면 가장 큰 가치를 얻을 수 있습니다. 공부할 때는 열심히 공부하고 좋은 학위를 받는 것이 전단지를 나눠 돈을 버는 것보다 낫습니다. 졸업 직후에는 일에 진지하게 임하면 연봉 인상이 풍부한 보상을 가져다 줄 것입니다. 가정을 꾸릴 때에는 집안을 돌보는 법을 배워야 합니다.&lt;/p&gt;
&lt;p&gt;관심 있는 분들은 이 연설문 한번 보러 가 보세요: 시간에 대해, 많은 책을 읽어야 답을 찾을 수 있습니다. 본 웹사이트에 원본 텍스트가 있습니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>증권사: 거래 중단</title>
        <link>https://ttf248.life/ko/p/interactive-brokers-trading-interruption/</link>
        <pubDate>Tue, 22 Jun 2021 10:51:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/interactive-brokers-trading-interruption/</guid>
        <description>&lt;p&gt;거래 중단이란 거래가 실행되었고 IB가 거래소로부터 실행 정보를 받은 후, 거래소가 어떤 오류(예: 가격, 전자 처리 과정, 명백한 오류 등)가 발생했다는 것을 인지하고 해당 거래를 중단(취소)하기로 결정하는 것을 의미합니다. 이 과정은 전적으로 거래소에서 결정되고 통제됩니다.&lt;/p&gt;
&lt;p&gt;A busted traderefers to a situation where an execution occurs and IB receives the execution messagefrom the exchange. The exchange then realizes some type of error (Pricing,electronic, obvious error, etc) and rules to bust (cancel) the trade. Theexchange makes these rulings entirely on their own.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;거래 관점에서 볼 때 홍콩 증권 거래소의 거래 취소 및 거래 수정에 해당합니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>거래소 인터페이스 문서 모음</title>
        <link>https://ttf248.life/ko/p/exchange-interface-documentation-summary/</link>
        <pubDate>Wed, 27 Jan 2021 14:35:21 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/exchange-interface-documentation-summary/</guid>
        <description>&lt;p&gt;금융 소프트웨어 개발 5년째, 다루는 것이 대부분 거래소 인터페이스 문서이고 익숙한 것도 홍콩 증권거래소 문서인데, 최근 중화통(中華通) 업무를 처리하면서 일부 중화통 관련 자료를 확인하기 위해 상하이 증권거래소와 선전 증권거래소 자료를 찾아보았다&lt;/p&gt;
&lt;h2 id=&#34;홍콩증권거래소&#34;&gt;홍콩증권거래소
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.hkex.com.hk/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;공식 웹사이트 링크&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;자주-사용됨&#34;&gt;자주 사용됨
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;거래 시간, 거래 및 결제일 달력&lt;/li&gt;
&lt;li&gt;거래 방식&lt;/li&gt;
&lt;li&gt;중국 홍콩 금융 용어 대조표&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;2021-Calendar_pdf_c.pdf&#34; &gt;홍콩항거래일정표 PDF&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;2021-Calendar_csv_c.csv&#34; &gt;홍콩항거래일정표 CSV&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;중국 홍콩 금융 용어 대조표 PDF&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;시장조사 메커니즘 냉각기 발동 기록&lt;/li&gt;
&lt;li&gt;증권 명단: 기본 정보, 증권 분류&lt;/li&gt;
&lt;li&gt;청산경매 거래시간 증권&lt;/li&gt;
&lt;li&gt;시장 변동성 조절 메커니즘(시조메커니즘) 증권&lt;/li&gt;
&lt;li&gt;공매도 가능 지정 증권&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;증권 명단: 기본 정보, 증권 분류 XLSX&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;시장-데이터-인터페이스-문서-홍콩-주식--중화-통과&#34;&gt;시장 데이터 인터페이스 문서: 홍콩 주식 + 중화 통과
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.hkex.com.hk/Services/Market-Data-Services/Infrastructure/Overview?sc_lang=en&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;시장 데이터 서비스 인프라 개요 링크&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;자주 묻는 질문, 개발 매뉴얼 안내, 과거 시장 데이터 인터페이스 문서는 검색창을 통해 다운로드 주소를 얻을 수 있으며, 과거 버전 번호도 검색할 수 있습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;홍콩 주식 증시 데이터 인터페이스 문서&lt;/li&gt;
&lt;li&gt;중국 본토 증시 연결 인터페이스 문서&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;HKEX_OMDC_Binary_Interface_Specifications_v_1,-d-,32c.pdf&#34; &gt;HKEX_OMDC_Binary_Interface_Specifications_v_1,-d-,32c.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;HKEX_OMDC_Developers_Guide_1_11.pdf&#34; &gt;HKEX_OMDC_Developers_Guide_1_11.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;OMDC_Connectivity_Guide_Securities_Market-_Index_datafeed_%28v2_2%29.pdf&#34; &gt;OMDC_Connectivity_Guide_Securities_Market-&lt;em&gt;Index_datafeed&lt;/em&gt;(v2_2).pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;OMD_Interface_Specification_China_Connect_Securities-%28v1-3%29.pdf&#34; &gt;OMD_Interface_Specification_China_Connect_Securities-(v1-3).pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;OMD_Connectivity_Guide_China_Connect_Securities.pdf&#34; &gt;OMD_Connectivity_Guide_China_Connect_Securities.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;OMD_Developers_Guide_China_Connect_Securities.pdf&#34; &gt;OMD_Developers_Guide_China_Connect_Securities.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;호가-인터페이스-문서-홍콩-주식--중화-통&#34;&gt;호가 인터페이스 문서: 홍콩 주식 + 중화 통
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.hkex.com.hk/Services/Trading/Securities/Infrastructure/Overview?sc_lang=en&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;호가 인터페이스 문서 모음 링크&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;홍콩증권거래소 FIX 프로토콜 인터페이스 문서 PDF&lt;/li&gt;
&lt;li&gt;홍콩증권거래소 OCG 이진 거래 인터페이스 사양서 v2.2 (정리본).pdf&lt;/li&gt;
&lt;li&gt;증권거래소 오류 코드 목록 (XLSX)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;[홍콩증권거래소 CCCG FIX 거래 인터페이스 사양서 v1.3(정리본).pdf]&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;HKEx_CCCG_Binary_Trading_Interface_Specifications_v1_3-%28clean%29.pdf&#34; &gt;중화통 이진 인터페이스 문서 PDF&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;상해증권거래소&#34;&gt;상해증권거래소
&lt;/h2&gt;&lt;p&gt;시장 호가 정보 인터페이스 문서&lt;/p&gt;
&lt;p&gt;오류 인터페이스 문서는 다른 메뉴에서 가져옵니다&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;SSE_IS111_ErrorCode_CV3.15.xlsx&#34; &gt;보고서 오류 인터페이스 문서 XLSX&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;심교소&#34;&gt;심교소
&lt;/h2&gt;&lt;p&gt;시장 서비스 기술 지원 인터페이스 문서&lt;/p&gt;
&lt;p&gt;선물거래소는 별도의 오류 정보 설명을 제공하지 않았으며, 호가 인터페이스 문서의 제6장에 부록 설명이 있습니다&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;P020201229686784934466.pdf&#34; &gt;심천 증권 거래소 바이너리 거래 데이터 인터페이스 규격(Ver 1.18) PDF&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;나스닥&#34;&gt;나스닥
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;휴가 일정&lt;/li&gt;
&lt;li&gt;신규 상장 정보&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;수시가&#34;&gt;수시가
&lt;/h2&gt;&lt;p&gt;전체 시장 마감 시세&lt;/p&gt;</description>
        </item>
        <item>
        <title>도커 두 세 가지 일</title>
        <link>https://ttf248.life/ko/p/docker-two-three-things/</link>
        <pubDate>Thu, 21 Jan 2021 09:26:07 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/docker-two-three-things/</guid>
        <description>&lt;p&gt;오랫동안 일하면서 접해왔던 것은 &lt;code&gt;CentOS&lt;/code&gt; 운영체제였고, &lt;code&gt;Mac&lt;/code&gt; 사용자나 &lt;code&gt;Ubuntu&lt;/code&gt; 사용자의 경우 일부 내용은 적용이 불가능할 수 있습니다&lt;/p&gt;
&lt;p&gt;설치 부분은 칭화대학교의 매뉴얼을 참고하시면 됩니다: &lt;a class=&#34;link&#34; href=&#34;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;설치&#34;&gt;설치
&lt;/h2&gt;&lt;p&gt;알 수 없는 신비한 힘으로 인해 국내 설치 시에는 클라우드 공급업체가 제공하는 저장소 주소를 사용하는 것이 좋으며, 여기서는 **알리바바 클라우드(阿里云)**를 추천합니다&lt;/p&gt;
&lt;h3 id=&#34;저장소-소스-주소를-설정하세요&#34;&gt;저장소 소스 주소를 설정하세요
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install yum-utils device-mapper-persistent-data lvm2 &amp;amp;&amp;amp; \
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;최신-버전을-배포하세요&#34;&gt;최신 버전을 배포하세요
&lt;/h3&gt;&lt;p&gt;도커는 일반적으로 사용되는 백그라운드 서비스이므로, 부팅 시 자동 시작으로 설정하는 것을 권장하며, 현재 명령어는 CentOS 7에 적용 가능합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum install -y docker-ce docker-ce-cli containerd.io &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;버전-배포-지정&#34;&gt;버전 배포 지정
&lt;/h3&gt;&lt;p&gt;쿠버네티스와 도커의 배포는 완전히 동기화되지 않았으므로, 다음으로 쿠버네티스를 배포해야 한다면 쿠버네티스 배포 지침을 참고하여 지정된 버전의 도커를 설치하십시오&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum list docker-ce --showduplicates | sort -r
sudo yum install -y docker-ce-18.09.2-3.el7 docker-ce-cli-18.09.2-3.el7 containerd.io-18.09.2-3.el7 &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;일반-사용자가-docker-권한을-추가합니다&#34;&gt;일반 사용자가 Docker 권한을 추가합니다
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo usermod -aG docker ${USER}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;제거&#34;&gt;제거
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum erase -y docker-ce docker-ce-cli containerd.io
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;일상-사용&#34;&gt;일상 사용
&lt;/h2&gt;&lt;h3 id=&#34;미러-가속&#34;&gt;미러 가속
&lt;/h3&gt;&lt;p&gt;여전히 예측할 수 없는 신비한 힘 때문에 이미지를 가져올 때 속도가 빠르지 않다. 이때 국내 클라우드 공급업체들이 나서서 다양한 가속 서비스를 제공하고 있으므로 &lt;strong&gt;알리바바 클라우드&lt;/strong&gt;를 추천한다.&lt;/p&gt;
&lt;p&gt;가속된 주소는 각자 스스로 등록하여 알리바운드 계정을 얻으세요. 이 서비스는 무료이며, 알리바운드는 또한 무료 이미지 빌드 서비스를 제공합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt; /etc/docker/daemon.json &amp;lt;&amp;lt;EOF
{
  &amp;quot;registry-mirrors&amp;quot;: [
    &amp;quot;https://docker.nju.edu.cn&amp;quot;,
    &amp;quot;https://mirror.baidubce.com&amp;quot;,
    &amp;quot;https://docker.m.daocloud.io&amp;quot;,
    &amp;quot;https://docker.mirrors.sjtug.sjtu.edu.cn&amp;quot;
  ]
}
EOF
systemctl daemon-reload &amp;amp;&amp;amp; \
systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;강력-추천하는-제어판&#34;&gt;강력 추천하는 제어판
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker volume create portainer_data &amp;amp;&amp;amp; \
docker run -d --name=portainer --restart=always -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:2.20.3-alpine
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;자주-사용하는-이미지-가져오기-모음&#34;&gt;자주 사용하는 이미지 가져오기 모음
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker pull rancher/rancher:stable &amp;amp;&amp;amp; docker pull  portainer/portainer-ce:2.0.1 &amp;amp;&amp;amp; \
docker pull centos:7 &amp;amp;&amp;amp; docker pull ubuntu:20.04 &amp;amp;&amp;amp; docker pull ubuntu:18.04 &amp;amp;&amp;amp; \
docker pull redis:5 &amp;amp;&amp;amp; docker pull redis:6 &amp;amp;&amp;amp; \
docker pull alpine:3.11 &amp;amp;&amp;amp; docker pull busybox:1.32 &amp;amp;&amp;amp; \
docker pull rabbitmq:3.7-management &amp;amp;&amp;amp; \
docker pull mariadb:10.2 &amp;amp;&amp;amp; \
docker pull nginx:1.18 &amp;amp;&amp;amp; docker pull nginx:1.19 &amp;amp;&amp;amp; \
docker pull mysql:5.6 &amp;amp;&amp;amp; docker pull mysql:8 &amp;amp;&amp;amp; \
docker pull elasticsearch:6.8.11 &amp;amp;&amp;amp; docker pull logstash:6.8.11 &amp;amp;&amp;amp; docker pull kibana:6.8.11 &amp;amp;&amp;amp; \
docker pull zookeeper:3.4 &amp;amp;&amp;amp; \
docker pull influxdb:1.7 &amp;amp;&amp;amp; docker pull grafana/grafana:7.3.1 &amp;amp;&amp;amp; \
docker pull percona:8 &amp;amp;&amp;amp; docker pull percona:5.6 &amp;amp;&amp;amp; \
docker pull cloverzrg/frps-docker:0.34.3 &amp;amp;&amp;amp; docker pull cloverzrg/frpc-docker:0.34.3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;자주-사용되는-명령어-조합&#34;&gt;자주 사용되는 명령어 조합
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/engine/reference/commandline/docker/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.docker.com/engine/reference/commandline/docker/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;컨테이너 실행 상태를 확인하고 &lt;code&gt;format&lt;/code&gt; 매개변수를 추가하여 자세한 컨테이너 정보를 확인합니다. 이때는 이미지 정보는 무시합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker ps --format &amp;quot;{{.Names}}: {{.Ports}}: {{.Size}}&amp;quot;
#portainer: 0.0.0.0:8000-&amp;gt;8000/tcp, 0.0.0.0:9000-&amp;gt;9000/tcp: 0B (virtual 172MB)
#influxdb: 0.0.0.0:8086-&amp;gt;8086/tcp: 183B (virtual 311MB)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;모든 컨테이너 중지&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker stop $(docker ps -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;모든 미러 삭제&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dokcer rmi $(docker images -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;이미지 내보내기&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; &amp;gt; -o XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이미지 내보내고 압축하기&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; | gzip &amp;gt; XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이미지 가져오기&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker load -i XXX.tar
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>리눅스 기반 Jmeter 압력 테스트 환경 구축</title>
        <link>https://ttf248.life/ko/p/linux-setup-jmeter-testing-environment/</link>
        <pubDate>Tue, 22 Dec 2020 10:12:50 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/linux-setup-jmeter-testing-environment/</guid>
        <description>&lt;p&gt;저자는 하드웨어에 대한 깊은 관심을 가지고 있으며, Jmeter를 사용하여 성능 테스트를 진행하고 CentOS 7에 Jmeter, InfluxDB 및 Grafana를 배포하는 과정을 기록했습니다. Jmeter 설치 및 명령어 사용법, InfluxDB의 특징 및 Docker 설치 방법, 그리고 Grafana의 간단한 배포 및 구성 방법을 공유했습니다. 고성능 프로그램 패턴에 대한 경험과 참고 자료를 정리했습니다.&lt;/p&gt;
&lt;h2 id=&#34;배경&#34;&gt;배경
&lt;/h2&gt;&lt;p&gt;다들 아시다시피 저는 하드웨어에 관심이 많습니다. 우연히 테스트팀에서 &lt;code&gt;Jmeter&lt;/code&gt;로 성능 테스트를 하고 있는데, 성능이 올라가지 않는 것을 발견했습니다. 호기심 많은 저라서 단번에 뛰어들어 회사에서 어떻게 압력 테스트를 하는지 살펴보기로 했습니다. 여기서 잠깐 일화 하나를 덧붙이자면, 아주 먼 옛날 오픈소스 차이나에서 어떤 게시글을 봤는데, 보기에도 더 멋진 성능 압력 테스트 그림을 그리는 방법에 대한 내용이었습니다. 테스트팀은 &lt;code&gt;windows&lt;/code&gt; 버전으로 실행되는 테스트를 지켜봤고, 시각화된 &lt;code&gt;TPS&lt;/code&gt; 데이터 표시가 이미 되어 있었습니다. 게다가 웹 패널을 설정하면 어떤 도움이 있을까요?&lt;/p&gt;
&lt;p&gt;생각은 자기만 생각하는 대로인데, 직접 해봐야 알 수 있어&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Don&amp;rsquo;t use GUI mode for load testing! only for Test creation and Test debuggin.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;공식적으로 권장하는 방법은 명령줄을 통해 부하 테스트 보고서를 얻고 GUI 방식으로 표시하는 것인데, 데이터 오류가 발생할 수 있나요? JMeter에 대한 이해는 깊지 않지만, 적어도 &lt;code&gt;Linux&lt;/code&gt; 버전 콘솔 패널을 굴려볼 만한 이유를 찾았습니다&lt;/p&gt;
&lt;p&gt;오픈소스차이나의 게시글인데, 핵심 컴포넌트 배포 방식이 썩 좋지 않고, 설치에 필요한 파일도 공중계정을 팔로우해야 다운로드할 수 있어서, 새세대 청년으로서 당연히 &lt;code&gt;Docker&lt;/code&gt;로 대체했다. 결국 서버가 국내에 있는 것이고, 국경 간 소스 주소 접근 속도는 매우 느리다. 적어도 이미지 서비스는 알리바이가 무료 가속을 제공한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker&lt;/code&gt; 설치 배포에 대한 내용은 여기서는 더 이상 설명하지 않겠습니다. 이전 기사를 참고하시기 바랍니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;다음 내용은 크게 두 부분으로 나뉩니다: 기본 테스트 환경 구성 요소 구축 및 각 구성 요소에 대한 간단한 설명&lt;/p&gt;
&lt;h2 id=&#34;jmeter&#34;&gt;Jmeter
&lt;/h2&gt;&lt;p&gt;Apache JMeter는 Apache 재단에서 개발한 Java 기반의 성능 테스트 도구입니다. 소프트웨어에 대한 부하 테스트를 위해 설계되었으며, 처음에는 웹 애플리케이션 테스트용으로 만들어졌지만 이후 다른 테스트 영역으로 확장되었습니다. 정적 파일, Java 마이크로 서비스, CGI 스크립트, Java 객체, 데이터베이스, FTP 서버 등과 같은 정적 및 동적 리소스를 테스트하는 데 사용할 수 있습니다. JMeter는 다양한 압력 범주에서 서버, 네트워크 또는 객체에 대한 막대한 부하를 시뮬레이션하여 강도를 테스트하고 전반적인 성능을 분석할 수 있습니다. 또한 JMeter는 어설션을 사용하여 스크립트를 생성하여 프로그램이 예상 결과를 반환하는지 확인하여 기능/회귀 테스트를 수행할 수 있습니다. 최대의 유연성을 위해 JMeter는 정규 표현식을 사용하여 어설션을 만들 수 있습니다.&lt;/p&gt;
&lt;p&gt;Apache JMeter는 정적 및 동적인 리소스(파일, 서블릿, Perl 스크립트, Java 객체, 데이터베이스 쿼리, FTP 서버 등)의 성능을 테스트하는 데 사용될 수 있습니다. 서버, 네트워크 또는 객체에 상당한 부하를 가하여 강도를 테스트하거나 다양한 유형의 압력 하에서 전체적인 성능을 분석할 수 있습니다. 성능의 그래프 분석을 수행하거나 대규모 동시 부하 테스트 시 서버/스크립트/객체를 테스트하는 데 사용할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;jmeter-배포-centos7&#34;&gt;JMeter 배포 CentOS7
&lt;/h3&gt;&lt;p&gt;JDK 실행 환경을 설치하고, Jmeter 설치 패키지를 다운로드합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install java-1.8.0-openjdk -y &amp;amp;&amp;amp; \
wget https://mirrors.bfsu.edu.cn/apache//jmeter/binaries/apache-jmeter-5.4.tgz &amp;amp;&amp;amp; tar -xf apache-jmeter-5.4.tgz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;환경 변수 설정&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export JMETER_HOME=$HOME/jmeter/apache-jmeter-5.4
export PATH=$JMETER_HOME/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;지메터-명령어&#34;&gt;지메터 명령어
&lt;/h3&gt;&lt;p&gt;최종적으로 &lt;code&gt;Grafana&lt;/code&gt; 제어판과 연결하면 &lt;code&gt;-l&lt;/code&gt; 파라미터를 입력하지 않고도 &lt;code&gt;web&lt;/code&gt; 제어대에서 데이터를 관찰할 수 있습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;jmeter -n -t /tmp/order-500-10s.jmx -l /tmp/jmeter-order-report-20200109/order-500-10s.jtl
# 一般不用测试结果和测试报告，简化命令
jmeter -n -t /tmp/order-500-10s.jmx
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;influxdb&#34;&gt;InfluxDB
&lt;/h2&gt;&lt;p&gt;InfluxDB는 Go 언어로 작성된 오픈 소스 분산 시계열, 이벤트 및 지표 데이터베이스이며 외부 의존성이 필요 없습니다. 이 데이터베이스는 현재 DevOps 모니터링 데이터, APP 메트릭, IoT 센서 데이터 및 실시간 분석 데이터와 같이 대량의 타임스탬프 데이터를 저장하는 데 주로 사용됩니다.&lt;/p&gt;
&lt;h3 id=&#34;인플럭스db-특징&#34;&gt;인플럭스DB 특징
&lt;/h3&gt;&lt;p&gt;인플럭스DB의 특징은 다음과 같은 9가지로 요약될 수 있습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;구조(패턴) 없음: 열의 개수가 임의일 수 있습니다&lt;/li&gt;
&lt;li&gt;메트릭 저장 기간을 설정할 수 있습니다&lt;/li&gt;
&lt;li&gt;시간 관련 함수(최소값, 최대값, 합계, 개수, 평균, 중앙값 등)를 지원하여 통계 처리에 용이하도록 합니다&lt;/li&gt;
&lt;li&gt;지원되는 저장 정책: 데이터의 삭제 및 수정에 사용할 수 있습니다.(InfluxDB는 데이터 삭제 및 수정 방법을 제공하지 않습니다)&lt;/li&gt;
&lt;li&gt;연속 쿼리 지원: 데이터베이스에서 자동으로 주기적으로 시작되는 일련의 문이며, 저장 정책과 함께 사용하면 InfluxDB 시스템 점유량을 줄일 수 있습니다&lt;/li&gt;
&lt;li&gt;네이티브 HTTP 지원, 내장된 HTTP API;&lt;/li&gt;
&lt;li&gt;SQL과 유사한 구문을 지원합니다&lt;/li&gt;
&lt;li&gt;클러스터 내 데이터 복제 수를 설정할 수 있습니다&lt;/li&gt;
&lt;li&gt;정기 샘플링 데이터를 지원하고, 다른 measurement에 기록하여 데이터의 세분화된 저장 기능을 제공합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;인플럭스db-도커-설치&#34;&gt;인플럭스DB 도커 설치
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir influxdb &amp;amp;&amp;amp; cd influxdb &amp;amp;&amp;amp; \
docker run -p 8086:8086 -d --name influxdb -v $PWD:/var/lib/influxdb influxdb:1.7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;컨테이너에 진입하여 명령을 실행하고, 수동으로 데이터베이스를 생성합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;root@bce0a55bbc72:/# influx
Connected to http://localhost:8086 version 1.7.10
InfluxDB shell version: 1.7.10
&amp;gt; 交互面板执行命令
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;인플럭스db-데이터베이스-및-사용자-생성&#34;&gt;인플럭스DB 데이터베이스 및 사용자 생성
&lt;/h3&gt;&lt;p&gt;데이터베이스 생성: create database jmeter_t2
데이터베이스 확인:
데이터베이스 전환: use jmeter_t2
사용자 생성: 비밀번호 &amp;lsquo;admin&amp;rsquo;으로 사용자 &amp;ldquo;admin&amp;quot;을 모든 권한으로 생성
사용자 보기&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; show users
user  admin
----  -----
admin true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;사용자 권한 &lt;code&gt;admin&lt;/code&gt;이 &lt;code&gt;true&lt;/code&gt;로 표시되면 데이터베이스 준비 작업은 완료되었습니다&lt;/p&gt;
&lt;h2 id=&#34;grafana&#34;&gt;Grafana
&lt;/h2&gt;&lt;p&gt;테스트 케이스를 작성하다 보니 차트 표시가 크게 필요하지 않다는 것을 알게 되었고, 인터페이스의 &lt;code&gt;tps&lt;/code&gt; 데이터는 명령줄에서 실행할 때 이미 관찰할 수 있으며, 더 중요한 것은 프로그램 내부의 소요 시간을 알고 싶다는 것이었습니다&lt;/p&gt;
&lt;p&gt;간단하게 &lt;code&gt;Grafana&lt;/code&gt; 대시보드 패널을 배포하고, 설정 파일을 가져와서 &lt;code&gt;InfluxDB&lt;/code&gt;에 연결합니다&lt;/p&gt;
&lt;p&gt;콘솔은 태그를 통해 테스트 결과를 필터링할 수 있으며, 일반적으로 &lt;code&gt;InfluxDB&lt;/code&gt; 데이터베이스 하나만 구성하면 됩니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;애플리케이션 이름&lt;/li&gt;
&lt;li&gt;테스트 사례 이름&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/linux-setup-jmeter-testing-environment/Snipaste_2021-03-09_19-44-22.png&#34;
	width=&#34;861&#34;
	height=&#34;357&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;grafana&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;241&#34;
		data-flex-basis=&#34;578px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -d --name=grafana -p 3000:3000 grafana/grafana:7.3.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;웹 버전은 샘플러 간격으로 인해 계산된 &lt;code&gt;TPS&lt;/code&gt; 및 관련 수치와 &lt;code&gt;Jmeter&lt;/code&gt; 집계 보고서가 일치하지 않을 수 있습니다. 참고 링크: &lt;a class=&#34;link&#34; href=&#34;https://www.vinsguru.com/jmeter-real-time-results-influxdb-grafana/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.vinsguru.com/jmeter-real-time-results-influxdb-grafana/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;자료에는 &lt;code&gt;리스너&lt;/code&gt;를 사용자 정의하는 방법도 설명되어 있습니다&lt;/p&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;고성능 프로그램 모드는 필연적으로 단일 루프 스레드이며, 어떠한 락, 대기열에 삽입 및 삭제도 불필요한 성능 손실을 야기한다&lt;/li&gt;
&lt;li&gt;핵심 비즈니스 로직의 처리 시간은 다른 코드 도입에 소요되는 시간보다 길기 때문에, 동시성만이 효율성을 효과적으로 높일 수 있다. 핵심 처리 시간이 충분히 짧다면 다른 코드를 신중하게 도입하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;JMeter 시리즈의 JMeter + Grafana + InfluxDB 실시간 모니터링&lt;/li&gt;
&lt;li&gt;인플럭스DB 공식 이미지&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/r/grafana/grafana&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Grafana 공식 이미지&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://jmeter.apache.org/download_jmeter.cgi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;JMeter 공식 웹사이트&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@jasonli.studio/to-install-apache-jmeter-in-centos7-294bc72a97ba&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;To install Apache JMeter in CentOS7&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>레드햇과 CentOS 라이프사이클</title>
        <link>https://ttf248.life/ko/p/redhat-centos-lifecycle/</link>
        <pubDate>Tue, 21 Jul 2020 20:02:35 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/redhat-centos-lifecycle/</guid>
        <description>&lt;p&gt;온라인 생산 환경 운영체제로는 Red Hat과 CentOS가 주류 선택입니다. 두 시스템의 라이프사이클에 대한 공식 웹사이트 링크를 기록하고 CentOS 8에서 CentOS 8 Stream으로 업그레이드한 경험을 공유합니다.&lt;/p&gt;
&lt;h2 id=&#34;서론&#34;&gt;서론
&lt;/h2&gt;&lt;p&gt;온라인 생산 환경 운영체제는 현재 국내 환경에서 보면 Red Hat과 CentOS가 주류 선택입니다. 지난 2년 동안 Red Hat 6의 지원 종료를 경험했으므로, 이 두 시스템의 라이프사이클 공식 웹사이트 링크를 기록합니다.&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://access.redhat.com/support/policy/updates/errata&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Red Hat Enterprise Linux Life Cycle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;CentOS 제품 사양&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;레드햇 엔터프라이즈 리눅스(RHEL)와 CentOS는 기업용 서버 운영체제에서 널리 사용되는 선택입니다. RHEL은 안정적인 지원 및 업데이트 주기를 제공하며, 기업 환경에 적합합니다. CentOS는 RHEL의 커뮤니티 버전으로 유사한 기능과 안정성을 제공하지만 공식적인 지원은 없습니다.&lt;/p&gt;
&lt;h2 id=&#34;계속-봐&#34;&gt;계속 봐
&lt;/h2&gt;&lt;p&gt;이 원고를 게시할 때, 두 년 후 업데이트하게 될 줄은 상상도 못 했습니다. 이틀 전까지만 해도 일상적으로 사용하는 가상 머신을 CentOS 8에서 CentOS 8 Stream으로 업그레이드했습니다. 생산 환경에서는 어떻게 선택하든 제가 자세히 말씀드리기는 어렵고, 로컬 환경은 최신 버전을 추구하는 편입니다.&lt;/p&gt;
&lt;p&gt;CentOS 8 Stream은 지속적인 릴리스 버전으로, 기존 CentOS보다 빠른 업데이트와 새로운 기능을 제공하며 개발 및 테스트 환경에 적합합니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>미국과 중국 간 무역 전쟁</title>
        <link>https://ttf248.life/ko/p/us-china-trade-war/</link>
        <pubDate>Tue, 21 Jul 2020 19:52:41 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/us-china-trade-war/</guid>
        <description>&lt;p&gt;먼저 본론과 거리가 있는 이야기를 좀 할게요. 중국 특색 사회주의와 자본주의의 차이점에 대해 말이죠. 선대들의 입에서 부를 쌓으려면 먼저 도로를 정비해야 한다는 말을 들어봤을 겁니다. 중국의 기반 시설 건설은 국가가 비용을 지출하는 것이고, 자본주의 사회에서는 이런 것들을 모두 위탁할 텐데요. 이익이 전혀 없는 외딴 지역이라면 기업들이 맡아줄 의사가 없을 겁니다. 너무 많이 이야기하면 현재 기사 주제에서 벗어나는 감이 있습니다. 일반인들은 무역 전쟁이 생활에 큰 영향을 미치지 않는다고 생각할 수도 있지만, 사실 우리나라는 고성능 제조업이 오랫동안 상대적으로 취약했습니다. 제가 종사하는 IT 분야를 보면 메모리, 하드 디스크, CPU, 그래픽 카드 등 컴퓨터를 조립하기 위한 핵심 부품들은 모두 해외 공장에서 생산되고, 이러한 부품 비용은 전체 가격의 50%를 차지합니다. 고성능 제조업은 반드시 필요합니다. 중국과 미국의 충돌은 피할 수 없을 것입니다.&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;미국과 중국 간의 무역 전쟁 (2018년 발발)&lt;/li&gt;
&lt;li&gt;중국제조 2025&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;위키백과&#34;&gt;위키백과
&lt;/h2&gt;&lt;p&gt;2018년에서 2020년 사이에 발생한 미중 무역 전쟁(영어: China–United States trade war)은, 약칭으로 미중 무역 분쟁, 미중 무역 마찰, 미중 무역 소송 또는 미중 무역 전쟁이라고도 불리며, 중화인민공화국과 미국 간의 무역 전쟁이다&lt;/p&gt;
&lt;p&gt;미국 대통령 도널드 트럼프가 2018년 3월 22일 메모를 서명하면서 “중국이 미국의 지적재산과 영업 비밀을 훔치고 있다”라고 주장하고, 1974년 무역법 제301조에 따라 미국무역대표부가 중국으로부터 수입되는 상품에 대해 관세를 부과하도록 요구했으며, 관련 상품의 총 가치는 약 600억 달러에 달했다. 이에 따라 미국은 2018년 7월 6일 중국으로 수출되는 340억 달러 규모의 상품에 대해 25%의 추가 관세를 부과했다. 중국 상무부는 같은 날 반제재 조치로 미국으로부터 수입되는 340억 달러 규모의 상품에 대해 25%의 추가 관세를 부과했으며, 여기에는 미국이 중국으로 가장 많이 수출하는 대두가 포함되어 있었다.&lt;/p&gt;
&lt;p&gt;미국과 중국 양측은 2018년 5월에 무역 전쟁을 중단하는 데 합의하고 화해를 모색하는 공동 성명을 발표한 바 있었다. 그러나 미국 무역대표부는 그 후 6월 16일에 첫 번째로 5억 달러 규모의 중국산 상품에 대한 세금 부과 목록을 발표하며 기존 10% 세율을 25%로 인상했다. 이에 따라 중국 국무원 관세정책위원회는 동등한 보복 조치를 취했으며, 중국 상무부 또한 미국으로 수출되는 여러 품목에 대한 반덤핑 조사 재개를 중단하지 않았다. 7월 6일, 트럼프 정부는 공식적으로 첫 번째 세금 부과 목록에 포함된 340억 달러 규모의 중국산 상품에 대해 25% 관세를 부과했으며, 이는 트럼프 행정부의 대중국 관세 정책이 본격적으로 시행되는 것을 의미했다(나머지 160억 달러 규모의 상품은 8월 23일에 25% 관세가 부과되었다). 중국 상무부는 그 후 성명에서 “미국은 세계 무역 규칙을 위반하여 역사상 최대 규모의 무역 전쟁을 벌였다”고 지적했다. 또한 중국 세관총서는 미국의 관세 부과 조치가 시행된 즉시 반격 조치를 취했다고 밝혔다.&lt;/p&gt;
&lt;p&gt;12월 1일, G20 부에노스아이레스 정상회담에서 양국 지도자 시진핑과 도널드 트럼프는 합의를 이루어 90일간의 협상을 진행하고 협상 기간 동안 새로운 무역 조치를 중단하기로 동의했다. 2019년 3월 1일 마감 기한이 만료된 후, 미국 측은 상당한 진전이 있다고 발표하며 새로운 무역 조치 중단 기간을 연장했다.&lt;/p&gt;
&lt;p&gt;2019년 5월 5일, 미국 대통령 도널드 트럼프는 추가로 약 2천억 달러 규모의 중국산 제품에 대해 총 25억 달러에 해당하는 25% 관세를 부과한다고 발표했습니다. 이 조치는 6월 1일부터 미국 항구에 도착하는 중국 상품에 적용되었습니다. 5월 13일, 중국 국무원 세관세정책위원회는 6월 1일부터 원산지가 미국인 일부 수입품에 대해 5%에서 25%로 관세를 인상한다고 발표했습니다. 6월 1일, 미 무역대표부 사무실은 미국의 추가적인 25% 관세 부과 시점을 6월 15일로 연기했으며, 중국 국무원 세관세정책위원회는 중국의 추가 관세 부과 조치는 6월 1일에 예정대로 시행된다고 밝혔습니다.&lt;/p&gt;
&lt;p&gt;6월 29일, 양국 지도자인 시진핑과 트럼프는 G20 오사카 정상회담에서 회담을 갖고 경貿 협상 재개를 동의했으며, 미국은 중국 제품에 대한 새로운 관세를 부과하지 않기로 합의했다&lt;/p&gt;
&lt;p&gt;8월 1일, 트럼프 정부가 중국 정부의 미국 농산물 구매 진행 상황에 불만을 표시하면서 트럼프는 트위터에서 2019년 9월 1일부터 잔여 3천억 달러 규모의 모든 중국 제품에 대해 10% 관세를 부과할 것이라고 발표했습니다. 8월 5일, 위안화 대비 달러 환율이 7선 아래로 떨어졌습니다. 같은 날 미국 재무부는 중국을 환율 조작국으로 지정했습니다. 이후 중국 정부는 미국 농산물 구매를 중단하고 8월 24일에 약 750억 달러 규모의 미국 상품에 대해 10% 또는 5% 관세를 부과하고, 미국 자동차 및 부품에 대한 관세 재부과를 발표했습니다. 이에 대해 미국은 다음 날 3천억 달러 규모의 중국 제품에 대한 기존 세율을 15%로 인상하고, 현재 2500억 달러 규모의 중국 제품에 대한 25% 관세를 30%로 인상하는 방식으로 대응했지만, 이후 중단되었습니다.&lt;/p&gt;
&lt;p&gt;2020년 1월 16일, 미중 양국은 최초 단계 무역 협약을 체결했다&lt;/p&gt;</description>
        </item>
        <item>
        <title>컴퓨터 조립 그거</title>
        <link>https://ttf248.life/ko/p/computer-assembly-tips/</link>
        <pubDate>Sat, 18 Jul 2020 14:33:46 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/computer-assembly-tips/</guid>
        <description>&lt;p&gt;저자는 어릴 때부터 컴퓨터 조립에 대한 관심이 많았으며, 대학교 이후로 하드웨어 조립을 접하기 시작했습니다. CPU, SSD, HDD, 메모리 주파수 등 하드웨어 성능 비교 웹사이트 및 구매 추천 정보를 제공하고, 하드웨어 선택 경험과 주의사항을 공유합니다.&lt;/p&gt;
&lt;h3 id=&#34;인연은-말로-다-할-수-없네&#34;&gt;인연은 말로 다 할 수 없네
&lt;/h3&gt;&lt;p&gt;어렸을 때부터 내 컴퓨터를 조립하고 싶었는데, 안타깝게도 경제적인 상황이 허락하지 않았다. 어렵게 대학에 와서는 휴대성을 고려해서 노트북으로 샀다. 정확한 시점을 꼽자면, 고향 도서관에서 시작된 것 같은데. 어쨌든 시내 수준의 도서관이라 전자 열람실(사실 가본 적은 없고 유료였다고 함)도 있었지만, 잡지 열람실에서 《大众软件》이나 《电脑报》같은 잡지를 보게 되었는데, 컴퓨터를 많이 접해보지 못했던 나에게는 거의 신과 같은 과학 지식 자료였다. 몬스터 사냥하는 챕터를 보면 내 컴퓨터를 만들어서 같이 몬스터를 잡아 주력 딜러가 되고 싶었고, 첨단 기술에 대한 내용을 보면 책에서 보던 대로 따라 하면 설명된 효과를 낼 수 있을 거라고 상상했다(해킹 도구 사용에 대한 이야기). 물론 고등학교 과제가 많았고, 내가 알던 한도 내에서도 공부도 해야 하고 놀이도 해야 하니, 순수하고 천진난만하게 지냈다고 할 수 있다. 핑계로 도서관에 가서 책을 보러 가는 척하면 작은 가방 하나 들고 시내를 걸어가서 도서관에 갔다. 도착해서 에어컨을 틀고 소설, 만화, 게임 잡지를 보거나 가끔은 진지한 책도 읽었다.&lt;/p&gt;
&lt;p&gt;나이가 들면 건망증이 생기기 쉬운데, 도서관에서 벌어진 일은 처음 있는 일이 아니었다. 중학교 때 친척 집에서 컴퓨터를 조립한 적이 있는데, 그때 그 기계를 조립한 이유가 무엇이었는지 기억도 안 난다. 운영체제는 윈도우 2003이고, 게임은 시스템에 내장된 카드 + 문명 시대로 이루어져 있었다. 온갖 “꾀와 용기”를 발휘해서 열쇠를 훔쳐 동생과 함께 게임을 하곤 했다.&lt;/p&gt;
&lt;p&gt;방금 중학교에 입학했는데 바로 컴퓨터 기초 교육이 있었고, 나중에 전학하면서 컴퓨터 경시대회라는 개념을 조금 접하게 됐어. 고등학교 때에는 NOIP 한 번 치뤘지. 여기서 얘기를 하면 꼭 해야 할 말이 있는데, 동문들의 힘이 정말 대단했어. 고등학교의 컴퓨터 건물은 동문의 기부로 지어졌고, 컴퓨터 교실과 도서관을 포함하고 있어. 그때는 사실 국내 인터넷 물결의 초기에 해당했지. 학교 관계자들도 컴퓨터 경시대회 참여를 지원했는데, 어쨌든 앞선 두 학년 선배들 여러 명이 컴퓨터를 통해 명문 대학에 진학했으니까.&lt;/p&gt;
&lt;p&gt;나와 컴퓨터에 대한 일들을 이렇게 되돌아본 적은 없었다. 졸업 후 자동화 전공을 과감하게 포기하고 컴퓨터 업계로 넘어간 것도 이해가 된다. 이미 씨앗이 뿌려져 있었고, 다만 관련자들은 미처 알지 못했을 뿐이다. 어릴 때부터 많이 접해 두었기에 자신이 대단하다고 생각했지만, 사실은 겉핱기만 할 줄 알았고, 가장 큰 장점은 처음의 열정이었다.&lt;/p&gt;
&lt;h3 id=&#34;하드웨어-조립&#34;&gt;하드웨어 조립
&lt;/h3&gt;&lt;p&gt;카드바, 칩헬, 지후 컴퓨터 조립 게시판을 많이 둘러보면 초보자도 비교적 간단하게 자신이 원하는 기계 목록을 작성할 수 있습니다. 2019년 이후 CPU를 구매하는데 경제적인 여유가 없다면 더 높은 성능을 원한다면 AMD를 우선적으로 선택하세요.&lt;/p&gt;
&lt;p&gt;자주 사용하는 하드웨어 성능 비교 웹사이트를 추천합니다: &lt;a class=&#34;link&#34; href=&#34;https://cpu.userbenchmark.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cpu.userbenchmark.com/&lt;/a&gt; 가격은 거의 중고나라 미국 버전과 비교할 수 있습니다. 진정한 고수라면 중고나라에서 중고 제품을 구매하면 훨씬 저렴하게 살 수 있습니다. 하지만 잘 모르는 분들은 중고나라를 이용하지 않는 것이 좋습니다. 저는 가짜 메모리를 구매했는데, 현재 사용하면서는 문제가 없는 것 같지만 정확히는 모르겠습니다. 모델과 파라미터가 완전히 일치하지 않습니다.&lt;/p&gt;
&lt;h4 id=&#34;sn550-vs-sn750&#34;&gt;SN550 VS SN750
&lt;/h4&gt;&lt;p&gt;SN550 1TB 용량과 SN750 1TB 용량의 차이는 지속적인 읽기/쓰기 속도가 두 배 정도 다르다는 것인데, 하나는 850MB이고 다른 하나는 1.6GB입니다. 하지만 일상 사용에서는 차이가 없는데, 둘 다 4K 성능은 동일하기 때문입니다. 물론 여기서 말하는 것은 1TB 용량의 SN550이고, 500G와 250G 모델은 순차 읽기/쓰기 속도가 더 느립니다. 사실 돈을 신경 쓰지 않는다면 일상 사용에는 SN550로 충분하다고 생각합니다. 제가 이 제품을 사지 않은 가장 큰 이유는 순차 읽기/쓰기 속도 때문이 아니라 최대 용량이 1TB인 것에 있고, SN750은 2TB 용량을 제공하기 때문입니다. 저에게는 추가 확장 없이 메인보드의 M.2 Nvme 슬롯이 이러한 SSD의 가격 차이보다 더 가치 있다고 생각합니다.&lt;/p&gt;
&lt;p&gt;여러 누리꾼들의 결론을 종합해 볼 때, 어댑터 하나를 구입하면 B150 메인보드도 M.2 인터페이스의 SSD를 지원할 수 있습니다&lt;/p&gt;
&lt;h4 id=&#34;기계식-하드-디스크-구매-가이드&#34;&gt;기계식 하드 디스크 구매 가이드
&lt;/h4&gt;&lt;p&gt;기계식 하드 디스크는 현재 가격이 안정적인 추세이며, 대용량 저장 공간이 필요한 사용자라면 적절한 기계식 하드 디스크를 선택해야 합니다. 자주 자료를 다운로드하는 사용자에게는 엔터프라이즈급 하드 디스크를 추천하며, 흔히 볼 수 있는 제품으로는 다음과 같은 것들이 있습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서부 데이터 디스크&lt;/li&gt;
&lt;li&gt;시게 exos&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;대용량 기계식 하드 디스크는 파티션을 나누어 사용하는 것이 좋습니다. 잦은 다운로드 작업은 특정 파티션에서 고정하고, 나중에 불량 섹터가 발생하면 해당 파티션만 버리면 되므로 수명을 효과적으로 연장할 수 있습니다.&lt;/p&gt;
&lt;p&gt;시지 게이트 &lt;a class=&#34;link&#34; href=&#34;https://www.seagate.com/cn/zh/enterprise-storage/exos-drives/exos-e-drives/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;공식 소개&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;시게 기업용 하드 디스크 개요&lt;/p&gt;
&lt;p&gt;시게 기업용 하드 디스크 개요&lt;/p&gt;
&lt;h4 id=&#34;메모리-주파수&#34;&gt;메모리 주파수
&lt;/h4&gt;&lt;p&gt;일상 업무의 관점에서 보면, 빈도는 성능에 큰 영향을 미치지 않습니다&lt;/p&gt;
&lt;p&gt;메모리 타이밍(메모리.png) ! [짜충 메모리](짜충 메모리.png)&lt;/p&gt;
&lt;p&gt;메모리 타이밍(Memory timings 또는 RAM timings)은 동기식 동적 랜덤 액세스 메모리(SDRAM) 성능을 설명하는 네 가지 매개변수: CL, TRCD, TRP 및 TRAS로, 클럭 주기 단위입니다. 이들은 일반적으로 7-8-8-24와 같이 하이픈으로 구분된 네 개의 숫자로 표시됩니다. 네 번째 매개변수(RAS)는 종종 생략되며 때로는 다섯 번째 매개변수인 명령 레이트(Command rate)가 추가되기도 하는데, 이는 보통 2T 또는 1T로 표기되거나 2N, 1N으로 쓰이기도 합니다. 이러한 매개변수는 랜덤 액세스 메모리 속도에 영향을 미치는 지연 시간(latency)을 지정합니다. 낮은 숫자는 일반적으로 더 빠른 성능을 의미합니다. 시스템 성능을 결정하는 최종 요소는 실제 지연 시간이며, 이는 보통 나노초 단위로 표시됩니다.&lt;/p&gt;
&lt;p&gt;메모리 타이밍을 실제 지연으로 변환할 때는 시계 주기 단위로 측정된다는 점이 가장 중요합니다. 시계 주기의 시간을 모르면 숫자 세트가 다른 숫자 세트보다 빠른지 알 수 없습니다.&lt;/p&gt;
&lt;p&gt;예를 들어, DDR3-2000 메모리의 클럭 주파수는 1000MHz이고 클럭 주기는 1ns입니다. 이 1ns의 클럭을 기준으로 CL=7은 절대 지연 7ns를 나타냅니다. 반면에 더 빠른 DDR3-2666(클럭 1333MHz, 주기 0.75ns)은 더 큰 CL=9를 사용할 수 있지만, 결과적으로 절대 지연은 6.75ns로 더 짧습니다.&lt;/p&gt;
&lt;p&gt;현대 DIMM은 자동 구성 권장 메모리 타이밍이 포함된 직렬 존재 감지(SPD) ROM 칩을 포함합니다. PC의 BIOS는 성능 향상을 위해 타이밍을 조정할 수 있지만(안정성 저하 위험이 있음), 특정 상황에서는 안정성을 높일 수도 있습니다(예: 권장 타이밍 사용).&lt;/p&gt;
&lt;p&gt;주의: 메모리 대역폭은 메모리의 처리량을 측정하며, 일반적으로 지연 시간보다는 전송 속도에 의해 제한됩니다. SDRAM의 여러 내부 bank를 교차적으로 접근하면 이론상 최고 속도로 연속적인 데이터 전송이 가능합니다. 대역폭을 늘리기 위해서는 지연 시간을 증가시킬 수 있습니다. 구체적으로 말해, 새로운 DDR 메모리 세대는 높은 전송 속도를 가지고 있지만 절대 지연 시간은 크게 변하지 않습니다. 특히 시장에 처음 출시된 제품들은 이전 세대보다 더 긴 지연 시간을 가지는 경향이 있습니다.&lt;/p&gt;
&lt;p&gt;메모리 지연이 증가하더라도 메모리 대역폭을 늘리면 다중 프로세서 또는 여러 실행 스레드를 가진 컴퓨터 시스템의 성능을 향상시킬 수 있습니다. 더 높은 대역폭은 전용 그래픽 메모리가 없는 통합 그래픽 카드의 성능도 높여줄 것입니다.&lt;/p&gt;
&lt;p&gt;메모리 타이밍 파라미터 설명&lt;/p&gt;
&lt;h3 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;메모리 타이밍 파라미터 설명&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>사이트 가속 및 도메인 설정</title>
        <link>https://ttf248.life/ko/p/website-acceleration-and-domain-setup/</link>
        <pubDate>Sat, 20 Jun 2020 10:36:27 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/website-acceleration-and-domain-setup/</guid>
        <description>&lt;p&gt;국내에서 GitHub Pages 접속이 느려서, 저자는 개인 도메인을 신청하고 국내 클라우드 호스트 제공업체의 CDN 가속 서비스를 구매했습니다. 설정 과정에서 www 서브도메인에 접근할 수 없는 문제가 발생했는데, 최종적으로 와일드카드 도메인 해석을 삭제하고 개별 2차 도메인을 설정하여 해결했습니다. 저자는 또한 CDN 가속의 원리와 설정 경험, 그리고 Nginx 리버스 프록시를 사용한 시도와 그 교훈을 공유했습니다.&lt;/p&gt;
&lt;h3 id=&#34;배경&#34;&gt;배경
&lt;/h3&gt;&lt;p&gt;GitHub Pages에 호스팅되어 있는데, 몇 가지 잘 알려진 이유로 GitHub Pages의 국내 접속이 약간 느립니다. 그래서 개인 도메인을 신청하고 국내 클라우드 호스트 제공업체의 CDN 가속 서비스를 구매했습니다. 가속 서비스를 설정하면서 개발 머신에 docker, frp, k8s 등 여러 서비스가 배포되어 있고, 이 서비스들은 모두 관련 대시보드를 가지고 있다는 것을 떠올랐습니다. 낭비하지 않겠다는 원칙을 가지고 몇 개의 리버스 프록시를 구성하여 모든 것을 하위 도메인에 연결했습니다.&lt;/p&gt;
&lt;p&gt;二级 도메인을 사용하고 있는데 갑자기 www 서브도메인에 접속할 수 없게 되었고, 알리바바 클라우드에서 DNS 설정이 &lt;a class=&#34;link&#34; href=&#34;https://www.xiangtianlong.com&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;www.xiangtianlong.com&lt;/a&gt;과 xiangtianlong.com으로 동시에 해석되도록 되어 있습니다. CDN 가속을 아직 활성화하지 않았을 때는 두 도메인이 모두 정상적으로 작동했습니다.&lt;/p&gt;
&lt;p&gt;CDN 가속을 설정할 때, 2차 도메인이 너무 많아서 와일드카드 도메인 규칙을 활성화했고, 모두 개발 머신으로 라우팅했는데, 그 결과 www라는 2차 도메인도 함께 접속이 안 되게 됐습니다. 네, 맞아요, www 접두사도 2차 도메인입니다. 실제 웹사이트는 GitHub Pages에 배포되어 있고, 개발 머신에는 웹사이트 캐시 정보가 전혀 없습니다.&lt;/p&gt;
&lt;p&gt;개발 환경에 사이트를 배포하지 않아도 되는 이유는 정적 블로그이고, GitHub에서 제공하는 action을 활용하면 자동으로 통합되어 게시되니 정말 좋네요&lt;/p&gt;
&lt;h3 id=&#34;도메인&#34;&gt;도메인
&lt;/h3&gt;&lt;p&gt;비전문적인 웹 개발에서는 도메인에 대한 이해가 SEO나 교차 영역 문제와 관련이 없습니다. 블로그 사이트로서, 누드 도메인은 블로거의 사이트를 돋보이게 할 수 있는데, 이는 저처럼 한자 병음으로 도메인을 사용하는 어린아이들에게 해당하며, 현재 모바일 접속이 많은 만큼 몇몇 문자를 줄일 수 있습니다.&lt;/p&gt;
&lt;p&gt;컴퓨터에서는 www와 com을 입력할 필요 없이 바로 사용할 수 있습니다&lt;/p&gt;
&lt;h3 id=&#34;cdn&#34;&gt;CDN
&lt;/h3&gt;&lt;p&gt;알리바바 클라우드와 텐센트 클라우드를 모두 사용해 봤는데, 신규 사용자도 쉽게 시작할 수 있습니다. 텐센트 클라우드는 관련 개념을 설명하는 비디오도 따로 제공하고 있습니다. CDN 가속의 원리와 제이동(JD) 창고는 같은 원리입니다. 신상품을 출시하면 미리 전국 각지의 창고에 통일적으로 배송한 후, 배송 요청이 발생했을 때 가장 가까운 창고에서 배송합니다.&lt;/p&gt;
&lt;p&gt;원본 주소: 웹사이트 리소스가 원래 보관된 주소&lt;/p&gt;
&lt;p&gt;캐시 파일 설정, 브라우저 F12, 관리 콘솔, 간단한 정적 리소스 및 동적 리소스 분석&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;전부 0일 유효기간&lt;/li&gt;
&lt;li&gt;.php;.jsp;.asp;.aspx 파일은 유효 기간이 0일입니다&lt;/li&gt;
&lt;li&gt;.jpg;.png;.js;.css;.woff2 유효기간 1일&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;텐센트 클라우드 설정 규칙:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;캐시 만료 규칙은 최대 10개까지 구성할 수 있습니다&lt;/li&gt;
&lt;li&gt;여러 캐시 만료 규칙 간의 우선순위는 하단 우선입니다&lt;/li&gt;
&lt;li&gt;캐시 만료 시간은 최대 365일까지 설정할 수 있습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;비참한-자수풀&#34;&gt;비참한 자수풀
&lt;/h3&gt;&lt;p&gt;예전에는 Nginx를 사용해 본 적이 없어서 웹사이트 검색으로만 역방향 프록시 설정을 이해할 수 있을 거라고 생각했는데, 결과가 좀 혼란스러웠습니다. 반나절을 끙끙거려도 302 리디렉션조차 제대로 설정하지 못해서 결국 아무 소용이 없었습니다. 그래서 어리석은 방법으로 해결하려고 DNS 파싱에서 *모드와 같은 일반 도메인 파싱을 삭제하고 개별 2단계 하위 도메인을 독립적으로 설정했습니다. 그때 갑자기 알리바바 클라우드 DNS 파싱에 &amp;lsquo;표시 URL 리디렉션&amp;rsquo;이라는 모드가 있다는 것을 알아차렸고, 시도해 보니 이게 제가 원하는 302 리디렉션이었습니다.&lt;/p&gt;
&lt;p&gt;첫 번째 2차 도메인을 설정하니 정상적으로 접속되는데, 두 번째를 설정하려니 안 되어서 거의 인생의 의미를 의심할 지경이었어요. 잠시 기다리니까 갑자기 잘 된다는 걸 보니, 알리바바 클라우드의 DNS 전파가 가끔씩 고장 나는 것 같네요.&lt;/p&gt;
&lt;h3 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;www가 없는 웹사이트 주소가 점점 더 많아지는 이유는 무엇인가요?&lt;/li&gt;
&lt;li&gt;www가 포함된 도메인과 미포함된 도메인의 차이점은 무엇인가요?&lt;/li&gt;
&lt;li&gt;도커 Nginx 리버스 프록시 설정&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>블로그 IDE 환경과 잡담</title>
        <link>https://ttf248.life/ko/p/blog-ide-environment-and-ramblings/</link>
        <pubDate>Tue, 31 Mar 2020 13:54:27 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/blog-ide-environment-and-ramblings/</guid>
        <description>&lt;p&gt;이 글은 마크다운의 기본 개념과 다양한 소프트웨어에서의 활용을 소개하고, VSCode를 IDE로 추천하며 관련 플러그인 목록을 제시합니다. 저자는 Hexo에서 Hugo로 전환한 경험을 공유하며 Hugo의 유연성과 사용자 정의 기능을 강조합니다. 마지막으로 새로운 기술을 빠르게 시작하기 위한 몇 가지 팁과 함께 Hugo 테마 스타일이 업데이트되지 않는 문제를 해결하는 작은 팁을 공유합니다.&lt;/p&gt;
&lt;h2 id=&#34;서론&#34;&gt;서론
&lt;/h2&gt;&lt;h3 id=&#34;markdown&#34;&gt;Markdown
&lt;/h3&gt;&lt;p&gt;가볍고 사람이 읽기 쉽고 쓰기 쉬운 순수 텍스트 형식으로 문서를 작성할 수 있게 해주는 경량 마크업 언어입니다&lt;/p&gt;
&lt;p&gt;자세한 Markdown 문법에 대한 설명은 이 글에서는 생략하며, 전자책을 참고하시기를 추천합니다. &lt;a class=&#34;link&#34; href=&#34;https://markdown-zh.readthedocs.io/en/latest/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;여기에 클릭&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;시판되는 많은 소프트웨어들은 이미 md를 작성 방식으로 지원하고 있습니다. csdn 블로그 시스템은 md 문법을 지원하는 온라인 편집기를 출시했는데, 처음 사용할 때 md 문법에 대한 소개 글이 기본적으로 제공되며, 필자는 괜찮다고 생각합니다. 에버노트(印象笔记)는 2018년에 md 노트 지원을 추가했으며, 단축키 바에 다양한 md 마크업 옵션이 있어 일반적인 문서 편집과 거의 비슷하며, 전반적인 인터랙션 흐름은 초보자에게 친숙합니다.&lt;/p&gt;
&lt;h3 id=&#34;ide-추천&#34;&gt;IDE 추천
&lt;/h3&gt;&lt;p&gt;이 글을 작성할 당시에는 이미 2020년이었고, vscode는 필연적으로 들어봤을 것이다. 결국 git page를 사용하여 블로그 시스템을 구축한다고 생각하는 사람은 업계 관계자일 테니까. 과거에는 sublime이나 atom도 괜찮은 선택이었지만, 2년간의 오픈소스 커뮤니티의 노력으로 vscode가 빠르게 발전하여 점차 초보자들이 입문하기에 가장 좋은 선택이 되었다.&lt;/p&gt;
&lt;p&gt;마이크로소프트의 거대 기업과 오픈소스 커뮤니티 관계가 단절된 상태에서 성공적으로 신혼기 시대로 전환되었습니다. 오픈 소스를 포용하고, 필자가 속한 회사 역시 최근 2년간 적극적으로 Java 생태계를 도입했습니다. 바꿔 말하면 현재 국내 비즈니스 개발에 있어 Java 생태계는 정말 매력적입니다.&lt;/p&gt;
&lt;h3 id=&#34;vs-code-플러그인-추천&#34;&gt;VS Code 플러그인 추천
&lt;/h3&gt;&lt;p&gt;플러그인 목록&lt;/p&gt;
&lt;p&gt;플러그인에는 자체 Readme 파일이 있어 기본적인 사용법과 핵심 기능을 설명하고 있으며, 일부 플러그인 제작자는 동적 효과 시연 이미지도 제공합니다&lt;/p&gt;
&lt;p&gt;이미지를 붙여넣기 하면 Hugo의 이미지 플러그인 방식으로 매우 편리하게 이미지를 추가할 수 있습니다&lt;/p&gt;
&lt;p&gt;단축키를 기억하지 못해서, vscode 단축키 관리 메뉴를 열고 md를 검색하고 여러 번 보고; 플러그인 사용 설명서를 다시 확인해 봐&lt;/p&gt;
&lt;h2 id=&#34;hugo&#34;&gt;hugo
&lt;/h2&gt;&lt;p&gt;저는 &lt;code&gt;hexo&lt;/code&gt;에서 &lt;code&gt;hugo&lt;/code&gt;로 전환했는데, 잦은 변덕을 피우는 것이 제 본성이고 결국 차분히 글을 쓰는 것을 참지 못하고 말았습니다&lt;/p&gt;
&lt;p&gt;휴고는 이미지를 별도의 폴더에 배치하고 md 문서를 지원합니다
학문적 주제는 디자인에서 다양한 종류의 문서 스타일을 지원합니다
다양한 편리한 사용자 지정 확장 기능&lt;/p&gt;
&lt;h2 id=&#34;academic&#34;&gt;academic
&lt;/h2&gt;&lt;p&gt;공식 웹사이트는 기본적으로 &lt;code&gt;exampleSite&lt;/code&gt;를 사용하며, 메뉴 도입 시 &lt;code&gt;#컴포넌트&lt;/code&gt; 방식을 채택하고 &lt;code&gt;URL&lt;/code&gt;을 사용하는 것을 권장합니다&lt;/p&gt;
&lt;p&gt;URL 패턴은 클릭하면 단일 페이지로 이동하고, 홈페이지에서 스크롤하는 방식이 아니라서 개인적인 취향입니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스타일별: 에세이, 강연, 전자책&lt;/li&gt;
&lt;li&gt;유연성: 전체 스타일 사용자 정의, CSS 스타일 사용자 정의&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 테마는 중국어 지원이 아직 완벽하지 않은데, 주로 시각적인 측면에서 폰트 크기가 중국어 읽기 습관에 잘 맞지 않습니다. Hexo 개발자 대다수가 중국인이므로 이 점에서는 Hugo보다 우수합니다.&lt;/p&gt;
&lt;p&gt;하지만, 직접 옷을 만들어 먹고, 브라우저에서 요소들을 검사합니다. 요소를 찾았으면 수정해야 할 CSS 스타일 이름이 궁금할 때 사이드바에서 &lt;strong&gt;Insert Style Rule Below&lt;/strong&gt;를 클릭하면 여러 계층으로 중첩된 CSS라도 쉽게 노드 이름을 가져올 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://sourcethemes.com/academic/docs/customization/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;custom.css 도입&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://sourcethemes.com/academic/docs/customization/#add-scripts-js&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;사용자 지정 &lt;strong&gt;custom_js&lt;/strong&gt; 도입&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;테마 내장 문법 강조 설정, &lt;a class=&#34;link&#34; href=&#34;https://sourcethemes.com/academic/docs/writing-markdown-latex/#highlighting-options.&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;공식 링크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;마무리&#34;&gt;마무리
&lt;/h2&gt;&lt;p&gt;애가 또 뭐라 하려고 하는군, 어떻게 처음부터 끝까지 얼버무려 얘기하고 세부사항 같은 건 하나도 안 짚어주는 거야?&lt;/p&gt;
&lt;p&gt;이것들이 있으면 충분할 거예요:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;공식 매뉴얼&lt;/li&gt;
&lt;li&gt;플러그인 설명&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;새로운 기술을 빠르게 시작하려면 먼저 공식 문서를 읽어보는 것이 좋습니다. 완벽하게 이해하려고 애쓰기보다는 대략적인 내용을 파악하는 데 집중하고, 검색 엔진에서 나오는 결과는 최신 버전과 일치하지 않을 수 있으므로 오해를 불러일으킬 수도 있습니다. 새 책도 마찬가지입니다. 목차를 먼저 보고 저자가 무엇을 이야기하려는지 파악하세요. 때로는 서문을 읽는 것이 좋습니다. 일부 외국 저작물이 중국어로 번역될 때, 번역자의 서문은 책의 핵심 내용과 상당 부분을 포함하고 있는 경우가 많습니다.&lt;/p&gt;
&lt;h2 id=&#34;이스터-에그&#34;&gt;이스터 에그
&lt;/h2&gt;&lt;p&gt;Hugo Academic 내장 스타일 스타일을 변경하고 사이트에 게시했지만, 방문 시 스타일이 변하지 않았습니다. 똑똑한 분들은 이미 생각했을 겁니다. 로컬 브라우저 캐시를 지우면 문제가 해결됩니다. 저처럼 영리한 방법은 F12 개발자 모드로 전환하여 &lt;code&gt;network&lt;/code&gt;로 이동한 다음 &lt;code&gt;disable cache&lt;/code&gt;를 선택하고 새로 고침하면 됩니다!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/blog-ide-environment-and-ramblings/2020-03-31-14-27-15.png&#34;
	width=&#34;399&#34;
	height=&#34;142&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;network&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;280&#34;
		data-flex-basis=&#34;674px&#34;
	
&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>자동 통합 시스템 전환</title>
        <link>https://ttf248.life/ko/p/auto-integration-system-switch/</link>
        <pubDate>Sun, 29 Mar 2020 02:11:33 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/auto-integration-system-switch/</guid>
        <description>&lt;p&gt;GitHub Actions를 사용하여 Hugo 블로그를 GitHub Pages 및 Gitee에 자동으로 배포합니다&lt;/p&gt;
&lt;h4 id=&#34;배경-소개&#34;&gt;배경 소개
&lt;/h4&gt;&lt;p&gt;어제 블로그를 업데이트하려는데 Travis 서비스가 안 된다는 걸 발견했어요. Travis 웹페이지를 살펴보니 진행이 소스 코드를 가져오는 단계에서 멈춰 있었고, 그때 GitHub에서 출시한 Action 서비스가 떠올랐습니다.&lt;/p&gt;
&lt;p&gt;그때는 좀 바쁠 것 같고, 액션을 사용하려면 신청도 해야 해서, 지금부터 정식으로 출시되었으니 주말에 시간 나면 새로운 장난감을 한번 해볼까요?&lt;/p&gt;
&lt;p&gt;공식 자료는 다들 웹사이트에서 직접 확인하시면 되고, 본문은 더 이상 인용하지 않겠습니다. 이전에 쿠버네티스를 사용해 보신 분들은 액션의 YAML 파일 설정이 쿠버네티스와 비슷하다고 느끼실 겁니다.&lt;/p&gt;
&lt;p&gt;초보자를 위한 튜토리얼이나 중국어 소개 자료를 찾고 있다면 &lt;strong&gt;阮一峰의 블로그&lt;/strong&gt;에서 검색해 보세요. 두 개의 기사가 있는데, 하나는 기본적인 문법 설명이고 다른 하나는 실제 사례입니다.&lt;/p&gt;
&lt;h4 id=&#34;본문&#34;&gt;본문
&lt;/h4&gt;&lt;p&gt;필요한 지식점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;github secrets&lt;/li&gt;
&lt;li&gt;행동 구문&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;핵심 작업은 기존 컴포넌트를 사용하여 완료되었고, 명령어를 통해 국내 gitee에 푸시했습니다. 명령어 부분은 다소 거칠며 강제 푸시를 사용하고 있으며, travis를 사용하던 로직을 이어받았습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;name: github pages and gitee pages

on:
  push:
    branches:
      - hugo

jobs:
  deploy:
    runs-on: ubuntu-18.04
    steps:
      - uses: actions/checkout@v2
        with:
          submodules: true

      - name: Setup Hugo
        uses: peaceiris/actions-hugo@v2
        with:
          hugo-version: &#39;latest&#39;
          extended: true

      - name: Build Github and Gitee ## 单个step只能写一个run命令
        run: hugo -b &amp;quot;https://www.xiangtianlong.com/&amp;quot; -d &amp;quot;github_public&amp;quot; &amp;amp;&amp;amp; hugo -b &amp;quot;https://www.xiangtianlong.com/&amp;quot; -d &amp;quot;gitee_public&amp;quot; &amp;amp;&amp;amp; ls

      - name: Deploy Github
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.BLOG_TOKEN }}
          publish_dir: ./github_public
          publish_branch: master
          cname: xiangtianlong.com

      - name: Deploy Gitee
        run: cd ./gitee_public &amp;amp;&amp;amp; git init &amp;amp;&amp;amp; git config user.name &amp;quot;TianlongXiang&amp;quot; &amp;amp;&amp;amp; git config user.email &amp;quot;tianlongxiang51@gmail.com&amp;quot; &amp;amp;&amp;amp; git add . &amp;amp;&amp;amp; git commit -m &amp;quot;Update TianlongXiang&#39;s Blog&amp;quot; &amp;amp;&amp;amp; git push --force &amp;quot;https://xiangtianlong:${{ secrets.GITEE_PASSWORD }}@gitee.com/xiangtianlong/xiangtianlong.git&amp;quot; master:master   
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;사후기&#34;&gt;사후기
&lt;/h4&gt;&lt;p&gt;공식 시장에서 제공하는 기능들을 보면 현재 지원되는 플레이 방식이 꽤 많고, Docker 이미지를 구축하면 더 이상 Docker Hub에서 제공하는 서비스에 의존하지 않아도 된다&lt;/p&gt;
&lt;p&gt;Hugo 이슈를 확인해 보니, GitHub 액션을 사용하여 Git Pages를 자동으로 배포하려면 최종적으로 게시되는 웹 페이지가 master 브랜치에 있어야 합니다. 다른 브랜치에 배포하면 설정 인터페이스에서 GitHub이 배포된 웹 페이지에 구문 문제가 있다는 것을 알립니다.&lt;/p&gt;
&lt;p&gt;실제로 hugo의 원 파일이 master 브랜치에 위치해 있어서, github가 jelly 블로그의 소스 코드로 간주하여 검사하고 통과하지 못하게 하는 오류로 인한 것이다&lt;/p&gt;
&lt;p&gt;솔루션도 간단합니다. Hugo 소스 파일을 다른 분기에 두고, 정적 파일은 master 분기에 게시하면 됩니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>미래의 좋은 중국은 좋은 노인 남성과 여성으로 가득한 중국일 것이다</title>
        <link>https://ttf248.life/ko/p/future-good-china-with-elderly/</link>
        <pubDate>Sat, 15 Feb 2020 11:28:28 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/future-good-china-with-elderly/</guid>
        <description>&lt;p&gt;스무 해 후에는 멋진 노인이 되어 사랑하는 배우자와 함께하며, 부유하지 않아도 괜찮으니 건강하게 전국을 돌아다니는 여행을 하고 싶습니다&lt;/p&gt;
&lt;h2 id=&#34;영상-원본&#34;&gt;영상 원본
&lt;/h2&gt;&lt;p&gt;유쿠 검색으로 충분합니다. 이후 링크는 제공하지 않겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;문자-자료&#34;&gt;문자 자료
&lt;/h2&gt;&lt;p&gt;나는 10년 후 멋쟁이 노인이 내가 될 거다, 멋쟁이 노인이 되기 위해 열심히 노력할 것이다. 미래의 중국은 분명히 멋쟁이 노인과 멋쟁이 할머니로 가득 찬 나라가 될 것이다. 비록 10년 후 60세가 된다 해도 나는 이 세계에서 가장 젊은 사람 중 하나일 것이다.&lt;/p&gt;
&lt;p&gt;솔직히 말해서, 다들 50세의 중국 남자인데 이런 체형이면 꽤 괜찮다고 생각하겠지만, 이 체형 뒤에는 제가 믿는 한 마디가 있습니다. 자율할수록 자유롭다! 비가 그친 후에 저는 달리기 가려고 했는데, 내일 오후에는 축구를 할 겁니다. 50세에도 여전히 큰 경기를 할 수 있는데, 농담이 아닙니다. 오히려 전문 선수들과 함께 하는 경우가 많습니다. 그렇다면 뒤에는 무엇이 있을까요? 뒤에는 자율성이 있습니다. 남은 시간 동안 저는 달리기를 하는데, 달리는 것이 지루하다고 생각하는 사람도 있지만, 자율할수록 자유롭다! 저는 자율하기 때문에 자유롭게 달릴 수 있고, 음악을 듣지 않는데, 제 호흡 소리가 가장 아름다운 음악이라고 생각하기 때문입니다.&lt;/p&gt;
&lt;p&gt;또는 저는 거의 러닝머신을 안 하고, 그리고 많은 사람들이 베이징 스모그가 그렇게 심한데 제가 일주일에 5일은 뛰는데, 이틀은 이미 스모그를 위해 남겨두고, 다른 사람들과 달리 농담으로 이야기하는데, 아마도 저는 절대 중단하지 않는 것 같아요. 저는 매달 일기에, 제 경험에 기록하는 방식으로 하루씩 달리고, 매달 최소 18일 이상은 달리는데, 러닝할 때는 순식간에 지나가고, 러닝할 때는 안경을 안 쓰고 있지만, 더 중요한 것은 제가 매주 축구를 하고 있다는 거예요. 제 대학원 마지막 수업은 우리 집에 가서 하는 수업이었는데, 주제는 재미였어요. 저는 재미가 너무 중요하다고 생각하고, 저는 전혀 즐거움이나 취미가 없는 사람들과는 섞이지 않아요.&lt;/p&gt;
&lt;p&gt;존경하고 멀리하는 사람, 그런 사람이 너무 무섭고 즐거움이 없어요. 당신이 뭐가 즐거운지 느껴본 적 있나요? 저도 별로 없는 것 같아요. 어떤 일을 하고 싶으세요? 올해 초에 제 대학원생은 중국신문주간에 분배되었는데, 저희는 특집을 진행했는데 제목이 ‘致’였어요. 10년 후 제 대학원생들이 매년 졸업할 때 마지막 과제는 그들에게 10년 후를 써보라고 하는 것이었고, 저는 그걸 보관해두었어요. 10년 후에 저는 그들을 차례로 펼쳐서 50세가 60세에게 쓰는 편지를 쓰기도 했는데, 60세는 예전에 생각조차 해본 적 없는 너무나 먼 곳이었지만, 눈 깜짝할 사이에 제 다음 목적지가 되었어요. 20세가 30세에게 쓰는 편지는 봄이 여름에 보내는 러브레터였지만, 제가 50세가 60세에게 쓰는 편지는 여름 끝이 가을에 속삭이는 듯한 것이었어요. 지금 저는 10년 후를 향해 전 세계에서 천천히 자신에게로 돌아오는 침대, 한 끼 식사, 자신의 가족 옆으로 쓰고 있는데, 이건 너무나 당연한 일이에요.&lt;/p&gt;
&lt;p&gt;하지만 60세에 어떤 사람이 될 것인가, 제 주제는 매우 명확합니다. 서문에서 이 글은 매우 길고, 저는 10년 후 사랑스러운 노인이 제가 될 것이며, 열심히 노력하여 사랑스러운 노인이 되겠습니다. 중국이 사랑스럽기를 바라는 것은 미래에 더 많은 시민들이 시민이 되어야 하고, 더 이상 작은 백성이 아닌, 활기 넘치는 젊은이들과 규칙을 지키는 젊은이가 있어야 합니다. 미래의 좋은 중국은 좋은 노인과 좋은 할머니가 있는 나라입니다. 현재 중국의 60세 이상 인구는 이미 2억 3천만 명이 넘어 있으며, 10년 후에는 확실히 3억 명을 넘을 것입니다. 즉, 60세 이상 인구만을 고려해도 중국은 단독 국가로 세계 5위일 가능성이 있고, 심지어 세계 3위가 될 수도 있습니다. 한번 생각해 보세요, 얼마나 무서운 일입니까?&lt;/p&gt;
&lt;p&gt;저는 그렇게 생각하지 않아요. 다들 오늘 인터넷에 올라온 표를 보셨을지 모르겠지만, 중국 각 성과 직辖시의 평균 수명은 상하이와 베이징이 80세 이상이에요. 남녀 모두 합친 평균 수명이죠. 평균 수명은 분명히 남자들이 여자들의 이득을 많이 본 거 같아요. 그러면 저도 10년 뒤에 60세가 되더라도 이 세상에서 가장 젊은 사람 중 하나일 거예요. 미래에는 여성분들은 55세에 은퇴해서 평균 수명인 80세까지 25년을 더 살고, 남성분들은 60세에 은퇴해서 평균 수명인 80세까지 20년을 더 사는 거죠! 그냥 광장 춤만 추는 게 아니라 뭔가 해야죠. 그리고 저는 오늘 광장 춤을 추시는 누나와 형님들은 시대가 가져다준 문화적 습관과 오락 방식이라고 말씀드릴 수 있어요.&lt;/p&gt;
&lt;p&gt;또 20년 후, 다음 세대도 많지는 않겠지만 여전히 광장 춤을 추는 사람이 있을 것이다. 왜냐하면 다음 세대는 집단 활동에 적극적으로 참여하는 것을 즐기지 않기 때문이다. 나이가 지긋한 사람들이 여행을 할 때 단체 관광을 선호하는 것처럼, 요즘 젊은이들은 자유여행이나 자가발생 여행을 점점 더 많이 한다. 앞으로도 광장 춤은 존재하겠지만, 그 범위는 분명히 줄어들 것이다. 이것이 좋고 나쁨이라고 말할 수는 없다. 시대가 변화하고 끊임없이 바뀌는 것일 뿐이다. 내가 60세였을 때 가장 젊은 팀의 일원이었는데, 나는 어떤 사람이 되어야 할까? 중국화에서는 60세에 귀가 밝다고 하는데, 나는 그때 절대 듣지 않을 것이다. 무엇이든 기뻐하는 것은 물론이고, 언급해서는 안 될 것을 말하면 기쁘지 않을 것이다. 더 중요한 것은 젊은 사람들을 위해 무엇을 해야 하는 것!&lt;/p&gt;
&lt;p&gt;좋은 일을 하려면 무엇을 해야 할까? 게으르지 않고 쉽게 타협하지 않으며, 반대해야 할 것을 반대해야 한다. 젊은 세대가 내 이익을 해칠 수도 있는데, 네가 그들 앞에 서서 막아줄 수 있느냐? 요즘 나는 자주 거울을 들여다본다. 내 좋은 친구 하나는 이미 떠났고, 타오 웨이 시절에는 우리 집에 자주 모였는데, 어느 날 진실한 이야기를 해주었던 적이 있다. 우리는 함께 슬퍼했다. 첸(陳) 세대는 집 안에 모든 것을 쌓아두었는데, 상자를 깨면 30개 넘게 침대 밑에 있는 것을 발견할 수 있었다. 이 옷은 500원 이상 주고 샀는데, 이제는 제사를 지내야 한다. 그래서 우리 세대는 부모님과 머리를 맞대고 싸우는 데 익숙해졌다. 700원이나 주고 사 왔는데 얼마가 남았을까?&lt;/p&gt;
&lt;ol start=&#34;220&#34;&gt;
&lt;li&gt;그런데 쉽게 문제가 생기기 쉽다. 타오웨이는 한번 400원 넘게 주고 아버지를 위해 티셔츠를 사 주었다. 그 티셔츠 정말 좋았는데, 얼마였지? 99원이었나. 그 디자인은 입어보니 괜찮았다. 다음 날 비참한 일이 벌어졌는데, 저녁에 돌아와서 타오웨이에게 400원을 자랑하길래 나를 위해 4개 더 사 달라고 했다. 오늘 입고 나가 보니 리 대장 등 여러 사람이 좋다고 했고, 결국 거짓말의 위험은 매우 크다는 이야기가 나왔다. 앞으로 이런 일은 하지 말아야 할 것이다. 정확히 어떤 사람인지 말하지는 않겠지만, 병원 정형외과에 있는 노인들의 경우 뼈가 부러진 중요한 원인이 시장에서 산 신발이라는 것을 발견했다. 물론 이것은 내가 다루는 것이 아직 물질적인 측면일 뿐이다. 나이가 들어서도 정신 생활이 필요하고, 호기심을 가져야 하며, 여전히 젊은이를 위해 바람을 막아주고 비를 가려주는 일에 기꺼이 나서야 한다. 하루하루 즐겁게 살아야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;제가 60살이 되는 순간을 궁금하고 기대하며 기다리고 있는데, 그게 멋진 시기의 시작이라고 생각합니다&lt;/p&gt;
&lt;p&gt;감사합니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>제 18살은 여러분과 조금 다를 수도 있어요</title>
        <link>https://ttf248.life/ko/p/my-18th-might-be-different/</link>
        <pubDate>Sat, 15 Feb 2020 11:19:33 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/my-18th-might-be-different/</guid>
        <description>&lt;p&gt;흔히 볼 수 있는 용어 &lt;strong&gt;정보 조각화&lt;/strong&gt;입니다. 고등학교 졸업 후 소설 보는 시간을 버리고 나서, 오랫동안 진지하고 조용하게 책을 읽은 적이 없네요. 가끔 뒤돌아보면, 이리 오래 일했는데도 매년 뭘 했는지 기억나는 게 별로 없습니다. 많은 경우, 하반기에 다다르면 상반기에도 잊어버린 일이 많습니다. 블로그를 쓰는 건 좋은 습관입니다. 비록 제가 쓰는 많은 글이 공개되지 않더라도 상관없습니다. 원래는 제 자신을 위해 쓰는 것이니까요.&lt;/p&gt;
&lt;p&gt;가장 충실한 독자는 바로 나 자신이다&lt;/p&gt;
&lt;h2 id=&#34;영상-원본&#34;&gt;영상 원본
&lt;/h2&gt;&lt;p&gt;유쿠 검색으로 충분합니다. 이후 링크는 제공하지 않겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;문자-자료&#34;&gt;문자 자료
&lt;/h2&gt;&lt;p&gt;모든 사람의 18세는 기대와 질문이 담긴 시선과 같습니다. 누구나 가끔 자신의 18살을 떠올리며, 자신이 살고 싶다고 생각했던 모습으로 살아왔는지 자문합니다. 저는 요즘 많은 사람들이 수많은 친구들과 소통하지만 진정한 친구는 없고, 매일 대화는 하지만 마음을 나누는 사람은 없으며, 지식은 무한히 얻지만 지혜와는 거리가 멀어진다는 것을 두려워합니다. 모든 사람은 자신의 18살을 떠올리며 스스로에게 물어야 합니다. 다른 사람을 속이는 것은 너무 쉽지만, 자신을 속이는 것은 너무 어렵습니다!&lt;/p&gt;
&lt;p&gt;네, 당신이 생각하는 모든 사람의 18세는 기대와 질문의 시선과 같아요. 다른 사람을 속일 수는 있지만, 자신의 18살을 속일 수는 없죠. 지금 모습이 18살에 자신이 되고 싶었던 모습인가요? 괜찮은 것 같아요. 요즘은 물질이나 명예 등 훨씬 더 많은 것을 생각하고 얻었지만, 동시에 계속 노력 중이에요. 제 18살 때는 방송 아카데미에서 언론학과를 다녔고, 최고의 기자, 팔라치오가 되는 것을 꿈꿨어요. 지금도 그 길을 가고 있죠. 그래서 사람들이 저에게 “백 선생님, 왜 아직 CCTV에 계세요?”라고 묻는 거예요. 저는 좋은 기자가 되고 싶었으니까요. 그리고 뉴스 일은 계속하고 있어요. 이게 제 18살의 시선이었던 것 같아요. 그러니 가끔 자신의 18살을 떠올리며 스스로에게 물어봐야 해요. 당신은 그때 자신이 살고 싶다고 생각했던 모습대로 살고 있나요?&lt;/p&gt;
&lt;p&gt;이것은 정말 속일 수 없는 것이에요. 제 18살 때 모습이에요, 눈 깜짝할 사이에 32년이나 지나버렸네요. 베이징에 와서 대학을 온 사람은 누구나 이런 사진 한 장을 가지고 있을 거예요. 그 시절에는 천안문 광장의 주름진 서복장을 입고, 학교 휘장(校徽)을 가슴에 달았어요. 당시에는 대학교 학생이 적어서 휘장을 달지 않으면 특별히 자랑스럽게 여겼죠. 머리도 길었지만 18살 때 모습이 참 좋았어요. 많은 세월이 흘러서 갑자기 18살 때 마주했던 것들에 대해 감사하게 생각하게 되었어요. 조용히 저를 만들어줬으니까요. 1986년 5월 8일, 왕푸징 서점에서 ‘몽롱시 선집’을 샀고, 그해 공인체육장에서 추이롄의 ‘무(無)’를 들었어요. 그런데 오늘 갑자기 제 문체의 영향을 가장 많이 받은 것이 몽롱시와 록 음악, 그리고 고룡의 무협 소설이라는 것을 깨달았어요.&lt;/p&gt;
&lt;p&gt;열여덟 살에 당신은 무엇을 겪었나요? 그리고 그로 인해 무엇을 가지고 길을 나아가게 될까요. 오늘날 열여덟 살들이 무엇을 겪고 있는지 정말 알고 싶어요. 마치 도끼나 괸상처럼 당신을 조각하는 것 같나요? 그렇다면 그는 어떤 도구를 사용했을까요? 그는 당신을 어떤 모습으로 다듬었을까요? 저는 요즘 사람들이 수많은 친구들과 연결되어 있지만, 진정한 친구는 없고, 매일 채팅만 하고, 마음을 나눌 사람은 없으며, 지식을 무한정 얻지만 지혜와는 거리가 멀고, 모든 것을 아는 듯하지만 아무것도 모르는 것 같아요. 겉으로는 모두가 개성을 표현하는 것처럼 보이지만, 제 관찰로는 요즘 젊은이들은 다 똑같아 보여요. 어떻게 해야 할까요? 열여덟 살 당신은 그에게 무엇을 겪게 하고 싶나요? 저는 1986년을 정말 좋아하는데, 왜냐하면 1986년이야말로 1966년을 해결할 가장 좋은 방법이기 때문이에요.&lt;/p&gt;
&lt;p&gt;1966년 문화대혁명은 76년에 사천붕을 타도하여 끝났는데, 우연적인 요소가 있었고, 진정으로 당신이 걱정하는 근본적인 문제를 없애려면 1986년의 계몽과 인간성에 대한 각성의 힘과 모든 사람의 성장이 있어야만 가능합니다. 우리는 아직 계몽을 겪어야 하고, 인간성에 대한 충분한 이해를 더 깊이 경험해야 합니다. 중국 사회가 아무리 큰 경제적 진보와 변화를 축적하더라도 인간성에 대한 진정한 이해 없이, 인간 본성 속 악의적인 면을 통제하고 선량한 면을 활성화하지 않으면 미래에도 우리를 걱정하게 하는 일들이 많을 것입니다. 저의 18세도 이 시대의 18세이고, 너무 멀리 왔으니 처음 시작했던 이유를 잊지 말아야 합니다. 지금은 “본초를 잃지 말라”라는 네 글자로 압축되어 있습니다.&lt;/p&gt;
&lt;p&gt;그래서 저는 아무리 멀리 가더라도 모든 사람은 자신의 18세 때 모습을 돌아보며 자문해야 한다고 생각해요. 18살 사진을 남겨두는 건 좋은 일이고, 자주 꺼내서 자신에게 물어봐야죠. 다른 사람이 하는 말은 중요하지 않아요. 사람을 속이는 건 너무 쉽지만, 자신을 속이는 건 정말 어려워요. 제가 방금 말씀드린 것처럼 18살 때 오늘 20살인 당신에게 해주고 싶은 말이 있어요. 당신은 항상 자신의 18세 모습을 통해 세상을 바라봐야 해요. 그리고 20대에도 제가 말씀드렸듯이 여러 문을 많이 열어보고 시도해 보세요. 자신에게 가장 잘 맞는 문이 어디인지 모르는 거니까요. 요즘 중국에서는 이상하게도 20대에 은퇴하는 노인들이 많고, 70대에 젊음을 누리는 사람들도 많아요.&lt;/p&gt;
&lt;p&gt;감사합니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>이 사회는 어떤 기자가 필요한가?</title>
        <link>https://ttf248.life/ko/p/what-kind-of-journalists-does-society-need/</link>
        <pubDate>Sat, 15 Feb 2020 11:08:38 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/what-kind-of-journalists-does-society-need/</guid>
        <description>&lt;p&gt;저널리즘에 대한 저자의 견해를 이야기하며, 언론인은 사회적 양심, 지식 축적, 그리고 장거리 경주 정신을 갖춰야 한다고 강조한다. 또한 저자는 50세의 자신에 대한 깨달음을 공유했는데, 호기심 유지, 물질과 정신의 균형, 그리고 미래에 대한 고찰 등이 포함되어 있다.&lt;/p&gt;
&lt;h2 id=&#34;영상-원본&#34;&gt;영상 원본
&lt;/h2&gt;&lt;p&gt;유쿠 검색으로 충분합니다. 이후 링크는 제공하지 않겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;문자-자료&#34;&gt;문자 자료
&lt;/h2&gt;&lt;p&gt;최고의 기자는 우선 사회적 양심이 있어야 하고, 둘째는 지식과 경험을 쌓아야 하며, 셋째는 장거리 경주와 같습니다. 제가 100미터만 뛰고 만족하지 않고 달리는 것은 의미가 없습니다. 이 세 가지가 결합되면 사람들은 백신 안전에 대한 우려를 완전히 해결해주기를 기대합니다. 이는 마치 과거 분유 사건과 같이 문제가 발생하고, 문제를 해결하고, 근본적으로 문제를 해결하는 이러한 논리적 순환 속에서 나아가는 것과 같습니다. 그렇지 않으면 기자에게 무엇을 시키려고 하는 걸까요?&lt;/p&gt;
&lt;p&gt;저는 최고의 기자는 우선 사회적 양심이 있어야 하고, 두 번째는 지식과 경험을 갖추고, 세 번째는 단거리 달리기가 아니라 장거리 달리기를 해야 합니다. 100미터 달리기로는 만족하지 않고 계속 달려야 한다고 생각합니다. 이 세 가지가 결합되니 올해 제가 50세가 되었는데, 이제 저에게 어울리는 일이 뉴스라고 생각하게 되었습니다. 저는 중국의 40년 개혁과 자연스럽게 묶여 있습니다. 제 30살 생일에는 송화강 기슭에 서 있었고, 40살 때에는 올림픽 중계를 통해 들어갔다가 나 왔습니다. 올해 50세인데, 전국적으로 개혁 40주년을 기념하고 있으니 확실히 일맥상통합니다. 만약 큰 시대가 40세라면, 중국의 개혁 40년은 불혹인가 혼란인가?&lt;/p&gt;
&lt;p&gt;40년의 길을 걸어온 중국이라고 하는데, 물질적으로는 우리 모두에게 충분한 것을 주었고 국가에도 충분한 것을 주었지만 불안과 혼란은 늘어나고 줄어들지 않았습니다. 우리는 강해지고 부유해졌으니 다 괜찮겠다고 생각했지만 결과적으로 물질은 그저 밑바탕일 뿐이었습니다. 원래 물질적인 가난에서 벗어나는 것은 가장 쉬웠지만 정신적으로 풍요로워지는 것, 그리고 대국이 되는 것은 정말 어렵습니다. 미국이 고기술을 공격하기 시작했으니 우리야말로 농산물을 공략해야 할 것입니다. 이 세상에는 ‘둘은 하나가 되기 어렵다’라는 것이 항상 존재합니다! 미국에서 몇 개의 2번이 망가지고 사라졌습니까? 따라서 우리는 필연적으로 오랜 세월을 거쳐 이러한 둘이 아닌 하나를 넘어 자신을 초월해야 합니다. 나는 무엇도 얻을 수 없을 것입니다.&lt;/p&gt;
&lt;p&gt;저는 25살에 TV 일을 시작하게 된 것이 다행이었고, 처음에는 인물 인터뷰부터 시작해서 수백에서 천 명에 달하는 다양한 환희를 가진 사람들을 접했습니다. 그때 젊은 세대들은 그런 환희가 그들을 행복하게 할 거라고 생각했지만, 가까이 다가가 보니 그렇지 않았습니다. 오히려 환희와 그들의 행복은 반비례 관계인 경우가 많았습니다. 며칠 전 막 과오모택동의 마지막 29년을 읽었는데, 국무 부총리, 정치협회 부주석, 부위원장 등 고위직에 있었음에도 불구하고 거의 처벌을 받지 않았습니다. 하지만 아들 둘이 하나는 자살하고 다른 한 명은 추락사했고, 그는 행복했을까요?&lt;/p&gt;
&lt;p&gt;무엇으로 행복을 측정할 수 있겠는가? 스스로 60대나 70대에 접어들었을 때, 몇 년 사이에 두 아들을 연이어 떠나보낸 후의 부총리라면 행복해할 수 있을 것이다. 많은 유명인의 서예 작품이 사람을 행복하게 할 수도 있고, 안전하게 많은 세월을 보냈다는 사실만으로도 행복해질 수 있다. 무엇이 필요하겠는가? 그래서 나는 사람을 보는 가장 좋은 거울은 책이라고 생각한다. 조금 더 강조하자면, 요즘 우리 많은 사람들의 불안감은 너무 많이 생각하고 책을 너무 적게 읽기 때문이라고 생각한다. 이는 양강 노인이 젊은이에게 보낸 답신이다. 책을 읽지 않고는 모두 패스트푸드를 기대하며, 휴대폰 하나로 대나무 엑스제를 찾으려 한다. 어떻게 가능하겠는가? 나는 한 권의 책을 통해 어리석음에서 벗어나 현명해지는 법을 배웠고, 책이 많아질수록 그 속에서 뺄셈을 하는 것이다.&lt;/p&gt;
&lt;p&gt;그래서 저는 모든 사람을 기대하기는 바라지 않지만, 점점 더 많은 중국인들이 공부를 통해 더 나은 자신을 발견할 수 있기를 바랍니다. 그것이 가장 중요한 것입니다. 아무도 앉아서 텅 빈 하늘을 바라보며 모든 것을 깨닫지는 않습니다. 저도 그렇게 할 수는 없습니다. 하지만 저는 거울을 볼 수 있습니다. 몇 년 전 BBC의 뉴스 앵커가 베이징에 왔는데, BBC 최고의 뉴스 앵커라고 자랑하더군요. 그러자 누군가가 인터컨티넨탈 호텔에서 중국 뉴스 앵커와 그의 대화를 주선했습니다. 저희 둘이 대화했죠. 그 사람이 대화 중에 저에게 물어봤습니다. &amp;ldquo;BBC가 CCTV로부터 무엇을 배워야 한다고 생각하십니까?&amp;rdquo; 저는 농담으로 시작해서 말했습니다. &amp;ldquo;물론 우선 중국어를 배워야 할 것입니다.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;다음은 제가 농담처럼 말했는데, BBC가 CCTV로부터 배워야 할 것은 세상에 대한 호기심이라고 했습니다. 지난 몇 년간 저희는 빠르게 세계로 나갔습니다. 다양한 특파국을 운영하고 있는데, 현재 70곳이 넘습니다. 학생들이 새로운 것을 보면 모두 매우 궁금해하며 거대한 호기심으로 세상을 관찰합니다. 하지만 BBC는 영국 자체를 세상이라고 생각하는 듯합니다. 더 이상 호기심이 없는 것 같습니다. 그러자 제 친구가 테이블을 치며 말했습니다. “당신 말이 맞아요, 우리에게 필요한 것이 바로 이거예요.” 2007년에 일본을 취재했을 때 작가가 저에게 이런 말을 했습니다. “일본은 희망만 없다면 다른 모든 것을 갖추고 있습니다.” 뒤돌아보니 그 말이 정말 심오합니다. 또 다른 관점에서 보면, 10년 전에는 중국이 희망 외에는 부족한 것 같았지만, 희망은 있었고 모두가 앞날을 기대했습니다.&lt;/p&gt;
&lt;p&gt;하지만 언젠가 우리도 희망 외에는 모든 것이 있는 풍요로운 나라가 될까 봐 걱정입니다. 솔직히 말해서, 중국이 부자가 되어서 무엇을 다 갖추고 나서야 비로소 자신이 정말 가난하다고 느끼게 되는 날이 올까 봐 매우 우려됩니다. 제가 50세에 이르렀을 때 모든 물질적인 조건을 충족하면서도 너무나 가난한 사람이 될까 봐 두려워합니다. 현실에서 고학력인데 교양이 없는 사람, 통장에 수많은 숫자가 있는 빈곤층이 많습니다. 이것이 바로 이 시대의 문제입니다. 진정으로 가난한 것은 두렵지 않습니다. 왜냐하면 앞에 목표와 희망이 있기 때문입니다. 그래서 도덕 결핍과 인간성 상실이 발생하는 이유라고 생각합니다. 과학자들이 많은 것을 발명한 것은 처음부터 위대한 어떤 사명을 짊어진 것이 아니라 호기심 덕분이라고 생각합니다.&lt;/p&gt;
&lt;p&gt;제가 어떻게 해낼 수 있을지 궁금해서요? 그래서 저는 항상 50대쯤부터 스스로에게 더 궁금하게 만들려고 노력했고, 그래서 저는 지금 매우 행복합니다. 제가 요즘 가장 힘든 일은 바로 &amp;lsquo;끈기&amp;rsquo;입니다. 방금 대화 중에 말씀하신 것처럼 아직도 끈기를 가지고 계시다고 하셨는데, 저는 말하지 말라고 했어요. 끈기가 죽음과 멀지 않다는 거죠. 예전에는 끈기가 곧 승리라고 생각했었어요. 중국 축구는 검은 3분을 버티면 끈기로 이를 악물고 버텼죠. 재미도 없고 방법도 없으면 끈기만 남게 되죠. 끈기는 때로는 중요하지만, 상당한 경우에는 이 말에는 양면성이 있어야 합니다. 제가 어떤 일을 할 때 끈기를 보이는 것이 두려워요. 예를 들어, 이렇게 사람들과 이야기할 때 저는 남은 말을 끝까지 하려고 끈기를 발휘하죠. 사실 지금 제 시간은 다 됐지만, 궁금합니다. 이런 식으로 사람들과의 교류가 어떻게 될지?&lt;/p&gt;
&lt;p&gt;나 자신에게 아주 작은 키워드를 주고, 다른 사람들과의 소통을 통해 대화한다면 괜찮다고 생각합니다. 50세에 이르러서도 호기심을 유지할 수 있다면 문제없습니다. 저는 재미있는 모든 것을 좋아하지만, 지금 가장 재미있는 것만 좋아하는 것은 아닙니다. 오늘의 유행은 금방 사라질 수도 있습니다. 매년 유행하는 단어가 있는데, 기억나는 것이 있나요? 오늘날의 인터넷 미디어가 10년 후에는 전통적인 언론이 꿈꾸는 모습일까요? 재미있는 것들은 항상 그 안에 재미를 위한 본질적인 이유가 있습니다. 저는 모든 사람들의 취향을 존중하며, 분명 그럴 만한 이유가 있을 것입니다. 하지만 장기적으로 보면 결국 중국인들이 가장 좋아하는 것은 마작이고, 패스트푸드를 즐기는 순간, 정식 요리를 제공하는 식당은 자연스럽게 사라지게 됩니다.&lt;/p&gt;
&lt;p&gt;많은 것들이 단순히 감탄하고 지나치는 것이 아니에요. 매일 스마트폰에서 얼마나 많은 조각난 글들을 읽고 있나요? 길게 읽는 습관은 얼마나 되나요? 하지만 이것도 하나의 과정이고, 스마트폰이 우리를 묶어두는 수갑처럼 되어가고 있어요. 그래서 짧은 콘텐츠를 많이 볼수록 점점 시력이 나빠질 거라고 생각해요. 물론 이것도 하나의 과정이죠. 저는 콘텐츠의 중요성을 걱정하지 않아요. 결국 돌아오게 될 거예요. 매일 즐거움에 빠져 살다가 40대에 와서야 차(茶)의 세계로 돌아오는 거죠. 마치 제가 십대 아이들이 콜라를 마시는 모습을 보는 것 같아요. 조금 줄이라고 하면, 결국 마시겠죠. 하지만 저는 낙관적이에요. 40대에 그가 차의 세계로 돌아올 거라고 믿어요. 이것이 중국인 일생이죠.&lt;/p&gt;
&lt;p&gt;정말 괜찮은데, 다음 변화가 좀 더 빨리 일어났으면 좋겠어요. 요즘 조사기자가 너무 없다는 게 안타셔요. 이제는 그런 것까지 보지 않으시는 건가 봐요.&lt;/p&gt;
&lt;p&gt;감사합니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>20년 후 중국 축구는 어떨까?</title>
        <link>https://ttf248.life/ko/p/chinese-football-in-20-years/</link>
        <pubDate>Sat, 15 Feb 2020 10:59:32 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/chinese-football-in-20-years/</guid>
        <description>&lt;p&gt;보충된 독후감은 기본적으로 2021년에 즉흥적으로 적어놓은 것이고, 백연수 선생님의 강연 대본을 글로 옮긴 때는 아직 코로나 팬데믹이 막 시작될 때였습니다. 스무 년 후가 아니라 일 년 후, 이 년 후에도 세상의 변화는 항상 사람들의 예상을 뛰어넘습니다. 지금 중국 내 코로나 상황은 거의 마무리 단계에 접어들었지만 해외에서는 여전히 난리입니다. 축구에 관해서는 지난 몇 년간 국가대표팀이 꽤 잘 하고 있고, 감독도 공격적으로 전진하는 것을 두려워하지 않습니다. 옛날 어리둥절하게 보던 시절에 비해 조부님과 함께 축구를 보는 것이 조금 재미있어지기 시작했습니다. 한 국가대표팀 경기를 보다가 노인조차 채널을 바꾸고 싶어할 정도라면 어떤 경험일까요?&lt;/p&gt;
&lt;h2 id=&#34;영상-원본&#34;&gt;영상 원본
&lt;/h2&gt;&lt;p&gt;유쿠 검색으로 충분합니다. 이후 링크는 제공하지 않겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;문자-자료&#34;&gt;문자 자료
&lt;/h2&gt;&lt;p&gt;중국 축구에 아직도 관심이 있나요? 아주 궁금합니다. 어떻게 이렇게 망가질 수 있을까요? 중국 축구가 잘 안 되는 이유는 여러 가지가 있는데, 그 중 하나는 누구도 공을 잃기 싫어하고, 다른 사람에게 패스하기보다는 자기만 생각한다는 겁니다. 이런 플레이 방식은 없습니다.&lt;/p&gt;
&lt;p&gt;물론 이건 그중 아주 작은 한 가지 이유일 뿐이고, 20년짜리 축구 이야기를 하니 20년 후 중국 축구가 엄청 멀게 느껴지네요. 첫 번째로 확장된 팀이 48개가 됐고, 중국도 갈 수도 있지만 여전히 못 갈 수도 있습니다. 국가대표팀의 최적 연령은 26&lt;del&gt;30세인데, 20년 후면 오늘 6&lt;/del&gt;10살 아이들이겠죠. 20년 뒤에는 분명히 될 거라고 생각하게 하는 낙관적인 느낌이 들고, 제가 오늘 6~10살 이야기를 하면 바로 표정이 심각해지시네요. 그러니까 인과관계는 결국 결과로 이어지고, 우리는 지금 무엇을 심고 있나요? 오늘 우리는 거의 국가대표팀이 리그를 뛰게 할 만한 대두를 심었는데요, 이게 어떻게 자랄까요? 누가 이런 행동을 내놓느냐에 따라 그 사람은 사직 준비를 해야 합니다. 이건 규칙에 위배되므로 저는 너무 많이 생각하지 않았습니다.&lt;/p&gt;
&lt;p&gt;하지만 진정으로 오늘 6~10세 아이들을 생각해 봐야 합니다. 그들이 축구를 하고 있나요? 20년 후 중국 축구가 어떤 모습일지 짐작할 수 있을 겁니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>도덕적 결핍, 인간성 상실</title>
        <link>https://ttf248.life/ko/p/moral-deficit-humanity-loss/</link>
        <pubDate>Sat, 15 Feb 2020 01:20:34 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/moral-deficit-humanity-loss/</guid>
        <description>&lt;p&gt;사람이 일을 할 때, 무엇보다 먼저는 양심의 반발 없이 해야 한다. 그래야 밤에 잠을 편안하게 잘 수 있고, 사소한 문제에서부터 큰 원칙의 문제까지, 잘못된 선택은 피하는 것이 좋다. 만약 정말로 잘못했다면, 최선을 다해 바로잡아야 하고 숨기려 하거나 잊으려 해서는 안 된다. 사람은 쉽게 잊기도 하지만, 기억력이 좋은 종족이다. 마음 편안함이 귀결이고, 스스로에게 되물어봐도 부끄러움이 없다면 삶을 좀 더 가볍게 살아갈 수 있다.&lt;/p&gt;
&lt;h2 id=&#34;영상-원본&#34;&gt;영상 원본
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://v.youku.com/v_show/id_XNDI5MzA4NjQ4NA==.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;영상 원본 링크 클릭하여 보기&lt;/a&gt;，만약 저작권 침해라면, 본인에게 연락 주시면 삭제하겠습니다. 이 글은 오직 텍스트 초안 번역입니다.&lt;/p&gt;
&lt;h2 id=&#34;문자-자료&#34;&gt;문자 자료
&lt;/h2&gt;&lt;p&gt;저에게 여덟 글자가 있는데, 그게 좀 무겁게 들리는 것 같아요. 저는 지금 우리 사회가 도덕적 적자를 겪고 있고, 인간성이 손상되었다고 생각합니다. 시대는 항상 문제가 발생하고 해결되는 논리적인 순환 속에서 나아가지요. 인내심을 가지고 재구성을 기다려야 합니다. 중국과 같이 큰 나라인 경우 많은 것들이 점진적인 재구성 과정입니다. 그러니 변화와 재구성에 대해 비관적으로 생각하지 마세요.&lt;/p&gt;
&lt;p&gt;최근 며칠 동안 중국은 두 개의 태풍과 싸우고 있습니다. 하나의 태풍은 보이지 않고, 다른 하나는 보입니다. 보이지 않는 태풍은 백신이고, 그것은 우리의 내면의 안보를 지키는 제방을 공격합니다. 또 다른 태풍은 중국에서 드물게 상하이에 상륙하여 베이징과 톈진에 피해를 입히며, 세 개의 직辖시가 함께 맞서는 태풍은 수십 년 동안 없었습니다. 이 이야기는 잠시 접어두고, 이제 당신은 스스로를 돌아보고, 당신에게 큰 변화가 있었고 많은 답을 얻었을 것입니다. 주변 환경이 변하지 않는다면 행복할까요? 저는 8글자로 표현했는데, 지금 우리는 도덕적 결핍과 인간성의 손실에 처해 있습니다. 이것이 현재 가장 큰 결핍이자 가장 큰 손실입니다.&lt;/p&gt;
&lt;p&gt;하지만 사람들은 백신의 안전성에 대한 우려가 완전히 해결되기를 기대하고 있습니다. 이는 과거 분유 사건과 마찬가지입니다. 그래서 역사를 더 살펴보고 미국의 식약청이 확립되고 완벽한 법률 체계가 갖춰진 과정 또한 과거 분유 및 유제품의 불안전성과 밀접하게 관련되어 있음을 알아야 합니다. 삼락 분유 사건은 중국의 유제품 분야에 큰 변화를 가져왔고, 백신 접종을 연달아 하는 것은 아니지만 이번에는 중단되기를 바랍니다. 시대는 문제 발생과 해결, 그리고 완전히 해결되는 이러한 논리적 순환 속에서 나아갑니다. 그렇지 않으면 기자들은 무슨 일을 하고 시민들은 무엇을 해야 할까요?&lt;/p&gt;
&lt;p&gt;그래서 저는 우리 각자가 할 수 있는 일이 관심을 기울이는 것이라고 생각합니다. 하지만 문제는 중국인들은 너무 쉽게 잊어버린다는 것입니다. 제가 방금 말씀드린 것처럼, 다른 사람의 차를 박고 나서 도로변에 세워두고 달아나면 아무도 막지 않습니다. 우리 이웃이나 동료들 중 상당수가 이런 사람들입니다. 그래서 천천히 변화시켜야 합니다. 그리고 우리와 같이 평범한 시민으로서 할 수 있는 일은 관심을 갖고 잊지 않는 것입니다. 과정이 부족한 것이 아니라, 배불리 먹고 따뜻하게 입기 전에는 사람들에게 이상을 이야기해도 설득력이 없습니다. 하지만 그들이 배불리 먹고 따뜻하게 입어서 세계 당뇨병 발병률 1위 국가, 고혈압 발병률 1위 국가 등 여러 개의 1위 국가가 되면, 중국인들은 달리기를 시작하고, 다이어트를 하기 시작합니다. 여기 있는 여러분의 여성분들께 묻는데, 제가 한 번 제대로 먹지 않으면 다이어트할 힘이 없었던 경험이 없는 사람이 있습니까? 이것이 작은 변화입니다.&lt;/p&gt;
&lt;p&gt;우리가 이야기하는 정신적인 차원도 마찬가지일 텐데, 배불리 먹고 따뜻하게 입었을 때, 달리기를 시작하고 다이어트를 할 때, 천천히 정신적인 욕구도 함께 늘어나는 것 같아요. 예를 들어 제가 예전에 담배를 피웠는데, 달리기를 시작한 후 갑자기 흐릿해진 기억 속에서 20일 넘게 담배를 안 피운다는 걸 발견했고, 그 이후에는 더 이상 피우지 않았어요. 물론 특별히 완전히 끊었다고 말하지는 않을게요. 너무 의식적인 느낌이라, 한 해에 두세 개비 정도는 태울 수도 있을 것 같아요. 생활 방식이 변하면 많은 것들이 함께 바뀌는데, 중국인들에게는 인내심을 가지고 기다려야 변화가 찾아올 거라고 생각해요.&lt;/p&gt;
&lt;p&gt;점점 더 많은 사람들이 자신을 행복하지 않다고 느끼지만, 스스로 불행에 빠지지는 않습니다. 우울증이 증가하는 것은 사실이지만, 다른 한편으로는 더 많은 사람들이 긍정적인 삶의 방식을 찾고 있습니다. 이럴 때 정신적인 측면이 성장하게 되니, 너무 비관적으로 생각하지 마세요. 똑같은 일이라도 어떻게 보느냐가 중요합니다. 저는 길에서 운전하며 끼어드는 사람들을 자주 보는데, 처음에는 좌절감을 느꼈지만, 곧 낙관적이 됩니다. 왜냐하면 다른 쪽 차선에 줄 서 있는 차량이 예전보다 훨씬 많기 때문입니다. 바로 이런 과정이죠. 오늘 이렇게 비가 그친 저녁에 이 자리에 모여 많은 쓸모없는 이야기를 나누는 것 자체가 즐거운 일이 아니겠습니까?&lt;/p&gt;
&lt;p&gt;이것 또한 일종의 변화이고, 많은 것들이 다른 방식으로 생각해야 하고, 물론 앞으로 천천히 늘어날 것이 많다고 생각합니다. 예를 들어 창업을 말씀하셨는데, 누구도 평생을 창업하며 살아갑니다. 모든 사람의 인생은 창업입니다. 지금 우리는 창업에 너무 시대적인 느낌을 부여하고 있지만, 사실 창업은 항상 존재했습니다. 소동파는 창업하지 않았나요? 이백은 창업하지 않았나요? 평생 동안 많은 것을 창조해냈고, 대부분 성공하지 못했지만 괜찮습니다. 당신이 충분히 맛있는 삶을 살고, 가치 있다고 느낀다면 됩니다. 지금 저는 중국이 특히 부족한 것은 좋은 실패가 또 다른 성공이라는 가치관이라고 생각합니다. 중국인들은 오직 성공적인 결말만을 받아들이지만, 좋은 실패는 성공이 아니라는 것을 받아들이지 않습니다.&lt;/p&gt;
&lt;p&gt;我覺得그건 정말 어렵다고 생각해요. 그래서 중국 축구가 잘 안 되는 이유가 많다는 걸 알게 됐는데, 그중 하나는 누구도 공을 잃을까 봐 자기에게 패스하거나 다른 사람에게 패스하는 것을 두려워한다는 거예요. 그런 플레이 방식이 없으니 당연히 아주 작은 이유 중 하나일 뿐이에요. 그래서 제가 이 나이에 30대에 들어서면서 서론에서 &amp;lsquo;느긋함과 행복&amp;rsquo;이라고 썼는데, 지금은 50세가 되니 조금 급해졌어요. 시간이 너무 빨리 지나가고, 기대했던 많은 것들이 현실이 되지 않았으니까요. 하지만 다른 한편으로는 중국이라는 나라의 경우, 많은 것이 점진적인 변화 과정이라는 것을 이해하고 있어요. 부모님을 보면, 어떤 분들은 신호등이 존재하지 않는다고 생각했지만 가끔 아이가 아빠 손을 잡는 모습을 볼 수 있죠. 변하고 있고, 변화를 겪고 있는 거니까요. 그래서 인내심을 좀 가져야 할 것 같아요.&lt;/p&gt;</description>
        </item>
        <item>
        <title>시간에 대해선 많은 책을 읽어야 답을 찾을 수 있을 것이다</title>
        <link>https://ttf248.life/ko/p/about-time-and-books/</link>
        <pubDate>Fri, 14 Feb 2020 07:27:21 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/about-time-and-books/</guid>
        <description>&lt;p&gt;나라 전체적으로 볼 때 좋아지고 부강해지는 추세인데, 만약 사람들의 허영심이 이만큼 강하지 않다면 더 좋을 텐데. 90년대부터 지금까지 제가 접촉한 가정들을 보면 모두 예전보다 생활 수준이 좋아졌고, 동시에 부유한 사람들도 많아졌습니다. 시장 경제 발전 과정에서 불가피하게 빈부 격차가 확대되는 현상이 나타났습니다.&lt;/p&gt;
&lt;p&gt;흔히 말하는 계층 고착화나 상승 기회가 막혀 있다는 것은 현재 세상의 흔한 문제점이며, 우리 당이 인민의 기본적인 복지 혜택과 사회 보장에 대해 이바지한 부분은 당연히 알아주어야 합니다. 소소한 일상생활이 점점 더 좋아질 것이고, 집을 사지 않고 싶다면 빌어서 살 수도 있습니다. 자녀 교육에도 교육 자원 분배 불균형 문제가 있고, 때로는 선택을 해야 할 수도 있습니다. 더 좋은 직업 기회나 환경을 원할 것인지, 아니면 가족과 더 많은 시간을 함께 보낼 것인지 고민해야 합니다. 자신의 생각을 다른 사람에게 강요하지 마세요. 당신의 자녀나 가족도 마찬가지입니다. 앉아서 차분히 이야기해 보세요. 결국 삶은 점점 더 나아질 것입니다.&lt;/p&gt;
&lt;h2 id=&#34;영상-원본&#34;&gt;영상 원본
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://v.youku.com/v_show/id_XNDI5MzA4NjcyNA&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;영상 원본 링크 클릭하여 보기&lt;/a&gt;, 혹시 저작권 침해 문제가 발생하면 연락 주시면 삭제하겠습니다. 이 글은 오직 텍스트 초안 번역을 위해 작성되었습니다.&lt;/p&gt;
&lt;h2 id=&#34;삼십세&#34;&gt;삼십세
&lt;/h2&gt;&lt;p&gt;삼십 세&lt;/p&gt;
&lt;p&gt;올해 벌써 50세가 됐습니다. 옛날에는 상상도 못 했는데, 이제야 나이가 들어 보이네요. 이게 30살 때 모습입니다. 30살 때는 자신이 젊고 예쁘다고 생각하지 않았지만, 50살이 되어서 뒤돌아보니 괜찮네요. 30대에 가장 큰 인생의 깨달음은 무엇일까요? 뒤돌아보면 빼기라고 생각합니다. 핵심 키워드는 빼기입니다. 어쩌면 고통과 즐거움 속에서도 빼기는 일종인데, 많은 것을 경험하고 생각했던 것들을 글로 쓰고 남겨두고 새로운 시작을 위해 달리기 시작했습니다. 하지만 제게 30대는 자신에게나 다른 사람들에게 주는 조언이든 뭐든 빼기가 정말 중요하다고 생각합니다.&lt;/p&gt;
&lt;p&gt;我现在在带东西联大的学生，我经常提醒他们，在30岁之前要玩命的做加法，要去尝试，你不知道自己有多少种可能，你也不知道命运将会给你怎样的机缘。所以不是你怎么知道，但是有的人就在20多岁的时候拼命的事，各种加法，但是忘了收，忘了到一定的时候要做减法，我觉得30岁左右是人生非常重要的一个，要在做了一系列加法和四处乱跑之后，要做一次减法的重要时间，否则就晚了，为什么要做减法？你不是所有的都适合，也不是适合你的，所有的事，你都该去做。 저는 현재 연대 학생들을 가르치고 있는데, 항상 그들에게 30세가 되기 전에 모든 노력을 다해 더하기를 해야 한다고 말합니다. 다양한 가능성을 시도해 봐야 하고, 운명이 어떤 기회를 줄지 모릅니다. 그래서 어떻게 알겠습니까? 하지만 어떤 사람들은 20대 때부터 필사적으로 여러 가지 더하기를 하지만, 빼기를 할 때가 왔다는 것을 잊고, 30세 정도는 인생에서 매우 중요한 시기라고 생각합니다. 일련의 더하기와 여기저기 돌아다니는 것들을 하고 난 후에 한 번 빼기를 해야 할 중요한 시간입니다. 그렇지 않으면 너무 늦습니다. 왜 빼기를 해야 할까요? 모든 것이 당신에게 맞는 것도 아니고, 당신에게 어울리는 것도 아닙니다. 모든 일을 다 해봐야 합니다.&lt;/p&gt;
&lt;p&gt;너를 묶는 8개의 선이 있다, 얼마나 멀리 도망갈 수 있을까? 서로 제약을 걸 수도 있어&lt;/p&gt;
&lt;p&gt;저렴한&lt;/p&gt;
&lt;p&gt;30살이 되어서는 특별 승진을 했는데, 학자라면 교수고 기자라면 고위 기자가 되는 것이죠. 29살에 특별 승진했고, 지금처럼 이런 일이 있는 건 드물지만 그때부터 엄청난 혼란을 느끼기 시작했습니다. 2000년에 시드니 올림픽을 하면서 박수도 많았는데 갑자기 모든 게 엉망인 것 같았습니다. 스스로에게 물었습니다. 나는 대체 무엇을 해야 하는 걸까? 무엇을 버려야 할까? 그해 아주 중요한 감산을 했는데, 제 프로그램을 중단했습니다. 1년 동안 방송 출연도 없이 지냈습니다. 당시 사람들이 말하길, 진행자는 한 달만 방송에 나오지 않으면 괜찮은데 반 년이 지나면 아무도 당신을 기억하지 못할 거라고 했습니다. 저는 “제 얼굴이 이렇게 싸구려 같나 보네요.”라고 답했습니다.&lt;/p&gt;
&lt;p&gt;그 해부터 새로운 프로그램을 개발하기 시작했어요. 고통과 즐거움을 모두 겪은 후에, 01년에 저는 한동안 완전히 멈춰 있었죠. 오늘 제가 하고 있는 모든 일들은 사실 그 당시의 비움에 대한 깨달음에서 비롯된 거예요. 그때는 스포츠를 할 수도 있고, E(엔터테인먼트)를 할 수도 있고, 다른 재미있는 일들을 많이 할 수 있었어요. 프로듀서를 할 수도 있었고요. 하지만 저는 안 됐다고 했죠. 제가 할 수 있는 건 뉴스뿐이고, 가장 잘할 수 있는 것도 뉴스라고 생각했어요. 그래서 당시 세 개의 프로그램의 프로듀서였는데, 갑자기 모두 그만두고 오늘날의 제가 된 거죠. 제 마음이 순수해진 거예요. 며칠 전 동료들과 이야기하면서 30대 초반에 내린 아주 중요한 결정에 대해 말하기도 했어요. 할 수 있는 일들이 많았지만, 저는 뉴스 일을 하고 싶었고, 마치 깊은 우물처럼 그 길을 파고들었어요. 많은 직위에서 저를 부주편집장으로 승진시키려고 제안했지만, 저는 모두 거절하고 평범한 사람의 기반으로 돌아왔죠.&lt;/p&gt;
&lt;p&gt;학부생&lt;/p&gt;
&lt;p&gt;지금까지 저는 중앙电视台 부서장급 간부였고, 절대적으로 학사 졸업생 출신이 아닌 일반적인 인파가 아니었습니다. 당신은 우리 체제를 이해하고 있지만, 저는 거절했습니다. 한번은 학사 학위로 어디까지 올라갈 수 있는지 보고 싶었고, 학사 학위로는 왜 끊임없이 배우고 스스로 대학원생을 지도할 수 없는지 궁금했습니다. 네, 지금은 대학원생을 11명이나 맡고 있는데, 이는 일종의 차감 결과입니다. 물론 뒤돌아보면 감회가 드는 일이겠죠. 게다가 젊었을 때는 특히 분주함 속에서 결국 모든 것을 다 가져야 한다는 느낌이 들었습니다. 만약 어떤 것을 얻지 못하거나, 어떤 일에 조금이라도 결함이 있다면 마음이 매우 불편했습니다.&lt;/p&gt;
&lt;p&gt;여기 계신 여러분, 부디 뺄셈을 하는 법도 배우셔야 합니다. 바로 28살처럼 30살에 가까워질 때, 1996년 올림픽을 보면서 저는 이런 문장을 만들어냈습니다. &lt;strong&gt;결함은 완벽의 중요한 부분이며, 이 세상에는 완벽한 것은 없습니다.&lt;/strong&gt; 曾国藩의 장편 소설에도 아주 중요한 한 구절이 쓰여 있습니다. 인생의 최고의 경지는 무엇일까요? 曾国藩은 자신의 서실 이름을 求阙厅이라고 하고 싶어 했습니다. 꽃이 완전히 피기 전이 가장 좋을 때이고, 달이 완전히 둥글지 않을 때가 가장 좋습니다. 하지만 보통 사람들은 이것을 결함이라고 생각하고, 아직 완벽하지 않고 최고에 도달하지 못했다고 느낍니다. 사람을 망치는 최고의 방법은 그에게 완벽과 극단을 추구하게 하는 것입니다.&lt;/p&gt;
&lt;p&gt;꽃이 완전히 피지 않았다&lt;/p&gt;
&lt;p&gt;이 세상은 그런 것이 아니에요. 꽃이 완전히 피기 전이 가장 좋을 때이고, 꽃이 완전히 핀 후에는 떨어질 날이 얼마 남지 않았어요. 달이 완전히 둥글기 시작하면 서서히 초승달로 변하는 날이 가까워지고, 그래서 저는 이것이 제 30대에 저에게 중요한 동기 부여와 깨달음을 주는 것 같아요. 40대에는 그럴 때가 없네요. 하지만 편안해졌어요. 더 자유로워진 것 같아요. 왜 이제는 정장을 입고 검은색과 흰색으로만 보이는 것이 아니라 행복을 묻기 시작했을까요?&lt;/p&gt;
&lt;h2 id=&#34;사십세&#34;&gt;사십세
&lt;/h2&gt;&lt;p&gt;마흔 살&lt;/p&gt;
&lt;p&gt;중국인들 중에 &amp;ldquo;마흔 살은 고뇌의 시기&amp;quot;라는 말이 있는데, 서른 살은 빼앗기는 것 같고 마흔 살은 혼란스럽지만 무혹이 아니라고 하는데, 요즘 시대에는 마흔 살에 혼란을 겪는 사람들이 가장 많은 것 같아요. 저의 중년 위기는 유독 빨리 찾아와서 스물여섯일곱 살부터 이 모든 일이 가치가 있나 고민하게 됐어요.&lt;/p&gt;
&lt;p&gt;의미가 있을까? 내가 과연 무엇을 행복이라고 해야 할까? 이 책은 바로 이러한 혼란 속에서 탄생했다. 30세쯤 되면 많은 행복 목표들이 물질과 연결되어 있다는 것을 깨닫게 되고, 30에 설(立)한다는 것은 학력으로 기반을 다진다는 뜻이다. 차도 있고 집도 있어야 장모님이 딸을 시집보내 주는데, 매우 물질적이다. 하지만 40대에 고뇌하기는 어렵다. 옛날 사람들은 아마 평균 수명이 지금보다 짧았기 때문에 40에 모든 것을 응축하여 고뇌를 겪고 불혹(不惑)했다고 생각한다. 나는 40대인데 아직도 혼란스럽다. &lt;strong&gt;물질은 나에게 행복을 가져다주지 않았다, 내가 그렇게 생각했던 행복을 말이다.&lt;/strong&gt; 역시 40세쯤 되면 많은 사람들이 나에게 묻는다. “당신은 행복합니까?”&lt;/p&gt;
&lt;p&gt;그 책 제목이 행복의 물결인가요? 물음표인데, 제 마음속의 혼란을 나타내는 거죠. 중년의 위기가 찾아오면 40살쯤 스스로에게 던지는 질문에 답해야 하고, 40살 정도가 되면 자신과 자주 대화하고 많은 것을 읽어 스스로에게 해답을 줘야 합니다. 다행히 제가 36세 7세 때 도덕경의 세계에 들어갔고, 백설에서 이미 말씀드렸듯이 40살쯤 생각할 일이 있을 때 주변 환경이 변하지 않고, 특히 소프트 환경이 바뀌지 않으면, 집 밖으로 나가서 신나게 걸어가는데 어디선가 빨간 불과 초록 불이 마구 엉켜 있고, 물건을 사도 가짜이고, 백신까지 맞아야 하는 상황이라면요.&lt;/p&gt;
&lt;p&gt;나는 이틀 동안 중국이 두 개의 태풍과 싸우고 있다고 말했는데, 하나의 태풍은 보이지 않고 다른 하나는 보이는 태풍입니다. 보이지 않는 태풍은 백신이고, 그것은 우리의 내면의 안전 둑을 공격합니다. 또 다른 태풍은 중국에서 상하이에 상륙하는 태풍이 드물지만, 이 이야기는 그만두고, 다음으로 당신이 생각해야 할 것은, 당신이 스스로를 위해 좋은 일을 하고, 당신에게 많은 답이 있고, 주변 환경이 변하지 않으면 행복할 수 있느냐입니다. &lt;strong&gt;저는 8개의 글자로 말했는데, 좀 더 무겁게 느껴집니다. 지금 우리는 도덕적 적자와 인간성 상실을 겪고 있으며, 이것이 현재 가장 큰 적자이자 가장 큰 손실입니다.&lt;/strong&gt; 며칠 전 이 근처에서 두 대의 차가 충돌하는 것을 직접 목격했습니다. 충돌은 그렇게 심하지 않았지만, 책임져야 할 사람이 다른 차를 들이받았고, 상대방에게 길가에 세우라고 말했고, 상대방도 천천히 길가에 세울 준비를 하고 있었는데, 앞차가 갑자기 도망갔고, 아무도 그를 막지 못했습니다.&lt;/p&gt;
&lt;p&gt;이 사람이 책임감 있는 아버지일까? 이 사람이 책임감 있는 아들이려나? 더군다나 그가 어떻게 책임감 있는 시민이 될 수 있을지 궁금하다. 그는 당신의 동료일 수도 있는데, 이것이야말로 도덕적 결핍과 인간성의 상실이며, 반드시 당신에게 영향을 미칠 것이다. 아무리 훌륭한 사람이라 할지라도, 집에서만 나오지 않는다고 해서 문제가 해결되는 것은 아니다. 예를 들어, 백신 접종을 해야 하는 자녀가 있을 수도 있고, 배달 음식이 있다면 음식에도 문제가 있을 수 있다!&lt;/p&gt;
&lt;p&gt;그래서 중국인이 어떻게 평범한 백성에서 시민으로 변하는지 배우게 될까, 이는 아마도 내가 40세쯤에 스스로에게 물어보는 질문이기도 하고 사회 전체에 중요한 문제이기도 할 것이다&lt;/p&gt;
&lt;p&gt;만약 30대가 마이너스라면, 40대는 혼란이라면, 나는 50대에 스스로에게 선물하는 단어를 호기심이라고 생각한다. 50대는 어색하다. 앞뒤로 갈 곳이 없다. 나아가면 공격할 만하고, 물러나면 융통성 있게 지낼 수도 있다. 자신이 얻은 무언가에 누워 10년을 보내고 은퇴까지 융통성 있게 지내는 것도 가능할 것 같다.&lt;/p&gt;
&lt;p&gt;최근에 책을 하나 읽었는데, 그 책 중에 한 구절이 매우 흥미로웠다. 실리콘밸리에서 진정으로 성공한 창업자들은 주로 50대 후반인 경우가 많다는 내용인데, 이는 우리의 생각과는 다른 점이다. 중국도 창업을 젊은 세대의 일이라고만 여기지 않아야 하고, 자원봉사자를 모두 청년 자원봉사자로 취급해서는 안 된다. 지난주에 프로그램을 진행했는데, 은퇴한 초중학교 교사를 채용하려는 프로그램이었다. 매년 2~3만 위안의 보조금을 받고 농촌에서 교사로 일하는 것으로, 반드시 우수한 인재여야 한다. 이처럼 은퇴 후 재고용을 개척하는 것은 좋은 일이다. 물론 자선 활동도 포함되지만, 50대에 도달하려면 아직 거리가 있다. 어떻게 나아갈 수 있을까?&lt;/p&gt;
&lt;h2 id=&#34;오십세&#34;&gt;오십세
&lt;/h2&gt;&lt;p&gt;쉰쑤이&lt;/p&gt;
&lt;p&gt;더 중요한 것은 50세 사람들에게 두 가지 도전이 있다는 것입니다. 첫 번째 도전은 바로 자기 자신입니다. 아직 많은 것에 대해 호기심을 느끼고 있나요? 그리고 당신의 인생관은 어떤가요? 제 50대에 가장 큰 수확이라고 할 수도 있고, 지금 제가 살아가는 방식은, &lt;strong&gt;오늘날을 소중히 여기는 것입니다. 20대 때는 내일에 쉽게 살아가지만, 한순간 방심하면 50세에는 어제에 사로잡히기 쉽습니다. 하지만 저는 끊임없이 절제하며 내일에도 어제에도 살지 않고 오늘날을 소중히 여깁니다. 50세 사람은 항상 내일이나 과거가 좋다고 말하지 않아야 합니다!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;오늘 제 생각에는 최진의 콘서트 앨범을 보는 게 제일 좋을 것 같아요. 최진이 한 말 중에 “사진을 볼 때마다 두 전년도의 내가 참 예뻤다고 생각하지만, 그때 그날은 스스로가 예쁘다고 생각해 본 적이 없었다”라는 말이 꽤 좋았어요. 이 문장에 뭔가 맛이 있는 것 같아요. 제가 서른 살 때는 그렇게 생각하지 않았어요. 그때는 괜찮다고 생각했고 제 결점이 많다고 생각했지만, 오늘 20년이나 지나서 뒤돌아보니 그랬더라고요.&lt;/p&gt;
&lt;p&gt;옛날에 저도 젊었었고, 머리도 많았었죠. 그러니 당신의 오늘을 소중히 여기고, 2년 후에 당신의 오늘을 다시 보는 것보다 더 좋은 일은 없을 거예요.&lt;/p&gt;
&lt;p&gt;내 다리가 걷잡을 수 없을 때, 휠체어에 앉아 매일 달리며 농구를 하던 시절을 그리워하며, 그 생각만으로도 매일 고통스러웠다
또 몇 년이 흘렀는데, 휠체어에 앉아 있는데 욕창이 생기고 온몸이 고통스러웠다. 그 때마다 몇 년 전 내가 아프지 않고 조용히 휠체어에 앉아 있을 수 있었던 시절을 그리워했다.
또 몇 년이 흘렀는데, 내가 신부전으로 고통받게 되었어. 계속 투석을 받아야 하고, 그때마다 나는 褥瘡만 있던 시절의 휠체어를 그리워해. 만약 50세까지 살지 못한다면, 앞으로의 50년은 헛고생한 셈이야.&lt;/p&gt;
&lt;p&gt;사실 저는 50세가 되어서야 이道理를 깨닫는 것을 기다릴 필요는 없다고 생각해요. 30대, 40대에 알아차려야죠. 모든 것이 쉽게 지나갈 수 있어요. 여행 중의 한 끼 식사를 놓치면, 30년 후에 다시 먹어도 맛이 없을 수도 있잖아요. 그래서 저는 50세가 되었을 때 가장 먼저 느낀 점은 오늘날을 소중히 여기는 것 같아요.&lt;/p&gt;
&lt;p&gt;두 번째는 호기심인데, 저는 이제 많은 것을 더 이상 궁금해하지 않아도 될 것 같다는 걸 깨달았습니다. 너무나 많은 것을 보고 경험했기 때문이죠. 하지만 스스로를 호기심을 유지하도록 독려합니다. 그래서 지금 하는 모든 일에 호기심을 가지고 임하고 있습니다. 휴대폰을 세로로 찍을 수 있을까요? 물론 가능합니다. 현장 보도를 하고, 겉으로는 매우 크고 엄숙한 듯 보이는 어떤 회의에 참석할 수도 있죠. 연결은 더 쉽고 재미있게, 사람들에게 깊은 인상을 남길 수 있을까요? 새로운 미디어를 통해 전파할 수도 있습니다. 호기심은 인간 진보를 촉진하는 가장 중요한 동력이라고 생각합니다. 왜 개인의 성장을 촉진하는 가장 중요한 동력이 될 수 없을까요? 한 민족이 호기심을 잃으면, 그 민족은 끝나는 겁니다. 또 다른 큰 차원에서 보면, 50세는 중요한 시험입니다. 40대에서 50대에 이르러서 중국에서 어떤 기득권자가 되는 것일까요? 저는 우리 주변의 많은 사람들이 젊었을 때 희망을 가지고 많은 꿈을 이루기 위해 노력했지만, 일단 자신의 꿈을 이루고 기득권자가 되면 다른 사람들의 꿈을 가로막는 사람이 된다는 점이 매우 걱정됩니다. 제가 맞춘 거죠? 돌이켜보면 그가 가장 싫어했던 방식으로 젊은 세대와 일에 대하고 있습니다.&lt;/p&gt;
&lt;p&gt;그래서 몇 년 전부터 제가 직접 자원봉사자 신분으로 매년 11명의 대학원을 모집하고, 두 해 동안 기다려주고, 이제 벌써 5개 학년을 졸업시켰습니다. 55명의 순수 대학원생들이 이미 졸업했습니다. 그런 특권층이 되는 것이 매우 행복하다고 생각합니다. 어떤 감정을 가지게 되고, 그들을 이끌 수 있는 능력이 생깁니다. 매일 수업을 마치고 저녁에 식사를 함께 하면 큰 돈이 들지 않습니다. 하지만 이것은 좋은 특권층이 해야 할 일입니다. 특권층은 두 가지 측면이 있을 수 있습니다. 한 가지는 다시 돌멩이가 되는 것입니다. 저는 한때 이런 말을 했습니다. 너무 많은 사람들에게 감사하다고 말하고 싶지 않다고 했어요. 왜냐하면 새로운 젊은이들을 배가하여 대하는 것이 저의 감사의 방식이기 때문입니다.&lt;/p&gt;
&lt;p&gt;만약 매일 그 자리에 앉아 &amp;ldquo;고맙습니다&amp;quot;라고 말하는 것이 방해자가 된다면, 다음은 다른 사람을 위한 길을 만드는 것이다. 중국이든 물질적, 경제적, 사상적, 문화적, 모든 분야에서 이익을 얻은 사람들이 당신도 그런 사람이 되었을 때 어떻게 해야 할지 고민해야 한다. 어제 기차를 밀었던 사람이 오늘 기차를 막는 사람이 된다면, 뒤돌아보면 중국 역사 곳곳에서 이런 일이 벌어지고 있다. 오늘날에도 마찬가지다. 오히려 더 심할 수도 있으므로 모든 이익을 얻은 사람들에게 당신이 젊었을 때 어떤 사람과 마주하기를 바랐는지처럼 행동해 주기를 촉구한다. 그런 사람들과 나는 충분히 잘 지내지 못했을지도 모르지만, 적어도 나는 생각하고, 하고, 말하려고 노력한다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>표준 라이브러리 컨테이너의 메모리 할당자: allocator</title>
        <link>https://ttf248.life/ko/p/standard-library-container-memory-allocator/</link>
        <pubDate>Mon, 30 Dec 2019 13:26:19 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/standard-library-container-memory-allocator/</guid>
        <description>&lt;p&gt;사용자 정의 할당자는 성능을 향상시키고 메모리 사용 효율성을 높이며 빈번한 소량의 메모리 할당 문제를 해결할 수 있습니다&lt;/p&gt;
&lt;h4 id=&#34;전인&#34;&gt;전인
&lt;/h4&gt;&lt;p&gt;최근 네트워크 데이터 패킷 개발을 진행하면서 빈번하게 작은 메모리 블록을 할당하고 해제해야 하는데, 원래는 메모리 풀을 사용하려 했고, 기존의 몇몇 메모리 풀들을 살펴보니 이런 것을 발견했다&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/cacay/MemoryPool&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/cacay/MemoryPool&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;인터페이스를 보니까 좀 이상하다는 생각이 들었는데, 이 메모리 풀 구현 방식이 왜 이렇게 특이할까. &lt;code&gt;MemoryPool&lt;/code&gt;의 구현 로직은 고정된 크기의 메모리 공간을 할당하는 방식인데. Boost의 메모리 풀 인터페이스를 보면 템플릿으로 제공되고 사용 시에 인스턴스화해야 한다. 다행히 이 라이브러리에 대한 설명이 있는 글도 있고, 거기서 &lt;code&gt;allocator&lt;/code&gt;라는 개념이 언급되어 있었다.&lt;/p&gt;
&lt;h4 id=&#34;wikihttpszhwikipediaorgwikie58886e9858de599a8_c2b2b&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_%28C%2B%2B%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wiki&lt;/a&gt;
&lt;/h4&gt;&lt;p&gt;C++ 프로그래밍에서 할당자(allocator)는 C++ 표준 라이브러리의 중요한 구성 요소입니다. C++ 라이브러리에는 연결 리스트, 집합 등 다양한 “컨테이너” 데이터 구조가 정의되어 있으며, 이러한 컨테이너의 공통적인 특징 중 하나는 프로그램 실행 시간에 크기를 변경할 수 있다는 것입니다. 이를 구현하기 위해 동적 메모리 할당이 필수적이므로 할당자는 컨테이너의 메모리 할당 및 해제 요청을 처리하는 데 사용됩니다. 다시 말해, 할당자는 표준 템플릿 라이브러리(STL) 컨테이너의 메모리 관리에 대한 저수준 세부 사항을 캡슐화합니다. 기본적으로 C++ 표준 라이브러리는 자체 제공하는 범용 할당자를 사용하지만, 필요에 따라 프로그래머는 자신만의 할당자를 정의하여 이를 대체할 수 있습니다.&lt;/p&gt;
&lt;p&gt;할당기는 원래 C++ 표준 템플릿 라이브러리(Standard Template Library, STL)의 일부로 알렉산드르 스테파노프에 의해 발명되었으며, 그의 초기 목표는 &amp;ldquo;라이브러리를 더욱 유연하게 만들고 기본 데이터 모델에 의존하지 않는 방법&amp;quot;을 만드는 것이었습니다. 이를 통해 프로그래머는 라이브러리에서 사용자 정의 포인터 및 참조 유형을 활용할 수 있었습니다. 그러나 C++ 표준 템플릿 라이브러리를 C++ 표준으로 포함하는 과정에서 C++ 표준 위원회는 데이터 모델의 완전한 추상화가 용납할 수 없는 성능 저하를 초래한다는 것을 깨달았습니다. 이러한 절충안으로 인해 표준에서 할당기에 대한 제한이 더욱 엄격해졌고, 결과적으로 현재 표준에 설명된 할당기는 스테파노프의 원래 구상과 비교하여 사용자 정의 가능성이 크게 제한되었습니다.&lt;/p&gt;
&lt;p&gt;할당기 사용자 정의는 어느 정도 제한이 있지만, 많은 경우 다양한 메모리 공간(공유 메모리나 재활용 메모리와 같은)에 대한 접근 방식을 캡슐화하거나, 메모리 풀을 사용하여 메모리를 할당할 때 성능을 향상시키기 위해 여전히 사용자 정의 할당기가 필요합니다. 또한, 빈번한 소량의 메모리 할당이 발생하는 프로그램에서 전용으로 맞춤 제작된 할당기를 도입하면 메모리 사용량과 실행 시간 측면에서도 상당한 이점을 얻을 수 있습니다.&lt;/p&gt;
&lt;h4 id=&#34;사용-요건&#34;&gt;사용 요건
&lt;/h4&gt;&lt;p&gt;정의된 사용자 정의 할당자의 주요 이유 중 하나는 성능 향상입니다. 전용 사용자 정의 할당자를 사용하면 프로그램의 성능을 높이거나 메모리 사용 효율성을 높이거나 둘 다 달성할 수 있습니다[4][8]. 기본 할당자는 new 연산자를 사용하여 저장 공간을 할당하는데, 이는 종종 C 언어 힙 할당 함수(malloc())를 통해 구현됩니다[9]. 힙 할당 함수는 일반적으로 일시적으로 많은 양의 메모리를 할당하는 데 최적화되므로 대량의 메모리를 한 번에 할당해야 하는 컨테이너(예: 벡터, 양방향 큐)의 경우 기본 할당자는 일반적으로 효율적입니다[8]. 그러나 연결된 컨테이너 및 양방향 링크드 리스트와 같이 빈번하게 소량의 메모리를 할당해야 하는 컨테이너의 경우 기본 할당자를 사용하면 일반적으로 효율성이 매우 낮습니다[4][9]. 또한 malloc()을 기반으로 하는 기본 할당자는 낮은 지역성[4]과 메모리 조각화 발생 가능성[4][9]과 같은 많은 문제를 가지고 있습니다.&lt;/p&gt;
&lt;p&gt;간단히 말해서, 이 부분(……)은 마치 이 표준이 할당기(allocator)에 대해 발표한 《나는 꿈이 있다》와 같습니다. 꿈이 실현되기 전에는 이식 가능성을 고려하는 프로그래머들은 상태 없는(stateless) 사용자 정의 할당기를 사용하는 데 스스로를 제한할 것입니다.
——스코트 메이스, 《Effective STL》
이러한 점을 감안하여, 이러한 상황에서 사람들은 빈번한 소량 할당 문제를 해결하기 위해 메모리 풀 기반 할당기를 자주 사용합니다[8]. 기본 “요청 시 할당” 방식과 달리, 메모리 풀 기반 할당기를 사용할 때는 프로그램이 미리 대용량 메모리(즉, &amp;ldquo;메모리 풀&amp;rdquo;)를 할당하고, 필요할 때 사용자 정의 할당기는 요청자에게 풀 내 메모리의 포인터를 반환하기만 합니다. 객체 소멸 시에는 실제로 메모리를 해제하지 않고, 메모리 풀의 수명이 종료될 때 비로소 메모리를 해제합니다[주 1][8].&lt;/p&gt;
&lt;p&gt;“사용자 정의 할당기”라는 주제에 대해 이미 많은 C++ 전문가와 관련 저자들이 참여하여 토론해 왔습니다. 예를 들어 스콧 메이어스의 “Effective STL”과 안드레이 알렉산더레스쿠의 “Modern C++ Design”에도 언급되어 있습니다. 메이어스는 특정 타입 T의 할당기 인스턴스가 모두 동일해야 한다면, 이식 가능한 할당기 인스턴스는 상태를 포함해서는 안 된다고 통찰했습니다. C++ 표준은 라이브러리 구현자가 상태 기반 할당기를 지원하도록 장려하지만[문헌 4], 메이어스는 관련 단락이 “（보이는 듯한）아름다운 관점”이지만 거의 말장난이라고 비판하며, 할당기의 제약이 “지나치게 엄격하다”고 주장했습니다[4]. 예를 들어 STL의 list는 splice 메서드를 제공하는데, 이는 list 객체 A의 노드를 다른 list 객체 B에 직접 이동시킬 수 있습니다. 이는 A의 할당기가 할당한 메모리가 B의 할당기에 의해 해제될 수 있어야 하므로, A와 B의 할당기 인스턴스가 동일해야 함을 의미합니다. 메이어스의 결론은 할당기를 정적 메서드를 사용하는 타입으로 정의하는 것이 가장 좋다는 것입니다. 예를 들어 C++ 표준에 따르면 할당기는 rebind 메서스를 구현한 other 클래스 템플릿을 제공해야 합니다.&lt;/p&gt;
&lt;p&gt;또 다른 한편, 《C++ 프로그램 설계 언어》에서 비야니 스트라우스트루프는 “‘엄격한 할당기 제한으로 각 객체 정보의 차이를 없앤다’는 점은 분명 큰 문제가 아니다.”라고 주장하며 대부분의 할당기는 상태가 필요하지 않으며 심지어 상태가 없는 경우 성능이 더 좋을 수도 있다고 지적한다. 그는 메모리 풀형 할당기, 공유 메모리형 할당기 및 가비지 컬렉션형 할당기의 세 가지 사용자 정의 할당기 사용 사례를 제시하고 내부 메모리 풀을 활용하여 소량의 메모리를 빠르게 할당/해제하는 할당기 구현을 보여준다. 하지만 그는 이러한 최적화가 이미 그가 제공한 예시 할당기에서 구현되었을 수도 있다고 언급한다[3].&lt;/p&gt;
&lt;p&gt;사용자 정의 할당기의 또 다른 용도는 메모리 관련 오류를 디버깅하는 것입니다[10]. 이를 위해 추가 메모리를 할당하여 디버그 정보를 저장할 수 있도록 할당기를 작성할 수 있습니다. 이러한 할당기는 메모리가 동일한 유형의 할당기에서 할당/해제되는지 확인하는 것 외에도 캐시 오버플로로부터 프로그램이 어느 정도 보호되도록 할 수 있습니다[11].&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
