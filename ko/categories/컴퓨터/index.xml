<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>컴퓨터 on 향숙의 수첩</title>
        <link>https://ttf248.life/ko/categories/%EC%BB%B4%ED%93%A8%ED%84%B0/</link>
        <description>Recent content in 컴퓨터 on 향숙의 수첩</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ko</language>
        <lastBuildDate>Mon, 26 May 2025 00:49:57 +0800</lastBuildDate><atom:link href="https://ttf248.life/ko/categories/%EC%BB%B4%ED%93%A8%ED%84%B0/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>클로드4 출시, Hugo 태그 및 하이퍼링크 번역 도우미 개발 시도</title>
        <link>https://ttf248.life/ko/p/claude-4-release-and-experimentation-hugo-tags-hyperlink-translation-assistant/</link>
        <pubDate>Sat, 24 May 2025 03:05:31 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/claude-4-release-and-experimentation-hugo-tags-hyperlink-translation-assistant/</guid>
        <description>&lt;p&gt;이 사이트는 hugo 기반이지만, 글 제목을 항상 중국어로 사용했기 때문에 생성되는 기사 링크가 친절하지 않습니다. 쉽게 말해서, 공유할 때 보기 좋지 않고, 중국어 문자가 링크에서 %E4%BD%A0%E5%A5%BD 와 같은 형태로 변환되기 때문입니다. 슬러그를 설정하여 해결할 수 있지만, 매번 수동으로 설정해야 해서 번거롭습니다.&lt;/p&gt;
&lt;p&gt;그래서 오늘 클로드4를 활용하여 중국어 제목을 영어 슬러그로 자동 변환하고, 기사에 하이퍼링크를 추가하는 번역 도우미를 개발해 보았습니다. 이렇게 하면 수동 설정의 번거로움을 피할 수 있습니다.&lt;/p&gt;
&lt;p&gt;클로드4는 정말 좋네요, 문맥 이해 능력과 복잡한 작업 처리 효율이 크게 향상되었습니다&lt;/p&gt;
&lt;p&gt;프로젝트 주소&lt;/p&gt;
&lt;p&gt;국내 프로젝트 주소: &lt;a class=&#34;link&#34; href=&#34;https://cnb.cool/ttf248/hugo-content-suite&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cnb.cool/ttf248/hugo-content-suite&lt;/a&gt;
해외 프로젝트 주소: &lt;a class=&#34;link&#34; href=&#34;https://github.com/ttf248/hugo-content-suite&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ttf248/hugo-content-suite&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;코드 구현&lt;/p&gt;
&lt;p&gt;먼저 구현 아이디어부터 설명드리자면, 모든 문서를 스캔하여 태그 정보와 문서 제목을 추출한 다음, 로컬 모델(예: gemma-3-12b-it)을 호출하여 번역합니다&lt;/p&gt;
&lt;p&gt;실제 개발에서 &lt;code&gt;Claude4&lt;/code&gt;는 이전 세대 대규모 언어 모델과 비교하여 몇 가지 뚜렷한 특징을 보여줍니다. 다양한 기능 요구 사항으로 인해 &lt;code&gt;Claude4&lt;/code&gt;는 자동 인터랙티브 메뉴를 설계하고, 모든 사용 시나리오를 포괄적으로 고려했습니다. 예를 들어, 태그 처리 측면에서 &lt;code&gt;Claude4&lt;/code&gt;는 태그의 통계 및 분석은 물론 분류 통계까지 지원하며, 심지어 &lt;strong&gt;비표시된 문서&lt;/strong&gt;도 감지할 수 있습니다. 또한 &lt;strong&gt;미리 보기&lt;/strong&gt;와 태그 페이지 생성 기능도 제공합니다.&lt;/p&gt;
&lt;p&gt;로컬 모델 연동, 번역 캐시 추가, 대규모 코드 리팩토링 등 무엇이든 한 번에 처리하며 거의 문제 없이 완료됩니다. 프로젝트 규모는 크지 않지만 다양한 기능들을 포함하고 있었는데, 기존의 거대 언어 모델들이 개발 과정에서 앞뒤 맥락을 잊는 경우가 많았지만 이번 &lt;code&gt;Claude4&lt;/code&gt;는 &lt;strong&gt;거의 맥락을 잊지 않았습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;간단히 말해서, 지능이 향상되었고, 이후 개발 작업은 주력 모델로 일상 코딩에 활용하기 위해 &lt;code&gt;Claude4&lt;/code&gt;로 전환할 준비를 하고 있습니다&lt;/p&gt;
&lt;p&gt;번역 캐시&lt;/p&gt;
&lt;p&gt;이 점은 단독으로 볼 때, 거대 모델 호출 횟수를 줄이는 것 외에도 실제 로컬에서 12B 모델을 실행하면 효율이 괜찮고 업무를 방해하지 않지만, 매번 거대 모델을 호출해야 하면 조금 느려지는 경향이 있습니다. 또한, 기사의 연결을 고정하기 위해 전체 업데이트 작업을 수행할 때 기사 제목이 길면 가끔씩 두 번 번역된 결과가 달라져서 기사 링크가 변경되는 상황이 발생하는데, 이 부분은 상당히 난감합니다.&lt;/p&gt;
&lt;p&gt;기능 개선&lt;/p&gt;
&lt;p&gt;전체 프로젝트를 &lt;code&gt;클로드4&lt;/code&gt;에 맡겨 분석 및 최적화 공간을 확인한 결과, 다음과 같은 제안을 받았습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;配置外置化 - 提高可维护性和灵活性
结构化日志 - 便于问题排查和监控
性能监控 - 了解系统运行状况
用户体验 - 进度条等视觉反馈
错误处理 - 更完善的异常处理机制
代码组织 - 更清晰的模块划分
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;코드 검토 결과, 문제 없습니다. 예를 들어 설정 파일의 경우, 기존 코드 설정을 기본 설정으로 변환하고, 설정 파일을 읽을 때 해당 파일이 없으면 자동으로 생성하여 사용자 실수로 인한 오류를 방지합니다.&lt;/p&gt;
&lt;h3 id=&#34;heading&#34;&gt;
&lt;/h3&gt;&lt;p&gt;요구 사항: 본문 번역 시 현재 번역 효율을 동적으로 계산하고, 남은 시간을 예측하여 콘솔에 관련 정보를 출력합니다. 현재 획득한 문서의 문자 수, 각 행 번역 시 현재 번역된 문자 수, 시간, 100자당 예상 번역 시간 등을 계산하며, 문서의 남은 번역 예상 시간도 함께 계산합니다.&lt;/p&gt;
&lt;p&gt;코드는 마무리했는데, 결과가 만족스럽지 않아 AI에게 새로운 디자인 방안을 제시하도록 했어:&lt;/p&gt;
&lt;p&gt;다양한 효율성 계산 방식 제공: 실시간 효율, 평균 효율, 슬라이딩 윈도우 효율
표시 방식 개선: 진행률 표시줄, 단계별 통계, 동적 새로 고침
더 유용한 지표 추가: API 호출 횟수, 성공률 등&lt;/p&gt;
&lt;p&gt;코드 완성 후 새로운 깜짝 놀랄 일이 발견되었는데, 번역 효율 통계 정보가 실시간으로 화면을 채우지만 맹목적으로 아래로 스크롤되지는 않는다&lt;/p&gt;
&lt;p&gt;번역 전문을 영어로 번역 중입니다 (총 7163자)
53행이 번역 필요로 감지됨
[1/53] Stage1/6 [░░░░░░░░░░░░░░░░░░░░░░░░░] 1.9% 번역 354자..
✅ 완료 (3.1초) | API 호출 #1
✅ 완료 (1.5초) | API 호출 #2
완료 (0.9초) | API 호출 #3
완료 (0.2초) | API 호출 #4
완료 (1.0초) | API 호출 #5
완료 (1.0초) | API 호출 #6
완료 (0.2초) | API 호출 #7
📊 진행률: 행 13.2% (7/53) | 문자 12.9% (925/7163) 114.6자/초 📊
⚡ 효율성: 실시간 76.4 | 평균 117.9 | 최근 109.0 | 단계별 113.6 자/초 📊
성공률: 100.0% (7/7) | 남은 항목: 46행 7초] 9.4% 번역 110자..
예상 남은 시간: 55초 | 완료 예상: 00:10:19 8초] 11.3% 번역 114자…
처리 속도: 3211.3 행/분 | 총 소요 시간: 8초] 13.2% 번역 16 문자..
[8/53] Stage1/6 [███░░░░░░░░░░░░░░░░░░░░░░] 15.1% 번역 166자..&lt;/p&gt;
&lt;p&gt;이전에는 제어 프로그램 코드를 많이 작성해보지 않아서 어떻게 구현되었는지 궁금해서 코드를 살펴봤다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// 清屏并重新显示 (动态刷新效果)
if translationCount &amp;gt; 1 {
   fmt.Print(&amp;quot;\033[6A\033[K&amp;quot;) // 上移6行并清除
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;성능 통계 메뉴&lt;/p&gt;
&lt;p&gt;새로 추가된 &lt;strong&gt;성능 통계 메뉴&lt;/strong&gt;는 제가 직접 디자인했는데, 이렇게 완벽하게 만들 수 있을 줄은 몰랐습니다&lt;/p&gt;
&lt;p&gt;성능 통계:
번역 횟수: 360
⚡ 캐시 적중률: 1.4% (5/365)
평균 번역 시간: 315.927234ms
파일 작업: 73
오류 횟수: 0&lt;/p&gt;
&lt;p&gt;진행률 표시&lt;/p&gt;
&lt;p&gt;새로운 &lt;strong&gt;진행률 표시&lt;/strong&gt;, 상세한 진행 상황, 경과 시간, 남은 예상 시간&lt;/p&gt;
&lt;p&gt;기능 선택 (0-13): 10
번역 목표를 수집 중입니다…
📄 캐시 파일이 로드되었습니다. 번역 기록 0개 포함&lt;/p&gt;
&lt;p&gt;번역 캐시 통계:
🏷️ 총 태그 수: 229개
📝 총 기사 수: 131건
✅ 캐시됨: 0개
🔄 번역 필요: 360개&lt;/p&gt;
&lt;p&gt;전체 번역 캐시 생성 확인하시겠습니까? (y/n): y
🚀 전체 번역 캐시 생성 중…
📄 캐시 파일이 로드되었습니다. 번역 기록 0개 포함
검색 중인 번역을 캐시에서 확인 중…
새로운 태그 360개 번역 필요
[░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 5/360 (1.4%) - 소요시간: 3초 - 예상 남은 시간: 3분 8초💾 캐시 파일 저장, 번역 기록 5개 포함
[█░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 10/360 (2.8%) - 소요시간: 6초 - 예상 남은 시간: 3분 28초💾 캐시 파일 저장, 번역 기록 10개 포함
[██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 15/360 (4.2%) - 소요시간: 9초 - 예상 남은 시간: 3분 30초💾 캐시 파일 저장 완료, 번역 기록 15개 포함
[██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 20/360 (5.6%) - 소요시간: 13초 - 예상 남은 시간: 3분 36초💾 캐시 파일 저장 완료, 번역 기록 20개 포함
[███░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 25/360 (6.9%) - 소요시간: 16초 - 예상 남은 시간: 3분 33초💾 캐시 파일 저장 완료, 번역 기록 25개 포함
[████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 30/360 (8.3%) - 소요시간: 19초 - 예상 남은 시간: 3분 30초💾 캐시 파일 저장 완료, 번역 기록 30개 포함
[████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 35/360 (9.7%) - 용량: 22s - 예상 남은 시간: 3분 25초💾 캐시 파일 저장 완료, 번역 기록 35개 포함&lt;/p&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;=== Hugo 博客管理工具 ===

🚀 核心功能
  1. 一键处理全部 (完整博客处理流程)

📝 内容管理
  2. 生成标签页面
  3. 生成文章Slug
  4. 翻译文章为多语言版本

💾 缓存管理
  5. 查看缓存状态
  6. 生成全量翻译缓存
  7. 清空翻译缓存

  0. 退出程序
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Fork 저장소에 Pull Request 병합</title>
        <link>https://ttf248.life/ko/p/merge-pullrequest-to-fork-repository/</link>
        <pubDate>Wed, 07 May 2025 18:44:03 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/merge-pullrequest-to-fork-repository/</guid>
        <description>&lt;p&gt;&lt;code&gt;github-readme-stats&lt;/code&gt;는 GitHub 프로필에 대한 통계 정보 생성기로, 사용자가 자신의 GitHub 프로필에 다양한 통계 정보와 차트를 표시할 수 있도록 합니다. 또한 사용자의 필요에 따라 조정할 수 있는 다양한 사용자 정의 옵션을 제공합니다.&lt;/p&gt;
&lt;p&gt;저는 창고 관리를 프로젝트별로 그룹화하는 습관이 있는데, GitHub는 창고 그룹화를 지원하지 않아서 여러 조직으로 분할해야 합니다. &lt;code&gt;github-readme-stats&lt;/code&gt; 최신 브랜치는 서로 다른 조직에 걸쳐 있는 창고 통계를 지원하지 못하기 때문에, 저는 포크하여 해당 코드를 병합했습니다.&lt;/p&gt;
&lt;h2 id=&#34;최종-효과&#34;&gt;최종 효과
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://github-readme-stats-chi-one-17.vercel.app/api?username=ttf248&amp;amp;hide_title=true&amp;amp;show_icons=true&amp;amp;hide=contribs&amp;amp;line_height=24&amp;amp;include_all_commits=true&amp;amp;count_private=true&amp;amp;bg_color=0000&amp;amp;text_color=8A919F&amp;amp;locale=cn&amp;amp;role=OWNER,COLLABORATOR,ORGANIZATION_MEMBER&amp;amp;timstamp=1746608356&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;GitHub Stats&#34;
	
	
&gt;
&lt;img src=&#34;https://github-readme-stats-chi-one-17.vercel.app/api/top-langs/?username=ttf248&amp;amp;hide_title=true&amp;amp;hide=html,javascript,css&amp;amp;layout=compact&amp;amp;bg_color=0000&amp;amp;text_color=8A919F&amp;amp;locale=cn&amp;amp;role=OWNER,COLLABORATOR,ORGANIZATION_MEMBER&amp;amp;timstamp=1746608356&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Top Languages&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;풀-리퀘스트-원본-주소&#34;&gt;풀 리퀘스트 원본 주소
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/anuraghazra/github-readme-stats/pull/2459&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Adds the ability to include data from organization repositories&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;fork-저장소에-pull-request-병합&#34;&gt;Fork 저장소에 Pull Request 병합
&lt;/h2&gt;&lt;p&gt;어떤 **풀 리퀘스트(PR)**를 당신이 &lt;strong&gt;포크한 저장소&lt;/strong&gt;에 병합하려면 몇 가지 방법이 있으며, 어떤 방식으로 하고 싶은지에 따라 달라집니다&lt;/p&gt;
&lt;p&gt;상위(上游) 저장소에서 PR을 병합할지,
다른 사람의 포크에서 PR을 병합하여 자신의 포크로 가져오거나,
fork하신 분이 제안한 PR(예: 다른 사람이 당신의 저장소를 포크하여 PR을 제출한 경우)를 병합하세요&lt;/p&gt;
&lt;p&gt;나는 먼저 가장 흔한 시나리오를 하나 제시할게: &lt;strong&gt;어떤 저장소를 포크했고, 상위 저장소의 특정 PR을 너의 포크에 병합하고 싶다고 가정해 보자.&lt;/strong&gt; 절차는 다음과 같다 👇:&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;방법-1-명령줄-방식가장-일반적&#34;&gt;방법 1: 명령줄 방식(가장 일반적)
&lt;/h3&gt;&lt;h4 id=&#34;단계-1-자신의-포크를-복제하세요&#34;&gt;단계 1: 자신의 포크를 복제하세요
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/你的用户名/仓库名.git
cd 仓库名
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;단계-2-업스트림원본-저장소-주소-추가&#34;&gt;단계 2: 업스트림(원본 저장소 주소) 추가
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git remote add upstream https://github.com/原作者用户名/仓库名.git
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;단계-3-업스트림-pr-분기-가져오기&#34;&gt;단계 3: 업스트림 PR 분기 가져오기
&lt;/h4&gt;&lt;p&gt;찾으려는 병합 PR 번호를 찾습니다. 예를 들어 PR #123입니다.&lt;/p&gt;
&lt;p&gt;이 PR의 코드는 다음과 같이 가져올 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git fetch upstream pull/123/head:pr-123
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;단계-4-분기-전환-및-병합&#34;&gt;단계 4: 분기 전환 및 병합
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git checkout main    # 或者你自己的目标分支
git merge pr-123
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;모든 것이 정상이라면, 포크한 GitHub 저장소에 푸시할 수 있습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git push origin main
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;방법-두-번째-github-웹-인터페이스간단하지만-기능이-제한적임&#34;&gt;방법 두 번째: GitHub 웹 인터페이스(간단하지만 기능이 제한적임)
&lt;/h3&gt;&lt;p&gt;GitHub 웹페이지에서 특정 PR이 상위 저장소에 대한 것이라면 다음과 같이 할 수 있습니다:&lt;/p&gt;
&lt;p&gt;해당 PR 페이지로 이동합니다
오른쪽 상단의 “&lt;strong&gt;Commits&lt;/strong&gt;” 또는 “&lt;strong&gt;Files changed&lt;/strong&gt;”를 클릭하여 이 PR이 어떤 브랜치를 기반으로 하는지 확인하세요
포크 페이지에서 새 브랜치를 만들고, 수동으로 PR 커밋을 체리픽하십시오(Git 기술이 필요합니다)
또는 “&lt;strong&gt;GitHub Desktop에서 열기&lt;/strong&gt;”를 클릭하여 GUI 도구를 사용하여 병합하세요&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;-만약-다른-사람이-당신의-포크에-대한-pr을-제안했다면&#34;&gt;🚀 만약 다른 사람이 당신의 포크에 대한 PR을 제안했다면
&lt;/h3&gt;&lt;p&gt;PR 페이지로 바로 들어가서 “&lt;strong&gt;Merge pull request&lt;/strong&gt;” 버튼을 클릭하면 됩니다&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;현재 구체적인 상황(예: PR 링크, 웹 페이지 또는 명령줄 사용)에 따라 제가 직접 시연해 드릴까요? 아니면 구체적인 링크를 주시면 가장 간단한 방법을 분석해 드리겠습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>Git 수정 기록의 커밋 메시지</title>
        <link>https://ttf248.life/ko/p/git-modify-commit-message/</link>
        <pubDate>Wed, 07 May 2025 18:38:31 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/git-modify-commit-message/</guid>
        <description>&lt;p&gt;스크립트는 Git 히스토리 커밋의 작성자 정보를 일괄적으로 수정하기 위해 git filter-branch를 사용하여 히스토리 커밋 기록을 재작성합니다&lt;/p&gt;
&lt;p&gt;제공하신 스크립트는 Git 저장소의 과거 커밋에서 작성자 정보를 일괄적으로 수정하는 데 사용되며, 전체적인 아이디어는 올바르지만 &lt;code&gt;git filter-branch&lt;/code&gt;의 &lt;code&gt;--env-filter&lt;/code&gt;에서 배열(예: &lt;code&gt;OLD_EMAILS=(&amp;quot;...&amp;quot;)&lt;/code&gt;)을 사용하는 경우 일부 셸 환경(예: &lt;code&gt;/bin/sh&lt;/code&gt;)이 배열 구문을 지원하지 않아 호환성 문제가 발생할 수 있습니다&lt;/p&gt;
&lt;p&gt;호환성을 높이기 위해 배열을 공백으로 구분된 문자열로 바꾸고, &lt;code&gt;for&lt;/code&gt; 루프를 사용하여 각 기존 이메일 주소를 반복하는 것이 좋습니다. 다음은 수정된 스크립트 예제입니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh

git filter-branch --env-filter &#39;
OLD_EMAILS=&amp;quot;TianlongXiang51@gmail.com nick@qq.com tianlongxiang51@gmail.com&amp;quot;
CORRECT_NAME=&amp;quot;tianlong.xiang&amp;quot;
CORRECT_EMAIL=&amp;quot;tianlong.xiang@foxmail.com&amp;quot;

for OLD_EMAIL in $OLD_EMAILS
do
    if [ &amp;quot;$GIT_COMMITTER_EMAIL&amp;quot; = &amp;quot;$OLD_EMAIL&amp;quot; ]
    then
        export GIT_COMMITTER_NAME=&amp;quot;$CORRECT_NAME&amp;quot;
        export GIT_COMMITTER_EMAIL=&amp;quot;$CORRECT_EMAIL&amp;quot;
    fi
    if [ &amp;quot;$GIT_AUTHOR_EMAIL&amp;quot; = &amp;quot;$OLD_EMAIL&amp;quot; ]
    then
        export GIT_AUTHOR_NAME=&amp;quot;$CORRECT_NAME&amp;quot;
        export GIT_AUTHOR_EMAIL=&amp;quot;$CORRECT_EMAIL&amp;quot;
    fi
done
&#39; --tag-name-filter cat -- --branches --tags
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;주의사항:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스크립트를 실행하기 전에 예기치 않은 상황을 방지하기 위해 저장소를 백업하는 것이 좋습니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 작업은 Git 기록을 덮어쓰고, 커밋 작성자 정보를 수정하여 커밋 해시 값이 변경될 수 있습니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;변경 사항을 원격 저장소에 푸시했다면 강제 푸시를 사용해야 합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git push --force --tags origin &#39;refs/heads/*&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;강제 푸시를 신중하게 사용하고, 특히 여러 사람이 협업하는 프로젝트에서는 다른 사람에게 영향을 미치지 않도록 주의하십시오&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;저장소의 모든 중복되지 않는 작성자 이메일 주소를 확인합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git log --format=&#39;%an &amp;lt;%ae&amp;gt;&#39; | sort -u
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>심심해서 중국 수묵화 스타일 테마를 디자인하고 싶다</title>
        <link>https://ttf248.life/ko/p/chinese-ink-style-theme/</link>
        <pubDate>Tue, 08 Apr 2025 03:42:47 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/chinese-ink-style-theme/</guid>
        <description>&lt;p&gt;다채로운 홈페이지를 너무 많이 봐서, 갑자기 미니멀리즘 스타일로 가고 싶어져서 중국 수묵화 스타일의 테마를 디자인하고 싶어요&lt;/p&gt;
&lt;p&gt;현재 스타일 시트는 각 요소에 맞게 특정 스타일이 적용되어 주제의 기본 스타일을 덮어쓰도록 수정되었습니다&lt;/p&gt;
&lt;p&gt;재구조화 없이 인공지능으로 직접 새로운 테마를 생성하면 결과가 매우 불안정합니다&lt;/p&gt;
&lt;p&gt;우연히 또 trae claude 대기열에 들어가서, vscode 에이전트 모드로 전환했더니 효과가 매우 안 좋고, 수정된 결과물은 아무런 디자인 감각도 없다&lt;/p&gt;
&lt;p&gt;결국, 제가 프론트엔드를 잘 몰라서 AI에게 효과적으로 업무를 분담할 수 없는 탓입니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>코딩 없이 맞춤 주식 모듈 설계 개발</title>
        <link>https://ttf248.life/ko/p/no-code-design-develop-custom-stock-module/</link>
        <pubDate>Thu, 27 Feb 2025 23:20:39 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/no-code-design-develop-custom-stock-module/</guid>
        <description>&lt;p&gt;지난달에 커서를 시험 사용해 봤는데, 무료 한도 제한 때문에 복잡한 기능 개발은 하지 않고 간단히 테스트만 했습니다. 그때쯔음에 바이트(Byte)도 유사한 제품을 출시했고, 두 제품 모두 기반으로 하는 대규모 언어 모델이 Claude-3.5였습니다.&lt;/p&gt;
&lt;p&gt;바이트의 제품인 트레이인데, 먼저 맥 버전으로 출시했고, 올해 2월에 드디어 윈도우 버전이 나왔어. 대기업 제품은 역시 좋지, 무료로 사용할 수 있고 돈을 내지 않아도 무제한으로 Claude-3.5를 사용할 수 있는데, 이 모델의 성능은 아주 괜찮아.&lt;/p&gt;
&lt;p&gt;최종적으로 K라인 차트 개발에 막혀버렸습니다. 개인적으로 React에 대한 기본 지식이 부족하여 포기할 수밖에 없었습니다. 계속 개발하려면 저자가 프론트엔드 기초 지식을 보충하고, “K라인 차트 개발”과 같이 큰 작업을 바로 주지 않고 더 세분화된 작은 작업으로 나누어야 합니다.&lt;/p&gt;
&lt;h2 id=&#34;발견된-문제&#34;&gt;발견된 문제
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;해외 AI 모델 사용으로 인해 Vue3 + Element-Plus의 학습 데이터가 부족하여, 프론트엔드 프레임워크로 React를 선택했습니다&lt;/li&gt;
&lt;li&gt;문법 오류가 발생할 수 있으므로, 사람이 직접 수정해야 합니다&lt;/li&gt;
&lt;li&gt;일부 복잡한 문제 해결에는 사람의 지침이 필요합니다&lt;/li&gt;
&lt;li&gt;코드 구조 최적화는 수동 지침이 필요합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;가장 시간이 오래 걸린 부분은 프론트엔드 코드를 컨테이너에 패키징하는 것이었는데, 작성자가 기초 지식이 전혀 없어서 &lt;code&gt;.env.production&lt;/code&gt; &lt;code&gt;tsconfig.json&lt;/code&gt; 같은 개념도 전혀 알지 못했습니다. 중간에 도움을 받은 덕분에 겨우 논리를 파악할 수 있었습니다. 프론트엔드 개발의 dev 모드와 build 모드는 코드 검사에서 큰 차이가 있습니다. 백엔드 데이터베이스 및 서비스 컨테이너 스크립트는 총 5분 만에 처리했습니다.&lt;/p&gt;
&lt;p&gt;AI는 현재 개발 효율성을 높이는 데 더 중점을 두고 있으며, 기본기가 가장 중요하며 AI가 모든 문제를 해결해 주는 것은 아닙니다&lt;/p&gt;
&lt;h2 id=&#34;창고-주소&#34;&gt;창고 주소
&lt;/h2&gt;&lt;p&gt;제목에서 언급했듯이, 이번에는 코딩하지 않고 AI와 직접 대화하며 자체 선택 주식 모듈을 설계하고 개발해 보겠습니다. 최종적으로 어떤 결과물이 나올지 지켜보죠.&lt;/p&gt;
&lt;p&gt;저장소 주소: &lt;a class=&#34;link&#34; href=&#34;https://github.com/ttf248/trae-demo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ttf248/trae-demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;자세한 사용 방법은 창고의 README.md 파일을 참조하십시오&lt;/p&gt;
&lt;p&gt;창고에는 많은 제출 기록이 포함되어 있는데, 대부분은 저와 Trae의 대화 기록과 제가 Trae의 몇몇 기능들을 테스트한 내용이며, 해당 기능을 구현하기 위해 수동 개입이 이루어졌는지에 대한 메모가 달려 있습니다&lt;/p&gt;
&lt;h2 id=&#34;prompt&#34;&gt;Prompt
&lt;/h2&gt;&lt;p&gt;프로젝트는 처음부터 시작되었으며, 프로젝트 프롬프트는 다음과 같습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;基于项目原型图，开发功能：自选股，需要支持合约的新增、删除、修改、查询。自选股界面需要展示基础的行情数据。支持多个不同的市场切换。

前端：react
后端：golang gin gorm
数据库：PostgreSQL

服务端需要支持跨域请求，同时需要考虑数据的校验和错误处理，如果后端服务不可用，前端需要告警提示。

后端需要展示请求和应答的日志；前端也打印通讯的日志，方便排查问题。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ui-및-상호작용-최적화&#34;&gt;UI 및 상호작용 최적화
&lt;/h2&gt;&lt;p&gt;프론트엔드 인터페이스 디자인은 완전히 Grok에 의존하고 있으며, 우리는 먼저 Trae에서 제품의 초기 형태를 만들었지만 심미적인 부분은 부족했습니다. 사용한 모델은 코드 능력은 강력하지만 다른 기능은 상대적으로 약하기 때문에 Grok을 사용하여 프론트엔드의 UI를 최적화해야 합니다.&lt;/p&gt;
&lt;p&gt;현재 인터페이스의 스크린샷을 찍어 Grok에 업로드한 다음, Grok이 우리 UI를 최적화하도록 하고, 여러 가지 최적화 제안을 한 번에 받은 뒤, 저희가 수동으로 평가하고 Trae에서 실행하여 최적화 효과를 관찰합니다&lt;/p&gt;
&lt;h3 id=&#34;기술-스택&#34;&gt;기술 스택
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;프론트엔드: React + TypeScript&lt;/li&gt;
&lt;li&gt;백엔드: Golang + Gin + GORM&lt;/li&gt;
&lt;li&gt;데이터베이스: PostgreSQL 17&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;시스템-아키텍처&#34;&gt;시스템 아키텍처
&lt;/h2&gt;&lt;h2 id=&#34;백엔드-아키텍처&#34;&gt;백엔드 아키텍처
&lt;/h2&gt;&lt;p&gt;백엔드는 Golang의 Gin 프레임워크로 구현된 RESTful API이며, 주요 모듈은 다음과 같습니다:&lt;/p&gt;
&lt;p&gt;데이터베이스 모듈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GORM을 ORM 프레임워크로 사용하세요&lt;/li&gt;
&lt;li&gt;환경 변수를 통해 데이터베이스 연결을 구성할 수 있습니다&lt;/li&gt;
&lt;li&gt;자동으로 데이터베이스 테이블 마이그레이션 수행&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;라우팅 모듈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RESTful API 설계&lt;/li&gt;
&lt;li&gt;통일된 오류 처리 메커니즘&lt;/li&gt;
&lt;li&gt;내장 요청 로깅&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;영역 간 처리&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;로컬 개발 환경 간의 교차 도메인 접근을 지원합니다&lt;/li&gt;
&lt;li&gt;구성 가능한 CORS 정책&lt;/li&gt;
&lt;li&gt;쿠키 크로스 도메인 지원&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;프론트엔드-아키텍처&#34;&gt;프론트엔드 아키텍처
&lt;/h2&gt;&lt;p&gt;프론트엔드는 React + TypeScript로 구축되었으며, 다음과 같은 기능을 구현했습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;주식 목록 표시&lt;/li&gt;
&lt;li&gt;자선주 관리&lt;/li&gt;
&lt;li&gt;시장 데이터 표시&lt;/li&gt;
&lt;li&gt;오류 표시 메커니즘&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>프로토Buf 0치 함정: 기본값이 비즈니스 로직의 보이지 않는 살인자</title>
        <link>https://ttf248.life/ko/p/protobuf-zero-value-traps/</link>
        <pubDate>Thu, 20 Feb 2025 15:26:51 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/protobuf-zero-value-traps/</guid>
        <description>&lt;p&gt;미국 주식 시장에는 세 가지 거래 시간대가 있습니다. 전시장, 장중, 장후입니다. 인터페이스 데이터 푸시는 값의 증분 로직(가능한 한 대역폭을 절약)이며, 처음 보내는 때는 전체 데이터를 보내고, 두 번째부터 모든 필드는 증분 방식으로 푸시됩니다.&lt;/p&gt;
&lt;p&gt;최적의 방안을 사용하지 않는 이유는 무엇인가요? 여러 프로젝트 팀이 관련되어 있고, 일부는 이미 수년 전에 배포되었습니다. 저희 쪽은 새로 연결하는 입장이므로 최대한 호환성을 고려할 수밖에 없습니다.&lt;/p&gt;
&lt;h2 id=&#34;일련의-문제&#34;&gt;일련의 문제
&lt;/h2&gt;&lt;p&gt;초록만 보더라도 별다른 문제가 없어 보일 수 있지만, 시스템 아키텍처가 문제 그룹으로 들어오면서 일련의 문제가 발생했습니다. 막 지난 문제를 해결하려 했더니 또 다른 문제가 생겼고, 이 문제는 이전 문제로 인해 발생한 것입니다.&lt;/p&gt;
&lt;h3 id=&#34;거래-기간을-식별할-수-없습니다&#34;&gt;거래 기간을 식별할 수 없습니다
&lt;/h3&gt;&lt;p&gt;알려진 바에 따르면, 디스크 내 단계 정의는 &lt;code&gt;protobuf&lt;/code&gt;에서 0으로 정의되어 있지만, 데이터를 수신할 때 증분 푸시로 인해 비즈니스 측면에서는 이 &lt;code&gt;0&lt;/code&gt;이 기본값인지 실제 비즈니스 값인지 효과적으로 식별하기 어렵습니다&lt;/p&gt;
&lt;p&gt;일반적인 이해로, 0을 받을 때마다 이 0이 새로운 시세 설정 값인지, 아니면 프로토콜 버퍼의 기본값인지 판단하기 어렵습니다&lt;/p&gt;
&lt;h3 id=&#34;선택적-도입&#34;&gt;선택적 도입
&lt;/h3&gt;&lt;p&gt;Since protobuf release 3.15, proto3 supports using the optional keyword (just as in proto2) to give a scalar field presence information&lt;/p&gt;
&lt;p&gt;조 내 통신 프로토콜은 &lt;code&gt;protobuf&lt;/code&gt; 기반이지만, 역사적인 이유로 비교적 오래된 버전이 선택되었고 &lt;code&gt;optional&lt;/code&gt; 키워드를 지원하지 않습니다. 아시는 분들은 이해하실 텐데, 하위부터 &lt;code&gt;protobuf&lt;/code&gt;를 도입하기 시작했고 프로젝트가 정적 라이브러리 방식으로 배포되어 전체 컴파일 링크를 업그레이드해야 하는데, 이 비용은 매우 높습니다.&lt;/p&gt;
&lt;h3 id=&#34;gcc-버전-문제&#34;&gt;GCC 버전 문제
&lt;/h3&gt;&lt;p&gt;정말 어렵게 대안을 마련했는데, 하위 레이어에서 두 가지 다른 버전을 배포하여 가능한 한 &lt;code&gt;protobuf&lt;/code&gt; 새 버전의 컴파일 의존성 전파를 제어하려고 했습니다. 하지만 컴파일하는 과정에서 &lt;code&gt;gcc&lt;/code&gt; 버전이 너무 낮아 &lt;code&gt;protobuf&lt;/code&gt;의 새로운 기능을 지원하지 않는다는 것을 발견했습니다.&lt;/p&gt;
&lt;p&gt;그룹 내에서 일반적으로 사용되는 서버 유형은 CentOS 7, CentOS 8입니다. CentOS 7의 기본 &lt;code&gt;gcc&lt;/code&gt; 버전은 4.8이고, CentOS 8의 기본 &lt;code&gt;gcc&lt;/code&gt; 버전은 8.3입니다. &lt;code&gt;protobuf&lt;/code&gt;의 새로운 기능은 &lt;code&gt;gcc&lt;/code&gt; 버전이 7.4 이상을 요구하므로 CentOS 7은 지원할 수 없습니다.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=82461&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Bug 82461 - [7 Regression] Temporary required for brace-initializing (non-literal-type) member variable&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;마지막으로 관련 서비스 배포 및 컴파일 서버를 CentOS 8로 옮겨서 이 문제를 해결했다&lt;/p&gt;
&lt;h2 id=&#34;합리적인-열거&#34;&gt;합리적인 열거
&lt;/h2&gt;&lt;p&gt;전체 문제를 되돌아보면, 사실 더 간단하고 효율적인 해결책이 있습니다. 바로 열거형의 정의를 조정하여 1부터 번호를 매기도록 하는 것입니다. 이렇게 하면 기본값과 비즈니스 값을 효과적으로 구별할 수 있으며, 위에서 언급한 일련의 문제들을 피할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;왜-1부터-시작하는-것이-더-합리적일까요&#34;&gt;왜 1부터 시작하는 것이 더 합리적일까요?
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;protobuf&lt;/code&gt;에서 열거형 유형의 기본값은 0으로 고정되어 있습니다. 의미 있는 비즈니스 값을 0으로 정의할 경우(예: &amp;ldquo;거래 중&amp;rdquo;), 증분 푸시 시 비즈니스 측에서 수신된 0이 비즈니스 값인지, 아니면 초기화되지 않은 기본값인지 판단하기 어렵습니다. 하지만 열거형을 1부터 시작하여 정의하면 0은 무의미한 기본값 또는 &amp;ldquo;알 수 없음&amp;rdquo; 상태로 유지할 수 있어 문제가 해결됩니다.&lt;/p&gt;
&lt;p&gt;권장되는 방법:&lt;/p&gt;
&lt;p&gt;프로토콜 버퍼 열거형을 설계할 때 항상 0을 무의미한 기본값(예: &lt;code&gt;UNKNOWN&lt;/code&gt; 또는 &lt;code&gt;RESERVED&lt;/code&gt;)으로 정의하십시오
실제 비즈니스 값을 1부터 할당하여 기본값 0과 구별되도록 합니다&lt;/p&gt;
&lt;p&gt;이 작은 조정 덕분에 우리는 거래 시간대 식별 문제를 해결했을 뿐만 아니라 향후 프로토콜 설계에 귀중한 교훈을 얻게 되었습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>백그라운드 서비스 TCP 통신 이상 점검</title>
        <link>https://ttf248.life/ko/p/backend-service-tcp-communication-troubleshooting/</link>
        <pubDate>Fri, 14 Feb 2025 22:54:13 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/backend-service-tcp-communication-troubleshooting/</guid>
        <description>&lt;p&gt;비즈니스 모델: 백엔드 서비스는 TCP를 통해 그룹의 시장 게이트웨이와 연결을 맺습니다. 각 연결 시에는 먼저 인증 요청을 보내고, 그 후 지속적으로 하트비트 패킷을 전송하여 연결 상태를 유지합니다.
하지만 어느 날, 서비스 연결 해제 경고 메시지를 받았습니다. 로그를 꼼꼼히 확인해 본 결과, 백엔드 서비스는 계속해서 하트비트 패킷을 전송하고 있었지만 상대방은 전혀 응답하지 않았음에도 불구하고 연결은 끊어지지 않고 있었습니다.&lt;/p&gt;
&lt;h2 id=&#34;현장-간략-설명&#34;&gt;현장 간략 설명
&lt;/h2&gt;&lt;p&gt;원래 회사에서 야근하며 프로젝트 진행을 추진 중이었는데, 업무 그룹 채팅방에 갑자기 경고 메시지가 떴다. 처음에는 예전 문제라고 생각했다. 네트워크 타임아웃으로 인해 하트비트 전송이 실패해서 연결이 끊어진 것 같았다. 하지만 로그를 자세히 확인해 보니 실제 상황은 그렇지 않았다. 백엔드에서 인증 로그인 메시지를 보냈지만 계속 응답을 받지 못했고, 동시에 하트비트는 지속적으로 전송되었지만 상대방은 어떠한 하트비트 데이터도 반환하지 않았다. 로그를 심층적으로 분석한 결과 다음과 같은 몇 가지 주요 문제가 드러났다:&lt;/p&gt;
&lt;p&gt;인가 메시지에 대한 응답이 없으면, 상대방 시스템이 재시동 중이라 인가 메시지가 적시에 처리되지 않았을 가능성이 매우 높습니다
승인되지 않은 상태에서 하트비트 데이터를 전송하는 문제: 조사 결과, 프로그램 로직의 결함이 원인입니다. 하트비트 전송 함수의 판단 로직에 문제가 있어 연결 상태만 확인하고 인증 상태를 확인하지 않았습니다.
서비스 연결이 끊어지면 재연결 메커니즘을 트리거하여 인증 메시지를 다시 보낼 수 있습니다&lt;/p&gt;
&lt;p&gt;현재, 해결해야 할 마지막 문제점은 서비스 연결이 끊어지지 않은 이유입니다. 이 문제의 해결을 위해서는 보다 심층적이고 세밀한 점검 작업이 필요합니다.&lt;/p&gt;
&lt;h2 id=&#34;네트워크-데이터-패킷-분석&#34;&gt;네트워크 데이터 패킷 분석
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;tcpdump&lt;/code&gt;는 매우 강력한 네트워크 패킷 캡처 도구로, 네트워크 데이터 패킷을 포착하는 데 사용할 수 있습니다. 네트워크 데이터 패킷을 분석함으로써 우리는 네트워크 통신의 세부 사항을 보다 직관적으로 이해할 수 있습니다. 여기서는 &lt;code&gt;tcpdump&lt;/code&gt;를 사용하여 네트워크 데이터 패킷을 포착하여 추가 분석을 할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/backend-service-tcp-communication-troubleshooting/20250220151952.png&#34;
	width=&#34;1126&#34;
	height=&#34;202&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;tcpdump&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;557&#34;
		data-flex-basis=&#34;1337px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;데이터를 분석해 보면 심박수는 계속 정상적으로 전송되고 있지만, 상대방 서버로부터는 아무런 데이터도 수신되지 않았고, 단지 &lt;code&gt;ACK&lt;/code&gt;만 받았기 때문에 연결이 자동으로 끊어지지 않고 있습니다&lt;/p&gt;
&lt;h2 id=&#34;일반적인-플래그-설명&#34;&gt;일반적인 플래그 설명
&lt;/h2&gt;&lt;p&gt;TCP 프로토콜에서 &lt;code&gt;PSH&lt;/code&gt;(Push)와 &lt;code&gt;ACK&lt;/code&gt;(Acknowledgment)는 데이터 전송과 흐름 제어를 위해 사용되는 중요한 플래그 비트입니다. 이들의 역할은 다음과 같습니다:&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;1-pshpush-flag&#34;&gt;&lt;strong&gt;1. PSH（Push Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;기능:
PSH 플래그는 &lt;strong&gt;수신 측이 버퍼에 있는 데이터를 상위 애플리케이션으로 즉시 푸시하도록 요청하는 역할&lt;/strong&gt;을 합니다(버퍼가 채워질 때까지 기다리지 않고). 이는 PSH 플래그가 있는 데이터 세그먼트를 받으면 수신 측은 운영체제 버퍼에 저장하기보다는 가능한 한 빨리 처리하여 애플리케이션에 전달합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;전형적인 장면&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP/HTTPS 요청 시(예: &lt;code&gt;GET /index.html&lt;/code&gt;) 클라이언트는 서버가 즉시 응답하기를 바라는 &lt;code&gt;PSH&lt;/code&gt;를 설정합니다&lt;/li&gt;
&lt;li&gt;SSH 프로토콜: 키보드 입력이 있을 때마다 &lt;code&gt;PSH&lt;/code&gt;가 트리거되어 입력 문자가 실시간으로 전송되도록 합니다&lt;/li&gt;
&lt;li&gt;실시간 통신: 비디오 스트리밍, 온라인 게임 등 저지연 시나리오에서는 &lt;code&gt;PSH&lt;/code&gt;를 사용하여 지연을 줄일 수 있습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;주의:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PSH는 필수가 아니며, 수신측은 해당 비트(flag bit)를 무시할 수 있습니다(데이터는 정상적으로 처리해야 합니다)&lt;/li&gt;
&lt;li&gt;보내는 쪽에서 &lt;code&gt;PSH&lt;/code&gt;를 설정하지 않을 수 있으며, 이 경우 받는 쪽은 자체 버퍼링 정책에 따라 데이터를 언제 보낼지 결정합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2-ackacknowledgment-flag&#34;&gt;&lt;strong&gt;2. ACK（Acknowledgment Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;기능:
ACK 플래그는 &lt;strong&gt;이전 데이터 세그먼트가 올바르게 수신되었음을 확인&lt;/strong&gt;합니다. 각 ACK에는 확인 번호(Acknowledgment Number)가 포함되어 있으며, 이는 예상되는 다음 바이트 시퀀스 번호를 나타냅니다. 이는 TCP 신뢰성 있는 전송의 핵심 메커니즘입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;작동 원리:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;송신자는 데이터 세그먼트를 보낼 때, 예상 수신자의 &lt;code&gt;ACK&lt;/code&gt; 값(예: &lt;code&gt;ACK = 시퀀스 번호 + 데이터 길이&lt;/code&gt;)을 함께 전송합니다&lt;/li&gt;
&lt;li&gt;수신 장치가 데이터를 수신하면, 수신 확인(&lt;code&gt;ACK&lt;/code&gt;) 세그먼트를 생성하여 수신된 데이터의 시퀀스 번호를 확인합니다&lt;/li&gt;
&lt;li&gt;송신자는 해당 &lt;code&gt;ACK&lt;/code&gt;를 수신한 후에야만 확인되지 않은 데이터를 재전송합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예시입니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;송신자가 시퀀스 번호가 &lt;code&gt;100~199&lt;/code&gt;인 데이터 세그먼트를 보냈다면, 예상되는 수신자의 &lt;code&gt;ACK&lt;/code&gt;는 &lt;code&gt;200&lt;/code&gt;이어야 한다&lt;/li&gt;
&lt;li&gt;수신자가 &lt;code&gt;100~199&lt;/code&gt; 범위 내의 특정 데이터를 받지 못하면, 송신자에게 재전송을 요청하기 위해 &lt;code&gt;ACK=150&lt;/code&gt;으로 알립니다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;psh와-ack의-조합&#34;&gt;PSH와 ACK의 조합
&lt;/h3&gt;&lt;p&gt;TCP 패킷에서 &lt;code&gt;PSH&lt;/code&gt;와 &lt;code&gt;ACK&lt;/code&gt;가 동시에 나타나는 경우는 다음과 같은 상황에서 흔히 볼 수 있습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;HTTP 요청 응답
클라이언트가 &lt;code&gt;POST&lt;/code&gt; 요청(데이터 포함)을 보낼 때, &lt;code&gt;PSH&lt;/code&gt;와 &lt;code&gt;ACK&lt;/code&gt;(이전 응답 확인)가 설정됩니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Client → Server: SYN, ACK=1 → 建立连接
Client → Server: PSH, ACK=1, 数据 → 发送请求数据
Server → Client: PSH, ACK=数据长度+1 → 返回响应
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SSH 핸드셰이킹 후 명령 전송
클라이언트가 명령을 입력하면 &lt;code&gt;PSH&lt;/code&gt; 및 &lt;code&gt;ACK&lt;/code&gt;가 포함된 데이터 세그먼트를 전송하여 명령이 즉시 전송되고 서버에서 처리되도록 합니다&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;다른-플래그-비트의-연관성&#34;&gt;다른 플래그 비트의 연관성
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;기호&lt;/th&gt;
&lt;th&gt;이름&lt;/th&gt;
&lt;th&gt;간략 설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;동기화&lt;/td&gt;
&lt;td&gt;초기화 연결 (세 번의 악수)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FIN&lt;/td&gt;
&lt;td&gt;종료&lt;/td&gt;
&lt;td&gt;연결 우아하게 닫기&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;재설정&lt;/td&gt;
&lt;td&gt;강제 연결 종료 (비정상 상황)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;URG&lt;/td&gt;
&lt;td&gt;긴급&lt;/td&gt;
&lt;td&gt;긴급 포인터 표시 (거의 사용하지 않음)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h3 id=&#34;요약&#34;&gt;요약
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;데이터가 최대한 빨리 애플리케이션 계층에 도달하도록 하여 지연 시간을 줄이는 데 중점을 두고 있습니다&lt;/li&gt;
&lt;li&gt;데이터의 신뢰성 있는 전송에 중점을 두고, 패킷 손실이나 순서 변경을 방지합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;두 가지는 협력하여 TCP 프로토콜의 효율성과 안정성을 균형 있게 맞췄다&lt;/p&gt;</description>
        </item>
        <item>
        <title>올라마에 deepseek-R1 로컬 배포</title>
        <link>https://ttf248.life/ko/p/ollama-local-deployment-deepseek-r1/</link>
        <pubDate>Fri, 07 Feb 2025 22:41:02 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/ollama-local-deployment-deepseek-r1/</guid>
        <description>&lt;p&gt;Ollama는 사용자가 로컬에서 대규모 언어 모델(LLM)을 실행하고 배포할 수 있도록 하는 오픈 소스 AI 도구입니다. 이 도구의 목표는 개발자가 클라우드 서비스에 의존하지 않고도 GPT와 같은 모델을 로컬 머신에서 편리하고 효율적으로 사용할 수 있는 방법을 제공하는 것입니다. Ollama는 다양한 모델을 지원하며 성능 최적화에 중점을 두어 리소스가 제한된 장치에서도 이러한 모델을 원활하게 실행할 수 있도록 합니다.&lt;/p&gt;
&lt;p&gt;올라마를 통해 사용자는 텍스트 기반의 AI 애플리케이션을 사용할 수 있으며, 데이터 개인 정보나 높은 API 사용 비용 걱정 없이 로컬에 배포된 모델과 상호 작용할 수 있습니다. 다양한 모델을 명령줄 인터페이스(CLI)를 통해 호출하여 자연어 처리, 질의 응답 등의 작업을 수행할 수 있습니다.&lt;/p&gt;
&lt;p&gt;올라마는 다양한 모델을 시험해 보기에 적합하지만, 윈도우 버전으로 테스트해 보니 하드웨어 성능을 충분히 활용하지 못하는 듯합니다. 아마 윈도우 버전 때문일 수도 있고, 리눅스 버전이 더 나을 수도 있습니다. 32b 파라미터 모델을 배포했을 때 메모리나 그래픽 카드 사용량이 높지 않음에도 불구하고 응답 속도가 매우 느립니다.&lt;/p&gt;
&lt;h2 id=&#34;하드웨어-개요&#34;&gt;하드웨어 개요
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;운영체제: win11&lt;/li&gt;
&lt;li&gt;CPU：i7-10700K&lt;/li&gt;
&lt;li&gt;메모리: 40GB&lt;/li&gt;
&lt;li&gt;그래픽 카드: RTX 3060 12GB&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;환경-준비&#34;&gt;환경 준비
&lt;/h2&gt;&lt;p&gt;새로운 시스템 환경 변수를 추가하여 향후 사용을 용이하게 합니다&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;set OLLAMA_MODELS=E:\ollama&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
이 변수는 Ollama 모델이 저장될 경로를 지정합니다. &lt;code&gt;E:\ollama&lt;/code&gt;는 모든 로컬 모델 파일이 해당 디렉터리에 저장되어 있음을 나타내는 폴더 경로입니다. Ollama는 이 경로를 기준으로 다운로드하거나 배포한 언어 모델을 로드하고 사용합니다. 모델 파일을 다른 위치에 저장하려면 이 경로만 변경하면 됩니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;set OLLAMA_HOST=127.0.0.1:8000&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
이 환경 변수는 Ollama 서비스의 호스트와 포트를 설정합니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;127.0.0.1&lt;/code&gt;은 로컬 주소(localhost)이며, Ollama 서비스는 로컬에서 온 요청만 수신합니다&lt;/li&gt;
&lt;li&gt;8000은 지정된 포트 번호이며, Ollama 서비스가 8000번 포트에서 요청을 기다리고 처리할 것임을 나타냅니다. 필요에 따라 포트 번호를 변경할 수 있지만, 해당 포트가 다른 애플리케이션에서 사용 중인지 확인해야 합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;set OLLAMA_ORIGINS=*&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
이 환경 변수는 Ollama 서비스에 접근할 수 있는 요청의 출처를 제어합니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;는 모든 소스(즉, 모든 도메인 및 IP 주소)에서 Ollama 서비스에 액세스할 수 있도록 허용합니다. 이는 일반적으로 개발 및 디버깅 환경에서 사용되며, 프로덕션 환경에서는 더 엄격한 소스 제어를 지정하여 특정 도메인 또는 IP만 서비스를 액세스하도록 제한하여 보안을 강화하는 것이 일반적입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;딥시크-r1-모델-배포&#34;&gt;딥시크-R1 모델 배포
&lt;/h2&gt;&lt;p&gt;올라마 설치는 간단하니 자세한 설명은 생략하겠습니다&lt;/p&gt;
&lt;p&gt;설치 후 검증:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\core&amp;gt;ollama -v
ollama version is 0.5.11
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;모델 배포는 공식 모델 페이지를 참조하여 해당 매개변수가 있는 모델을 선택합니다: &lt;code&gt;ollama run deepseek-r1:14b&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;14b 파라미터는 대화 컨텍스트를 효과적으로 기억할 수 있지만, 더 작은 파라미터 버전은 그렇지 못합니다. 32b 파라미터 버전은 로컬에서 실행하면 매우 느려서 더 이상 테스트하지 않았습니다.&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.ollama.com/library/deepseek-r1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.ollama.com/library/deepseek-r1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://mp.weixin.qq.com/s/SPEvYTmTBxhoEkJqm1yPmw&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mp.weixin.qq.com/s/SPEvYTmTBxhoEkJqm1yPmw&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/x18990027/article/details/145368094&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/x18990027/article/details/145368094&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>파워셸 7과 지속 가능한 설정 명령줄 예측 보기</title>
        <link>https://ttf248.life/ko/p/powershell-7-persisting-settings-command-line-prediction-view/</link>
        <pubDate>Fri, 07 Feb 2025 22:19:12 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/powershell-7-persisting-settings-command-line-prediction-view/</guid>
        <description>&lt;p&gt;Linux에서 zsh를 사용하다가, 이틀 전 블로그를 쓰다가 PowerShell 7도 영구적인 설정으로 명령줄 예측 보기를 지원하는 것을 발견해서 한번 시켜봤는데, 꽤 괜찮게 잘 된다&lt;/p&gt;
&lt;p&gt;어떻게든 뭔가를 했는데, 이 기능이 켜진 것 같아. 그냥 있는 거다.&lt;/p&gt;
&lt;p&gt;오늘날 다양화된 운영체제 환경에서 시스템 관리자와 개발자들은 플랫폼 간 호환성, 효율성 및 강력한 기능을 갖춘 도구를 찾아 시스템 관리 및 자동화 작업에 대한 요구를 충족하고자 합니다. PowerShell 7은 바로 이러한 주목을 받는 도구 중 하나로, 강력한 스크립팅 기능뿐만 아니라 Windows, Linux 및 macOS와 같은 다양한 운영체제에서 실행될 수 있어 사용자에게 전례 없는 편의성을 제공합니다.&lt;/p&gt;
&lt;h2 id=&#34;파워셸-7-강력한-크로스-플랫폼-도구&#34;&gt;파워셸 7: 강력한 크로스 플랫폼 도구
&lt;/h2&gt;&lt;h3 id=&#34;플랫폼-간-호환성&#34;&gt;플랫폼 간 호환성
&lt;/h3&gt;&lt;p&gt;파워셸 7은 플랫폼의 제약을 깨뜨려 Windows 시스템에서 기업용 서버 관리를 하든, Linux 환경에서 시스템 운영을 하든, macOS에서 일상적인 개발 작업을 하든, 사용자는 통일된 파워셸 7 도구를 사용할 수 있습니다. 이는 업무 효율성을 크게 향상시키고 플랫폼 차이로 인한 학습 비용과 작업 복잡성을 줄입니다.&lt;/p&gt;
&lt;h3 id=&#34;강력한-기능&#34;&gt;강력한 기능
&lt;/h3&gt;&lt;p&gt;스크립트 작성 능력이 뛰어나며 객체 지향 프로그래밍, 함수, 모듈과 같은 고급 프로그래밍 기능을 지원합니다. PowerShell 7을 통해 사용자는 파일 시스템을 쉽게 조작하여 파일 및 폴더를 생성, 삭제, 복사, 이동할 수 있습니다. 또한 레지스트리를 액세스하고 수정하여 시스템 구성을 심층적으로 조정할 수 있으며 프로세스와 서비스를 관리하여 시스템 실행 상태를 효과적으로 모니터링하고 제어할 수 있습니다. 게다가 PowerShell 7은 Active Directory에서 사용자 및 권한 관리를 포함하여 Windows 및 비 Windows 기술과 상호 작용할 수 있으며 Azure 클라우드 플랫폼에서 리소스 할당 및 관리를 수행할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;오픈소스-생태계&#34;&gt;오픈소스 생태계
&lt;/h3&gt;&lt;p&gt;PowerShell 7은 오픈 소스이며, 이러한 특징으로 인해 전 세계 개발자와 애호가들이 적극적으로 개발과 개선에 참여할 수 있습니다. 많은 오픈 소스 모듈과 도구가 끊임없이 등장하여 PowerShell 7의 기능과 적용 분야를 풍부하게 합니다. 사용자는 자신의 필요에 따라 오픈 소스 커뮤니티에서 적합한 모듈을 찾아 PowerShell 7 기능을 확장하거나, 자신의 코드를 기여하여 전체 커뮤니티 발전에 기여할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;호환성-및-안정성&#34;&gt;호환성 및 안정성
&lt;/h3&gt;&lt;p&gt;PowerShell 7은 이전 버전의 PowerShell과의 호환성을 유지하면서도 많은 새로운 기능과 개선 사항을 도입했습니다. 이러한 개선 사항은 성능 향상뿐만 아니라 안정성도 강화하여 사용자가 다양한 작업을 더욱 원활하게 완료하고 소프트웨어 오류로 인한 작업 중단을 줄일 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;명령줄-예측-뷰-열기&#34;&gt;명령줄 예측 뷰 열기
&lt;/h2&gt;&lt;p&gt;파워셸 7의 다양한 유용한 기능 중, &lt;code&gt;Set-PSReadLineOption -PredictionViewStyle ListView&lt;/code&gt; 명령은 사용자 명령줄 입력 경험을 향상시키는 실용적인 도구입니다&lt;/p&gt;
&lt;p&gt;명령을 활성화하지 않아도 자동 완성 기능을 사용할 수 있지만, 이는 현재 줄 내에서의 자동 완성에만 해당됩니다. 명령을 활성화하면 예측 뷰가 표시되고, 가능한 모든 자동 완성 옵션이 목록 형태로 나타납니다. 사용자는 위아래 화살표 키를 사용하여 필요한 옵션을 선택할 수 있으며, 이를 통해 명령 입력의 정확성과 효율성을 높일 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/powershell-7-persisting-settings-command-line-prediction-view/20250207222546.png&#34;
	width=&#34;814&#34;
	height=&#34;205&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;powershell7&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;397&#34;
		data-flex-basis=&#34;952px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;명령을-지속적으로-적용하는-방법&#34;&gt;명령을 지속적으로 적용하는 방법
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Set-PSReadLineOption -PredictionViewStyle ListView&lt;/code&gt; 명령어를 매번 PowerShell을 시작할 때 적용되도록 하려면, PowerShell 프로필 파일에 추가할 수 있습니다. PowerShell 프로필 파일은 PowerShell이 시작될 때 자동으로 실행되는 특수한 스크립트입니다.&lt;/p&gt;
&lt;h3 id=&#34;설정-파일-경로-확인&#34;&gt;설정 파일 경로 확인
&lt;/h3&gt;&lt;p&gt;파워셸에서 우리는 &lt;code&gt;$PROFILE&lt;/code&gt; 변수를 사용하여 구성 파일의 경로를 확인할 수 있습니다. 해당 경로에 파일이 없으면 사용자가 직접 생성할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo $PROFILE
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;설정-파일을-엽니다&#34;&gt;설정 파일을 엽니다
&lt;/h3&gt;&lt;p&gt;기능이 강력한 메모장++나 가벼운 Visual Studio Code와 같은 텍스트 편집기를 사용하여 &lt;code&gt;$PROFILE&lt;/code&gt; 변수를 통해 얻은 구성 파일 경로에 해당하는 파일을 엽니다&lt;/p&gt;
&lt;h3 id=&#34;추가-명령&#34;&gt;추가 명령
&lt;/h3&gt;&lt;p&gt;열려 있는 설정 파일에 &lt;code&gt;Set-PSReadLineOption -PredictionViewStyle ListView&lt;/code&gt; 명령을 추가합니다. 명령이 정확하게 작성되었는지 확인하여 설정 파일이 실행될 때 제대로 적용되도록 합니다.&lt;/p&gt;
&lt;h3 id=&#34;구성-파일-저장&#34;&gt;구성 파일 저장
&lt;/h3&gt;&lt;p&gt;명령이 추가된 후에는 구성 파일을 저장하고 텍스트 편집기를 닫습니다. 이제 구성 파일에는 PowerShell을 시작할 때마다 실행하려는 명령이 포함되어 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;검증-설정&#34;&gt;검증 설정
&lt;/h3&gt;&lt;p&gt;현재 PowerShell 창을 닫은 다음 PowerShell을 다시 시작합니다. 새로 시작된 PowerShell에서 명령어를 입력할 때, 명령줄 입력 예측 보기 스타일이 목록 보기 형태로 표시되어야 하는데, 이는 우리의 설정이 성공적으로 적용되었다는 것을 의미합니다.&lt;/p&gt;
&lt;p&gt;위 단계를 통해 우리는 PowerShell 7의 강력한 기능과 특징을 깊이 있게 이해했을 뿐만 아니라, 명령줄 입력 예측 보기 스타일을 설정하여 작업 경험을 향상시키는 방법과 이러한 설정을 지속적으로 유지하는 방법을 익혔습니다. 이 지식이 PowerShell 7 사용 과정에서 더욱 능숙하게, 그리고 효율적으로 다양한 시스템 관리 및 자동화 작업을 수행하는 데 도움이 되기를 바랍니다.&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/PowerShell/PowerShell/releases&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/PowerShell/PowerShell/releases&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.v2ex.com/t/911909&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.v2ex.com/t/911909&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>atop 도구를 사용하여 Linux 시스템 지표를 모니터링하는 방법: 설치, 구성 및 사용법 완벽 가이드</title>
        <link>https://ttf248.life/ko/p/using-atop-to-monitor-linux-system-metrics-installation-configuration-and-usage-guide/</link>
        <pubDate>Thu, 06 Feb 2025 22:48:55 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/using-atop-to-monitor-linux-system-metrics-installation-configuration-and-usage-guide/</guid>
        <description>&lt;p&gt;리눅스 시스템 운영 과정에서 시스템 자원과 프로세스 상태를 실시간으로 종합적으로 모니터링하는 것은 매우 중요합니다. atop 도구는 강력한 모니터링 도구로서, 이를 쉽게 달성하도록 도와줍니다. 본 문서에서는 리눅스 인스턴스에 atop 모니터링 도구를 설치, 구성 및 사용하는 방법을 자세히 설명하겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;일반적으로-사용되는-atop-도구-소개&#34;&gt;일반적으로 사용되는 atop 도구 소개
&lt;/h2&gt;&lt;p&gt;atop은 Linux 시스템 리소스 및 프로세스를 모니터링하는 데 특화된 도구입니다. 시스템과 프로세스의 활동을 기록하고 모든 프로세스의 실행 상황을 보고합니다. 이 도구는 CPU, 메모리, 디스크, 네트워크 등 리소스 사용량 정보와 프로세스 상태 데이터를 수집하며, 데이터를 로그 파일 형태로 디스크에 저장할 수도 있습니다. 각 프로세스별로 CPU 사용률, 메모리 증가량, 디스크 사용률, 우선순위, 사용자 이름, 상태 및 종료 코드 등의 주요 정보를 얻을 수 있습니다. 또한 atop 설정 파일을 통해 로그 수집 빈도, 로그 파일 저장 경로 및 로테이션 정책과 같은 매개변수를 사용자 정의할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;두-번째-atop-도구-설치&#34;&gt;두 번째, atop 도구 설치
&lt;/h2&gt;&lt;p&gt;다양한 Linux 배포판에서 atop을 설치하는 방법은 약간씩 다르며, 다음에서는 일반적인 운영체제를 기준으로 설명하겠습니다&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Alibaba Cloud Linux 3/2、CentOS 7/8、Fedora、Rocky Linux 9&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실행 설치 명령: &lt;code&gt;sudo yum install -y atop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;atop 서비스를 시작합니다: &lt;code&gt;sudo systemctl start atop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Ubuntu / Debian&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;소프트웨어 저장소 목록 업데이트: &lt;code&gt;sudo apt update&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;실행 설치 명령: &lt;code&gt;sudo apt install -y atop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;atop 서비스를 시작합니다: &lt;code&gt;sudo systemctl start atop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CentOS Stream 9&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다운로드 및 설치: &lt;code&gt;sudo wget https://www.atoptool.nl/download/atop-2.11.0-1.el9.x86_64.rpm &amp;amp;&amp;amp; sudo rpm -i atop-2.11.0-1.el9.x86_64.rpm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;atop 서비스를 시작합니다: &lt;code&gt;sudo systemctl start atop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;openSUSE&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실행할 설치 명령: &lt;code&gt;sudo zypper install -y atop atop-daemon&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;atop 서비스를 시작합니다: &lt;code&gt;sudo systemctl start atop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;위에 나열된 운영체제에 사용하시는 배포판이 포함되어 있지 않다면, atop 공식 웹사이트에서 설치 정보를 확인하실 수 있습니다&lt;/p&gt;
&lt;h2 id=&#34;세-모니터링-주기-및-로그-보존-기간-설정&#34;&gt;세, 모니터링 주기 및 로그 보존 기간 설정
&lt;/h2&gt;&lt;p&gt;설정 파일 위치: Alibaba Cloud Linux 3/2, CentOS 7/8 및 Fedora 시스템에서는 atop의 설정 파일이 &lt;code&gt;/etc/sysconfig/atop&lt;/code&gt;이고, Ubuntu, Debian 및 openSUSE 시스템에서는 설정 파일이 &lt;code&gt;/etc/default/atop&lt;/code&gt;입니다
기본 설정 매개변수 설명
- 로그옵션은 로그 파일 기록 옵션을 제어하는 데 사용되며, 기본값은 비어 있습니다
- 로그 간격입니다. 기본값은 600초입니다. 과거 로그 추적 문제를 수집하려면 실제 요구 사항에 따라 이 빈도를 조정하는 것이 좋습니다.
- 로그 보존 기간, 기본값 28일
- 로그 파일 저장 경로입니다. 기본값은 /var/log/atop 입니다.
설정 단계
- 명령을 실행하여 설정 파일을 엽니다:
- Alibaba Cloud Linux 3/2, CentOS 7/8, Fedora 시스템에서: &lt;code&gt;sudo vim /etc/sysconfig/atop&lt;/code&gt;
- Ubuntu, Debian, openSUSE, CentOS Stream 9, Rocky Linux 9 시스템에서: &lt;code&gt;sudo vim /etc/default/atop&lt;/code&gt;
- &lt;code&gt;i&lt;/code&gt;로 들어가 편집 모드로 전환한 다음, 필요에 따라 구성 매개변수를 조정합니다. 예를 들어, 모니터링 주기를 30초로 변경하고, 로그 보존 기간을 7일로 설정하며, 로그 경로를 기본값으로 유지합니다.
- &lt;code&gt;Esc&lt;/code&gt; 키를 누르고 &lt;code&gt;:wq&lt;/code&gt; 를 입력하여 저장하고 편집을 종료합니다
- atop 서비스를 재시작하여 설정이 적용됩니다: &lt;code&gt;sudo systemctl restart atop&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;LOGOPTS=&amp;quot;&amp;quot;
LOGINTERVAL=30
LOGGENERATIONS=7
LOGPATH=/var/log/atop 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;네-알겠습니다-사-atop-도구-사용&#34;&gt;네, 알겠습니다. 사, atop 도구 사용
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;자주 사용되는 명령어 소개:&lt;/strong&gt; 상호 작용 명령 모드에서 다음의 자주 사용되는 명령어가 있습니다
- 기본 통합 출력 보기로 전환합니다
- 프로세스 열의 전체 명령줄을 표시합니다
- 프로세스 메모리 사용률에 따라 내림차순으로 필터링합니다
- 프로세스 디스크 사용률을 기준으로 내림차순으로 필터링합니다
- 프로세스 자원 종합 활용률에 따라 내림차순으로 필터링합니다
- 프로세스 네트워크 사용률에 따라 내림차순으로 필터링합니다
- 다음 모니터링 수집 지점으로 이동합니다
- 이전 모니터링 수집 지점으로 이동합니다
- 시간 지정, 형식은 &lt;code&gt;YYYYMMDDhhmm&lt;/code&gt;입니다&lt;/p&gt;
&lt;p&gt;자원 모니터링 필드 의미 설명
- 호스트 이름, 정보 샘플링 날짜 및 시간입니다
- 프로세스 전체 실행 상황, 커널 모드 및 사용자 모드 실행 시간, 프로세스 총 수, 다양한 상태의 프로세스 수 등을 포함합니다
- CPU 전체 사용률은 각 필드의 숫자 합계가 &lt;code&gt;N*100%&lt;/code&gt;(N은 CPU 코어 수)로 표시되며, 커널 모드, 사용자 모드, 인터럽트, 유휴 상태, 디스크 I/O 대기 등의 시간 비율을 포함합니다
- CPL은 CPU 부하 상황을 나타내며, 과거 1분, 5분 및 15분 동안 실행 대기열에 있는 평균 프로세스 수, 컨텍스트 스위칭 횟수, 인터럽트 발생 횟수를 포함합니다
- 메모리 사용량 정보로, 총 물리 메모리 용량, 유휴 메모리, 페이지 캐시 메모리, 파일 캐시 메모리, 커널 점유 메모리 등을 포함합니다
- SWP：스왑 공간 사용량 정보, 스왑 영역 총 용량 및 남은 스왑 공간 크기를 포함합니다
- 가상 메모리 페이지 상태, 예를 들어 스왑 인 및 스왑 아웃된 페이지 수
- DSK：디스크 사용률, 각 디스크 장치별로 한 열을 표시하며 장치 식별자, 바쁜 상태 시간 비율, 읽기/쓰기 요청 횟수를 나타냅니다
- 네트워크 상태를 보여주며, 전송 계층 TCP와 UDP, IP 계층 및 각 활성 네트워크 포트의 송수신 패킷 크기를 표시합니다&lt;/p&gt;
&lt;p&gt;실시간 시스템 지표 확인
- 매 5초마다 시스템 지표를 확인합니다: &lt;code&gt;atop 5&lt;/code&gt;
- 현재 시간 이후 5분 내 (총 30회, 간격 10초)의 시스템 지표를 확인합니다: &lt;code&gt;atop -M 10 30&lt;/code&gt;
- 현재 시간 이후 10분(10회, 간격 60초)의 시스템 지표를 확인하고 결과를 파일에 기록합니다: &lt;code&gt;atop -M 60 10 &amp;gt; /log/atop.mem&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;atop을 시작한 후 수집된 기록은 기본적으로 &lt;code&gt;/var/log/atop&lt;/code&gt; 디렉터리에 저장됩니다. 확인할 때는 지정된 날짜의 로그 파일이 반드시 존재해야 하며, 그렇지 않으면 오류가 발생합니다.
- 오늘 날짜의 히스토리 지표 로그 보기: &lt;code&gt;atop -r&lt;/code&gt;
- 어제 기록 지표 로그 확인: &lt;code&gt;atop -r y&lt;/code&gt;
- 지정된 날짜의 과거 지표 로그를 확인합니다. 예를 들어 2024년 11월 06일: &lt;code&gt;atop -r 20241106&lt;/code&gt;
- 지정된 날짜 및 시간 이후의 과거 지표 로그를 확인합니다. 예를 들어 2024년 11월 6일 14:00 이후: &lt;code&gt;atop -r 20241106 -b 14:00&lt;/code&gt;
- 지정된 날짜 및 시간 범위 내의 과거 지표 로그를 확인합니다. 예를 들어 2024년 11월 5일 00시 04분부터 00시 08분까지는 &lt;code&gt;atop -r 20241105 -b 00:04 -e 00:08&lt;/code&gt; 명령을 사용합니다.&lt;/p&gt;
&lt;p&gt;시스템 활동 보고서 확인
- 현재 시스템의 CPU 사용률 보고서를 1분 동안(12회, 간격 5초) 확인합니다: &lt;code&gt;atopsar -c 5 12&lt;/code&gt;
- 당일 지정된 시간대의 메모리 지표 보고서를 확인하려면, 예를 들어 18:00부터 18:01까지: &lt;code&gt;atopsar -m -b 18:00 -e 18:01&lt;/code&gt;
- 지정된 날짜 및 시간 범위 내의 메모리 지표 보고서를 확인합니다. 예를 들어 2024년 11월 5일 18:00부터 18:01까지: &lt;code&gt;atopsar -m -r 20241105 -b 18:00 -e 18:01&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;다섯-기타-조작&#34;&gt;다섯. 기타 조작
&lt;/h2&gt;&lt;p&gt;천기 수준 로그 로테이션 정책 구성: 매일 atop 지표 로그 파일을 생성하려면 다음 단계를 수행할 수 있습니다
- (선택 사항) 필요에 따라 모니터링 주기, 로그 보존 기간 및 로그 저장 경로를 조정합니다
- 명령을 실행하여 매일 로그 로테이션 관련 서비스의 자동 시작을 설정하고 서비스를 시작합니다: &lt;code&gt;sudo systemctl enable --now atop atopacct atop-rotate.timer&lt;/code&gt;
- 비즈니스에서 더 복잡한 로깅 처리가 필요하다면 logrotate나 사용자 정의 스크립트를 활용하여 로그 관리를 구현할 수 있습니다&lt;/p&gt;
&lt;p&gt;선택적 netatop 커널 모듈 로드: 네트워크 사용률을 모니터링하려면 netatop 모듈(atop에서 기본적으로 설치되지 않음)을 설치할 수 있습니다. Alibaba Cloud Linux 3 시스템의 예를 들어:
- 커널 개발 패키지 및 컴파일에 필요한 소프트웨어 환경 설치: &lt;code&gt;sudo yum install -y kernel-devel dkms elfutils-libelf-devel&lt;/code&gt;
- 최신 버전 netatop 소스 코드를 지정된 디렉터리로 다운로드합니다: &lt;code&gt;cd /usr/src/ &amp;amp;&amp;amp; sudo wget https://www.atoptool.nl/download/netatop-3.2.2.tar.gz --no-check-certificate&lt;/code&gt;
- 소스 코드를 압축 해제하고 소스 코드 디렉토리로 들어갑니다: &lt;code&gt;sudo tar -zxvf netatop-3.2.2.tar.gz &amp;amp;&amp;amp; cd netatop-3.2.2&lt;/code&gt;
- 소스 코드를 기반으로 모듈과 데몬을 빌드하고 설치합니다: &lt;code&gt;sudo make &amp;amp;&amp;amp; sudo make install&lt;/code&gt;
- netatop 서비스 시작: &lt;code&gt;sudo systemctl start netatop&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;atop 도구는 기능이 강력하고 사용하기 유연하며, 적절한 설치, 구성 및 사용을 통해 Linux 시스템의 실행 상태를 더 잘 이해하고 잠재적인 문제를 조기에 발견하여 해결할 수 있습니다. 본 문서가 Linux 시스템 모니터링 측면에서 여러분의 역량을 향상시키는 데 도움이 되기를 바랍니다.&lt;/p&gt;
&lt;h2 id=&#34;6-참고-자료-링크&#34;&gt;6. 참고 자료 링크
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;[atop 공식 웹사이트]&lt;/li&gt;
&lt;li&gt;[ atop 모니터링 도구 설치, 구성 및 사용 ]&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Visual Studio에서 일치하지 않는 PDB 파일을 로드합니다</title>
        <link>https://ttf248.life/ko/p/visual-studio-loading-unmatched-pdb-files/</link>
        <pubDate>Thu, 23 Jan 2025 20:04:33 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/visual-studio-loading-unmatched-pdb-files/</guid>
        <description>&lt;p&gt;윈도우에서 Visual Studio로 프로그램을 디버깅할 때, pdb 파일이 실행 파일과 일치하지 않으면 Visual Studio가 &amp;ldquo;기호 파일을 로드할 수 없음&amp;quot;이라는 메시지를 표시합니다. 프로그램이 충돌하고 덤프 파일이 생성되면, 일치하지 않는 pdb 파일 때문에 Visual Studio는 충돌 현장에 원활하게 진입하지 못합니다.&lt;/p&gt;
&lt;h2 id=&#34;pdb-파일이-뭐죠&#34;&gt;pdb 파일이 뭐죠?
&lt;/h2&gt;&lt;p&gt;PDB 파일은 마이크로소프트에서 제공하는 디버깅 정보 파일이며, 프로그램 디버깅에 사용됩니다. PDB 파일에는 프로그램의 심볼 테이블, 소스 코드 파일 이름, 행 번호 등의 정보가 포함되어 있습니다. 프로그램 컴파일 시 PDB 파일을 생성하여 프로그램을 디버깅할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;windbg-디버깅&#34;&gt;WinDbg 디버깅
&lt;/h2&gt;&lt;p&gt;WinDbg는 마이크로소프트의 디버깅 도구이며, Windows 프로그램을 디버깅하는 데 사용될 수 있습니다. WinDbg는 호환되지 않는 pdb 파일을 로드할 수 있지만, 수동으로 로드해야 합니다. &lt;code&gt;.reload /f /i&lt;/code&gt; 명령어를 사용하여 호환되지 않는 pdb 파일을 강제로 로드할 수 있습니다.&lt;/p&gt;
&lt;p&gt;하지만 WinDbg는 Visual Studio만큼 사용하기 편리하지 않으므로, 저희는 Visual Studio에서도 호환되지 않는 PDB 파일을 로드할 수 있기를 바랍니다&lt;/p&gt;
&lt;h2 id=&#34;비주얼-스튜디오에서-호환되지-않는-pdb-파일을-로드합니다&#34;&gt;비주얼 스튜디오에서 호환되지 않는 PDB 파일을 로드합니다
&lt;/h2&gt;&lt;p&gt;소스 코드는 보통 git으로 관리되므로, 해당 버전의 코드를 찾아 다시 컴파일하여 일치하는 pdb 파일을 생성할 수 있습니다. 왜 로드되지 않을까요? 주로 메타데이터가 매칭되지 않기 때문입니다.&lt;/p&gt;
&lt;p&gt;작은 도구가 있는데, 실행 파일 정보에 기반하여 메타데이터를 수정하고 새로운 pdb 파일을 생성하여 Visual Studio가 로드할 수 있게 합니다&lt;/p&gt;
&lt;p&gt;chkmatch 다운로드 주소: &lt;a class=&#34;link&#34; href=&#34;https://www.debuginfo.com/tools/chkmatch.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.debuginfo.com/tools/chkmatch.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;사이트 캐시 주소: &lt;a class=&#34;link&#34; href=&#34;chkmatch.zip&#34; &gt;chkmatch.zip&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ChkMatch utility can be used to check whether an executable and debug information file match. It can also be used to enforce matching between an executable and debug information file, if they are compatible.

For more information about debug information matching and related issues, see this article.

Supported debug information formats: DBG, PDB 2.0, PDB 7.0.

chkmatch [-c ExeFile DebugInfoFile ] |
         [-m ExeFile DebugInfoFile]
-c
Check matching between the executable and the debug information file.
-m
Make the executable and the debug information file match.
ExeFile
The name of the executable file.
DebugInfoFile
The name of the debug information file.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;chkmatch-사용하세요&#34;&gt;chkmatch 사용하세요
&lt;/h2&gt;&lt;p&gt;먼저 검사 작업을 수행하고, 불일치 원인을 분석한 후 서명 불일치를 알립니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\tianlong.xiang\Downloads\chkmatch&amp;gt;ChkMatch.exe -c &amp;quot;D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe&amp;quot; E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb
ChkMatch - version 1.0
Copyright (C) 2004 Oleg Starodumov
http://www.debuginfo.com/


Executable: D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe
Debug info file: E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb

Executable:
TimeDateStamp: c26d9be3
Debug info: 2 ( CodeView )
TimeStamp: f86b0a4f  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 122  RVA: 001cdc44  FileOffset: 001cbe44
CodeView format: RSDS
Signature: {428c9b95-39a3-4a8d-a8e5-7be453684757}  Age: 1
PdbFile: D:\stock_UAT\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\obj\Release\YinTrade.Main.pdb
Debug info: 16 ( Unknown )
TimeStamp: 00000000  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 0  RVA: 00000000  FileOffset: 00000000

Debug information file:
Format: PDB 7.00
Signature: {06fae08e-c0a2-4f3d-9c7c-dfc684445dd1}  Age: 1

Result: Unmatched (reason: Signature mismatch)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그런 다음 수정 작업을 실행하여 pdb 파일과 exe 파일을 일치시킵니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\tianlong.xiang\Downloads\chkmatch&amp;gt;ChkMatch.exe -m &amp;quot;D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe&amp;quot; E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb
ChkMatch - version 1.0
Copyright (C) 2004 Oleg Starodumov
http://www.debuginfo.com/


Executable: D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe
Debug info file: E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb

Executable:
TimeDateStamp: c26d9be3
Debug info: 2 ( CodeView )
TimeStamp: f86b0a4f  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 122  RVA: 001cdc44  FileOffset: 001cbe44
CodeView format: RSDS
Signature: {428c9b95-39a3-4a8d-a8e5-7be453684757}  Age: 1
PdbFile: D:\stock_UAT\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\obj\Release\YinTrade.Main.pdb
Debug info: 16 ( Unknown )
TimeStamp: 00000000  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 0  RVA: 00000000  FileOffset: 00000000

Debug information file:
Format: PDB 7.00
Signature: {06fae08e-c0a2-4f3d-9c7c-dfc684445dd1}  Age: 1

Writing to the debug information file...
Result: Success.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/38147487/forcing-to-load-unmatched-symbols-in-visual-studio-2015-debugger&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;forcing-to-load-unmatched-symbols-in-visual-studio-2015-debugger&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>커서 AI 프로그래밍 IDE 체험</title>
        <link>https://ttf248.life/ko/p/cursor-ai-programming-ide-trial/</link>
        <pubDate>Thu, 23 Jan 2025 19:30:13 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/cursor-ai-programming-ide-trial/</guid>
        <description>&lt;p&gt;번뜩이는 사이 또 일 년이 지나갔다. 업무적으로 가장 큰 변화는 인공지능의 참여도가 눈에 띄게 높아진 것인데, 이전에는 다양한 개발 언어 간 전환 시 개발자가 익숙해해야 할 여러 언어들의 다른 API 인터페이스들이 있었지만, 이제 이러한 기본적인 코드들은 AI를 통해 생성할 수 있게 되었다. 이는 개발자들에게 큰 행운이다.&lt;/p&gt;
&lt;h2 id=&#34;chatgpt&#34;&gt;ChatGPT
&lt;/h2&gt;&lt;p&gt;23년도에 간단한 입문 소개 두 편을 다룬 적이 있었는데, 눈 깜짝할 사이에 25년이 벌써 왔네요. 어떻게 말해야 할지 모르겠지만, 뚜렷한 발전은 없는 것 같아요. 아직은 자신만의 인식을 가지고 합리적으로 작업을 분할할 수 있어야 하고, 무엇보다 중요한 것은 AI가 생성한 코드에 버그가 있는지 식별하는 것입니다.&lt;/p&gt;
&lt;h2 id=&#34;github-copilot&#34;&gt;Github copilot
&lt;/h2&gt;&lt;p&gt;어느 날인지 잊혀졌는데, 자료를 보니 싱가포르에 서버를 구축했고, 이제 국내에서 사용할 수 있어서 더 이상 오랫동안 VPN을 사용할 필요가 없어. 물론 로그인할 때는 아직 VPN이 필요하지만, 이 VPN은 로그인할 때만 잠깐 사용하면 되고 그 후에는 종료해도 돼.&lt;/p&gt;
&lt;p&gt;일상적으로 더 많이 사용하는 것은 Github Copilot 플러그인인데, 이 플러그인은 vscode나 visual studio에서 바로 사용할 수 있습니다. 두 프로그램 사이를 전환할 필요가 없습니다. ChatGPT에 비해 Github Copilot이 프로젝트 지원이 더 좋고, 상호작용도 더 친절하며, 일부 로컬 파일을 선택하여 AI를 **“훈련”**시킬 수 있어 생성되는 코드가 프로젝트에 더 잘 맞습니다.&lt;/p&gt;
&lt;h2 id=&#34;cursor-ai&#34;&gt;Cursor AI
&lt;/h2&gt;&lt;p&gt;최근에 새로운 AI 프로그래밍 IDE인 Cursor AI를 보았는데, 이 IDE는 Github Copilot을 기반으로 하고 있지만, 더 똑똑하고 파일을 직접 생성해 줄 수 있습니다&lt;/p&gt;
&lt;p&gt;간단히 사용해 봤는데 괜찮은 것 같긴 하지만, 현재 프로젝트에 대한 이해는 아직 부족하고, 로컬 프로젝트 파일이 많을 때는 큰 규모의 리팩토링이나 최적화 조정은 여전히 &lt;strong&gt;개발자가 작업을 분할해야 한다&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;예시 하나를 덧붙입니다: curso의 엔지니어링 모드로 전환하여 다음 내용을 입력하세요: 새로운 개인 이력서 웹페이지를 생성하고, 여러 가지 다른 스타일로 전환할 수 있도록 지원하며, 데이터 표시를 위해 몇몇 개인 정보를 채워 넣으세요&lt;/p&gt;
&lt;p&gt;몇 번이고 &lt;strong&gt;두었다 떼었다&lt;/strong&gt; 하는 과정을 거치면 다음과 같은 웹페이지를 얻을 수 있습니다. 물론 이 웹페이지는 비교적 간단하지만, 초보자에게는 아주 괜찮은 시작입니다.&lt;/p&gt;
&lt;p&gt;현재 등록 사용자는 고급 API를 150회 무료로 체험해 볼 수 있으며, 유료 사용자는 고급 API 사용이 5000회로 제한됩니다&lt;/p&gt;
&lt;p&gt;개인 이력서&lt;/p&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43; 비트 연산 기초: 비트별 값 가져오기 및 플래그 설정</title>
        <link>https://ttf248.life/ko/p/cpp-bitwise-operations-basics-flags/</link>
        <pubDate>Fri, 17 Jan 2025 02:23:56 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/cpp-bitwise-operations-basics-flags/</guid>
        <description>&lt;p&gt;실제 C++ 개발에서 비트 연산은 흔한 기술이며, 특히 시스템 상태, 플래그 또는 제어 비트를 처리할 때 매우 효율적인 솔루션을 제공합니다. 본 글에서는 예제를 통해 비트 연산을 사용하여 특정 플래그를 가져오고 설정하는 방법을 설명하겠습니다.&lt;/p&gt;
&lt;h3 id=&#34;비트-연산-기초-개념&#34;&gt;비트 연산 기초 개념
&lt;/h3&gt;&lt;p&gt;컴퓨터에서 데이터는 이진 비트(0과 1)로 저장됩니다. 비트 연산은 이러한 이진 비트에 대한 연산을 말합니다. C++에는 몇 가지 일반적인 비트 연산자가 있습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;비트 AND 연산 (&amp;amp;)는 특정 비트가 1인지 확인하는 데 사용됩니다&lt;/li&gt;
&lt;li&gt;비트 OR (|) : 특정 비트를 1로 설정하는 데 사용됩니다&lt;/li&gt;
&lt;li&gt;비트별 XOR(^) 연산은 특정 비트를 반전시키는 데 사용됩니다&lt;/li&gt;
&lt;li&gt;비트 반전(~)&lt;/li&gt;
&lt;li&gt;모든 비트를 몇 자리 왼쪽으로 이동합니다&lt;/li&gt;
&lt;li&gt;모든 비트를 지정된 자릿수만큼 오른쪽으로 이동합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 예제에서는 &lt;code&gt;unsigned short&lt;/code&gt; 타입의 변수 &lt;code&gt;wInfo&lt;/code&gt;에 대해 일련의 비트 연산을 수행하여 다양한 플래그를 통해 서로 다른 상태를 표현해야 합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;flowchart LR
    A[原始数值: 00010000] --&amp;gt; B[左移: 00010000 &amp;lt;&amp;lt; 1]
    B --&amp;gt; C[结果: 00100000]
    C --&amp;gt; D[右移: 00100000 &amp;gt;&amp;gt; 1]
    D --&amp;gt; E[结果: 00010000]

    subgraph 左移操作
        direction LR
        A --&amp;gt; B --&amp;gt; C
    end

    subgraph 右移操作
        direction LR
        C --&amp;gt; D --&amp;gt; E
    end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;요구사항-분석&#34;&gt;요구사항 분석
&lt;/h3&gt;&lt;p&gt;문제 설명에 따르면, 우리는 다양한 상태를 나타내기 위해 사용되는 16비트 플래그가 있습니다. 이러한 상태는 각각 다른 이진 비트를 통해 표현되며, 각 이진 비트는 특정 의미를 가집니다. 예를 들어:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;비트 0가 실패했습니까?&lt;/li&gt;
&lt;li&gt;비트 1 압축되었습니까?&lt;/li&gt;
&lt;li&gt;비트2 증분 업데이트인가?&lt;/li&gt;
&lt;li&gt;비트3에 후속 패키지가 있나요?&lt;/li&gt;
&lt;li&gt;정상 요청 또는 로그아웃&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;비트-연산을-사용하여-구현하세요&#34;&gt;비트 연산을 사용하여 구현하세요
&lt;/h3&gt;&lt;p&gt;우리는 비트 연산을 통해 이러한 플래그를 설정하고 가져올 것입니다. 구체적으로:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;각 자리 값 가져오기：어떤 한 자리의 값(0 또는 1)을 얻는다&lt;/li&gt;
&lt;li&gt;비트 설정: 특정 비트를 1로 설정합니다&lt;/li&gt;
&lt;li&gt;비트 단위로 지우기: 특정 비트를 0으로 설정합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;우리는 먼저 &lt;code&gt;unsigned short&lt;/code&gt; 타입의 변수 &lt;code&gt;wInfo&lt;/code&gt;를 정의하여 이러한 플래그들을 저장합니다. 그런 다음, 비트 연산을 통해 해당 플래그들을 확인하고 설정합니다.&lt;/p&gt;
&lt;h3 id=&#34;c-예제-코드&#34;&gt;C++ 예제 코드
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;bitset&amp;gt;

// 定义标志位常量
const unsigned short BIT_0_FAIL = 1 &amp;lt;&amp;lt; 0;    // bit0 是否失败
const unsigned short BIT_1_COMPRESSED = 1 &amp;lt;&amp;lt; 1; // bit1 是否压缩
const unsigned short BIT_2_INCREMENT = 1 &amp;lt;&amp;lt; 2;  // bit2 是否增量
const unsigned short BIT_3_HAS_MORE = 1 &amp;lt;&amp;lt; 3;   // bit3 是否有后续包
const unsigned short BIT_5_CANCEL = 1 &amp;lt;&amp;lt; 5;     // bit5 正常请求(0)或注销(1)

// 检查某一位是否为1
bool isBitSet(unsigned short wInfo, unsigned short bitMask) {
    return (wInfo &amp;amp; bitMask) != 0;
}

// 设置某一位为1
void setBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo |= bitMask;
}

// 清除某一位（设置为0）
void clearBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo &amp;amp;= ~bitMask;
}

int main() {
    // 假设wInfo的初始值为0
    unsigned short wInfo = 0;

    // 设置bit0（失败标志）
    setBit(wInfo, BIT_0_FAIL);
    
    // 设置bit1（压缩标志）
    setBit(wInfo, BIT_1_COMPRESSED);
    
    // 打印wInfo的二进制值
    std::cout &amp;lt;&amp;lt; &amp;quot;wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    // 检查各个标志位
    std::cout &amp;lt;&amp;lt; &amp;quot;bit0 (是否失败): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_0_FAIL) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit1 (是否压缩): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_1_COMPRESSED) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit2 (是否增量): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_2_INCREMENT) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit3 (是否有后续包): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_3_HAS_MORE) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit5 (是否注销): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_5_CANCEL) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;

    // 清除bit1（压缩标志）
    clearBit(wInfo, BIT_1_COMPRESSED);
    
    // 打印更新后的wInfo
    std::cout &amp;lt;&amp;lt; &amp;quot;Updated wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;코드 실행, 오래된 친구 추천: &lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wInfo (in binary): 0000000000000011
bit0 (是否失败): 是
bit1 (是否压缩): 是
bit2 (是否增量): 否
bit3 (是否有后续包): 否
bit5 (是否注销): 否
Updated wInfo (in binary): 0000000000000001
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;코드-설명&#34;&gt;코드 설명
&lt;/h3&gt;&lt;p&gt;플래그 비트는 비트 시프트 연산(&lt;code&gt;1 &amp;lt;&amp;lt; n&lt;/code&gt;)을 사용하여 정의합니다. 예를 들어, &lt;code&gt;1 &amp;lt;&amp;lt; 0&lt;/code&gt;은 &lt;code&gt;bit0&lt;/code&gt;에 해당하고, &lt;code&gt;1 &amp;lt;&amp;lt; 1&lt;/code&gt;은 &lt;code&gt;bit1&lt;/code&gt;에 해당하며, 이와 같은 방식으로 계속됩니다. 이렇게 하면 각 플래그 비트에 고유한 이진 위치를 할당하게 됩니다.&lt;/p&gt;
&lt;p&gt;특정 비트가 1인지 확인하려면 &lt;code&gt;isBitSet&lt;/code&gt; 함수가 비트 AND 연산 &lt;code&gt;wInfo &amp;amp; bitMask&lt;/code&gt;를 사용하여 이를 수행합니다. 해당 비트가 1이면 함수는 &lt;code&gt;true&lt;/code&gt;를 반환하고, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt;를 반환합니다.&lt;/p&gt;
&lt;p&gt;설정비트: &lt;code&gt;setBit&lt;/code&gt; 함수는 비트 OR 연산 &lt;code&gt;wInfo |= bitMask&lt;/code&gt;를 통해 특정 플래그 비트를 1로 설정합니다&lt;/p&gt;
&lt;p&gt;특정 비트 위치를 0으로 설정하기 위해 &lt;code&gt;clearBit&lt;/code&gt; 함수는 비트 AND 연산 &lt;code&gt;wInfo &amp;amp;= ~bitMask&lt;/code&gt;를 사용합니다&lt;/p&gt;
&lt;h3 id=&#34;요약&#34;&gt;요약
&lt;/h3&gt;&lt;p&gt;비트 연산을 통해 우리는 여러 상태 플래그를 효율적으로 처리할 수 있습니다. 실제 개발에서 이 기술은 특히 유용합니다. 예를 들어, 임베디드 개발, 네트워크 프로토콜, 시스템 상태 관리 등의 시나리오에서 비트 플래그를 사용하여 여러 개의 이진 상태를 표현함으로써 공간을 절약하고 효율성을 높일 수 있습니다.&lt;/p&gt;
&lt;p&gt;이 블로그 게시물이 C++에서 비트 연산을 사용하여 비트 값 가져오기 및 설정 방법을 이해하는 데 도움이 되기를 바랍니다. 이러한 기술을 숙달하면 효율적이고 유지 관리하기 쉬운 코드를 작성하는 데 매우 유용합니다!&lt;/p&gt;</description>
        </item>
        <item>
        <title>데스크탑을 2.5G 네트워크 카드로 업그레이드하여 로컬 영역 네트워크 연결 속도를 높입니다</title>
        <link>https://ttf248.life/ko/p/desktop-upgrade-to-25g-network-card-accelerate-lan-interconnection/</link>
        <pubDate>Fri, 10 Jan 2025 00:37:52 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/desktop-upgrade-to-25g-network-card-accelerate-lan-interconnection/</guid>
        <description>&lt;p&gt;데스크톱 하드웨어 연달아 출시, 앞선 글에서 PCIE 어댑터에 대해 언급했는데, 구형 SSD는 어떻게 됐을까요? 당연히 버려진 건 아니죠. 고장난 것도 아니고, 분해해서 1년 전 구매한 &lt;code&gt;메카니저 크리에이터 미니-3765H&lt;/code&gt;에 설치했습니다.&lt;/p&gt;
&lt;p&gt;새 장비, 하드웨어 사양은 여전히 훌륭합니다. 2.5G 이중 네트워크 포트, PCIE4.0, WiFi6.&lt;/p&gt;
&lt;p&gt;최근 이사한 집에는 개별 라우터가 없어 네트워크 연결이 모두 무선으로 되어 있습니다. 아수스 메인보드 데스크탑의 무선 카드 성능이 좋지 않거나, 라우터의 무선 접속이나 로컬 네트워크 간 업로드 속도 문제일 수도 있는데, 이로 인해 기기 간 속도가 빠르지 않습니다. 새로 2.5G 네트워크 카드를 구매하여 데스크탑에 설치했습니다.&lt;/p&gt;
&lt;p&gt;여기까지, 메인보드의 슬롯이 모두 채워졌습니다: 그래픽 카드, 무선 네트워크 카드, 2.5G 네트워크 카드, SSD PCIE 어댑터&lt;/p&gt;
&lt;h2 id=&#34;네트워크-설명&#34;&gt;네트워크 설명
&lt;/h2&gt;&lt;p&gt;두 대의 기기는 여전히 원래 무선 네트워크 어댑터를 통해 인터넷에 연결되지만, 두 기기 사이는 직접 네트워크 케이블로 연결되어 있으며 양쪽 모두 2.5G 네트워크 어댑터입니다. 두 기기를 네트워크 케이블로 직접 연결하는 방법은 자세히 설명하지 않겠습니다. 온라인에 많은 튜토리얼이 있습니다. 방화벽을 열어두는 것을 잊지 마세요. 원하는 한 대를 게이트웨이로 선택하면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
    A[机器1&amp;lt;br&amp;gt;IP: 192.168.4.1&amp;lt;br&amp;gt;子网掩码: 255.255.255.0&amp;lt;br&amp;gt;默认网关: - &amp;lt;br&amp;gt;自动获取DNS] --&amp;gt;|网线直连（2.5G）| B[机器2&amp;lt;br&amp;gt;IP: 192.168.4.2&amp;lt;br&amp;gt;子网掩码: 255.255.255.0&amp;lt;br&amp;gt;默认网关: 192.168.4.1&amp;lt;br&amp;gt;自动获取DNS];
    A --&amp;gt;|无线网卡| Internet;
    B --&amp;gt;|无线网卡| Internet;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;두-네트워크-구간-속도-측정&#34;&gt;두 네트워크 구간 속도 측정
&lt;/h2&gt;&lt;h3 id=&#34;라우터-로컬-네트워크&#34;&gt;라우터 로컬 네트워크
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\core\Desktop\iperf-3.1.3-win32&amp;gt;iperf3.exe -c 192.168.3.237
Connecting to host 192.168.3.237, port 5201
[  4] local 192.168.3.122 port 1656 connected to 192.168.3.237 port 5201
[ ID] Interval           Transfer     Bandwidth
[  4]   0.00-1.00   sec  9.17 MBytes  76.7 Mbits/sec
[  4]   1.00-2.00   sec  9.91 MBytes  83.2 Mbits/sec
[  4]   2.00-3.00   sec  8.74 MBytes  73.3 Mbits/sec
[  4]   3.00-4.00   sec  10.2 MBytes  85.2 Mbits/sec
[  4]   4.00-5.00   sec  9.23 MBytes  77.1 Mbits/sec
[  4]   5.00-6.00   sec  8.80 MBytes  73.9 Mbits/sec
[  4]   6.00-7.01   sec  8.00 MBytes  66.8 Mbits/sec
[  4]   7.01-8.00   sec  7.69 MBytes  64.9 Mbits/sec
[  4]   8.00-9.01   sec  9.72 MBytes  81.1 Mbits/sec
[  4]   9.01-10.01  sec  7.63 MBytes  63.6 Mbits/sec
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bandwidth
[  4]   0.00-10.01  sec  89.0 MBytes  74.6 Mbits/sec                  sender
[  4]   0.00-10.01  sec  89.0 MBytes  74.6 Mbits/sec                  receiver

iperf Done.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;직결-로컬-영역-네트워크&#34;&gt;직결 로컬 영역 네트워크
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\core\Desktop\iperf-3.1.3-win32&amp;gt;iperf3.exe -c 192.168.4.1
Connecting to host 192.168.4.1, port 5201
[  4] local 192.168.4.2 port 1524 connected to 192.168.4.1 port 5201
[ ID] Interval           Transfer     Bandwidth
[  4]   0.00-1.01   sec   178 MBytes  1.48 Gbits/sec
[  4]   1.01-2.00   sec   204 MBytes  1.72 Gbits/sec
[  4]   2.00-3.00   sec   214 MBytes  1.80 Gbits/sec
[  4]   3.00-4.00   sec   229 MBytes  1.92 Gbits/sec
[  4]   4.00-5.00   sec   202 MBytes  1.69 Gbits/sec
[  4]   5.00-6.00   sec   213 MBytes  1.79 Gbits/sec
[  4]   6.00-7.00   sec   230 MBytes  1.93 Gbits/sec
[  4]   7.00-8.00   sec   192 MBytes  1.61 Gbits/sec
[  4]   8.00-9.00   sec   220 MBytes  1.84 Gbits/sec
[  4]   9.00-10.00  sec   230 MBytes  1.93 Gbits/sec
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bandwidth
[  4]   0.00-10.00  sec  2.06 GBytes  1.77 Gbits/sec                  sender
[  4]   0.00-10.00  sec  2.06 GBytes  1.77 Gbits/sec                  receiver

iperf Done.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Hugo에 mermaid 지원 추가&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>華碩 마더보드 Z490 설치 디스크가 너무 많아 가끔씩 디스크 인식에 실패함</title>
        <link>https://ttf248.life/ko/p/asus-motherboard-z490-too-many-disks-intermittent-disk-recognition/</link>
        <pubDate>Fri, 10 Jan 2025 00:08:51 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/asus-motherboard-z490-too-many-disks-intermittent-disk-recognition/</guid>
        <description>&lt;p&gt;바로 위 내용에 이어, 갑자기 무선 네트워크 카드가 인식되지 않는 문제가 발생했는데, 파티션을 재구성하기 전에 인터넷에서 다른 해결책들을 찾아봤습니다. 예를 들어 메인보드 배터리를 제거하거나 전원을 15분 동안 끊는 방법, 최신 버전의 BOIS 드라이버로 업그레이드하는 방법 등이 있었지만 모두 문제였습니다.&lt;/p&gt;
&lt;p&gt;처리할 일이 더 있다고 생각하며 제한된 네트워크로 전환하고, 거실에서 인터넷 랜선을 방으로 끌어왔는데, 이 순간 또 문제가 발생했다. 유선 네트워크도 인식되지 않는다. 큰 결단을 내리고 시스템을 재설치했더니 가이드 파티션이 손상되었다. 계속해서 문제가 발생하지 않았다면 이렇게까지 고생하지 않았을 텐데. ASUS의 디스크 충돌은 일시적인 문제이며, 시스템 재부팅 시 불안정성을 유발한다.&lt;/p&gt;
&lt;p&gt;지난주 데스크탑에 새로운 디스크를 추가했는데, 장강메모리의 2TB SSD이고 M.2 인터페이스입니다. 그리고 어제 전원을 껐을 때까지 재부팅이 되지 않았습니다.&lt;/p&gt;
&lt;p&gt;디스크 전체 정보&lt;/p&gt;
&lt;h2 id=&#34;시스템-재설치&#34;&gt;시스템 재설치
&lt;/h2&gt;&lt;p&gt;시간을 계산해 보니 2년이나 시스템을 다시 설치하지 않았고, C 드라이브는 이미 공간이 부족하다. 윈도우즈의 오래된 문제로, 일상적인 각종 소프트웨어도 C 드라이브에 뭔가 저장하는 것을 좋아한다. 그래서 시스템을 다시 설치하기로 했다. 시스템 재설치 후 네트워크 카드 문제는 정상적으로 해결되었고, 다음 날에는 일상적인 개발 환경을 복원했다. 시스템 백업을 준비하던 중 새로운 문제가 발생했는데, 시스템 재부팅 후에 부트 파티션이 사라졌다.&lt;/p&gt;
&lt;p&gt;이전 기사의 단계를 따라 부트 파티션을 재건했지만, 안정적이지 않습니다. 재부팅 후 부트 파티션이 로드되지 않을 가능성이 있으며, 케이스를 건드리는 것을 의심하기 시작했을 때 하드 드라이브 선이 느슨해졌지만 몇 번 확인해도 문제는 없습니다.&lt;/p&gt;
&lt;h2 id=&#34;기억-회복&#34;&gt;기억 회복
&lt;/h2&gt;&lt;p&gt;몇 년 전 이 기계에 한 번 SSD를 추가한 적이 있는데, 그때는 새로운 PCIE 컨버터(그래픽 카드 인터페이스에 연결)를 구입해서 직접 메인보드에 설치하지 않았습니다. 이번에는 바로 메인보드에 설치했는데, 아마 메인보드 문제일 수도 있습니다.&lt;/p&gt;
&lt;p&gt;고체 변환기&lt;/p&gt;
&lt;h2 id=&#34;메인보드-설명서&#34;&gt;메인보드 설명서
&lt;/h2&gt;&lt;p&gt;메인보드 설명서에 문제가 있는데, 표시된 SATA 포트 위치와 실제 위치가 달라서 디스크가 너무 많아 포트에 모두 장착되어 있고, 기존 SSD들은 모두 SATA 인터페이스를 사용하고 있습니다. 메인보드 설명서에 따르면 포트 간 충돌이 존재하는데, 실제로 테스트해 보니 이 충돌은 불안정하게 발생하며, 발생하면 해당 디스크를 로드할 수 없게 됩니다. 마침 이 디스크가 시스템 디스크이고 부팅도 해당 디스크에 있기 때문에 부팅 실패가 발생합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/asus-motherboard-z490-too-many-disks-intermittent-disk-recognition/20250110002401.png&#34;
	width=&#34;807&#34;
	height=&#34;847&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Z490&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;95&#34;
		data-flex-basis=&#34;228px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;해결책&#34;&gt;해결책
&lt;/h2&gt;&lt;p&gt;PCIE 어댑터에 SSD를 다시 장착하니, 메인보드의 SATA 포트와의 충돌이 사라지고 시스템이 정상적으로 부팅되었습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>ESP 파티션, GPT 파티션 테이블과 윈도우 운영 체제의 협력 원리 탐구</title>
        <link>https://ttf248.life/ko/p/exploring-esp-gpt-and-windows-cooperation/</link>
        <pubDate>Thu, 09 Jan 2025 23:58:20 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/exploring-esp-gpt-and-windows-cooperation/</guid>
        <description>&lt;p&gt;어제 퇴근하고 집에 와서 늘 하던 대로 데스크탑을 켰는데, 시스템은 정상적으로 시작되었지만 무선 네트워크 카드를 로드할 수 없었습니다. 카드 연결이 풀렸다고 생각해서 분해 후 무선 네트워크 카드를 다시 장착했는데, 문제가 더 커져서 시스템이 아예 부팅되지 않고 부트 로더가 실패했습니다.&lt;/p&gt;
&lt;p&gt;오래간만이라 데스크톱을 만지작거린 터라 파티션 부팅이 좀 낯설다. DisGenius로 빈 파티션을 다시 분할하고(보통 디스크 전방에 분할한다), ESP 파티션으로 할당하는데(기본적으로 300M), PE 시스템에서 부트 설정을 재건하면 된다. 관련 자료는 인터넷에서 찾아볼 수 있다.&lt;/p&gt;
&lt;p&gt;새 ESP 파티션 생성&lt;/p&gt;
&lt;p&gt;MSR 파티션을 제거할 수 있습니다&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;컴퓨터 저장 공간의 세계에서 ESP 파티션, GPT 파티션 테이블, 그리고 Windows 운영체제는 밀접하게 연결되어 있으며, 각자 고유하고 중요한 역할을 수행하며 시스템의 안정적인 작동과 효율적인 관리를 함께 뒷받침합니다. 하지만 이들을 자세히 알아보기 전에, 컴퓨터 파티션 역사 속 “선배”라고 할 수 있는 MBR 파티션 테이블 형식을 언급하지 않을 수 없는데, 이는 후대의 기술들과 서로 상호 반영되어 기술 진화의 맥락을 더욱 돋보이게 합니다. 오늘 우리는 이러한 요소들의 내재적인 연관성과 정교함에 대해 자세히 분석해 보겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;일반적으로-mbr-파티션-테이블--기존-하드-디스크-파티션의-기초&#34;&gt;일반적으로 MBR 파티션 테이블 — 기존 하드 디스크 파티션의 “기초”
&lt;/h2&gt;&lt;p&gt;MBR은 주로 주 부트 레코드(Master Boot Record)의 약자로, 개인용 컴퓨터 탄생 초기부터 존재하며 수십 년간 하드 디스크 파티션 영역을 지배해 왔습니다&lt;/p&gt;
&lt;h3 id=&#34;기본-구조&#34;&gt;기본 구조
&lt;/h3&gt;&lt;p&gt;이것은 하드 디스크의 첫 번째 섹터, 즉 0번 섹터에 위치하며 512바이트 공간을 차지합니다. 이 512바이트는 주로 세 부분으로 나뉘는데, 첫째는 부트 로더 코드이며 컴퓨터가 시작될 때 운영 체제의 부트 로더를 로드하는 역할을 하며 일반적으로 446바이트입니다. 둘째는 디스크 파티션 테이블로 64바이트를 차지하며 최대 4개의 주 파티션 정보를 정의할 수 있습니다. 각 파티션 설명은 16바이트를 차지하며 파티션의 시작 헤드, 섹터, 실린더와 파티션 유형, 크기와 같은 중요한 매개변수를 기록합니다. 마지막 2바이트는 MBR 종료 플래그 &amp;ldquo;55 AA&amp;quot;이며 이 섹터를 유효한 MBR로 식별하는 데 사용됩니다.&lt;/p&gt;
&lt;h3 id=&#34;역사적-공적과-한계&#34;&gt;역사적 공적과 한계
&lt;/h3&gt;&lt;p&gt;초기에 MBR 파티션 테이블은 개인용 컴퓨터의 비교적 간단한 저장 요구 사항을 충분히 충족했습니다. 운영 체제가 하드 디스크 파티션을 원활하게 인식하고 데이터를 순서대로 저장하고 읽을 수 있도록 했습니다. 그러나 시대가 발전함에 따라 그 한계가 점점 더 분명해지고 있습니다. 한 가지는 64바이트의 파티션 테이블 공간으로 인해 최대 4개의 주 파티션만 분할할 수 있으며, 더 많은 파티션을 만들려면 다소 복잡한 확장 파티션 및 논리 파티션과 같은 방법을 사용해야 하므로 디스크 관리에 불편을 초래합니다. 다른 한편으로는 최대 2TB의 하드 드라이브 용량만 지원하므로 현재 수 TB에서 수십 TB에 이르는 대용량 하드 드라이브 앞에서 힘이 부족하며, 이는 저장 기술의 추가적인 발전을 제약하는 병목 현상이 되고 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;두-번째-esp-파티션--시스템의-보이지-않는-부팅-키&#34;&gt;두 번째, ESP 파티션 — 시스템의 “보이지 않는 부팅 키”
&lt;/h2&gt;&lt;p&gt;ESP는 EFI System Partition의 약자로, UEFI(통합 확장 펌웨어 인터페이스) 표준을 기반으로 하는 컴퓨터에 필수적인 특수 파티션입니다&lt;/p&gt;
&lt;h3 id=&#34;기능-특징&#34;&gt;기능 특징
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;부트 시퀀스&lt;/strong&gt;: 컴퓨터가 전원을 켜면 UEFI 펌웨어는 먼저 하드 디스크에서 ESP 파티션을 찾아 그 안에 저장된 부트 로더(예: Windows Boot Manager)를 읽어 운영체제를 시작합니다. 마치 정확한 열쇠처럼 시스템 부팅의 문을 열어주는 것과 같습니다. 없으면 시스템은 전원이 들어올 때 혼란에 빠져 어디로 가야 할지 모릅니다.&lt;/li&gt;
&lt;li&gt;저장 드라이버: ESP 파티션은 시스템 부팅 과정에서 필수적인 일부 드라이버를 저장하여 초기 부팅 단계에서 하드웨어 장치(하드 디스크 컨트롤러, 그래픽 카드 등)가 정상적으로 작동하도록 하고, 이후 운영체제의 원활한 인계를 위한 기반을 마련합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;공간-요구사항-및-형식&#34;&gt;공간 요구사항 및 형식
&lt;/h3&gt;&lt;p&gt;일반적으로 ESP 파티션의 권장 크기는 100MB ~ 500MB 사이이며, 일반적으로 200MB 정도 할당하면 기본적인 요구 사항을 충족할 수 있습니다. 파일 시스템 형식은 반드시 FAT32여야 하며, 이는 UEFI 펌웨어만이 FAT32 형식을 통해 부트 파일을 읽어들일 수 있기 때문입니다. 이러한 방식이 호환성과 플랫폼 간 상호 운용성을 보장합니다.&lt;/p&gt;
&lt;h2 id=&#34;셋-gpt-파티션-테이블--하드-디스크의-스마트-관리자&#34;&gt;셋, GPT 파티션 테이블 — 하드 디스크의 “스마트 관리자”
&lt;/h2&gt;&lt;p&gt;GPT(가이드 파티션 테이블), 즉 전역적으로 고유한 식별자 파티션 테이블은 기존의 MBR 파티션 테이블을 대체하기 위해 개발된 새로운 파티셔닝 방식입니다&lt;/p&gt;
&lt;h3 id=&#34;장점-부각&#34;&gt;장점 부각
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;대용량 지원&lt;/strong&gt;: 오늘날 데이터 폭발의 시대에 대용량 하드 디스크가 끊임없이 등장하고 있습니다. GPT 파티션 테이블은 MBR의 2TB 용량 제한을 돌파하여 이론적으로 최대 9.4ZB(제타바이트, 1ZB = 1024 EB, 1EB = 1024 PB, 1PB = 1024 TB)의 초대형 저장 공간을 지원하며, 막대한 양의 데이터를 저장할 수 있는 가능성을 제공합니다.&lt;/li&gt;
&lt;li&gt;구분 영역 수 증가: MBR의 경우 최대 4개의 주 파티션만 분할할 수 있는 것과 달리, GPT는 최대 128개의 파티션을 생성할 수 있어 사용자 및 시스템 관리자에게 큰 유연성을 제공합니다. 여러 개의 시스템 파티션, 데이터 파티션 또는 특정 용도를 위한 파티션을 할당하든 자유롭게 활용할 수 있습니다.&lt;/li&gt;
&lt;li&gt;신뢰성이 높습니다: GPT 파티션 테이블은 중복 백업 메커니즘을 채택하여 하드 디스크 헤드와 테일 각각에 파티션 테이블 정보를 저장합니다. 한 곳의 파티션 테이블이 손상되면 시스템은 자동으로 다른 백업에서 복구하므로, 파티션 테이블 오류로 인한 데이터 손실 위험을 크게 줄여 데이터 보안을 보장합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;구조-분석&#34;&gt;구조 분석
&lt;/h3&gt;&lt;p&gt;GPT 파티션 테이블은 여러 부분으로 구성되어 있으며, 보호 MBR(전통적인 BIOS와의 호환성을 위해 보존된 MBR 구조의 일부이지만 실제 파티션 관리에 사용되지는 않음), GPT 헤더(파티션 테이블 버전, 파티션 수, 파티션 테이블 크기와 같은 GPT 파티션 테이블의 기본 정보를 저장), 그리고 파티션 항목 배열(각 파티션 항목은 파티션의 시작 섹터, 종료 섹터, 파티션 유형 GUID, 파티션 고유 식별자와 같은 중요한 정보를 상세히 기록)을 포함합니다. 이러한 구조들은 서로 협력하여 하드 디스크 공간을 정확하게 계획하고 관리합니다.&lt;/p&gt;
&lt;h2 id=&#34;네-알겠습니다-윈도우-운영체제--사용자의-디지털-상호작용-세상&#34;&gt;네, 알겠습니다. 윈도우 운영체제 — 사용자의 “디지털 상호작용 세상”
&lt;/h2&gt;&lt;p&gt;윈도우는 전 세계적으로 널리 사용되는 운영체제로, 사람과 컴퓨터 하드웨어 간의 친근한 다리를 놓습니다&lt;/p&gt;
&lt;h3 id=&#34;esp-파티션과-gpt-파티션-테이블의-통합&#34;&gt;ESP 파티션과 GPT 파티션 테이블의 통합
&lt;/h3&gt;&lt;p&gt;UEFI 기반 Windows 시스템 설치 과정에서, 설치 프로그램은 자동으로 ESP 파티션을 생성하고 부트 파일을 배포합니다. 동시에 디스크는 GPT 파티션 테이블 형식으로 초기화되며, 시스템 예약 파티션(시스템 핵심 파일 저장 공간, 기존 BIOS 환경의 시스템 부트 파일 영역과 유사), Windows 시스템 파티션(시스템 핵심 파일이 설치되는 곳) 및 기타 사용자 정의 데이터 파티션 등이 구성됩니다. Windows 시스템은 GPT 파티션 테이블을 통해 각 파티션을 정확하게 식별하고 ESP 파티션을 통해 원활하게 부팅되며, 이 세 가지 요소는 매끄럽게 연결되어 사용자에게 쾌적한 부팅 및 사용 경험을 제공합니다.&lt;/p&gt;
&lt;h3 id=&#34;시스템-관리-및-최적화-기반&#34;&gt;시스템 관리 및 최적화 기반
&lt;/h3&gt;&lt;p&gt;Windows는 실행되는 동안 GPT 파티션 테이블의 장점을 최대한 활용하여 디스크 관리를 수행합니다. 예를 들어, 디스크 관리 도구에서 GPT 파티션을 쉽게 식별하고 사용자가 파티션을 생성, 삭제, 포맷하거나 파티션 크기를 조정하는 등 다양한 단계의 데이터 저장 요구 사항을 충족할 수 있습니다. 또한 시스템 업데이트, 소프트웨어 설치 등의 과정도 파티션 레이아웃과 밀접하게 관련되어 있으며, 합리적인 파티션 계획은 시스템 성능 및 안정성을 향상시키고 디스크 공간 부족이나 파티션 혼란으로 인해 발생하는 문제를 줄이는 데 도움이 됩니다.&lt;/p&gt;
&lt;h2 id=&#34;다섯째-실전-팁-유지-보수-및-문제-해결&#34;&gt;다섯째, 실전 팁: 유지 보수 및 문제 해결
&lt;/h2&gt;&lt;p&gt;이들의 밀접한 관계를 이해하면 일상적인 유지 보수와 문제 해결에 대한 절차가 생깁니다&lt;/p&gt;
&lt;h3 id=&#34;디스크-공간-관리&#34;&gt;디스크 공간 관리
&lt;/h3&gt;&lt;p&gt;ESP 파티션 공간을 정기적으로 확인하여 과도한 부팅 항목 관련 소프트웨어 설치로 인한 공간 부족으로 시스템 시작에 영향을 미치는 것을 방지합니다. GPT 파티션 하의 데이터 파티션에서는 합리적인 저장 공간 계획을 세우고, 불필요한 파일을 즉시 정리하여 단일 파티션이 가득 차서 시스템 운영에 영향을 미치지 않도록 합니다.&lt;/p&gt;
&lt;h3 id=&#34;문제-해결-시작&#34;&gt;문제 해결 시작
&lt;/h3&gt;&lt;p&gt;시스템 부팅에 실패한 경우, 먼저 ESP 파티션이 손상되었거나 파일이 누락되었는지 확인하십시오. UEFI 펌웨어에 내장된 부트 항목 복구 도구를 사용하거나 Windows 설치 미디어를 통해 복구 환경에 진입하여 ESP 파티션의 부트 파일을 재구성할 수 있습니다. GPT 파티션 테이블 오류가 의심되는 경우, 전문 디스크 도구(DiskGenius 등)를 사용하여 파티션 테이블 무결성을 확인하고 백업된 파티션 정보를 활용하여 파티션을 복구하십시오.&lt;/p&gt;
&lt;p&gt;ESP 파티션, GPT 파티션 테이블, 그리고 Windows 운영체제는 마치 정밀하게 협력하는 팀과 같이 각자의 전문성을 발휘하여 안정적이고 효율적인 컴퓨터 사용 환경을 구축합니다. 이들을 깊이 이해하면 시스템 설치 및 유지 보수 시 능숙하게 대처할 수 있을 뿐만 아니라 컴퓨터의 하위 실행 로직을 파악하고 디지털 세계를 자유롭게 탐험할 수 있습니다. 동시에 MBR 파티션 테이블의 흥망성쇠를 되돌아보면 기술 발전의 힘에 감탄하며, 이는 저장 기술이 끊임없이 전진하여 증가하는 데이터 저장 요구를 충족하도록 이끌고 있음을 깨닫게 됩니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>GCC, GLIBC 및 C&#43;&#43; 프로그램 호환성 문제 심층 이해</title>
        <link>https://ttf248.life/ko/p/deep-understanding-gcc-glibc-cpp-compatibility-issues/</link>
        <pubDate>Mon, 06 Jan 2025 19:51:16 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/deep-understanding-gcc-glibc-cpp-compatibility-issues/</guid>
        <description>&lt;p&gt;C++ 개발 분야에서 GCC와 GLIBC는 피할 수 없는 핵심 요소이며, 프로그램 출시 후 호환성 문제는 개발자를 끊임없이 괴롭힌다. 본 논문에서는 이들의 본질을 심층적으로 분석하고, 호환성 문제의 근원과 대응 전략을 탐구한다.&lt;/p&gt;
&lt;h2 id=&#34;하나-gcc-강력한-컴파일러-기반&#34;&gt;하나, GCC: 강력한 컴파일러 기반
&lt;/h2&gt;&lt;p&gt;정의와 기능&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC는 GNU 컴파일러 컬렉션의 약자로, GNU 프로젝트에서 개발한 오픈 소스 컴파일러 모음입니다. 이는 일반적인 컴파일러가 아니며, C, C++, Objective-C, Fortran, Ada 및 Go와 같은 다양한 주류 언어를 지원하여 크로스 플랫폼 개발을 위한 원스톱 솔루션을 제공합니다.&lt;/li&gt;
&lt;li&gt;C++를 예로 들어보면, 클래스, 템플릿, 함수 오버로딩과 같은 복잡한 특징을 포함하는 소스 파일을 작성할 때 GCC는 C++의 엄격한 문법 및 의미 규칙에 따라 고급 C++ 코드를 하위 레벨 기계가 이해하고 실행할 수 있는 명령어 시퀀스로 변환합니다. 이 과정은 어휘 분석, 구문 분석, 의미 분석, 최적화 및 코드 생성과 같은 여러 가지 정교한 단계를 포함합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;컴파일 과정 상세 설명&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;전처리 단계&lt;/strong&gt;: GCC는 먼저 소스 파일을 전처리합니다. 이 과정에서 &lt;code&gt;#&lt;/code&gt;로 시작하는 모든 전처리 지시를 처리합니다. 예를 들어, &lt;code&gt;#include&lt;/code&gt; 지시는 지정된 헤더 파일(C++ 입출력 스트림 작업에 사용되는 &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt;과 같이)의 전체 내용을 소스 파일의 해당 위치에 삽입하여 프로그램이 헤더 파일에 선언된 함수, 클래스와 같은 리소스를 사용할 수 있도록 합니다. &lt;code&gt;#define&lt;/code&gt; 지시로 정의된 매크로는 이 단계에서 펼쳐서 대체됩니다. 예를 들어, &lt;code&gt;#define PI 3.14159&lt;/code&gt;인 경우 소스 파일의 모든 &lt;code&gt;PI&lt;/code&gt;가 &lt;code&gt;3.14159&lt;/code&gt;로 바뀝니다. 전처리가 완료되면 소스 파일은 초기 “확장”을 거칩니다.&lt;/li&gt;
&lt;li&gt;컴파일 단계: 전처리된 파일은 컴파일 과정으로 들어가고, GCC는 C++ 언어 표준에 따라 소스 파일을 어셈블리 언어 코드로 변환합니다. 이 과정에서 코드 구조를 꼼꼼히 검사하여 클래스 상속, 다형성 구현의 정확성, 함수 호출 인자 일치 여부 등을 확인하며, 문법 및 의미 규칙에 위배되는 오류가 발견되면 즉시 에러를 발생시키고 컴파일 과정을 중단합니다. 예를 들어, 함수 선언과 정의된 인자 목록이 불일치하는 경우, GCC는 문제 지점을 정확하게 지적합니다.&lt;/li&gt;
&lt;li&gt;어셈블리 단계: 어셈블러는 이전 단계에서 생성된 어셈블리 코드를 기계어로 변환하여 &lt;code&gt;.o&lt;/code&gt; 확장자를 가진 목적 파일을 생성합니다. 이러한 목적 파일에는 기기가 직접 실행할 수 있는 이진 명령어가 포함되어 있지만, 일반적으로 완전한 프로그램은 여러 모듈로 구성되고 각 모듈 간의 함수 및 변수 참조 관계가 해결되지 않았기 때문에 독립적으로 실행될 수 없습니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;링크 단계&lt;/strong&gt;: 이는 실행 파일을 생성하는 마지막 스퍼트 단계입니다. 링커는 여러 목표 파일과 필요한 라이브러리 파일(정적 라이브러리 또는 동적 라이브러리)을 통합합니다. 예를 들어, C++ 표준 템플릿 라이브러리의 컨테이너 클래스를 사용할 때 링크 시에는 해당 라이브러리 구현 코드를 찾아야 하며, 프로그램 실행 시 &lt;code&gt;vector&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt; 등의 컨테이너 기능을 올바르게 호출할 수 있도록 보장하여 최종적으로 완전한 실행 파일을 생성합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;두-번째-glibc-c-프로그램-실행의-숨겨진-기반&#34;&gt;두 번째, GLIBC: C++ 프로그램 실행의 숨겨진 기반
&lt;/h2&gt;&lt;p&gt;본질과 작용&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GLIBC는 GNU C Library이며, GNU 생태계에서 C 표준 라이브러리의 구체적인 구현입니다. 이름에서 C가 강조되어 있지만, C++ 프로그램 역시 C의 기본 부분을 상속받기 때문에 GLIBC에 크게 의존합니다. 메모리 관리를 위한 &lt;code&gt;malloc&lt;/code&gt;(동적 메모리 할당), &lt;code&gt;free&lt;/code&gt;(메모리 해제) 함수와 같이 방대한 기본 함수를 제공하는데, 이는 C++에서 동적 배열이나 객체를 생성할 때 필수적입니다. 또한 &lt;code&gt;strcpy&lt;/code&gt;(문자열 복사), &lt;code&gt;strcat&lt;/code&gt;(문자열 연결)과 같은 문자열 처리 함수는 C++에 더 고급의 &lt;code&gt;string&lt;/code&gt; 클래스가 있더라도 하위 코드와의 상호 작용이나 최고의 성능을 추구할 때 여전히 사용됩니다. 뿐만 아니라 &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;와 같은 표준 입력/출력 함수 역시 C++ 초기 개발 단계나 성능에 민감하고 간결함을 추구하는 상황에서 자주 등장합니다.
운영 체제와의 협력&lt;/li&gt;
&lt;li&gt;GLIBC는 운영체제와 애플리케이션 간의 중요한 연결고리 역할을 합니다. Linux 시스템에서 C++ 프로그램이 파일을 열기 위해 &lt;code&gt;open&lt;/code&gt; 함수를 사용하는 등 시스템 호출을 시작하면 GLIBC는 프로그램의 요청을 운영체제 커널이 규정한 방식으로 캡슐화하여 커널에 전달하고, 커널 처리 완료 후 결과를 애플리케이션으로 다시 반환합니다. 이를 통해 애플리케이션은 파일 시스템, 네트워크, 프로세스 관리와 같은 다양한 시스템 리소스를 복잡한 운영체제 하위 수준의 시스템 호출 인터페이스 세부 사항을 깊이 이해하지 않고도 편리하게 사용할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;세-번째-c-프로그램-배포-후-호환성-문제-분석&#34;&gt;세 번째, C++ 프로그램 배포 후 호환성 문제 분석
&lt;/h2&gt;&lt;p&gt;GLIBC 버전 차이로 인한 호환성 문제&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다양한 Linux 배포판은 종종 서로 다른 버전의 GLIBC를 탑재하고 있습니다. C++ 프로그램이 높은 버전의 GLIBC 환경에서 컴파일되면, 의식하지 못 사이에 해당 버전에서 새롭게 추가된 특정 함수 기능이나 최적화된 함수 구현에 의존하게 될 수 있습니다. 예를 들어, 새로운 GLIBC 버전은 메모리 할당 알고리즘을 개선했으며, 프로그램은 런타임 시 이러한 새로운 알고리즘을 빈번히 활용하여 성능을 향상시킵니다. 만약 이 프로그램을 낮은 버전의 GLIBC 시스템에서 실행한다면, 해당 함수를 찾을 수 없거나 (해당 기능이 낮은 버전에 도입되지 않았기 때문입니다) 함수의 동작에 이상이 생길 수 있습니다 (오래된 함수 구현 로직과 새로운 버전 간의 차이로 인해). 이는 프로그램 충돌이나 결과 오류로 이어질 수 있습니다.
컴파일러 차이로 인한 호환성 문제&lt;/li&gt;
&lt;li&gt;비록 모두 GCC 컴파일러를 사용하더라도, 다른 버전의 GCC는 코드 생성, 표준 라이브러리 지원 및 C++ 기능 구현 방식에 차이가 있습니다. 최신 버전의 GCC는 C++ 최신 표준(예: C++20의 모듈, 코루틴 등)을 완벽하게 지원할 수 있지만, 이러한 최첨단 기능을 사용하는 프로그램이 구버전 GCC에서 컴파일하면 컴파일러가 새로운 문법 구조를 인식하지 못해 오류를 발생시킵니다. 심지어 문법 오류가 없더라도, 다른 GCC 버전 간의 최적화 전략이 다르기 때문에 생성된 기계 코드의 실행 효율성 및 메모리 사용량에 큰 차이가 있을 수 있으며, 성능이 중요한 환경에서는 프로그램의 동작 방식이 크게 달라질 수 있습니다.
시스템 아키텍처 차이로 인한 과제&lt;/li&gt;
&lt;li&gt;C++ 프로그램은 x86, ARM, PowerPC 등 다양한 하드웨어 시스템 아키텍처에서 실행될 수 있습니다. 각 아키텍처는 고유한 명령어 집합, 메모리 레이아웃 및 데이터 정렬 요구 사항을 가지고 있습니다. 예를 들어 데이터 정렬의 경우, x86 아키텍처에서 정상적으로 작동하는 구조체 데이터 저장 방식이 ARM 아키텍처에서는 정렬 규칙이 다르기 때문에 메모리 접근 이상을 일으켜 프로그램 오류를 유발할 수 있습니다. 또한 GCC는 서로 다른 아키텍처에 대해 컴파일할 때 생성되는 기계 코드의 차이가 매우 크며, 프로그램 내에 하드 코딩된 아키텍처 관련 명령어 또는 가정이 있는 경우, 여러 아키텍처에서 실행 시 빈번한 오류가 발생합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;네-가지-대응-호환성-문제-전략&#34;&gt;네 가지 대응 호환성 문제 전략
&lt;/h2&gt;&lt;p&gt;정적 링크 라이브러리의 활용&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;정적 링크 라이브러리 사용을 고려해 볼 수 있는데, 이는 프로그램이 의존하는 GLIBC와 같은 라이브러리 코드를 실행 파일에 직접 패키징하는 방식입니다. 이렇게 하면 프로그램은 런타임 시 대상 시스템의 특정 GLIBC 버전에 더 이상 의존하지 않으므로 GLIBC 버전 불일치로 인해 발생하는 문제를 효과적으로 피할 수 있습니다. 하지만 정적 링크는 실행 파일 크기를 크게 증가시키므로 저장 공간이 제한된 환경에서는 장단점을 신중하게 고려해야 합니다.
컨테이너화 배포&lt;/li&gt;
&lt;li&gt;Docker와 같은 컨테이너화 기술을 활용하여 C++ 프로그램과 필요한 실행 환경(특정 버전의 GCC, GLIBC 등)을 하나의 독립적인 컨테이너로 묶습니다. 어떤 기본 운영체제로 배포하든 컨테이너 내부에서는 항상 프로그램 개발 시의 환경 일관성을 유지하여 프로그램이 예상대로 작동하도록 하고, 다양한 환경에 대한 배포 복잡성을 크게 줄입니다.
호환성 테스트 및 지속적 통합&lt;/li&gt;
&lt;li&gt;다양한 GLIBC 버전, GCC 버전 및 일반적인 시스템 아키텍처를 포괄하는 종합적인 호환성 테스트 체계를 구축한다. 프로그램 개발 과정에서 지속적 통합 도구를 사용하여 다양한 환경에서 정기적으로 자동화된 테스트를 수행하고, 호환성 문제가 발견되면 즉시 수정하여 잠재적인 위험을 초기 단계에서 제거함으로써 프로그램 출시 후의 안정성을 확보한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;결론적으로, GCC와 GLIBC의 작동 방식을 깊이 이해하고, C++ 프로그램 호환성 문제의 근원을 정확하게 파악하며, 유연하게 대응 전략을 활용하는 것은 모든 C++ 개발자가 안정적이고 크로스 플랫폼 애플리케이션을 구축하기 위한 필수적인 기술입니다. 그래야만 우리의 C++ 작품은 다양한 기술 생태계에서 자유롭게 이동할 수 있습니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>Windows에 내장된 디스크 정리 도구: 저장 공간</title>
        <link>https://ttf248.life/ko/p/windows-disk-cleanup-storage/</link>
        <pubDate>Mon, 06 Jan 2025 19:29:45 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/windows-disk-cleanup-storage/</guid>
        <description>&lt;p&gt;어떤 버전부터인지는 정확히 기억나지 않지만, &lt;code&gt;Windows 11&lt;/code&gt;에서 디스크 정리 도구가 크게 개선되어 훨씬 더 스마트해졌습니다&lt;/p&gt;
&lt;p&gt;중요한 것은 공식 도구라는 점이며, 파일 삭제 오류가 없고, 광고도 없고, 팝업창도 없고, 백그라운드 프로세스도 없으며, 불필요한 기능이 전혀 없습니다&lt;/p&gt;
&lt;p&gt;Windows 11에서 설정-시스템-저장 공간-임시 파일로 이동하여 디스크 정리 도구를 열 수 있습니다&lt;/p&gt;
&lt;p&gt;저장 인터페이스&lt;/p&gt;
&lt;p&gt;일반 사용자는 &lt;code&gt;청소 제안&lt;/code&gt;을 선택하면 시스템에서 사용 상황에 따라 몇 가지 제안을 제공합니다&lt;/p&gt;
&lt;p&gt;개발자로서 저의 디스크에는 임시 파일이 많기 때문에 &lt;code&gt;임시 파일&lt;/code&gt;을 선택했습니다. 그 안에는 &lt;code&gt;Visual Studio&lt;/code&gt; 임시 파일, &lt;code&gt;Windows Update&lt;/code&gt; 임시 파일 등 다양한 임시 파일들이 포함되어 있습니다.&lt;/p&gt;
&lt;p&gt;임시 파일&lt;/p&gt;</description>
        </item>
        <item>
        <title>도커 국내 이미지 프록시 만료</title>
        <link>https://ttf248.life/ko/p/docker-domestic-mirror-failure/</link>
        <pubDate>Sat, 04 Jan 2025 18:29:25 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/docker-domestic-mirror-failure/</guid>
        <description>&lt;p&gt;국내 서버에 도커를 배포하고, 배포 후 회사에서 이미지 센터를 제공하지 않는 경우, 개발자가 먼저 해야 할 일은 국내 이미지 가속 주소를 설정하는 것입니다. 그런데 오늘 우연히 서버 한 대가 있고, 이미지 가속 주소를 설정했는데 이미지를 가져오려고 하면 계속 가져오지 못합니다.&lt;/p&gt;
&lt;p&gt;데몬 오류: &lt;code&gt;https://registry-1.docker.io/v2/&lt;/code&gt;에서 헤더를 기다리는 동안 연결을 기다리던 중 요청이 취소되었습니다(Client.Timeout 초과)&lt;/p&gt;
&lt;p&gt;두 날이 지났지만 모든 서버가 복구되었고, 이 일이 검색어 순위에 오르지 않고, 국내 모든 미러 대리들이 멈췄다&lt;/p&gt;
&lt;h2 id=&#34;오류-해결-및-복구-시도&#34;&gt;오류 해결 및 복구 시도
&lt;/h2&gt;&lt;p&gt;처음에 다른 미러 이미지 주소로 전환을 시도하여 문제를 해결하고자 했지만, 기대와 달리 문제는 여전히 발생했습니다&lt;/p&gt;
&lt;p&gt;곧바로, 로컬 DNS 설정을 수정하기 시작하여 네트워크 해상도 수준에서 돌파구를 찾으려 했지만, 안타깝게도 여러 번의 디버깅 끝에 문제점은 여전히 남아 있었다&lt;/p&gt;
&lt;p&gt;현재, 로컬 네트워크의 안정성이 크게 의심받고 있어 즉시 휴대폰 핫스팟으로 전환하여 가능한 로컬 네트워크 문제점을 우회하려 했지만 결과는 낙담스러웠고, 문제는 전혀 개선될 기미가 보이지 않습니다&lt;/p&gt;
&lt;h2 id=&#34;문제-확산&#34;&gt;문제 확산
&lt;/h2&gt;&lt;p&gt;현재 &lt;strong&gt;국내에 배치된 몇 대의 서버&lt;/strong&gt;가 있으며, 모두 Docker 환경이 설치되어 있습니다. 이러한 서버에서 이미지를 가져오려고 시도했었는데, 다른 방법을 찾을 수 있을 것이라고 생각했지만 결과적으로는 단 한 건도 성공하지 못했고, 보고되는 오류 메시지가 모두 동일했습니다. 이는 문제가 특정 장비에 국한된 것이 아니라는 것을 의미합니다.&lt;/p&gt;
&lt;p&gt;더 자세히 조사해 보니 미러 에이전트가 갑자기 작동하지 않음을 확인했습니다. 이 긴급한 순간에 해외 머신으로 빠르게 전환하여 시도했고, 다행히 이미지 풀링은 여기서 정상적으로 복구되었습니다. 이는 문제의 원인이 국내 네트워크 링크나 관련 설정에 있을 가능성이 높다는 것을 의미합니다.&lt;/p&gt;
&lt;h2 id=&#34;전략-조정-우회-해결&#34;&gt;전략 조정: 우회 해결
&lt;/h2&gt;&lt;p&gt;국내에서 직접 이미지를 가져오는 경로가 여러 차례 막히고 해외 이미지는 정상적으로 접근할 수 있다는 점을 고려하여, 프로젝트를 최대한 빠르게 진행하기 위해 우회적인 전술을 채택합니다. 먼저 해외 서버로 전환하여 필요한 이미지를 성공적으로 가져온 후, 이를 국내 이미지 저장소에 푸시하여 “데이터 다리”를 구축합니다.&lt;/p&gt;
&lt;p&gt;동시에 Dockerfile 파일도 수정하여 이미지 주소를 국내 환경에 적합한 주소로 변경하고, 다시 이미지를 빌드하여 최종적으로 성공적으로 배포했습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>CentOS 8 Stream EOL</title>
        <link>https://ttf248.life/ko/p/centos-8-stream-eol/</link>
        <pubDate>Sat, 16 Nov 2024 23:24:50 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/centos-8-stream-eol/</guid>
        <description>&lt;p&gt;CentOS Stream은 레드햇 엔터프라이즈 Linux 배포 전의 상위 소스 코드 개발 플랫폼입니다
최초로 오픈소스 운영체제 라이프사이클 [레드햇 및 CentOS 라이프사이클]({&amp;lt; relref &amp;ldquo;/post/2020/07-redhat and centos life cycle&amp;rdquo; &amp;gt;}})에 주목하게 되었음&lt;/p&gt;
&lt;p&gt;만료되었는데, 문제가 있나요? 보안 문제 외에도 dnf를 사용할 수 없게 되었고, 최근에 도구 설치 시 dnf가 실패하는 것을 발견했습니다. 이미지 소스를 확인해 보니 &lt;code&gt;CentOS 8 Stream&lt;/code&gt;이 만료되었습니다.&lt;/p&gt;
&lt;h2 id=&#34;centos-스트림-소개&#34;&gt;CentOS 스트림 소개
&lt;/h2&gt;&lt;h3 id=&#34;위치와-역할&#34;&gt;위치와 역할
&lt;/h3&gt;&lt;p&gt;CentOS 스트림은 Fedora Linux(상위 개발)과 RHEL(Red Hat Enterprise Linux, 하위 개발) 사이에 위치하여 다리 역할을 합니다&lt;/p&gt;
&lt;p&gt;최신 Red Hat Linux 기능들을 경험하기 위한 버전으로, 새로운 기능을 시험해 보고 싶어하는 사용자에게 적합합니다&lt;/p&gt;
&lt;h3 id=&#34;탄생과-배경&#34;&gt;탄생과 배경
&lt;/h3&gt;&lt;p&gt;시간이 지나면서, Red Hat 사는 기업용 Linux 플랫폼을 발전시키는 보다 효과적인 방법을 모색하기 시작했고, CentOS Stream 을 출시했습니다&lt;/p&gt;
&lt;p&gt;CentOS 8은 2021년 말 지원이 종료된 후, CentOS Stream이 그 계승자로서 계속 업데이트되고 있으며, CentOS 프로젝트의 미래 발전 방향이 되었습니다&lt;/p&gt;
&lt;h3 id=&#34;특징-및-장점&#34;&gt;특징 및 장점
&lt;/h3&gt;&lt;p&gt;CentOS 스트림은 지속적으로 업데이트되는 Linux 배포판으로, 더 빠른 업데이트를 제공합니다. 커뮤니티, 파트너 및 고객의 참여를 위한 투명성과 기회를 높여 사용자에게 Red Hat Enterprise Linux에 더 빠르고 직접적인 방식으로 기여할 수 있도록 합니다.&lt;/p&gt;
&lt;p&gt;CentOS 스트림의 내용은 Red Hat이 다음 안정 버전 RHEL에 의도적으로 포함할 소프트웨어이기 때문에 커뮤니티 구성원에게 개발 및 테스트를 위한 안정적인 ABI/API를 제공합니다&lt;/p&gt;
&lt;h3 id=&#34;사용-시나리오-및-대상-사용자&#34;&gt;사용 시나리오 및 대상 사용자
&lt;/h3&gt;&lt;p&gt;CentOS Stream은 최신 Linux 기능 업데이트를 계속 받고자 하는 CentOS 사용자, 그리고 Red Hat Enterprise Linux 개발에 참여하고자 하는 개발자와 파트너에게 적합합니다&lt;/p&gt;
&lt;p&gt;커뮤니티 구성원, Red Hat 파트너 및 다른 사람들이 보다 안정적이고 예측 가능한 Linux 환경에서 혁신적인 오픈 소스 프로그램을 최대한 활용할 수 있도록 돕는 것을 목표로 합니다&lt;/p&gt;
&lt;h2 id=&#34;만료일&#34;&gt;만료일
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Release&lt;/th&gt;
&lt;th&gt;Released&lt;/th&gt;
&lt;th&gt;Active Support&lt;/th&gt;
&lt;th&gt;Security Support&lt;/th&gt;
&lt;th&gt;Latest&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;3 years ago (15 Sep 2021)&lt;/td&gt;
&lt;td&gt;Ends in 2 years and 6 months (31 May 2027)&lt;/td&gt;
&lt;td&gt;Ends in 2 years and 6 months (31 May 2027)&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;5 years ago (24 Sep 2019)&lt;/td&gt;
&lt;td&gt;Ended 5 months and 3 weeks ago (31 May 2024)&lt;/td&gt;
&lt;td&gt;Ended 5 months and 3 weeks ago (31 May 2024)&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;해결책&#34;&gt;해결책
&lt;/h2&gt;&lt;p&gt;업그레이드 문제로 번거로운 일은 피하기 위해 &lt;code&gt;Ubuntu 24.04&lt;/code&gt; 장기 지원 버전을 선택했습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>Hugo 모듈 커스터마이징 테마 수정 방법: 아이디어 설명</title>
        <link>https://ttf248.life/ko/p/hugo-module-custom-theme-ideas/</link>
        <pubDate>Fri, 15 Nov 2024 22:01:17 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/hugo-module-custom-theme-ideas/</guid>
        <description>&lt;p&gt;과거 커밋 기록을 살펴보니, 사이트는 여러 번 테마를 변경해 왔습니다. 매번 테마를 변경할 때마다 몇 가지 사용자 정의 수정 사항이 있었고, 여기 그 수정 아이디어를 기록합니다. 제 &lt;code&gt;Github&lt;/code&gt;에도 저장소가 있는데, even 테마를 잠시 유지 관리하다가 강박증 때문에 최신 버전의 &lt;code&gt;hugo&lt;/code&gt; 컴파일러로 업그레이드하고 싶었지만, even 테마와 호환되지 않아 다시 &lt;code&gt;stack&lt;/code&gt; 테마로 전환했습니다.&lt;/p&gt;
&lt;h2 id=&#34;휴고의-모듈화&#34;&gt;휴고의 모듈화
&lt;/h2&gt;&lt;p&gt;모듈화를 언급하면 Nginx 모듈이나 IDEA 플러그인 등이 떠오르는 경우가 많습니다. 보통은 몇몇 모듈을 업로드하여 차별화된 요구사항을 충족할 수 있습니다. 모두가 이러한 모듈을 선호하는 주된 이유는 충분히 유연하기 때문이며, 큰 노력을 들이지 않고도 자체적인 요구사항을 충족할 수 있기 때문입니다. 많은 경우 전체적으로는 비슷하더라도 세부적인 차이가 존재합니다. 이는 기술적 복잡성 외에도 비즈니스 복잡성을 보여주는 것이기도 합니다. 대부분의 경우 우리는 비즈니스 복잡성에 직면하게 됩니다. 이것이 소프트웨어 분야에서 “동업자 간에도 산과 같다는” 속담을 가장 잘 설명하는 것입니다. 요즘은 인터넷 업계뿐만 아니라 금융 업계, 심지어 전통적인 제조업에 이르기까지 정보화 시스템을 활용하여 기업의 생산 및 관리를 돕고 있습니다. 마찬가지로 휴가 신청 시스템이라도 같은 산업 분야라도 서로 다른 회사마다 차이가 있을 수 있습니다.&lt;/p&gt;
&lt;p&gt;그리고 &lt;code&gt;Hugo&lt;/code&gt;의 모듈은 사람들의 일반적인 인식과는 조금 다르게, 기능별로 차별화된 요구를 충족하기 위한 것이 아니라 디렉토리 구조를 중심으로 동일한 구조를 식별합니다&lt;/p&gt;
&lt;p&gt;자료 링크: &lt;a class=&#34;link&#34; href=&#34;https://medium.com/@sunwei.xyz/07-hugo%E6%9E%B6%E6%9E%84-hugo%E7%9A%84%E6%A8%A1%E5%9D%97-8ef5a520a822&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;07. Hugo 아키텍처 — Hugo의 모듈&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[[imports]]
path = &amp;quot;github.com/CaiJimmy/hugo-theme-stack/v3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;git 서브모듈 방식은 여전히 사용할 수 있지만, 본문에서는 권장하지 않습니다. 테마가 업데이트되면 유지 관리가 복잡해지며, 테마를 별도의 git 저장소로 관리해야 합니다.&lt;/p&gt;
&lt;h2 id=&#34;주제의-수정-로직&#34;&gt;주제의 수정 로직
&lt;/h2&gt;&lt;p&gt;앞선 모듈화의 기본 개념을 이해했으면, 사용자 정의 테마를 이해하는 것은 훨씬 쉬워졌습니다. &lt;code&gt;hugo&lt;/code&gt;의 현재 테마도 여러 개의 다른 모듈로 조립된 것이며, 우리는 원하는 모듈을 찾아 해당 템플릿 파일을 수정하면 됩니다.&lt;/p&gt;
&lt;p&gt;스택 공식 문서에서 발췌:&lt;/p&gt;
&lt;p&gt;Using this method, there won&amp;rsquo;t be any file under &lt;code&gt;themes&lt;/code&gt; directory. In order to modify the theme, you will have to copy the file you want to modify to the same directory under &lt;code&gt;layouts&lt;/code&gt; directory.&lt;/p&gt;
&lt;p&gt;For example, in order to modify the &lt;code&gt;themes/hugo-theme-stack/layouts/partials/head/custom.html&lt;/code&gt; file, you will have to copy it to &lt;code&gt;layouts/partials/head/custom.html&lt;/code&gt; and modify it there (copy the code from theme&amp;rsquo;s repository). The same applies to &lt;code&gt;assets&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt; directories。&lt;/p&gt;
&lt;h2 id=&#34;템플릿-파일을-어떻게-찾을-수-있나요&#34;&gt;템플릿 파일을 어떻게 찾을 수 있나요?
&lt;/h2&gt;&lt;h3 id=&#34;정통적-사고방식&#34;&gt;정통적 사고방식
&lt;/h3&gt;&lt;p&gt;테마의 소스 파일을 살펴보면서 디자인 아이디를 이해하고, 해당 템플릿 파일을 찾아 수정하면 됩니다&lt;/p&gt;
&lt;h3 id=&#34;거친-사고방식&#34;&gt;거친 사고방식
&lt;/h3&gt;&lt;p&gt;저는 프론트엔드 코드를 잘 모르는 편이라 때로는 직접적인 방법을 사용합니다. 예를 들어 브라우저에서 해당 페이지를 열고, 수정하고 싶은 부분을 찾아 &lt;code&gt;요소 검사&lt;/code&gt; 기능을 통해 &lt;code&gt;CSS 이름&lt;/code&gt;을 찾은 다음, 테마 소스 코드에서 검색하여 해당하는 파일을 찾아서 복사한 후 사이트 디렉토리에 붙여넣고 수정하는 방식입니다.&lt;/p&gt;
&lt;h2 id=&#34;소-팁&#34;&gt;소 팁
&lt;/h2&gt;&lt;p&gt;공식적으로 기본 제공되는 파일로 스타일을 커스터마이징할 수 있으며, 수정해야 할 부분을 여러 파일로 분리하고 &lt;code&gt;custom.scss&lt;/code&gt; 파일에서 다른 파일을 불러와서 사용하면 스타일 파일을 더 효과적으로 관리할 수 있습니다&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/hugo-module-custom-theme-ideas/image.png&#34;
	width=&#34;141&#34;
	height=&#34;375&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;37&#34;
		data-flex-basis=&#34;90px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;수정-내용-요약6시간&#34;&gt;수정 내용 요약(6시간)
&lt;/h2&gt;&lt;p&gt;이제는 AI 코딩의 원년이라고 할 수 있으며, 자세한 내용은 여기서는 생략하고 간단히 나열하자면, 본 사이트의 수정 내용 몇 가지 예를 들어 복사 버튼 스타일 조정, 코드 블록 스타일 재설정 등이 있는데, ChatGPT로도 쉽게 처리할 수 있습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;전체: 전체 글꼴 스타일은 이전 &lt;code&gt;even&lt;/code&gt;과 &lt;code&gt;info cn&lt;/code&gt;을 결합한 표시 스타일을 유지하며, 중국어 사용자를 위한 친화적인 디자인입니다&lt;/li&gt;
&lt;li&gt;홈페이지: 오른쪽 네비게이션에 마우스 상호작용 애니메이션 추가&lt;/li&gt;
&lt;li&gt;처음 페이지: 기사 요약 미리 보기 (시간이 많이 소요되므로, 편리한 방법을 사용했습니다.)&lt;/li&gt;
&lt;li&gt;스크롤바: 스크롤바 스타일을 다듬었습니다&lt;/li&gt;
&lt;li&gt;코드 블록에 &lt;code&gt;highlight.js&lt;/code&gt; 코드 하이라이트 플러그인이 도입되어 코드 블록 스타일이 개선되었습니다&lt;/li&gt;
&lt;li&gt;내용 상세: 일부 내용은 재게시되었으며, 원저자 정보 표시 및 원본 링크 표시가 추가되었습니다&lt;/li&gt;
&lt;li&gt;아카이브 페이지: 상단의 카테고리 이미지, 테마 자체 색상 오버레이 제거, 원본 이미지 표시&lt;/li&gt;
&lt;li&gt;파일 페이지: 연도별 분류 통계 표시 패널이 추가되었습니다&lt;/li&gt;
&lt;li&gt;아카이브 페이지: 두 열 레이아웃 표시&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;스택 테마의 컴포넌트 재사용성이 매우 높아, 홈페이지에 새 글 요약 미리 보기 기능을 추가하는 데 상당한 시간이 소요되었습니다. 관련 컴포넌트를 수정했더니, 게시글 상세 페이지에서도 내용이 중복되어 표시되는 문제가 발생했습니다. &lt;code&gt;golang 템플릿&lt;/code&gt; 문법에도 익숙하지 않아 더 많은 시간을 소비했고, 컴포넌트 간의 파라미터 전달은 끝내 해결하지 못했습니다. 결국, 트릭을 사용하여 홈페이지에 별도의 &lt;code&gt;JavaScript&lt;/code&gt; 스크립트를 도입하고, 사용자 정의 특수 변수를 통해 요약 미리 보기 기능을 구현했습니다.&lt;/p&gt;
&lt;p&gt;때로는 코드 재사용률이 너무 높아서 문제가 될 수도 있는데, 한 부분을 수정하면 다른 부분에도 영향을 미치기 때문에 테마를 수정할 때는 기존 로직을 훼손하지 않도록 주의해야 합니다&lt;/p&gt;
&lt;h3 id=&#34;댓글-영역&#34;&gt;댓글 영역
&lt;/h3&gt;&lt;p&gt;이 친구의 수정은 더욱 완벽해졌습니다: &lt;a class=&#34;link&#34; href=&#34;https://blog.reincarnatey.net/2024/0719-better-waline/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.reincarnatey.net/2024/0719-better-waline/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이 사이트는 간단하게 &lt;code&gt;Waline&lt;/code&gt; 댓글 시스템을 적용했으며, &lt;code&gt;stack&lt;/code&gt; 테마는 기본적으로 &lt;code&gt;Waline&lt;/code&gt;을 지원하므로 &lt;code&gt;config.toml&lt;/code&gt;에서 설정하면 됩니다&lt;/p&gt;
&lt;p&gt;추천 홈페이지, 이메일 연락처. 본 사이트는 댓글 기능을 제공하지 않습니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>리눅스 백엔드 서비스 문자열 데이터 처리 - 속도가 느림</title>
        <link>https://ttf248.life/ko/p/linux-backend-slow-string-processing/</link>
        <pubDate>Wed, 13 Nov 2024 19:42:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/linux-backend-slow-string-processing/</guid>
        <description>&lt;p&gt;C++ 개발의 과거 프로젝트에서 우리는 자체 프로토콜을 사용하여 통신했고, 이 프로토콜은 2차원 배열 패턴을 채택했습니다. 대량의 데이터를 처리할 때 프로토콜 내부에서 배열을 순회하고 시리얼화 작업을 수행하여 로그를 생성해야 했는데, 효율성이 낮아 시스템이 고부하 상태에서 눈에 띄는 끊김 현상을 일으켰고, 이로 인해 사업 부서로부터 시스템 끊김에 대한 피드백을 받았습니다.&lt;/p&gt;
&lt;h2 id=&#34;문제-파악&#34;&gt;문제 파악
&lt;/h2&gt;&lt;p&gt;문제 해결 과정에서, 우리는 먼저 시스템 성능을 분석했고, 대량의 데이터를 처리할 때 CPU 사용률이 눈에 띄게 증가하고 시스템 응답 시간이 길어지는 것을 확인했습니다. 시스템 로그를 분석한 결과, 많은 양의 직렬화 작업이 있었고, 이러한 작업은 특히 2차원 배열을 처리할 때 효율성이 낮아 시스템 성능 저하를 유발하는 것으로 나타났습니다.&lt;/p&gt;
&lt;p&gt;pstack 도구로 스레드 정보를 캡처한 결과, 로그 스레드가 대부분의 시간을 문자열 연결 처리에 소비하는 것으로 나타났다&lt;/p&gt;
&lt;p&gt;여기 오늘의 핵심인데, 다른 누적 방식에 따라 효율성이 엄청나게 달라집니다. 기존 코드에서는 + 연산자를 사용했는데, 이 방식은 빈번하게 임시 객체를 생성하므로 효율이 매우 낮습니다. 그 비효율성을 알고는 있지만, 얼마나 비효율적인지 제대로 모르는 그런 종류입니다.&lt;/p&gt;
&lt;h2 id=&#34;데모-검증&#34;&gt;데모 검증
&lt;/h2&gt;&lt;p&gt;프로젝트 코드를 기반으로 비즈니스 로직을 분리하고, 문자열 연결 효율성 문제를 검증하기 위한 간단한 데모를 작성했습니다. &lt;code&gt;windows&lt;/code&gt; 환경의 &lt;code&gt;vs2022&lt;/code&gt; 컴파일러와 &lt;code&gt;linux&lt;/code&gt; 환경의 &lt;code&gt;gcc8.5&lt;/code&gt; 컴파일러로 &lt;code&gt;Release&lt;/code&gt; 모드에서 컴파일 및 실행하여 효율성을 비교했습니다.&lt;/p&gt;
&lt;h3 id=&#34;주요-사항-안내&#34;&gt;주요 사항 안내
&lt;/h3&gt;&lt;p&gt;프로젝트에서는 방법 네 가지를 사용했는데, 테스트 데이터를 받기 전 독자들은 어떤 방식이 가장 효율적이고 어떤 방식이 가장 비효율적인지 먼저 생각해 볼 수 있습니다. 결과를 보았을 때 저는 여전히 놀랐습니다.&lt;/p&gt;
&lt;p&gt;방법 1 (&lt;code&gt;+=&lt;/code&gt; 연결): 각 필드를 &lt;code&gt;+=&lt;/code&gt; 연산자를 사용하여 문자열에 직접 연결합니다
방법 2 ( &lt;code&gt;std::ostringstream&lt;/code&gt; 연결): 스트림(&lt;code&gt;std::ostringstream&lt;/code&gt;)을 사용하여 각 필드를 연결하는 방법으로, 특히 대량의 데이터를 연결할 때 더 효율적입니다
방법 3(미리 할당된 메모리의 += 연결): &lt;code&gt;reserve&lt;/code&gt;를 사용하여 문자열에 필요한 충분한 메모리를 미리 할당하면 메모리 재할당 비용을 줄여 성능을 향상시킬 수 있습니다
방법 4(&lt;code&gt;bodys = bodys + body + &amp;quot;\n&amp;quot;&lt;/code&gt;): 매번 연결할 때마다 새로운 임시 문자열 객체를 생성하므로, 특히 대규모 연결 시 성능 저하가 발생합니다. 이는 매번 연결이 새로운 메모리 할당 및 복사를 수반하기 때문입니다.&lt;/p&gt;
&lt;p&gt;참고 결과, 프로젝트가 효율이 가장 낮은 방식을 선택한 것을 알 수 있습니다&lt;/p&gt;
&lt;p&gt;더 나아가, 다양한 플랫폼 컴파일러의 최적화 효율을 분석해 보겠습니다. 마이크로소프트의 &lt;code&gt;Visual Studio&lt;/code&gt;는 여전히 뛰어난 성능을 보여주며 문자열 최적화 효율이 매우 높지만, &lt;code&gt;gcc&lt;/code&gt; 컴파일러는 이 부분에서 최적화 효율이 다소 떨어지는 편입니다.&lt;/p&gt;
&lt;p&gt;코드 실행 환경이 다른 기계에서 이루어지므로 데이터 간의 직접적인 비교는 의미가 없습니다. 각각의 조인 방법 간의 차이를 비교하는 것이 좋습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;windows 平台下的 vs2022 编译器

----------------------------------------
Data Generation Time: 0.054 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.053 seconds.
+ ostringstream Data merging took: 0.054 seconds.
+ Pre-reserved Data merging took: 0.045 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 16.108 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;linux 平台下的 gcc8.5 编译器
----------------------------------------
Data Generation Time: 0.108 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.100 seconds.
+ ostringstream Data merging took: 0.083 seconds.
+ Pre-reserved Data merging took: 0.057 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 29.298 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;전체-코드&#34;&gt;전체 코드
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;random&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;iomanip&amp;gt;

typedef std::vector&amp;lt;std::string&amp;gt; DataRow;
typedef std::vector&amp;lt;DataRow&amp;gt; DataGroup;

struct ResponsePackage
{
    std::string ErrorInfo;
    DataRow Head;
    std::string ClientId;
    std::string UUID;
    std::string MsgID;
    std::string SessionID;
    std::string ExtraInfo1;
    std::string ExtraInfo2;
    DataGroup DataBody;
};

// Generate specified length of random string
std::string generateRandomString(size_t length)
{
    const char charset[] = &amp;quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&amp;quot;;
    const size_t max_index = sizeof(charset) - 1;
    std::string random_string;
    random_string.reserve(length);

    std::random_device rd;
    std::mt19937 generator(rd());
    std::uniform_int_distribution&amp;lt;&amp;gt; distribution(0, max_index);

    for (size_t i = 0; i &amp;lt; length; ++i)
    {
        random_string += charset[distribution(generator)];
    }

    return random_string;
}

void create_large_string()
{
    // Example request package with 50 fields
    ResponsePackage requestPackage;

    requestPackage.Head = {
        &amp;quot;Field1&amp;quot;, &amp;quot;Field2&amp;quot;, &amp;quot;Field3&amp;quot;, &amp;quot;Field4&amp;quot;, &amp;quot;Field5&amp;quot;,
        &amp;quot;Field6&amp;quot;, &amp;quot;Field7&amp;quot;, &amp;quot;Field8&amp;quot;, &amp;quot;Field9&amp;quot;, &amp;quot;Field10&amp;quot;,
        &amp;quot;Field11&amp;quot;, &amp;quot;Field12&amp;quot;, &amp;quot;Field13&amp;quot;, &amp;quot;Field14&amp;quot;, &amp;quot;Field15&amp;quot;,
        &amp;quot;Field16&amp;quot;, &amp;quot;Field17&amp;quot;, &amp;quot;Field18&amp;quot;, &amp;quot;Field19&amp;quot;, &amp;quot;Field20&amp;quot;,
        &amp;quot;Field21&amp;quot;, &amp;quot;Field22&amp;quot;, &amp;quot;Field23&amp;quot;, &amp;quot;Field24&amp;quot;, &amp;quot;Field25&amp;quot;,
        &amp;quot;Field26&amp;quot;, &amp;quot;Field27&amp;quot;, &amp;quot;Field28&amp;quot;, &amp;quot;Field29&amp;quot;, &amp;quot;Field30&amp;quot;,
        &amp;quot;Field31&amp;quot;, &amp;quot;Field32&amp;quot;, &amp;quot;Field33&amp;quot;, &amp;quot;Field34&amp;quot;, &amp;quot;Field35&amp;quot;,
        &amp;quot;Field36&amp;quot;, &amp;quot;Field37&amp;quot;, &amp;quot;Field38&amp;quot;, &amp;quot;Field39&amp;quot;, &amp;quot;Field40&amp;quot;,
        &amp;quot;Field41&amp;quot;, &amp;quot;Field42&amp;quot;, &amp;quot;Field43&amp;quot;, &amp;quot;Field44&amp;quot;, &amp;quot;Field45&amp;quot;,
        &amp;quot;Field46&amp;quot;, &amp;quot;Field47&amp;quot;, &amp;quot;Field48&amp;quot;, &amp;quot;Field49&amp;quot;, &amp;quot;Field50&amp;quot;
    };

    requestPackage.ClientId = &amp;quot;ClientID&amp;quot;;
    requestPackage.UUID = &amp;quot;UUID&amp;quot;;
    requestPackage.MsgID = &amp;quot;MsgID&amp;quot;;
    requestPackage.SessionID = &amp;quot;SessionID&amp;quot;;
    requestPackage.ExtraInfo1 = &amp;quot;ExtraInfo1&amp;quot;;
    requestPackage.ExtraInfo2 = &amp;quot;ExtraInfo2&amp;quot;;

    // Start timing for data generation
    auto start_gen = std::chrono::high_resolution_clock::now();

    // Generate 10,000 rows of data, each with 50 fields
    for (size_t i = 0; i &amp;lt; 10000; ++i)
    {
        DataRow dataRow(50, &amp;quot;This is a test string&amp;quot;);
        requestPackage.DataBody.push_back(dataRow);
    }

    // End timing for data generation
    auto end_gen = std::chrono::high_resolution_clock::now();
    std::chrono::duration&amp;lt;double&amp;gt; duration_gen = end_gen - start_gen;

    // Display result generation time
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Generation Time: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_gen.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    // Data merging using different methods
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Performance:\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    {
        // Method 1: Using &#39;+=&#39; string concatenation
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (+=) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 2: Using ostringstream
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::ostringstream bodys;
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::ostringstream body;
            body &amp;lt;&amp;lt; &amp;quot;This is a test string&amp;quot;;
            for (auto&amp;amp; item : vec)
            {
                body &amp;lt;&amp;lt; item &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            }
            bodys &amp;lt;&amp;lt; body.str() &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ ostringstream Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 3: Pre-allocated memory
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys;
        bodys.reserve(1000 * 50 * 20); // Pre-allocate enough memory
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            body.reserve(50 * 20); // Pre-allocate memory for each row
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Pre-reserved Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 4: Using &#39;bodys = bodys + body + &amp;quot;\n&amp;quot;&#39;
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body = body + item + &amp;quot; &amp;quot;; // Note the use of &#39;body = body + item&#39;
            }
            bodys = bodys + body + &amp;quot;\n&amp;quot;; // Again, using &#39;bodys = bodys + body&#39;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (bodys = bodys + body + \&amp;quot;\\n\&amp;quot;) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Complete.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;
}

int main()
{
    try
    {
        create_large_string();
    }
    catch (const std::exception&amp;amp; e)
    {
        std::cerr &amp;lt;&amp;lt; &amp;quot;Caught exception: &amp;quot; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\nProgram finished.\n&amp;quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43; 람다 표현식 매개변수 생명 주기</title>
        <link>https://ttf248.life/ko/p/cpp-lambda-parameter-lifetime/</link>
        <pubDate>Wed, 13 Nov 2024 19:23:02 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/cpp-lambda-parameter-lifetime/</guid>
        <description>&lt;p&gt;C++에서 람다 표현식은 외부 변수를 캡처하여 그 안에서 사용할 수 있는 편리한 익명 함수입니다. 이는 람다가 유연한 프로그래밍 도구가 되도록 합니다. 하지만 람다 표현식의 매개변수 생명 주기는 특히 캡처 및 전달 시 특별히 주의해야 할 측면입니다.&lt;/p&gt;
&lt;h3 id=&#34;람다-표현식의-매개변수-생명-주기&#34;&gt;람다 표현식의 매개변수 생명 주기
&lt;/h3&gt;&lt;p&gt;람다 표현식의 매개변수 수명은 일반적으로 다른 C++ 함수와 동일합니다. 함수의 매개변수는 함수 호출 시 존재하며, 함수 호출이 종료되면 매개변수 수명이 종료됩니다. 하지만 람다 표현식이 외부 변수를 캡처할 수 있기 때문에 매개변수 수명은 캡처 방식에 영향을 받기도 합니다.&lt;/p&gt;
&lt;h3 id=&#34;포획과-매개변수-생명-주기의-관계&#34;&gt;포획과 매개변수 생명 주기의 관계
&lt;/h3&gt;&lt;h4 id=&#34;외부-변수-캡처&#34;&gt;외부 변수 캡처
&lt;/h4&gt;&lt;p&gt;C++ 람다 표현식은 외부 변수를 두 가지 방식으로 캡처할 수 있습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;값 캡처: 값 캡처를 통해 외부 변수의 값이 람다 내부에 복사되고, 람다 내부의 복사본은 람다의 생명주기에 의해 제어됩니다&lt;/li&gt;
&lt;li&gt;참조 캡처: 참조 캡처를 통해 외부 변수의 참조가 유지되며, 람다 내부의 참조는 원래 외부 변수를 가리키고, 생명 주기는 외부 변수에 의존합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda_by_value = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };  // 捕获x的副本
auto lambda_by_reference = [&amp;amp;x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };  // 捕获x的引用

lambda_by_value();  // 打印10
lambda_by_reference();  // 打印10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;캡처된 변수의 수명 주기는 다음과 같습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;값 캡처: 캡처 시 외부 변수의 값이 람다에 복사되고, 람다가 종료될 때 복사된 사본이 파괴됩니다&lt;/li&gt;
&lt;li&gt;람다가 외부 변수를 참조할 때, &lt;strong&gt;외부 변수는 람다 사용 전에 유효해야 하며, 그렇지 않으면 정의되지 않은 동작이 발생할 수 있습니다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;람다-매개변수&#34;&gt;람다 매개변수
&lt;/h4&gt;&lt;p&gt;람다 함수의 매개변수는 일반 함수 매개변수와 유사하며, 그 수명은 람다 함수 내에서만 유효합니다. 즉, 람다 매개변수는 람다 호출 시 생성되고, 람다 호출이 종료되면 매개변수의 수명도 함께 종료됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto lambda = [](int a, int b) {
    std::cout &amp;lt;&amp;lt; a + b &amp;lt;&amp;lt; std::endl;
};
lambda(5, 10);  // a和b在这里是lambda的参数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 예제에서, &lt;code&gt;a&lt;/code&gt;와 &lt;code&gt;b&lt;/code&gt;는 람다 표현식의 매개변수이며, 람다 호출 시 생성되고 람다 실행 종료 후 파괴됩니다&lt;/p&gt;
&lt;h3 id=&#34;외부-변수-캡처-시-라이프사이클-문제&#34;&gt;외부 변수 캡처 시 라이프사이클 문제
&lt;/h3&gt;&lt;h4 id=&#34;람다-외부에서-포획된-변수가-유효한지&#34;&gt;람다 외부에서 포획된 변수가 유효한지
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;람다 호출 후 외부 변수가 파괴되더라도 람다는 여전히 외부 변수의 복사본을 보유합니다. 따라서 외부 변수가 더 이상 존재하지 않더라도 람다 내부의 복사본은 안전하게 사용할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x 在lambda调用后修改
lambda();  // 打印10，捕获的是x的副本
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;캡처된 변수가 참조에 의한 캡처인 경우, 람다 내부에서 해당 참조에 대한 접근은 외부 변수의 수명 주기(lifetime)에 의존합니다. 만약 외부 변수가 람다가 실행되기 전에 소멸된다면, 댕글링 포인터(dangling reference) 문제가 발생하여 정의되지 않은 동작을 초래할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [&amp;amp;x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x 在lambda调用前修改
lambda();  // 打印20，捕获的是x的引用
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;람다 함수의 실행 순서가 불확실한 경우, 람다가 실행될 때 캡처된 외부 변수가 여전히 유효한지 확인하는 것이 중요합니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>Win11 로지텍 G431 헤드셋 드라이버 설치</title>
        <link>https://ttf248.life/ko/p/win11-logitech-g431-headphone-driver-installation/</link>
        <pubDate>Wed, 05 Jun 2024 07:20:17 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/win11-logitech-g431-headphone-driver-installation/</guid>
        <description>&lt;p&gt;책은 지난 번에 이어져서, 돌아와 보니 Ghub이 업데이트되었네. 조금 기뻤는데, 고객센터에서 해결했다고 하는 문제 드라이브가 정상적으로 로드되지 않는 문제가 해결되었다고 했는데, 결과적으로 한 바퀴 뱅글뱅글 돌리고 재설치 및 제거를 해도 제대로 사용하지 못하네.&lt;/p&gt;
&lt;h2 id=&#34;배경&#34;&gt;배경
&lt;/h2&gt;&lt;p&gt;계속 고객센터에 문의하여 처리 방안을 알아보니, 엔지니어의 원격 지원은 가능하지만 엔지니어의 근무 시간과 제 근무 시간이 똑같다는 답변을 받았습니다. 어쩔 수 없이 포기하고, 이전 문제 해결 과정에서 남겨둔 자료를 살펴보며 직접 드라이버를 설치해 보려고 합니다.&lt;/p&gt;
&lt;h2 id=&#34;드라이버-설치-패키지-받기&#34;&gt;드라이버 설치 패키지 받기
&lt;/h2&gt;&lt;p&gt;로지텍 공식에서는 별도의 장치 드라이버 설치 파일을 제공하지 않습니다. 드라이버 파일은 어떻게 얻을 수 있나요?&lt;/p&gt;
&lt;p&gt;이전 시스템 재설치로 남은 시스템 이미지 설치 패키지를 활용하여, 로컬 가상 머신에서 시스템을 다시 설치할 수 있습니다. 깨끗한 시스템 환경에서 Ghub를 개별적으로 배포하고, 헤드폰 장치를 가상 머신에 연결한 후 드라이버 경로를 찾아 복사해낼 수 있습니다.&lt;/p&gt;
&lt;p&gt;관련 경로:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C:\ProgramData\LGHUB&lt;/li&gt;
&lt;li&gt;C:\Windows\System32\DriverStore\FileRepository\logi_audio.inf_amd64_010b035044e24be4&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장치-관리자&#34;&gt;장치 관리자
&lt;/h2&gt;&lt;p&gt;두 번째 경로를 찾는 것이 핵심인데, 먼저 Win11 시스템에서 드라이버 파일을 수동으로 관리하는 방법을 간단히 정리해 보겠습니다. 이 내용은 &lt;strong&gt;변수 제어법을 통해 식별했는데, 가상 머신 안에서 장치를 계속 연결하고 분리하면서 장치 관리자에서 장치 정보를 분석하여 헤드폰에 대해 처리해야 할 세 개의 드라이버가 있다는 것을 확인했습니다&lt;/strong&gt;. 그 중 두 개는 시스템 내장 드라이버이고 하나는 로지텍에서 제공하는 것입니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;드라이버 관리자&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;상단 그림의 두 번째 드라이버는 로지텍에서 제공하는 것으로, 현재 장치의 드라이버를 분석하고 가상 머신 안에서 모든 드라이버 경로를 뒤져야 합니다. 당연히 logi로 시작하는 파일을 먼저 찾아야 하고, 파일 비교를 통해 드라이버 파일을 찾을 수 있습니다. 전체 폴더를 복사하면 드라이버 설치 패키지를 얻게 됩니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;드라이버 설치 패키지&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;드라이버-설치&#34;&gt;드라이버 설치
&lt;/h2&gt;&lt;p&gt;장치 관리자 인터페이스에서 “드라이버 업데이트”를 클릭한 다음, “내 컴퓨터에서 드라이버 찾아보기”를 클릭하면 다음과 같은 화면으로 진입합니다&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;드라이버 설치&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;물론 열면 드라이버 하나만 보일 텐데, 그것은 일반 USB 드라이버입니다. &amp;ldquo;디스크에서 설치&amp;quot;를 선택하고 경로가 앞서 복사해 놓은 폴더로 설정하면 됩니다. 설치 후에는 드롭다운 목록에 로지텍 특유의 드라이버가 추가될 것이고, 새로 설치된 드라이버로 장치 드라이버를 전환하면 됩니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;디스크 설치&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;인체학-장비-드라이버&#34;&gt;인체학 장비 드라이버
&lt;/h2&gt;&lt;p&gt;이 장치의 드라이버 파일은 모두 시스템에서 제공하는 것이므로, 장치 드라이버 앞에 느낌표가 있는지 확인하기만 하면 됩니다. 느낌표가 있다면 드라이버 선택 화면으로 들어가서 다른 유형의 드라이버로 임시로 변경한 후 다시 원래대로 돌리면 정상적으로 복구됩니다.&lt;/p&gt;
&lt;h2 id=&#34;완료&#34;&gt;완료
&lt;/h2&gt;&lt;p&gt;헤드폰 마이크 음량이 정상으로 돌아왔고, 익숙한 이어모니터 기능도 다시 작동하기 시작했습니다&lt;/p&gt;
&lt;p&gt;측음&lt;/p&gt;</description>
        </item>
        <item>
        <title>로지텍 헤드셋 드라이버 설치 실패</title>
        <link>https://ttf248.life/ko/p/logitech-headset-driver-installation-failed/</link>
        <pubDate>Fri, 31 May 2024 21:46:12 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/logitech-headset-driver-installation-failed/</guid>
        <description>&lt;p&gt;이런 것들을 전혀 모른다면, 처음부터 공식 고객센터에 연락했으면 몇 시간이고 끙끙거릴 필요가 없었을 텐데&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/logitech-headset-driver-installation-failed/20240531220709.png&#34;
	width=&#34;693&#34;
	height=&#34;489&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;GHUB&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;141&#34;
		data-flex-basis=&#34;340px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;최근에 제가 집에서 개발용으로 사용하는 데스크탑의 C드라이브 용량이 부족해져서, 특별히 256GB의 반납된 SSD를 따로 C드라이브로 사용하기로 했습니다. 하지만 자주 이것저것 만지작거려서 제대로 되지 않았습니다. 상하이로 이사 온 후 계속해서 여러 가지 일에 바빴는데, 드디어 지난주에 시간을 내어 시스템을 다시 설치했습니다.&lt;/p&gt;
&lt;p&gt;시스템 재설치 과정은 매우 순조로웠고, 일상적인 소프트웨어 설치와 개발 환경 구축에도 문제는 없었다. 며칠 후 휴식을 취하며 게임을 몇 판 하려고 할 때 마침 키보드와 헤드셋 드라이버가 아직 설치되지 않은 것을 알게 되었다. 이 두 장치는 모두 로지텍 제품이어서 GHUB 소프트웨어를 다운로드하여 하드웨어를 자동으로 인식하고 드라이버를 설치했다.&lt;/p&gt;
&lt;p&gt;하지만, 예기치 않은 일이 발생했다. 마우스 드라이버는 문제없이 설치되었지만 헤드셋 드라이버는 계속해서 &amp;ldquo;로딩 중&amp;quot;이라고 표시되었다. 최신 버전의 Windows 11 시스템과 로지텍 드라이버가 호환되지 않아 설치에 실패한 것 같다고 생각했다. 그래서 자료를 찾아보고 수동으로 드라이버를 설치하려고 시도했지만, 문제는 여전히 해결되지 않았다.&lt;/p&gt;
&lt;p&gt;이 두 장치의 드라이버는 각각 어떤 역할을 하는지 간단히 설명해 드릴게요&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;마우스 드라이버는 주로 마우스 이동 속도 등의 기능을 조절하는 데 사용됩니다. 매크로 기능은 거의 사용하지 않으며, 이전에 저장했던 설정을 불러오기만 하면 됩니다.&lt;/li&gt;
&lt;li&gt;이어폰의 드라이버는 주로 이어모니터링 기능에 사용되는데, 팀 음성 채팅 시 매우 유용합니다. 제 목소리를 들을 수 있게 해주죠. 시스템 마이크 설정에도 비슷한 모니터링 기능이 있지만, 드라이버로 구현했을 때 효과가 더 좋습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;몇 번이고 반복해서 시도했지만, 이어폰 드라이버가 제대로 로드되지 않습니다. 오늘 겨우 고객센터에 문의해 보았는데, 해결책이 있는지 확인했습니다. 고객센터에서는 최근 서버에 문제가 생겨 드라이버 다운로드가 비정상적으로 이루어지고 있다고 했습니다. 현재 이 문제를 처리 중이며, 다음 업데이트 후에 문제는 해결될 것이라고 하셨습니다.&lt;/p&gt;
&lt;p&gt;아직 헤드폰 드라이버 문제 해결은 못 했지만, 적어도 원인은 알게 되었고, 문제가 최대한 빨리 해결되기를 바랍니다&lt;/p&gt;
&lt;h2 id=&#34;마우스-드라이버-설정&#34;&gt;마우스 드라이버 설정
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/logitech-headset-driver-installation-failed/20240531220930.png&#34;
	width=&#34;1024&#34;
	height=&#34;768&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;G502&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;133&#34;
		data-flex-basis=&#34;320px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/logitech-headset-driver-installation-failed/20240531220903.png&#34;
	width=&#34;1024&#34;
	height=&#34;768&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;G502&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;133&#34;
		data-flex-basis=&#34;320px&#34;
	
&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>파이썬 딕셔너리에 사용자 정의 객체 저장 시 참조와 깊은 복사의 중요성</title>
        <link>https://ttf248.life/ko/p/python-dictionary-custom-objects-reference-vs-deepcopy/</link>
        <pubDate>Fri, 22 Mar 2024 01:08:05 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/python-dictionary-custom-objects-reference-vs-deepcopy/</guid>
        <description>&lt;p&gt;파이썬 프로그래밍에서 딕셔너리는 매우 강력한 자료 구조이며, 키-값 쌍을 연결하고 이러한 데이터를 효율적으로 검색하고 조작할 수 있습니다. 사용자 정의 객체를 딕셔너리에 저장하려고 할 때 일반적으로 중요한 개념에 직면하는데, 파이썬에서의 객체 할당은 실제로 객체의 깊은 복사라기보다는 참조 할당입니다. 즉, 사용자 정의 객체를 딕셔너리에 넣으면 딕셔너리에는 해당 객체에 대한 참조가 저장되고 객체의 새로운 복사본이 저장되는 것이 아닙니다.&lt;/p&gt;
&lt;h2 id=&#34;사용자-정의-객체-저장의-기본-예제&#34;&gt;사용자 정의 객체 저장의 기본 예제
&lt;/h2&gt;&lt;p&gt;가정적으로 간단한 &lt;code&gt;Person&lt;/code&gt; 클래스가 있다고 가정해 봅시다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

# 创建一个 Person 对象
p1 = Person(&amp;quot;Alice&amp;quot;, 30)

# 将对象存储到字典中
people_dict = {}
people_dict[&amp;quot;alice&amp;quot;] = p1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 예제에서, &lt;code&gt;people_dict&lt;/code&gt; 딕셔너리는 이제 키가 &lt;code&gt;&amp;quot;alice&amp;quot;&lt;/code&gt;인 항목을 포함하고 있으며, 그 값은 &lt;code&gt;Person&lt;/code&gt; 타입의 &lt;code&gt;p1&lt;/code&gt; 객체에 대한 참조입니다. 만약 우리가 &lt;code&gt;p1&lt;/code&gt;의 속성을 수정한다면:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;p1.age = 31
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그러면 딕셔너리로 이 객체에 접근하면, 그 나이도 업데이트된 것을 확인할 수 있습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(people_dict[&amp;quot;alice&amp;quot;].age)  # 输出：31
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;딕셔너리에 저장되는 것은 &lt;code&gt;Person&lt;/code&gt; 객체의 독립적인 복사본이 아니라 동일한 메모리 주소를 가리키는 참조입니다&lt;/p&gt;
&lt;h2 id=&#34;깊은-복사와-얕은-복사의-차이점&#34;&gt;깊은 복사와 얕은 복사의 차이점
&lt;/h2&gt;&lt;p&gt;중첩된 데이터 구조나 사용자 정의 객체를 다룰 때는 이러한 참조 동작으로 인해 예기치 않은 결과가 발생할 수 있습니다. 예를 들어, 사용자 정의 객체에 변경 가능한 속성(예: 목록이나 다른 사용자 정의 객체)이 포함되어 있는 경우, 그런 객체를 딕셔너리에 직접 저장하고 수정하면 딕셔너리를 통해 얻은 객체가 영향을 받습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Address:
    def __init__(self, street, city):
        self.street = street
        self.city = city

class Person:
    def __init__(self, name, age, address):
        self.name = name
        self.age = age
        self.address = address

address = Address(&amp;quot;Main St.&amp;quot;, &amp;quot;Springfield&amp;quot;)
p1 = Person(&amp;quot;Bob&amp;quot;, 40, address)
people_dict[&amp;quot;bob&amp;quot;] = p1

# 修改原始地址对象
address.city = &amp;quot;Shelbyville&amp;quot;

# 字典中的人的地址也变了
print(people_dict[&amp;quot;bob&amp;quot;].address.city)  # 输出：Shelbyville
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;해결 방법: 깊은 복사&lt;/p&gt;
&lt;p&gt;이러한 공유 상태로 인해 발생하는 문제를 피하기 위해 때로는 딕셔너리에 객체의 완전한 복사본을 저장하도록 해야 하며, 참조가 아닌 복사본을 저장해야 합니다. 파이썬은 이를 달성하기 위해 &lt;code&gt;copy&lt;/code&gt; 모듈의 &lt;code&gt;deepcopy&lt;/code&gt; 함수를 제공합니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import copy

# 使用深拷贝存储对象
people_dict[&amp;quot;bob_deepcopy&amp;quot;] = copy.deepcopy(p1)

# 此时即使修改原始地址对象，深拷贝的对象不会受影响
address.city = &amp;quot;Capital City&amp;quot;
print(people_dict[&amp;quot;bob&amp;quot;].address.city)  # 输出：Capital City
print(people_dict[&amp;quot;bob_deepcopy&amp;quot;].address.city)  # 输出：Shelbyville
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;결론적으로, 파이썬에서 딕셔너리를 사용하여 사용자 정의 객체를 저장할 때는 기본적으로 객체 참조가 저장된다는 점에 유의해야 합니다. 독립적인 상태를 유지해야 하는 경우에는 &lt;code&gt;deepcopy&lt;/code&gt;를 사용하여 깊은 복사를 수행하여 공유 참조로 인한 예기치 않은 데이터 변경을 방지하십시오.&lt;/p&gt;</description>
        </item>
        <item>
        <title>새로 설치한 기가급 유선 광섬유 회선인데 속도 측정 시 100메가에 그치는 이유는 무엇인가요?</title>
        <link>https://ttf248.life/ko/p/new-gigabit-fiber-slow-speed/</link>
        <pubDate>Mon, 18 Mar 2024 00:29:02 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/new-gigabit-fiber-slow-speed/</guid>
        <description>&lt;p&gt;집안 네트워크를 번개처럼 빠릿하게 만들고 싶으신가요? 핵심은 랜 케이블 선택, 광모뎀 및 공유기 설정, 그리고 눈에 띄지 않는 작은 디테일을 이해하는 데 있습니다. 이 블로그는 6급 랜 케이블로 기가비트 네트워크를 구축하고 간단한 장비 점검과 설정을 통해 네트워크 속도를 제약 없이 유지하는 방법을 쉽게 알려드릴 것입니다. 함께 탐색하며 집안 인터넷 속도를 높여 봅시다!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;수동 복구&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;제1장-네트워크-전송-매체-심층-분석&#34;&gt;제1장: 네트워크 전송 매체 심층 분석
&lt;/h2&gt;&lt;p&gt;기가비트급 네트워크 접속을 논할 때, 정보를 고속으로 전송하는 매개체인 랜 케이블은 매우 중요한 역할을 합니다. 다음에서는 5급, 6급 및 7급 랜 케이블에 대해 자세히 설명하겠습니다.&lt;/p&gt;
&lt;h3 id=&#34;다섯-종류의-네트워크-케이블cat5&#34;&gt;다섯 종류의 네트워크 케이블(CAT5)
&lt;/h3&gt;&lt;p&gt;다섯 종류의 네트워크 케이블, CAT5라고도 불리는 이 케이블은 비교적 초기에 널리 사용된 트위스트 페어 케이블 유형으로, 각 선 코어가 정밀한 나선 구조 설계로 인해 신호 간섭을 줄입니다. 주로 10/100Mbps의 빠른 이더넷에 적용되며 최대 전송 주파수는 약 100MHz입니다. 과거에는 널리 사용되었지만 현재 기가비트 이상 속도를 추구하는 요구 사항을 충족하기 위해서는 물리적인 한계로 인해 다섯 종류의 네트워크 케이블은 요구를 만족시키지 못합니다.&lt;/p&gt;
&lt;h3 id=&#34;6가지-네트워크-케이블cat6&#34;&gt;6가지 네트워크 케이블(CAT6)
&lt;/h3&gt;&lt;p&gt;기술 발전과 함께 6가지 종류의 네트워크 케이블이 등장했습니다. 5가지 종류의 네트워크 케이블에 비해 6가지 종류의 케이블은 더 엄격한 제조 기준과 더욱 발전된 구조 설계로 제작되어, 전반적인 내성능과 데이터 전송 효율을 크게 향상시켰습니다. 최대 1Gbps의 전송 속도를 지원하며 이상적인 조건에서는 전송 거리가 100미터까지 가능하여, 기가비트 네트워크 접속 요구 사항에 정확히 부합합니다.&lt;/p&gt;
&lt;h3 id=&#34;7가지-네트워크-케이블-cat7&#34;&gt;7가지 네트워크 케이블 (CAT7)
&lt;/h3&gt;&lt;p&gt;7가지 종류의 네트워크 케이블은 현재 트위스트 페어 기술의 최첨단을 나타냅니다. 이는 전송 속도에서 비약적인 향상을 가져왔을 뿐만 아니라 이론적으로 최대 10Gbps의 초고속을 지원하며, 설계에 완전한 차폐 시스템을 적용하여 각 선 쌍 간의 차폐와 전체 외부층의 차폐를 포함함으로써 외부 전자파 간섭과 근접 교차 누화를 크게 줄여 데이터 전송의 안정성과 정확성을 보장합니다. 하지만 7가지 종류의 네트워크 케이블은 주로 미래의 10기가비트 이더넷 또는 특정 고 요구 사항 시나리오에 사용됩니다.&lt;/p&gt;
&lt;p&gt;기가비트 가정 네트워크 환경을 구축할 때, 기가 광섬유의 잠재력을 최대한 발휘하기 위해서는 6급 랜 케이블을 선택하는 것이 가장 경제적이고 효율적인 방법입니다. 동시에 모든 연결 케이블의 품질이 양호한지 확인하고 엄격하게 표준 배선 방식으로 작업하는 것도 네트워크 성능을 확보하는 중요한 단계입니다.&lt;/p&gt;
&lt;h2 id=&#34;제2장-네트워크-핵심-장비인-광모뎀-라우터-lan-포트-대역폭의-영향-심층-분석&#34;&gt;제2장: 네트워크 핵심 장비인 광모뎀, 라우터 LAN 포트 대역폭의 영향 심층 분석
&lt;/h2&gt;&lt;h3 id=&#34;광촉매와-lan-포트-대역폭의-중요성&#34;&gt;광촉매와 LAN 포트 대역폭의 중요성
&lt;/h3&gt;&lt;p&gt;광촉매, 정식 명칭 광섬유 모뎀은 가정용 초고속 인터넷 접속의 핵심 장비이며, 빛 신호를 디지털 신호로 변환하여 가정 네트워크 장비에서 사용하도록 하는 기능이 있습니다. 기가급 광섬유 사용자에게 있어 광촉매가 기가 전송을 지원하는지 여부가 특히 중요합니다. 만약 광촉매의 WAN 포트가 기가 속도를 지원하지 않는다면, 입구 광섬유 속도가 아무리 높아도 이 병목 현상으로 인해 기가 속도 내에서 제한됩니다. 마찬가지로 광촉매의 LAN 포트 또한 기가 출력 능력을 갖춰야 하며, 그렇지 않으면 연결된 라우터나 다른 장비는 진정한 기가 속도를 얻을 수 없습니다.&lt;/p&gt;
&lt;h3 id=&#34;라우터-lan-포트-대역폭의-역할&#34;&gt;라우터 LAN 포트 대역폭의 역할
&lt;/h3&gt;&lt;p&gt;라우터의 LAN 포트는 수신된 데이터를 각 단말 장치에 분배하는 역할을 합니다. 라우터의 LAN 포트가 100메가비트에 불과할 경우, 다른 장치의 구성이 아무리 좋아도 100메가비트 속도의 로컬 네트워크 통신만 가능합니다. 따라서 기가홈 파티를 구축할 때는 라우터의 WAN 포트가 기가 데이터를 수신할 수 있도록 하고, LAN 포트 또한 기가 수준의 데이터 출력 능력을 제공해야 모든 스마트 장치가 고속 네트워크가 제공하는 원활한 경험을 누릴 수 있습니다.&lt;/p&gt;
&lt;p&gt;또한, 주의해야 할 점은 일부 구형 또는 저가형 라우터는 LAN 포트 자동 협상 기능이 있을 수 있다는 것입니다. 즉, 라우터 자체는 기가비트를 지원하더라도 회선, 장치 호환성 등의 이유로 속도가 100메가비트 모드로 낮아질 수 있습니다. 따라서 기가비트 네트워크를 구현하기 위해서는 라우터 설정을 올바르게 구성하고 강제 기가비트 모드를 활성화하며 기가비트 스위치 또는 직접 연결 장치를 함께 사용하는 것이 중요한 단계 중 하나입니다.&lt;/p&gt;
&lt;p&gt;기가급 광섬유로 업그레이드한 후에는 반드시 기가급 ONT와 기가급 라우터로 교체하고, 모든 장비 인터페이스가 기가급 수준에 도달하는지 확인하십시오&lt;/p&gt;
&lt;h2 id=&#34;제3장-숨겨진-미스터리---끊어진-서브스레드가-어떻게-테라비트급-네트워크-속도에-영향을-미치는가&#34;&gt;제3장: 숨겨진 미스터리 - 끊어진 서브스레드가 어떻게 테라비트급 네트워크 속도에 영향을 미치는가
&lt;/h2&gt;&lt;h3 id=&#34;서브-라인-장애-및-네트워크-성능-저하&#34;&gt;서브 라인 장애 및 네트워크 성능 저하
&lt;/h3&gt;&lt;p&gt;측정 기간 동안 네트워크 연결은 항상 유지되었으며, 눈에 띄는 단절 현상은 없었습니다. 신규 입주형 광대역 회선이라 분배함 내부가 어수선하고, 가끔은 광모뎀 배선이나 전원 인터페이스 콘센트 위치를 조정하다 보니 간혹 기가 속도가 측정된 적도 있습니다.&lt;/p&gt;
&lt;p&gt;앞선 자료를 바탕으로 점검해 본 결과, 랜 케이블 모델과 광케이블 LAN 포트 속도를 분석했더니, 결국 범인은 랜 케이블 내부의 갈색 서브 와이어가 끊어진 것이었습니다&lt;/p&gt;
&lt;p&gt;설치 기사님이 크리스탈 헤드를 설치할 때 이 랜선에 조금 세게 힘을 가했고, 그 결과 한 선이 반쯤 끊어졌지만 완전히 끊어진 것은 아니었습니다. 이후 광모뎀 위치를 계속 조정하면서 위치를 옮기니 결국 완전히 끊어졌습니다.&lt;/p&gt;
&lt;h3 id=&#34;6가지-랜-케이블-8가닥-선의-기능-분석&#34;&gt;6가지 랜 케이블 8가닥 선의 기능 분석
&lt;/h3&gt;&lt;p&gt;여섯 종류의 네트워크 케이블은 TIA/EIA-568-B 표준을 따르며, 8개의 트위스트 페어 전선으로 구성되어 있으며, 색상 코딩은 다음과 같습니다:&lt;/p&gt;
&lt;p&gt;백귤 / 귤
백록 / 녹
흰색과 파란색 / 파란색
백갈색 / 갈색&lt;/p&gt;
&lt;p&gt;기가비트 이더넷(1000BASE-T) 표준 하에서, 이 8개의 선 중 4쌍의 선이 동시에 작동하며, 구체적인 역할 분담은 다음과 같습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;백오렌지와 오렌지 이 두 선(1&amp;amp;2)은 데이터를 전송(Tx+/-)하는 데 사용됩니다&lt;/li&gt;
&lt;li&gt;백록과 녹색의 이 선(3&amp;amp;6)은 데이터 수신(Rx+/-)에 사용됩니다&lt;/li&gt;
&lt;li&gt;백란과 남색의 이 선(4&amp;amp;5)과 백갈색과 갈색의 이 선(7&amp;amp;8)은 기가비트 이더넷에서는 원래 주 용도로 사용되지 않지만, 일부 고급 애플리케이션(예: 특정 PoE 전원 공급 또는 미래 기술 확장)에서 활성화될 수 있습니다. 반면 전통적인 100메가비트 네트워크에서는 1, 2, 3, 6번 선만 사용하는 것으로 충분합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;절단된-하위-링크가-네트워크-속도에-미치는-영향&#34;&gt;절단된 하위 링크가 네트워크 속도에 미치는 영향
&lt;/h3&gt;&lt;p&gt;위와 같은 상황에서 갈색의 부선(갈색 선 또는 갈색 흰색 선)이 끊어지면 이론적으로는 1Gbps 네트워크 환경에서 속도 저하가 발생할 수 있습니다. 왜냐하면 1Gbps 네트워크는 모든 네 쌍의 선이 동시에 양방향으로 데이터를 전송하여 최고 속도를 달성하기 때문입니다. 하지만 가정용 네트워크 장비에는 자동 협상 기능이 종종 존재하며, 케이블에 문제가 감지되면 정상적으로 작동하는 낮은 속도 모드, 즉 100Mbps 모드로 되돌아갑니다. 따라서 부선이 끊어져도 네트워크 연결은 유지되고 100Mbps 속도로 작동하는 이유가 바로 이것입니다.&lt;/p&gt;
&lt;p&gt;간단히 말해서, 하나의 갈색 보조 광섬유가 끊어진다고 해서 100메가 네트워크의 기본적인 작동에는 영향을 미치지 않지만, 기가비트 네트워크 환경에서는 네트워크 속도를 제한하는 중요한 요인이 될 수 있습니다. 심층적인 진단과 복구가 이루어져야 비로소 기가급 광섬유의 잠재력을 완전히 발휘할 수 있습니다. 이는 유사한 상황에 직면했을 때, 기본적인 연결에는 영향을 미치지 않는 것처럼 보이는 작은 결함이라 할지라도 네트워크 인프라의 잠재적인 문제를 간과해서는 안 된다는 점을 상기시켜 줍니다. 이러한 결함은 고속 네트워크 경험의 보이지 않는 장애물이 될 수 있기 때문입니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>WPF UI 스레드와 멈춤 문제 및 해결 방법</title>
        <link>https://ttf248.life/ko/p/wpf-ui-thread-and-freezing-issues-solutions/</link>
        <pubDate>Tue, 12 Mar 2024 07:12:21 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/wpf-ui-thread-and-freezing-issues-solutions/</guid>
        <description>&lt;p&gt;데스크톱 애플리케이션을 개발할 때, 특히 Windows Presentation Foundation(WPF) 프레임워크를 사용하여 리치 클라이언트 애플리케이션을 구축할 때는 애플리케이션의 원활성과 응답성을 보장하기 위해 사용자 인터페이스(UI) 스레드를 올바르게 처리하는 것이 매우 중요합니다. UI 스레드, 또는 메인 스레드는 창과 컨트롤 이벤트 처리, 레이아웃 계산 및 인터페이스 렌더링을 담당하는 핵심 스레드입니다. UI 요소와의 모든 상호 작용은 UI 스레드에서 실행되어야 하며, 이는 WPF는 물론 다른 대부분의 GUI 프레임워크가 따르는 기본 원칙입니다.&lt;/p&gt;
&lt;h2 id=&#34;ui-스레드가-무엇인가요&#34;&gt;UI 스레드가 무엇인가요?
&lt;/h2&gt;&lt;p&gt;WPF 애플리케이션 시작 시 UI 스레드는 운영체제에 의해 생성되고 애플리케이션의 주 창을 초기화합니다. 이는 애플리케이션 내에서 UI 구성 요소의 상태를 직접적으로 액세스하고 수정할 수 있는 유일한 스레드입니다. 즉, 버튼 클릭, 텍스트 상자 입력, 창 크기 변경과 같은 모든 사용자 상호 작용으로 발생하는 이벤트는 이 스레드 컨텍스트 내에서 처리됩니다. 동시에 WPF의 종속 속성 시스템, 데이터 바인딩 메커니즘 및 레이아웃 로직도 UI 스레드 위에서 동기적으로 실행됩니다.&lt;/p&gt;
&lt;h2 id=&#34;끊김-현상-및-원인&#34;&gt;끊김 현상 및 원인
&lt;/h2&gt;&lt;p&gt;UI 스레드가 장시간 점유되거나 차단될 때, 예를 들어 시간이 오래 걸리는 계산, 대량 데이터 로딩, 데이터베이스 쿼리 또는 기타 I/O 집약적인 작업을 수행할 때 발생합니다. 이로 인해 UI 스레드가 사용자 상호 작용 요청에 즉시 응답하지 못하고, 결과적으로 화면이 응답하지 않는(Freeze) 현상이 나타납니다. 흔히 “카통”이라고 불리는 이것은 사용자가 앱의 지연과 끊김을 명확하게 느낄 수 있으며, 심할 경우 &amp;ldquo;Application Not Responding&amp;rdquo;(ANR) 경고가 발생할 수도 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;ui-스레드의-두-가지-기본-규칙&#34;&gt;UI 스레드의 두 가지 기본 규칙
&lt;/h2&gt;&lt;p&gt;위와 같은 상황을 방지하기 위해 WPF 개발자는 다음 두 가지 주요 규칙을 준수해야 합니다&lt;/p&gt;
&lt;p&gt;UI 스레드에서 시간이 오래 걸리는 작업을 수행하지 마세요. UI 스레드를 멈추게 할 수 있는 작업은 가능한 한 백그라운드 스레드로 옮겨서 사용자 입력에 즉시 응답하고 화면 변경을 렌더링할 수 있도록 해야 합니다.
UI 스레드에서 직접 UI 요소를 업데이트하지 마세요. WPF의 보안 메커니즘 설계상, UI 요소 수정은 UI 스레드만 권한이 있습니다. 다른 스레드에서 직접 UI 상태를 변경하려고 하면 예외가 발생합니다. 따라서 백그라운드 스레드에서 계산이나 데이터 준비가 완료되더라도 적절한 크로스 스레드 통신 메커니즘을 통해 결과를 UI에 표시해야 합니다.&lt;/p&gt;
&lt;h2 id=&#34;비동기-프로그래밍-및-스레드-안전-업데이트-솔루션&#34;&gt;비동기 프로그래밍 및 스레드 안전 업데이트 솔루션
&lt;/h2&gt;&lt;p&gt;UI의 응답성을 유지하면서도 시간이 오래 걸리는 작업을 수행하기 위해 WPF는 개발자가 이 목표를 달성하도록 돕기 위한 다양한 비동기 프로그래밍 모델과 도구를 제공합니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;디스패처 객체: WPF의 디스패처 클래스는 작업 항목을 UI 스레드의 작업 큐에 배치하여 실행할 수 있습니다. &lt;code&gt;Dispatcher.Invoke&lt;/code&gt; 또는 &lt;code&gt;Dispatcher.BeginInvoke&lt;/code&gt; 메서드를 사용하여 백그라운드 스레드에서 안전하게 UI를 업데이트할 수 있습니다.&lt;/li&gt;
&lt;li&gt;C# 언어의 비동기 기능을 활용하면 &lt;code&gt;await&lt;/code&gt; 키워드를 사용하여 백그라운드 작업 완료를 기다리고, 완료 후 자동으로 UI 스레드로 돌아와서 이후 UI 업데이트 코드를 실행할 수 있습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;사례&#34;&gt;사례
&lt;/h2&gt;&lt;h3 id=&#34;ui를-업데이트하려면-dispatcherinvoke-메서드를-사용하세요&#34;&gt;UI를 업데이트하려면 &lt;code&gt;Dispatcher.Invoke&lt;/code&gt; 메서드를 사용하세요
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private void Button_Click(object sender, RoutedEventArgs e)
{
    // 假设这是一个耗时操作
    Task.Run(() =&amp;gt;
    {
        var result = LongRunningOperation(); // 这里是模拟一个耗时计算的方法
        
        // 当耗时操作完成后，在UI线程上更新UI
        Application.Current.Dispatcher.Invoke(() =&amp;gt;
        {
            LabelStatus.Text = $&amp;quot;计算结果: {result}&amp;quot;;
        });
    });
}

private string LongRunningOperation()
{
    // 模拟耗时操作
    Thread.Sleep(5000);
    return &amp;quot;已完成&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;asyncawait-키워드와-taskrun을-함께-사용하세요&#34;&gt;&lt;code&gt;async/await&lt;/code&gt; 키워드와 &lt;code&gt;Task.Run&lt;/code&gt;을 함께 사용하세요
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private async void Button_ClickAsync(object sender, RoutedEventArgs e)
{
    Button button = sender as Button;
    button.IsEnabled = false; // 防止用户重复点击

    try
    {
        // 开启后台任务
        var result = await Task.Run(() =&amp;gt; LongRunningOperation());

        // 在后台任务完成后，自动切换回UI线程更新UI
        LabelStatus.Text = $&amp;quot;计算结果: {result}&amp;quot;;
    }
    catch (Exception ex)
    {
        MessageBox.Show($&amp;quot;发生错误: {ex.Message}&amp;quot;);
    }
    finally
    {
        button.IsEnabled = true; // 重新启用按钮
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>GCC 버전 업그레이드로 인한 프로그램 충돌: 비표준 코드의 잠재적 위험</title>
        <link>https://ttf248.life/ko/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</link>
        <pubDate>Sun, 10 Mar 2024 23:19:06 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</guid>
        <description>&lt;p&gt;동일한 비즈니스 코드의 경우, 프로그램은 CentOS 7 환경에서 정상적으로 컴파일 및 실행되었지만, CentOS 8로 전환하고 최신 버전의 GCC를 사용하여 컴파일하면 프로그램이 충돌합니다. 주목할 점은 문제가 &lt;strong&gt;릴리스 모드&lt;/strong&gt;에서만 발생하며, &lt;strong&gt;디버그 모드&lt;/strong&gt;에서는 전혀 문제가 없다는 것입니다. 이와 같은 상황은 처음 경험했으며, 삼 일간의 조사 끝에 문제의 근본 원인을 찾았습니다.&lt;/p&gt;
&lt;h3 id=&#34;문제-파악&#34;&gt;문제 파악
&lt;/h3&gt;&lt;p&gt;일련의 점검을 거쳐 문제의 원인은 &lt;strong&gt;함수가 반환값을 갖지 못하는 것&lt;/strong&gt;으로 밝혀졌습니다. Release 모드에서는 GCC 최신 버전이 더 많은 최적화를 수행하는데, 이로 인해 명시적으로 반환값이 없는 함수 실행 과정에서 예상치 못한 로직이 발생하여 충돌을 일으켰습니다. 결론은 &lt;strong&gt;컴파일러 경고를 간과해서는 안 된다는 것입니다. 특히 기존 프로젝트에서는 일부 경고가 무시될 수도 있지만, 모든 경고를 차단하는 것은 피해야 합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;환경-설명&#34;&gt;환경 설명
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CentOS 7 GCC 버전:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39)
Copyright © 2015 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CentOS 8 GCC 버전:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 8.5.0 20210514 (Red Hat 8.5.0-21)
Copyright (C) 2018 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;붕괴-현상&#34;&gt;붕괴 현상
&lt;/h3&gt;&lt;p&gt;프로그램 충돌 스택을 분석하는 과정에서 다음과 같은 스택 정보를 확인했습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[New LWP 1385902]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib64/libthread_db.so.1&amp;quot;.
Core was generated by `./pstack_main`.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007ffe894b4420 in ?? ()
(gdb) bt
#0  0x00007ffe894b4420 in ?? ()
#1  0x00000000004008e9 in main ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 스택은 직관적이지 않아 보이고, 충돌 함수의 스택 정보가 &lt;code&gt;??&lt;/code&gt;로 표시되어 있어 문제 해결이 더욱 복잡해졌다&lt;/p&gt;
&lt;h3 id=&#34;코드-예시&#34;&gt;코드 예시
&lt;/h3&gt;&lt;p&gt;문제 이해를 돕기 위해, 오류 재현을 위한 최소 코드 예제는 다음과 같습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int test() {
    std::cout &amp;lt;&amp;lt; &amp;quot;1&amp;quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    test();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;해당 코드의 &lt;code&gt;test()&lt;/code&gt; 함수는 명시적으로 값을 반환하지 않음에도 불구하고, 반환 타입이 &lt;code&gt;int&lt;/code&gt;로 선언되어 있습니다. C++ 규격에 따르면 &lt;code&gt;int&lt;/code&gt; 타입으로 선언된 함수는 반드시 값을 반환해야 하며, 그렇지 않으면 정의되지 않은 동작을 초래할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;컴파일-경고&#34;&gt;컴파일 경고
&lt;/h3&gt;&lt;p&gt;우리 프로젝트에서 CMake 스크립트는 많은 컴파일 시 경고를 비활성화했으며, 그 중에는 다음과 같은 경고 메시지도 포함되어 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/root/pstack/main.cpp: In function ‘int test()’:
/root/pstack/main.cpp:7:1: warning: no return statement in function returning non-void [-Wreturn-type]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 경고는 &lt;code&gt;test()&lt;/code&gt; 함수가 값을 반환하지 않는다는 것을 의미하며, 이것이 문제의 근원입니다. 높은 버전의 GCC(예: 8.5.0)는 코드를 최적화할 때 이러한 정의되지 않은 동작에 대해 불안정한 최적화를 수행하여 프로그램 충돌을 일으킬 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;어셈블리-코드-차이&#34;&gt;어셈블리 코드 차이
&lt;/h3&gt;&lt;p&gt;GCC 컴파일러 최적화 동작의 차이를 설명하기 위해, 우리는 서로 다른 버전의 GCC가 생성한 어셈블리 코드를 비교했습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;GCC 4.8.5가 생성한 어셈블리 코드:&lt;/p&gt;
&lt;p&gt;어셈블리 코드는 다소 장황하며 표준 출력 스트림(예: &lt;code&gt;std::cout&lt;/code&gt;) 처리를 위한 로직을 포함하고 있습니다. 이는 컴파일러가 더 보수적인 최적화를 수행했으며, &lt;code&gt;test()&lt;/code&gt; 함수에서 누락된 반환값 문제에 대한 과도한 최적화를 하지 않았음을 시사합니다. 아마도 이로 인해 프로그램이 충돌하는 것을 피했을 것입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GCC 8.5.0에서 생성된 어셈블리 코드:&lt;/p&gt;
&lt;p&gt;새 버전의 GCC는 더 많은 최적화를 수행하여 코드 양을 줄였습니다. 하지만 이러한 최적화로 인해 반환 값이 없는 함수의 실행 시 동작이 불확실해져 프로그램이 충돌할 수 있습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;결론&#34;&gt;결론
&lt;/h3&gt;&lt;p&gt;이번 문제 해결 과정을 통해, C++에서 &lt;strong&gt;함수 반환 값은 명시적이어야 한다&lt;/strong&gt;는 것을 깊이 인식하게 되었습니다. 특히 함수가 &lt;code&gt;int&lt;/code&gt;로 선언된 경우 반드시 반환 값을 제공해야 합니다. 구 버전 컴파일러를 사용하는 프로젝트의 경우, 최신 버전 GCC로 업그레이드하면 더 많은 최적화와 엄격한 경고 메커니즘을 마주할 수 있습니다. 따라서 컴파일 시 &lt;strong&gt;모든 경고를 숨기지 말고&lt;/strong&gt;, 함수 반환 값, 타입 매칭 등과 같은 일반적인 문제에 대해 선택적으로 처리하는 것을 권장합니다.&lt;/p&gt;
&lt;p&gt;결국, &lt;code&gt;test()&lt;/code&gt; 함수에 반환값을 추가함으로써 문제가 해결되었고 프로그램이 정상적으로 작동하게 되었습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>VMware 가상 머신 CPU 리소스 사용량 이상</title>
        <link>https://ttf248.life/ko/p/vmware-virtual-machine-cpu-resource-usage-anomaly/</link>
        <pubDate>Sun, 10 Mar 2024 22:14:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/vmware-virtual-machine-cpu-resource-usage-anomaly/</guid>
        <description>&lt;p&gt;로컬 머신에 Windows 버전의 업무 시스템이 배포되어 있으며, CPU 자원 사용량은 약 5% 정도입니다. VMware에 설치된 CentOS8에서 Linux 버전의 업무 시스템을 배포했는데, 자원 사용량이 비정상적입니다.&lt;/p&gt;
&lt;h2 id=&#34;문제-설명&#34;&gt;문제 설명
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;호스트 시스템: win10 기업 버전&lt;/li&gt;
&lt;li&gt;vmware：17.5&lt;/li&gt;
&lt;li&gt;가상 머신: CentOS 8&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;가상 머신 리소스 할당은 &lt;code&gt;4C8GB&lt;/code&gt;로 설정하고, 비즈니스 시스템을 시작했습니다. 비즈니스 시스템은 가상 머신 Linux 시스템에 배포되었으며, 내부 top 명령어를 통해 시스템 리소스 사용량을 관찰한 결과 CPU 사용량은 높지 않았습니다. 하지만 외부 Windows 시스템에서 작업 관리자를 통해 확인했을 때 CPU 리소스 사용량이 매우 높았고, 프로세스를 확인해 보니 VMware 프로세스가 CPU 리소스를 많이 사용하고 있었습니다.&lt;/p&gt;
&lt;p&gt;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+
|         Windows           |
|                           |
|   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+  |
|   |      VMware        |  |
|   |      Program       |  |
|   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+  |
|                           |
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+&lt;/p&gt;
&lt;h2 id=&#34;지식점&#34;&gt;지식점
&lt;/h2&gt;&lt;p&gt;이 문제의 원인 분석은 순조롭지 않았는데, 그 이유는 도화선이 비즈니스 시스템 자체가 아니라 가상 머신 자체의 문제였기 때문이다. 어떻게 하면 일반적인 비즈니스 코드에서 벗어나 시스템 부하로 사고를 전환하고, 부하 데이터의 이상 현상을 통해 소프트 인터럽트를 찾아내어 결국 핵심에 다다를 수 있을까? 무엇이 VMware 소프트 인터럽트의 효율성을 저해하는 것일까? 본 논문에서는 먼저 각 지식 포인트를 설명하고 마지막으로 해결책을 제시한다.&lt;/p&gt;
&lt;h3 id=&#34;hyper-v&#34;&gt;hyper-v
&lt;/h3&gt;&lt;p&gt;윈도우 운영 체제의 가상화 기술이 중대한 변화를 겪었습니다. 마이크로소프트가 WSL을 처음 출시했을 때 Hyper-V 서비스를 활성화하면 VMware 가상 머신을 동시에 사용할 수 없었습니다. 이후 버전에서 VMware는 Hyper-V 서비스와 호환되게 되었습니다.&lt;/p&gt;
&lt;h3 id=&#34;시스템-부하&#34;&gt;시스템 부하
&lt;/h3&gt;&lt;p&gt;리눅스 시스템에서 &amp;ldquo;로드(load)&amp;ldquo;는 실행 중이거나 실행을 기다리는 프로세스의 수를 의미합니다. 로드는 일반적으로 1분, 5분, 15분 동안의 실행 대기열에 있는 평균 프로세스 수를 나타내는 세 자리 숫자로 표시됩니다. 이러한 숫자는 &amp;ldquo;uptime&amp;rdquo; 명령이나 &amp;ldquo;top&amp;rdquo; 명령을 실행하여 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;구체적으로 말씀드리면, 이 세 개의 숫자는 각각 다음을 의미합니다:&lt;/p&gt;
&lt;p&gt;1분간의 로드(load): 시스템이 지난 1분 동안 실행 중인 프로세스들의 평균 수량입니다
과거 5분 동안의 평균 실행 프로세스 수입니다
지난 15분 동안 시스템에서 실행 중인 프로세스 평균 수입니다&lt;/p&gt;
&lt;p&gt;부하의 의미는 시스템에서 실행을 기다리는 프로세스 수입니다. 이 숫자가 시스템의 논리 CPU 수보다 높으면 시스템 부하가 높다는 것을 나타내며, 많은 프로세스가 프로세서 리소스를 기다리고 있다는 뜻입니다. 부하 정도와 시스템 구성 및 성능에 따라 시스템이 느려지거나 응답하지 않을 수 있습니다.&lt;/p&gt;
&lt;p&gt;이상적으로는, 부하가 시스템의 논리 CPU 수 범위 내에 유지되어야 시스템 성능을 최적화할 수 있습니다. 부하가 지속적으로 CPU 수보다 높다면, 시스템 내 프로세스를 추가적으로 분석하여 높은 부하를 유발하는 원인을 파악하고, 시스템 리소스 할당을 조정하거나 프로세스 실행 방식을 최적화하기 위한 적절한 조치를 취해야 합니다.&lt;/p&gt;
&lt;h3 id=&#34;mpstat-로드-분석&#34;&gt;mpstat 로드 분석
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;mpstat&lt;/code&gt; 명령은 평균 로드, CPU 사용률, 인터럽트 및 컨텍스트 스위치와 같은 단일 또는 여러 프로세서의 다양한 정보를 보고하는 데 사용됩니다. &lt;code&gt;sysstat&lt;/code&gt; 패키지에서 &lt;code&gt;mpstat&lt;/code&gt;은 시스템 부하를 분석하는 데 유용한 도구입니다. 다음은 &lt;code&gt;mpstat&lt;/code&gt;을 사용하여 부하를 분석하는 단계입니다.&lt;/p&gt;
&lt;p&gt;설치 sysstat
시스템에 &lt;code&gt;sysstat&lt;/code&gt;이 설치되어 있지 않다면, 시스템에 적합한 패키지 관리 도구를 사용하여 설치할 수 있습니다&lt;/p&gt;
&lt;p&gt;mpstat 실행
&lt;code&gt;mpstat&lt;/code&gt; 명령어를 사용하여 CPU 사용률과 부하를 확인합니다. 기본적으로 &lt;code&gt;mpstat&lt;/code&gt;는 CPU 사용률의 평균값을 매초마다 표시합니다. 출력 빈도를 조정하려면 시간 간격을 지정할 수 있습니다. 예를 들어, &lt;code&gt;mpstat -P ALL 2&lt;/code&gt; 명령어를 사용하면 매초마다 한 번씩 실행되며, &lt;code&gt;irq&lt;/code&gt;는 리소스 점유를 나타냅니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```shell
01:32:33 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
01:32:35 PM  all    0.00    0.00    0.26    0.00    3.73    0.26    0.00    0.00    0.00   95.76
01:32:35 PM    0    0.00    0.00    0.51    0.00    3.57    0.00    0.00    0.00    0.00   95.92
01:32:35 PM    1    0.00    0.00    0.00    0.00    3.59    0.51    0.00    0.00    0.00   95.90
01:32:35 PM    2    0.00    0.00    0.00    0.00    4.15    0.00    0.00    0.00    0.00   95.85
01:32:35 PM    3    0.00    0.00    0.52    0.00    3.61    0.52    0.00    0.00    0.00   95.36
```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;분석 결과 출력
mpstat 출력에는 각 CPU의 사용률과 시스템의 평균 부하가 포함됩니다. 평균 부하와 각 CPU의 사용률에 특히 주의를 기울이면 시스템의 부하 상태를 파악하는 데 도움이 됩니다. 부하가 높으면 어떤 프로세스가 원인인지 추가 분석하고 성능 병목 현상이 있는지 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;다른 도구와 결합하세요:
&lt;code&gt;mpstat&lt;/code&gt; 외에도 &lt;code&gt;sar&lt;/code&gt;, &lt;code&gt;pidstat&lt;/code&gt;, &lt;code&gt;iostat&lt;/code&gt; 등의 도구를 사용하여 시스템 성능을 종합적으로 분석할 수 있습니다. 다양한 도구의 출력을 결합하면 시스템 부하를 보다 포괄적으로 파악하고 성능 문제의 근본 원인을 찾아낼 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;중단&#34;&gt;중단
&lt;/h3&gt;&lt;p&gt;여기서는 내용을 너무 자세히 설명하지 않겠습니다
추천: &lt;a class=&#34;link&#34; href=&#34;https://www.codedump.info/post/20200522-sgfap-softirq/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;애플리케이션 개발자를 위한 시스템 가이드 CPU편 - 소프트 인터럽트&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;잦은 소프트웨어 인터럽트 발생은 시스템 부하에도 반영된다&lt;/p&gt;
&lt;h2 id=&#34;문제-해결&#34;&gt;문제 해결
&lt;/h2&gt;&lt;p&gt;CPU 관점에서만 문제를 파악하기 어렵다는 점을 고려할 때, 시스템에 이상이 발생했을 가능성을 의심해 볼 시점일까요? Linux 운영체제의 부하가 과도하여 VMware가 지나치게 많은 CPU 자원을 사용하고 있을 수도 있습니다. &lt;code&gt;mpstat&lt;/code&gt;를 사용하여 로컬 가상 머신을 분석한 결과, &lt;code&gt;irq&lt;/code&gt; 점유율이 비정상적으로 높았고 단일 코어는 약 25%에 달했습니다. 정상적인 상황에서는 비즈니스 프로세스를 시작하지 않은 상태에서 &lt;code&gt;irq&lt;/code&gt; 점유율은 약 5% 정도여야 합니다.&lt;/p&gt;
&lt;p&gt;그룹 내 동료 개발 환경에서 그의 CentOS 7은 VMware에 배포되었으며, 리소스 사용량은 정상적으로 표시됩니다. 반면에 상하이의 개발 환경에서는 동일하게 VMware이지만 호스트 CPU 리소스 상황을 직접 관찰할 수 없습니다. 이때 우리는 VMware 가상 머신, Linux 운영 체제 및 GCC 버전을 포함한 여러 변수를 고려해야 합니다.&lt;/p&gt;
&lt;p&gt;전환하여 테스트 환경을 분석해 보니, 선전의 테스트 환경은 물리 머신에 배포되어 있고, 오래된 버전 GCC 컴파일 서비스가 실행 중이며 CentOS 8 위에서 운영되고 있습니다. 흥미롭게도, 선전 환경에서는 &lt;code&gt;irq&lt;/code&gt; 점유량이 모두 정상입니다.&lt;/p&gt;
&lt;p&gt;문제점을 파악하기 위해 GCC 최신 버전으로 컴파일된 프로그램을 선전 환경에 배포하여 테스트한 결과, 모두 정상 작동하는 것으로 나타났습니다&lt;/p&gt;
&lt;p&gt;문제는 더 명확해지는 듯하고, 우리는 운영체제에 문제가 있는 것은 아닌지 의심하기 시작했다. 결국 CentOS 8은 더 이상 공식 지원을 받지 못한다. 하지만 순수한 CentOS 7과 CentOS 8을 다시 배포해도 문제는 여전히 존재한다.&lt;/p&gt;
&lt;p&gt;지금, 우리는 유일한 불확실 요소인 VMware 가상화 소프트웨어를 의심하기 시작했습니다. 갑자기 아이디어가 떠올랐습니다. Hyper-V 기술은 어떨까요? 혹시 이전에 Hyper-V가 활성화되었지만 완전히 종료되지 않아 이런 문제가 발생했을 수도 있습니다? 결국, 소프트 인터럽트도 가상화 소프트웨어를 통해 구현되니까요. 서로 다른 가상화 기술에 버그는 없는 걸까요? 이러한 문제들은 깊이 생각하고 조사할 가치가 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;결론&#34;&gt;결론
&lt;/h2&gt;&lt;p&gt;마이크로소프트 공식 매뉴얼에 따르면, 로컬 Hyper-V 서비스를 완전히 종료한 후 VMware가 호스트에서 정상적으로 복구되는 것을 확인했습니다. 이렇게 해서 문제 해결이 마침내 순조롭게 진행되었습니다. 처음 설명했듯이 이 경험은 굴곡지고 고되었으며 종합적인 분석과 판단이 필요했습니다. 또한, 이번에 처음으로 문제를 진단하고 가상 머신 수준까지 위치를 특정하게 되었습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Disable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V-Hypervisor
bcdedit /set hypervisorlaunchtype off
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/application-management/virtualization-apps-not-work-with-hyper-v&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/application-management/virtualization-apps-not-work-with-hyper-v&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43; 프로그래밍의 함정: `std::map` 오용으로 인한 프로그램 충돌 상세 분석</title>
        <link>https://ttf248.life/ko/p/cpp-programming-traps-std-map-crash-details/</link>
        <pubDate>Sun, 10 Mar 2024 22:03:06 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/cpp-programming-traps-std-map-crash-details/</guid>
        <description>&lt;p&gt;C++ 프로그래밍에서 &lt;code&gt;std::map&lt;/code&gt; 컨테이너를 잘못 사용하면 프로그램이 충돌할 수 있습니다. 대괄호 연산자를 사용하여 존재하지 않는 키에 접근하려고 하면 자동으로 빈 요소가 추가됩니다. 이 오해를 자세히 분석하고 예제 코드를 통해 잠재적인 위험을 보여드리겠습니다.&lt;/p&gt;
&lt;p&gt;저장하는 값이 단순한 값이라면 문제가 없지만, 포인터를 저장하면 문제가 발생할 수 있습니다. 왜냐하면 포인터는 주소이고, 초기화되지 않으면 해당 주소가 불확실해져 프로그램이 충돌할 수 있기 때문입니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;C++ 표준 라이브러리에서 &lt;code&gt;std::map&lt;/code&gt;은 키(key)를 기준으로 오름차순으로 요소를 저장하는 연관 컨테이너이며, 효율적인 키워드 검색 기능을 제공합니다. 하지만 초보 개발자는 &lt;code&gt;std::map&lt;/code&gt;의 대괄호 연산자 &lt;code&gt;[]&lt;/code&gt;의 동작 방식에 대한 이해 부족으로 어려움을 겪을 수 있습니다. 실제로 &lt;code&gt;[]&lt;/code&gt;를 사용하여 존재하지 않는 키에 접근하면 &lt;code&gt;std::map&lt;/code&gt;은 새로운 키-값 쌍을 삽입하고, 기본 생성자를 사용하여 해당 키에 해당하는 값 타입이 초기화됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int main() {
    std::map&amp;lt;std::string, int&amp;gt; myMap;
    
    // 错误的用法：假设这里试图访问一个不存在的键并认为会得到0
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for &#39;nonexistent_key&#39;: &amp;quot; &amp;lt;&amp;lt; myMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;

    // 实际上，上述行代码创建了一个新的键值对，其中值被默认初始化为int的默认值（通常是0）
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 코드 조각은 프로그램 충돌을 직접적으로 유발하지는 않지만, 이러한 암묵적인 삽입 동작은 특정 상황에서 예상치 못한 부작용을 초래할 수 있습니다. 예를 들어 리소스 누수나 예측 불가능한 상태 변경이 발생할 수 있습니다. 더 나쁜 것은 다중 스레드 환경에서 초기화되지 않은 메모리 영역에 동시에 접근하면 프로그램 충돌로 이어질 수도 있습니다.&lt;/p&gt;
&lt;p&gt;이러한 문제가 발생하는 것을 방지하기 위해 &lt;code&gt;std::map::find()&lt;/code&gt; 또는 &lt;code&gt;std::map::count()&lt;/code&gt; 메서드를 사용하여 키가 존재하는지 확인하거나, &lt;code&gt;std::map::insert()&lt;/code&gt;를 사용하여 명시적으로 요소를 삽입하는 것이 좋습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::map&amp;lt;std::string, int&amp;gt; safeMap;
if (safeMap.count(&amp;quot;nonexistent_key&amp;quot;) == 0) {
    std::cout &amp;lt;&amp;lt; &amp;quot;Key does not exist.&amp;quot; &amp;lt;&amp;lt; std::endl;
} else {
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for existing key: &amp;quot; &amp;lt;&amp;lt; safeMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;
}

// 或者明确插入一个键值对，指定初始值
safeMap.insert({ &amp;quot;new_key&amp;quot;, 0 });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;만약 map 컨테이너 내부에 저장된 객체가 포인터 타입이라면, 자동 삽입 동작은 초기화되지 않은 포인터를 저장하며, 이 포인터에 대한 어떠한 작업도 프로그램 충돌을 야기할 수 있습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>pstack으로 프로세스 멈춤 확인</title>
        <link>https://ttf248.life/ko/p/pstack-troubleshooting-process-hang/</link>
        <pubDate>Sat, 24 Feb 2024 23:55:59 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/pstack-troubleshooting-process-hang/</guid>
        <description>&lt;p&gt;소프트웨어 개발 및 운영 환경에서 프로세스 응답 없음 현상이 자주 발생하는데, 이로 인해 시스템 성능 저하나 서비스 중단이 발생할 수 있습니다. 본 문서에서는 pstack 도구를 사용하여 프로세스 응답 없음 문제를 진단하고, 프로세스의 스택 정보를 분석하여 문제 원인을 파악하고 해결하는 방법을 소개합니다.&lt;/p&gt;
&lt;p&gt;배경: 위험 관리 시스템 하위 서비스가 응답하지 않는 상태로 멈춰 위험 관리 서비스를 사용할 수 없게 되었습니다. 서비스 가용성 모니터링이 부족하여 프로세스가 멈춘 상황을 즉시 파악하지 못했고, 이로 인해 시스템이 사용할 수 없게 되었습니다.&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;프로세스 응답 없음은 프로세스가 응답을 멈춘 상태이지만 종료되지 않은 것을 의미합니다. 이는 데드락, 리소스 고갈, 예외 등 다양한 원인으로 발생할 수 있습니다. 이러한 문제를 해결하기 위해 pstack 도구를 사용하여 프로세스의 스택 정보를 분석하고 문제의 근본 원인을 파악할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;단계&#34;&gt;단계
&lt;/h2&gt;&lt;p&gt;pstack은 일반적으로 gdb(GNU 디버거)와 함께 제공되는 유용한 도구입니다. 다음 명령을 통해 설치할 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt-get install gdb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;프로세스 ID 획득: 먼저, 응답하지 않는 프로세스의 프로세스 ID(PID)를 얻어야 합니다. ps 명령어를 사용하여 모든 프로세스를 나열하고 문제 해결이 필요한 프로세스 ID를 찾을 수 있습니다.
pstack 도구를 사용하여 프로세스 스택을 분석하고, 일단 프로세스 ID를 얻으면 pstack 도구를 사용하여 해당 프로세스의 스택 정보를 가져올 수 있습니다. 다음 명령어를 실행하세요:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pstack &amp;lt;PID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 프로세스의 스택 정보를 출력하여 현재 실행 중인 함수 호출 시퀀스를 표시합니다. 이러한 정보를 분석하면 프로세스가 멈춘 위치를 파악하고 문제를 진단할 수 있습니다.&lt;/p&gt;
&lt;p&gt;스택 정보를 분석하면 프로세스가 멈추는 원인을 파악할 수 있습니다. 데드락, 무한 루프 또는 기타 예외 상황이 발견될 수 있습니다. 구체적인 상황에 따라 잠금을 해제하거나 코드 로직을 수정하는 등의 조치를 취하십시오.&lt;/p&gt;
&lt;h2 id=&#34;사례&#34;&gt;사례
&lt;/h2&gt;&lt;p&gt;간단한 데모인데, 메인 함수가 시작된 후 서브 스레드를 새로 만들고 실제 실행 함수에 들어가면 무한 루프에 빠져 프로그램이 정상적으로 종료되지 않고 멈춰버리는 상태입니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cmake_minimum_required(VERSION 3.0.0)
project(pstack_main VERSION 0.1.0 LANGUAGES C CXX)

include(CTest)
enable_testing()

# 查找线程库
find_package(Threads REQUIRED)

add_executable(pstack_main main.cpp)

# 链接线程库
target_link_libraries(pstack_main PRIVATE Threads::Threads)

set(CPACK_PROJECT_NAME ${PROJECT_NAME})
set(CPACK_PROJECT_VERSION ${PROJECT_VERSION})
include(CPack)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;
#include &amp;lt;chrono&amp;gt;

void infiniteLoop() {
    while (true) {
        // 主线程进入死循环
    }
}

int main() {
    std::thread thread(infiniteLoop); // 创建一个线程，执行死循环函数
    thread.join(); // 等待线程结束
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;프로그램을 시작하고 pstack 결과를 실행합니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Thread 2 (Thread 0x7eff3619b700 (LWP 1315017)):
#0  infiniteLoop () at /root/pstack/main.cpp:6
#1  0x0000000000402ca9 in std::__invoke_impl&amp;lt;void, void (*)()&amp;gt; (__f=@0x2260eb8: 0x4029a6 &amp;lt;infiniteLoop()&amp;gt;) at /usr/include/c++/8/bits/invoke.h:60
#2  0x0000000000402b02 in std::__invoke&amp;lt;void (*)()&amp;gt; (__fn=@0x2260eb8: 0x4029a6 &amp;lt;infiniteLoop()&amp;gt;) at /usr/include/c++/8/bits/invoke.h:95
#3  0x0000000000403150 in std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt;::_M_invoke&amp;lt;0ul&amp;gt; (this=0x2260eb8) at /usr/include/c++/8/thread:244
#4  0x0000000000403126 in std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt;::operator() (this=0x2260eb8) at /usr/include/c++/8/thread:253
#5  0x000000000040310a in std::thread::_State_impl&amp;lt;std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt; &amp;gt;::_M_run (this=0x2260eb0) at /usr/include/c++/8/thread:196
#6  0x00007eff36bceb23 in execute_native_thread_routine () from /lib64/libstdc++.so.6
#7  0x00007eff36ea91ca in start_thread () from /lib64/libpthread.so.0
#8  0x00007eff361d58d3 in clone () from /lib64/libc.so.6
Thread 1 (Thread 0x7eff372e1740 (LWP 1315016)):
#0  0x00007eff36eaa6cd in __pthread_timedjoin_ex () from /lib64/libpthread.so.0
#1  0x00007eff36bceda7 in std::thread::join() () from /lib64/libstdc++.so.6
#2  0x00000000004029d2 in main () at /root/pstack/main.cpp:13
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;볼 수 있듯이, 프로세스가 멈춘 이유는 무한 루프 때문입니다. 메인 스레드가 무한 루프에 진입하고, 서브 스레드가 종료되지 않아 프로세스가 멈춥니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43; 함수 호출 시간</title>
        <link>https://ttf248.life/ko/p/cpp-function-call-timing/</link>
        <pubDate>Wed, 24 Jan 2024 14:11:33 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/cpp-function-call-timing/</guid>
        <description>&lt;p&gt;다양한 콜백 함수 구현 방식에 맞춰 디자인 시나리오 SDK를 테스트하는 데 많은 시간이 소요되었습니다. 최근 C++ 함수 프로그래밍을 살펴보고 있는데, 함수가 일급 시민이 되어 프로그램 내부에서 자유롭게 흐르는 경우 성능 차이가 있나요?&lt;/p&gt;
&lt;p&gt;이전 링크: [컴파일러, 콜백 함수, 성능 테스트]({&amp;lt; relref &amp;ldquo;/post/2023/02-15-컴파일러、콜백 함수、성능 테스트&amp;rdquo; &amp;gt;}})&lt;/p&gt;
&lt;p&gt;레이마오 대장도 비슷한 테스트를 해서 코드를 빌려 썼다&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;실행 플랫폼은 여전히 우리의 오랜 친구, &lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt; 입니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;cassert&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

int add_one(int input) { return input + 1; }

bool validate_vector_add_one(std::vector&amp;lt;int&amp;gt; const&amp;amp; input_vector,
                             std::vector&amp;lt;int&amp;gt; const&amp;amp; output_vector)
{
    bool is_valid{true};
    for (size_t i{0}; i &amp;lt; input_vector.size(); ++i)
    {
        if (output_vector.at(i) != input_vector.at(i) + 1)
        {
            is_valid = false;
            break;
        }
    }
    return is_valid;
}

void reset_vector(std::vector&amp;lt;int&amp;gt;&amp;amp; input_vector)
{
    for (size_t i{0}; i &amp;lt; input_vector.size(); ++i)
    {
        input_vector.at(i) = 0;
    }
}

template &amp;lt;typename T, typename Func&amp;gt;
void unitary_function_pass_by_lambda_function(T&amp;amp; output, T const&amp;amp; input,
                                              Func const func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_std_function_value(T&amp;amp; output, T const&amp;amp; input,
                                                 std::function&amp;lt;T(T)&amp;gt; const func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_std_function_reference(
    T&amp;amp; output, T const&amp;amp; input, std::function&amp;lt;T(T)&amp;gt; const&amp;amp; func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_function_pointer(T&amp;amp; output, T const&amp;amp; input,
                                               T (*func)(T))
{
    output = func(input);
}

int main()
{
    // Set floating point format std::cout with 3 decimal places.
    std::cout.precision(3);

    size_t const num_elements{10000000};
    std::vector&amp;lt;int&amp;gt; input_vector(num_elements, 0);
    std::vector&amp;lt;int&amp;gt; output_vector(num_elements, 0);

    auto const lambda_function_add_one{[](int const&amp;amp; input) -&amp;gt; int
                                       { return input + 1; }};
    std::function&amp;lt;int(int)&amp;gt; const std_function_add_one{lambda_function_add_one};

    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a function pointer: &amp;quot; &amp;lt;&amp;lt; sizeof(&amp;amp;add_one)
              &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a std::function pointer: &amp;quot;
              &amp;lt;&amp;lt; sizeof(&amp;amp;std_function_add_one) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a std::function: &amp;quot; &amp;lt;&amp;lt; sizeof(std_function_add_one)
              &amp;lt;&amp;lt; std::endl;

    // Call function frequently in a vanilla way.
    // The compiler knows what function to call at compile time and can optimize
    // the code.
    // This is the best performance we could get.
    std::chrono::steady_clock::time_point const time_start_vanilla{
        std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        output_vector.at(i) = add_one(input_vector.at(i));
    }
    std::chrono::steady_clock::time_point const time_end_vanilla{
        std::chrono::steady_clock::now()};
    auto const time_elapsed_vanilla{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(time_end_vanilla -
                                                             time_start_vanilla)
            .count()};
    float const latency_vanilla{time_elapsed_vanilla /
                                static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass Vanilla: &amp;quot; &amp;lt;&amp;lt; latency_vanilla &amp;lt;&amp;lt; &amp;quot; ns&amp;quot;
              &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // Sometimes, we don&#39;t know what function to call at compile time.
    // We can use std::function to pass a function as an argument.
    // In this case, we pass the std::function by value.
    // Because the size of a std::function is 32 bytes, passing by value
    // results in a lot of copying and bad performance.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_std_function_value{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_std_function_value(
            output_vector.at(i), input_vector.at(i), std_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_std_function_value{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_std_function_value{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_std_function_value -
            time_start_pass_by_std_function_value)
            .count()};
    float const latency_pass_by_std_function_value{
        time_elapsed_pass_by_std_function_value /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Std Function Value: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_std_function_value &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // Instead of passing the std::function by value, we can pass it by
    // reference (pointer). In this case, object copying is eliminated. The
    // performance is better than passing the std::function by value. However,
    // the performance is still not as good as the vanilla way.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_std_function_reference{
            std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_std_function_reference(
            output_vector.at(i), input_vector.at(i), std_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_std_function_reference{
            std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_std_function_reference{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_std_function_reference -
            time_start_pass_by_std_function_reference)
            .count()};
    float const latency_pass_by_std_function_reference{
        time_elapsed_pass_by_std_function_reference /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Std Function Reference: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_std_function_reference &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // std::function is a general purpose wrapper for function pointers,
    // callable objects, and lambda functions. Because it&#39;s general purpose,
    // it&#39;s not as efficient as a function pointer. In this case, we pass a
    // function pointer to a function. The performance is better than passing
    // the std::function by reference.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_function_pointer{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_function_pointer(output_vector.at(i),
                                                  input_vector.at(i), &amp;amp;add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_function_pointer{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_function_pointer{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_function_pointer -
            time_start_pass_by_function_pointer)
            .count()};
    float const latency_pass_by_function_pointer{
        time_elapsed_pass_by_function_pointer /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Function Pointer: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_function_pointer &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // We can also pass a lambda function to a function.
    // The compiler knows what function to call at compile time and can optimize
    // the code. The performance is also better than passing the std::function
    // by reference.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_lambda_function{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_lambda_function(
            output_vector.at(i), input_vector.at(i), lambda_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_lambda_function{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_lambda_function{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_lambda_function -
            time_start_pass_by_lambda_function)
            .count()};
    float const latency_pass_by_lambda_function{
        time_elapsed_pass_by_lambda_function /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Lambda Function: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_lambda_function &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 组里常规也就开启 O2 优化，编译选用了 gcc13，不同版本的 gcc 性能耗时略有不同，版本越高 lambda 效果越好
The size of a function pointer: 8
The size of a std::function pointer: 8
The size of a std::function: 32
Latency Pass Vanilla: 0.418 ns
Latency Pass By Std Function Value: 3.47 ns
Latency Pass By Std Function Reference: 1.36 ns
Latency Pass By Function Pointer: 0.396 ns
Latency Pass By Lambda Function: 0.44 ns
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leimao.github.io/blog/CPP-Function-Call-Performance/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://leimao.github.io/blog/CPP-Function-Call-Performance/&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>프로그램이 디버깅을 어떻게 회피하는가</title>
        <link>https://ttf248.life/ko/p/program-how-to-anti-debug/</link>
        <pubDate>Tue, 23 Jan 2024 19:46:36 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/program-how-to-anti-debug/</guid>
        <description>&lt;p&gt;뜻밖에도 벽지 새로 해보자는 생각이 들어서, 평소 검은색 계열을 선호하는지라 부분적으로 색상을 넣고 싶어요. 바탕화면에는 아이콘을 배치해야 해서 다른 색상으로 배경을 설정하면 아이콘이 잘 보이지 않네요.&lt;/p&gt;
&lt;p&gt;위 어셈블리 코드에 대해 잠시 생각해 보았는데, 무슨 뜻인지 모르겠어. AI에게 시도해 봤더니 명령어를 설명은 했지만 상황은 설명하지 않았고, 분명히 특정 상황에서 사용되는 명령어일 것이다. 일반적인 코드는 이런 방식이 아니다.&lt;/p&gt;
&lt;p&gt;AI는 현재 검색 엔진보다 낫지 않다, 어셈블리의 지식 저장량은 부족하다&lt;/p&gt;
&lt;h2 id=&#34;벽지&#34;&gt;벽지
&lt;/h2&gt;&lt;p&gt;검은색 조립 벽지&lt;/p&gt;
&lt;h2 id=&#34;어셈블리-코드&#34;&gt;어셈블리 코드
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;PUSHFD
MOV DWORD PTR [ESP],0X100
POPFD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;실제 사용 시나리오&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool IsDebugged()
{
    __try
    {
        __asm
        {
            pushfd
            mov dword ptr [esp], 0x100
            popfd
            nop
        }
        return true;
    }
    __except(GetExceptionCode() == EXCEPTION_SINGLE_STEP
        ? EXCEPTION_EXECUTE_HANDLER
        : EXCEPTION_CONTINUE_EXECUTION)
    {
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;설명&#34;&gt;설명
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;TrapFlag&lt;/code&gt;은 플래그 레지스터 내의 플래그 비트이며, 이 플래그 비트가 설정되면 예외 &lt;code&gt;SINGLE_STEP&lt;/code&gt;이 발생합니다. 왜냐하면 우리가 코드를 추적할 때 디버거가 이 플래그 비트를 초기화하기 때문에 이 예외를 볼 수 없기 때문입니다.&lt;/p&gt;
&lt;p&gt;실제 테스트 시 발견한 내용인데, 검사 디버깅 함수를 직접 건너뛰면 디버깅이 감지되지 않고, 검사 함수 실행에 들어가야만 감지된다 (자료 조사 중이며 아직 실제 확인은 되지 않음)&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;p&gt;관련 자료는 모두 웹사이트의 영어 원문을 번역한 것이며, 해당 사이트는 다양한 디버깅 방지 기술을 설명하고 있습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://anti-debug.checkpoint.com/techniques/assembly.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://anti-debug.checkpoint.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://song-10.gitee.io/2021/08/08/Reverse-2021-08-08-anti-debug/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://song-10.gitee.io/2021/08/08/Reverse-2021-08-08-anti-debug/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>초점 인터뷰/CCTV 비디오 파일을 어떻게 다운로드하나요?</title>
        <link>https://ttf248.life/ko/p/how-to-download-focus-interview-cctv-video-files/</link>
        <pubDate>Tue, 23 Jan 2024 19:23:35 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/how-to-download-focus-interview-cctv-video-files/</guid>
        <description>&lt;p&gt;최근에 사람들이 &amp;ldquo;집중 인터뷰&amp;rdquo; 비디오를 어떻게 다운로드하는지 물어보는데, 머리로는 거의 대부분이 &lt;code&gt;m3u8&lt;/code&gt; 방식으로 암호화되어 있을 거라고 생각하고 있었고, 간단히 처리했다&lt;/p&gt;
&lt;h2 id=&#34;다운로더&#34;&gt;다운로더
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/nilaoda/N_m3u8DL-CLI&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/nilaoda/N_m3u8DL-CLI&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;m3u8 다운로더 오픈소스 명령줄 m3u8/HLS/dash 다운로더입니다. 일반적인 AES-128-CBC 복호화, 멀티 스레드, 사용자 지정 헤더 등을 지원합니다. 중국어 간체, 중국어 번체 및 영어를 지원합니다. 영어 지원.&lt;/p&gt;
&lt;h2 id=&#34;브라우저-플러그인&#34;&gt;브라우저 플러그인
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://microsoftedge.microsoft.com/addons/detail/ngjclnbcdbahekojpkhancmiobdahemb&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Live Stream Downloader&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;꿀-같은-자신감&#34;&gt;꿀 같은 자신감
&lt;/h2&gt;&lt;p&gt;주소를 받았다고 생각했는데, оказалось ничего не получилось. 분할 내용을 정상적으로 파싱할 수 없었고, 자료를 검색해 보니 공식에서 다운로드 주소를 처리해서, 플러그인이 파싱한 &lt;code&gt;key&lt;/code&gt;를 아래 링크에 수동으로 복사하여 교체해야 한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;https://newcntv.qcloudcdn.com/asp/hls/2000/0303000a/3/default/***********************/2000.m3u8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2024년 1월까지 주소 테스트가 유효합니다. 이후 변경 사항이 있으면 웹페이지를 직접 분석하십시오.&lt;/p&gt;
&lt;p&gt;이전 주소 백업: &lt;code&gt;https://hlswx.cntv.kcdnvip.com/asp/hls/main/0303000a/3/default/일련의 문자/main.m3u8?maxbr=2000&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://jln.cn/post/517.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://jln.cn/post/517.html&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>SQL Server 데이터베이스 디스크 파일 권한 일괄 수정</title>
        <link>https://ttf248.life/ko/p/bulk-modify-sqlserver-database-disk-file-permissions/</link>
        <pubDate>Tue, 23 Jan 2024 19:06:36 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/bulk-modify-sqlserver-database-disk-file-permissions/</guid>
        <description>&lt;p&gt;회사 보안 정책 변경으로, &lt;code&gt;메카닉 미니&lt;/code&gt;는 결국 백업 서버로 집으로 이사했고, 시스템을 재설치했습니다. &lt;code&gt;우분투&lt;/code&gt;에서 &lt;code&gt;윈도우 서버&lt;/code&gt;로 전환했는데, 활성화 방법이 정규적이지 않아서, 집에서는 활성화하지 않아도 괜찮은 것 같습니다.&lt;/p&gt;
&lt;p&gt;비정상적인 방식으로 활성화하여 마이크로소프트의 검사를 트리거했습니다(반달 동안 정상적으로 실행됨). 서버는 1시간 동안 켜져 있다가 자동으로 종료되었고, 시스템 로그를 뒤지니 불법 복제본으로 인한 문제였습니다.&lt;/p&gt;
&lt;p&gt;방법이 없네요, 시스템을 다시 설치해야 하고, &lt;code&gt;SqlServer&lt;/code&gt;도 재설치를 해야 합니다. 할 때마다 골치 아픈데, 파일 권한 관리가 엄격해서 데이터베이스를 정상적으로 추가할 수 없습니다.&lt;/p&gt;
&lt;h2 id=&#34;오류-정보&#34;&gt;오류 정보
&lt;/h2&gt;&lt;p&gt;시스템을 재설치한 후, &lt;code&gt;SqlServer&lt;/code&gt;가 데이터베이스를 첨부하는 과정에서 5120 오류 및 운영체제의 액세스 거부 문제가 발생할 수 있습니다&lt;/p&gt;
&lt;h2 id=&#34;스크립트-처리&#34;&gt;스크립트 처리
&lt;/h2&gt;&lt;p&gt;이전 링크: &lt;a class=&#34;link&#34; href=&#34;https://ttf248.life/ko/p/bulk-update-local-git-repository-and-legacy-permission-issues/&#34; &gt;로컬 Git 저장소 일괄 업데이트&lt;/a&gt;, 물론 또 이 익숙한 스크립트입니다. 폴더를 순회하면서 파일의 권한을 수정하도록 변경했는데, 현재는 완전 편집 권한을 가지고 있습니다.&lt;/p&gt;
&lt;p&gt;온라인 튜토리얼은 대부분 수동으로 수정하도록 시키는데, 그들은 겨우 몇 개의 파일만 수정하는 건가? 나는 매번 일괄적으로 파일을 처리해야 하고, 전부 수동으로 하려니 사람이 지쳐 쓰러질 것 같아&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$currentUserName = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8
$rootDirectory = &amp;quot;D:\data\2013_RujiaInfo&amp;quot;

Get-ChildItem -Path $rootDirectory -Recurse | ForEach-Object {
    $itemPath = $_.FullName

    if ($_ -is [System.IO.DirectoryInfo]) {
        $icaclsResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            Write-Host &amp;quot;已更改文件夹 $itemPath 的所有者为 $currentUserName&amp;quot;
            # 授予当前用户写入权限
            Invoke-Expression &amp;quot;icacls `&amp;quot;$itemPath`&amp;quot; /grant `&amp;quot;$($currentUserName):(OI)(CI)F`&amp;quot;&amp;quot;
            Write-Host &amp;quot;已授予 $currentUserName 编辑文件夹的权限&amp;quot;
        } else {
            Write-Host &amp;quot;无法更改文件夹 $itemPath 的所有者。错误信息: $icaclsResult&amp;quot;
        }
    } else {
        $takeownResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            # 授予当前用户写入权限
            Invoke-Expression &amp;quot;icacls `&amp;quot;$itemPath`&amp;quot; /grant `&amp;quot;$($currentUserName):(F)`&amp;quot;&amp;quot;
            Write-Host &amp;quot;已授予 $currentUserName 编辑文件的权限&amp;quot;
        } else {
            Write-Host &amp;quot;无法更改文件 $itemPath 的所有者。错误信息: $takeownResult&amp;quot;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>리눅스 시스템 벤치마크 테스트</title>
        <link>https://ttf248.life/ko/p/linux-system-benchmark-test/</link>
        <pubDate>Tue, 09 Jan 2024 10:56:23 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/linux-system-benchmark-test/</guid>
        <description>&lt;p&gt;윈도우 플랫폼에는 루마스터(유희 마스터)라는 프로그램이 있는데, 데이터가 아주 정확하다고는 할 수 없지만 대략적인 참고 자료로 쓸 수는 있습니다. 물론 다른 전문 벤치마크 소프트웨어도 있고, 리눅스 시스템에서는 특별히 적합한 벤치마크 프로그램을 아직 못 찾았습니다.&lt;/p&gt;
&lt;p&gt;Sysbench는 CPU, 메모리, 파일 I/O, 스레드 성능 등을 테스트할 수 있는 다목적 벤치마크 도구입니다. 다양한 성능 테스트 작업을 수행하기 위해 Sysbench를 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;손에 있는 테스트용 장비가 세 대 있는데, 메커니컬 미니 로컬 호스트, 알리바바 클라우드 개발 클라우드 서버, 화웨이 클라우드 개발 서버가 있습니다&lt;/p&gt;
&lt;h2 id=&#34;sysbench-설치&#34;&gt;Sysbench 설치
&lt;/h2&gt;&lt;p&gt;대부분의 Linux 배포판에서 패키지 관리 도구를 사용하여 Sysbench를 설치할 수 있습니다. 예를 들어 CentOS 8에서는 다음 명령어를 사용하여 설치할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo dnf install sysbench
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sysbench-사용-예시&#34;&gt;Sysbench 사용 예시
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CPU 성능 테스트: &lt;code&gt;sysbench --test=cpu run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;메모리 읽기 성능 테스트: &lt;code&gt;sysbench --test=memory run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;테스트 파일 I/O 성능:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysbench --test=fileio --file-test-mode=rndrw prepare
sysbench --test=fileio --file-test-mode=rndrw run
sysbench --test=fileio --file-test-mode=rndrw cleanup
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;멀티 스레드 성능 테스트: &lt;code&gt;sysbench --test=threads --num-threads=4 실행&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;MySQL 데이터베이스 성능 테스트(데이터베이스 최대 연결 수 조정 필요):&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword --oltp-table-size=1000000 prepare
sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword --max-time=60 --oltp-read-only=off --oltp-test-mode=complex --max-requests=0 run
sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword cleanup
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;분포-데이터-보고서&#34;&gt;분포 데이터 보고서
&lt;/h2&gt;&lt;meta http-equiv=&#34;Content-Type&#34; content=&#34;text/html; charset=utf-8&#34;&gt;&lt;link type=&#34;text/css&#34; rel=&#34;stylesheet&#34; href=&#34;resources/sheet.css&#34; &gt;
&lt;style type=&#34;text/css&#34;&gt;.ritz .waffle a { color: inherit; }.ritz .waffle .s0{background-color:#ffffff;text-align:left;color:#000000;font-family:&#39;Arial&#39;;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}&lt;/style&gt;&lt;div class=&#34;ritz grid-container&#34; dir=&#34;ltr&#34;&gt;&lt;table class=&#34;waffle&#34; cellspacing=&#34;0&#34; cellpadding=&#34;0&#34;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th class=&#34;row-header freezebar-origin-ltr&#34;&gt;&lt;/th&gt;&lt;th id=&#34;0C0&#34; style=&#34;width:100px;&#34; class=&#34;column-headers-background&#34;&gt;A&lt;/th&gt;&lt;th id=&#34;0C1&#34; style=&#34;width:421px;&#34; class=&#34;column-headers-background&#34;&gt;B&lt;/th&gt;&lt;th id=&#34;0C2&#34; style=&#34;width:398px;&#34; class=&#34;column-headers-background&#34;&gt;C&lt;/th&gt;&lt;th id=&#34;0C3&#34; style=&#34;width:422px;&#34; class=&#34;column-headers-background&#34;&gt;D&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R0&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;1&lt;/div&gt;&lt;/th&gt;&lt;td&gt;&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;本地机械师&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;阿里云&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;华为云&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R1&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;2&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;系统配置&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;System Information&lt;br&gt;  Operating System              Ubuntu 23.04&lt;br&gt;  Kernel                        Linux 6.2.0-36-generic x86_64&lt;br&gt;  Model                         Machenike Machenike DT Computer&lt;br&gt;  Motherboard                   Machenike Machenike DT Computer&lt;br&gt;  BIOS                          American Megatrends International, LLC.&lt;br&gt;DB19V012&lt;br&gt;&lt;br&gt;CPU Information&lt;br&gt;  Name                          Intel Core i7-12650H&lt;br&gt;  Topology                      1 Processor, 10 Cores, 16 Threads&lt;br&gt;  Identifier                    GenuineIntel Family 6 Model 154 Stepping 3&lt;br&gt;  Base Frequency                4.60 GHz&lt;br&gt;  L1 Instruction Cache          32.0 KB x 8&lt;br&gt;  L1 Data Cache                 48.0 KB x 8&lt;br&gt;  L2 Cache                      1.25 MB x 2&lt;br&gt;  L3 Cache                      24.0 MB&lt;br&gt;&lt;br&gt;Memory Information&lt;br&gt;  Size                          62.6 GB&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;System Information&lt;br&gt;  Operating System              CentOS Stream 8&lt;br&gt;  Kernel                        Linux 4.18.0-513.el8.x86_64 x86_64&lt;br&gt;  Model                         Alibaba Cloud Alibaba Cloud ECS&lt;br&gt;  Motherboard                   N/A&lt;br&gt;  BIOS                          SeaBIOS 449e491&lt;br&gt;&lt;br&gt;CPU Information&lt;br&gt;  Name                          Intel(R) Xeon(R) Platinum&lt;br&gt;  Topology                      1 Processor, 1 Core, 2 Threads&lt;br&gt;  Identifier                    GenuineIntel Family 6 Model 85 Stepping 4&lt;br&gt;  Base Frequency                2.50 GHz&lt;br&gt;  L1 Instruction Cache          32.0 KB&lt;br&gt;  L1 Data Cache                 32.0 KB&lt;br&gt;  L2 Cache                      1.00 MB&lt;br&gt;  L3 Cache                      33.0 MB&lt;br&gt;&lt;br&gt;Memory Information&lt;br&gt;  Size                          1.65 GB&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;System Information&lt;br&gt;  Operating System              Ubuntu 22.04.1 LTS&lt;br&gt;  Kernel                        Linux 5.15.0-60-generic x86_64&lt;br&gt;  Model                         OpenStack Foundation OpenStack Nova&lt;br&gt;  Motherboard                   N/A&lt;br&gt;  BIOS                          SeaBIOS&lt;br&gt;rel-1.10.2-0-g5f4c7b1-20181220_000000-szxrtosci10000&lt;br&gt;&lt;br&gt;CPU Information&lt;br&gt;  Name                          Intel(R) Xeon(R) Gold 6278C CPU @ 2.60GHz&lt;br&gt;  Topology                      1 Processor, 1 Core, 2 Threads&lt;br&gt;  Identifier                    GenuineIntel Family 6 Model 85 Stepping 7&lt;br&gt;  Base Frequency                2.60 GHz&lt;br&gt;  L1 Instruction Cache          32.0 KB&lt;br&gt;  L1 Data Cache                 32.0 KB&lt;br&gt;  L2 Cache                      1.00 MB&lt;br&gt;  L3 Cache                      35.8 MB&lt;br&gt;&lt;br&gt;Memory Information&lt;br&gt;  Size                          3.64 GB&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R2&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;3&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;CPU&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Prime numbers limit: 10000&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;CPU speed:&lt;br&gt;    events per second:  4032.48&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0004s&lt;br&gt;    total number of events:              40330&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.25&lt;br&gt;         avg:                                    0.25&lt;br&gt;         max:                                    0.73&lt;br&gt;         95th percentile:                        0.25&lt;br&gt;         sum:                                 9997.55&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           40330.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9975/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Prime numbers limit: 10000&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;CPU speed:&lt;br&gt;    events per second:  1062.51&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0008s&lt;br&gt;    total number of events:              10628&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.91&lt;br&gt;         avg:                                    0.94&lt;br&gt;         max:                                   22.84&lt;br&gt;         95th percentile:                        1.06&lt;br&gt;         sum:                                 9993.46&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           10628.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9935/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Prime numbers limit: 10000&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;CPU speed:&lt;br&gt;    events per second:  1125.56&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0005s&lt;br&gt;    total number of events:              11258&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.86&lt;br&gt;         avg:                                    0.89&lt;br&gt;         max:                                    1.70&lt;br&gt;         95th percentile:                        0.99&lt;br&gt;         sum:                                 9995.40&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           11258.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9954/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R3&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;4&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;内存&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Running memory speed test with the following options:&lt;br&gt;  block size: 1KiB&lt;br&gt;  total size: 102400MiB&lt;br&gt;  operation: write&lt;br&gt;  scope: global&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;Total operations: 101993199 (10198146.52 per second)&lt;br&gt;&lt;br&gt;99602.73 MiB transferred (9959.13 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0001s&lt;br&gt;    total number of events:              101993199&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.00&lt;br&gt;         max:                                    0.03&lt;br&gt;         95th percentile:                        0.00&lt;br&gt;         sum:                                 4059.50&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           101993199.0000/0.00&lt;br&gt;    execution time (avg/stddev):   4.0595/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Running memory speed test with the following options:&lt;br&gt;  block size: 1KiB&lt;br&gt;  total size: 102400MiB&lt;br&gt;  operation: write&lt;br&gt;  scope: global&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;Total operations: 48418803 (4841004.79 per second)&lt;br&gt;&lt;br&gt;47283.99 MiB transferred (4727.54 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0001s&lt;br&gt;    total number of events:              48418803&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.00&lt;br&gt;         max:                                   25.26&lt;br&gt;         95th percentile:                        0.00&lt;br&gt;         sum:                                 4578.95&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           48418803.0000/0.00&lt;br&gt;    execution time (avg/stddev):   4.5789/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Running memory speed test with the following options:&lt;br&gt;  block size: 1KiB&lt;br&gt;  total size: 102400MiB&lt;br&gt;  operation: write&lt;br&gt;  scope: global&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;Total operations: 57056904 (5704765.11 per second)&lt;br&gt;&lt;br&gt;55719.63 MiB transferred (5571.06 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0001s&lt;br&gt;    total number of events:              57056904&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.00&lt;br&gt;         max:                                    0.06&lt;br&gt;         95th percentile:                        0.00&lt;br&gt;         sum:                                 4556.06&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           57056904.0000/0.00&lt;br&gt;    execution time (avg/stddev):   4.5561/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R4&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;5&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;硬盘&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;2147483648 bytes written in 1.81 seconds (1129.59 MiB/sec).&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Extra file open flags: (none)&lt;br&gt;128 files, 16MiB each&lt;br&gt;2GiB total file size&lt;br&gt;Block size 16KiB&lt;br&gt;Number of IO requests: 0&lt;br&gt;Read/Write ratio for combined random IO test: 1.50&lt;br&gt;Periodic FSYNC enabled, calling fsync() each 100 requests.&lt;br&gt;Calling fsync() at the end of test, Enabled.&lt;br&gt;Using synchronous I/O mode&lt;br&gt;Doing random r/w test&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;File operations:&lt;br&gt;    reads/s:                      3373.41&lt;br&gt;    writes/s:                     2248.94&lt;br&gt;    fsyncs/s:                     7201.80&lt;br&gt;&lt;br&gt;Throughput:&lt;br&gt;    read, MiB/s:                  52.71&lt;br&gt;    written, MiB/s:               35.14&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0127s&lt;br&gt;    total number of events:              128288&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.08&lt;br&gt;         max:                                    5.14&lt;br&gt;         95th percentile:                        0.34&lt;br&gt;         sum:                                 9977.78&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           128288.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9778/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;2147483648 bytes written in 19.29 seconds (106.16 MiB/sec).&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Extra file open flags: (none)&lt;br&gt;128 files, 16MiB each&lt;br&gt;2GiB total file size&lt;br&gt;Block size 16KiB&lt;br&gt;Number of IO requests: 0&lt;br&gt;Read/Write ratio for combined random IO test: 1.50&lt;br&gt;Periodic FSYNC enabled, calling fsync() each 100 requests.&lt;br&gt;Calling fsync() at the end of test, Enabled.&lt;br&gt;Using synchronous I/O mode&lt;br&gt;Doing random r/w test&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;File operations:&lt;br&gt;    reads/s:                      1593.12&lt;br&gt;    writes/s:                     1062.08&lt;br&gt;    fsyncs/s:                     3406.64&lt;br&gt;&lt;br&gt;Throughput:&lt;br&gt;    read, MiB/s:                  24.89&lt;br&gt;    written, MiB/s:               16.60&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0164s&lt;br&gt;    total number of events:              60600&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.16&lt;br&gt;         max:                                   31.32&lt;br&gt;         95th percentile:                        0.54&lt;br&gt;         sum:                                 9956.30&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           60600.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9563/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;2147483648 bytes written in 18.29 seconds (111.98 MiB/sec).&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Extra file open flags: (none)&lt;br&gt;128 files, 16MiB each&lt;br&gt;2GiB total file size&lt;br&gt;Block size 16KiB&lt;br&gt;Number of IO requests: 0&lt;br&gt;Read/Write ratio for combined random IO test: 1.50&lt;br&gt;Periodic FSYNC enabled, calling fsync() each 100 requests.&lt;br&gt;Calling fsync() at the end of test, Enabled.&lt;br&gt;Using synchronous I/O mode&lt;br&gt;Doing random r/w test&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;File operations:&lt;br&gt;    reads/s:                      1665.88&lt;br&gt;    writes/s:                     1110.59&lt;br&gt;    fsyncs/s:                     3563.77&lt;br&gt;&lt;br&gt;Throughput:&lt;br&gt;    read, MiB/s:                  26.03&lt;br&gt;    written, MiB/s:               17.35&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0112s&lt;br&gt;    total number of events:              63355&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.16&lt;br&gt;         max:                                  205.01&lt;br&gt;         95th percentile:                        0.78&lt;br&gt;         sum:                                 9972.64&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           63355.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9726/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R5&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;6&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;多线程&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 4&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0002s&lt;br&gt;    total number of events:              197956&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.16&lt;br&gt;         avg:                                    0.20&lt;br&gt;         max:                                    0.34&lt;br&gt;         95th percentile:                        0.21&lt;br&gt;         sum:                                39970.47&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           49489.0000/5.70&lt;br&gt;    execution time (avg/stddev):   9.9926/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 4&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0174s&lt;br&gt;    total number of events:              18360&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.57&lt;br&gt;         avg:                                    2.18&lt;br&gt;         max:                                   32.77&lt;br&gt;         95th percentile:                        2.61&lt;br&gt;         sum:                                40050.41&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           4590.0000/94.36&lt;br&gt;    execution time (avg/stddev):   10.0126/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 4&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0004s&lt;br&gt;    total number of events:              28536&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.23&lt;br&gt;         avg:                                    1.40&lt;br&gt;         max:                                    3.56&lt;br&gt;         95th percentile:                        1.47&lt;br&gt;         sum:                                39975.16&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           7134.0000/39.87&lt;br&gt;    execution time (avg/stddev):   9.9938/0.01&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;p&gt;ChatGPT는 여전히 좋은 도구입니다. 위에 있는 표는 이전에 익숙했던 Markdown으로는 완전히 구성할 수 없으며, 표로 만들지 않으면 표시 효과가 매우 좋지 않습니다. 사용자 지정 테마는 페이지 최대 너비를 제한하며, 페이지 설정도 변경하여 너비를 백분율 제한으로 조정했습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;간단한 방법은 TablesGenerator와 같은 온라인 도구를 사용하여 HTML 테이블을 생성하는 것입니다(내용이 복잡하면 적합하지 않음)&lt;/li&gt;
&lt;li&gt;또는 구글 온라인 문서로 작성한 후 HTML 문서로 다운로드하여 저장하고, 블로그에 바로 복사하는 방법(간단하고 직접적이며, 최종적으로 이 방법을 사용했습니다)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;config 설정에서 unsafe 옵션이 활성화되어 있는지 확인하고, 페이지별로 너비를 개별적으로 지정하세요&lt;/p&gt;
&lt;p&gt;Hugo에서 페이지별로 너비를 설정할 수 있습니다. 이는 페이지의 프론트 매터에 사용자 지정 파라미터를 추가하여 구현할 수 있습니다. 다음은 예시입니다.&lt;/p&gt;
&lt;p&gt;마크다운 페이지의 프론트 매터 부분(일반적으로 파일의 시작 부분)에 사용자 지정 파라미터, 예를 들어 &lt;code&gt;custom_width&lt;/code&gt;를 추가하세요&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;---
title: &amp;quot;我的页面&amp;quot;
date: 2024-01-09
custom_width: &amp;quot;800px&amp;quot;  # 设置宽度为 800 像素
---

正文内容...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;귀하의 Hugo 테마에서 해당 단일 페이지 템플릿 파일(예: &lt;code&gt;layouts/_default/single.html&lt;/code&gt;)을 찾거나 생성하십시오&lt;/p&gt;
&lt;p&gt;단일 페이지 템플릿에서, 페이지의 프론트 매터에 &lt;code&gt;custom_width&lt;/code&gt; 파라미터가 있는지 확인하고, 해당 HTML 요소(예: &lt;code&gt;div&lt;/code&gt;)에 적용합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{{ define &amp;quot;main&amp;quot; }}
  &amp;lt;div style=&amp;quot;max-width: {{ with .Params.custom_width }}{{ . }}{{ else }}100%{{ end }}; margin: 0 auto;&amp;quot;&amp;gt;
    {{ .Content }}
  &amp;lt;/div&amp;gt;
{{ end }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 예제에서는 &lt;code&gt;style&lt;/code&gt; 속성을 사용하여 &lt;code&gt;div&lt;/code&gt; 요소에 &lt;code&gt;max-width&lt;/code&gt; 속성을 설정하여 &lt;code&gt;custom_width&lt;/code&gt; 매개변수를 지정하지 않을 때 너비를 기본적으로 100%로 만듭니다. &lt;code&gt;margin: 0 auto;&lt;/code&gt;는 &lt;code&gt;div&lt;/code&gt; 요소를 가운데 정렬하는 데 사용됩니다.&lt;/p&gt;
&lt;p&gt;실제 적용 시에는 위 예시를 주제 구조와 CSS 스타일의 세부 사항에 따라 조정해야 할 수 있습니다. 스타일을 조정할 때는 주제의 일관성과 가독성을 유지하는 것이 중요합니다.&lt;/p&gt;
&lt;p&gt;활성화된 테마가 약간 달라서 사이트 사용자 정의 &lt;code&gt;CSS&lt;/code&gt; 설정을 최종적으로 조정했습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>Git 비활성화 http 저장소</title>
        <link>https://ttf248.life/ko/p/git-disable-http-repositories/</link>
        <pubDate>Mon, 08 Jan 2024 21:22:04 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/git-disable-http-repositories/</guid>
        <description>&lt;p&gt;소프트웨어 버전을 업데이트하는 것이 습관인데, 어느 버전의 &lt;code&gt;Git&lt;/code&gt;부터인지 모르겠지만 &lt;code&gt;Http&lt;/code&gt; 저장소에서 코드를 가져오지 못하게 금지되어 있습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;fatal: Unencrypted HTTP is not supported for GitLab. Ensure the repository remote URL is using HTTPS
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;배경-소개&#34;&gt;배경 소개
&lt;/h2&gt;&lt;p&gt;환경: Windows 플랫폼, 항상 작은 거북이로 git을 사용하고 있었고, 키 설정도 작은 거북이로 처리했습니다. 전에 스크립트를 통해 한 번 로컬 저장소를 일괄적으로 업데이트한 적이 있습니다.&lt;/p&gt;
&lt;p&gt;이전 링크: [로컬 Git 저장소 일괄 업데이트]({&amp;lt; relref &amp;ldquo;/post/2023/10-19-批量更新本地git仓库&amp;rdquo; &amp;gt;}})&lt;/p&gt;
&lt;p&gt;오늘 집에 와서 코드 업데이트를 하려는데, 위에 언급된 오류가 발생해서 저장소를 정상적으로 업데이트할 수 없게 됐습니다. &lt;code&gt;Git&lt;/code&gt;에서 &lt;code&gt;http&lt;/code&gt; 프로토콜을 사용하여 계속 업데이트하도록 설정하는 옵션이 있을 줄 알았는데, 찾아봐도 해당 설정 항목은 찾을 수가 없었습니다.&lt;/p&gt;
&lt;p&gt;가장 간단한 해결책은 당연히 &lt;code&gt;ssh&lt;/code&gt; 프로토콜로 전환하여 저장소를 업데이트하는 것입니다. 회사 설정상 &lt;code&gt;gitlab&lt;/code&gt;은 단기적으로 &lt;code&gt;https&lt;/code&gt; 프로토콜을 제공하지 않을 예정입니다.&lt;/p&gt;
&lt;h2 id=&#34;미해결-문제&#34;&gt;미해결 문제
&lt;/h2&gt;&lt;p&gt;앞서 작성했던 로컬 저장소 일괄 업데이트 스크립트를 만들 때, 원래는 &lt;code&gt;ssh&lt;/code&gt; 방식으로 저장소를 가져올 생각이었는데, 왜 그런지 자세히 확인하지 않았습니다. TortoiseGit 설정 정보가 config 파일에 동기화되지 않아 명령줄에서 실행&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git pull #提示没有权限，无法正常更新仓库
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;명령을 통해 키 설정도 확인하는 것은 올바르다: &lt;code&gt;ssh -T git@gitlab.yintech.net&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;TortoiseGit을 사용하여 코드를 정상적으로 가져올 수 있지만 명령줄에서 git pull 명령어를 사용할 때 키가 올바르지 않다고 표시되면 TortoiseGit이 PuTTY의 SSH 키를 사용하는 반면 명령줄은 OpenSSH의 SSH 키를 사용하기 때문일 수 있습니다&lt;/p&gt;
&lt;p&gt;작은 거북이의 키 설정은 시스템 .ssh 폴더에서 키 파일 정보를 읽어오는 대신, 인터페이스 저장소 구성 시 별도로 키 파일 경로를 설정합니다. 유용한 팁: 첫 번째로 구성된 저장소에 키를 설정하면 나머지 저장소는 이 키 파일을 재사용할 수 있습니다. PuTTY가 키를 로드한 후에는 즉시 종료되지 않고 프록시 서비스를 시작합니다.&lt;/p&gt;
&lt;p&gt;전역 구성을 조정하여 시스템 기본 &lt;code&gt;ssh&lt;/code&gt; 설정을 사용하지 않도록 하면 Git Bash가 TortoisePlink를 사용하여 SSH 작업을 수행합니다. 이러한 설정은 TortoiseGit에 포함된 PuTTY 도구를 사용하는 경우에 적합합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global core.sshCommand &amp;quot;&#39;C:/Program Files/TortoiseGit/bin/TortoisePlink.exe&#39; -batch -ssh&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위에 설정된 실행 파일 경로를 해당 작은 거북이 경로로 직접 수정하면 시스템 환경 변수에 경로를 추가할 필요가 없습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>AI 프로그래밍 및 작업 분할</title>
        <link>https://ttf248.life/ko/p/ai-programming-and-task-decomposition/</link>
        <pubDate>Fri, 22 Dec 2023 08:44:26 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/ai-programming-and-task-decomposition/</guid>
        <description>&lt;p&gt;2년 전 사이트에 코드 영역 복사 기능을 추가했는데, 여러 날을 끙끙거린 끝에 최종 렌더링 효과가 만족스럽지 않았습니다. 반쪽짜리 프론트엔드 개발자였기 때문에 개선하려 하지는 않고 그냥 사용했습니다. 올해 &lt;code&gt;AI&lt;/code&gt;로 미니 프로그램을 개발하면서 프론트엔드 개발에도 더 익숙해졌고, 그래서 다시 한번 (AI 재설계) 리팩토링을 했습니다.&lt;/p&gt;
&lt;p&gt;깨달음: 과제를 분해하니 작은 작업들이 많아져서, AI 개발에 적합하네요. 이미 폐쇄된 앱인데 75%의 코드를 AI가 제공했고, 여러 개의 작업으로 분할하여 배포했으며, 사람이 프로젝트 코드 조립을 담당했습니다.&lt;/p&gt;
&lt;h2 id=&#34;전문&#34;&gt;전문
&lt;/h2&gt;&lt;p&gt;간단하다고 생각했던 일이지만, 코드 복사 버튼을 추가하면 됩니다&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;CSS와 JavaScript 코드를 설계하여 class=&amp;ldquo;highlight&amp;quot;인 웹 요소의 컨테이너 내에 복사 버튼을 추가하고, 코드 복사 기능을 구현합니다&lt;/p&gt;
&lt;p&gt;제공된 첫 번째 초안 코드에는 문제가 있는 듯 보입니다. 다시 생성한 초안은 기본적으로 사용 가능하지만, 복사된 내용이 정확하지 않고 불필요한 텍스트가 포함되어 있습니다. 핵심 색상 디자인과 어떤 효과를 포함할지 수동으로 지정하여 추가 최적화를 유도했습니다.&lt;/p&gt;
&lt;p&gt;버튼의 크기와 색상에 대한 특정 요구 사항이 있다는 것을 파악했습니다. 귀하의 요구 사항에 맞게 버튼 스타일을 다시 디자인할 수 있습니다. 다음은 제공하신 색상 구성표를 포함하고 버튼 크기를 최적화한 조정된 CSS 스타일입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.copy-btn {
  position: absolute;
  top: 2px; /* 调整位置 */
  right: 2px;
  padding: 3px 6px; /* 缩小尺寸 */
  font-size: 12px; /* 减小字体大小 */
  background-color: #8FD1E1; /* 按钮背景色 */
  color: #272822; /* 文字颜色 */
  border: 1px solid #272822; /* 边框颜色 */
  border-radius: 3px; /* 圆角 */
  cursor: pointer;
  opacity: 0.7; /* 默认半透明 */
  transition: opacity 0.3s ease, background-color 0.3s ease; /* 平滑过渡效果 */
}

.copy-btn:hover {
  opacity: 1; /* 鼠标悬停时不透明 */
  background-color: #A3D4E5; /* 鼠标悬停时的背景色 */
}

.highlight {
  position: relative;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 스타일에서 저는 버튼 크기와 글꼴 크기를 줄여 더욱 세련되게 만들었습니다. 동시에 버튼의 기본 상태는 반투명하며, 마우스가 버튼 위에 올라갈 때 불투명해지고 배경색이 약간 밝아져 시각적인 피드백을 제공합니다. 이러한 디자인은 귀하의 색상 요구 사항을 충족하면서도 현대적이고 사용자 친화적인 특징을 유지합니다.&lt;/p&gt;
&lt;p&gt;해당하는 더 간단한 &lt;code&gt;JavaScript&lt;/code&gt;를 제공합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;document.addEventListener(&#39;DOMContentLoaded&#39;, function() {
  // 查找所有 .highlight 元素
  const highlights = document.querySelectorAll(&#39;.highlight&#39;);

  highlights.forEach(function(highlight) {
    // 创建复制按钮
    const copyBtn = document.createElement(&#39;button&#39;);
    copyBtn.textContent = &#39;复制&#39;;
    copyBtn.classList.add(&#39;copy-btn&#39;);

    // 将按钮添加到每个 .highlight 元素中
    highlight.appendChild(copyBtn);

    // 添加点击事件监听器
    copyBtn.addEventListener(&#39;click&#39;, function() {
      // 假设 .highlight 下的第一个 &amp;lt;code&amp;gt; 元素包含要复制的代码
      const code = highlight.querySelector(&#39;code&#39;) ? highlight.querySelector(&#39;code&#39;).textContent : &#39;&#39;;

      navigator.clipboard.writeText(code).then(() =&amp;gt; {
        // 显示复制成功信息
        copyBtn.textContent = &#39;已复制!&#39;;
        setTimeout(() =&amp;gt; {
          copyBtn.textContent = &#39;复制&#39;;
        }, 2000);
      }).catch(err =&amp;gt; {
        console.error(&#39;复制失败: &#39;, err);
      });
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;p&gt;비록 코드 영역의 오른쪽 상단에 복사 버튼을 추가하는 것을 더 기대했지만, 프론트엔드에 대한 이해 부족으로 기능이 정확하게 설명되지 않았고, AI와 몇 번이고 반복했음에도 예상한 결과를 얻지 못했습니다&lt;/p&gt;
&lt;p&gt;시간이 지나면서 AI가 프로그램 개발에 얼마나 큰 영향을 미칠지 모르겠다&lt;/p&gt;</description>
        </item>
        <item>
        <title>클라우드 서버와 스크립트 키즈</title>
        <link>https://ttf248.life/ko/p/cloud-servers-and-script-kids/</link>
        <pubDate>Mon, 20 Nov 2023 15:08:53 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/cloud-servers-and-script-kids/</guid>
        <description>&lt;p&gt;더블 11 행사를 빌려 알리바이가 새 서버를 구매했습니다. 경제적인 버전으로, 연간 99위안이고, 사양은 높지 않지만 집에서 제공하는 서비스의 방화벽 역할을 하는 데도 괜찮습니다. 이 이벤트는 2026년까지 진행됩니다.&lt;/p&gt;
&lt;p&gt;특이적으로 상하이 지역 서버를 선택했고, 낮은 지연 시간 프록시로 집의 컴퓨터를 연결했습니다. win11과 windows server 2022인데, 서버 버전은 나중에 배포되었고, 사용하려고 하니 갑자기 접근 거부 메시지를 받았습니다. 서버 업데이트 때문이라고 생각해서 잠시 기다리니 정상적으로 복구될 줄 알았는데, 5분 정도 지나서 다시 시도해도 여전히 로그인되지 않습니다. 관련 오류를 검색해 보니 누군가가 로그인을 시도하고 있고, 비밀번호가 너무 많이 틀렸기 때문에 현재는 로그인이 불가능하다고 합니다.&lt;/p&gt;
&lt;p&gt;이전에도 보안 공격 스크립트를 접해본 경험이 있어서, 이러한 로그인 시도는 정상적인 행동이 아니라고 바로 생각했다. 누군가가 서비스를 공격하고 로그인 서버를 무작위로 해킹하려 하는 것 같았다. 서버 방화벽 설정이 간단하게 되어 있어 백리스트가 설정되어 있지 않았고, 두 대의 기계의 3389 포트를 프록시했기 때문에 공공 네트워크에 노출되었다. 마치 연못 속 미끼와 같은 상황이었다. 스크립트 키드가 공격하고 있다는 것을 알았으니, 다음 단계는 간단했다. 방화벽 백리스트를 설정하여 회사 IP 주소와 집 IP 주소만 프록시 서비스에 접속하도록 허용하면 된다.&lt;/p&gt;
&lt;p&gt;frps 에이전트 서버는 이전에도 실행 로그를 설정하지 않았는데, 로그를 켜니 정말 좋네요. 전국 각지의 프록시 IP 주소들이 제 집의 서버에 접속을 시도하고 있었어요. 다행히 한 대는 서버 버전이라 문제점을 깨닫게 되었고, 그렇지 않으면 win11 그 컴퓨터는 결국 해킹당할 거예요. 비밀번호 설정이 꽤 간단했거든요.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;2023/11/17 16:51:14 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [101.43.98.211:50486]
2023/11/17 16:51:14 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [218.93.202.63:56970]
2023/11/17 16:51:14 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [222.179.106.174:60812]
2023/11/17 16:51:15 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [58.16.204.238:2839]
2023/11/17 16:51:15 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [124.223.47.24:50274]
2023/11/17 16:51:16 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [43.248.128.22:55883]
2023/11/17 16:51:16 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [43.143.53.138:56955]
2023/11/17 16:51:16 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [43.228.7.250:61550]
2023/11/17 16:51:16 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [125.76.228.9:55842]
2023/11/17 16:51:17 [I] [proxy.go:204] [4dfcc2259937dcb9] [winserver-remote] get a user connection [91.240.118.187:49326]
2023/11/17 16:51:17 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [91.240.118.187:49324]
2023/11/17 16:51:17 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [89.248.163.79:51712]
2023/11/17 16:51:18 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [218.63.75.24:62387]
2023/11/17 16:51:19 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [103.186.109.227:51396]
2023/11/17 16:51:20 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [116.233.234.104:51567]
2023/11/17 16:51:20 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [222.187.193.202:51585]
2023/11/17 16:51:20 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [59.48.98.42:57489]
2023/11/17 16:51:20 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [146.56.241.134:53558]
2023/11/17 16:51:21 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [222.179.106.174:30620]
2023/11/17 16:51:23 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [183.14.214.51:62128]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;일부러 확인해 보니, 알리바바 클라우드 서버 외에 친구가 사용하는 화웨이 클라우드 서버도 있더군요&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo grep &amp;quot;Failed password&amp;quot; /var/log/secure  centos系列
sudo grep &amp;quot;Failed password&amp;quot; /var/log/auth.log  ubuntu系列
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Nov 16 04:46:34 aliyun-sh sshd[156625]: Failed password for root from 120.55.164.64 port 53410 ssh2
Nov 16 04:46:34 aliyun-sh sshd[156623]: Failed password for root from 111.16.215.122 port 36548 ssh2
Nov 16 04:46:58 aliyun-sh sshd[156630]: Failed password for invalid user share from 139.9.233.78 port 53872 ssh2
Nov 16 04:47:23 aliyun-sh sshd[156634]: Failed password for invalid user spark from 139.9.233.78 port 36134 ssh2
Nov 16 04:47:26 aliyun-sh sshd[156636]: Failed password for root from 120.55.164.64 port 46142 ssh2
Nov 16 04:47:47 aliyun-sh sshd[156640]: Failed password for root from 111.16.215.122 port 42962 ssh2
Nov 16 04:48:24 aliyun-sh sshd[156652]: Failed password for root from 120.55.164.64 port 38868 ssh2
Nov 16 04:48:25 aliyun-sh sshd[156654]: Failed password for root from 111.16.215.122 port 46164 ssh2
Nov 16 04:48:39 aliyun-sh sshd[156657]: Failed password for invalid user test from 139.9.233.78 port 39386 ssh2
Nov 16 04:48:50 aliyun-sh sshd[156659]: Failed password for root from 111.16.215.122 port 38892 ssh2
Nov 16 04:48:53 aliyun-sh sshd[156662]: Failed password for root from 120.55.164.64 port 49348 ssh2
Nov 16 04:48:53 aliyun-sh sshd[156664]: Failed password for invalid user test from 139.9.233.78 port 49864 ssh2
Nov 16 04:50:02 aliyun-sh sshd[156672]: Failed password for root from 111.16.215.122 port 45294 ssh2
Nov 16 04:50:30 aliyun-sh sshd[156680]: Failed password for invalid user zabbix from 139.9.233.78 port 52206 ssh2
Nov 16 04:50:50 aliyun-sh sshd[156683]: Failed password for root from 120.55.164.64 port 34820 ssh2
Nov 16 04:50:51 aliyun-sh sshd[156685]: Failed password for root from 111.16.215.122 port 58978 ssh2
Nov 16 04:51:18 aliyun-sh sshd[156689]: Failed password for root from 120.55.164.64 port 45306 ssh2
Nov 16 04:51:25 aliyun-sh sshd[156692]: Failed password for root from 111.16.215.122 port 33938 ssh2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;화웨이 클라우드 이 머신은 시작한 지 시간이 꽤 됐고, 이제 사변 공격의 중간 단계에 들어서면서 온갖 이상한 사용자들까지 나타나기 시작했다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Nov 16 20:30:35 hecs-411458 sshd[182965]: Failed password for invalid user oeh from 39.129.9.180 port 26459 ssh2
Nov 16 20:32:17 hecs-411458 sshd[182967]: Failed password for invalid user dnu from 39.129.9.180 port 27079 ssh2
Nov 16 20:34:12 hecs-411458 sshd[182971]: Failed password for invalid user rq from 39.129.9.180 port 27742 ssh2
Nov 16 20:36:07 hecs-411458 sshd[182979]: Failed password for invalid user zw from 39.129.9.180 port 28415 ssh2
Nov 16 20:37:59 hecs-411458 sshd[182981]: Failed password for invalid user egi from 39.129.9.180 port 29068 ssh2
Nov 16 20:39:52 hecs-411458 sshd[182984]: Failed password for invalid user bjb from 39.129.9.180 port 29723 ssh2
Nov 16 20:41:53 hecs-411458 sshd[182988]: Failed password for invalid user hna from 39.129.9.180 port 30375 ssh2
Nov 16 20:43:46 hecs-411458 sshd[182994]: Failed password for invalid user gar from 39.129.9.180 port 31036 ssh2
Nov 16 20:45:40 hecs-411458 sshd[183003]: Failed password for invalid user mze from 39.129.9.180 port 31703 ssh2
Nov 16 20:47:35 hecs-411458 sshd[183007]: Failed password for invalid user tmh from 39.129.9.180 port 32381 ssh2
Nov 16 21:23:01 hecs-411458 sshd[183047]: Failed password for invalid user amax from 112.4.65.118 port 41188 ssh2
Nov 16 22:31:20 hecs-411458 sshd[183116]: Failed password for root from 211.228.203.123 port 60213 ssh2
Nov 16 22:53:44 hecs-411458 sshd[183162]: Failed password for root from 112.132.249.164 port 39272 ssh2
Nov 17 11:44:26 hecs-411458 sshd[184811]: Failed password for invalid user jsh from 43.157.103.27 port 54608 ssh2
Nov 17 11:47:23 hecs-411458 sshd[184818]: Failed password for invalid user mrunal from 43.157.103.27 port 50448 ssh2
Nov 17 11:48:46 hecs-411458 sshd[184820]: Failed password for invalid user robertsheen from 43.157.103.27 port 50560 ssh2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;p&gt;자체 서버를 개발할 경우, Windows의 공용 네트워크 접속 시 화이트리스트 설정을 해야 하며, Linux에서는 비밀번호 로그인을 금지하고 키 파일 로그인 기능을 활성화하는 것이 좋습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>일괄 업데이트된 로컬 Git 저장소 및 기존 권한 문제</title>
        <link>https://ttf248.life/ko/p/bulk-update-local-git-repository-and-legacy-permission-issues/</link>
        <pubDate>Thu, 19 Oct 2023 14:16:22 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/bulk-update-local-git-repository-and-legacy-permission-issues/</guid>
        <description>&lt;p&gt;팀 내 프로젝트들 간에는 의존 관계가 존재하며, 과거의 사유로 인해 &lt;code&gt;submodule&lt;/code&gt;을 사용하여 프로젝트 의존성을 관리하지 않았습니다. 따라서 일상적인 개발 과정에서 저장소 코드를 수동으로 순차적으로 업데이트해야 하며, 그렇지 않으면 다양한 이상한 문제가 발생할 수 있습니다.&lt;/p&gt;
&lt;p&gt;온라인 자료를 참고하여 구조가 기본적으로 유사하므로, 로컬에서 &lt;strong&gt;git_list.txt&lt;/strong&gt;라는 저장소 디렉터리를 수동으로 유지하고, 스크립트를 작성하여 디렉터리를 순회하며 한 번에 업데이트합니다. 이후 작업 전에 스크립트를 실행하세요.&lt;/p&gt;
&lt;h2 id=&#34;linux&#34;&gt;linux
&lt;/h2&gt;&lt;p&gt;create new file: batch_pull.sh&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash

echo &amp;quot;============ 更新仓库 ===================&amp;quot;

# 检查 git_list.txt 是否存在
if [ ! -f &amp;quot;git_list.txt&amp;quot; ]; then
  echo &amp;quot;git_list.txt 文件不存在！请创建并添加要拉取的 git 仓库 URL。&amp;quot;
  exit 1
else
  echo &amp;quot;============ 检测到了 git 仓库清单文件 ====&amp;quot;
fi

# 逐行读取 git_list.txt 中的 URL，并执行拉取操作
while read -r url; do
  if [ -d &amp;quot;$url&amp;quot; ]; then
    cd &amp;quot;$url&amp;quot; || continue
    git pull
    cd ..
    echo &amp;quot;Pull $url 完成！&amp;quot;
    echo &amp;quot;========================================&amp;quot;
  else
    echo &amp;quot;目录 $url 不存在，跳过拉取。&amp;quot;
  fi
done &amp;lt; &amp;quot;git_list.txt&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;windows&#34;&gt;windows
&lt;/h2&gt;&lt;p&gt;create a new file: batch_pull.bat&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bat&#34;&gt;@echo off
chcp 65001 &amp;gt; nul
rem 进入脚本所在目录
cd /d &amp;quot;%~dp0&amp;quot;

rem 检查 git_list.txt 是否存在
if not exist &amp;quot;git_list.txt&amp;quot; (
  echo git_list.txt 文件不存在！请创建并添加要拉取的 git 仓库 URL。
  exit /b 1
) else (
  echo ============ 检测到了 git 仓库清单文件 ====
)

rem 逐行读取 git_list.txt 中的 URL，并执行拉取操作
for /f %%i in (git_list.txt) do (
  if exist &amp;quot;%%i&amp;quot; (
    pushd &amp;quot;%%i&amp;quot;
    git pull
    popd
    echo Pull %%i 完成！
    echo ========================================
  ) else (
    echo 目录 %%i 不存在，跳过拉取。
  )
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;역사적-유산-문제&#34;&gt;역사적 유산 문제
&lt;/h3&gt;&lt;p&gt;시스템 재설치 후 발생한 &lt;code&gt;git&lt;/code&gt; 폴더 권한 파일 관련 오류: &lt;strong&gt;&amp;ldquo;안전하지 않은 저장소 (&amp;rsquo;/home/repon&amp;rsquo;은 다른 사용자가 소유하고 있습니다&amp;rsquo;)&amp;rdquo; 치명적인 오류&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;온라인에서 제안하는 방법들은 대부분 &lt;code&gt;스택 오버플로우&lt;/code&gt;에서 비롯된 것입니다&lt;/p&gt;
&lt;p&gt;저장소 디렉터리에 대한 신뢰 추가: &lt;code&gt;git config --global --add safe.directory /home/repon&lt;/code&gt;
수동으로 &lt;code&gt;.gitconfig&lt;/code&gt; 설정 파일을 수정하여 디렉터리를 추가하고 신뢰하도록 지정합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[safe]
    directory = /home/repon
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 방법으로 처리한 후, 창고 업데이트는 정상적으로 되었지만, &lt;code&gt;git pull&lt;/code&gt;을 실행할 때마다 콘솔에 많은 경고 메시지가 표시되는데, 사용자 소유권 오류를 나타냅니다&lt;/p&gt;
&lt;h3 id=&#34;데스크톱-컴퓨터-재설치&#34;&gt;데스크톱 컴퓨터 재설치
&lt;/h3&gt;&lt;p&gt;개발한 기계가 너무 오래돼서 시스템을 재설치하지 않았더니, 쓰레기 파일이 폭발해서 방법이 없었습니다. 시간을 내어 시스템을 재설치했는데, 또 이 권한 문제가 발생했습니다. 예전 스크립트가 실행되지 않고, 수정된 권한이 완전하지 않습니다.&lt;/p&gt;
&lt;p&gt;새로운 방식을 사용하면 &lt;code&gt;*&lt;/code&gt;를 직접 추가하면, 이렇게 하면 &lt;code&gt;git&lt;/code&gt;이 모든 디렉터리를 자동으로 신뢰합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global --add safe.directory &amp;quot;*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;사용자 권한 문제인지, 아니면 다들 &lt;code&gt;windows&lt;/code&gt; 플랫폼에도 &lt;code&gt;chown&lt;/code&gt;과 유사한 명령이 있다는 것에 익숙하지 않은 건지 모르겠다. 폴더 소유자를 수정하는 방법인데, 만약 디렉토리가 많지 않다면 수동으로 소유자를 변경해도 괜찮다. 하지만 이 업무용 컴퓨터에는 도메인 정보가 추가되어 있는데, 회사에서 배포한 도메인에 이상이 있는지, 아니면 로컬 시스템 설정에 문제가 있는 건지 잘 모르겠다. 사용자 목록에서 로그인에 사용되는 사용자를 찾을 수 없었고, 결국 명령줄로 처리했다.&lt;/p&gt;
&lt;p&gt;관리자 권한으로 &lt;code&gt;powershell&lt;/code&gt; 스크립트 &lt;code&gt;change_ower.ps1&lt;/code&gt;을 실행하세요. 스크립트 파일 인코딩을 &lt;code&gt;gbk&lt;/code&gt;로 조정하는 것을 잊지 마세요. 중국어 운영체제에서 그래야 깨짐 없이 실행됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;# 获取当前用户的用户名
$currentUserName = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name

# 设置 PowerShell 的字符编码为 UTF-8
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8

# 要更改所有者的根目录路径
$rootDirectory = &amp;quot;G:\workspace&amp;quot;  # 替换为实际的目录路径

# 递归遍历目录并更改文件和文件夹的所有者
Get-ChildItem -Path $rootDirectory -Recurse | ForEach-Object {
    $itemPath = $_.FullName

    # 检查是文件还是文件夹
    if ($_ -is [System.IO.DirectoryInfo]) {
        # 如果是文件夹，使用 icacls 更改所有者权限
        $icaclsResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            Write-Host &amp;quot;已更改文件夹 $itemPath 的所有者为 $currentUserName&amp;quot;
        } else {
            Write-Host &amp;quot;无法更改文件夹 $itemPath 的所有者。错误信息: $icaclsResult&amp;quot;
        }
    } else {
        # 如果是文件，使用 icacls 更改所有者权限
        $takeownResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            # Write-Host &amp;quot;已更改文件 $itemPath 的所有者为 $currentUserName&amp;quot;
        } else {
            Write-Host &amp;quot;无法更改文件 $itemPath 的所有者。错误信息: $takeownResult&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;예상치 못한 상황이 발생했는데, 스크립트 실행 시 출력되는 중국어 정보가 깨져 있었고, 콘솔 문자 인코딩을 설정하고 스크립트 인코딩을 조정했음에도 불구하고 여전히 엉망진창이었다. 머리가 제대로 작동하지 않는 것 같아서, 제어판-지역-언어 설정의 베타 기능을 활성화하고 전역적으로 유니코드 인코딩을 켰더니 스크립트는 정상적으로 실행되었지만 여러 개발 소프트웨어가 제대로 작동하지 않았다. 뒤돌아보니 자료를 정리하다가 스크립트 파일의 인코딩을 &lt;code&gt;gbk&lt;/code&gt;로 설정해야 한다는 것을 기억해냈다.&lt;/p&gt;
&lt;h2 id=&#34;자료&#34;&gt;자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://ganzhixiong.com/p/f1b9f4fc/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ganzhixiong.com/p/f1b9f4fc/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/71901632/fatal-error-unsafe-repository-home-repon-is-owned-by-someone-else&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stackoverflow.com/questions/71901632/fatal-error-unsafe-repository-home-repon-is-owned-by-someone-else&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>WPF 학습 자료</title>
        <link>https://ttf248.life/ko/p/wpf-learning-resources/</link>
        <pubDate>Tue, 17 Oct 2023 10:49:24 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/wpf-learning-resources/</guid>
        <description>&lt;p&gt;미니 프로그램 개발 설계의 함정은 아직 채우지 못했는데, 새로운 &lt;strong&gt;WPF&lt;/strong&gt;를 파고 최근 회사도 동요가 있었고, 다른 지역과의 협업 업무 소통은 어쩔 수 없이 효율이 조금 미흡했기에, 그냥 클라이언트 인터페이스 개발을 맡기로 했다&lt;/p&gt;
&lt;h2 id=&#34;wpf&#34;&gt;WPF
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/dotnet/desktop/wpf/introduction-to-wpf?view=netframeworkdesktop-4.8&amp;amp;preserve-view=true&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 마이크로소프트 공식 학습 자료&lt;/a&gt;를 추천합니다&lt;/li&gt;
&lt;li&gt;[WPF 기초 요약(학습 제안)]&lt;/li&gt;
&lt;li&gt;[WPF 중국어 웹사이트]&lt;/li&gt;
&lt;li&gt;WPF 개인 정리 및 학습 추천&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;WPF 인터페이스 디자인에 사용되는 많은 개념들은 웹 프론트엔드 디자인과 유사하며, 가능한 한 UI 디자인과 비즈니스 로직을 분리하여 UI 디자인이 독립적으로 가능하도록 하는 것이 인터넷 회사들이 기대하는 분업 방식입니다. 올해 마침 소형 프로그램(小程序)을 개발해 보았는데, 많은 개념적인 부분에서 공통점이 있어 익숙해지기도 쉬웠습니다. 이러한 것들은 현대 UI 디자인의 &lt;strong&gt;진리&lt;/strong&gt;라고 할 수 있으며, 기본적인 프레임워크 개념을 숙지하면 이후로 잘못된 방향으로 나아갈 가능성이 줄어듭니다.&lt;/p&gt;
&lt;p&gt;이전에 &lt;code&gt;Winform&lt;/code&gt; 개발 경험이 있는 독자라면, &lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/zh7791/p/11502696.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 기초 요약(학습 제안)&lt;/a&gt;을 읽어보시는 것을 추천합니다. 분량이 길지 않아 경험이 있는 독자들이 학습 경로를 계획하기에 적합합니다.&lt;/p&gt;
&lt;p&gt;영문 없이 읽는 독자들을 위해 &lt;a class=&#34;link&#34; href=&#34;http://www.wpfsoft.com/introduction&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 중국어 웹사이트&lt;/a&gt;를 추천합니다. 이 곳에서는 기본 개념, 발전 역사, 그리고 하위 클래스에 대한 이해 논리를 처음부터 설명하고 있습니다. 재미롭게도 이 웹사이트는 올해 8월에 게시되었는데, 저의 일정과 딱 맞아떨어졌습니다. 조금만 더 늦었더라면 아마 기회가 없었을 겁니다.&lt;/p&gt;
&lt;p&gt;가장 정통적인 학습 자료를 원한다면 당연히 마이크로소프트 공식 자료여야 합니다. 다소 지루할 수 있지만, 새로운 독자들은 인내심을 가져야 합니다.&lt;/p&gt;
&lt;p&gt;고전적인 전자책도 많지만, 크게 추천하지는 않아요. 일상 업무가 많아서 책을 읽을 시간이 많지 않고, 한 번에 몰입해서 보기 어렵습니다. 프로젝트 연습과 함께 하는 것이 더 적합할 것 같아요.&lt;/p&gt;
&lt;h2 id=&#34;c-및-net-출시-기록&#34;&gt;C# 및 .NET 출시 기록
&lt;/h2&gt;&lt;p&gt;이전에 학습했던 언어에 비해 최근 몇 년간은 새롭게 추가된 기능이 조금 많아지고, 매년 문법 버전이 업데이트되고 있습니다&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/C_Sharp_%28programming_language%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://en.wikipedia.org/wiki/C_Sharp_(programming_language)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;공식 학습 자료:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/dotnet/csharp/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/dotnet/csharp/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/dotnet/core/tutorials/with-visual-studio?pivots=dotnet-7-0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/dotnet/core/tutorials/with-visual-studio?pivots=dotnet-7-0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>지리적 분산 환경의 제로티어</title>
        <link>https://ttf248.life/ko/p/zero-tier-remote-lan/</link>
        <pubDate>Tue, 19 Sep 2023 04:58:03 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/zero-tier-remote-lan/</guid>
        <description>&lt;p&gt;사무실에 새 &lt;code&gt;mini&lt;/code&gt; 호스트를 구입했는데, 환경 설정이 간편하고 가끔 집에서 접속할 필요가 있어서 임시로 내장 네트워크 침투를 구축했습니다. 이전 경험을 바탕으로 &lt;code&gt;frp&lt;/code&gt; 서비스를 배포하고 포트 전달을 지정했더니 공용 서버가 필요했고 연결 품질은 공용 서버의 대역폭에 따라 달라졌습니다. 새로운 &lt;code&gt;Zerotier&lt;/code&gt; 가상 머신 로컬 영역 네트워크를 구축했는데, 이는 &lt;code&gt;VPN&lt;/code&gt;과 유사하며 로컬에서 가상 네트워크 카드를 새로 만들고 모든 장치를 하나의 가상 네트워크에 추가했습니다.&lt;/p&gt;
&lt;h2 id=&#34;제로티어는-무엇인가요&#34;&gt;제로티어는 무엇인가요?
&lt;/h2&gt;&lt;p&gt;ZeroTier는 다양한 지리적 위치의 장치 간에 안전한 가상 네트워크를 생성할 수 있는 소프트웨어 정의 광역 네트워크(SD-WAN) 솔루션입니다. ZeroTier를 통해 여러 대의 컴퓨터, 서버 및 장치를 마치 동일한 로컬 영역 네트워크에 있는 것처럼 하나의 가상 암호화된 네트워크에 쉽게 연결할 수 있습니다. 이를 통해 프로그래머와 IT 전문가는 복잡한 네트워크 설정 및 VPN 구성 없이 서로 다른 위치에서 데이터와 리소스를 안전하게 공유할 수 있습니다.&lt;/p&gt;
&lt;p&gt;제로티어 네트워크는 가상 전역 로컬 영역 네트워크로, 서로 다른 장치들이 인터넷을 통해 연결되어 마치 동일한 물리적 네트워크에 있는 것처럼 작동하도록 합니다. 이 네트워크는 여러 서브넷으로 구성될 수 있으며, 모든 장치는 제로티어 기술을 통해 연결됩니다.&lt;/p&gt;
&lt;p&gt;행성 서버: 행성 서버는 Zerotier 네트워크의 핵심 구성 요소 중 하나입니다. 이들은 전 세계적으로 운영되며, Zerotier 네트워크 전체의 토폴로지 구조, 라우팅 정보 및 네트워크 상태를 유지 관리합니다. 행성 서버는 네트워크 제어 센터 역할을 하지만 데이터를 직접 전송하지는 않습니다. 사용자의 장치는 Zerotier 네트워크에 참여하기 위해 최소한 하나의 행성 서버에 연결해야 합니다.&lt;/p&gt;
&lt;p&gt;중계 서버: 중계 서버는 Zerotier 네트워크에서 보조 노드로, 장치 간의 직접 통신 채널을 설정하는 데 도움을 줍니다. 장치가 서로 직접 연결할 수 없을 때, 이들은 중계 서버를 통해 데이터를 전송할 수 있습니다. 이는 네트워크의 가용성과 성능을 향상시키는 데 도움이 됩니다. 중계 서버는 일반적으로 전 세계 곳곳에 위치하여 데이터 전송의 중계 지점 역할을 합니다.&lt;/p&gt;
&lt;p&gt;전반적으로, Zerotier는 행성 서버와 중계 서버의 도움을 받아 전 세계적으로 가상 로컬 영역 네트워크를 구축하여 장치 간 안전하고 빠른 통신을 가능하게 합니다. 행성 서버는 전체 네트워크 관리를 담당하며, 중계 서버는 필요할 때 장치가 통신 연결을 설정하도록 돕습니다.&lt;/p&gt;
&lt;h2 id=&#34;설치-배포&#34;&gt;설치 배포
&lt;/h2&gt;&lt;p&gt;ZeroTier 공식 웹사이트(&lt;a class=&#34;link&#34; href=&#34;https://www.zerotier.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.zerotier.com/&lt;/a&gt;)에서 설치 파일과 문서를 다운로드하세요
귀하의 운영 체제에 따라 ZeroTier One 클라이언트 프로그램을 다운로드하여 설치하십시오. Windows, macOS, Linux 및 기타 여러 플랫폼을 지원합니다.
설치가 완료되면 ZeroTier One 클라이언트를 시작합니다
ZeroTier 계정이 아직 없으시다면, 계정을 만드세요. 클라이언트에서 계정을 생성할 수 있습니다.
ZeroTier 계정으로 로그인하여 새 네트워크를 만드세요. 네트워크에는 고유한 16자리 ID가 있으며, 이 ID를 기억해야 합니다.
귀하의 장치에 이 네트워크를 추가합니다. 클라이언트에서 네트워크 ID를 입력하거나 QR 코드 스캔 기능을 사용할 수 있습니다.
7. ZeroTier 클라이언트가 설치 및 구성된 장치는 동일한 가상 네트워크에 추가됩니다. 이제 이러한 장치들은 마치 동일한 로컬 영역 네트워크에 있는 것처럼 직접 통신할 수 있습니다.
ZeroTier 제어판에서 네트워크 설정 관리, 장치 추가 및 네트워크 트래픽 모니터링 등을 할 수 있습니다&lt;/p&gt;
&lt;h2 id=&#34;문-설치-배포&#34;&gt;문 설치 배포
&lt;/h2&gt;&lt;p&gt;국내 통신사들은 대부분 &lt;code&gt;UDP&lt;/code&gt; 포트 포워딩을 금지하고 있습니다. &lt;code&gt;frp&lt;/code&gt; 서비스는 안정적이며, &lt;code&gt;TCP&lt;/code&gt; 프로토콜을 사용하기 때문에 &lt;code&gt;Zerotier&lt;/code&gt;를 통해 리퍼 서버를 배포하여 유사한 효과를 낼 수 있습니다. 방화벽에서는 &lt;code&gt;udp 9993&lt;/code&gt; 포트를 개방해야 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -s https://install.zerotier.com/ | sudo bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;설치 성공 여부 확인&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zerotier-cli info
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;로컬 네트워크에 참여하세요&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zerotier-cli join network-id
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;moon&lt;/code&gt;을 생성합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd /var/lib/zerotier-one &amp;amp;&amp;amp; sudo zerotier-idtool initmoon identity.public &amp;gt; moon.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;편집기 구성 파일을 조정하고 &lt;code&gt;stableEndpoints&lt;/code&gt; 노드를 &amp;ldquo;서버 공용 IP/9993&amp;quot;으로 설정합니다&lt;/p&gt;
&lt;p&gt;서명 구성 생성, &lt;code&gt;moons.d&lt;/code&gt; 폴더 생성 후 해당 파일들을 이동하고 서비스를 재시작합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo zerotier-idtool genmoon moon.json
mkdir moons.d &amp;amp;&amp;amp; mv 000000eb444ec0d8.moon moons.d/
systemctl restart zerotier-one.service
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;클라이언트 노드가 문(moon) 서버에 접속하며, ID는 앞선 JSON 설정 파일의 ID 필드에서 가져옵니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zerotier-cli.bat orbit ztaddr ztaddr
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 观察是否出现新的 mooon 节点，id 和信息为服务器配置的相同
[root@idv-36f9d5 ~]# zerotier-cli listpeers
200 listpeers &amp;lt;ztaddr&amp;gt; &amp;lt;path&amp;gt; &amp;lt;latency&amp;gt; &amp;lt;version&amp;gt; &amp;lt;role&amp;gt;
200 listpeers 0cccb***** 35.236.*.*/64393;110;10726 327 1.6.3 LEAF
200 listpeers 3a46f***** 185.180.*.*/9993;110;757 -1 - PLANET
200 listpeers 3ed7c***** 39.97.*.*/9993;172;79 32 1.6.3 MOON
200 listpeers 4f838***** - -1 - LEAF
200 listpeers 62f86***** 50.7.*.*/9993;110;4796 351 - PLANET
200 listpeers 778cd***** 103.195.*.*/9993;5148;4887 253 - PLANET
200 listpeers 992fc***** 195.181.*.*/9993;10161;4921 226 - PLANET
200 listpeers 9d2b5***** - -1 - LEAF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Windows 플랫폼에서는 관리자 권한으로 터미널을 실행하고 zerotier-cli.bat 명령줄 도구를 사용하여 Linux 플랫폼에서는 zerotier-cli를 사용합니다. peers 서브 명령어는 연결 상태를 확인하고, listpeers는 모든 노드를 표시하며, &lt;code&gt;moon&lt;/code&gt; 노드가 정상적으로 표시되면 성공적으로 조인된 것입니다.&lt;/p&gt;
&lt;h2 id=&#34;어떻게-제거할-수-있나요&#34;&gt;어떻게 제거할 수 있나요
&lt;/h2&gt;&lt;p&gt;윈도우 플랫폼에서 제거하는 방법은 더 이상 설명하지 않겠습니다. 일반적인 작업으로 제어판을 통해 제거하면 됩니다. 우리는 &lt;code&gt;Ubuntu&lt;/code&gt;에 대해 중점적으로 이야기하겠습니다.&lt;/p&gt;
&lt;p&gt;dpkg를 통해 zerotier-one 서비스를 삭제합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo dpkg -P zerotier-one
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;zerotier-one 폴더를 삭제하면 주소가 저장되어 있는데, 삭제 후 다시 설치하면 새로운 주소를 얻을 수 있습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo rm -rf /var/lib/zerotier-one/
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;p&gt;원래 다 이미 제거해 놨는데, 서버는 도착했는데 적절한 프록시 노드 역할을 할 서비스가 없어서 알리바바 클라우드가 실적을 위해 개발 전용 서버를 제공했어. 사양은 높지 않고, 연간 99위안으로 저렴해서 두 대 정도 돌리고 있어. 서버에서 제공하는 대역폭이 마음에 들어서 그런 거야.&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.wnark.com/archives/152.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.wnark.com/archives/152.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/Yogile/p/12642423.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cnblogs.com/Yogile/p/12642423.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>VMware 가상 머신 디스크 공간 최적화</title>
        <link>https://ttf248.life/ko/p/vmware-virtual-disk-space-optimization/</link>
        <pubDate>Wed, 21 Jun 2023 18:35:41 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/vmware-virtual-disk-space-optimization/</guid>
        <description>&lt;p&gt;VMware 가상 머신을 설치하고 개발 시스템을 사용할 때, 보통은 디스크 공간을 넉넉하게 남겨두는데, 시간이 지나면 실제 파일 내용보다 훨씬 더 많은 로컬 디스크 공간을 차지하게 됩니다&lt;/p&gt;
&lt;h2 id=&#34;장면-묘사&#34;&gt;장면 묘사
&lt;/h2&gt;&lt;p&gt;df -h 명령어를 통해 현재 기계의 디스크 정보를 확인하니, 실제로 60GB를 사용 중이었고, 모든 스냅샷과 클론 이미지를 삭제했음에도 불구하고 로컬 가상 머신이 차지하는 디스크 공간은 여전히 60GB를 훨씬 넘어섰다. 본래 부족한 하드디스크에 더 많은 부담을 주게 되었다.&lt;/p&gt;
&lt;h2 id=&#34;선행-조건&#34;&gt;선행 조건
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;가상 머신 설치할 때, 미리 할당된 디스크를 선택하지 않았습니다&lt;/li&gt;
&lt;li&gt;가상 머신이 사용하는 공간보다 현재 로컬에 저장된 가상 머신의 하드 디스크에 남은 디스크 공간이 더 큽니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;남은 공간이 부족하므로, 임시로 가상 머신을 외장 하드 드라이브로 이동한 후 디스크를 최적화했다가 다시 이전하는 것을 고려해 볼 수 있습니다&lt;/p&gt;
&lt;h2 id=&#34;도구&#34;&gt;도구
&lt;/h2&gt;&lt;p&gt;공식적으로 &lt;code&gt;open-vm-tools&lt;/code&gt; 패키지를 제공하며, yum을 통해 설치하거나 VMware Tools 이미지 패키지로 설치할 수 있습니다&lt;/p&gt;
&lt;h2 id=&#34;명령&#34;&gt;명령
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vmware-toolbox-cmd disk shrink /
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;실행하면 가상 머신이 자동으로 종료되고 VMware 호스트 프로그램은 디스크 압축을 실행합니다. 이 작업 시간은 가상 머신의 크기와 디스크 액세스 속도에 따라 달라집니다.&lt;/p&gt;
&lt;p&gt;실행 결과는 여전히 꽤 괜찮으며, 가상 머신의 디스크 공간 사용량은 &lt;code&gt;df -h&lt;/code&gt;의 디스크 정보와 거의 동일합니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>스테이블 디퓨전 - 처음부터 설치하는 은원정후</title>
        <link>https://ttf248.life/ko/p/stable-diffusion-zero-install-saga/</link>
        <pubDate>Thu, 13 Apr 2023 00:23:54 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/stable-diffusion-zero-install-saga/</guid>
        <description>&lt;p&gt;국내 자료들을 보니 거의 다 &lt;strong&gt;아키바&lt;/strong&gt; 형님의 원클릭 배포 패키지를 추천하고 있네요. &lt;code&gt;Python&lt;/code&gt; 기반의 오픈소스 프로젝트인 만큼, 설치도 그렇게 복잡하지 않을 것 같아서 처음부터 직접 해보려고 합니다.&lt;/p&gt;
&lt;p&gt;AI 생성 이미지로 씨름하느라, 특별히 그래픽 카드를 교체했는데 &lt;code&gt;3060 12G&lt;/code&gt; 보급형 모델입니다. 7년간 사용한 &lt;code&gt;960&lt;/code&gt;은 영광스럽게도 은퇴했습니다.&lt;/p&gt;
&lt;p&gt;핵심적인 &lt;code&gt;pytorch cuda&lt;/code&gt; 설치, 예전에 &lt;code&gt;python&lt;/code&gt; 게임 보조 스크립트를 작성할 때 로컬에 설치한 적이 있는데, 생각보다 문제도 많이 겪고 &lt;code&gt;cuda&lt;/code&gt; 암호화가 계속 활성화되지 않는다&lt;/p&gt;
&lt;h2 id=&#34;처리할-일&#34;&gt;처리할 일
&lt;/h2&gt;&lt;p&gt;새로운 기사 구조로 재구성하여 pytorch, 버전 호환성, 버전을 확인하는 방법을 먼저 소개합니다
로컬에서 어떻게 처음부터 가상 환경을 만들고 PyTorch를 배포할 수 있나요?
번역 자료, 0부터 시작하는 Stable Diffusion &lt;a class=&#34;link&#34; href=&#34;https://stable-diffusion-art.com/install-windows/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stable-diffusion-art.com/install-windows/&lt;/a&gt;
자료 정리&lt;/p&gt;
&lt;h2 id=&#34;단계&#34;&gt;단계
&lt;/h2&gt;&lt;p&gt;중국어로 검색하면 관련 단계별 설치 튜토리얼을 찾기 어려울 수 있습니다. &lt;code&gt;Google&lt;/code&gt;에서 영어로 검색하면, 처음부터 시작하는 유사한 튜토리얼이 많이 있습니다. 필요한 것들을 설명했는데, 먼저 &lt;code&gt;git&lt;/code&gt;을 설치해야 하고, 그 다음에는 &lt;code&gt;python&lt;/code&gt;을 설치해야 한다고 했습니다. 그리고 저장소를 다운로드하고 스크립트를 더블 클릭하면 끝났습니다.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/AUTOMATIC1111/stable-diffusion-webui&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;자세한 사용법 및 FAQ는 &lt;code&gt;issues&lt;/code&gt;를 참고하시고, &lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki&lt;/a&gt; 를 확인하세요&lt;/p&gt;
&lt;p&gt;저도 왜인지 이 창고가 무엇을 하는 곳인지 설명하는 사람이 없네요. 사실 이름만 봐도 알 수 있습니다. 이건 인터페이스 콘솔이고, 우리를 더 편리하게 사용할 수 있도록 해 줍니다. 실제로 설치할 때, 그는 공식 저장소 내용을 다운로드하고 실제 &lt;code&gt;SD&lt;/code&gt; 코드를 가져옵니다.&lt;/p&gt;
&lt;p&gt;창고와 함께 설치 시작 스크립트도 만들었습니다. 현재 폴더에 &lt;code&gt;Python&lt;/code&gt; 가상 환경이 있는지 자동으로 인식하며, 있다면 기본적으로 현재 경로의 &lt;code&gt;python&lt;/code&gt;을 사용합니다.&lt;/p&gt;
&lt;p&gt;만약 완전한 초보 사용자라면, 다음을 참고해 보세요: &lt;a class=&#34;link&#34; href=&#34;https://stable-diffusion-art.com/install-windows/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stable-diffusion-art.com/install-windows/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;pytorch&#34;&gt;pytorch
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://pytorch.org/get-started/locally/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pytorch.org/get-started/locally/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;여기서부터 제가 오늘 말씀드리고 싶은 건데요, 우선 그들의 단계대로 스크립트를 바로 실행하지 마세요. 파이썬은 requirement 파일로 의존성 라이브러리를 설치하는데, 이건 별거 아니에요. 핵심은 그래픽 카드 드라이버 버전과 pytorch가 호환되는지 확인하는 겁니다. 이 부분에 대한 설명도 많은 사람들이 소개하고 있으니, 인터넷에서 찾아보면 쉽게 찾을 수 있을 거예요.&lt;/p&gt;
&lt;p&gt;참고 자료: &lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/weixin_40660408/article/details/129896700&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/weixin_40660408/article/details/129896700&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;가상 환경을 하나 만들어서, 즉 빈 가상 환경에서 먼저 공식 웹사이트에서 스크립트를 실행해서 pytorch를 설치하세요&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python -c &amp;quot;import torch; print(torch.version.cuda)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python -c &amp;quot;import torch; print(torch.__version__, torch.cuda.is_available())&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 두 스크립트는 설치해야 할 CUDA 버전을 확인하고, 설치가 성공적으로 되었는지 확인할 수 있습니다&lt;/p&gt;
&lt;p&gt;여기 화려한 조작은 권장하지 않으니, 일단 공식 페이지의 로직대로 복사해서 설치하면 되고, 바로 pip로 설치하면 실패할 가능성이 높거나 CUDA가 활성화되지 않을 수 있습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;중요한 점은 폴더 경로에 불필요한 것들이 없어야 합니다. 그렇지 않으면 pytorch를 사용할 수 없을 가능성이 매우 높습니다.&lt;/p&gt;
&lt;p&gt;중간에 여러 번 설치하고, 공식 설치 파일을 다운로드하여 수동으로 설치하는 방법도 시도했습니다. 2.0 버전으로 업그레이드하려고 했는데, 공식 문서에는 2.0 버전이 속도가 좀 더 빠르다고 되어 있습니다. 하지만 이전에는 많이 사용하지 않았고, Python 버전과 이것이 관련이 있는지 잘 모르겠습니다. 중간에 공식 매뉴얼을 살펴보니 3.8 버전을 사용하는 것이 좋다고 합니다. 그래서 약간의 충돌이 발생했는데, 이전에 원클릭 설치 패키지를 사용했더니 그 안에 3.10 버전이 있었습니다. 결국 처음부터 다시 시작하여 새 폴더를 만들고 가상 환경을 생성하고 torch가 성공적으로 설치되었는지 확인했습니다.&lt;/p&gt;
&lt;p&gt;그런 다음 이 설치된 가상 환경을 웹 UI 폴더 안에 이동하세요. 이때부터 스크립트 설치를 시작하면 다른 의존성 문제는 크게 줄어들 것입니다.&lt;/p&gt;
&lt;p&gt;이동 후에는 다음을 실행해야 합니다: python -m pip install &amp;ndash;upgrade &amp;ndash;force-reinstall pip, pip를 수정합니다&lt;/p&gt;
&lt;p&gt;아마 꽤 이상하게 보일 수도 있지만, 이 부분은 꽤 오랫동안 고생했어요. 제 torch를 제대로 인식하지 못했기 때문입니다. 모든 간섭 요소를 배제하기 위해 먼저 이것을 설치한 다음 다른 종속성 라이브러리를 설치하려고 했습니다.&lt;/p&gt;
&lt;h2 id=&#34;xformers&#34;&gt;Xformers
&lt;/h2&gt;&lt;p&gt;제안은 활성화하면 이미지 생성 속도를 높이고 기존 사용량을 줄일 수 있습니다. 부작용으로는 동일한 매개변수 그룹에서 &lt;strong&gt;생성된 이미지가 상대적으로 안정적이지 않을 수 있습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Xformers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;stable-diffusion-webui:Xformers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://huggingface.co/docs/diffusers/optimization/xformers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;huggingface optimization&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Optimization Ratio&lt;/th&gt;
&lt;th&gt;Time taken&lt;/th&gt;
&lt;th&gt;Torch active/reserved&lt;/th&gt;
&lt;th&gt;Sys VRAM&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;100.00%&lt;/td&gt;
&lt;td&gt;2m 57.03s&lt;/td&gt;
&lt;td&gt;7440/10058 MiB&lt;/td&gt;
&lt;td&gt;12288/12288 MiB (100.0%)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;51.02%&lt;/td&gt;
&lt;td&gt;1m 29.21s&lt;/td&gt;
&lt;td&gt;4547/7164 MiB&lt;/td&gt;
&lt;td&gt;9298/12288 MiB (75.67%)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;((masterpiece)),((best quality)),((high detial)),((realistic,))
Industrial age city, deep canyons in the middle,chinese architectural streets,bazaars, Bridges, (rainy days:1.2), (steampunk:0.8), chinese architecture
Negative prompt: nsfw,((cowboy)),(((pubic))), ((((pubic_hair))))sketch, duplicate, ugly, huge eyes, text, logo, monochrome, worst face, (bad and mutated hands:1.3), (worst quality:2.0), (low quality:2.0), (blurry:2.0), horror, geometry, bad_prompt, (bad hands), (missing fingers), multiple limbs, bad anatomy, (interlocked fingers:1.2), Ugly Fingers, (extra digit and hands and fingers and legs and arms:1.4), crown braid, ((2girl)), (deformed fingers:1.2), (long fingers:1.2),succubus wings,horn,succubus horn,succubus hairstyle, (bad-artist-anime), bad-artist, bad hand, borrowed character, text focus, watermark, sample watermark, character watermark, lofter username, photo date watermark, movie poster, magazine cover, journal, cover, cover page, doujin cover, album cover, manga cover, brand name imitation, EasyNegative,Tights, silk stockings,shorts
Steps: 35, Sampler: DPM adaptive, CFG scale: 5.5, Seed: 2223996555, Size: 1088x1088, Model hash: 543bcbc212, Model: base_Anything-V3.0-pruned, Clip skip: 2, ENSD: 31337
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;p&gt;왜 추천하는 원클릭 배포 패키지가 아닌지 궁금해하는데, 그 패키지 안에는 일부 설정이 작성자 개인적으로 커스터마이징된 부분이 있어서 공식 버전과 완전히 동일하지 않습니다. 만약 초보 사용자라면 왜 그런 파라미터를 설정해야 하는지에 대한 최선의 논리는 먼저 공식 버전을 사용하는 것입니다. 사용 시간이 길어질수록 공식 매뉴얼을 더 자주 살펴보면 어떤 파라미터를 조정해야 할지 알 수 있을 겁니다.&lt;/p&gt;
&lt;h2 id=&#34;그래픽-카드-선택&#34;&gt;그래픽 카드 선택
&lt;/h2&gt;&lt;p&gt;데이터 마이닝 이후, 그래픽카드 가격이 상대적으로 많이 내렸고, 일반적인 입문자라면 &lt;code&gt;3060&lt;/code&gt;과 &lt;code&gt;3060ti&lt;/code&gt; 사이에서 고민할 때 보통 더 큰 메모리 용량인 &lt;code&gt;12G&lt;/code&gt; 버전의 3060을 추천하는 경우가 많다. 결국 더 높은 해상도의 이미지를 생성할 수 있기 때문이다. 왜 더 높은 해상도가 필요하냐면, 이미지 생성 시 해상도를 높여서 더욱 선명하고 섬세한 이미지를 얻을 수 있기 때문이다. 만약 작은 이미지를 생성하고 싶다면 &lt;code&gt;8G&lt;/code&gt; 메모리 용량도 충분하다.&lt;/p&gt;
&lt;p&gt;아직 하나 더, &lt;strong&gt;고화질 확대&lt;/strong&gt; 옵션은 디테일을 구체화하여 화면의 디테일을 더욱 풍부하게 만들지만, 더 많은 비디오 메모리가 필요합니다&lt;/p&gt;
&lt;p&gt;다음은 NVIDIA GeForce GTX 970, GeForce RTX 3060 Ti, GeForce RTX 3060, GeForce RTX 3080 및 GeForce RTX 3080 Ti의 단정밀도(FP32), 반정밀도(FP16) 및 배정밀도(FP64) 부동소수점 연산 능력 사양 요약표입니다:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;그래픽 카드 모델&lt;/th&gt;
&lt;th&gt;출시 연도&lt;/th&gt;
&lt;th&gt;단정밀도 부동소수점 연산 능력 (TFLOPS)&lt;/th&gt;
&lt;th&gt;반정밀도 부동소수점 연산 능력 (TFLOPS)&lt;/th&gt;
&lt;th&gt;배정밀도 부동소수점 연산 능력 (TFLOPS)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GeForce GTX 970&lt;/td&gt;
&lt;td&gt;2014&lt;/td&gt;
&lt;td&gt;3.49&lt;/td&gt;
&lt;td&gt;87.2&lt;/td&gt;
&lt;td&gt;0.109&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3060 Ti&lt;/td&gt;
&lt;td&gt;2020&lt;/td&gt;
&lt;td&gt;16.2&lt;/td&gt;
&lt;td&gt;32.4&lt;/td&gt;
&lt;td&gt;0.51&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3060&lt;/td&gt;
&lt;td&gt;2021&lt;/td&gt;
&lt;td&gt;12.7&lt;/td&gt;
&lt;td&gt;25.4&lt;/td&gt;
&lt;td&gt;0.39&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3080&lt;/td&gt;
&lt;td&gt;2020&lt;/td&gt;
&lt;td&gt;29.8&lt;/td&gt;
&lt;td&gt;58.9&lt;/td&gt;
&lt;td&gt;0.93&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3080 Ti&lt;/td&gt;
&lt;td&gt;2021&lt;/td&gt;
&lt;td&gt;34.8&lt;/td&gt;
&lt;td&gt;68.7&lt;/td&gt;
&lt;td&gt;1.36&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;발췌한, &lt;a class=&#34;link&#34; href=&#34;https://docs.google.com/spreadsheets/d/1Zlv4UFiciSgmJZncCujuXKHwc4BcxbjbSBg71-SdeNk/edit#gid=0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;다양한 그래픽 카드 성능 테스트 데이터&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;업데이트&#34;&gt;업데이트
&lt;/h2&gt;&lt;p&gt;반년 정도의 공백을 두고, 원래는 설치 단계를 다시 정리하고 더 많은 기초 개념을 설명하려고 했는데, 결과적으로 보니 일반인들이 AI 그림을 그리는 건 다들 제공하는 이미지 파라미터를 기반으로 파라미터를 조정하거나, 이미 있는 이미지를 바탕으로 형식화된 재렌더링을 하는 것이더라고요&lt;/p&gt;
&lt;p&gt;중간에 프로젝트가 있었는데, AI를 이용해서 앱 UI 소재를 그려보려고 했더니, 반나절을 끙끙거려도 결과는 만족스럽지 않았어. 그냥 공식 앱에서 리소스를 가져오는 그림이 더 나은 것 같아.&lt;/p&gt;</description>
        </item>
        <item>
        <title>프로그램 최적화는 하드웨어에 맞서려 해서는 안 됩니다</title>
        <link>https://ttf248.life/ko/p/program-optimization-dont-fight-hardware/</link>
        <pubDate>Fri, 07 Apr 2023 16:30:15 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/program-optimization-dont-fight-hardware/</guid>
        <description>&lt;p&gt;하나의 루프 스레드인데, 소요 시간은 이미 &lt;strong&gt;마이크로초&lt;/strong&gt; 수준이며, 서버를 교체했더니 최대 6만 개의 데이터 패킷이 쌓이는 것에서 거의 쌓이지 않는 상태로 바뀌었습니다&lt;/p&gt;
&lt;p&gt;단일 스레드 루프 처리 시나리오에서 CPU 성능은 클럭 속도, 캐시 크기, 명령어 집합 아키텍처 등의 요인에 따라 달라집니다. 일반적으로 클럭 속도가 높고, 캐시가 크며, 명령어 집합 아키텍처가 더 발전된 CPU일수록 단일 스레드 데이터 처리 성능이 좋습니다.&lt;/p&gt;
&lt;h2 id=&#34;단일-스레드&#34;&gt;단일 스레드
&lt;/h2&gt;&lt;p&gt;성능 향상을 위해 스레드를 늘리는 것은 필수가 아니며, 프로젝트 흐름을 정리하고 병목 지점을 파악해야 합니다. 단일 스레드가 요구사항을 충족하는지 확인하고, 단일 스레드는 고려할 사항이 적고 문제 발생 가능성도 낮습니다.&lt;/p&gt;
&lt;p&gt;上来就说增加线程，이것 좀 이상하다&lt;/p&gt;
&lt;h2 id=&#34;사건&#34;&gt;사건
&lt;/h2&gt;&lt;p&gt;처리하는 것은 모두 &lt;strong&gt;시장 데이터이고, 지연에 민감하다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;吭哧吭哧加班一晚上，发布新的优化版本，本地剥离接口进行测试，速度也还行，tps：4.2万 낑낑대며 야근 한 밤새고, 새로운 최적화 버전 배포하고, 로컬에서 인터페이스 분리해서 테스트했는데, 속도도 괜찮고, TPS: 4만 2천&lt;/p&gt;
&lt;p&gt;서버에 배포하니 TPS가 급격히 떨어졌는데: 21,000. 집에 와서 데스크탑에서 시도해보니 TPS는 79,000이었다. 내부 서비스 가상화 환경에 문제가 있는 것 같기 시작했다. 우선 CPU 주파수가 원인이라고 의심했는데, 가정용 데스크탑과 서버의 CPU 차이점은 바로 주파수였다.&lt;/p&gt;
&lt;p&gt;테스트 서버 A&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;processor	: 7
vendor_id	: GenuineIntel
cpu family	: 6
model		: 47
model name	: Intel(R) Xeon(R) CPU E7- 4807  @ 1.87GHz
stepping	: 2
microcode	: 0x34
cpu MHz		: 1866.733
cache size	: 18432 KB
physical id	: 1
siblings	: 4
core id		: 3
cpu cores	: 4
apicid		: 7
initial apicid	: 7
fpu		: yes
fpu_exception	: yes
cpuid level	: 11
wp		: yes
flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss ht syscall nx rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc cpuid aperfmperf pni pclmulqdq ssse3 cx16 sse4_1 sse4_2 popcnt aes hypervisor lahf_lm pti dtherm arat
bugs		: clflush_monitor cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit
bogomips	: 3733.46
clflush size	: 64
cache_alignment	: 64
address sizes	: 40 bits physical, 48 bits virtual
power management:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;테스트 서버 B&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;processor	: 7
vendor_id	: GenuineIntel
cpu family	: 6
model		: 63
model name	: Intel(R) Xeon(R) CPU E5-2640 v3 @ 2.60GHz
stepping	: 2
microcode	: 0x3c
cpu MHz		: 2599.998
cache size	: 20480 KB
physical id	: 14
siblings	: 1
core id		: 0
cpu cores	: 1
apicid		: 14
initial apicid	: 14
fpu		: yes
fpu_exception	: yes
cpuid level	: 15
wp		: yes
flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc cpuid aperfmperf pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand hypervisor lahf_lm cpuid_fault epb pti fsgsbase smep xsaveopt cqm_llc cqm_occup_llc dtherm ida arat pln pts
bugs		: cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit
bogomips	: 5199.99
clflush size	: 64
cache_alignment	: 64
address sizes	: 40 bits physical, 48 bits virtual
power management:
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;openai에-문의하세요&#34;&gt;OpenAI에 문의하세요
&lt;/h2&gt;&lt;p&gt;먼저 코어 수와 클럭 속도 측면에서 Intel(R) Xeon(R) CPU E7- 4807 @ 1.87GHz는 6개의 물리적 코어와 12개의 논리적 코어를 가지고 있으며, 클럭 속도는 1.87GHz입니다. 반면에 Intel(R) Xeon(R) CPU E5-2640 v3 @ 2.60GHz는 8개의 물리적 코어와 16개의 논리적 코어를 가지고 있으며, 클럭 속도는 2.60GHz입니다. 따라서 코어 수와 클럭 속도 측면에서 볼 때, E5-2640 v3가 단일 스레드 처리 시 E7- 4807보다 더 유리해야 합니다.&lt;/p&gt;
&lt;p&gt;다음으로 캐시 크기 측면에서 E7-4807은 12MB의 캐시 크기를 가지고 있는 반면, E5-2640 v3는 20MB의 캐시 크기를 가지고 있습니다. 따라서 E5-2640 v3는 더 큰 캐시 공간을 제공하여 데이터 접근 속도와 캐시 히트율을 향상시킬 수 있습니다.&lt;/p&gt;
&lt;p&gt;마지막으로 아키텍처 측면에서 E5-2640 v3는 더 발전된 Haswell 아키텍처를 채택한 반면, E7-4807은 구형 Nehalem 아키텍처를 사용합니다. Haswell 아키텍처는 Nehalem 아키텍처에 비해 성능이 향상되었으며, 이는 E5-2640 v3의 단일 스레드 데이터 처리 성능 향상에 영향을 미칠 수 있습니다.&lt;/p&gt;
&lt;p&gt;따라서, 종합적으로 고려했을 때 단일 스레드 루프 처리 시나리오에서는 E5-2640 v3가 E7-4807보다 더 나은 성능을 보여줄 것으로 예상됩니다. 하지만 구체적인 성능 차이는 데이터 처리 알고리즘, 메모리 대역폭, 시스템 부하 등 다양한 요인의 영향을 받으므로, 개별 문제에 따라 분석해야 합니다.&lt;/p&gt;
&lt;h2 id=&#34;하드웨어-자료&#34;&gt;하드웨어 자료
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cpubenchmark.net/compare/3786.2vs2365.2/%5BDual-CPU%5D-Intel-Xeon-E7%e2%80%934807-vs-%5BDual-CPU%5D-Intel-Xeon-E5-2640-v3&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cpubenchmark.net/compare/3786.2vs2365.2/%5BDual-CPU%5D-Intel-Xeon-E7–4807-vs-%5BDual-CPU%5D-Intel-Xeon-E5-2640-v3&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Specification&lt;/th&gt;
&lt;th&gt;Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Price&lt;/td&gt;
&lt;td&gt;Search Online  $78 - BUY&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Socket Type&lt;/td&gt;
&lt;td&gt;LGA1567&lt;/td&gt;
&lt;td&gt;LGA2011-v3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU Class&lt;/td&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Clockspeed&lt;/td&gt;
&lt;td&gt;1.9 GHz&lt;/td&gt;
&lt;td&gt;2.6 GHz&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Turbo Speed&lt;/td&gt;
&lt;td&gt;Not Supported&lt;/td&gt;
&lt;td&gt;Up to 3.4 GHz&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;# of Physical Cores&lt;/td&gt;
&lt;td&gt;6 (Threads: 12)&lt;/td&gt;
&lt;td&gt;8 (Threads: 16)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Cache&lt;/td&gt;
&lt;td&gt;NA2&lt;/td&gt;
&lt;td&gt;NA2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Max TDP&lt;/td&gt;
&lt;td&gt;95W x 2&lt;/td&gt;
&lt;td&gt;90W x 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Yearly Running Cost&lt;/td&gt;
&lt;td&gt;$34.68&lt;/td&gt;
&lt;td&gt;$32.85&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Other&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;First Seen on Chart&lt;/td&gt;
&lt;td&gt;Q3 2020&lt;/td&gt;
&lt;td&gt;Q3 2014&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;# of Samples&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;46&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU Value&lt;/td&gt;
&lt;td&gt;69.1&lt;/td&gt;
&lt;td&gt;225.6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Single Thread Rating&lt;/td&gt;
&lt;td&gt;721 (-59.2%)&lt;/td&gt;
&lt;td&gt;1767 (0.0%)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU Mark&lt;/td&gt;
&lt;td&gt;6223 (-64.6%)&lt;/td&gt;
&lt;td&gt;17600 (0.0%)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description>
        </item>
        <item>
        <title>프롬프트 엔지니어</title>
        <link>https://ttf248.life/ko/p/prompt-engineer/</link>
        <pubDate>Sun, 26 Mar 2023 20:46:53 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/prompt-engineer/</guid>
        <description>&lt;p&gt;과거 검색 엔진 사용법을 배우던 것처럼, 우리도 AI와 소통하는 방법, 즉 합리적이고 충분한 조건을 제시하여 필요한 답변을 효율적으로 얻는 방법을 배워야 합니다&lt;/p&gt;
&lt;p&gt;만약 다른 각도에서 생각해 보면, 현재의 AI는 기억력이 아주 좋은 어린이에 해당합니다. 그는 눈에 보이는 것을 모두 외울 수 있고, 베끼기 능력이 있습니다. 우리가 해야 할 일은 AI와 어떻게 정확하고 효과적으로 소통하며, 요구사항을 정밀하게 묘사하여 AI가 예상되는 결과를 생성하도록 돕는 것입니다.&lt;/p&gt;
&lt;h2 id=&#34;과학-대중화&#34;&gt;과학 대중화
&lt;/h2&gt;&lt;p&gt;AI라고 불리는, 정확히 말하면 &lt;code&gt;Generative Pre-Training&lt;/code&gt;은 직역하면 생성적 사전 훈련입니다. 이는 인터넷에서 사용 가능한 데이터로 학습된 텍스트 생성 심층 학습 모델이며, 질의 응답, 텍스트 요약 생성, 기계 번역, 분류, 코드 생성 및 대화형 AI와 같은 작업에 사용됩니다. 현재 GPT-1, GPT-2, GPT-3 및 GPT-4 등 다양한 버전의 모델이 있으며, 각 버전은 이전 버전에 비해 더 크고 강력합니다.&lt;/p&gt;
&lt;h2 id=&#34;정말-인공지능이-있을까&#34;&gt;정말 인공지능이 있을까
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;유사도가 충분히 높으면 정확도 또한 높아집니다&lt;/li&gt;
&lt;li&gt;기본적이고 반복적인 업무는 특정 훈련을 거치면 더 이상 인공의 개입이 필요하지 않다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;생성형 AI는 기존의 텍스트, 오디오, 이미지 등 데이터를 활용하여 새로운 콘텐츠를 생성하는 기술입니다. 텍스트 생성, 음성 합성, 이미지 생성, 대화 시스템 등 다양한 작업에 사용될 수 있습니다. 생성형 AI의 논리성은 학습 데이터와 모델 구조에 따라 달라집니다. 일반적으로 생성형 AI는 문법, 논리 및 상식에 어느 정도 따르지만 오류, 편향 또는 부정확한 내용을 포함할 수도 있습니다. 따라서 생성형 AI의 출력은 인간의 판단과 검증이 필요하며 맹목적으로 믿거나 사용할 수 없습니다.&lt;/p&gt;
&lt;h2 id=&#34;프롬프트-엔지니어&#34;&gt;프롬프트 엔지니어
&lt;/h2&gt;&lt;p&gt;시간의 흐름은 거슬러갈 수 없고, 사람은 변화하는 흐름에 적응해야 합니다. AI가 똑똑하지 않다고 생각할 수도 있고, 논리성이 없다고 생각할 수도 있습니다. 코드를 작성해도 제대로 작동하지 않는 경우가 많습니다.&lt;/p&gt;
&lt;p&gt;만약 다른 각도에서 생각해 보면, 현재의 AI는 기억력이 아주 좋은 어린이에 해당합니다. 그는 눈에 보이는 것을 모두 외울 수 있고, 베끼기 능력이 있습니다. 우리가 해야 할 일은 AI와 어떻게 정확하고 효과적으로 소통하며, 요구사항을 정밀하게 묘사하여 AI가 예상되는 결과를 생성하도록 돕는 것입니다.&lt;/p&gt;
&lt;h2 id=&#34;대화-모드&#34;&gt;대화 모드
&lt;/h2&gt;&lt;p&gt;2년 전 &lt;code&gt;Github Copilot&lt;/code&gt;이 출시되었을 때, 2년 후 &lt;code&gt;OpenAI&lt;/code&gt;가 갑자기 등장하여 인간의 인지 능력을 크게 확장시키는 대규모 언어 모델의 가능성을 보여줄 거라고는 아무도 예상하지 못했습니다&lt;/p&gt;
&lt;p&gt;주석 기반 프로그래밍과 대화 기반 프로그래밍은 상호 작용 방식이 완전히 다르며, 대화의 패턴은 초보 사용자에게 친숙한 경험을 제공합니다. 여기서 &lt;code&gt;NewBing&lt;/code&gt;이 각 질문마다 제시하는 후속 질문 제안을 언급하지 않을 수 없는데, 이는 마이크로소프트가 사용자를 유도하여 AI 지식 데이터베이스에서 더 많은 정보를 얻으려고 시도하고 있는 것입니다.&lt;/p&gt;
&lt;h2 id=&#34;예시로-말하자면&#34;&gt;예시로 말하자면
&lt;/h2&gt;&lt;p&gt;고속철도 여행 시간은 길고, 코딩이 좋은 선택이다. 데이터 사용량이 제한적인 상황에서 몇 장의 사진을 처리하고 이미지 자료를 얻었지만, 소프트웨어를 다운로드하여 사진을 처리하는 것은 조금 사치스럽고 네트워크 환경도 허락하지 않는다.&lt;/p&gt;
&lt;p&gt;요구 사항은 다음과 같습니다. 투명 배경이 있는 이미지 자료가 여러 벌 있는데, 이것들을 앱의 내비게이션 바에 사용하려고 합니다. 선택된 상태는 컬러로, 선택되지 않은 상태는 흑백으로 하고, 원본 이미지는 모두 컬러입니다. 따라서 사전 처리 작업이 필요합니다.&lt;/p&gt;
&lt;p&gt;폴더에서 모든 이미지를 읽어와서, 이미지를 흑백으로 변환하고 투명 배경을 유지하며, 이미지 저장 시 품질을 최적화하여 파일 크기를 줄이고, 콘솔에 최적화 전후 파일 크기 비교를 표시하는 파이썬 코드를 작성하세요&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 导入必要的库
import os
import PIL
from PIL import Image

# 定义一个函数，将图片转换成黑白，维持透明背景，保存图片，并返回文件体积
def convert_and_save(image_file):
    # 打开图片
    image = Image.open(image_file)
    # 获取图片的模式，如果是 RGBA 模式，说明有透明背景
    mode = image.mode
    if mode == &amp;quot;RGBA&amp;quot;:
        # 创建一个和图片大小一致的白色背景图片
        background = Image.new(&amp;quot;RGB&amp;quot;, image.size, (255, 255, 255))
        # 将原图片粘贴到白色背景上，忽略透明像素
        background.paste(image, mask=image.split()[3])
        # 将合成的图片转换成灰度模式
        gray_image = background.convert(&amp;quot;L&amp;quot;)
        # 将灰度图片再转换成 RGBA 模式，以便保留透明背景
        final_image = gray_image.convert(&amp;quot;RGBA&amp;quot;)
    else:
        # 如果不是 RGBA 模式，直接将图片转换成灰度模式
        final_image = image.convert(&amp;quot;L&amp;quot;)
    # 获取原图片的文件名和扩展名
    file_name, file_ext = os.path.splitext(image_file)
    # 定义新图片的文件名，添加 _bw 后缀表示黑白
    new_file_name = file_name + &amp;quot;_bw&amp;quot; + file_ext
    # 保存新图片，并优化质量，减少文件体积
    final_image.save(new_file_name, optimize=True)
    # 获取原图片和新图片的文件体积，并返回
    old_size = os.path.getsize(image_file)
    new_size = os.path.getsize(new_file_name)
    return old_size, new_size

# 定义一个文件夹路径，存放所有的图片
folder_path = &amp;quot;images&amp;quot;
# 遍历文件夹中的所有文件
for file in os.listdir(folder_path):
    # 拼接完整的文件路径
    file_path = os.path.join(folder_path, file)
    # 判断是否是图片文件，根据扩展名判断，可以根据需要添加或修改扩展名
    if file_path.endswith((&amp;quot;.png&amp;quot;, &amp;quot;.jpg&amp;quot;, &amp;quot;.jpeg&amp;quot;, &amp;quot;.gif&amp;quot;)):
        # 调用函数，转换并保存图片，并获取文件体积
        old_size, new_size = convert_and_save(file_path)
        # 在控制台展示优化前后的文件体积大小对比
        print(f&amp;quot;{file}: {old_size} bytes -&amp;gt; {new_size} bytes&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;AI가 빠르게 답을 내놓았는데, 보기에 좋고 사용하기에도 괜찮은데, 경험이 많은 프로그래머라면 아래 코드가 충분히 일반적이지 않다고 느낄 것이고, 생산 환경에 적용하기도 어렵다고 생각할 것입니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;매개변수가 고정되었습니다&lt;/li&gt;
&lt;li&gt;로그 파일이 없고, 정보는 모두 콘솔에 출력됩니다&lt;/li&gt;
&lt;li&gt;이미지 처리는 다중 스레드 모델에 적합합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;뉴빙이 등장하여 프롬프트에 따라 질문을 선택했습니다: &lt;strong&gt;이 코드의 개선할 부분이 있나요?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;제공된 답변은 솔직히 기대 이상이었고, 일반 프로그래머가 생각할 수 있는 최적화 방안에 대해 AI가 해당하는 제안을 제시했습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;这段代码可能还有一些可以改进的地方，比如：

可以使用 argparse 库，让用户可以通过命令行参数指定文件夹路径和扩展名，而不是写死在代码里。
可以使用 logging 库，记录程序的运行情况，而不是直接打印到控制台。
可以使用 try-except 语句，捕获可能出现的异常，比如文件打开失败，图片转换失败等，并做相应的处理。
可以使用 multiprocessing 库，利用多核处理器，加速图片的转换和保存过程。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;매우 친절한 응답입니다. 배포 환경의 차이를 고려하여 다중 프로세스를 지원하지 않아도 괜찮습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;当然，我很乐意帮你修改一下代码。我尝试添加了 argparse, logging 和 try-except 语句，但没有添加 multiprocessing 库，因为我不确定你的电脑是否支持多核处理。修改后的代码如下：
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 导入必要的库
import argparse
import logging
import multiprocessing
import os

from PIL import Image


# 定义一个函数，将图片转换成黑白，维持透明背景，保存图片，并返回文件体积
def convert_and_save(image_file):
    # 打开图片
    try:
        image = Image.open(image_file)
    except Exception as e:
        logging.error(f&amp;quot;Failed to open {image_file}: {e}&amp;quot;)
        return None, None
    # 获取图片的模式，如果是 RGBA 模式，说明有透明背景
    mode = image.mode
    if mode == &amp;quot;RGBA&amp;quot;:
        # 创建一个和图片大小一致的白色背景图片
        background = Image.new(&amp;quot;RGB&amp;quot;, image.size, (255, 255, 255))
        # 将原图片粘贴到白色背景上，忽略透明像素
        background.paste(image, mask=image.split()[3])
        # 将合成的图片转换成灰度模式
        gray_image = background.convert(&amp;quot;L&amp;quot;)
        # 将灰度图片再转换成 RGBA 模式，以便保留透明背景
        final_image = gray_image.convert(&amp;quot;RGBA&amp;quot;)
    else:
        # 如果不是 RGBA 模式，直接将图片转换成灰度模式
        final_image = image.convert(&amp;quot;L&amp;quot;)
    # 获取原图片的文件名和扩展名
    file_name, file_ext = os.path.splitext(image_file)
    # 定义新图片的文件名，添加 _bw 后缀表示黑白
    new_file_name = file_name + &amp;quot;_bw&amp;quot; + file_ext
    # 保存新图片，并优化质量，减少文件体积
    try:
        final_image.save(new_file_name, optimize=True)
    except Exception as e:
        logging.error(f&amp;quot;Failed to save {new_file_name}: {e}&amp;quot;)
        return None, None
    # 获取原图片和新图片的文件体积，并返回
    old_size = os.path.getsize(image_file)
    new_size = os.path.getsize(new_file_name)
    return file_name, old_size, new_size

# 定义一个函数，解析命令行参数，并返回文件夹路径和扩展名列表
def parse_args():
    # 创建一个解析器对象
    parser = argparse.ArgumentParser(description=&amp;quot;Convert images to black and white and optimize quality.&amp;quot;)
    # 添加一个必选的位置参数，表示文件夹路径
    parser.add_argument(&amp;quot;folder_path&amp;quot;, help=&amp;quot;The path of the folder that contains the images.&amp;quot;)
    # 添加一个可选的参数，表示扩展名列表，默认为 png, jpg, jpeg 和 gif
    parser.add_argument(&amp;quot;-e&amp;quot;, &amp;quot;--extensions&amp;quot;, nargs=&amp;quot;+&amp;quot;, default=[&amp;quot;.png&amp;quot;, &amp;quot;.jpg&amp;quot;, &amp;quot;.jpeg&amp;quot;, &amp;quot;.gif&amp;quot;], help=&amp;quot;The extensions of the image files.&amp;quot;)
    # 解析命令行参数，并返回结果对象
    args = parser.parse_args()
    return args.folder_path, args.extensions

# 定义一个函数，打印优化前后的文件体积大小对比
def print_result(result):
    # 如果结果不为空，说明转换和保存成功
    if result:
        # 解包结果为文件名和文件体积元组
        if len(result) == 3:
            file, old_size, new_size = result
            # 在控制台展示优化前后的文件体积大小对比
            logging.info(f&amp;quot;{file}: {old_size} bytes -&amp;gt; {new_size} bytes&amp;quot;)
        else:
            logging.info(f&amp;quot;{result}&amp;quot;)

# 配置日志记录器，将日志输出到控制台和文件中，设置日志等级为 INFO
logging.basicConfig(level=logging.INFO,
                    format=&amp;quot;%(asctime)s %(levelname)s %(message)s&amp;quot;,
                    handlers=[logging.StreamHandler(),
                              logging.FileHandler(&amp;quot;log.txt&amp;quot;)])

# 调用函数，获取文件夹路径和扩展名列表
folder_path, extensions = parse_args()

if __name__ == &amp;quot;__main__&amp;quot;:
    # Windows 需要这个函数的原因是 Windows 缺乏 fork() 函数（这不完全正确）。
    # 因此，在 Windows 上，fork() 是通过创建一个新的进程来模拟的，这个新的进程中运行的代码，在 Linux 上是在子进程中运行的。
    # 由于这些代码要在技术上无关的进程中运行，所以它必须在运行之前被传递到那里。
    # 传递的方式是先将它们序列化，然后通过管道从原始进程发送到新的进程。
    # 另外，这个新的进程被通知它必须运行通过管道传递的代码，通过向它传递 --multiprocessing-fork 命令行参数。
    # 如果你看一下 freeze_support() 函数的实现，它的任务是检查它运行在哪个进程中，是否应该运行通过管道传递的代码
    multiprocessing.freeze_support()

    # 创建一个进程池，根据电脑的核心数自动分配进程
    pool = multiprocessing.Pool()
    # 创建一个空列表，用于存放异步任务的结果对象
    results = []
    # 遍历文件夹中的所有文件
    for file in os.listdir(folder_path):
        # 拼接完整的文件路径
        file_path = os.path.join(folder_path, file)
        # 判断是否是图片文件，根据扩展名判断，可以根据需要修改扩展名列表
        if any(file_path.endswith(ext) for ext in extensions):
            # 调用函数，转换并保存图片，并获取文件体积，使用异步方式，不阻塞主进程
            result = pool.apply_async(convert_and_save, args=(file_path,), callback=print_result)
            # 将结果对象添加到列表中
            results.append((file, result))
    # 关闭进程池，不再接受新的任务
    pool.close()
    # 等待所有的任务完成
    pool.join()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;p&gt;로컬 개발 환경이 &lt;code&gt;windows&lt;/code&gt; 시스템이기 때문에, &lt;code&gt;AI&lt;/code&gt;가 처음 제시한 답변에는 &lt;code&gt;main&lt;/code&gt; 함수와 &lt;code&gt;multiprocessing.freeze_support&lt;/code&gt;가 포함되지 않았습니다. 질문을 통해 발생한 오류를 해결하여 코드를 수정했습니다.&lt;/p&gt;
&lt;p&gt;과거 검색 엔진 사용법을 배우던 것처럼, AI와 소통하는 방법도 배워야 합니다. 합리적이고 충분한 조건을 제시하여 필요한 답변을 효율적으로 얻어야 합니다.&lt;/p&gt;
&lt;p&gt;주의: &lt;strong&gt;만약 여러분이 프로그래밍 초보이고 주어진 주석을 바탕으로도 이해가 안 되는 부분이 있다면 관련 코드에 대해 계속 질문해도 좋습니다.&lt;/strong&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>위챗 미니 프로그램 배경 및 개발 환경</title>
        <link>https://ttf248.life/ko/p/wechat-mini-program-background-and-development-environment/</link>
        <pubDate>Fri, 24 Mar 2023 21:59:11 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/wechat-mini-program-background-and-development-environment/</guid>
        <description>&lt;p&gt;위챗 미니 프로그램 소개 및 개발 준비&lt;/p&gt;
&lt;h2 id=&#34;왜-소규모-프로그램이-있을까&#34;&gt;왜 소규모 프로그램이 있을까?
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;더 나은 경험: 내장된 웹 페이지 로딩이 느리고, 흰 화면이 나타납니다. 네이티브 앱의 경험은 더 빠른 로딩을 제공합니다.&lt;/li&gt;
&lt;li&gt;규범과 관리: 위챗의 경우, 접속 및 관리&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;小程序发布되기 전에, 微信은 &lt;code&gt;JSSDK&lt;/code&gt;라는 &lt;code&gt;SDK&lt;/code&gt;를 출시하여 微信의 원어민 기능인 微信支付, 카드券 기능을 개방했습니다. 하지만 개발자는 웹 페이지 개발 언어를 기반으로 개발하여 微信의 일부 규제를 우회할 수 있었습니다. 小程序은 자체적인 설명 언어를 가지고 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;무엇이-미니-프로그램인가&#34;&gt;무엇이 미니 프로그램인가?
&lt;/h2&gt;&lt;p&gt;미니 프로그램은 다운로드나 설치 없이 사용할 수 있는 애플리케이션으로, 앱을 손쉽게 이용할 수 있다는 꿈을 실현했습니다&lt;/p&gt;
&lt;p&gt;사용자가 스캔하거나 검색하기만 하면 앱을 열 수 있다는 점도 &lt;strong&gt;쓰고 버리는&lt;/strong&gt; 개념을 반영합니다&lt;/p&gt;
&lt;p&gt;사용자는 너무 많은 앱을 설치했는지 여부에 대해 걱정할 필요가 없습니다. 앱은 어디에나 존재하고 언제든지 사용할 수 있지만, &lt;strong&gt;설치하거나 제거할 필요는 없습니다&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&#34;미니-프로그램과-모바일-앱의-차이점&#34;&gt;미니 프로그램과 모바일 앱의 차이점
&lt;/h2&gt;&lt;p&gt;설치 불필요, 메모리 차지 없음, 간편한 전파: QR 코드, 미니 프로그램 카드, 검색&lt;/p&gt;
&lt;h2 id=&#34;小程序로-무엇을-할-수-있나요&#34;&gt;小程序로 무엇을 할 수 있나요
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;콘텐츠 도구: 지식, 웨이보 인기 게시물, 모바이크 자전거, 오늘날부 터, 텐센트 지도, 텐센트 번역&lt;/li&gt;
&lt;li&gt;소매: 핀두어두오, 징둥쇼핑, 무궁가게, 메이리우션, 샤오미몰, 퀴청스&lt;/li&gt;
&lt;li&gt;게임: 쩜프쩜프, 즐거운 땅따먹기, 즐거운 마작, 도유 라이브, YY 라이브&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;강의 내용은 2018년 것이고, 지금은 일부 애플리케이션 공급업체가 이미 문을 닫았습니다&lt;/p&gt;
&lt;h2 id=&#34;개발-준비&#34;&gt;개발 준비
&lt;/h2&gt;&lt;p&gt;소규모 프로그램 계정 등록: 일반적인 정보 입력으로 등록 가능하며, 이메일로 활성화 링크를 클릭하세요
정보 등록
3. 소규모 프로그램 관리 백오피스에 로그인하세요.
미니 프로그램 정보 보완
개인 개발자는 로그인한 위챗 계정이 관리자 계정으로, 별도의 바인딩 작업이 필요 없습니다&lt;/p&gt;
&lt;p&gt;이메일 계정에는 제한이 있어 새로운 이메일 주소가 필요하지만, QQ 메일은 별칭을 신청할 수 있고 微信 백엔드에서는 이를 검증하지 않습니다. 시도해 본 결과, 소규모 프로그램 이름이 다소 까다롭지만 상표가 관련된 경우 쉽게 승인에 실패합니다.&lt;/p&gt;
&lt;p&gt;서비스 카테고리를 선택할 수도 있고, 직접 추가할 수도 있습니다. 하나의 소규모 프로그램은 다섯 개의 카테고리를 추가할 수 있습니다.&lt;/p&gt;
&lt;p&gt;설정 안에서 소규모 프로그램의 &lt;code&gt;ID&lt;/code&gt; 정보를 확인할 수 있을 뿐만 아니라 메시지 푸시도 활성화할 수 있습니다. 메시지 푸시를 활성화하면 메시지 템플릿 기능을 사용할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;개발자-도구필자의-경험담&#34;&gt;개발자 도구(필자의 경험담)
&lt;/h2&gt;&lt;p&gt;정상적으로 다운로드 및 설치하면 특별한 주의사항은 없고, 간단히 알아보고 바로 방문자 모드로 들어가면 됩니다. 휴대폰 디버깅을 활성화하여 소형 프로그램의 개발 버전을 보고 싶다면, 소형 프로그램 개발자 계정에 로그인한 후 설정에서 프로젝트 상세 정보 내에서 지정된 소형 프로그램 ID로 전환해야 합니다.&lt;/p&gt;
&lt;h2 id=&#34;코드-구조&#34;&gt;코드 구조
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;JS: 상호작용 로직&lt;/li&gt;
&lt;li&gt;JSON：데이터 설정&lt;/li&gt;
&lt;li&gt;인터페이스의 요소&lt;/li&gt;
&lt;li&gt;인터페이스 스타일&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>사무실 이전에 서버 접속이 안 됩니다</title>
        <link>https://ttf248.life/ko/p/office-migration-server-unavailable/</link>
        <pubDate>Sat, 11 Mar 2023 01:42:05 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/office-migration-server-unavailable/</guid>
        <description>&lt;p&gt;행정 공지, 사무실 위치 변경, 기존 2층에서 15층으로 이전, 평범한 자리 이동입니다&lt;/p&gt;
&lt;h2 id=&#34;디자인-감각&#34;&gt;디자인 감각
&lt;/h2&gt;&lt;p&gt;사무실 건물&lt;/p&gt;
&lt;h2 id=&#34;이주&#34;&gt;이주
&lt;/h2&gt;&lt;p&gt;퇴근하면서 짐을 정리하고, 익숙하게 자리를 옮겨 새로운 자리에서 컴퓨터 배선을 조정하니 편안한 자세로 일하기 딱 좋네요&lt;/p&gt;
&lt;p&gt;(ÒωÓױ)！ 인터넷 연결했는데, 팀에서 주로 사용하는 서버에 접속이 안 돼요. 무선 네트워크로 바꿔보니 다시 정상적으로 접속되네요.&lt;/p&gt;
&lt;p&gt;처음에는 서버 네트워크 세그먼트 설정 문제라고 생각했습니다. 새로운 작업 공간의 유선 네트워크는 방화벽 구성 목록에 없어서 IT 동료에게 연락해서 조정하면 될 거라고 생각했죠. 그런데 이 네트워크 세그먼트는 여러 대의 서버가 있는데, 다른 서버들에 접속해 보니 모두 정상이었고, 점차 의심이 들기 시작했습니다. 전문적인 일은 전문가에게 맡기는 것이 좋다고 생각하고, 결국 운영 부서 동료들이 문제 해결을 위해 조사한 결과, 해당 서버에 &lt;code&gt;docker&lt;/code&gt;가 배포되어 있어서 서비스의 기본 네트워크 &lt;code&gt;docker0&lt;/code&gt;와 사무실 유선 네트워크 구성 세그먼트 간 충돌이 발생하여 전송된 데이터 패킷이 응답을 받지 못하고 &lt;code&gt;docker&lt;/code&gt; 서비스로 라우팅되었다는 것을 확인했습니다.&lt;/p&gt;
&lt;p&gt;다른 서버에는 &lt;code&gt;docker&lt;/code&gt; 서비스가 배포되어 있지 않아서, 이 서버만 사용하고 있고 가끔 컨테이너로 테스트 서비스를 배포하곤 했는데, 이런 상황을 마주할 줄은 몰랐다. 나중에 생각해보니, 그룹 전체가 같은 사무실 건물에 있고 IT 부서 동료들이 네트워크 세그먼트를 분할하면서 &lt;code&gt;172&lt;/code&gt;로 시작하는 주소를 사용한 것은 이상한 일이 아니라고 생각했다.&lt;/p&gt;
&lt;h2 id=&#34;docker0&#34;&gt;docker0
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# vim /etc/docker/daemon.json
{
    &amp;quot;bip&amp;quot;:&amp;quot;172.200.0.1/24&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;서비스를 재시작하고 새로운 네트워크로 전환하면 서버가 정상적으로 접근 가능해집니다&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;p&gt;도커 입문부터 실전까지 - docker0&lt;/p&gt;</description>
        </item>
        <item>
        <title>임베디드 입문 1 - 전문 용어</title>
        <link>https://ttf248.life/ko/p/embedded-introduction-professional-terms/</link>
        <pubDate>Tue, 07 Mar 2023 13:42:36 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/embedded-introduction-professional-terms/</guid>
        <description>&lt;p&gt;임베디드 시스템을 얘기하면 아직도 학교 연구실의 51 단일칩 컴퓨터와 프리스케일을 떠올린다&lt;/p&gt;
&lt;p&gt;LPA3399Pro는 루신(Rockchip) RK3399Pro 플랫폼을 기반으로 개발된 비전 호스트로, 대규모 시각 연산이 필요한 휴대용 컴퓨팅 장치에 적합합니다. 내장 NPU 컴퓨팅 유닛을 통해 3.0TOPS의 연산 능력을 제공하며 다양한 알고리즘 모델을 지원합니다.&lt;/p&gt;
&lt;p&gt;RV1109은 딥알 AI 머신 비전 브랜치의 SoC인 루싱위(Realtek Vision)의 제품이며, 내장된 독립 NPU를 갖추고 있습니다. RV1109은 1 TOPS의 연산 능력을 제공할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;system-on-chip&#34;&gt;System on Chip
&lt;/h2&gt;&lt;p&gt;SoC는 System on a Chip의 약자로, “칩상 시스템”을 의미합니다. 이는 여러 전자 시스템을 하나의 칩에 통합하는 기술입니다. 이 기술은 전자 제품의 크기와 무게를 크게 줄이는 동시에 성능을 향상시키고 전력 소비를 낮출 수 있습니다.&lt;/p&gt;
&lt;p&gt;SoC(시스템 온 어 칩)와 CPU(중앙 처리 장치)는 모두 컴퓨터 시스템의 중요한 구성 요소이지만, 이 둘 사이에는 몇 가지 차이가 있습니다&lt;/p&gt;
&lt;p&gt;CPU는 컴퓨터 시스템에서 핵심적인 프로세서로서 프로그램 명령어를 실행하는 역할을 담당합니다. 일반적으로 연산 장치, 제어 장치 및 레지스터와 같은 기본 부품으로만 구성됩니다.&lt;/p&gt;
&lt;p&gt;SoC는 여러 전자 시스템을 하나의 칩에 통합한 것으로, CPU 외에도 메모리, 그래픽 프로세서, 입출력 인터페이스 등 다른 구성 요소를 포함할 수 있습니다. 이를 통해 전자 제품의 크기와 무게를 크게 줄이고 성능을 향상시키면서 전력 소비를 낮출 수 있습니다.&lt;/p&gt;
&lt;p&gt;전반적으로, CPU는 SoC의 구성 요소이며, SoC는 더욱 복잡하고 통합된 전자 시스템입니다&lt;/p&gt;
&lt;h2 id=&#34;microcontroller-unit&#34;&gt;Microcontroller Unit
&lt;/h2&gt;&lt;p&gt;SoC(시스템 온 칩)와 MCU(마이크로컨트롤러 유닛)는 여러 전자 시스템을 하나의 칩에 통합하는 기술이지만, 이들 사이에는 몇 가지 차이점이 있습니다&lt;/p&gt;
&lt;p&gt;MCU는 일반적으로 CPU, 메모리, 입출력 인터페이스와 같은 기본 부품을 포함하는 마이크로컨트롤러입니다. 이는 가전제품, 자동차 전자 시스템과 같이 다른 전자 장치를 제어하는 데 자주 사용됩니다.&lt;/p&gt;
&lt;p&gt;SoC는 더 많은 전자 시스템을 하나의 칩에 통합하는 것으로, MCU의 기본 구성 요소를 포함하는 것 외에도 그래픽 프로세서, 무선 통신 모듈과 같은 다른 구성 요소도 통합할 수 있습니다. 이를 통해 전자 제품의 크기와 무게를 크게 줄이는 동시에 성능을 향상시키고 전력 소비를 낮출 수 있습니다.&lt;/p&gt;
&lt;p&gt;결론적으로, MCU는 간단한 마이크로컨트롤러이고, SoC는 더욱 복잡하고 통합된 전자 시스템입니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>AI 지원 프로그래밍, 생산성 진화</title>
        <link>https://ttf248.life/ko/p/ai-assisted-programming-productivity-evolution/</link>
        <pubDate>Tue, 28 Feb 2023 17:05:17 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/ai-assisted-programming-productivity-evolution/</guid>
        <description>&lt;p&gt;깃허브 코파일럿이 출시된 지 2년도 채 되지 않았는데, 챗GPT가 등장했네요. 작동 원리는 잘 모르겠지만, 둘 다 한동안 사용하고 있습니다. 두 도구는 보조 기능에서 완전히 다르지만, 생산성 향상에 큰 도움이 됩니다.&lt;/p&gt;
&lt;p&gt;너무 복잡한 일은 아직 AI가 해내지 못합니다. 결국 그들은 논리가 없고, 패턴이 있거나 패러다임이 고정된 일은 훈련 데이터가 충분하면 AI의 효과는 90%까지 도달할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;github-copilot&#34;&gt;github copilot
&lt;/h2&gt;&lt;p&gt;발표할 때, 공식 홈페이지의 소개 &lt;code&gt;demo&lt;/code&gt;를 보고 보니까 그렇게 똑똑해 보이지 않았고, 사용해 봤는데 잘 안 돼서 포기했다&lt;/p&gt;
&lt;p&gt;2022년 이전에는, 시간 날 때마다 새로운 버전으로 바꿔서 사용해 보는데, 효과는 꽤 괜찮은 편이야. 다만 국내 속도가 좀 느린 것 같아. 네트워크 문제일 확률이 높지. &lt;code&gt;Python&lt;/code&gt; 같은 언어는 주석을 보고 코드를 짜면, 제가 자료를 찾아 직접 작성하는 것보다 훨씬 빠르더라고요.&lt;/p&gt;
&lt;h2 id=&#34;chatgpt&#34;&gt;ChatGPT
&lt;/h2&gt;&lt;p&gt;깃허브 코파일럿은 아직 프로그래머, 즉 개발의 관점에서 제품을 설계하고 있으며, 프로그래밍 방법을 이해해야 하고, 점차 주석을 통해 AI를 보조 프로그래밍하도록 유도해야 합니다&lt;/p&gt;
&lt;p&gt;ChatGPT가 다음 단계로 진화하여 &lt;strong&gt;전문가가 아닌 일반인도 빠르게 익힐 수 있게 되었습니다&lt;/strong&gt;. 대화형 챗 인터페이스 덕분에 질문하고, 요구사항을 설명하며, 이해가 안 되는 부분은 계속해서 질문할 수 있습니다.&lt;/p&gt;
&lt;p&gt;간단한 예시로, 토큰화 개념은 알지만 코딩하는 방법은 모르고 문자열의 유사도를 계산하고 싶습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Python 分词计算 維天運通 LOGORY 和 合肥維天運通信息科技股份有限公司 两个字符串的相似度；
比较前，统一处理字符串，英文转换为小写；
第二个字符中如果能找到第一个字符的首字符，将第二个字符串截位，截位的长度为第一个字符串的长度
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;안녕하세요, 빙입니다. 😊&lt;/p&gt;
&lt;p&gt;온라인 정보에 따르면 123, Python 토큰화 계산은 jieba 라이브러리를 사용하여 구현할 수 있습니다. jieba 라이브러리는 정확 모드, 전체 모드 및 검색 엔진 모드의 세 가지 토큰화 모드를 지원합니다. 필요에 따라 적절한 모드를 선택할 수 있습니다.&lt;/p&gt;
&lt;p&gt;두 문자열의 유사도를 비교하려면 먼저 토큰화한 다음 단어 벡터 또는 편집 거리와 같은 지표를 계산해야 합니다. 수학 연산에는 numpy나 scipy 등의 라이브러리를 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;문자열을 일관되게 처리하기 위해 영문자를 소문자로 변환하려면 Python의 내장 함수 lower()를 사용할 수 있습니다&lt;/p&gt;
&lt;p&gt;두 번째 문자열을 추출하려면 Python의 슬라이스 연산자 []를 사용할 수 있습니다&lt;/p&gt;
&lt;p&gt;다음은 가능한 코드 예제입니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import jieba
import numpy as np
from scipy.spatial.distance import cosine

# 定义两个字符串
str1 = &amp;quot;維天運通 LOGORY&amp;quot;
str2 = &amp;quot;合肥維天運通信息科技股份有限公司&amp;quot;

# 统一处理字符串，英文转换为小写
str1 = str1.lower()
str2 = str2.lower()

# 找到第二个字符串中第一个字符的位置
index = str2.find(str1[0])

# 如果找到了，截取第二个字符串
if index != -1:
    str2 = str2[index:index+len(str1)]

# 使用 jieba 库进行分词
words1 = list(jieba.cut(str1))
words2 = list(jieba.cut(str2))

# 计算两个字符串的词向量（以词频作为权重）
vector1 = np.zeros(len(words1))
vector2 = np.zeros(len(words1))

for i, word in enumerate(words1):
    vector1[i] += 1 # 统计第一个字符串中每个词出现的次数
    if word in words2:
        vector2[i] += 1 # 统计第二个字符串中每个词出现的次数

# 计算两个字符串的相似度（以余弦距离作为指标）
similarity = 1 - cosine(vector1, vector2)

print(&amp;quot;两个字符串的相似度是：&amp;quot;, similarity)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;더 나아가서, 실행 결과를 문의했더니, 당신을 축하하며 문제점을 발견했습니다. 결과는 날조된 것이고, 실제 코드를 실행하지 않고도 괜찮은 결과를 보여줍니다.&lt;/p&gt;
&lt;h3 id=&#34;밤&#34;&gt;밤
&lt;/h3&gt;&lt;p&gt;SQL 쿼리, 제품 코드 테이블에서 제품 코드가 80000부터 89999 사이인 레코드를 찾아주세요&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;你好，这是 Bing。😊

根据搜索结果12，你可以使用 SQL BETWEEN 运算符来选择给定区间内的值。BETWEEN 运算符包含了开始和结束的值。

你需要先指定要查询的表名和列名，然后在 WHERE 子句中使用 BETWEEN 运算符和区间值。

例如，如果你要查询产品代码表中，产品代码在 80000 到 89999 之间的记录，你可以使用以下语句：

SELECT * FROM product_code
WHERE code BETWEEN 80000 AND 89999;
这里，* 表示选择所有列3。如果你只想选择特定的列，比如产品名称和价格，你可以用逗号分隔它们，如下：

SELECT name, price FROM product_code
WHERE code BETWEEN 80000 AND 89999;
希望这能帮助到你。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;계속 질문하고 반박하세요: 제품 코드는 문자열인데, 당신의 코드가 잘못되었습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;抱歉，我没有注意到产品代码是字符串。如果是这样的话，你需要在区间值两边加上单引号，如下：

SELECT * FROM product_code
WHERE code BETWEEN &#39;80000&#39; AND &#39;89999&#39;;
请原谅我的错误。🙏
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;축하해요, 틀릴 거예요&lt;/p&gt;</description>
        </item>
        <item>
        <title>자주 사용하지 않는 몇 가지 GIT 명령어 모음</title>
        <link>https://ttf248.life/ko/p/git-less-common-commands-summary/</link>
        <pubDate>Fri, 17 Feb 2023 10:08:57 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/git-less-common-commands-summary/</guid>
        <description>&lt;p&gt;자주 사용하지는 않지만 매우 유용한 &lt;code&gt;git&lt;/code&gt; 명령어&lt;/p&gt;
&lt;h3 id=&#34;시스템-재설치로-인해-windows-상의-폴더-소유자-정보가-변경되었습니다&#34;&gt;시스템 재설치로 인해 &lt;code&gt;windows&lt;/code&gt; 상의 폴더 소유자 정보가 변경되었습니다
&lt;/h3&gt;&lt;p&gt;새 버전의 &lt;code&gt;git&lt;/code&gt;에서 보안 검증이 추가되어 안전하지 않다는 경고가 발생하여 더 이상 작업을 진행할 수 없습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global --add safe.directory
git config --global --add safe.directory &amp;quot;*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;새-컴퓨터에-계정-비밀번호-정보를-저장합니다&#34;&gt;새 컴퓨터에 계정 비밀번호 정보를 저장합니다
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global credential.helper store
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;정보를 업데이트하려면 먼저 기존 증거를 정리하세요&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --system --unset credential.helper
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>컴파일러, 콜백 함수, 성능 테스트</title>
        <link>https://ttf248.life/ko/p/compiler-callback-function-performance-testing/</link>
        <pubDate>Wed, 15 Feb 2023 13:59:25 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/compiler-callback-function-performance-testing/</guid>
        <description>&lt;p&gt;지난해에 SDK를 설계했는데, 이 SDK는 일부 이벤트 처리 및 캡슐화를 담당하고, 클래스 인터페이스를 통해 외부로 제공합니다. 서비스 초기화 시에는 호출자가 해당 클래스를 구현하고 객체 포인터를 모듈에 전달합니다.
C11을 접해보다 보니 호기심이 고양이의 목숨을 앗아가듯, 이러한 인터페이스들을 &lt;code&gt;lambda&lt;/code&gt; 함수 객체 콜백으로 구현하면 어떤 결과가 나올지 궁금했습니다. 순수 추상 함수의 인터페이스 정의 방법과 비교했을 때 더 유연하다고 생각합니다.
의문이 생겼다. 두 가지 다른 문법 중 성능 면에서 어느 것이 더 빠른가? 컴파일 원리를 모르는 사람이 코드를 조금 작성해서 확인해 보았다.&lt;/p&gt;
&lt;h2 id=&#34;서론&#34;&gt;서론
&lt;/h2&gt;&lt;p&gt;온라인 주소이며, 다양한 컴파일러와 컴파일 옵션을 선택하고 &lt;code&gt;linux&lt;/code&gt; 플랫폼에서 코드를 실행하거나 해당 어셈블리 코드를 확인할 수 있습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가끔 기술 검증을 하는데, 웹 페이지에서 짧은 코드 조각을 실행하는 것이 편리합니다&lt;/li&gt;
&lt;li&gt;Godbolt.org는 다양한 색상으로 다른 어셈블리 코드를 구분하여 로컬 디버거보다 훨씬 편리합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;표준위원회에서 문법 규칙을 제정했으며, 컴파일 단계에서 어떻게 구현할지는 각 컴파일러에 달려 있습니다. 여기서 짚고 넘어가야 할 것은 마이크로소프트의 컴파일러는 꽤 강력하다는 점입니다. 문법적 설탕이 만능은 아니며, 콜백 인터페이스가 많지 않으므로 &lt;code&gt;lambda&lt;/code&gt;를 사용하면 더욱 편리하고 빈 콜백 함수 인터페이스를 정의할 필요도 없습니다. 콜백 인터페이스 종류가 다양해질 때는 전통적인 가상 함수가 비즈니스 인터페이스 정의의 통일성을 더 돕습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;윈도우 플랫폼에서는 두 제품의 성능이 거의 비슷하며 큰 차이가 없습니다&lt;/li&gt;
&lt;li&gt;리눅스 플랫폼에서 가상 함수와 람다 비교 시, 한 번 실행에 1.35ns 더 걸린다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;일반적인 비즈니스 시스템 개발에서는 이 정도의 성능 손실은 무시할 수 있으며, &lt;code&gt;lambda&lt;/code&gt;를 도입하면 설계 측면에서 더 많은 편의성을 제공합니다. 특히 다중 신호 처리를 설계할 때 두드러지며, 하단에 이벤트 트리거가 있을 때 로그를 저장해야 한다면 로그 객체를 처리하는 함수가 필요합니다. 더 많은 비즈니스 처리 인터페이스가 필요할 때는 하단에서 &lt;code&gt;vector&lt;/code&gt;로 &lt;code&gt;lambda&lt;/code&gt; 객체를 저장하고, 이벤트 트리거 시 순차적으로 탐색하며 호출합니다. 이는 &lt;code&gt;QT&lt;/code&gt;의 신호와 슬롯과 유사하며, 로그, 모니터링, 비즈니스 1, 비즈니스 2는 서로 완전히 분리되어 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;코드&#34;&gt;코드
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Counter: 1000000
Time: 3966us
Counter: 1000000
Time: 5316us
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;memory&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;atomic&amp;gt;
#include &amp;lt;string&amp;gt;

std::atomic_int64_t counter = 0;

// 定义回调接口
class UserInterface
{
public:
    virtual void name() = 0;
    virtual void full_name() = 0;
};

class User : public UserInterface
{
public:
    void name() {}
    void full_name() { counter++; }
};

void to_string(UserInterface* user)
{
    user-&amp;gt;name();
    user-&amp;gt;full_name();
}

using name_handler = std::function&amp;lt;void()&amp;gt;;
using full_name_handler = std::function&amp;lt;void()&amp;gt;;

class Test
{
    name_handler name_;
    full_name_handler full_name_;

public:
    void set_name_handler(name_handler name)
    {
        name_ = name;
    }

    void set_full_name_handler(full_name_handler full_name)
    {
        full_name_ = full_name;
    }

    void to_string()
    {
        name_();
        full_name_();
    }
};

int main()
{
    User user;

    auto start = std::chrono::high_resolution_clock::now();

    for (int i = 0; i &amp;lt; 1000000; i++)
    {
        to_string(&amp;amp;user);
    }

    auto end = std::chrono::high_resolution_clock::now();
    std::cout &amp;lt;&amp;lt; &amp;quot;Counter: &amp;quot; &amp;lt;&amp;lt; counter &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;Time: &amp;quot; &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(end - start).count() &amp;lt;&amp;lt; &amp;quot;us&amp;quot; &amp;lt;&amp;lt; std::endl;

    counter = 0;
    auto name = []() {};
    auto full_name = []() { counter++; };

    Test test;
    test.set_name_handler(name);
    test.set_full_name_handler(full_name);

    start = std::chrono::high_resolution_clock::now();

    for (int i = 0; i &amp;lt; 1000000; i++)
    {
        test.to_string();
    }

    end = std::chrono::high_resolution_clock::now();
    std::cout &amp;lt;&amp;lt; &amp;quot;Counter: &amp;quot; &amp;lt;&amp;lt; counter &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;Time: &amp;quot; &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(end - start).count() &amp;lt;&amp;lt; &amp;quot;us&amp;quot; &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;p&gt;자료를 찾다가 비슷한 코드 조각 &lt;a class=&#34;link&#34; href=&#34;https://gist.githubusercontent.com/benloong/8050171/raw/fa577ec923b460862078b8b40233a42a1c619eeb/functionperformance.cpp&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;functionperformance.cpp&lt;/a&gt;를 발견했습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;memory&amp;gt;
#include &amp;lt;functional&amp;gt;

using namespace std;
using namespace std::chrono;

class Base
{
public:
	Base(){}
	virtual ~Base(){}
	virtual int func(int i) = 0;
};

class Derived : public Base
{
public:
	Derived(int base = 10) : base{base}
	{

	}
	~Derived(){}

	virtual int func(int i)
	{
		return i*base;
	}
private:
	int base;
};

struct Func
{
	int base;
	int operator()(int i)
	{
		return i*base;
	}
	Func(int base) : base {base}
	{

	}
};
const int base = 10;
int calculate(int i)
{
	return base*i;
}

int main()
{
	const int num = 10000;
	Base *p = new Derived{10};
	int total = 0;
	auto start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += p-&amp;gt;func(i);
	}
	auto end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nvirtual call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;

	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += calculate(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\ndirect function call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;

	Func functor{10};
	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += functor(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nfunctor call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;
	int base = 10;
	function&amp;lt;int(int)&amp;gt; lambda = [base](int i)
	{
		return i*base;
	};
	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += lambda(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nlambda call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;
	return 0;
}

/*
test on mac mini i7 2.7GHz
clang++ -std=c++11 chronotest.cpp -O0
output:
result: 499950000
virtual call elapsed: 	43171 nanoseconds.

result: 499950000
direct function call elapsed: 	31379 nanoseconds.

result: 499950000
functor call elapsed: 	41497 nanoseconds.

result: 499950000
lambda call elapsed: 	207416 nanoseconds.
===================================================
clang++ -std=c++11 chronotest.cpp -O1
output:
result: 499950000
virtual call elapsed: 	26144 nanoseconds.

result: 499950000
direct function call elapsed: 	22384 nanoseconds.

result: 499950000
functor call elapsed: 	33477 nanoseconds.

result: 499950000
lambda call elapsed: 	55799 nanoseconds.
===================================================
clang++ -std=c++11 chronotest.cpp -O2
result: 499950000
virtual call elapsed: 	22284 nanoseconds.

result: 499950000
direct function call elapsed: 	36 nanoseconds.

result: 499950000
functor call elapsed: 	30 nanoseconds.

result: 499950000
lambda call elapsed: 	28292 nanoseconds.

===================================================
clang++ -std=c++11 chronotest.cpp -O3
result: 499950000
virtual call elapsed: 	18975 nanoseconds.

result: 499950000
direct function call elapsed: 	29 nanoseconds.

result: 499950000
functor call elapsed: 	30 nanoseconds.

result: 499950000
lambda call elapsed: 	22542 nanoseconds.
===================================================
clang++ -std=c++11 chronotest.cpp -O4

result: 499950000
virtual call elapsed: 	22141 nanoseconds.

result: 499950000
direct function call elapsed: 	30 nanoseconds.

result: 499950000
functor call elapsed: 	30 nanoseconds.

result: 499950000
lambda call elapsed: 	22584 nanoseconds.
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기에는 일반 함수와 람다 함수라는 두 가지 새로운 모드가 추가되었으며, 인터페이스 콜백 방식과 직접 호출 방식을 비교하여 성능 손실이 수치적인 차이를 보입니다. 람다 함수의 성능은 함수에 근접하며 때로는 더 우수합니다. 컴파일 원리에 대한 지식 부족으로 추측해 보면, 접근하는 변수의 주소와 함수가 서로 인접하여 CPU 처리 측면에서 유리한 것으로 생각됩니다.&lt;/p&gt;
&lt;p&gt;첨부된 &lt;code&gt;wandbox&lt;/code&gt; 실행 결과입니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;result: 499950000
virtual call elapsed: 6143 nanoseconds.

result: 499950000
direct function call elapsed: 30 nanoseconds.

result: 499950000
functor call elapsed: 31 nanoseconds.

result: 499950000
lambda call elapsed: 15134 nanoseconds.
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>호스트 순서, 네트워크 순서를 디버거를 통해 직접 관찰</title>
        <link>https://ttf248.life/ko/p/host-order-network-order-debugger-observation/</link>
        <pubDate>Tue, 10 Jan 2023 14:18:12 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/host-order-network-order-debugger-observation/</guid>
        <description>&lt;p&gt;컴퓨터 발전 역사에서 데이터를 저장하는 방법에 대한 통일된 표준은 없었습니다&lt;/p&gt;
&lt;p&gt;바이트의 배열 방식에는 두 가지 일반적인 규칙이 있습니다. 예를 들어, 다중 자릿수의 하위 바이트를 작은 주소에 두고 상위 바이트를 큰 주소에 두는 것을 리틀 엔디언이라고 하며, 반대로 빅 엔디언이라고 합니다. 네트워크 애플리케이션에서는 바이트 순서가 반드시 고려해야 할 요소인데, 서로 다른 기계 유형이 서로 다른 표준의 바이트 순서를 채택할 수 있기 때문입니다. 따라서 모두 네트워크 표준으로 변환합니다.&lt;/p&gt;
&lt;p&gt;읽기 습관에 따라 빅 엔디안 바이트 순서가 왼쪽에서 오른쪽으로 읽는 순서와 더 일치합니다&lt;/p&gt;
&lt;h2 id=&#34;프로세서-아키텍처&#34;&gt;프로세서 아키텍처
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;x86, MOS Technology 6502, Z80, VAX, PDP-11 등 프로세서는 리틀 엔디언입니다&lt;/li&gt;
&lt;li&gt;모토로라 6800, 모토로라 68000, PowerPC 970 등 프로세서는 빅 엔디안 방식입니다&lt;/li&gt;
&lt;li&gt;ARM, PowerPC(PowerPC 970 제외), DEC Alpha, SPARC V9, MIPS, PA-RISC 및 IA64의 바이트 순서는 구성 가능합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;네트워크-서론&#34;&gt;네트워크 서론
&lt;/h2&gt;&lt;p&gt;네트워크 전송은 일반적으로 빅 엔디안을 사용하며, 네트워크 바이트 오더 또는 네트워크 순서라고도 합니다. IP 프로토콜에서 빅 엔디안을 네트워크 바이트 오더로 정의합니다.
버클리 소켓은 16비트 및 32비트 정수를 네트워크 바이트 순서와 로컬 호스트 바이트 순서 간에 변환하는 데 사용되는 일련의 변환 함수를 정의합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;arpa/inet.h&amp;gt;

uint32_t htonl(uint32_t hostlong); //把uint32_t类型从主机序转换到网络序
uint16_t htons(uint16_t hostshort); //把uint16_t类型从主机序转换到网络序
uint32_t ntohl(uint32_t netlong); //把uint32_t类型从网络序转换到主机序
uint16_t ntohs(uint16_t netshort); //把uint16_t类型从网络序转换到主机序
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;asio를 네트워크 라이브러리로 선택하는 경우, 내장된 네임스페이스에 플랫폼 독립적인 함수 이름이 있습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;boost::asio::detail::socket_ops::network_to_host_long&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::network_to_host_short&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::host_to_network_long&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::host_to_network_short&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;비주얼-스튜디오-디버거&#34;&gt;비주얼 스튜디오 디버거
&lt;/h2&gt;&lt;p&gt;디버그 모드에서 디버그 메뉴, 창을 선택하고 메모리 윈도우를 체크합니다&lt;/p&gt;
&lt;p&gt;Visual Studio에서 디버거에서 메모리 내의 데이터를 직접 확인할 수 있습니다. 그림은 아래와 같습니다.&lt;/p&gt;
&lt;p&gt;디버거 메뉴&lt;/p&gt;
&lt;h3 id=&#34;메모리-확인-방법&#34;&gt;메모리 확인 방법
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;창을 통해 변수 이름을 직접 출력하고 해당 변수의 주소로 이동합니다&lt;/li&gt;
&lt;li&gt;변수가 원래 포인터라면, 변수를 더블 클릭하여 선택한 후 메모리 윈도우로 드래그하면 해당 주소의 내용을 보여줍니다&lt;/li&gt;
&lt;li&gt;변수가 포인터가 아니면 계산 창에 추가하고, 주소를 가져온 다음 메모리 창에 수동으로 복사하세요&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;예시로-말하자면&#34;&gt;예시로 말하자면
&lt;/h3&gt;&lt;p&gt;데이터를 수신하여 &lt;code&gt;buffer&lt;/code&gt; 객체에 저장하고, 네트워크 바이트 순서를 호스트 바이트 순서로 변환했습니다. 그 결과 &lt;code&gt;body_length&lt;/code&gt;는 30이 되었고, 서버에서는 이 데이터를 전송하기 위해 네 개의 바이트를 할당했습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool NetworkMessage::decode_header()
{
    // 网络序转成主机序
    body_length_ = boost::asio::detail::socket_ops::network_to_host_long(*(int *)buffer_.data());
    return auto_reserve(body_length_);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;메모리 윈도우에서 &lt;code&gt;buffer_&lt;/code&gt;의 내용을 관찰합니다(빅 엔디안 바이트 순서)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/host-order-network-order-debugger-observation/buffer_.png&#34;
	width=&#34;603&#34;
	height=&#34;318&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;buffer_&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;189&#34;
		data-flex-basis=&#34;455px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;메모리 윈도우에서 &lt;code&gt;body_length_&lt;/code&gt;의 내용을 관찰하세요&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/host-order-network-order-debugger-observation/body_length_.png&#34;
	width=&#34;581&#34;
	height=&#34;333&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;body_length_&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;174&#34;
		data-flex-basis=&#34;418px&#34;
	
&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>C11: sleep for vs yield</title>
        <link>https://ttf248.life/ko/p/c11-sleep-for-vs-yield/</link>
        <pubDate>Tue, 20 Sep 2022 20:54:51 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/c11-sleep-for-vs-yield/</guid>
        <description>&lt;p&gt;코드를 살펴보던 중, &lt;code&gt;std::this_thread::yield()&lt;/code&gt;가 갑자기 눈에 들어왔다. C11의 문법적 설탕을 많이 사용했는데, &lt;code&gt;yield&lt;/code&gt;는 처음 보는 것 같고, 예전에는 신경 쓰지 않았다.&lt;/p&gt;
&lt;p&gt;매뉴얼을 확인하지 않고 가장 먼저 떠오르는 것은 비동기와 관련이 있는지인데, &lt;code&gt;yield&lt;/code&gt; boost 라이브러리의 코루틴 구현에 이 단어가 사용되었으므로 여기서는 코루틴과는 상관없고 제어 로직은 일반 스레드와 관련이 있는 것 같습니다&lt;/p&gt;
&lt;h2 id=&#34;문서&#34;&gt;문서
&lt;/h2&gt;&lt;h3 id=&#34;yield&#34;&gt;yield
&lt;/h3&gt;&lt;p&gt;이 함수의 정확성은 구현에 의존하며, 특히 사용 중인 OS 스케줄러 메커니즘과 시스템 상태에 따라 달라집니다. 예를 들어, 먼저 온(First-Come, First-Served) 실시간 스케줄러(Linux의 SCHED_FIFO)는 현재 스레드를 일시 중단하고 준비 실행 대기열의 동일 우선순위 스레드 뒤로 배치합니다(다른 스레드가 동일한 우선순위에 없다면 yield 효과는 없습니다).&lt;/p&gt;
&lt;h3 id=&#34;sleep_for&#34;&gt;sleep_for
&lt;/h3&gt;&lt;p&gt;지정된 sleep_duration 동안 현재 스레드의 실행을 차단합니다
이 함수는 스케줄링 지연이나 리소스 충돌로 인해 sleep_duration보다 오래 블록될 수 있습니다
표준 라이브러리는 안정적인 클럭으로 지속 시간을 측정하는 것을 권장합니다. 구현이 시스템 시간으로 대체되면 대기 시간 또한 클럭 조정에 민감할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;분석&#34;&gt;분석
&lt;/h3&gt;&lt;p&gt;두 함수 모두 현재 스레드가 더 이상 스레드를 점유하지 않도록 하는 것인데, 실행 결과는 플랫폼에 따라 다를 수 있나요? 여기서도 여전히 엉망진창인 느낌인데, 코드를 실행해서 결과를 확인해 보겠습니다&lt;/p&gt;
&lt;p&gt;ThinkPad 노트북(Visual Studio 커뮤니티 버전 2022), 텐센트 클라우드 S2 표준 서버(gcc8.5)&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;실행 플랫폼&lt;/th&gt;
&lt;th&gt;함수&lt;/th&gt;
&lt;th&gt;첫 번째/μs&lt;/th&gt;
&lt;th&gt;두 번째/μs&lt;/th&gt;
&lt;th&gt;세 번째/μs&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;sleep_for&lt;/td&gt;
&lt;td&gt;9872&lt;/td&gt;
&lt;td&gt;1884&lt;/td&gt;
&lt;td&gt;11302&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;yield&lt;/td&gt;
&lt;td&gt;119&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;sleep_for&lt;/td&gt;
&lt;td&gt;171&lt;/td&gt;
&lt;td&gt;168&lt;/td&gt;
&lt;td&gt;167&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;yield&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;td&gt;102&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;운영 결과에서 알 수 있듯이, 운영 체제 구현 방식에 따라 고정밀 슬립 시 &lt;code&gt;sleep_for&lt;/code&gt;의 안정성은 매우 다릅니다. 고정밀 슬립을 원한다면 &lt;code&gt;yield&lt;/code&gt;를 사용하는 것이 더 적합합니다.&lt;/p&gt;
&lt;p&gt;시간 정밀도가 &lt;code&gt;ms&lt;/code&gt; 단위까지 향상되니, 두 값 사이의 차이는 뚜렷하지 않다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;thread&amp;gt;
 
// 建议其他线程运行一小段时间的“忙睡眠”
void little_sleep(std::chrono::microseconds us)
{
    auto start = std::chrono::high_resolution_clock::now();
    auto end = start + us;
    do {
        std::this_thread::yield();
    } while (std::chrono::high_resolution_clock::now() &amp;lt; end);
}
 
int main()
{
    auto start = std::chrono::high_resolution_clock::now();
 
    little_sleep(std::chrono::microseconds(100));
    std::this_thread::sleep_for(std::chrono::microseconds(100));
 
    auto elapsed = std::chrono::high_resolution_clock::now() - start;
    std::cout &amp;lt;&amp;lt; &amp;quot;waited for &amp;quot;
              &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(elapsed).count()
              &amp;lt;&amp;lt; &amp;quot; microseconds\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;참조&#34;&gt;참조
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/header/thread.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/header/thread.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/thread/sleep_for.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/thread/sleep_for.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>리눅스 서버, MySQL 비밀번호 재설정</title>
        <link>https://ttf248.life/ko/p/linux-server-reset-mysql-password/</link>
        <pubDate>Tue, 20 Sep 2022 14:27:35 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/linux-server-reset-mysql-password/</guid>
        <description>&lt;p&gt;유휴 상태인 텐센트 클라우드 서버가 있는데, 연말에 만료되므로 갱신할 생각도 없었고, 개발용 데이터베이스로 MySQL을 설치했다. 시스템을 재설치할 때 귀찮아서 텐센트 클라우드가 제공하는 써드파티 이미지를 바로 선택했는데, MySQL 데이터베이스가 이미 설치되어 있었다. 시스템 내부에 비밀번호나 배포 경로를 설명하는 Readme 파일 같은 것이 있을 줄 알았는데.&lt;/p&gt;
&lt;p&gt;腾讯云 재설치 시스템은 정말 빠르네요, 1분 정도 지나니 재설치가 완료되었다는 알림이 왔고, 로그인하니 &lt;code&gt;systemctl status mysql&lt;/code&gt; 서비스가 이미 시작되어 있었어요. 비밀번호가 어디 있는지 찾아봤는데, 아무리 찾아도 없어서 점점 짜증나기 시작했어요.&lt;/p&gt;
&lt;p&gt;이때 생각하니 이미 서버에 접근해서 &lt;code&gt;root&lt;/code&gt; 권한을 가지고 있으니, 방법이 있을 거야. 자료를 뒤져보니 알리바바 클라우드 포럼에 관련 글이 있네, 계속 시도해 봐야겠다.&lt;/p&gt;
&lt;h2 id=&#34;비밀번호-재설정&#34;&gt;비밀번호 재설정
&lt;/h2&gt;&lt;p&gt;편집기로 &lt;code&gt;/etc/my.cnf&lt;/code&gt; 파일을 열고 &lt;code&gt;mysqld&lt;/code&gt; 노드에 다음 설정을 추가합니다: &lt;code&gt;skip-grant-tables&lt;/code&gt;. 그런 다음 명령을 실행하여 데이터를 재시작합니다: &lt;code&gt;systemctl restart mysql&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;다시 &lt;code&gt;mysql&lt;/code&gt;로 직접 로그인하여 데이터를 확인하고, 이후에는 정상적인 작업을 진행하겠습니다. &lt;code&gt;root&lt;/code&gt; 사용자 비밀번호를 재설정하고, 원격 로그인을 허용하도록 설정하겠습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;USE mysql;
UPDATE user SET authentication_string = password (&#39;pass&#39;) WHERE User = &#39;root&#39;;
grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;pass&#39; with grant option;
flush privileges;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;되돌린 수정 사항 적용을 위해 데이터베이스를 재시작하세요. 해결되었습니다.&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://help.aliyun.com/document_detail/42520.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://help.aliyun.com/document_detail/42520.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>자동화 테스트에 대한 간략한 소개</title>
        <link>https://ttf248.life/ko/p/shallow-discussion-on-automation-testing/</link>
        <pubDate>Thu, 04 Aug 2022 11:39:18 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/shallow-discussion-on-automation-testing/</guid>
        <description>&lt;p&gt;금융 거래 시스템에 대한 테스트 투자액은 다른 시스템보다 훨씬 높지만, 복잡한 테스트 단계가 반복되고 &lt;code&gt;ROI&lt;/code&gt;는 너무 낮습니다. 프로젝트와 인력의 교체로 인해 피할 수 없이 더 많은 통제 불가능한 요소들이 유입되고 있으며, 흔히 A 인터페이스 출력의 특정 필드를 수정하면 B 인터페이스 결과에 영향을 미치는 경우가 발생합니다. 매번 버전이 출시될 때마다 위험도 누적됩니다.&lt;/p&gt;
&lt;h2 id=&#34;이론적-지식&#34;&gt;이론적 지식
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;자동화의 가치를 어떻게 측정할 수 있나요?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;자동화 테스트 사례 ROI = (수동 실행 시간) * (실행 횟수) / (개발 비용 + 유지 보수 비용)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어떤 기능에 자동화 테스트가 필요합니까?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;사용자가 자주 사용하는 기능, 자주 변경되지 않는 기능에 대해 자동화 테스트 코드를 작성하면 가장 큰 효과를 볼 수 있습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자동화 테스트를 추진하기 위한 이 시점을 선택한 이유는 무엇입니까?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;프로젝트 출시가 임박한 시점에는 적절하지 않습니다. 멀리 있는 물로 당장의 갈증을 해결할 수 없으며, 자동화는 장기적인 수익 모델입니다. 프로젝트는 이미 &lt;strong&gt;실제 운영 환경&lt;/strong&gt;에 배포되었고 안정적인 릴리스 주기를 맞이하고 있으므로 지금이 가장 적합합니다.&lt;/p&gt;
&lt;h2 id=&#34;프레임-선택&#34;&gt;프레임 선택
&lt;/h2&gt;&lt;p&gt;관련된 실무 경험이 부족한 상태에서 자동화 테스트라는 과제를 받았다면, 일반적인 시작은 다음과 같다: 검색 엔진을 열어 현재 시스템의 &lt;strong&gt;기술 스택&lt;/strong&gt;에 사용할 수 있는 도구와 프레임워크를 찾고 사용 설명서를 훑어본다. 바로 적절한 도구를 찾으면 축하한다, &lt;strong&gt;완벽한 시작&lt;/strong&gt;이다.&lt;/p&gt;
&lt;p&gt;먼저 잘못했다고 말씀드립니다. 관련 자료를 확인해 보니 없다는 게 아니라 프레임워크 자체가 너무 복잡하고, 배포 시 점유하는 리소스도 많습니다. 초보자 입문에는 작고 간결한 것이 필요합니다. 테스트 그룹 동료들과 상의 결과 기존 유닛 테스트 프레임워크를 활용하여 자동화 테스트 프레임워크로 캡슐화하는 &lt;code&gt;Python&lt;/code&gt; 자체 구축 프레임워크가 언급되었습니다.&lt;/p&gt;
&lt;p&gt;이 프로젝트의 디자인 아이디어를 참고하세요: &lt;a class=&#34;link&#34; href=&#34;https://github.com/wintests/pytestDemo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/wintests/pytestDemo&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;프레임워크가-왜-필요할까요&#34;&gt;프레임워크가 왜 필요할까요?
&lt;/h2&gt;&lt;p&gt;서비스는 여러 개의 다양한 배포 환경을 가지고 있습니다. 개발 환경, 테스트 환경, 온라인 테스트 환경이 있으며, 프레임워크의 역할은 계층을 분리하고 테스트 사례와 데이터를 분리하는 것입니다. 각 환경에 따라 다른 사례 데이터를 구성하며, 물론 공통 데이터도 지원합니다.&lt;/p&gt;
&lt;p&gt;핵심적인 논리는 자동화 활용률을 높이기 위한 것이다. 시나리오가 더 복잡해지고, 서로 다른 환경 간의 데이터는 일관성이 없고 아무런 관련이 없다면, 설정 사례 데이터를 추가할 때 &lt;code&gt;label&lt;/code&gt; 태그를 늘려 현재 데이터가 지원하는 환경을 지정하면 된다.&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;p&gt;가성비 최고의 자동화 테스트를 구축하세요&lt;/p&gt;</description>
        </item>
        <item>
        <title>새로운 언어를 배워야 하는 이유는 무엇인가?</title>
        <link>https://ttf248.life/ko/p/why-learn-a-new-language/</link>
        <pubDate>Thu, 04 Aug 2022 11:27:30 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/why-learn-a-new-language/</guid>
        <description>&lt;p&gt;학교 다닐 때부터 세면 10년이 넘게 C++를 접했는데, 왜 다른 프로그래밍 언어를 배워야 할까요?&lt;/p&gt;
&lt;p&gt;세련된 모듈 설계 경험은 부족하지만, &lt;code&gt;C++&lt;/code&gt; 문법은 자유로운 편이고 다른 언어를 학습하면서 더 세련된 설계를 유도할 수 있다&lt;/p&gt;
&lt;p&gt;도구를 작성할 때 자주 사용하게 된다&lt;/p&gt;
&lt;p&gt;하위 레이어 라이브러리 설계든, 비즈니스 모듈 구현이든, 설계의 원칙은 일관성이 있습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>비주얼 스튜디오 컴파일 문자 집합 [전환]</title>
        <link>https://ttf248.life/ko/p/visual-studio-compilation-character-set-translation/</link>
        <pubDate>Thu, 04 Aug 2022 10:51:43 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/visual-studio-compilation-character-set-translation/</guid>
        <description>&lt;p&gt;C++ 크로스 플랫폼 개발 시 중국어 운영체제에서는 종종 &lt;code&gt;error C2001&lt;/code&gt; 상수에 줄 바꿈 문자가 있다는 오류를 마주할 수 있습니다&lt;/p&gt;
&lt;h2 id=&#34;visual-studio&#34;&gt;visual studio
&lt;/h2&gt;&lt;p&gt;CMake는 프로젝트 빌드 스크립트를 구성하며, Windows 시스템에서 개발할 때 임시로 솔루션을 생성합니다. 플랫폼 간 호환성을 위해 파일 인코딩은 UTF-8을 선택했습니다.&lt;/p&gt;
&lt;p&gt;인용된 자료는 원리에서 출발하여 문제의 발생 원인을 상세히 설명하고 있습니다&lt;/p&gt;
&lt;p&gt;코딩 관련해서는 &lt;code&gt;MSVC&lt;/code&gt;에서 &lt;code&gt;/source-charset&lt;/code&gt;과 &lt;code&gt;/execution-charset&lt;/code&gt;이라는 전용 컴파일 옵션이 있는데, 전자는 파일 자체의 인코딩을 나타내고 후자는 컴파일 이후 문자 배열 내 바이트가 어떤 인코딩인지 나타냅니다. 인코딩 문제는 이 두 옵션으로 거의 해결할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예를 들어, &lt;code&gt;windows&lt;/code&gt;의 &lt;code&gt;cmd&lt;/code&gt; 콘솔은 기본적으로 &lt;code&gt;GBK&lt;/code&gt; 인코딩만 표시할 수 있지만, 코드 파일 자체는 &lt;code&gt;UTF-8&lt;/code&gt;로 되어 있어서 플랫폼 간 호환성 때문에 직접 &lt;code&gt;GBK&lt;/code&gt;로 변경하기가 편리하지 않습니다. 물론 여기에는 다양한 플랫폼을 위한 인코딩 변환 코드를 작성하는 방법은 포함되지 않습니다. &lt;code&gt;Win10&lt;/code&gt;에서는 컴파일러에 &lt;code&gt;/source-charset:utf-8 /execution-charset:gbk&lt;/code&gt; 옵션을 설정하여 UTF-8로 인코딩된 파일을 읽어들여서 GBK로 변환 후 배열에 저장하고, 이렇게 하면 &lt;code&gt;printf&lt;/code&gt;를 통해 콘솔에서 한자를 정상적으로 표시할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;cmake는-visual-studio-설정용입니다&#34;&gt;CMake는 Visual Studio 설정용입니다
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;if( WIN32 )
    message( STATUS &amp;quot;Configuring trade on WIN32&amp;quot;)
    set( CMAKE_CXX_FLAGS &amp;quot;${CMAKE_CXX_FLAGS} /source-charset:utf-8 /execution-charset:gbk&amp;quot;)
endif()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/146543940&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/146543940&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Windows 플랫폼에서 폴더 크기 빠르게 통계</title>
        <link>https://ttf248.life/ko/p/windows-platform-quick-folder-size-statistics/</link>
        <pubDate>Mon, 01 Aug 2022 19:54:18 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/windows-platform-quick-folder-size-statistics/</guid>
        <description>&lt;p&gt;리눅스 플랫폼은 간단해서 &lt;code&gt;du -sh *&lt;/code&gt; 한 줄의 코드로 끝내 버릴 수 있다. 윈도우는 어떨까? 디스크가 많고, 파일을 정리하고 싶을 때, 파일이 많은 상황에서 시스템 내장 리소스 관리자는 폴더 크기를 통계적으로 계산하는 속도가 너무 느려서 포기하고 싶게 만든다.&lt;/p&gt;
&lt;h2 id=&#34;everything&#34;&gt;Everything
&lt;/h2&gt;&lt;p&gt;윈도우 플랫폼에서 개발하는 분이라면, 직접 사용해 보지 않더라도 친구에게 들어봤을 &lt;code&gt;Everything&lt;/code&gt;이라는 프로그램이 있을 겁니다. 검색 속도는 시스템 자체의 파일 탐색기보다 훨씬 빠릅니다. 시스템 수준에서 빠른 파일 인덱싱을 지원하는 만큼, 파일을 인덱스하고 동시에 파일 크기를 통계적으로 관리하는 유사한 도구를 찾을 수 있을 것입니다.&lt;/p&gt;
&lt;h2 id=&#34;wiztree&#34;&gt;WizTree
&lt;/h2&gt;&lt;p&gt;공식 웹사이트: &lt;a class=&#34;link&#34; href=&#34;https://www.diskanalyzer.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.diskanalyzer.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;일반 설치 모드나 그린 버전 압축 해제 후 실행&lt;/p&gt;
&lt;p&gt;속도가 빠르고, 데이터 표시 유형이 풍부하며, 왼쪽에 트리 형태의 모드와 오른쪽에 파일 유형이 있고, 물론 하단 막대에도 시각화된 표현 방식도 있습니다&lt;/p&gt;
&lt;h2 id=&#34;spacesniffer업데이트-2023년-이후-더-이상-업데이트되지-않습니다&#34;&gt;SpaceSniffer(업데이트 2023년 이후 더 이상 업데이트되지 않습니다.)
&lt;/h2&gt;&lt;p&gt;소프트웨어 공식 웹사이트: &lt;a class=&#34;link&#34; href=&#34;http://www.uderzo.it/main_products/space_sniffer/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.uderzo.it/main_products/space_sniffer/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;조작은 매우 간단합니다. 해당하는 디스크 문자를 선택하면 소프트웨어가 그래픽 방식으로 폴더 크기를 표시하는데, 크기가 클수록 이미지 내 해당 매트릭스도 커집니다. 나머지 조작은 직접 클릭해보면 알 수 있을 것이고, 조건 필터를 입력하여 파일을 지원합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;파일 크기 필터링&lt;/li&gt;
&lt;li&gt;파일 날짜 필터&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;기본 사용법&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;고급 사용법&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://moe.best/software/spacesniffer.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://moe.best/software/spacesniffer.html&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>웹 페이지 스타일 시트(CSS) 복사 방법: 요소 검사</title>
        <link>https://ttf248.life/ko/p/how-to-copy-webpage-css-element-inspection/</link>
        <pubDate>Sun, 31 Jul 2022 23:36:48 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/how-to-copy-webpage-css-element-inspection/</guid>
        <description>&lt;p&gt;정적인 블로그 테마는 주로 해외 템플릿을 기반으로 수정 및 조정하며, 중국어 콘텐츠의 레이아웃에 대한 고려가 충분하지 않다&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;반 달 전, 블로그 스타일 시트를 조금 조정했는데, 오랫동안 백엔드 서비스 개발만 해와서 프론트엔드는 완전 초보입니다. 앞뒤로 반나절을 끙끙거렸는데 디자인이 별로 마음에 들지 않았습니다. 문득 떠올라 자주 보는 기술 블로그인 infoq, 오픈소스 중국의 스타일이 정말 좋다고 생각했습니다. 이걸 조금 가져다 쓸 수 있을까요? 잠시 소스 파일을 살펴봤지만 관련된 요소를 찾으려니 머리가 엉망이 되었습니다.&lt;/p&gt;
&lt;p&gt;프론트엔드 개발자 친구들은 여기서 웃을지도 모르겠네. 특정 요소를 찾는 것조차 모르는구만. 모르는 건 괜찮아, 주말에 시간도 많으니 잠시 멈춰서 생각해보니, 예전에 &lt;code&gt;python&lt;/code&gt; 크롤러를 만들 때 비슷한 걸 사용했던 것 같아.&lt;/p&gt;
&lt;h3 id=&#34;요소-검토&#34;&gt;요소 검토
&lt;/h3&gt;&lt;p&gt;맞아요, 바로 브라우저 자체의 요소 검사 도구인데, 스타일 시트 복사나 특정 요소 찾기 같은 것들은 금방 할 수 있습니다. &lt;code&gt;selector&lt;/code&gt;로 요소를 찾고, &lt;code&gt;hugo&lt;/code&gt;에서 &lt;code&gt;user define css&lt;/code&gt;를 새로 만들 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;요소 복사&lt;/li&gt;
&lt;li&gt;복사 outerHTML&lt;/li&gt;
&lt;li&gt;선택자 복사&lt;/li&gt;
&lt;li&gt;JS 경로 복사&lt;/li&gt;
&lt;li&gt;스타일 복사&lt;/li&gt;
&lt;li&gt;XPath 복사&lt;/li&gt;
&lt;li&gt;전체 XPath 복사&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Windows 플랫폼 편집을 위한 초대형 파일: EmEditor (텍스트 에디터)</title>
        <link>https://ttf248.life/ko/p/windows-platform-editing-large-files-emeditor-text-editor/</link>
        <pubDate>Sun, 31 Jul 2022 23:21:24 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/windows-platform-editing-large-files-emeditor-text-editor/</guid>
        <description>&lt;p&gt;상하이 국안 데이터베이스 사건은 해커 커뮤니티에서 떠들썩하게 돌아다니고 있지만, 진실 여부는 알 수 없습니다. 2년 후에 다시 한번 살펴보겠습니다. 과거 경험에 따르면, 지역 소셜 엔지니어링 데이터베이스 자료가 업데이트되었는데, 17.9G라는 거대한 SQL 파일이 있었습니다. 일반적인 텍스트 편집기로는 미리 보기조차 어렵고 열기는 더더욱 불가능했습니다. 누리꾼과 대화하던 중 EmEditor라는 프로그램을 언급했습니다.&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;공식 웹사이트: &lt;a class=&#34;link&#34; href=&#34;https://www.emeditor.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.emeditor.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;주말에 시간 날 때 한번 해봤는데, 꽤 편리하네요. 디자인 자체가 큰 파일을 편집할 수 있게 되어 있고, 메모리가 충분하면 전체 파일이 메모리에 로드되어서 검색이나 편집 속도도 빠르고, 파일 분할 기능도 지원합니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>생각보다 간단해 보이는 일에 코드 복사 버튼을 추가하는 것</title>
        <link>https://ttf248.life/ko/p/add-code-copy-button/</link>
        <pubDate>Fri, 25 Feb 2022 01:23:39 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/add-code-copy-button/</guid>
        <description>&lt;p&gt;네 시간이나 붙잡고 있었는데, 이 문장을 보니까 웃겼다. 이렇게 오래 걸릴 리가 있나 싶었지. 그런데 시간을 보니 세 시간이었어.&lt;/p&gt;
&lt;p&gt;뭐랄까, 2022년의 첫 글이라고 할 수 있는데, 크게 복잡한 건 아니고 제목 그대로인 것만 (그때는 아직 어렸을 때), &lt;a class=&#34;link&#34; href=&#34;https://ouuan.github.io/post/from-hexo-to-hugo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;작업&lt;/a&gt;을 그냥 베껴서 넣고, 즐겨찾기에 넣어두고 끄느니 차라리 미루고 미루다가 겨우 생각났다&lt;/p&gt;
&lt;p&gt;Hugo로 마이그레이션할 때부터 플러그인이 너무 부족하다고 생각했는데, 코드 복사 붙여넣기가 안 돼서 많은 노트들을 에버노트에서 블로그로 옮길 때 코드 복사 붙여넣기 작업이 번거워져서 제 블로그에 글을 쓰는 의욕을 많이 꺾였어요&lt;/p&gt;
&lt;h2 id=&#34;서론&#34;&gt;서론
&lt;/h2&gt;&lt;p&gt;원저작자의 초고를 꼼꼼히 살펴보고, 한 번 쭉 읽은 다음 작가 소개도 살펴보자. 와, 대단한 분을 만났네. 칭화대 재학 중인 학부생인데, 어릴 때부터 컴퓨터에 익숙했었나 보네. 아, 갑자기 뭘 해야 할지 기억이 안 나. 관련해서는 저자의 &lt;code&gt;Github&lt;/code&gt; 저장소도 한번 살펴보고, 이 수정된 &lt;code&gt;even&lt;/code&gt; 테마가 지금보다 훨씬 보기 좋고 기능도 많아. 이걸 해봐야겠다. 일단 관련된 코드를 가져와서 합쳐보자.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/add-code-copy-button/2022-02-25-02-08-19.png&#34;
	width=&#34;215&#34;
	height=&#34;150&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;143&#34;
		data-flex-basis=&#34;344px&#34;
	
&gt; &lt;img src=&#34;https://ttf248.life/p/add-code-copy-button/2022-02-25-02-08-40.png&#34;
	width=&#34;217&#34;
	height=&#34;167&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;129&#34;
		data-flex-basis=&#34;311px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;새로운-기능-기사-이력-확인-연관-제출-기록-보기&#34;&gt;새로운 기능: 기사 이력 확인, 연관 제출 기록 보기
&lt;/h3&gt;&lt;p&gt;효과는 괜찮은 편이고, 기사 맨 끝부분에서 체험해 볼 수 있습니다&lt;/p&gt;
&lt;p&gt;손질하기 전에 작가의 원 저장소 기록을 자세히 보지 않았고, 간단하게 병합하면 될 줄 알았는데, 결국 많은 코드를 병합했고, 중간에 충돌도 여러 번 있었고, 무식하게 덮어썼다. 내가 원하는 대로 하기 위해서 프론트엔드와 렌더링 템플릿 코드들이었다.&lt;/p&gt;
&lt;p&gt;저장소 주소: &lt;a class=&#34;link&#34; href=&#34;https://github.com/TianlongXiang/hugo-theme-even&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/TianlongXiang/hugo-theme-even&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;중국어의 함정인데, &lt;code&gt;git&lt;/code&gt;에서 이 파라미터를 조정하지 않으면 현재 문서의 &lt;code&gt;commit hash&lt;/code&gt;를 가져올 수 없어 역사 링크 생성이 실패합니다. 전체 역사를 생성할 때도 자동 통합 스크립트를 수정해야 하고, 현재 저장소의 모든 역사 기록을 가져오도록 해야 합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/TianlongXiang/TianlongXiang.github.io/commit/0d860154de9b335ed88a57d62eedd4b6e3ccbeee&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;기능: 전체 GitHub 저장소 가져오기를 시도하여 기사 마지막 수정 기록을 동적으로 업데이트합니다&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;경로에 중국어가 존재하므로, Hugo GitInfo 설정에서 이 기능을 활성화해야 합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;name: Build Github
run: git config --global core.quotePath false &amp;amp;&amp;amp; hugo -b &amp;quot;https://www.xiangtianlong.com/&amp;quot; -d &amp;quot;github_public&amp;quot; &amp;amp;&amp;amp; ls
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;스타일-조정&#34;&gt;스타일 조정
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;사이트 콘텐츠 너비를 조정해 보세요. 이전 디자인은 모바일과 PC 모두에 적합했지만, 실제로 아무도 휴대폰으로 보지 않고 저조차도 컴퓨터로 보는 것 같아요.&lt;/li&gt;
&lt;li&gt;목록 열 지원 자동 확장/축소&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ouuan&lt;/code&gt;의 코드 기록을 한 시간 반 넘게 봤는데, 복사 버튼을 어떻게 추가하는지 도통 이해가 안 간다&lt;/p&gt;
&lt;p&gt;시간이 흘러 한 달쯤 지나서, 또 이 일이 생각났다&lt;/p&gt;
&lt;p&gt;이 과제가 이해가 안 되면 다른 문제로 베끼고, 어쨌든 따라 하면 알 수 있을 거야. 검색 결과는 꽤 뜻밖이었는데, &lt;code&gt;hugo&lt;/code&gt; 공식 포럼에 복사 버튼을 추가하는 방법에 대한 글이 있길래 가봤더니 논리가 명확하더라고. 그런데 이상한 일이 벌어졌어. 돌아와서 보니 &lt;code&gt;even&lt;/code&gt;으로 렌더링된 코드 블록 스타일이 자료 설명과 달라서 이 부분은 좀 번거로워. 간단히 기록해 둘게.&lt;/p&gt;
&lt;p&gt;기본적인 프론트엔드 개발 지식이 부족해서 모르는 부분은 브라우저의 &lt;code&gt;요소 검사&lt;/code&gt;를 열어 코드와 오른쪽 스타일 정보에 맞춰 분석하며 천천히 로직을 이해하게 되었고, &lt;code&gt;JavaScript&lt;/code&gt;는 이해가 안 가서 콘솔에 로그를 남겼다. 많이 모를 때는 차분히 마음을 가다듬고 천천히 로직을 정리하고 분해하면 결국 해결책이 보인다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pre&lt;/code&gt; 노드가 여러 개 있는데, 여기서은 단일 코드 블록을 의미하며, 테마에서 자체적으로 라인 번호를 렌더링하여 복사 버튼이 두 개로 나타납니다
이런, 관심 주제 자체의 코드 하이라이트 렌더링을 구현하고 싶지만 이 주제 설정에 익숙하지 않네요
공식 홈페이지에서 자료를 봤는데, 반쯤 이해가 됐고, 코드 하이라이트를 제어할 수 있는 마크업 설정이 있다는 걸 알게 됨
설정 파일을 조정해도 계속 안 되고, 렌더링 결과가 예상과 다릅니다
이 설정들 &lt;code&gt;pygmentsOptions&lt;/code&gt;을 발견하고 또 자료를 뒤져서 설정을 조정했다. 우선 행 번호는 제거한다.
사용자 정의 &lt;code&gt;css&lt;/code&gt; 스타일 시트와 사용자 정의 &lt;code&gt;js&lt;/code&gt; 스크립트를 구성합니다
이렇게까지 많은 일을 해놓았으니, 문득 최근에 봤던 색상 조합이 괜찮다는 생각이 들어서 버튼 스타일을 조금 바꿔볼까 하는데: 중국풍 천청색으로 해보자&lt;/p&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:20%&#34; src=&#34;2022-02-25-02-01-22.png&#34; /&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:20%&#34; src=&#34;2022-02-25-02-01-33.png&#34; /&gt;
&lt;p&gt;네 시간이나 붙잡고 있었는데, 이 문장을 보니까 웃겼다. 이렇게 오래 걸릴 리가 있나 싶었거든. 그런데 시간을 보니: 세 시간.&lt;/p&gt;
&lt;h2 id=&#34;참조-링크&#34;&gt;참조 링크
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://ouuan.github.io/post/from-hexo-to-hugo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ouuan.github.io/post/from-hexo-to-hugo/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://gohugobrasil.netlify.app/content-management/syntax-highlighting/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://gohugobrasil.netlify.app/content-management/syntax-highlighting/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://gohugo.io/getting-started/configuration-markup#highlight&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://gohugo.io/getting-started/configuration-markup#highlight&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.dannyguo.com/blog/how-to-add-copy-to-clipboard-buttons-to-code-blocks-in-hugo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.dannyguo.com/blog/how-to-add-copy-to-clipboard-buttons-to-code-blocks-in-hugo/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>혼돈 엔지니어링</title>
        <link>https://ttf248.life/ko/p/chaos-engineering/</link>
        <pubDate>Wed, 28 Jul 2021 14:35:07 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/chaos-engineering/</guid>
        <description>&lt;p&gt;시스템 안정성 테스트를 위한 시스템 파괴 모드&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;국내 인터넷 업계는 항상 새로운 것을 만들어내려고 애쓰는데, 가끔 용어를 들으면 대체 뭘 말하는지 떠올리기 어려운 경우가 많다&lt;/p&gt;
&lt;p&gt;부분적으로 기사를 살펴봤는데, 혼돈 엔지니어링 초기 정의에 대한 이 부분이 가장 받아들이기 쉬웠다&lt;/p&gt;
&lt;p&gt;혼돈 엔지니어링의 초기 탐색은 사실 업계에서 꾸준히 있어 왔으며, 장애 테스트나 재해 훈련과 같은 형태로 존재했습니다. 하지만 마이크로서비스 아키텍처의 지속적인 발전과 분산 시스템의 규모가 계속 커짐에 따라 혼돈 엔지니어링이 두각을 나타내기 시작하며 점점 더 중요해지고 있습니다. 넷플릭스가 공식적으로 혼돈 엔지니어링 개념을 제안한 이후 관련 이론도 빠르게 풍부해졌습니다. 또한 넷플릭스의 실천은 혼돈 엔지니어링이 안정성 분야에 가져다주는 엄청난 의미를 증명했습니다.&lt;/p&gt;
&lt;h2 id=&#34;참조-링크&#34;&gt;참조 링크
&lt;/h2&gt;&lt;p&gt;바이트댄스 혼돈 공학 실천 요약&lt;/p&gt;</description>
        </item>
        <item>
        <title>쿠버네티스 pod 일시 중지</title>
        <link>https://ttf248.life/ko/p/kubernetes-pause-pod/</link>
        <pubDate>Mon, 12 Jul 2021 11:23:09 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/kubernetes-pause-pod/</guid>
        <description>&lt;p&gt;배포 컨트롤러는 Kubernetes 클러스터에서 매우 중요한 기능인 Pod의 수평 확장 및 축소 기능을 구현합니다. 이 기능은 기존 클라우드 시대 플랫폼이 반드시 갖춰야 할 역량입니다.&lt;/p&gt;
&lt;p&gt;비즈니스 시나리오에서 데이터베이스의 데이터를 수정하고, 조정 후 Pod 노드를 재시작해야 하는 상황이 발생했습니다. 하지만 Pod가 실행되는 동안 계속해서 테이블 필드를 수정하고 있어, 일시적으로 애플리케이션의 테이블 업데이트를 중단한 다음 데이터를 조정하고 Pod를 복구해야 합니다.&lt;/p&gt;
&lt;p&gt;배포를 강제로 삭제하는 것 외에, 비슷한 중단 효과를 낼 수 있는 다른 방법이 있을까요?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl scale --replicas=0 deployment/&amp;lt;your-deployment&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;답을 보기 전에는 많은 사람들이 상상도 못했을 텐데, 답을 보고 나니 미소를 지으며, 머리가 돌아가지 않는 느낌이 들고 아직 프로세스를 직접 조작하던 시대에 머물러 있어서, 비즈니스 프로세스를 직접 조작하려 하는 것 같은 생각이 든다&lt;/p&gt;
&lt;h2 id=&#34;참조-링크&#34;&gt;참조 링크
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/54821044/how-to-stop-pause-a-pod-in-kubernetes&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;how to stop/pause a pod in kubernetes&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>도커 두 세 가지 일</title>
        <link>https://ttf248.life/ko/p/docker-two-three-things/</link>
        <pubDate>Thu, 21 Jan 2021 09:26:07 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/docker-two-three-things/</guid>
        <description>&lt;p&gt;오랫동안 일하면서 접해왔던 것은 &lt;code&gt;CentOS&lt;/code&gt; 운영체제였고, &lt;code&gt;Mac&lt;/code&gt; 사용자나 &lt;code&gt;Ubuntu&lt;/code&gt; 사용자의 경우 일부 내용은 적용이 불가능할 수 있습니다&lt;/p&gt;
&lt;p&gt;설치 부분은 칭화대학교의 매뉴얼을 참고하시면 됩니다: &lt;a class=&#34;link&#34; href=&#34;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;설치&#34;&gt;설치
&lt;/h2&gt;&lt;p&gt;알 수 없는 신비한 힘으로 인해 국내 설치 시에는 클라우드 공급업체가 제공하는 저장소 주소를 사용하는 것이 좋으며, 여기서는 **알리바바 클라우드(阿里云)**를 추천합니다&lt;/p&gt;
&lt;h3 id=&#34;저장소-소스-주소를-설정하세요&#34;&gt;저장소 소스 주소를 설정하세요
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install yum-utils device-mapper-persistent-data lvm2 &amp;amp;&amp;amp; \
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;최신-버전을-배포하세요&#34;&gt;최신 버전을 배포하세요
&lt;/h3&gt;&lt;p&gt;도커는 일반적으로 사용되는 백그라운드 서비스이므로, 부팅 시 자동 시작으로 설정하는 것을 권장하며, 현재 명령어는 CentOS 7에 적용 가능합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum install -y docker-ce docker-ce-cli containerd.io &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;버전-배포-지정&#34;&gt;버전 배포 지정
&lt;/h3&gt;&lt;p&gt;쿠버네티스와 도커의 배포는 완전히 동기화되지 않았으므로, 다음으로 쿠버네티스를 배포해야 한다면 쿠버네티스 배포 지침을 참고하여 지정된 버전의 도커를 설치하십시오&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum list docker-ce --showduplicates | sort -r
sudo yum install -y docker-ce-18.09.2-3.el7 docker-ce-cli-18.09.2-3.el7 containerd.io-18.09.2-3.el7 &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;일반-사용자가-docker-권한을-추가합니다&#34;&gt;일반 사용자가 Docker 권한을 추가합니다
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo usermod -aG docker ${USER}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;제거&#34;&gt;제거
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum erase -y docker-ce docker-ce-cli containerd.io
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;일상-사용&#34;&gt;일상 사용
&lt;/h2&gt;&lt;h3 id=&#34;미러-가속&#34;&gt;미러 가속
&lt;/h3&gt;&lt;p&gt;여전히 예측할 수 없는 신비한 힘 때문에 이미지를 가져올 때 속도가 빠르지 않다. 이때 국내 클라우드 공급업체들이 나서서 다양한 가속 서비스를 제공하고 있으므로 &lt;strong&gt;알리바바 클라우드&lt;/strong&gt;를 추천한다.&lt;/p&gt;
&lt;p&gt;가속된 주소는 각자 스스로 등록하여 알리바운드 계정을 얻으세요. 이 서비스는 무료이며, 알리바운드는 또한 무료 이미지 빌드 서비스를 제공합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt; /etc/docker/daemon.json &amp;lt;&amp;lt;EOF
{
  &amp;quot;registry-mirrors&amp;quot;: [
    &amp;quot;https://docker.nju.edu.cn&amp;quot;,
    &amp;quot;https://mirror.baidubce.com&amp;quot;,
    &amp;quot;https://docker.m.daocloud.io&amp;quot;,
    &amp;quot;https://docker.mirrors.sjtug.sjtu.edu.cn&amp;quot;
  ]
}
EOF
systemctl daemon-reload &amp;amp;&amp;amp; \
systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;강력-추천하는-제어판&#34;&gt;강력 추천하는 제어판
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker volume create portainer_data &amp;amp;&amp;amp; \
docker run -d --name=portainer --restart=always -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:2.20.3-alpine
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;자주-사용하는-이미지-가져오기-모음&#34;&gt;자주 사용하는 이미지 가져오기 모음
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker pull rancher/rancher:stable &amp;amp;&amp;amp; docker pull  portainer/portainer-ce:2.0.1 &amp;amp;&amp;amp; \
docker pull centos:7 &amp;amp;&amp;amp; docker pull ubuntu:20.04 &amp;amp;&amp;amp; docker pull ubuntu:18.04 &amp;amp;&amp;amp; \
docker pull redis:5 &amp;amp;&amp;amp; docker pull redis:6 &amp;amp;&amp;amp; \
docker pull alpine:3.11 &amp;amp;&amp;amp; docker pull busybox:1.32 &amp;amp;&amp;amp; \
docker pull rabbitmq:3.7-management &amp;amp;&amp;amp; \
docker pull mariadb:10.2 &amp;amp;&amp;amp; \
docker pull nginx:1.18 &amp;amp;&amp;amp; docker pull nginx:1.19 &amp;amp;&amp;amp; \
docker pull mysql:5.6 &amp;amp;&amp;amp; docker pull mysql:8 &amp;amp;&amp;amp; \
docker pull elasticsearch:6.8.11 &amp;amp;&amp;amp; docker pull logstash:6.8.11 &amp;amp;&amp;amp; docker pull kibana:6.8.11 &amp;amp;&amp;amp; \
docker pull zookeeper:3.4 &amp;amp;&amp;amp; \
docker pull influxdb:1.7 &amp;amp;&amp;amp; docker pull grafana/grafana:7.3.1 &amp;amp;&amp;amp; \
docker pull percona:8 &amp;amp;&amp;amp; docker pull percona:5.6 &amp;amp;&amp;amp; \
docker pull cloverzrg/frps-docker:0.34.3 &amp;amp;&amp;amp; docker pull cloverzrg/frpc-docker:0.34.3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;자주-사용되는-명령어-조합&#34;&gt;자주 사용되는 명령어 조합
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/engine/reference/commandline/docker/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.docker.com/engine/reference/commandline/docker/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;컨테이너 실행 상태를 확인하고 &lt;code&gt;format&lt;/code&gt; 매개변수를 추가하여 자세한 컨테이너 정보를 확인합니다. 이때는 이미지 정보는 무시합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker ps --format &amp;quot;{{.Names}}: {{.Ports}}: {{.Size}}&amp;quot;
#portainer: 0.0.0.0:8000-&amp;gt;8000/tcp, 0.0.0.0:9000-&amp;gt;9000/tcp: 0B (virtual 172MB)
#influxdb: 0.0.0.0:8086-&amp;gt;8086/tcp: 183B (virtual 311MB)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;모든 컨테이너 중지&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker stop $(docker ps -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;모든 미러 삭제&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dokcer rmi $(docker images -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;이미지 내보내기&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; &amp;gt; -o XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이미지 내보내고 압축하기&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; | gzip &amp;gt; XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이미지 가져오기&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker load -i XXX.tar
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>리눅스 기반 Jmeter 압력 테스트 환경 구축</title>
        <link>https://ttf248.life/ko/p/linux-setup-jmeter-testing-environment/</link>
        <pubDate>Tue, 22 Dec 2020 10:12:50 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/linux-setup-jmeter-testing-environment/</guid>
        <description>&lt;p&gt;저자는 하드웨어에 대한 깊은 관심을 가지고 있으며, Jmeter를 사용하여 성능 테스트를 진행하고 CentOS 7에 Jmeter, InfluxDB 및 Grafana를 배포하는 과정을 기록했습니다. Jmeter 설치 및 명령어 사용법, InfluxDB의 특징 및 Docker 설치 방법, 그리고 Grafana의 간단한 배포 및 구성 방법을 공유했습니다. 고성능 프로그램 패턴에 대한 경험과 참고 자료를 정리했습니다.&lt;/p&gt;
&lt;h2 id=&#34;배경&#34;&gt;배경
&lt;/h2&gt;&lt;p&gt;다들 아시다시피 저는 하드웨어에 관심이 많습니다. 우연히 테스트팀에서 &lt;code&gt;Jmeter&lt;/code&gt;로 성능 테스트를 하고 있는데, 성능이 올라가지 않는 것을 발견했습니다. 호기심 많은 저라서 단번에 뛰어들어 회사에서 어떻게 압력 테스트를 하는지 살펴보기로 했습니다. 여기서 잠깐 일화 하나를 덧붙이자면, 아주 먼 옛날 오픈소스 차이나에서 어떤 게시글을 봤는데, 보기에도 더 멋진 성능 압력 테스트 그림을 그리는 방법에 대한 내용이었습니다. 테스트팀은 &lt;code&gt;windows&lt;/code&gt; 버전으로 실행되는 테스트를 지켜봤고, 시각화된 &lt;code&gt;TPS&lt;/code&gt; 데이터 표시가 이미 되어 있었습니다. 게다가 웹 패널을 설정하면 어떤 도움이 있을까요?&lt;/p&gt;
&lt;p&gt;생각은 자기만 생각하는 대로인데, 직접 해봐야 알 수 있어&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Don&amp;rsquo;t use GUI mode for load testing! only for Test creation and Test debuggin.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;공식적으로 권장하는 방법은 명령줄을 통해 부하 테스트 보고서를 얻고 GUI 방식으로 표시하는 것인데, 데이터 오류가 발생할 수 있나요? JMeter에 대한 이해는 깊지 않지만, 적어도 &lt;code&gt;Linux&lt;/code&gt; 버전 콘솔 패널을 굴려볼 만한 이유를 찾았습니다&lt;/p&gt;
&lt;p&gt;오픈소스차이나의 게시글인데, 핵심 컴포넌트 배포 방식이 썩 좋지 않고, 설치에 필요한 파일도 공중계정을 팔로우해야 다운로드할 수 있어서, 새세대 청년으로서 당연히 &lt;code&gt;Docker&lt;/code&gt;로 대체했다. 결국 서버가 국내에 있는 것이고, 국경 간 소스 주소 접근 속도는 매우 느리다. 적어도 이미지 서비스는 알리바이가 무료 가속을 제공한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker&lt;/code&gt; 설치 배포에 대한 내용은 여기서는 더 이상 설명하지 않겠습니다. 이전 기사를 참고하시기 바랍니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;다음 내용은 크게 두 부분으로 나뉩니다: 기본 테스트 환경 구성 요소 구축 및 각 구성 요소에 대한 간단한 설명&lt;/p&gt;
&lt;h2 id=&#34;jmeter&#34;&gt;Jmeter
&lt;/h2&gt;&lt;p&gt;Apache JMeter는 Apache 재단에서 개발한 Java 기반의 성능 테스트 도구입니다. 소프트웨어에 대한 부하 테스트를 위해 설계되었으며, 처음에는 웹 애플리케이션 테스트용으로 만들어졌지만 이후 다른 테스트 영역으로 확장되었습니다. 정적 파일, Java 마이크로 서비스, CGI 스크립트, Java 객체, 데이터베이스, FTP 서버 등과 같은 정적 및 동적 리소스를 테스트하는 데 사용할 수 있습니다. JMeter는 다양한 압력 범주에서 서버, 네트워크 또는 객체에 대한 막대한 부하를 시뮬레이션하여 강도를 테스트하고 전반적인 성능을 분석할 수 있습니다. 또한 JMeter는 어설션을 사용하여 스크립트를 생성하여 프로그램이 예상 결과를 반환하는지 확인하여 기능/회귀 테스트를 수행할 수 있습니다. 최대의 유연성을 위해 JMeter는 정규 표현식을 사용하여 어설션을 만들 수 있습니다.&lt;/p&gt;
&lt;p&gt;Apache JMeter는 정적 및 동적인 리소스(파일, 서블릿, Perl 스크립트, Java 객체, 데이터베이스 쿼리, FTP 서버 등)의 성능을 테스트하는 데 사용될 수 있습니다. 서버, 네트워크 또는 객체에 상당한 부하를 가하여 강도를 테스트하거나 다양한 유형의 압력 하에서 전체적인 성능을 분석할 수 있습니다. 성능의 그래프 분석을 수행하거나 대규모 동시 부하 테스트 시 서버/스크립트/객체를 테스트하는 데 사용할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;jmeter-배포-centos7&#34;&gt;JMeter 배포 CentOS7
&lt;/h3&gt;&lt;p&gt;JDK 실행 환경을 설치하고, Jmeter 설치 패키지를 다운로드합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install java-1.8.0-openjdk -y &amp;amp;&amp;amp; \
wget https://mirrors.bfsu.edu.cn/apache//jmeter/binaries/apache-jmeter-5.4.tgz &amp;amp;&amp;amp; tar -xf apache-jmeter-5.4.tgz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;환경 변수 설정&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export JMETER_HOME=$HOME/jmeter/apache-jmeter-5.4
export PATH=$JMETER_HOME/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;지메터-명령어&#34;&gt;지메터 명령어
&lt;/h3&gt;&lt;p&gt;최종적으로 &lt;code&gt;Grafana&lt;/code&gt; 제어판과 연결하면 &lt;code&gt;-l&lt;/code&gt; 파라미터를 입력하지 않고도 &lt;code&gt;web&lt;/code&gt; 제어대에서 데이터를 관찰할 수 있습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;jmeter -n -t /tmp/order-500-10s.jmx -l /tmp/jmeter-order-report-20200109/order-500-10s.jtl
# 一般不用测试结果和测试报告，简化命令
jmeter -n -t /tmp/order-500-10s.jmx
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;influxdb&#34;&gt;InfluxDB
&lt;/h2&gt;&lt;p&gt;InfluxDB는 Go 언어로 작성된 오픈 소스 분산 시계열, 이벤트 및 지표 데이터베이스이며 외부 의존성이 필요 없습니다. 이 데이터베이스는 현재 DevOps 모니터링 데이터, APP 메트릭, IoT 센서 데이터 및 실시간 분석 데이터와 같이 대량의 타임스탬프 데이터를 저장하는 데 주로 사용됩니다.&lt;/p&gt;
&lt;h3 id=&#34;인플럭스db-특징&#34;&gt;인플럭스DB 특징
&lt;/h3&gt;&lt;p&gt;인플럭스DB의 특징은 다음과 같은 9가지로 요약될 수 있습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;구조(패턴) 없음: 열의 개수가 임의일 수 있습니다&lt;/li&gt;
&lt;li&gt;메트릭 저장 기간을 설정할 수 있습니다&lt;/li&gt;
&lt;li&gt;시간 관련 함수(최소값, 최대값, 합계, 개수, 평균, 중앙값 등)를 지원하여 통계 처리에 용이하도록 합니다&lt;/li&gt;
&lt;li&gt;지원되는 저장 정책: 데이터의 삭제 및 수정에 사용할 수 있습니다.(InfluxDB는 데이터 삭제 및 수정 방법을 제공하지 않습니다)&lt;/li&gt;
&lt;li&gt;연속 쿼리 지원: 데이터베이스에서 자동으로 주기적으로 시작되는 일련의 문이며, 저장 정책과 함께 사용하면 InfluxDB 시스템 점유량을 줄일 수 있습니다&lt;/li&gt;
&lt;li&gt;네이티브 HTTP 지원, 내장된 HTTP API;&lt;/li&gt;
&lt;li&gt;SQL과 유사한 구문을 지원합니다&lt;/li&gt;
&lt;li&gt;클러스터 내 데이터 복제 수를 설정할 수 있습니다&lt;/li&gt;
&lt;li&gt;정기 샘플링 데이터를 지원하고, 다른 measurement에 기록하여 데이터의 세분화된 저장 기능을 제공합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;인플럭스db-도커-설치&#34;&gt;인플럭스DB 도커 설치
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir influxdb &amp;amp;&amp;amp; cd influxdb &amp;amp;&amp;amp; \
docker run -p 8086:8086 -d --name influxdb -v $PWD:/var/lib/influxdb influxdb:1.7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;컨테이너에 진입하여 명령을 실행하고, 수동으로 데이터베이스를 생성합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;root@bce0a55bbc72:/# influx
Connected to http://localhost:8086 version 1.7.10
InfluxDB shell version: 1.7.10
&amp;gt; 交互面板执行命令
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;인플럭스db-데이터베이스-및-사용자-생성&#34;&gt;인플럭스DB 데이터베이스 및 사용자 생성
&lt;/h3&gt;&lt;p&gt;데이터베이스 생성: create database jmeter_t2
데이터베이스 확인:
데이터베이스 전환: use jmeter_t2
사용자 생성: 비밀번호 &amp;lsquo;admin&amp;rsquo;으로 사용자 &amp;ldquo;admin&amp;quot;을 모든 권한으로 생성
사용자 보기&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; show users
user  admin
----  -----
admin true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;사용자 권한 &lt;code&gt;admin&lt;/code&gt;이 &lt;code&gt;true&lt;/code&gt;로 표시되면 데이터베이스 준비 작업은 완료되었습니다&lt;/p&gt;
&lt;h2 id=&#34;grafana&#34;&gt;Grafana
&lt;/h2&gt;&lt;p&gt;테스트 케이스를 작성하다 보니 차트 표시가 크게 필요하지 않다는 것을 알게 되었고, 인터페이스의 &lt;code&gt;tps&lt;/code&gt; 데이터는 명령줄에서 실행할 때 이미 관찰할 수 있으며, 더 중요한 것은 프로그램 내부의 소요 시간을 알고 싶다는 것이었습니다&lt;/p&gt;
&lt;p&gt;간단하게 &lt;code&gt;Grafana&lt;/code&gt; 대시보드 패널을 배포하고, 설정 파일을 가져와서 &lt;code&gt;InfluxDB&lt;/code&gt;에 연결합니다&lt;/p&gt;
&lt;p&gt;콘솔은 태그를 통해 테스트 결과를 필터링할 수 있으며, 일반적으로 &lt;code&gt;InfluxDB&lt;/code&gt; 데이터베이스 하나만 구성하면 됩니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;애플리케이션 이름&lt;/li&gt;
&lt;li&gt;테스트 사례 이름&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/linux-setup-jmeter-testing-environment/Snipaste_2021-03-09_19-44-22.png&#34;
	width=&#34;861&#34;
	height=&#34;357&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;grafana&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;241&#34;
		data-flex-basis=&#34;578px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -d --name=grafana -p 3000:3000 grafana/grafana:7.3.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;웹 버전은 샘플러 간격으로 인해 계산된 &lt;code&gt;TPS&lt;/code&gt; 및 관련 수치와 &lt;code&gt;Jmeter&lt;/code&gt; 집계 보고서가 일치하지 않을 수 있습니다. 참고 링크: &lt;a class=&#34;link&#34; href=&#34;https://www.vinsguru.com/jmeter-real-time-results-influxdb-grafana/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.vinsguru.com/jmeter-real-time-results-influxdb-grafana/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;자료에는 &lt;code&gt;리스너&lt;/code&gt;를 사용자 정의하는 방법도 설명되어 있습니다&lt;/p&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;고성능 프로그램 모드는 필연적으로 단일 루프 스레드이며, 어떠한 락, 대기열에 삽입 및 삭제도 불필요한 성능 손실을 야기한다&lt;/li&gt;
&lt;li&gt;핵심 비즈니스 로직의 처리 시간은 다른 코드 도입에 소요되는 시간보다 길기 때문에, 동시성만이 효율성을 효과적으로 높일 수 있다. 핵심 처리 시간이 충분히 짧다면 다른 코드를 신중하게 도입하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;JMeter 시리즈의 JMeter + Grafana + InfluxDB 실시간 모니터링&lt;/li&gt;
&lt;li&gt;인플럭스DB 공식 이미지&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://hub.docker.com/r/grafana/grafana&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Grafana 공식 이미지&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://jmeter.apache.org/download_jmeter.cgi&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;JMeter 공식 웹사이트&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@jasonli.studio/to-install-apache-jmeter-in-centos7-294bc72a97ba&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;To install Apache JMeter in CentOS7&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>레드햇과 CentOS 라이프사이클</title>
        <link>https://ttf248.life/ko/p/redhat-centos-lifecycle/</link>
        <pubDate>Tue, 21 Jul 2020 20:02:35 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/redhat-centos-lifecycle/</guid>
        <description>&lt;p&gt;온라인 생산 환경 운영체제로는 Red Hat과 CentOS가 주류 선택입니다. 두 시스템의 라이프사이클에 대한 공식 웹사이트 링크를 기록하고 CentOS 8에서 CentOS 8 Stream으로 업그레이드한 경험을 공유합니다.&lt;/p&gt;
&lt;h2 id=&#34;서론&#34;&gt;서론
&lt;/h2&gt;&lt;p&gt;온라인 생산 환경 운영체제는 현재 국내 환경에서 보면 Red Hat과 CentOS가 주류 선택입니다. 지난 2년 동안 Red Hat 6의 지원 종료를 경험했으므로, 이 두 시스템의 라이프사이클 공식 웹사이트 링크를 기록합니다.&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://access.redhat.com/support/policy/updates/errata&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Red Hat Enterprise Linux Life Cycle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;CentOS 제품 사양&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;레드햇 엔터프라이즈 리눅스(RHEL)와 CentOS는 기업용 서버 운영체제에서 널리 사용되는 선택입니다. RHEL은 안정적인 지원 및 업데이트 주기를 제공하며, 기업 환경에 적합합니다. CentOS는 RHEL의 커뮤니티 버전으로 유사한 기능과 안정성을 제공하지만 공식적인 지원은 없습니다.&lt;/p&gt;
&lt;h2 id=&#34;계속-봐&#34;&gt;계속 봐
&lt;/h2&gt;&lt;p&gt;이 원고를 게시할 때, 두 년 후 업데이트하게 될 줄은 상상도 못 했습니다. 이틀 전까지만 해도 일상적으로 사용하는 가상 머신을 CentOS 8에서 CentOS 8 Stream으로 업그레이드했습니다. 생산 환경에서는 어떻게 선택하든 제가 자세히 말씀드리기는 어렵고, 로컬 환경은 최신 버전을 추구하는 편입니다.&lt;/p&gt;
&lt;p&gt;CentOS 8 Stream은 지속적인 릴리스 버전으로, 기존 CentOS보다 빠른 업데이트와 새로운 기능을 제공하며 개발 및 테스트 환경에 적합합니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>컴퓨터 조립 그거</title>
        <link>https://ttf248.life/ko/p/computer-assembly-tips/</link>
        <pubDate>Sat, 18 Jul 2020 14:33:46 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/computer-assembly-tips/</guid>
        <description>&lt;p&gt;저자는 어릴 때부터 컴퓨터 조립에 대한 관심이 많았으며, 대학교 이후로 하드웨어 조립을 접하기 시작했습니다. CPU, SSD, HDD, 메모리 주파수 등 하드웨어 성능 비교 웹사이트 및 구매 추천 정보를 제공하고, 하드웨어 선택 경험과 주의사항을 공유합니다.&lt;/p&gt;
&lt;h3 id=&#34;인연은-말로-다-할-수-없네&#34;&gt;인연은 말로 다 할 수 없네
&lt;/h3&gt;&lt;p&gt;어렸을 때부터 내 컴퓨터를 조립하고 싶었는데, 안타깝게도 경제적인 상황이 허락하지 않았다. 어렵게 대학에 와서는 휴대성을 고려해서 노트북으로 샀다. 정확한 시점을 꼽자면, 고향 도서관에서 시작된 것 같은데. 어쨌든 시내 수준의 도서관이라 전자 열람실(사실 가본 적은 없고 유료였다고 함)도 있었지만, 잡지 열람실에서 《大众软件》이나 《电脑报》같은 잡지를 보게 되었는데, 컴퓨터를 많이 접해보지 못했던 나에게는 거의 신과 같은 과학 지식 자료였다. 몬스터 사냥하는 챕터를 보면 내 컴퓨터를 만들어서 같이 몬스터를 잡아 주력 딜러가 되고 싶었고, 첨단 기술에 대한 내용을 보면 책에서 보던 대로 따라 하면 설명된 효과를 낼 수 있을 거라고 상상했다(해킹 도구 사용에 대한 이야기). 물론 고등학교 과제가 많았고, 내가 알던 한도 내에서도 공부도 해야 하고 놀이도 해야 하니, 순수하고 천진난만하게 지냈다고 할 수 있다. 핑계로 도서관에 가서 책을 보러 가는 척하면 작은 가방 하나 들고 시내를 걸어가서 도서관에 갔다. 도착해서 에어컨을 틀고 소설, 만화, 게임 잡지를 보거나 가끔은 진지한 책도 읽었다.&lt;/p&gt;
&lt;p&gt;나이가 들면 건망증이 생기기 쉬운데, 도서관에서 벌어진 일은 처음 있는 일이 아니었다. 중학교 때 친척 집에서 컴퓨터를 조립한 적이 있는데, 그때 그 기계를 조립한 이유가 무엇이었는지 기억도 안 난다. 운영체제는 윈도우 2003이고, 게임은 시스템에 내장된 카드 + 문명 시대로 이루어져 있었다. 온갖 “꾀와 용기”를 발휘해서 열쇠를 훔쳐 동생과 함께 게임을 하곤 했다.&lt;/p&gt;
&lt;p&gt;방금 중학교에 입학했는데 바로 컴퓨터 기초 교육이 있었고, 나중에 전학하면서 컴퓨터 경시대회라는 개념을 조금 접하게 됐어. 고등학교 때에는 NOIP 한 번 치뤘지. 여기서 얘기를 하면 꼭 해야 할 말이 있는데, 동문들의 힘이 정말 대단했어. 고등학교의 컴퓨터 건물은 동문의 기부로 지어졌고, 컴퓨터 교실과 도서관을 포함하고 있어. 그때는 사실 국내 인터넷 물결의 초기에 해당했지. 학교 관계자들도 컴퓨터 경시대회 참여를 지원했는데, 어쨌든 앞선 두 학년 선배들 여러 명이 컴퓨터를 통해 명문 대학에 진학했으니까.&lt;/p&gt;
&lt;p&gt;나와 컴퓨터에 대한 일들을 이렇게 되돌아본 적은 없었다. 졸업 후 자동화 전공을 과감하게 포기하고 컴퓨터 업계로 넘어간 것도 이해가 된다. 이미 씨앗이 뿌려져 있었고, 다만 관련자들은 미처 알지 못했을 뿐이다. 어릴 때부터 많이 접해 두었기에 자신이 대단하다고 생각했지만, 사실은 겉핱기만 할 줄 알았고, 가장 큰 장점은 처음의 열정이었다.&lt;/p&gt;
&lt;h3 id=&#34;하드웨어-조립&#34;&gt;하드웨어 조립
&lt;/h3&gt;&lt;p&gt;카드바, 칩헬, 지후 컴퓨터 조립 게시판을 많이 둘러보면 초보자도 비교적 간단하게 자신이 원하는 기계 목록을 작성할 수 있습니다. 2019년 이후 CPU를 구매하는데 경제적인 여유가 없다면 더 높은 성능을 원한다면 AMD를 우선적으로 선택하세요.&lt;/p&gt;
&lt;p&gt;자주 사용하는 하드웨어 성능 비교 웹사이트를 추천합니다: &lt;a class=&#34;link&#34; href=&#34;https://cpu.userbenchmark.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cpu.userbenchmark.com/&lt;/a&gt; 가격은 거의 중고나라 미국 버전과 비교할 수 있습니다. 진정한 고수라면 중고나라에서 중고 제품을 구매하면 훨씬 저렴하게 살 수 있습니다. 하지만 잘 모르는 분들은 중고나라를 이용하지 않는 것이 좋습니다. 저는 가짜 메모리를 구매했는데, 현재 사용하면서는 문제가 없는 것 같지만 정확히는 모르겠습니다. 모델과 파라미터가 완전히 일치하지 않습니다.&lt;/p&gt;
&lt;h4 id=&#34;sn550-vs-sn750&#34;&gt;SN550 VS SN750
&lt;/h4&gt;&lt;p&gt;SN550 1TB 용량과 SN750 1TB 용량의 차이는 지속적인 읽기/쓰기 속도가 두 배 정도 다르다는 것인데, 하나는 850MB이고 다른 하나는 1.6GB입니다. 하지만 일상 사용에서는 차이가 없는데, 둘 다 4K 성능은 동일하기 때문입니다. 물론 여기서 말하는 것은 1TB 용량의 SN550이고, 500G와 250G 모델은 순차 읽기/쓰기 속도가 더 느립니다. 사실 돈을 신경 쓰지 않는다면 일상 사용에는 SN550로 충분하다고 생각합니다. 제가 이 제품을 사지 않은 가장 큰 이유는 순차 읽기/쓰기 속도 때문이 아니라 최대 용량이 1TB인 것에 있고, SN750은 2TB 용량을 제공하기 때문입니다. 저에게는 추가 확장 없이 메인보드의 M.2 Nvme 슬롯이 이러한 SSD의 가격 차이보다 더 가치 있다고 생각합니다.&lt;/p&gt;
&lt;p&gt;여러 누리꾼들의 결론을 종합해 볼 때, 어댑터 하나를 구입하면 B150 메인보드도 M.2 인터페이스의 SSD를 지원할 수 있습니다&lt;/p&gt;
&lt;h4 id=&#34;기계식-하드-디스크-구매-가이드&#34;&gt;기계식 하드 디스크 구매 가이드
&lt;/h4&gt;&lt;p&gt;기계식 하드 디스크는 현재 가격이 안정적인 추세이며, 대용량 저장 공간이 필요한 사용자라면 적절한 기계식 하드 디스크를 선택해야 합니다. 자주 자료를 다운로드하는 사용자에게는 엔터프라이즈급 하드 디스크를 추천하며, 흔히 볼 수 있는 제품으로는 다음과 같은 것들이 있습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서부 데이터 디스크&lt;/li&gt;
&lt;li&gt;시게 exos&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;대용량 기계식 하드 디스크는 파티션을 나누어 사용하는 것이 좋습니다. 잦은 다운로드 작업은 특정 파티션에서 고정하고, 나중에 불량 섹터가 발생하면 해당 파티션만 버리면 되므로 수명을 효과적으로 연장할 수 있습니다.&lt;/p&gt;
&lt;p&gt;시지 게이트 &lt;a class=&#34;link&#34; href=&#34;https://www.seagate.com/cn/zh/enterprise-storage/exos-drives/exos-e-drives/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;공식 소개&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;시게 기업용 하드 디스크 개요&lt;/p&gt;
&lt;p&gt;시게 기업용 하드 디스크 개요&lt;/p&gt;
&lt;h4 id=&#34;메모리-주파수&#34;&gt;메모리 주파수
&lt;/h4&gt;&lt;p&gt;일상 업무의 관점에서 보면, 빈도는 성능에 큰 영향을 미치지 않습니다&lt;/p&gt;
&lt;p&gt;메모리 타이밍(메모리.png) ! [짜충 메모리](짜충 메모리.png)&lt;/p&gt;
&lt;p&gt;메모리 타이밍(Memory timings 또는 RAM timings)은 동기식 동적 랜덤 액세스 메모리(SDRAM) 성능을 설명하는 네 가지 매개변수: CL, TRCD, TRP 및 TRAS로, 클럭 주기 단위입니다. 이들은 일반적으로 7-8-8-24와 같이 하이픈으로 구분된 네 개의 숫자로 표시됩니다. 네 번째 매개변수(RAS)는 종종 생략되며 때로는 다섯 번째 매개변수인 명령 레이트(Command rate)가 추가되기도 하는데, 이는 보통 2T 또는 1T로 표기되거나 2N, 1N으로 쓰이기도 합니다. 이러한 매개변수는 랜덤 액세스 메모리 속도에 영향을 미치는 지연 시간(latency)을 지정합니다. 낮은 숫자는 일반적으로 더 빠른 성능을 의미합니다. 시스템 성능을 결정하는 최종 요소는 실제 지연 시간이며, 이는 보통 나노초 단위로 표시됩니다.&lt;/p&gt;
&lt;p&gt;메모리 타이밍을 실제 지연으로 변환할 때는 시계 주기 단위로 측정된다는 점이 가장 중요합니다. 시계 주기의 시간을 모르면 숫자 세트가 다른 숫자 세트보다 빠른지 알 수 없습니다.&lt;/p&gt;
&lt;p&gt;예를 들어, DDR3-2000 메모리의 클럭 주파수는 1000MHz이고 클럭 주기는 1ns입니다. 이 1ns의 클럭을 기준으로 CL=7은 절대 지연 7ns를 나타냅니다. 반면에 더 빠른 DDR3-2666(클럭 1333MHz, 주기 0.75ns)은 더 큰 CL=9를 사용할 수 있지만, 결과적으로 절대 지연은 6.75ns로 더 짧습니다.&lt;/p&gt;
&lt;p&gt;현대 DIMM은 자동 구성 권장 메모리 타이밍이 포함된 직렬 존재 감지(SPD) ROM 칩을 포함합니다. PC의 BIOS는 성능 향상을 위해 타이밍을 조정할 수 있지만(안정성 저하 위험이 있음), 특정 상황에서는 안정성을 높일 수도 있습니다(예: 권장 타이밍 사용).&lt;/p&gt;
&lt;p&gt;주의: 메모리 대역폭은 메모리의 처리량을 측정하며, 일반적으로 지연 시간보다는 전송 속도에 의해 제한됩니다. SDRAM의 여러 내부 bank를 교차적으로 접근하면 이론상 최고 속도로 연속적인 데이터 전송이 가능합니다. 대역폭을 늘리기 위해서는 지연 시간을 증가시킬 수 있습니다. 구체적으로 말해, 새로운 DDR 메모리 세대는 높은 전송 속도를 가지고 있지만 절대 지연 시간은 크게 변하지 않습니다. 특히 시장에 처음 출시된 제품들은 이전 세대보다 더 긴 지연 시간을 가지는 경향이 있습니다.&lt;/p&gt;
&lt;p&gt;메모리 지연이 증가하더라도 메모리 대역폭을 늘리면 다중 프로세서 또는 여러 실행 스레드를 가진 컴퓨터 시스템의 성능을 향상시킬 수 있습니다. 더 높은 대역폭은 전용 그래픽 메모리가 없는 통합 그래픽 카드의 성능도 높여줄 것입니다.&lt;/p&gt;
&lt;p&gt;메모리 타이밍 파라미터 설명&lt;/p&gt;
&lt;h3 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;메모리 타이밍 파라미터 설명&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>사이트 가속 및 도메인 설정</title>
        <link>https://ttf248.life/ko/p/website-acceleration-and-domain-setup/</link>
        <pubDate>Sat, 20 Jun 2020 10:36:27 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/website-acceleration-and-domain-setup/</guid>
        <description>&lt;p&gt;국내에서 GitHub Pages 접속이 느려서, 저자는 개인 도메인을 신청하고 국내 클라우드 호스트 제공업체의 CDN 가속 서비스를 구매했습니다. 설정 과정에서 www 서브도메인에 접근할 수 없는 문제가 발생했는데, 최종적으로 와일드카드 도메인 해석을 삭제하고 개별 2차 도메인을 설정하여 해결했습니다. 저자는 또한 CDN 가속의 원리와 설정 경험, 그리고 Nginx 리버스 프록시를 사용한 시도와 그 교훈을 공유했습니다.&lt;/p&gt;
&lt;h3 id=&#34;배경&#34;&gt;배경
&lt;/h3&gt;&lt;p&gt;GitHub Pages에 호스팅되어 있는데, 몇 가지 잘 알려진 이유로 GitHub Pages의 국내 접속이 약간 느립니다. 그래서 개인 도메인을 신청하고 국내 클라우드 호스트 제공업체의 CDN 가속 서비스를 구매했습니다. 가속 서비스를 설정하면서 개발 머신에 docker, frp, k8s 등 여러 서비스가 배포되어 있고, 이 서비스들은 모두 관련 대시보드를 가지고 있다는 것을 떠올랐습니다. 낭비하지 않겠다는 원칙을 가지고 몇 개의 리버스 프록시를 구성하여 모든 것을 하위 도메인에 연결했습니다.&lt;/p&gt;
&lt;p&gt;二级 도메인을 사용하고 있는데 갑자기 www 서브도메인에 접속할 수 없게 되었고, 알리바바 클라우드에서 DNS 설정이 &lt;a class=&#34;link&#34; href=&#34;https://www.xiangtianlong.com&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;www.xiangtianlong.com&lt;/a&gt;과 xiangtianlong.com으로 동시에 해석되도록 되어 있습니다. CDN 가속을 아직 활성화하지 않았을 때는 두 도메인이 모두 정상적으로 작동했습니다.&lt;/p&gt;
&lt;p&gt;CDN 가속을 설정할 때, 2차 도메인이 너무 많아서 와일드카드 도메인 규칙을 활성화했고, 모두 개발 머신으로 라우팅했는데, 그 결과 www라는 2차 도메인도 함께 접속이 안 되게 됐습니다. 네, 맞아요, www 접두사도 2차 도메인입니다. 실제 웹사이트는 GitHub Pages에 배포되어 있고, 개발 머신에는 웹사이트 캐시 정보가 전혀 없습니다.&lt;/p&gt;
&lt;p&gt;개발 환경에 사이트를 배포하지 않아도 되는 이유는 정적 블로그이고, GitHub에서 제공하는 action을 활용하면 자동으로 통합되어 게시되니 정말 좋네요&lt;/p&gt;
&lt;h3 id=&#34;도메인&#34;&gt;도메인
&lt;/h3&gt;&lt;p&gt;비전문적인 웹 개발에서는 도메인에 대한 이해가 SEO나 교차 영역 문제와 관련이 없습니다. 블로그 사이트로서, 누드 도메인은 블로거의 사이트를 돋보이게 할 수 있는데, 이는 저처럼 한자 병음으로 도메인을 사용하는 어린아이들에게 해당하며, 현재 모바일 접속이 많은 만큼 몇몇 문자를 줄일 수 있습니다.&lt;/p&gt;
&lt;p&gt;컴퓨터에서는 www와 com을 입력할 필요 없이 바로 사용할 수 있습니다&lt;/p&gt;
&lt;h3 id=&#34;cdn&#34;&gt;CDN
&lt;/h3&gt;&lt;p&gt;알리바바 클라우드와 텐센트 클라우드를 모두 사용해 봤는데, 신규 사용자도 쉽게 시작할 수 있습니다. 텐센트 클라우드는 관련 개념을 설명하는 비디오도 따로 제공하고 있습니다. CDN 가속의 원리와 제이동(JD) 창고는 같은 원리입니다. 신상품을 출시하면 미리 전국 각지의 창고에 통일적으로 배송한 후, 배송 요청이 발생했을 때 가장 가까운 창고에서 배송합니다.&lt;/p&gt;
&lt;p&gt;원본 주소: 웹사이트 리소스가 원래 보관된 주소&lt;/p&gt;
&lt;p&gt;캐시 파일 설정, 브라우저 F12, 관리 콘솔, 간단한 정적 리소스 및 동적 리소스 분석&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;전부 0일 유효기간&lt;/li&gt;
&lt;li&gt;.php;.jsp;.asp;.aspx 파일은 유효 기간이 0일입니다&lt;/li&gt;
&lt;li&gt;.jpg;.png;.js;.css;.woff2 유효기간 1일&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;텐센트 클라우드 설정 규칙:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;캐시 만료 규칙은 최대 10개까지 구성할 수 있습니다&lt;/li&gt;
&lt;li&gt;여러 캐시 만료 규칙 간의 우선순위는 하단 우선입니다&lt;/li&gt;
&lt;li&gt;캐시 만료 시간은 최대 365일까지 설정할 수 있습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;비참한-자수풀&#34;&gt;비참한 자수풀
&lt;/h3&gt;&lt;p&gt;예전에는 Nginx를 사용해 본 적이 없어서 웹사이트 검색으로만 역방향 프록시 설정을 이해할 수 있을 거라고 생각했는데, 결과가 좀 혼란스러웠습니다. 반나절을 끙끙거려도 302 리디렉션조차 제대로 설정하지 못해서 결국 아무 소용이 없었습니다. 그래서 어리석은 방법으로 해결하려고 DNS 파싱에서 *모드와 같은 일반 도메인 파싱을 삭제하고 개별 2단계 하위 도메인을 독립적으로 설정했습니다. 그때 갑자기 알리바바 클라우드 DNS 파싱에 &amp;lsquo;표시 URL 리디렉션&amp;rsquo;이라는 모드가 있다는 것을 알아차렸고, 시도해 보니 이게 제가 원하는 302 리디렉션이었습니다.&lt;/p&gt;
&lt;p&gt;첫 번째 2차 도메인을 설정하니 정상적으로 접속되는데, 두 번째를 설정하려니 안 되어서 거의 인생의 의미를 의심할 지경이었어요. 잠시 기다리니까 갑자기 잘 된다는 걸 보니, 알리바바 클라우드의 DNS 전파가 가끔씩 고장 나는 것 같네요.&lt;/p&gt;
&lt;h3 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;www가 없는 웹사이트 주소가 점점 더 많아지는 이유는 무엇인가요?&lt;/li&gt;
&lt;li&gt;www가 포함된 도메인과 미포함된 도메인의 차이점은 무엇인가요?&lt;/li&gt;
&lt;li&gt;도커 Nginx 리버스 프록시 설정&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>블로그 IDE 환경과 잡담</title>
        <link>https://ttf248.life/ko/p/blog-ide-environment-and-ramblings/</link>
        <pubDate>Tue, 31 Mar 2020 13:54:27 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/blog-ide-environment-and-ramblings/</guid>
        <description>&lt;p&gt;이 글은 마크다운의 기본 개념과 다양한 소프트웨어에서의 활용을 소개하고, VSCode를 IDE로 추천하며 관련 플러그인 목록을 제시합니다. 저자는 Hexo에서 Hugo로 전환한 경험을 공유하며 Hugo의 유연성과 사용자 정의 기능을 강조합니다. 마지막으로 새로운 기술을 빠르게 시작하기 위한 몇 가지 팁과 함께 Hugo 테마 스타일이 업데이트되지 않는 문제를 해결하는 작은 팁을 공유합니다.&lt;/p&gt;
&lt;h2 id=&#34;서론&#34;&gt;서론
&lt;/h2&gt;&lt;h3 id=&#34;markdown&#34;&gt;Markdown
&lt;/h3&gt;&lt;p&gt;가볍고 사람이 읽기 쉽고 쓰기 쉬운 순수 텍스트 형식으로 문서를 작성할 수 있게 해주는 경량 마크업 언어입니다&lt;/p&gt;
&lt;p&gt;자세한 Markdown 문법에 대한 설명은 이 글에서는 생략하며, 전자책을 참고하시기를 추천합니다. &lt;a class=&#34;link&#34; href=&#34;https://markdown-zh.readthedocs.io/en/latest/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;여기에 클릭&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;시판되는 많은 소프트웨어들은 이미 md를 작성 방식으로 지원하고 있습니다. csdn 블로그 시스템은 md 문법을 지원하는 온라인 편집기를 출시했는데, 처음 사용할 때 md 문법에 대한 소개 글이 기본적으로 제공되며, 필자는 괜찮다고 생각합니다. 에버노트(印象笔记)는 2018년에 md 노트 지원을 추가했으며, 단축키 바에 다양한 md 마크업 옵션이 있어 일반적인 문서 편집과 거의 비슷하며, 전반적인 인터랙션 흐름은 초보자에게 친숙합니다.&lt;/p&gt;
&lt;h3 id=&#34;ide-추천&#34;&gt;IDE 추천
&lt;/h3&gt;&lt;p&gt;이 글을 작성할 당시에는 이미 2020년이었고, vscode는 필연적으로 들어봤을 것이다. 결국 git page를 사용하여 블로그 시스템을 구축한다고 생각하는 사람은 업계 관계자일 테니까. 과거에는 sublime이나 atom도 괜찮은 선택이었지만, 2년간의 오픈소스 커뮤니티의 노력으로 vscode가 빠르게 발전하여 점차 초보자들이 입문하기에 가장 좋은 선택이 되었다.&lt;/p&gt;
&lt;p&gt;마이크로소프트의 거대 기업과 오픈소스 커뮤니티 관계가 단절된 상태에서 성공적으로 신혼기 시대로 전환되었습니다. 오픈 소스를 포용하고, 필자가 속한 회사 역시 최근 2년간 적극적으로 Java 생태계를 도입했습니다. 바꿔 말하면 현재 국내 비즈니스 개발에 있어 Java 생태계는 정말 매력적입니다.&lt;/p&gt;
&lt;h3 id=&#34;vs-code-플러그인-추천&#34;&gt;VS Code 플러그인 추천
&lt;/h3&gt;&lt;p&gt;플러그인 목록&lt;/p&gt;
&lt;p&gt;플러그인에는 자체 Readme 파일이 있어 기본적인 사용법과 핵심 기능을 설명하고 있으며, 일부 플러그인 제작자는 동적 효과 시연 이미지도 제공합니다&lt;/p&gt;
&lt;p&gt;이미지를 붙여넣기 하면 Hugo의 이미지 플러그인 방식으로 매우 편리하게 이미지를 추가할 수 있습니다&lt;/p&gt;
&lt;p&gt;단축키를 기억하지 못해서, vscode 단축키 관리 메뉴를 열고 md를 검색하고 여러 번 보고; 플러그인 사용 설명서를 다시 확인해 봐&lt;/p&gt;
&lt;h2 id=&#34;hugo&#34;&gt;hugo
&lt;/h2&gt;&lt;p&gt;저는 &lt;code&gt;hexo&lt;/code&gt;에서 &lt;code&gt;hugo&lt;/code&gt;로 전환했는데, 잦은 변덕을 피우는 것이 제 본성이고 결국 차분히 글을 쓰는 것을 참지 못하고 말았습니다&lt;/p&gt;
&lt;p&gt;휴고는 이미지를 별도의 폴더에 배치하고 md 문서를 지원합니다
학문적 주제는 디자인에서 다양한 종류의 문서 스타일을 지원합니다
다양한 편리한 사용자 지정 확장 기능&lt;/p&gt;
&lt;h2 id=&#34;academic&#34;&gt;academic
&lt;/h2&gt;&lt;p&gt;공식 웹사이트는 기본적으로 &lt;code&gt;exampleSite&lt;/code&gt;를 사용하며, 메뉴 도입 시 &lt;code&gt;#컴포넌트&lt;/code&gt; 방식을 채택하고 &lt;code&gt;URL&lt;/code&gt;을 사용하는 것을 권장합니다&lt;/p&gt;
&lt;p&gt;URL 패턴은 클릭하면 단일 페이지로 이동하고, 홈페이지에서 스크롤하는 방식이 아니라서 개인적인 취향입니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스타일별: 에세이, 강연, 전자책&lt;/li&gt;
&lt;li&gt;유연성: 전체 스타일 사용자 정의, CSS 스타일 사용자 정의&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 테마는 중국어 지원이 아직 완벽하지 않은데, 주로 시각적인 측면에서 폰트 크기가 중국어 읽기 습관에 잘 맞지 않습니다. Hexo 개발자 대다수가 중국인이므로 이 점에서는 Hugo보다 우수합니다.&lt;/p&gt;
&lt;p&gt;하지만, 직접 옷을 만들어 먹고, 브라우저에서 요소들을 검사합니다. 요소를 찾았으면 수정해야 할 CSS 스타일 이름이 궁금할 때 사이드바에서 &lt;strong&gt;Insert Style Rule Below&lt;/strong&gt;를 클릭하면 여러 계층으로 중첩된 CSS라도 쉽게 노드 이름을 가져올 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://sourcethemes.com/academic/docs/customization/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;custom.css 도입&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://sourcethemes.com/academic/docs/customization/#add-scripts-js&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;사용자 지정 &lt;strong&gt;custom_js&lt;/strong&gt; 도입&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;테마 내장 문법 강조 설정, &lt;a class=&#34;link&#34; href=&#34;https://sourcethemes.com/academic/docs/writing-markdown-latex/#highlighting-options.&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;공식 링크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;마무리&#34;&gt;마무리
&lt;/h2&gt;&lt;p&gt;애가 또 뭐라 하려고 하는군, 어떻게 처음부터 끝까지 얼버무려 얘기하고 세부사항 같은 건 하나도 안 짚어주는 거야?&lt;/p&gt;
&lt;p&gt;이것들이 있으면 충분할 거예요:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;공식 매뉴얼&lt;/li&gt;
&lt;li&gt;플러그인 설명&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;새로운 기술을 빠르게 시작하려면 먼저 공식 문서를 읽어보는 것이 좋습니다. 완벽하게 이해하려고 애쓰기보다는 대략적인 내용을 파악하는 데 집중하고, 검색 엔진에서 나오는 결과는 최신 버전과 일치하지 않을 수 있으므로 오해를 불러일으킬 수도 있습니다. 새 책도 마찬가지입니다. 목차를 먼저 보고 저자가 무엇을 이야기하려는지 파악하세요. 때로는 서문을 읽는 것이 좋습니다. 일부 외국 저작물이 중국어로 번역될 때, 번역자의 서문은 책의 핵심 내용과 상당 부분을 포함하고 있는 경우가 많습니다.&lt;/p&gt;
&lt;h2 id=&#34;이스터-에그&#34;&gt;이스터 에그
&lt;/h2&gt;&lt;p&gt;Hugo Academic 내장 스타일 스타일을 변경하고 사이트에 게시했지만, 방문 시 스타일이 변하지 않았습니다. 똑똑한 분들은 이미 생각했을 겁니다. 로컬 브라우저 캐시를 지우면 문제가 해결됩니다. 저처럼 영리한 방법은 F12 개발자 모드로 전환하여 &lt;code&gt;network&lt;/code&gt;로 이동한 다음 &lt;code&gt;disable cache&lt;/code&gt;를 선택하고 새로 고침하면 됩니다!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/blog-ide-environment-and-ramblings/2020-03-31-14-27-15.png&#34;
	width=&#34;399&#34;
	height=&#34;142&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;network&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;280&#34;
		data-flex-basis=&#34;674px&#34;
	
&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>자동 통합 시스템 전환</title>
        <link>https://ttf248.life/ko/p/auto-integration-system-switch/</link>
        <pubDate>Sun, 29 Mar 2020 02:11:33 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/auto-integration-system-switch/</guid>
        <description>&lt;p&gt;GitHub Actions를 사용하여 Hugo 블로그를 GitHub Pages 및 Gitee에 자동으로 배포합니다&lt;/p&gt;
&lt;h4 id=&#34;배경-소개&#34;&gt;배경 소개
&lt;/h4&gt;&lt;p&gt;어제 블로그를 업데이트하려는데 Travis 서비스가 안 된다는 걸 발견했어요. Travis 웹페이지를 살펴보니 진행이 소스 코드를 가져오는 단계에서 멈춰 있었고, 그때 GitHub에서 출시한 Action 서비스가 떠올랐습니다.&lt;/p&gt;
&lt;p&gt;그때는 좀 바쁠 것 같고, 액션을 사용하려면 신청도 해야 해서, 지금부터 정식으로 출시되었으니 주말에 시간 나면 새로운 장난감을 한번 해볼까요?&lt;/p&gt;
&lt;p&gt;공식 자료는 다들 웹사이트에서 직접 확인하시면 되고, 본문은 더 이상 인용하지 않겠습니다. 이전에 쿠버네티스를 사용해 보신 분들은 액션의 YAML 파일 설정이 쿠버네티스와 비슷하다고 느끼실 겁니다.&lt;/p&gt;
&lt;p&gt;초보자를 위한 튜토리얼이나 중국어 소개 자료를 찾고 있다면 &lt;strong&gt;阮一峰의 블로그&lt;/strong&gt;에서 검색해 보세요. 두 개의 기사가 있는데, 하나는 기본적인 문법 설명이고 다른 하나는 실제 사례입니다.&lt;/p&gt;
&lt;h4 id=&#34;본문&#34;&gt;본문
&lt;/h4&gt;&lt;p&gt;필요한 지식점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;github secrets&lt;/li&gt;
&lt;li&gt;행동 구문&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;핵심 작업은 기존 컴포넌트를 사용하여 완료되었고, 명령어를 통해 국내 gitee에 푸시했습니다. 명령어 부분은 다소 거칠며 강제 푸시를 사용하고 있으며, travis를 사용하던 로직을 이어받았습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;name: github pages and gitee pages

on:
  push:
    branches:
      - hugo

jobs:
  deploy:
    runs-on: ubuntu-18.04
    steps:
      - uses: actions/checkout@v2
        with:
          submodules: true

      - name: Setup Hugo
        uses: peaceiris/actions-hugo@v2
        with:
          hugo-version: &#39;latest&#39;
          extended: true

      - name: Build Github and Gitee ## 单个step只能写一个run命令
        run: hugo -b &amp;quot;https://www.xiangtianlong.com/&amp;quot; -d &amp;quot;github_public&amp;quot; &amp;amp;&amp;amp; hugo -b &amp;quot;https://www.xiangtianlong.com/&amp;quot; -d &amp;quot;gitee_public&amp;quot; &amp;amp;&amp;amp; ls

      - name: Deploy Github
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.BLOG_TOKEN }}
          publish_dir: ./github_public
          publish_branch: master
          cname: xiangtianlong.com

      - name: Deploy Gitee
        run: cd ./gitee_public &amp;amp;&amp;amp; git init &amp;amp;&amp;amp; git config user.name &amp;quot;TianlongXiang&amp;quot; &amp;amp;&amp;amp; git config user.email &amp;quot;tianlongxiang51@gmail.com&amp;quot; &amp;amp;&amp;amp; git add . &amp;amp;&amp;amp; git commit -m &amp;quot;Update TianlongXiang&#39;s Blog&amp;quot; &amp;amp;&amp;amp; git push --force &amp;quot;https://xiangtianlong:${{ secrets.GITEE_PASSWORD }}@gitee.com/xiangtianlong/xiangtianlong.git&amp;quot; master:master   
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;사후기&#34;&gt;사후기
&lt;/h4&gt;&lt;p&gt;공식 시장에서 제공하는 기능들을 보면 현재 지원되는 플레이 방식이 꽤 많고, Docker 이미지를 구축하면 더 이상 Docker Hub에서 제공하는 서비스에 의존하지 않아도 된다&lt;/p&gt;
&lt;p&gt;Hugo 이슈를 확인해 보니, GitHub 액션을 사용하여 Git Pages를 자동으로 배포하려면 최종적으로 게시되는 웹 페이지가 master 브랜치에 있어야 합니다. 다른 브랜치에 배포하면 설정 인터페이스에서 GitHub이 배포된 웹 페이지에 구문 문제가 있다는 것을 알립니다.&lt;/p&gt;
&lt;p&gt;실제로 hugo의 원 파일이 master 브랜치에 위치해 있어서, github가 jelly 블로그의 소스 코드로 간주하여 검사하고 통과하지 못하게 하는 오류로 인한 것이다&lt;/p&gt;
&lt;p&gt;솔루션도 간단합니다. Hugo 소스 파일을 다른 분기에 두고, 정적 파일은 master 분기에 게시하면 됩니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>표준 라이브러리 컨테이너의 메모리 할당자: allocator</title>
        <link>https://ttf248.life/ko/p/standard-library-container-memory-allocator/</link>
        <pubDate>Mon, 30 Dec 2019 13:26:19 +0800</pubDate>
        
        <guid>https://ttf248.life/ko/p/standard-library-container-memory-allocator/</guid>
        <description>&lt;p&gt;사용자 정의 할당자는 성능을 향상시키고 메모리 사용 효율성을 높이며 빈번한 소량의 메모리 할당 문제를 해결할 수 있습니다&lt;/p&gt;
&lt;h4 id=&#34;전인&#34;&gt;전인
&lt;/h4&gt;&lt;p&gt;최근 네트워크 데이터 패킷 개발을 진행하면서 빈번하게 작은 메모리 블록을 할당하고 해제해야 하는데, 원래는 메모리 풀을 사용하려 했고, 기존의 몇몇 메모리 풀들을 살펴보니 이런 것을 발견했다&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/cacay/MemoryPool&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/cacay/MemoryPool&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;인터페이스를 보니까 좀 이상하다는 생각이 들었는데, 이 메모리 풀 구현 방식이 왜 이렇게 특이할까. &lt;code&gt;MemoryPool&lt;/code&gt;의 구현 로직은 고정된 크기의 메모리 공간을 할당하는 방식인데. Boost의 메모리 풀 인터페이스를 보면 템플릿으로 제공되고 사용 시에 인스턴스화해야 한다. 다행히 이 라이브러리에 대한 설명이 있는 글도 있고, 거기서 &lt;code&gt;allocator&lt;/code&gt;라는 개념이 언급되어 있었다.&lt;/p&gt;
&lt;h4 id=&#34;wikihttpszhwikipediaorgwikie58886e9858de599a8_c2b2b&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_%28C%2B%2B%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wiki&lt;/a&gt;
&lt;/h4&gt;&lt;p&gt;C++ 프로그래밍에서 할당자(allocator)는 C++ 표준 라이브러리의 중요한 구성 요소입니다. C++ 라이브러리에는 연결 리스트, 집합 등 다양한 “컨테이너” 데이터 구조가 정의되어 있으며, 이러한 컨테이너의 공통적인 특징 중 하나는 프로그램 실행 시간에 크기를 변경할 수 있다는 것입니다. 이를 구현하기 위해 동적 메모리 할당이 필수적이므로 할당자는 컨테이너의 메모리 할당 및 해제 요청을 처리하는 데 사용됩니다. 다시 말해, 할당자는 표준 템플릿 라이브러리(STL) 컨테이너의 메모리 관리에 대한 저수준 세부 사항을 캡슐화합니다. 기본적으로 C++ 표준 라이브러리는 자체 제공하는 범용 할당자를 사용하지만, 필요에 따라 프로그래머는 자신만의 할당자를 정의하여 이를 대체할 수 있습니다.&lt;/p&gt;
&lt;p&gt;할당기는 원래 C++ 표준 템플릿 라이브러리(Standard Template Library, STL)의 일부로 알렉산드르 스테파노프에 의해 발명되었으며, 그의 초기 목표는 &amp;ldquo;라이브러리를 더욱 유연하게 만들고 기본 데이터 모델에 의존하지 않는 방법&amp;quot;을 만드는 것이었습니다. 이를 통해 프로그래머는 라이브러리에서 사용자 정의 포인터 및 참조 유형을 활용할 수 있었습니다. 그러나 C++ 표준 템플릿 라이브러리를 C++ 표준으로 포함하는 과정에서 C++ 표준 위원회는 데이터 모델의 완전한 추상화가 용납할 수 없는 성능 저하를 초래한다는 것을 깨달았습니다. 이러한 절충안으로 인해 표준에서 할당기에 대한 제한이 더욱 엄격해졌고, 결과적으로 현재 표준에 설명된 할당기는 스테파노프의 원래 구상과 비교하여 사용자 정의 가능성이 크게 제한되었습니다.&lt;/p&gt;
&lt;p&gt;할당기 사용자 정의는 어느 정도 제한이 있지만, 많은 경우 다양한 메모리 공간(공유 메모리나 재활용 메모리와 같은)에 대한 접근 방식을 캡슐화하거나, 메모리 풀을 사용하여 메모리를 할당할 때 성능을 향상시키기 위해 여전히 사용자 정의 할당기가 필요합니다. 또한, 빈번한 소량의 메모리 할당이 발생하는 프로그램에서 전용으로 맞춤 제작된 할당기를 도입하면 메모리 사용량과 실행 시간 측면에서도 상당한 이점을 얻을 수 있습니다.&lt;/p&gt;
&lt;h4 id=&#34;사용-요건&#34;&gt;사용 요건
&lt;/h4&gt;&lt;p&gt;정의된 사용자 정의 할당자의 주요 이유 중 하나는 성능 향상입니다. 전용 사용자 정의 할당자를 사용하면 프로그램의 성능을 높이거나 메모리 사용 효율성을 높이거나 둘 다 달성할 수 있습니다[4][8]. 기본 할당자는 new 연산자를 사용하여 저장 공간을 할당하는데, 이는 종종 C 언어 힙 할당 함수(malloc())를 통해 구현됩니다[9]. 힙 할당 함수는 일반적으로 일시적으로 많은 양의 메모리를 할당하는 데 최적화되므로 대량의 메모리를 한 번에 할당해야 하는 컨테이너(예: 벡터, 양방향 큐)의 경우 기본 할당자는 일반적으로 효율적입니다[8]. 그러나 연결된 컨테이너 및 양방향 링크드 리스트와 같이 빈번하게 소량의 메모리를 할당해야 하는 컨테이너의 경우 기본 할당자를 사용하면 일반적으로 효율성이 매우 낮습니다[4][9]. 또한 malloc()을 기반으로 하는 기본 할당자는 낮은 지역성[4]과 메모리 조각화 발생 가능성[4][9]과 같은 많은 문제를 가지고 있습니다.&lt;/p&gt;
&lt;p&gt;간단히 말해서, 이 부분(……)은 마치 이 표준이 할당기(allocator)에 대해 발표한 《나는 꿈이 있다》와 같습니다. 꿈이 실현되기 전에는 이식 가능성을 고려하는 프로그래머들은 상태 없는(stateless) 사용자 정의 할당기를 사용하는 데 스스로를 제한할 것입니다.
——스코트 메이스, 《Effective STL》
이러한 점을 감안하여, 이러한 상황에서 사람들은 빈번한 소량 할당 문제를 해결하기 위해 메모리 풀 기반 할당기를 자주 사용합니다[8]. 기본 “요청 시 할당” 방식과 달리, 메모리 풀 기반 할당기를 사용할 때는 프로그램이 미리 대용량 메모리(즉, &amp;ldquo;메모리 풀&amp;rdquo;)를 할당하고, 필요할 때 사용자 정의 할당기는 요청자에게 풀 내 메모리의 포인터를 반환하기만 합니다. 객체 소멸 시에는 실제로 메모리를 해제하지 않고, 메모리 풀의 수명이 종료될 때 비로소 메모리를 해제합니다[주 1][8].&lt;/p&gt;
&lt;p&gt;“사용자 정의 할당기”라는 주제에 대해 이미 많은 C++ 전문가와 관련 저자들이 참여하여 토론해 왔습니다. 예를 들어 스콧 메이어스의 “Effective STL”과 안드레이 알렉산더레스쿠의 “Modern C++ Design”에도 언급되어 있습니다. 메이어스는 특정 타입 T의 할당기 인스턴스가 모두 동일해야 한다면, 이식 가능한 할당기 인스턴스는 상태를 포함해서는 안 된다고 통찰했습니다. C++ 표준은 라이브러리 구현자가 상태 기반 할당기를 지원하도록 장려하지만[문헌 4], 메이어스는 관련 단락이 “（보이는 듯한）아름다운 관점”이지만 거의 말장난이라고 비판하며, 할당기의 제약이 “지나치게 엄격하다”고 주장했습니다[4]. 예를 들어 STL의 list는 splice 메서드를 제공하는데, 이는 list 객체 A의 노드를 다른 list 객체 B에 직접 이동시킬 수 있습니다. 이는 A의 할당기가 할당한 메모리가 B의 할당기에 의해 해제될 수 있어야 하므로, A와 B의 할당기 인스턴스가 동일해야 함을 의미합니다. 메이어스의 결론은 할당기를 정적 메서드를 사용하는 타입으로 정의하는 것이 가장 좋다는 것입니다. 예를 들어 C++ 표준에 따르면 할당기는 rebind 메서스를 구현한 other 클래스 템플릿을 제공해야 합니다.&lt;/p&gt;
&lt;p&gt;또 다른 한편, 《C++ 프로그램 설계 언어》에서 비야니 스트라우스트루프는 “‘엄격한 할당기 제한으로 각 객체 정보의 차이를 없앤다’는 점은 분명 큰 문제가 아니다.”라고 주장하며 대부분의 할당기는 상태가 필요하지 않으며 심지어 상태가 없는 경우 성능이 더 좋을 수도 있다고 지적한다. 그는 메모리 풀형 할당기, 공유 메모리형 할당기 및 가비지 컬렉션형 할당기의 세 가지 사용자 정의 할당기 사용 사례를 제시하고 내부 메모리 풀을 활용하여 소량의 메모리를 빠르게 할당/해제하는 할당기 구현을 보여준다. 하지만 그는 이러한 최적화가 이미 그가 제공한 예시 할당기에서 구현되었을 수도 있다고 언급한다[3].&lt;/p&gt;
&lt;p&gt;사용자 정의 할당기의 또 다른 용도는 메모리 관련 오류를 디버깅하는 것입니다[10]. 이를 위해 추가 메모리를 할당하여 디버그 정보를 저장할 수 있도록 할당기를 작성할 수 있습니다. 이러한 할당기는 메모리가 동일한 유형의 할당기에서 할당/해제되는지 확인하는 것 외에도 캐시 오버플로로부터 프로그램이 어느 정도 보호되도록 할 수 있습니다[11].&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
