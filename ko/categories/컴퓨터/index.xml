<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>컴퓨터 on 향숙의 수첩</title>
        <link>https://blog.ttf248.life/ko/categories/%EC%BB%B4%ED%93%A8%ED%84%B0/</link>
        <description>Recent content in 컴퓨터 on 향숙의 수첩</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ko</language>
        <lastBuildDate>Wed, 28 May 2025 09:47:38 +0800</lastBuildDate><atom:link href="https://blog.ttf248.life/ko/categories/%EC%BB%B4%ED%93%A8%ED%84%B0/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>GitHub 페이지 이스터에그: 여러 페이지 배포</title>
        <link>https://blog.ttf248.life/ko/p/github-pages-easter-egg-deploy-multiple-sites/</link>
        <pubDate>Wed, 28 May 2025 02:55:54 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/github-pages-easter-egg-deploy-multiple-sites/</guid>
        <description>&lt;p&gt;최근 생체 리듬이 좀 엉망이라 새벽 두시 넘게까지도 Github Pages 배포를 만지작거렸어&lt;/p&gt;
&lt;p&gt;밤늦게까지 일하고 밥을 먹으러 갔더니, 딱 먹고 나자 졸리고, 다 먹고 돌아오니 8시 반쯤 됐는데 너무 피곤해서 잠깐 눈을 붙이려다 잠이 들어버렸네요. 깨보니 이미 새벽 2시가 넘었어요.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;시작하기도 전에 사라진 분류: AI 학습회&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;망신당하다&#34;&gt;망신당하다
&lt;/h2&gt;&lt;p&gt;어제는 프론트엔드 일은 하지 말자고 했는데, 오늘은 프론트엔드가 아닌 UI/UX 경험을 개선해 봅시다&lt;/p&gt;
&lt;h2 id=&#34;프로젝트&#34;&gt;프로젝트
&lt;/h2&gt;&lt;p&gt;초청합니다, 우리의 오랜 친구 &lt;a class=&#34;link&#34; href=&#34;https://github.com/ttf248/ai-coding-demo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ttf248/ai-coding-demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;맞아요, 바로 기존 자선주 프로젝트고요, 이 프로젝트에서 전체 구조를 재구성하고, 이후 AI 프로그래밍 관련 내용은 모두 이 프로젝트 아래로 둘 예정입니다&lt;/p&gt;
&lt;h2 id=&#34;여러-페이지-배포&#34;&gt;여러 페이지 배포
&lt;/h2&gt;&lt;p&gt;프로젝트가 &lt;a class=&#34;link&#34; href=&#34;https://cnb.cool/ttf248/ai-coding-demo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cnb.cool/ttf248/ai-coding-demo&lt;/a&gt;에 호스팅되어 있는데, 널리 알려진 이유로 국내에서는 페이지를 게시할 수 없습니다. 따라서 해외 GitHub에 게시해야 합니다.&lt;/p&gt;
&lt;p&gt;블로그는 해외의 Github에 게시하는 것입니다. 아직 시도해보지는 않았지만, 여러 프로젝트 페이지를 발행하고, 현재 처리 중인 프로젝트는 전통적인 블로그 사이트가 아니라 문서가 많고 몇몇 정적 HTML 디자인 시안이 겹쳐져 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/github-pages-easter-egg-deploy-multiple-sites/20250528030230.png&#34;
	width=&#34;798&#34;
	height=&#34;530&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;pages&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;150&#34;
		data-flex-basis=&#34;361px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;맞아요, 이 페이지는 제가 처음 클릭했을 때 발견했는데, 여러 프로젝트의 페이지 배포가 블로그 게시물에 영향을 주지 않고, 블로그 도메인 아래 새로운 경로를 추가하는 방식이에요&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://ttf248.life/ai-coding-demo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ttf248.life/ai-coding-demo/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;여기 보니 완벽하다!&lt;/p&gt;
&lt;h2 id=&#34;ai-학습회&#34;&gt;AI 학습회
&lt;/h2&gt;&lt;p&gt;어제 새로 만든 분류인데, AI를 통해 컴퓨터 과목을 많이 배우려고 하는데, 예를 들어 알고리즘이나 LeetCode 문제 풀이 같은 것들이다&lt;/p&gt;
&lt;p&gt;매 학습 기록을 블로그에 게시하여 지식 기반을 구축합니다. 새로운 분류: AI 연구소&lt;/p&gt;
&lt;p&gt;지금으로서는, 다른 수업마다 새로운 프로젝트를 만들고 학습 노트는 모두 해당 프로젝트의 Readme.md 파일에 작성하는 것이 좋겠습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>오래된 습관, 화려함에 눈이 멀다</title>
        <link>https://blog.ttf248.life/ko/p/old-ailment-stunning-flowers/</link>
        <pubDate>Mon, 26 May 2025 23:54:12 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/old-ailment-stunning-flowers/</guid>
        <description>&lt;p&gt;수년간 백엔드 개발에 집중해 왔는데, 최근 프론트엔드 인터페이스를 구현하기 위해 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 编程，并涉足了一些前端相关的内容。然而，在这段折腾的过程中，我逐渐意识到自己又陷入了一个老毛病——繁花迷人眼。总想着用 __INLINE_CODE_1__을 시도하기 시작했으나, 실제로는 현재 업무에 큰 도움이 되지 않고 오히려 에너지를 분산시키는 것 같습니다&lt;/p&gt;
&lt;h2 id=&#34;ai-적용-사례&#34;&gt;AI 적용 사례
&lt;/h2&gt;&lt;p&gt;소규모 프로젝트에서는 특히 독립성이 강하고 시스템과의 연계가 낮으며 비즈니스 로직이 간단한 함수를 작성할 때, AI 도구가 큰 역할을 할 수 있습니다. 이러한 작업은 일반적으로 명확한 입력과 출력을 가지며 컨텍스트 의존성이 적어 현재 AI 지원 프로그래밍의 역량 범위에 매우 적합합니다.&lt;/p&gt;
&lt;p&gt;그러나 복잡한 시스템 아키텍처나 심층적인 비즈니스 로직에 직면하면 AI의 한계가 점차 드러난다. AI는 겉으로는 합리적이지만 실제로는 프로젝트의 요구사항과 동떨어진 코드를 생성하거나, 해결하기 어려운 잠재적인 문제를 유발할 수도 있다. 이러한 상황에서는 AI를 완전한 코드 생성 도구로 의존하기보다는 보조 도구로 활용하는 것이 적절하다. 생성된 코드는 엄격하게 검토하고 테스트하여 실제 요구사항을 충족하는지 확인해야 한다.&lt;/p&gt;
&lt;h2 id=&#34;실패와-학습의-대가&#34;&gt;실패와 학습의 대가
&lt;/h2&gt;&lt;p&gt;AI를 활용하여 프론트엔드 코드를 생성하려 시도하는 과정에서 여러 어려움에 직면했습니다. 프론트엔드는 제가 익숙한 분야가 아니기 때문에 문제 해결 과정이 시간과 노력이 많이 소요됩니다. 프롬프트를 조정하여 AI가 코드를 재작성해도 초보적인 오류를 피하기 어렵습니다. 이러한 반복적인 시도는 시간을 낭비할 뿐만 아니라, 현재 제 에너지를 익숙하지 않은 분야에서 헤매는 대신 백엔드 비즈니스 로직에 집중하는 것이 더 중요함을 깨닫게 했습니다.&lt;/p&gt;
&lt;p&gt;주말에 완료한 그 프로젝트를 돌이켜보면, 백엔드 개발과 사용자 인터랙션 로직에 집중하고 콘솔을 통해 기능을 구현하는 것이 현재 가장 효율적인 선택이라는 확신이 듭니다. 더 많은 시간과 에너지가 있을 때 시스템적으로 프론트엔드 지식을 학습하는 것이 더 나은 전략일 수도 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;프론트엔드-학습-계획&#34;&gt;프론트엔드 학습 계획
&lt;/h2&gt;&lt;p&gt;프론트엔드 기술 스택이 복잡하고 다양해서 빠르게 익히는 것은 현실적이지 않습니다. 그래서 Vue.js나 React.js와 같이 하나의 프레임워크를 선택하여 핵심 개념과 사용법을 깊이 있게 학습할 계획입니다. 기초 지식을 숙지한 후에야 AI를 활용하여 프론트엔드 코드를 생성하면, 미숙함으로 인한 오류와 시간 낭비를 효과적으로 막을 수 있습니다.&lt;/p&gt;
&lt;p&gt;결국, 현재 단계에서는 백엔드 개발에 집중하며 핵심 역량을 꾸준히 강화하는 것이 중요합니다. 시기가 되면 프론트엔드와 AI의 결합을 탐색하면 더 큰 성과를 얻을 수 있을 것입니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>클로드4 출시, hugo 태그 및 하이퍼링크 번역 도우미 개발 시도</title>
        <link>https://blog.ttf248.life/ko/p/claude-4-release-and-experimentation-hugo-tags-hyperlink-translation-assistant/</link>
        <pubDate>Sat, 24 May 2025 03:05:31 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/claude-4-release-and-experimentation-hugo-tags-hyperlink-translation-assistant/</guid>
        <description>&lt;p&gt;이 사이트는 hugo 기반이지만, 글 제목을 항상 중국어로 사용했기 때문에 생성되는 기사 링크가 친절하지 않습니다. 쉽게 말해서, 공유할 때 보기 좋지 않고, 중국어 문자가 링크에서 %E4%BD%A0%E5%A5%BD 와 같은 형태로 변환되기 때문입니다. 슬러그를 설정하여 해결할 수 있지만, 매번 수동으로 설정해야 해서 번거롭습니다.&lt;/p&gt;
&lt;p&gt;그래서 오늘 클로드4를 활용해 중국어 제목을 영어 슬러그로 자동 변환하고, 기사에 하이퍼링크를 추가하는 번역 도우미를 개발해 보았습니다. 이렇게 하면 수동 설정의 번거로움을 피할 수 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;클로드4는 정말 좋네요, 문맥 이해 능력과 복잡한 작업 처리 효율이 크게 향상되었습니다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;프로젝트-주소&#34;&gt;프로젝트 주소
&lt;/h2&gt;&lt;p&gt;국내 프로젝트 주소: &lt;a class=&#34;link&#34; href=&#34;https://cnb.cool/ttf248/hugo-content-suite&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cnb.cool/ttf248/hugo-content-suite&lt;/a&gt;
해외 프로젝트 주소: &lt;a class=&#34;link&#34; href=&#34;https://github.com/ttf248/hugo-content-suite&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ttf248/hugo-content-suite&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;코드-구현&#34;&gt;코드 구현
&lt;/h2&gt;&lt;p&gt;먼저 구현 아이디어부터 설명드리자면, 모든 문서를 스캔하여 태그 정보와 문서 제목을 추출한 다음, 로컬의 대형 모델(예: gemma-3-12b-it)을 사용하여 번역합니다&lt;/p&gt;
&lt;p&gt;실제 개발에서, 이전 세대 대규모 모델과 비교하여 &lt;code&gt;Claude4&lt;/code&gt; 展现了几个显著的亮点。由于功能需求较多，&lt;code&gt;Claude4&lt;/code&gt; 自动设计了交互式菜单，全面考虑了各种使用场景。例如，在标签处理方面，&lt;strong&gt;INLINE_CODE_2&lt;/strong&gt; 不仅支持标签的统计与分析，还包括分类统计，甚至能够检测** 태그 없는 문서 &lt;strong&gt;。此外，它还提供了&lt;/strong&gt; 미리 보기 및 생성 기능&lt;/p&gt;
&lt;p&gt;어떤 로컬 모델과 연결하든, 새로운 번역 캐시를 추가하든, 아니면 광범위한 코드 리팩토링을 하든, &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 都一次性完成，几乎没有出现任何问题。尽管项目规模不大，但包含了许多小功能。以往在开发过程中，大模型经常会遗忘前面的内容，而这次的 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; 表现非常出色，**거의 문맥을 잃는 경우가 발생하지 않습니다&lt;/p&gt;
&lt;p&gt;간단히 말해서, 지능이 향상되었고, 이후 개발 작업의 주력 모델로 사용하기 위해 __INLINE_CODE_0__으로 전환할 준비를 하고 있습니다&lt;/p&gt;
&lt;h2 id=&#34;번역-캐시&#34;&gt;번역 캐시
&lt;/h2&gt;&lt;p&gt;이 점은 단독으로 볼 때, 거대 모델 호출 횟수를 줄이는 것 외에도 실제 로컬에서 12B 모델을 실행하면 효율이 괜찮고 업무를 방해하지 않지만, 매번 거대 모델을 호출해야 하면 약간 느려지는 경향이 있습니다. 또한, 기사의 연결을 고정하기 위해 전체 업데이트 작업을 수행할 때 기사 제목이 길면 가끔씩 두 번 번역된 결과가 달라져서 기사 링크가 바뀌는 경우가 있는데, 이 부분은 상당히 난감합니다.&lt;/p&gt;
&lt;h2 id=&#34;기능-개선&#34;&gt;기능 개선
&lt;/h2&gt;&lt;p&gt;전체 프로젝트를 __INLINE_CODE_0__에게 맡기고 분석 및 최적화 여지를 확인한 결과, 다음과 같은 제안을 받았습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;配置外置化 - 提高可维护性和灵活性
结构化日志 - 便于问题排查和监控
性能监控 - 了解系统运行状况
用户体验 - 进度条等视觉反馈
错误处理 - 更完善的异常处理机制
代码组织 - 更清晰的模块划分
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;코드 검토 결과, 문제 없습니다. 예를 들어 설정 파일의 경우, 기존 코드 설정을 기본 설정으로 변환하고, 설정 파일을 읽을 때 해당 파일이 없으면 자동으로 생성하여 사용자 실수로 인한 오류를 방지합니다.&lt;/p&gt;
&lt;h3 id=&#34;heading&#34;&gt;
&lt;/h3&gt;&lt;p&gt;요구 사항: 본문 번역 시 현재 번역 효율을 동적으로 계산하고, 남은 시간을 예측하여 콘솔에 관련 정보를 출력합니다. 현재 획득한 문서의 문자 수, 각 행 번역 시 현재 번역된 문자 수, 시간, 100자당 예상 번역 시간 등을 계산하며, 문서의 남은 번역 예상 시간도 함께 계산합니다.&lt;/p&gt;
&lt;p&gt;코드는 마무리했는데, 결과가 만족스럽지 않아서 AI에게 새로운 디자인 방안을 제시하도록 했어:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다양한 효율성 계산 방식 제공: 실시간 효율, 평균 효율, 슬라이딩 윈도우 효율&lt;/li&gt;
&lt;li&gt;표시 방식 개선: 진행률 표시줄, 단계별 통계, 동적 새로 고침&lt;/li&gt;
&lt;li&gt;더 유용한 지표 추가: API 호출 횟수, 성공률 등&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;코드 완성 후 새로운 깜짝 놀랄 일이 발견되었는데, 번역 효율 통계 정보가 실시간으로 화면을 채우지만 맹목적으로 아래로 스크롤되지는 않는다&lt;/p&gt;
&lt;p&gt;번역 전문을 영어로 번역 중입니다(총 7163자)
53행이 번역 필요로 감지됨
[1/53] Stage1/6 [░░░░░░░░░░░░░░░░░░░░░░░░░] 1.9% 번역 354자.
✅ 완료 (3.1초) | API 호출 #1
✅ 완료 (1.5초) | API 호출 #2
완료 (0.9초) | API 호출 #3
완료 (0.2초) | API 호출 #4
완료 (1.0초) | API 호출 #5
완료 (1.0초) | API 호출 #6
완료 (0.2초) | API 호출 #7
📊 진행률: 행 13.2% (7/53) | 문자 12.9% (925/7163) 114.6자/초 📊
⚡ 효율성: 실시간 76.4 | 평균 117.9 | 최근 109.0 | 단계별 113.6 자/초 📊
성공률: 100.0% (7/7) | 남은 항목: 46행, 7초] 9.4% 번역 110자.
예상 남은 시간: 55초 | 완료 예상: 00:10:19 8초] 11.3% 번역 114자…
처리 속도: 3211.3 행/분 | 총 소요 시간: 8초] 13.2% 번역 16 문자.
[8/53] Stage1/6 [███░░░░░░░░░░░░░░░░░░░░░░] 15.1% 번역 166자.&lt;/p&gt;
&lt;p&gt;이전에는 제어 프로그램 코드를 많이 작성해보지 않아서 어떻게 구현되었는지 궁금해서 코드 확인해 보았다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// 清屏并重新显示 (动态刷新效果)
if translationCount &amp;gt; 1 {
   fmt.Print(&amp;quot;\033[6A\033[K&amp;quot;) // 上移6行并清除
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;성능-통계-메뉴&#34;&gt;성능 통계 메뉴
&lt;/h3&gt;&lt;p&gt;새로 추가된 &lt;strong&gt;性能统计菜单&lt;/strong&gt;, 제가 직접 디자인해도 이렇게 완벽하게 만들 수 있을지 모르겠네요&lt;/p&gt;
&lt;p&gt;성능 통계:
번역 횟수: 360
⚡ 캐시 적중률: 1.4% (5/365)
평균 번역 시간: 315.927234ms
파일 작업: 73
오류 횟수: 0&lt;/p&gt;
&lt;h3 id=&#34;진행률-표시&#34;&gt;진행률 표시
&lt;/h3&gt;&lt;p&gt;새로운 &lt;strong&gt;进度条显示&lt;/strong&gt;, 상세한 진행 상황, 소요 시간, 남은 시간 예측&lt;/p&gt;
&lt;p&gt;기능 선택 (0-13): 10
번역 목표를 수집 중입니다…
📄 캐시 파일이 로드되었습니다. 번역 기록 0개 포함&lt;/p&gt;
&lt;p&gt;번역 캐시 통계:
🏷️ 총 태그 수: 229개
📝 총 기사 수: 131건
✅ 캐시됨: 0개
🔄 번역 필요: 360개&lt;/p&gt;
&lt;p&gt;전체 번역 캐시 생성 확인하시겠습니까? (y/n): y
🚀 전체 번역 캐시 생성 중…
📄 캐시 파일이 로드되었습니다. 번역 기록 0개 포함
검색 중인 번역 확인 중…
새로운 태그 360개 번역 필요
[░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 5/360 (1.4%) - 소요시간: 3초 - 예상 남은 시간: 3분 8초💾 캐시 파일 저장 완료, 번역 기록 5개 포함
[█░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 10/360 (2.8%) - 소요시간: 6초 - 예상 남은 시간: 3분 28초💾 캐시 파일 저장, 번역 기록 10개 포함
[██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 15/360 (4.2%) - 소요시간: 9초 - 예상 남은 시간: 3분 30초💾 캐시 파일 저장 완료, 번역 기록 15개 포함
[██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 20/360 (5.6%) - 소요시간: 13초 - 예상 남은 시간: 3분 36초💾 캐시 파일 저장 완료, 번역 기록 20개 포함
[███░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 25/360 (6.9%) - 소요시간: 16초 - 예상 남은 시간: 3분 33초💾 캐시 파일 저장 완료, 번역 기록 25개 포함
[████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 30/360 (8.3%) - 소요시간: 19초 - 예상 남은 시간: 3분 30초💾 캐시 파일 저장 완료, 번역 기록 30개 포함
[████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 35/360 (9.7%) - 용량: 22s - 예상 남은 시간: 3분 25초💾 캐시 파일 저장 완료, 번역 기록 35개 포함&lt;/p&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;=== Hugo 博客管理工具 ===

🚀 核心功能
  1. 一键处理全部 (完整博客处理流程)

📝 内容管理
  2. 生成标签页面
  3. 生成文章Slug
  4. 翻译文章为多语言版本

💾 缓存管理
  5. 查看缓存状态
  6. 生成全量翻译缓存
  7. 清空翻译缓存

  0. 退出程序
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Fork 저장소에 Pull Request 병합</title>
        <link>https://blog.ttf248.life/ko/p/merge-pullrequest-to-fork-repository/</link>
        <pubDate>Wed, 07 May 2025 18:44:03 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/merge-pullrequest-to-fork-repository/</guid>
        <description>&lt;p&gt;__INLINE_CODE_0__은 GitHub 프로필 통계 생성 도구로, 사용자가 자신의 GitHub 프로필에 다양한 통계 및 차트를 표시할 수 있도록 합니다. 사용자 요구사항에 맞춰 여러 가지 맞춤 설정 옵션을 제공합니다.&lt;/p&gt;
&lt;p&gt;저는 창고 관리를 프로젝트별로 그룹화하는 습관이 있는데, GitHub는 창고 그룹화를 지원하지 않으므로 여러 조직으로 분할해야 합니다. &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 최신 브랜치는 서로 다른 조직에 걸쳐 있는 창고 통계를 지원하지 못하므로, 저는 한 개의 브랜치를 포크하여 해당 코드를 병합했습니다.&lt;/p&gt;
&lt;h2 id=&#34;최종-결과&#34;&gt;최종 결과
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://github-readme-stats-chi-one-17.vercel.app/api?username=ttf248&amp;amp;hide_title=true&amp;amp;show_icons=true&amp;amp;hide=contribs&amp;amp;line_height=24&amp;amp;include_all_commits=true&amp;amp;count_private=true&amp;amp;bg_color=0000&amp;amp;text_color=8A919F&amp;amp;locale=cn&amp;amp;role=OWNER,COLLABORATOR,ORGANIZATION_MEMBER&amp;amp;timstamp=1746608356&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;GitHub Stats&#34;
	
	
&gt;
&lt;img src=&#34;https://github-readme-stats-chi-one-17.vercel.app/api/top-langs/?username=ttf248&amp;amp;hide_title=true&amp;amp;hide=html,javascript,css&amp;amp;layout=compact&amp;amp;bg_color=0000&amp;amp;text_color=8A919F&amp;amp;locale=cn&amp;amp;role=OWNER,COLLABORATOR,ORGANIZATION_MEMBER&amp;amp;timstamp=1746608356&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Top Languages&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;요청-주소-원본&#34;&gt;요청 주소 원본
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/anuraghazra/github-readme-stats/pull/2459&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Adds the ability to include data from organization repositories&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;fork-저장소에-pull-request-병합&#34;&gt;Fork 저장소에 Pull Request 병합
&lt;/h2&gt;&lt;p&gt;어떤 **Pull Request (PR)**을 당신의 &lt;strong&gt;fork 的仓库&lt;/strong&gt;에 병합하는 방법은 여러 가지가 있으며, 이는 무엇을 하고 싶으냐에 따라 달라집니다&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;上游（upstream）仓库&lt;/strong&gt; 병합 PR을 당신의 포크로 옮기는 것인가, 아니면&lt;/li&gt;
&lt;li&gt;다른 사람의 포크에서 PR을 합병하여 자신의 포크로 가져오거나,&lt;/li&gt;
&lt;li&gt;fork된 저장소에서 보낸 PR 병합 (예: 다른 사람이 당신의 fork에 PR을 제출한 경우)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;가장 흔한 시나리오 &lt;strong&gt;你 fork 了一个仓库，想把上游的某个 PR 合并到你的 fork&lt;/strong&gt;입니다. 절차는 다음과 같습니다 👇:&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;방법-1-명령줄-방식-가장-일반적&#34;&gt;방법 1: 명령줄 방식 (가장 일반적)
&lt;/h3&gt;&lt;h4 id=&#34;단계-1-자신만의-포크를-복제하세요&#34;&gt;단계 1: 자신만의 포크를 복제하세요
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/你的用户名/仓库名.git
cd 仓库名
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;단계-2-상위-저장소원래-리포지토리-주소-추가&#34;&gt;단계 2: 상위 저장소(원래 리포지토리 주소) 추가
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git remote add upstream https://github.com/原作者用户名/仓库名.git
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;단계-3-상위upstream-pr-분기-가져오기&#34;&gt;단계 3: 상위(upstream) PR 분기 가져오기
&lt;/h4&gt;&lt;p&gt;찾으려는 병합 PR 번호를 찾습니다. 예: PR #123.&lt;/p&gt;
&lt;p&gt;이 PR의 코드는 다음과 같이 가져올 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git fetch upstream pull/123/head:pr-123
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;단계-4-분기-전환-및-병합&#34;&gt;단계 4: 분기 전환 및 병합
&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git checkout main    # 或者你自己的目标分支
git merge pr-123
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;모든 것이 정상이라면, 포크한 GitHub 저장소에 푸시할 수 있습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git push origin main
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;방법-2-github-웹-인터페이스-간단하지만-기능-제한적&#34;&gt;방법 2: GitHub 웹 인터페이스 (간단하지만 기능 제한적)
&lt;/h3&gt;&lt;p&gt;GitHub 웹페이지에서 특정 PR이 상위 저장소에 대한 것이라면 다음과 같이 할 수 있습니다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;해당 PR 페이지로 이동합니다&lt;/li&gt;
&lt;li&gt;오른쪽 상단의 &amp;ldquo;&lt;strong&gt;Commits&lt;/strong&gt;&amp;rdquo; 또는 &amp;ldquo;&lt;strong&gt;Files changed&lt;/strong&gt;&amp;ldquo;을 클릭하여 이 PR이 어떤 브랜치를 기반으로 하는지 확인하세요&lt;/li&gt;
&lt;li&gt;포크 페이지에서 새 브랜치를 만들고, 수동으로 PR 커밋을 체리픽하세요 (Git 기술이 필요합니다)&lt;/li&gt;
&lt;li&gt;또는 “&lt;strong&gt;Open in GitHub Desktop&lt;/strong&gt;”을 클릭하여 GUI 도구를 사용하여 병합하세요&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;-다른-사람이-당신의-포크에-대한-pr을-제안했다면&#34;&gt;🚀 다른 사람이 당신의 포크에 대한 PR을 제안했다면
&lt;/h3&gt;&lt;p&gt;PR 페이지로 바로 들어가서 &amp;ldquo;&lt;strong&gt;Merge pull request&lt;/strong&gt;&amp;rdquo; 버튼을 클릭하면 됩니다&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;현재 구체적인 상황(예: PR 링크, 웹 페이지 또는 명령줄 사용)에 맞춰 제가 직접 시연해 드릴까요? 아니면 구체적인 링크를 주시면 가장 간단한 방법을 분석해 드리겠습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>깃 커밋 기록 수정</title>
        <link>https://blog.ttf248.life/ko/p/git-modify-commit-message/</link>
        <pubDate>Wed, 07 May 2025 18:38:31 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/git-modify-commit-message/</guid>
        <description>&lt;p&gt;스크립트는 Git 히스토리의 여러 커밋에 대한 작성자 정보를 일괄적으로 수정하며, git filter-branch를 사용하여 히스토리를 재작성합니다&lt;/p&gt;
&lt;p&gt;제공하신 스크립트는 Git 저장소의 과거 커밋 작성자 정보를 일괄적으로 수정하는 데 사용되며, 전체적인 아이디어는 옳지만 &lt;code&gt;git filter-branch&lt;/code&gt;BOLD_4&lt;code&gt;--env-filter&lt;/code&gt;BOLD_5&lt;code&gt;OLD_EMAILS=(&amp;quot;...&amp;quot;)&lt;/code&gt;BOLD_6__INLINE_CODE_3__）에서는 배열 구문을 지원하지 않습니다&lt;/p&gt;
&lt;p&gt;호환성 향상을 위해 배열을 공백으로 구분된 문자열로 바꾸고, &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 루프를 사용하여 각 기존 이메일 주소를 반복하는 것이 좋습니다. 다음은 수정된 스크립트 예제입니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh

git filter-branch --env-filter &#39;
OLD_EMAILS=&amp;quot;TianlongXiang51@gmail.com nick@qq.com tianlongxiang51@gmail.com&amp;quot;
CORRECT_NAME=&amp;quot;tianlong.xiang&amp;quot;
CORRECT_EMAIL=&amp;quot;tianlong.xiang@foxmail.com&amp;quot;

for OLD_EMAIL in $OLD_EMAILS
do
    if [ &amp;quot;$GIT_COMMITTER_EMAIL&amp;quot; = &amp;quot;$OLD_EMAIL&amp;quot; ]
    then
        export GIT_COMMITTER_NAME=&amp;quot;$CORRECT_NAME&amp;quot;
        export GIT_COMMITTER_EMAIL=&amp;quot;$CORRECT_EMAIL&amp;quot;
    fi
    if [ &amp;quot;$GIT_AUTHOR_EMAIL&amp;quot; = &amp;quot;$OLD_EMAIL&amp;quot; ]
    then
        export GIT_AUTHOR_NAME=&amp;quot;$CORRECT_NAME&amp;quot;
        export GIT_AUTHOR_EMAIL=&amp;quot;$CORRECT_EMAIL&amp;quot;
    fi
done
&#39; --tag-name-filter cat -- --branches --tags
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스크립트 실행 전, 혹시 모를 상황에 대비하여 저장소 백업을 권장합니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이 작업은 Git 기록을 덮어쓰고, 커밋 작성자 정보를 수정하여 커밋 해시 값이 변경될 수 있습니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;변경 사항을 원격 저장소에 푸시했다면 강제 푸시를 사용해야 합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git push --force --tags origin &#39;refs/heads/*&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;강제 푸시를 신중하게 사용하고, 특히 여러 사람이 협업하는 프로젝트에서는 다른 사람에게 영향을 미치지 않도록 주의하세요&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;저장소의 모든 중복되지 않는 작성자 이메일 주소를 확인합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git log --format=&#39;%an &amp;lt;%ae&amp;gt;&#39; | sort -u
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>시간 많을 때 심심해서 중국 수묵화 스타일 테마를 디자인하고 싶어</title>
        <link>https://blog.ttf248.life/ko/p/chinese-ink-style-theme/</link>
        <pubDate>Tue, 08 Apr 2025 03:42:47 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/chinese-ink-style-theme/</guid>
        <description>&lt;p&gt;다채로운 홈페이지에 질렸으니, 갑자기 미니멀 스타일로 가서 중국 수묵화 스타일 테마를 디자인하고 싶다&lt;/p&gt;
&lt;p&gt;현재 스타일 시트는 각 요소에 맞게 특정 스타일이 적용되어 주제 기본 스타일을 덮어쓰도록 수정되었습니다&lt;/p&gt;
&lt;p&gt;재구조화 없이 AI로 직접 새로운 테마를 생성하면 결과가 매우 불안정합니다&lt;/p&gt;
&lt;p&gt;우연히 또 트레이 클로드 대규모 모델 줄 서 있는 거랑 vscode 에이전트 모드로 전환했더니, 수정된 결과물이 전혀 디자인 감각이 없네&lt;/p&gt;
&lt;p&gt;결국, 제가 프론트엔드를 잘 몰라서 AI에게 효과적으로 업무를 분담할 수 없는 셈입니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>코딩 없이 맞춤 주식 모듈 설계 개발</title>
        <link>https://blog.ttf248.life/ko/p/no-code-design-develop-custom-stock-module/</link>
        <pubDate>Thu, 27 Feb 2025 23:20:39 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/no-code-design-develop-custom-stock-module/</guid>
        <description>&lt;p&gt;지난달에 커서를 시험 사용해 봤는데, 무료 한도 때문에 복잡한 기능 개발은 못 하고 간단히 테스트만 했습니다. 그때쯔음에 바이트(Byte)도 유사한 제품을 출시했고, 두 제품 모두 Claude-3.5를 기반으로 하고 있습니다.&lt;/p&gt;
&lt;p&gt;바이트의 제품인 Trae가 먼저 Mac 버전으로 출시되었고, 올해 2월에 드디어 Windows 버전이 나왔다. 대기업 제품은 역시 좋아서, 무료로 사용할 수 있고 돈을 낼 필요 없이 Claude-3.5를 무제한으로 사용할 수 있다. 이 모델 성능은 아주 괜찮다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;결국 K라인 차트 개발에 막혀서, 본인은 React를 거의 모르는 관계로 포기해야 했습니다. 계속 개발하려면 저자가 프론트엔드 기초 지식을 보충하고, “K라인 차트 개발”과 같이 큰 덩어리의 과제를 바로 주지 않고 더 세분화된 작은 단위로 나누어야 합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;발견된-문제&#34;&gt;발견된 문제
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;해외 AI 모델 사용으로 인해 Vue3 + Element-Plus의 학습 데이터가 부족하여, 프론트엔드 프레임워크로 React를 선택했습니다&lt;/li&gt;
&lt;li&gt;일부 문법 오류가 발생할 수 있으며, 사람이 직접 수정해야 합니다&lt;/li&gt;
&lt;li&gt;일부 복잡한 문제 해결에는 인공 지침이 필요합니다&lt;/li&gt;
&lt;li&gt;코드 구조 최적화는 수동 지침이 필요합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;가장 시간이 오래 걸린 부분은 프론트엔드 코드를 컨테이너에 패키징하는 것이었는데, 저의 __INLINE_CODE_0__BOLD_2&lt;code&gt;tsconfig.json&lt;/code&gt; 지식 부족으로 전혀 감이 잡히지 않았습니다. 중간에 도움을 받아야 겨우 로직을 파악할 수 있었습니다. 프론트엔드 개발의 dev 모드와 build 모드는 코드 검사에서 큰 차이가 있습니다. 백엔드 데이터베이스 및 서비스 컨테이너 스크립트는 총 5분 만에 처리했습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AI 目前更多的提高开发的效率，你有基础是最好的，并不是 AI 会帮你解决所有的问题&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;창고-주소&#34;&gt;창고 주소
&lt;/h2&gt;&lt;p&gt;제목에서 언급했듯이, 이번에는 코딩을 하지 않고 AI와 직접 대화하며 자체 선택 주식 모듈을 설계하고 개발해 봅니다. 최종 결과물이 어떻게 나올지 보겠습니다.&lt;/p&gt;
&lt;p&gt;창고 주소: &lt;a class=&#34;link&#34; href=&#34;https://github.com/ttf248/trae-demo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ttf248/trae-demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;자세한 사용 방법은 저장소의 README.md 파일을 참조하세요&lt;/p&gt;
&lt;p&gt;창고에는 많은 제출 기록이 포함되어 있는데, 대부분은 저와 트레이의 대화 기록과 제가 트레이의 몇몇 기능들을 테스트한 내용이며, 해당 기능을 구현하기 위해 수동 개입이 있었는지 여부를 메모해 두었습니다&lt;/p&gt;
&lt;h2 id=&#34;prompt&#34;&gt;Prompt
&lt;/h2&gt;&lt;p&gt;프로젝트는 처음부터 시작되었으며, 아래는 프로젝트 프롬프트입니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;基于项目原型图，开发功能：自选股，需要支持合约的新增、删除、修改、查询。自选股界面需要展示基础的行情数据。支持多个不同的市场切换。

前端：react
后端：golang gin gorm
数据库：PostgreSQL

服务端需要支持跨域请求，同时需要考虑数据的校验和错误处理，如果后端服务不可用，前端需要告警提示。

后端需要展示请求和应答的日志；前端也打印通讯的日志，方便排查问题。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ui-및-상호작용-최적화&#34;&gt;UI 및 상호작용 최적화
&lt;/h2&gt;&lt;p&gt;프론트엔드 디자인은 Grok에 완전히 의존하며, 우리는 먼저 Trae에서 제품의 초기 형태를 만들었지만 심미적인 부분은 부족했습니다. 사용한 모델은 코드 능력은 뛰어나지만 다른 기능이 상대적으로 약하기 때문에 Grok을 사용하여 프론트엔드 UI를 최적화해야 합니다.&lt;/p&gt;
&lt;p&gt;현재 인터페이스 스크린샷을 찍어 Grok에 업로드한 후, UI 최적화를 요청하면 여러 건의 제안을 받을 수 있습니다. 저희는 이를 검토하고 Trae에서 실행하여 최적화 효과를 확인합니다.&lt;/p&gt;
&lt;h3 id=&#34;기술-스택&#34;&gt;기술 스택
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;프론트엔드: React + TypeScript&lt;/li&gt;
&lt;li&gt;백엔드: Golang + Gin + GORM&lt;/li&gt;
&lt;li&gt;데이터베이스: PostgreSQL 17&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;시스템-아키텍처&#34;&gt;시스템 아키텍처
&lt;/h2&gt;&lt;h2 id=&#34;백엔드-아키텍처&#34;&gt;백엔드 아키텍처
&lt;/h2&gt;&lt;p&gt;백엔드는 Golang의 Gin 프레임워크로 구현된 RESTful API이며, 주요 모듈은 다음과 같습니다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;数据库模块&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;GORM을 ORM 프레임워크로 사용&lt;/li&gt;
&lt;li&gt;환경 변수를 통해 데이터베이스 연결을 구성할 수 있습니다&lt;/li&gt;
&lt;li&gt;자동으로 데이터베이스 테이블 마이그레이션&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;路由模块&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;RESTful API 설계&lt;/li&gt;
&lt;li&gt;통일된 오류 처리 메커니즘&lt;/li&gt;
&lt;li&gt;내장 요청 로깅&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;跨域处理&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;로컬 개발 환경 간의 교차 도메인 접근을 지원합니다&lt;/li&gt;
&lt;li&gt;구성 가능한 CORS 정책&lt;/li&gt;
&lt;li&gt;쿠키 크로스 도메인 지원&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;프론트엔드-아키텍처&#34;&gt;프론트엔드 아키텍처
&lt;/h2&gt;&lt;p&gt;리액트(React) + 타입스크립트(TypeScript)로 구축하여 다음과 같은 기능을 구현했습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;주식 목록 표시&lt;/li&gt;
&lt;li&gt;자선주 관리&lt;/li&gt;
&lt;li&gt;시장 데이터 표시&lt;/li&gt;
&lt;li&gt;오류 표시 메커니즘&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>프로토콜 버퍼 기본값 함정: 기본값이 비즈니스 로직의 숨겨진 살인자</title>
        <link>https://blog.ttf248.life/ko/p/protobuf-zero-value-traps/</link>
        <pubDate>Thu, 20 Feb 2025 15:26:51 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/protobuf-zero-value-traps/</guid>
        <description>&lt;p&gt;미국 주식 시장은 세 가지 거래 시간대로 나뉘는데, 전시장, 장중, 장후가 있습니다. 데이터 인터페이스는 가능한 한 대역폭을 절약하기 위해 최초에는 전체 데이터를 전송하고, 이후부터는 모든 필드를 증분 방식으로 푸시합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;최적의 방안을 안 쓰는 이유는 무엇인가요? 여러 프로젝트 그룹에 영향을 미치고, 일부는 이미 오래전에 배포되었기 때문입니다. 저희 쪽은 새로 연결하는 입장이므로 최대한 호환성을 고려할 수밖에 없습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;일련의-문제&#34;&gt;일련의 문제
&lt;/h2&gt;&lt;p&gt;초록만 보면 별다른 문제 없어 보이지만, 시스템 아키텍처에 문제가 유입되면서 일련의 문제가 발생했다. 막 지난 문제를 해결하려니 또 다른 문제가 생겼는데, 이 문제는 이전 문제 때문에 생긴 것이다.&lt;/p&gt;
&lt;h3 id=&#34;거래-시간-식별-불가&#34;&gt;거래 시간 식별 불가
&lt;/h3&gt;&lt;p&gt;알려진 디스크 상태는 __INLINE_CODE_0__BOLD_2&lt;code&gt;零&lt;/code&gt;이 기본값인지, 실제 비즈니스 값인지를 나타냅니다&lt;/p&gt;
&lt;p&gt;일반적인 이해로, 0을 받을 때마다 이 0이 새로운 시세 설정 값인지, 아니면 protobuf의 기본값인지 판단하기 어렵습니다&lt;/p&gt;
&lt;h3 id=&#34;선택-사항-도입&#34;&gt;선택 사항 도입
&lt;/h3&gt;&lt;p&gt;Since protobuf release 3.15, proto3 supports using the optional keyword (just as in proto2) to give a scalar field presence information&lt;/p&gt;
&lt;p&gt;조 내 통신 프로토콜은 &lt;code&gt;protobuf&lt;/code&gt;BOLD_3&lt;code&gt;optional&lt;/code&gt; 关键字。懂的都理解，由于从底层开始引入 &lt;code&gt;protobuf&lt;/code&gt;을 기반으로 하며, 프로젝트 하위 계층이 정적 라이브러리 방식으로 배포되어 전체 컴파일 링크를 업그레이드해야 하는데, 이 비용은 매우 높습니다&lt;/p&gt;
&lt;h3 id=&#34;gcc-버전-문제&#34;&gt;GCC 버전 문제
&lt;/h3&gt;&lt;p&gt;어떻게든 대안을 마련했는데, 하위에서 두 가지 다른 버전을 출시하여 최대한 &lt;code&gt;protobuf&lt;/code&gt; 新版本的编译依赖传播。但是在编译的时候，发现 &lt;code&gt;gcc&lt;/code&gt; 版本太低，不支持 &lt;code&gt;protobuf&lt;/code&gt;의 새로운 기능을 제어하려고 합니다&lt;/p&gt;
&lt;p&gt;팀 내에서 주로 사용되는 서버 유형은 CentOS 7, CentOS 8입니다. CentOS 7의 기본 버전이 7.4 이상이기 때문에 CentOS 7을 지원하지 않습니다.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=82461&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Bug 82461 - [7 Regression] Temporary required for brace-initializing (non-literal-type) member variable&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;최종적으로 관련 서비스 배포 및 컴파일 서버를 CentOS 8로 옮겨 이 문제를 해결했습니다&lt;/p&gt;
&lt;h2 id=&#34;합리적-열거&#34;&gt;합리적 열거
&lt;/h2&gt;&lt;p&gt;전체 문제를 되돌아보면, 사실 더 간단하고 효율적인 해결책이 있습니다. 열거형의 정의를 0부터 시작하는 대신 1부터 시작하도록 조정하면 기본값과 비즈니스 값을 효과적으로 구별하여 위에서 언급한 일련의 번거로움을 피할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;왜-1부터-시작하는-것이-더-합리적일까요&#34;&gt;왜 1부터 시작하는 것이 더 합리적일까요?
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 내에서, 열거형의 기본값은 항상 0으로 고정됩니다. 만약 의미 있는 비즈니스 값을 0으로 정의한다면(예: &amp;ldquo;판 중&amp;rdquo;), 증분 푸시 시 비즈니스 측에서는 수신된 0이 비즈니스 값인지 아니면 초기화되지 않은 기본값인지 판단할 수 없습니다. 하지만 열거형을 1부터 시작하여 정의하면, 0은 무의미한 기본값 또는 &amp;ldquo;알 수 없음&amp;rdquo; 상태로 유지될 수 있으며, 문제는 해결됩니다.&lt;/p&gt;
&lt;p&gt;제안된 방법:&lt;/p&gt;
&lt;p&gt;프로토콜 버퍼 열거형을 설계할 때 항상 0을 무의미한 기본값으로 정의하십시오
실제 비즈니스 값을 1부터 할당하여 기본값 0과 구분합니다&lt;/p&gt;
&lt;p&gt;이 작은 조정으로 우리는 거래 시간대 식별 문제를 해결했을 뿐만 아니라, 향후 프로토콜 설계에 귀중한 교훈을 얻었습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>백그라운드 서비스 TCP 통신 이상 점검</title>
        <link>https://blog.ttf248.life/ko/p/backend-service-tcp-communication-troubleshooting/</link>
        <pubDate>Fri, 14 Feb 2025 22:54:13 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/backend-service-tcp-communication-troubleshooting/</guid>
        <description>&lt;p&gt;비즈니스 모델: 백엔드 서비스는 TCP를 통해 그룹의 호가 게이트웨이와 연결을 맺습니다. 각 연결 시, 먼저 인증 요청을 보내고 이후 지속적으로 하트비트 패킷을 전송하여 연결 상태를 유지합니다.
그러나 어느 날, 서비스 연결 해제 경고 메시지를 받았다. 꼼꼼히 로그를 확인한 결과, 백엔드 서비스는 계속해서 하트비트를 전송하고 있었지만 상대방은 전혀 응답하지 않았음에도 불구하고 연결은 끊어지지 않았다.&lt;/p&gt;
&lt;h2 id=&#34;현장-설명&#34;&gt;현장 설명
&lt;/h2&gt;&lt;p&gt;원래 회사에서 야근하며 프로젝트 진행을 추진 중이었는데, 업무 그룹 채팅방에 갑자기 경고 메시지가 떴다. 처음에는 예전 문제라고 생각했다. 네트워크 타임아웃으로 인해 하트비트 전송이 실패해서 서비스 연결이 끊어진 것 같았다. 하지만 로그를 자세히 확인해 보니 실제 상황은 그렇지 않았다. 백엔드에서 인증 로그인 메시지를 보냈지만 응답을 받지 못했고, 동시에 하트비트는 계속 전송되었지만 상대방은 어떠한 하트비트 데이터도 반환하지 않았다. 로그를 심층적으로 분석한 결과 다음과 같은 몇 가지 주요 문제가 드러났다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;인가 메시지 응답 없음: 상대방 시스템이 재시동 중일 가능성이 높으며, 이로 인해 인가 메시지가 적시에 처리되지 못했을 수 있습니다&lt;/li&gt;
&lt;li&gt;승인되지 않은 상태에서 하트비트 데이터를 전송하는 문제는 프로그램 로직의 결함 때문입니다. 하트비트 전송 함수가 연결 상태만 확인하고, 승인 상태를 확인하지 않아 판단 로직에 오류가 있었습니다.&lt;/li&gt;
&lt;li&gt;서비스 연결 해제 실패: 서비스가 연결을 끊을 수 있다면, 재연결 메커니즘이 작동하여 인증 메시지를 다시 보낼 수 있습니다&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;현재 해결해야 할 마지막 문제, 즉 서비스 연결 해제 실패 원인을 파악하기 위해 보다 면밀한 점검이 필요합니다&lt;/p&gt;
&lt;h2 id=&#34;네트워크-데이터-패킷-분석&#34;&gt;네트워크 데이터 패킷 분석
&lt;/h2&gt;&lt;p&gt;네트워크 데이터 패킷을 획득하여 추가 분석합니다&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/backend-service-tcp-communication-troubleshooting/20250220151952.png&#34;
	width=&#34;1126&#34;
	height=&#34;202&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;tcpdump&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;557&#34;
		data-flex-basis=&#34;1337px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;데이터를 분석해 보면 심박수는 정상적으로 전송되고 있지만, 상대방 서버로부터 응답이 없고, __INLINE_CODE_0__가 주어졌기 때문에 연결이 자동으로 끊어지지 않습니다&lt;/p&gt;
&lt;h2 id=&#34;일반적인-플래그-설명&#34;&gt;일반적인 플래그 설명
&lt;/h2&gt;&lt;p&gt;TCP 프로토콜에서 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;（Push）和 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt;(ACK)는 데이터 전송과 흐름 제어를 위해 사용되는 두 개의 중요한 플래그입니다. 이들의 역할은 다음과 같습니다:&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;1-pshpush-flag&#34;&gt;&lt;strong&gt;1. PSH（Push Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;:
수신측은 버퍼 내의 데이터를 상위 애플리케이션으로 즉시 푸시하고, __BOLD_2&lt;code&gt;PSH&lt;/code&gt; 플래그가 설정된 데이터 블록을 처리하여 운영체제 버퍼에 보관하지 않고 최대한 빠르게 애플리케이션으로 전달해야 합니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;典型场景&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클라이언트가 요청을 보낼 때(예: &lt;code&gt;GET /index.html&lt;/code&gt;BOLD_3&lt;code&gt;PSH&lt;/code&gt;), 서버의 즉각적인 응답을 기대합니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;키보드 입력 시마다 __인라인_2____가 발생하여 입력 문자열이 실시간으로 전송됩니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;비디오 스트리밍, 온라인 게임 등 저지연 시나리오에서 &lt;code&gt;PSH&lt;/code&gt;을 사용하여 지연 시간을 줄일 수 있습니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 필수는 아니며, 수신자는 해당 비트(flag bit)를 무시할 수 있습니다(데이터는 정상적으로 처리해야 합니다)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;발신자가 __INLINE_CODE_0__을 설정하지 않을 경우, 수신자는 자체 버퍼링 정책에 따라 데이터를 푸시할 시점을 결정합니다&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2-ackacknowledgment-flag&#34;&gt;&lt;strong&gt;2. ACK（Acknowledgment Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;:
수신된 이전 데이터 세그먼트가 올바르게 전달되었음을 확인하는 신호이며, 다음 바이트 시퀀스 번호를 나타냅니다. 이는 TCP의 핵심적인 신뢰성 있는 전송 메커니즘입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;工作原理&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터 전송 시, 송신자는 수신자가 기대하는 (&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 值（例如 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt;)을 함께 보냅니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;수신측은 데이터를 수신한 후, &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 메시지 세그먼트를 생성하여 수신 확인된 데이터 시퀀스 번호를 알립니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;발신자는 해당 __INLINE_CODE_0__을 수신한 후에야 재전송할 것입니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;만약 발신자가 번호가 &lt;code&gt;100~199&lt;/code&gt; 的数据段，则期望接收方的 &lt;code&gt;ACK&lt;/code&gt; 应为 __INLINE_CODE_2__인 메시지를 보냈다면,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;수신자가 재전송 요청을 __INLINE_CODE_0__BOLD_2&lt;code&gt;ACK=150&lt;/code&gt;에 알리지 못함&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;3-psh-和-ack-的组合&#34;&gt;&lt;strong&gt;3. PSH 和 ACK 的组合&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;TCP 패킷에서 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 和 __INLINE_CODE_1__이 동시에 나타날 수 있으며, 다음과 같은 상황에서 흔히 볼 수 있습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;HTTP 请求响应&lt;/strong&gt;:
클라이언트가 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 请求时（含数据），会设置 __INLINE_CODE_1__BOLD_4&lt;code&gt;ACK&lt;/code&gt;(이전 응답 확인)을 보냅니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Client → Server: SYN, ACK=1 → 建立连接
Client → Server: PSH, ACK=1, 数据 → 发送请求数据
Server → Client: PSH, ACK=数据长度+1 → 返回响应
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SSH 握手后传输命令&lt;/strong&gt;:
클라이언트가 명령을 입력하면 &lt;code&gt;PSH&lt;/code&gt; 和 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; 데이터 세그먼트를 전송하여 명령이 즉시 전송되고 서버에서 처리되도록 합니다&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;4-其他标志位的关联&#34;&gt;&lt;strong&gt;4. 其他标志位的关联&lt;/strong&gt;
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;플래그&lt;/th&gt;
&lt;th&gt;이름&lt;/th&gt;
&lt;th&gt;간략 설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;동기화, 초기화 연결 (세 번의 악수)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;연결 우아하게 종료&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RST&lt;/td&gt;
&lt;td&gt;재설정&lt;/td&gt;
&lt;td&gt;강제 연결 종료 (비정상 상황)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;URG&lt;/td&gt;
&lt;td&gt;긴급&lt;/td&gt;
&lt;td&gt;긴급 포인터 표시 (거의 사용하지 않음)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h3 id=&#34;总结&#34;&gt;&lt;strong&gt;总结&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;관심사는 &lt;strong&gt;数据尽快到达应用层&lt;/strong&gt;, 지연 감소입니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ACK&lt;/strong&gt; 중점은 &lt;strong&gt;数据的可靠传输&lt;/strong&gt;, 데이터 손실이나 순서 오류 방지입니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;두 가지가 협력하여 TCP 프로토콜의 효율성과 안정성을 균형 있게 맞췄다&lt;/p&gt;</description>
        </item>
        <item>
        <title>올라마에 deepseek-R1 로컬 배포</title>
        <link>https://blog.ttf248.life/ko/p/ollama-local-deployment-deepseek-r1/</link>
        <pubDate>Fri, 07 Feb 2025 22:41:02 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/ollama-local-deployment-deepseek-r1/</guid>
        <description>&lt;p&gt;Ollama는 사용자가 로컬에서 대규모 언어 모델(LLM)을 실행하고 배포할 수 있도록 하는 오픈 소스 AI 도구입니다. 개발자가 클라우드 서비스에 의존하지 않고도 GPT와 같은 모델을 로컬 머신에서 편리하고 효율적으로 사용할 수 있도록 지원하며, 다양한 모델을 지원하고 성능 최적화에 중점을 두어 리소스가 제한적인 장치에서도 원활하게 실행될 수 있도록 합니다.&lt;/p&gt;
&lt;p&gt;올라마를 통해 사용자는 텍스트 기반 AI 애플리케이션을 활용하고, 데이터 프라이버시나 높은 API 사용 비용 걱정 없이 로컬에 배포된 모델과 상호 작용할 수 있습니다. 다양한 모델을 명령줄 인터페이스(CLI)를 통해 호출하여 자연어 처리, 질의응답 등의 작업을 수행할 수 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;올라마는 다양한 모델을 시험해 보기에 적합하지만, 윈도우 버전은 하드웨어 성능을 충분히 활용하지 못하는 듯합니다. 리눅스 버전이 더 나을 수도 있습니다. 32B 파라미터 모델을 배포했을 때 메모리나 GPU 사용량이 높지 않음에도 응답 속도가 매우 느립니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;하드웨어-개요&#34;&gt;하드웨어 개요
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;운영체제: win11&lt;/li&gt;
&lt;li&gt;CPU：i7-10700K&lt;/li&gt;
&lt;li&gt;메모리: 40GB&lt;/li&gt;
&lt;li&gt;그래픽 카드: RTX 3060 12GB&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;환경-준비&#34;&gt;환경 준비
&lt;/h2&gt;&lt;p&gt;새로운 시스템 환경 변수를 추가하여 향후 사용을 용이하게 합니다&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;set OLLAMA_MODELS=E:\ollama&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
이 변수는 Ollama 모델이 저장될 경로를 지정합니다. __INLINE_CODE_0__은 모든 로컬 모델 파일이 저장되는 폴더 경로입니다. Ollama는 이 경로를 기준으로 다운로드하거나 배포한 언어 모델을 로드하고 사용합니다. 모델 파일을 다른 위치에 저장하려면 이 경로를 변경하면 됩니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;set OLLAMA_HOST=127.0.0.1:8000&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
이 환경 변수는 Ollama 서비스의 호스트와 포트를 설정합니다&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;__INLINE_CODE_0__은 로컬 주소(localhost)이며, Ollama 서비스가 로컬 요청만 수신하도록 합니다&lt;/li&gt;
&lt;li&gt;__INLINE_CODE_0__은 지정된 포트 번호이며, Ollama 서비스가 8000번 포트에서 요청을 대기하고 처리할 것임을 나타냅니다. 필요에 따라 포트 번호를 변경할 수 있지만, 해당 포트가 다른 애플리케이션에 의해 사용되지 않는지 확인해야 합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;set OLLAMA_ORIGINS=*&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
이 환경 변수는 Ollama 서비스에 접근할 수 있는 요청의 출처를 제어합니다&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 모든 소스(모든 도메인 및 IP 주소)에서 Ollama 서비스에 접근할 수 있도록 허용합니다. 이는 일반적으로 개발 및 디버깅 환경에서 사용되며, 프로덕션 환경에서는 보안 강화를 위해 특정 도메인 또는 IP만 접근하도록 제한하는 것이 일반적입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;딥시크-r1-모델-배포&#34;&gt;딥시크-R1 모델 배포
&lt;/h2&gt;&lt;p&gt;설치는 간단하니 생략합니다&lt;/p&gt;
&lt;p&gt;설치 후 검증:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\core&amp;gt;ollama -v
ollama version is 0.5.11
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;모델 배포는 공식 모델 페이지에서 해당 매개변수의 모델을 선택하세요: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;14B 파라미터는 대화 맥락을 효과적으로 기억할 수 있지만, 더 작은 파라미터 버전은 그렇지 못합니다. 32B 파라미터 버전은 로컬 배포 시 버벅거림이 심해 더 이상 테스트하지 않았습니다.&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.ollama.com/library/deepseek-r1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.ollama.com/library/deepseek-r1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://mp.weixin.qq.com/s/SPEvYTmTBxhoEkJqm1yPmw&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mp.weixin.qq.com/s/SPEvYTmTBxhoEkJqm1yPmw&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/x18990027/article/details/145368094&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/x18990027/article/details/145368094&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>파워셸 7과 지속 가능한 설정 명령줄 예측 보기</title>
        <link>https://blog.ttf248.life/ko/p/powershell-7-persisting-settings-command-line-prediction-view/</link>
        <pubDate>Fri, 07 Feb 2025 22:19:12 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/powershell-7-persisting-settings-command-line-prediction-view/</guid>
        <description>&lt;p&gt;Linux의 zsh에 익숙해져서, 블로그를 쓰려고 했을 때 갑자기 PowerShell 7도 영구적인 설정으로 명령줄 예측 뷰를 지원하는 것을 발견해서 한번 시켜봤는데, 꽤 괜찮게 잘 된다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;어떻게든 뭔가 조작을 한 건지, 기능을 켰더니 그냥 생겼다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;오늘날 다양한 운영체제 환경에서 시스템 관리자와 개발자들은 플랫폼 간 호환성, 효율성 및 강력한 기능을 갖춘 도구를 찾아 시스템 관리 및 자동화 작업의 요구를 충족하고자 합니다. PowerShell 7은 이러한 주목을 받는 도구 중 하나로, 강력한 스크립팅 기능뿐만 아니라 Windows, Linux 및 macOS 등 다양한 운영체제에서 실행될 수 있어 사용자에게 전례 없는 편의성을 제공합니다.&lt;/p&gt;
&lt;h2 id=&#34;파워셸-7-강력한-크로스-플랫폼-도구&#34;&gt;파워셸 7: 강력한 크로스 플랫폼 도구
&lt;/h2&gt;&lt;h3 id=&#34;플랫폼-간-호환성&#34;&gt;플랫폼 간 호환성
&lt;/h3&gt;&lt;p&gt;PowerShell 7은 플랫폼 제약을 없애 Windows, Linux, macOS 환경에서 모두 동일한 PowerShell 7 도구를 사용하여 기업용 서버 관리, 시스템 운영 및 일상적인 개발 작업을 수행할 수 있습니다. 이는 업무 효율성을 크게 높이고 플랫폼 차이로 인한 학습 비용과 복잡성을 줄입니다.&lt;/p&gt;
&lt;h3 id=&#34;강력한-기능&#34;&gt;강력한 기능
&lt;/h3&gt;&lt;p&gt;스크립트 작성 능력과 객체 지향 프로그래밍, 함수, 모듈 등 고급 프로그래밍 기능을 제공합니다. PowerShell 7을 통해 사용자는 파일 시스템을 쉽게 조작하여 파일 및 폴더 생성, 삭제, 복사, 이동 등의 작업을 수행하고, 레지스트리를 액세스하고 수정하여 시스템 구성을 심층적으로 조정할 수 있습니다. 또한 프로세스와 서비스를 관리하여 시스템 실행 상태를 효과적으로 모니터링하고 제어할 수 있습니다. 게다가 PowerShell 7은 Active Directory에서 사용자 및 권한 관리를 포함하여 Windows 및 비 Windows 기술과 상호 작용하며 Azure 클라우드 플랫폼에서 리소스 할당 및 관리를 수행할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;오픈소스-생태계&#34;&gt;오픈소스 생태계
&lt;/h3&gt;&lt;p&gt;파워셸 7은 오픈 소스이므로 전 세계 개발자와 애호가들이 적극적으로 참여하여 개발 및 개선할 수 있습니다. 다양한 오픈 소스 모듈과 도구가 지속적으로 등장하며 파워셸 7의 기능과 활용 분야를 풍부하게 합니다. 사용자는 자신의 필요에 따라 오픈 소스 커뮤니티에서 적절한 모듈을 찾아 기능을 확장하거나, 코드를 기여하여 전체 커뮤니티 발전에 동참할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;호환성-및-안정성&#34;&gt;호환성 및 안정성
&lt;/h3&gt;&lt;p&gt;PowerShell 7은 이전 버전과의 호환성을 유지하면서도 많은 새로운 기능과 개선 사항을 도입했습니다. 이러한 개선 사항은 성능 향상뿐만 아니라 안정성 강화에도 기여하여 사용자가 더욱 원활하게 작업을 완료하고 소프트웨어 오류로 인한 업무 중단을 줄일 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;명령줄-예측-보기-열기&#34;&gt;명령줄 예측 보기 열기
&lt;/h2&gt;&lt;p&gt;파워셸 7의 다양한 유용한 기능 중, &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 명령은 사용자 명령줄 입력 경험을 향상시키는 실용적인 도구입니다&lt;/p&gt;
&lt;p&gt;명령어 자동 완성 기능을 켤 필요 없이도 사용할 수 있지만, 이는 줄 안에서의 자동 완성에 그칩니다. 기능을 활성화하면 예측 보기로 가능한 모든 자동 완성 옵션을 목록 형태로 표시하고, 사용자는 위아래 화살표 키를 사용하여 원하는 옵션을 선택하여 명령어 입력의 정확성과 효율성을 높일 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/powershell-7-persisting-settings-command-line-prediction-view/20250207222546.png&#34;
	width=&#34;814&#34;
	height=&#34;205&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;powershell7&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;397&#34;
		data-flex-basis=&#34;952px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;명령을-영구적으로-유지하는-방법&#34;&gt;명령을 영구적으로 유지하는 방법
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 명령이 PowerShell을 시작할 때마다 적용되도록 하려면 PowerShell 프로필 파일에 추가할 수 있습니다. PowerShell 프로필 파일은 PowerShell 시작 시 자동으로 실행되는 특수한 스크립트입니다.&lt;/p&gt;
&lt;h3 id=&#34;설정-파일-경로-확인&#34;&gt;설정 파일 경로 확인
&lt;/h3&gt;&lt;p&gt;PowerShell에서, 우리는 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 변수를 사용하여 구성 파일의 경로를 확인할 수 있습니다. 해당 경로에 파일이 없으면 사용자가 직접 생성할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo $PROFILE
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;설정-파일-열기&#34;&gt;설정 파일 열기
&lt;/h3&gt;&lt;p&gt;텍스트 편집기(예: 강력한 Notepad++ 또는 가벼운 Visual Studio Code)를 사용하여 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 변수에 저장된 설정 파일 경로에 해당하는 파일을 엽니다&lt;/p&gt;
&lt;h3 id=&#34;추가-명령&#34;&gt;추가 명령
&lt;/h3&gt;&lt;p&gt;열려 있는 설정 파일에 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 명령을 추가합니다. 명령어를 정확하게 작성하여 설정 파일이 실행될 때 제대로 적용되도록 합니다.&lt;/p&gt;
&lt;h3 id=&#34;구성-파일-저장&#34;&gt;구성 파일 저장
&lt;/h3&gt;&lt;p&gt;명령 추가가 완료되면 구성 파일을 저장하고 텍스트 편집기를 닫습니다. 이제 구성 파일에는 PowerShell 시작 시 실행할 명령이 포함되어 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;설정-확인&#34;&gt;설정 확인
&lt;/h3&gt;&lt;p&gt;현재 PowerShell 창을 닫은 후 다시 시작합니다. 새로 시작된 PowerShell에서 명령어를 입력하면, 명령줄 입력 예측 보기 스타일이 목록 보기 형태로 표시되어야 합니다. 이는 설정이 성공적으로 적용되었음을 의미합니다.&lt;/p&gt;
&lt;p&gt;위 단계를 통해 PowerShell 7의 강력한 기능과 특징을 깊이 있게 이해하고, 명령줄 입력 예측 보기 스타일 설정을 통해 작업 경험을 향상시키는 방법과 이러한 설정이 지속적으로 유지되도록 하는 방법을 익혔습니다. 이 지식이 PowerShell 7 사용 과정에서 더욱 능숙하게 시스템 관리 및 자동화 작업을 효율적으로 수행하는 데 도움이 되기를 바랍니다.&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/PowerShell/PowerShell/releases&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/PowerShell/PowerShell/releases&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.v2ex.com/t/911909&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.v2ex.com/t/911909&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>atop 도구를 이용한 Linux 시스템 지표 모니터링: 설치, 설정 및 사용법 완벽 가이드</title>
        <link>https://blog.ttf248.life/ko/p/using-atop-to-monitor-linux-system-metrics-installation-configuration-and-usage-guide/</link>
        <pubDate>Thu, 06 Feb 2025 22:48:55 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/using-atop-to-monitor-linux-system-metrics-installation-configuration-and-usage-guide/</guid>
        <description>&lt;p&gt;리눅스 시스템 운영 과정에서 시스템 자원과 프로세스 상태를 실시간으로 종합적으로 모니터링하는 것은 매우 중요합니다. atop 도구는 강력한 모니터링 도구로서, 이를 쉽게 달성하도록 돕습니다. 본 문서에서는 리눅스 인스턴스에 atop 모니터링 도구를 설치, 구성 및 사용하는 방법을 자세히 설명하겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;일반적으로-사용되는-atop-도구-소개&#34;&gt;일반적으로 사용되는 atop 도구 소개
&lt;/h2&gt;&lt;p&gt;atop은 Linux 시스템 리소스 및 프로세스를 모니터링하는 도구로, 시스템과 프로세스의 활동을 기록하고 모든 프로세스의 실행 상태를 보고합니다. 이 도구는 CPU, 메모리, 디스크, 네트워크 등 리소스 사용량 정보와 프로세스 상태 데이터를 수집하며, 로그 파일 형태로 저장할 수 있습니다. 각 프로세스별 CPU 사용률, 메모리 증가량, 디스크 사용률, 우선순위, 사용자 이름, 상태 및 종료 코드 등의 주요 정보를 얻을 수 있으며, atop 설정 파일을 통해 로그 수집 빈도, 로그 파일 저장 경로 및 로테이션 정책 등의 매개변수를 사용자 정의할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;두-번째-atop-도구-설치&#34;&gt;두 번째, atop 도구 설치
&lt;/h2&gt;&lt;p&gt;다양한 Linux 배포판에서 atop 설치 방법은 약간씩 다르므로, 여기서는 일반적인 운영체제를 기준으로 설명하겠습니다&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Alibaba Cloud Linux 3/2、CentOS 7/8、Fedora、Rocky Linux 9&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;설치 명령 실행: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;atop 서비스 시작:&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;Ubuntu / Debian&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;소프트웨어 저장소 목록 업데이트:&lt;/li&gt;
&lt;li&gt;설치 명령 실행: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;atop 서비스 시작:&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;CentOS Stream 9&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;다운로드 및 설치:&lt;/li&gt;
&lt;li&gt;atop 서비스 시작:&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;openSUSE&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;설치 명령 실행: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;atop 서비스 시작:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위에 언급된 운영체제에 사용하시는 배포판이 포함되지 않았다면, atop 공식 웹사이트에서 설치 정보를 확인하실 수 있습니다&lt;/p&gt;
&lt;h2 id=&#34;세-모니터링-주기-및-로그-보존-기간-설정&#34;&gt;세, 모니터링 주기 및 로그 보존 기간 설정
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Alibaba Cloud Linux 3/2, CentOS 7/8 및 Fedora 시스템에서 atop 설정 파일은 __；在Ubuntu、Debian和openSUSE系统中，配置文件是__INLINE_CODE_1__입니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;默认配置参数说明&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;：로그 파일 기록 옵션을 제어하며, 기본값은 비어 있습니다&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LOGINTERVAL&lt;/code&gt;：모니터링 주기, 기본 600초입니다. 과거 로그 추적 문제가 필요한 경우, 실제 요구사항에 따라 해당 주기를 조정하는 것이 좋습니다.&lt;/li&gt;
&lt;li&gt;로그 보관 기간, 기본 28일&lt;/li&gt;
&lt;li&gt;__INLINE_CODE_0__BOLD_2&lt;code&gt;/var/log/atop&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;配置步骤&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;명령 실행하여 설정 파일 열기:&lt;/li&gt;
&lt;li&gt;Alibaba Cloud Linux 3/2, CentOS 7/8, Fedora 시스템에서: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Ubuntu, Debian, openSUSE, CentOS Stream 9, Rocky Linux 9 시스템에서: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;을 눌러 편집 모드로 진입한 다음, 필요에 따라 구성 매개변수를 조정합니다. 예를 들어, 모니터링 주기를 30초로 변경하고, 로그 보존 기간을 7일로 설정하며, 로그 경로는 기본값으로 유지합니다.&lt;/li&gt;
&lt;li&gt;저장하고 편집을 종료합니다&lt;/li&gt;
&lt;li&gt;atop 서비스 재시작 시 설정이 적용됩니다&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;LOGOPTS=&amp;quot;&amp;quot;
LOGINTERVAL=30
LOGGENERATIONS=7
LOGPATH=/var/log/atop 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;네-알겠습니다-네-가지-사용-atop-도구&#34;&gt;네, 알겠습니다. 네 가지 사용 atop 도구
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;常用命令介绍&lt;/strong&gt;: 대화형 명령 모드에서 다음의 일반적인 명령어가 있습니다&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;기본 통합 출력 보기로 전환합니다&lt;/li&gt;
&lt;li&gt;프로세스 목록의 전체 명령줄 표시&lt;/li&gt;
&lt;li&gt;프로세스 메모리 사용량별 내림차순으로 필터링합니다&lt;/li&gt;
&lt;li&gt;프로세스 디스크 사용률을 기준으로 내림차순 정렬합니다&lt;/li&gt;
&lt;li&gt;프로세스 자원 종합 활용률에 따라 내림차순으로 필터링합니다&lt;/li&gt;
&lt;li&gt;프로세스 네트워크 사용률을 기준으로 내림차순 정렬합니다&lt;/li&gt;
&lt;li&gt;다음 모니터링 지점으로 이동합니다&lt;/li&gt;
&lt;li&gt;이전 모니터링 지점으로 이동합니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;：指定时间点，格式为__INLINE_CODE_1__。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;资源监控字段含义介绍&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ATOP&lt;/strong&gt;: 호스트 이름, 정보 샘플링 날짜 및 시간&lt;/li&gt;
&lt;li&gt;프로세스 전체 실행 상황, 커널 모드 및 사용자 모드 실행 시간, 프로세스 총 수, 다양한 상태의 프로세스 수 등을 포함합니다&lt;/li&gt;
&lt;li&gt;CPU 전체 사용률을 나타내며, 각 필드의 숫자 합은 &lt;strong&gt;INLIN_2&lt;/strong&gt;__(N은 CPU 코어 수)이며, 커널 모드, 사용자 모드, 인터럽트, 유휴 상태, 디스크 I/O 대기 등의 시간 비율을 포함합니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPL&lt;/strong&gt;: CPU 사용률 정보, 예를 들어 지난 1분, 5분 및 15분 동안의 실행 중인 프로세스 평균 수, 컨텍스트 스위칭 횟수, 인터럽트 발생 횟수&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MEM&lt;/strong&gt;: 메모리 사용량 정보, 물리 메모리 총량, 유휴 메모리, 페이지 캐시 메모리, 파일 캐시 메모리, 커널 점유 메모리 등을 포함합니다&lt;/li&gt;
&lt;li&gt;스왑 공간 사용량 정보, 스왑 영역 총 용량 및 남은 스왑 공간 크기 포함&lt;/li&gt;
&lt;li&gt;가상 메모리 페이지 상태, 예를 들어 스왑 인/아웃된 페이지 수&lt;/li&gt;
&lt;li&gt;디스크 사용률, 각 디스크 장치별로 표시되며 장치 식별자, 바쁨 상태 시간 비율, 읽기/쓰기 요청 횟수를 나타냅니다&lt;/li&gt;
&lt;li&gt;네트워크 상태를 보여주며, 전송 계층 TCP 및 UDP, IP 계층과 각 활성 네트워크 포트의 송수신 패킷 크기를 표시합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;查看实时系统指标&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;5초마다 시스템 지표 확인: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 시스템 지표를 현재 시간 이후 5분 내(총 30회, 간격 10초)에 확인합니다&lt;/li&gt;
&lt;li&gt;현재 시간 이후 10분 후의 시스템 지표를 확인하고(10회, 60초 간격으로), 결과를 파일에 기록합니다: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;查看历史指标日志&lt;/strong&gt;: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 디렉터리에 기본적으로 저장됩니다. 확인 시 지정된 날짜의 로그 파일이 존재해야 하며, 그렇지 않으면 오류가 발생합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;일별 히스토리 지표 로그 확인: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;어제 기록 지표 로그 확인: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;지정된 날짜의 과거 지표 로그를 확인합니다. 예: 2024년 11월 06일: &lt;code&gt;atop -r 20241106&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;지정된 날짜 및 시간 이후의 과거 지표 로그를 확인합니다. 예: 2024년 11월 6일 14:00부터 &lt;code&gt;atop -r 20241106 -b 14:00&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;지정된 날짜 및 시간 범위 내의 과거 지표 로그를 확인합니다. 예: 2024년 11월 5일 00:04 ~ 00:08: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;查看系统活动报告&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;현재 시스템의 CPU 사용률 보고서를 1분 동안(12회, 간격 5초) 확인합니다: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;해당 날짜 지정 시간대의 메모리 지표 보고서를 확인합니다. 예: 18:00~18:01&lt;/li&gt;
&lt;li&gt;지정된 날짜 및 시간 범위 내의 메모리 지표 보고서 확인 (예: 2024년 11월 5일 18:00~18:01):&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;다섯-기타-작업&#34;&gt;다섯. 기타 작업
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;配置天级别日志轮转策略&lt;/strong&gt;: 매일 atop 지표 로그 파일을 생성하려면 다음 단계를 따르세요&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;(선택 사항) 필요에 따라 모니터링 주기, 로그 보존 기간 및 로그 저장 경로를 조정합니다&lt;/li&gt;
&lt;li&gt;명령 실행하여 매일 로그 로테이션 관련 서비스 자동 시작 및 서비스 시작: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;더 복잡한 로깅 처리가 필요하다면 logrotate나 사용자 정의 스크립트를 활용하여 로그 관리를 구현할 수 있습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;加载可选的netatop内核模块&lt;/strong&gt;: 네트워크 사용률을 모니터링하려면 netatop 모듈(atop에서 기본 설치되지 않음)을 설치할 수 있습니다. Alibaba Cloud Linux 3 시스템을 예로 들면:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;커널 개발 패키지 및 컴파일에 필요한 소프트웨어 환경 설치: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;최신 버전 netatop 소스 코드를 지정된 디렉터리에 다운로드합니다&lt;/li&gt;
&lt;li&gt;소스 코드를 압축 해제하고 소스 코드 디렉토리로 들어갑니다: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;소스 코드 기반으로 모듈과 데몬을 구축 및 설치합니다&lt;/li&gt;
&lt;li&gt;netatop 서비스 시작:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;atop 도구는 기능이 강력하고 사용하기 유연하여, 적절한 설치, 구성 및 활용을 통해 Linux 시스템의 실행 상태를 더 잘 파악하고 잠재적인 문제를 조기에 발견하고 해결할 수 있습니다. 본 문서가 Linux 시스템 모니터링 역량 향상에 도움이 되기를 바랍니다.&lt;/p&gt;
&lt;h2 id=&#34;참고-링크&#34;&gt;참고 링크
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Visual Studio에서 호환되지 않는 pdb 파일을 로드합니다</title>
        <link>https://blog.ttf248.life/ko/p/visual-studio-loading-unmatched-pdb-files/</link>
        <pubDate>Thu, 23 Jan 2025 20:04:33 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/visual-studio-loading-unmatched-pdb-files/</guid>
        <description>&lt;p&gt;Windows에서 Visual Studio로 프로그램을 디버깅할 때 pdb 파일과 실행 파일이 일치하지 않으면 &amp;ldquo;기호 파일을 로드할 수 없음&amp;quot;이라는 메시지가 표시됩니다. 프로그램 충돌 후 덤프 파일이 생성되더라도 일치하지 않는 pdb 파일이면 Visual Studio가 정상적으로 충돌 현장에 진입하지 못합니다.&lt;/p&gt;
&lt;h2 id=&#34;pdb-파일이-뭐죠&#34;&gt;pdb 파일이 뭐죠?
&lt;/h2&gt;&lt;p&gt;PDB 파일은 마이크로소프트에서 제공하는 디버깅 정보 파일이며, 프로그램 디버깅에 사용됩니다. PDB 파일에는 프로그램의 심볼 테이블, 소스 코드 파일 이름, 행 번호 등의 정보가 포함되어 있습니다. 프로그램 컴파일 시 PDB 파일을 생성하여 디버깅에 활용할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;windbg-디버깅&#34;&gt;WinDbg 디버깅
&lt;/h2&gt;&lt;p&gt;WinDbg는 마이크로소프트의 디버깅 도구이며, Windows 프로그램을 디버깅하는 데 사용될 수 있습니다. WinDbg는 불일치하는 pdb 파일을 로드할 수 있지만, 수동으로 로드해야 합니다. &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 명령은 불일치하는 pdb 파일을 강제로 로드할 수 있습니다.&lt;/p&gt;
&lt;p&gt;하지만 WinDbg가 Visual Studio만큼 사용하기 편리하지 않으므로, 저희는 Visual Studio에서도 호환되지 않는 PDB 파일을 로드할 수 있기를 바랍니다&lt;/p&gt;
&lt;h2 id=&#34;비주얼-스튜디오에서-호환되지-않는-pdb-파일-로드&#34;&gt;비주얼 스튜디오에서 호환되지 않는 PDB 파일 로드
&lt;/h2&gt;&lt;p&gt;소스 코드는 보통 git으로 관리되므로, 해당 버전의 코드를 찾아 재컴파일하여 일치하는 pdb 파일을 생성할 수 있습니다. 왜 로드되지 않을까요? 주로 메타데이터 불일치가 원인입니다.&lt;/p&gt;
&lt;p&gt;작은 도구가 있어, 실행 파일 정보를 기반으로 메타데이터를 수정하여 Visual Studio가 로드할 수 있는 새로운 pdb 파일을 생성한다&lt;/p&gt;
&lt;p&gt;chkmatch 다운로드 주소: &lt;a class=&#34;link&#34; href=&#34;https://www.debuginfo.com/tools/chkmatch.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.debuginfo.com/tools/chkmatch.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;사이트 캐시 주소: &lt;a class=&#34;link&#34; href=&#34;chkmatch.zip&#34; &gt;chkmatch.zip&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ChkMatch utility can be used to check whether an executable and debug information file match. It can also be used to enforce matching between an executable and debug information file, if they are compatible.

For more information about debug information matching and related issues, see this article.

Supported debug information formats: DBG, PDB 2.0, PDB 7.0.

chkmatch [-c ExeFile DebugInfoFile ] |
         [-m ExeFile DebugInfoFile]
-c
Check matching between the executable and the debug information file.
-m
Make the executable and the debug information file match.
ExeFile
The name of the executable file.
DebugInfoFile
The name of the debug information file.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;chkmatch-사용&#34;&gt;chkmatch 사용
&lt;/h2&gt;&lt;p&gt;먼저 검사 작업을 수행하고, 불일치 원인을 분석한 후 서명 불일치를 알립니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\tianlong.xiang\Downloads\chkmatch&amp;gt;ChkMatch.exe -c &amp;quot;D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe&amp;quot; E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb
ChkMatch - version 1.0
Copyright (C) 2004 Oleg Starodumov
http://www.debuginfo.com/


Executable: D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe
Debug info file: E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb

Executable:
TimeDateStamp: c26d9be3
Debug info: 2 ( CodeView )
TimeStamp: f86b0a4f  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 122  RVA: 001cdc44  FileOffset: 001cbe44
CodeView format: RSDS
Signature: {428c9b95-39a3-4a8d-a8e5-7be453684757}  Age: 1
PdbFile: D:\stock_UAT\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\obj\Release\YinTrade.Main.pdb
Debug info: 16 ( Unknown )
TimeStamp: 00000000  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 0  RVA: 00000000  FileOffset: 00000000

Debug information file:
Format: PDB 7.00
Signature: {06fae08e-c0a2-4f3d-9c7c-dfc684445dd1}  Age: 1

Result: Unmatched (reason: Signature mismatch)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그런 다음 수정 작업을 실행하여 pdb 파일과 exe 파일을 일치시킵니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\tianlong.xiang\Downloads\chkmatch&amp;gt;ChkMatch.exe -m &amp;quot;D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe&amp;quot; E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb
ChkMatch - version 1.0
Copyright (C) 2004 Oleg Starodumov
http://www.debuginfo.com/


Executable: D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe
Debug info file: E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb

Executable:
TimeDateStamp: c26d9be3
Debug info: 2 ( CodeView )
TimeStamp: f86b0a4f  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 122  RVA: 001cdc44  FileOffset: 001cbe44
CodeView format: RSDS
Signature: {428c9b95-39a3-4a8d-a8e5-7be453684757}  Age: 1
PdbFile: D:\stock_UAT\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\obj\Release\YinTrade.Main.pdb
Debug info: 16 ( Unknown )
TimeStamp: 00000000  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 0  RVA: 00000000  FileOffset: 00000000

Debug information file:
Format: PDB 7.00
Signature: {06fae08e-c0a2-4f3d-9c7c-dfc684445dd1}  Age: 1

Writing to the debug information file...
Result: Success.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/38147487/forcing-to-load-unmatched-symbols-in-visual-studio-2015-debugger&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;forcing-to-load-unmatched-symbols-in-visual-studio-2015-debugger&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>커서 AI 프로그래밍 IDE 체험</title>
        <link>https://blog.ttf248.life/ko/p/cursor-ai-programming-ide-trial/</link>
        <pubDate>Thu, 23 Jan 2025 19:30:13 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/cursor-ai-programming-ide-trial/</guid>
        <description>&lt;p&gt;번뜩하니 또 일 년이 지났습니다. 업무적으로 가장 큰 변화는 AI의 참여도가 눈에 띄게 높아진 것인데, 이전에는 개발 언어 간 전환 시 각 언어별 다양한 API 인터페이스를 익혀야 했지만, 이제 이러한 기본 코드는 AI가 생성해 주니 개발자에게는 정말 큰 축복입니다.&lt;/p&gt;
&lt;h2 id=&#34;chatgpt&#34;&gt;ChatGPT
&lt;/h2&gt;&lt;p&gt;23년 초에 간단한 입문 소개 두 편을 다루었었는데, 눈 깜짝할 사이에 25년이 벌써 왔네요. 어떻게 말해야 할지 모르겠지만, 뚜렷한 발전은 없는 것 같아요. 여전히 자신만의 인식을 갖고 합리적으로 작업을 분할할 수 있어야 하고, 무엇보다 중요한 것은 AI가 생성한 코드에 버그가 있는지 식별하는 것입니다.&lt;/p&gt;
&lt;h2 id=&#34;github-copilot&#34;&gt;Github copilot
&lt;/h2&gt;&lt;p&gt;날짜가 언제인지 잊어버렸는데, 자료를 보니 싱가포르에 서버를 구축했고 국내에서 사용할 수 있게 되었다. 더 이상 장기간으로 VPN을 사용할 필요는 없지만, 로그인할 때는 여전히 VPN이 필요하다. 하지만 이 VPN은 로그인할 때만 사용하면 되고 그 후에는 종료할 수 있다.&lt;/p&gt;
&lt;p&gt;일상적으로 더 많이 사용하는 것은 Github Copilot 플러그인인데, 이 플러그인은 VS Code, Visual Studio에서 바로 사용할 수 있습니다. 두 프로그램 사이를 전환할 필요가 없습니다. ChatGPT에 비해 Github Copilot이 프로젝트 지원이 더 좋고, 상호작용도 더 친절하며, 일부 로컬 파일을 선택하여 &lt;strong&gt;“训练”AI&lt;/strong&gt; 투입하면 해당 프로젝트에 더 적합한 코드를 생성합니다.&lt;/p&gt;
&lt;h2 id=&#34;cursor-ai&#34;&gt;Cursor AI
&lt;/h2&gt;&lt;p&gt;최근에 새로운 AI 프로그래밍 IDE인 Cursor AI를 보았는데, 이 IDE는 Github Copilot 기반이지만 더 똑똑하고 파일을 직접 생성해 준다&lt;/p&gt;
&lt;p&gt;간단히 사용해 봤는데 괜찮은 것 같긴 하지만, 현재 프로젝트에 대한 이해는 아직 부족하고, 로컬 프로젝트 파일이 많을 때는 큰 규모의 리팩토링 및 최적화 조정에는 여전히 &lt;strong&gt;开发者拆分任务&lt;/strong&gt;가 필요하다&lt;/p&gt;
&lt;p&gt;curso 프로젝트의 엔지니어 모드로 전환하여 &amp;ldquo;새로운 개인 이력서 웹페이지 생성&amp;quot;이라는 내용을 입력하고, 다양한 스타일 전환을 지원하며, 데이터 표시를 위해 개인 정보를 채워 넣으세요&lt;/p&gt;
&lt;p&gt;몇 번이고 반복하다 보면 다음과 같은 웹페이지를 얻을 수 있습니다. 물론 이 페이지는 비교적 간단하지만, 초보자에게는 꽤 괜찮은 시작입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;현재 등록 사용자는 고급 API를 150회 무료로 체험할 수 있으며, 유료 사용자는 고급 API 사용이 5000회로 제한됩니다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43; 비트 연산 기초: 비트별 값 가져오기 및 플래그 설정</title>
        <link>https://blog.ttf248.life/ko/p/cpp-bitwise-operations-basics-flags/</link>
        <pubDate>Fri, 17 Jan 2025 02:23:56 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/cpp-bitwise-operations-basics-flags/</guid>
        <description>&lt;p&gt;실제 C++ 개발에서 비트 연산은 흔히 사용되는 기술이며, 특히 시스템 상태, 플래그 또는 제어 비트를 처리할 때 매우 효율적인 솔루션을 제공합니다. 본 글에서는 예제를 통해 비트 연산을 사용하여 특정 플래그를 가져오고 설정하는 방법을 설명하겠습니다.&lt;/p&gt;
&lt;h3 id=&#34;비트-연산-기초-개념&#34;&gt;비트 연산 기초 개념
&lt;/h3&gt;&lt;p&gt;컴퓨터에서 데이터는 2진 비트(0과 1)로 저장되며, 비트 연산은 이 2진 비트에 대한 연산입니다. C++에는 몇 가지 일반적인 비트 연산자가 있습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;按位与（&amp;amp;）&lt;/strong&gt;: 특정 비트가 1인지 확인하는 데 사용됩니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按位或（|）&lt;/strong&gt;: 특정 비트를 1로 설정합니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按位异或（^）&lt;/strong&gt;: 특정 비트를 반전시키는 데 사용됩니다&lt;/li&gt;
&lt;li&gt;모든 비트를 반전합니다&lt;/li&gt;
&lt;li&gt;모든 비트를 몇 자리 내립니다&lt;/li&gt;
&lt;li&gt;모든 비트를 몇 자리 오른쪽으로 이동합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 예제에서는 __BOLD_2&lt;code&gt;wInfo&lt;/code&gt;에 대해 일련의 비트 연산을 수행하여 다양한 플래그를 통해 서로 다른 상태를 표현해야 합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;flowchart LR
    A[原始数值: 00010000] --&amp;gt; B[左移: 00010000 &amp;lt;&amp;lt; 1]
    B --&amp;gt; C[结果: 00100000]
    C --&amp;gt; D[右移: 00100000 &amp;gt;&amp;gt; 1]
    D --&amp;gt; E[结果: 00010000]

    subgraph 左移操作
        direction LR
        A --&amp;gt; B --&amp;gt; C
    end

    subgraph 右移操作
        direction LR
        C --&amp;gt; D --&amp;gt; E
    end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;요구-분석&#34;&gt;요구 분석
&lt;/h3&gt;&lt;p&gt;주어진 설명에 따르면, 우리는 다양한 상태를 나타내는 16비트 플래그가 있습니다. 이러한 상태는 각각 다른 이진 비트로 표현되며, 각 이진 비트는 특정 의미를 가집니다. 예를 들어:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실패했나?&lt;/li&gt;
&lt;li&gt;압축 여부&lt;/li&gt;
&lt;li&gt;증분 추가 여부&lt;/li&gt;
&lt;li&gt;후속 패키지 있나요?&lt;/li&gt;
&lt;li&gt;정상 요청 또는 로그아웃&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;비트-연산-구현&#34;&gt;비트 연산 구현
&lt;/h3&gt;&lt;p&gt;이러한 플래그 비트는 비트 연산을 통해 설정하고 가져올 것입니다. 구체적으로:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;按位取值&lt;/strong&gt;: 특정 비트 값(0 또는 1)을 가져옵니다&lt;/li&gt;
&lt;li&gt;설정된 비트를 1로 설정합니다&lt;/li&gt;
&lt;li&gt;설정된 비트를 0으로 만듭니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;우리는 먼저 이러한 플래그를 저장하기 위한 __ 类型的变量 __INLINE_CODE_0__을 정의합니다. 그런 다음 비트 연산을 통해 해당 플래그를 확인하고 설정합니다.&lt;/p&gt;
&lt;h3 id=&#34;c-예제-코드&#34;&gt;C++ 예제 코드
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;bitset&amp;gt;

// 定义标志位常量
const unsigned short BIT_0_FAIL = 1 &amp;lt;&amp;lt; 0;    // bit0 是否失败
const unsigned short BIT_1_COMPRESSED = 1 &amp;lt;&amp;lt; 1; // bit1 是否压缩
const unsigned short BIT_2_INCREMENT = 1 &amp;lt;&amp;lt; 2;  // bit2 是否增量
const unsigned short BIT_3_HAS_MORE = 1 &amp;lt;&amp;lt; 3;   // bit3 是否有后续包
const unsigned short BIT_5_CANCEL = 1 &amp;lt;&amp;lt; 5;     // bit5 正常请求(0)或注销(1)

// 检查某一位是否为1
bool isBitSet(unsigned short wInfo, unsigned short bitMask) {
    return (wInfo &amp;amp; bitMask) != 0;
}

// 设置某一位为1
void setBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo |= bitMask;
}

// 清除某一位（设置为0）
void clearBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo &amp;amp;= ~bitMask;
}

int main() {
    // 假设wInfo的初始值为0
    unsigned short wInfo = 0;

    // 设置bit0（失败标志）
    setBit(wInfo, BIT_0_FAIL);
    
    // 设置bit1（压缩标志）
    setBit(wInfo, BIT_1_COMPRESSED);
    
    // 打印wInfo的二进制值
    std::cout &amp;lt;&amp;lt; &amp;quot;wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    // 检查各个标志位
    std::cout &amp;lt;&amp;lt; &amp;quot;bit0 (是否失败): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_0_FAIL) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit1 (是否压缩): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_1_COMPRESSED) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit2 (是否增量): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_2_INCREMENT) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit3 (是否有后续包): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_3_HAS_MORE) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit5 (是否注销): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_5_CANCEL) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;

    // 清除bit1（压缩标志）
    clearBit(wInfo, BIT_1_COMPRESSED);
    
    // 打印更新后的wInfo
    std::cout &amp;lt;&amp;lt; &amp;quot;Updated wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;코드 실행, 추천 친구: &lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wInfo (in binary): 0000000000000011
bit0 (是否失败): 是
bit1 (是否压缩): 是
bit2 (是否增量): 否
bit3 (是否有后续包): 否
bit5 (是否注销): 否
Updated wInfo (in binary): 0000000000000001
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;코드-설명&#34;&gt;코드 설명
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;변위 연산(시프트 연산, AND 연산, OR 연산, XOR 연산, NOT 연산 등)을 사용하면 각 플래그 비트에 고유한 이진 위치를 할당할 수 있습니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;굵게_4&lt;/strong&gt;: _이탤릭체_8 &lt;strong&gt;굵게_5&lt;/strong&gt;: _이탤릭체_9 &lt;strong&gt;굵게_6&lt;/strong&gt;: _이탤릭체_10 &lt;strong&gt;굵게_7&lt;/strong&gt;: _이탤릭체_11 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특정 비트 위치를 1로 설정합니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특정 비트 위치를 0으로 설정합니다&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;요약&#34;&gt;요약
&lt;/h3&gt;&lt;p&gt;비트 연산을 통해 여러 상태 플래그를 효율적으로 처리할 수 있습니다. 특히 임베디드 개발, 네트워크 프로토콜, 시스템 상태 관리 등 실제 개발 환경에서 유용하며, 여러 이진 상태를 표현하여 공간을 절약하고 효율성을 높이는 데 자주 사용됩니다.&lt;/p&gt;
&lt;p&gt;이 블로그 게시물이 C++에서 비트 연산을 사용하여 비트 값 가져오기 및 설정 방법을 이해하는 데 도움이 되기를 바랍니다. 이러한 기술을 숙달하면 효율적이고 유지 관리하기 쉬운 코드를 작성하는 데 매우 유용합니다!&lt;/p&gt;</description>
        </item>
        <item>
        <title>데스크탑을 2.5G 네트워크 카드로 업그레이드하여 로컬 영역 네트워크 연결 속도를 높입니다</title>
        <link>https://blog.ttf248.life/ko/p/desktop-upgrade-to-25g-network-card-accelerate-lan-interconnection/</link>
        <pubDate>Fri, 10 Jan 2025 00:37:52 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/desktop-upgrade-to-25g-network-card-accelerate-lan-interconnection/</guid>
        <description>&lt;p&gt;데스크톱 하드웨어 릴리즈 세 편 중 첫 번째에서 PCIe 어댑터에 대해 언급했는데, 구형 SSD는 어디로 갔냐고요? 당연히 버린 건 아니에요. 고장난 것도 아니고, 새 컴퓨터(&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;)에 설치해서 사용하고 있어요 (1년 전 구매).&lt;/p&gt;
&lt;p&gt;새 기기, 하드웨어 스펙은 여전히 훌륭하다. 2.5G 이중 네트워크 포트, PCIE4.0, WiFi6.&lt;/p&gt;
&lt;p&gt;최근 이사하면서 개별 공유기가 없어 모든 기기를 무선 네트워크로 연결하고 있는데, ASUS 메인보드 데스크탑 PC의 무선 성능이 좋지 않거나, 공유기의 무선 접속이나 로컬 네트워크 간 업로드 속도 문제일 수도 있습니다. 그래서 2.5G 네트워크 카드를 새로 구매해서 데스크탑에 설치했습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;至此，主板的插槽用完了：显卡、无线网卡、2.5G 网卡、固态硬盘 PCIE 转接器。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;네트워크-설명&#34;&gt;네트워크 설명
&lt;/h2&gt;&lt;p&gt;두 대의 기기는 원래 무선 네트워크 카드를 통해 인터넷에 연결되지만, 두 기기 간에는 직접 네트워크 케이블로 연결하고 양쪽 모두 2.5G 네트워크 카드입니다. 두 기기를 네트워크 케이블로 직접 연결하는 방법은 자세히 설명하지 않겠습니다. 온라인에 많은 튜토리얼이 있습니다. 방화벽을 열어두고, 원하는 한 대를 게이트웨이로 선택하십시오.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
    A[机器1&amp;lt;br&amp;gt;IP: 192.168.4.1&amp;lt;br&amp;gt;子网掩码: 255.255.255.0&amp;lt;br&amp;gt;默认网关: - &amp;lt;br&amp;gt;自动获取DNS] --&amp;gt;|网线直连（2.5G）| B[机器2&amp;lt;br&amp;gt;IP: 192.168.4.2&amp;lt;br&amp;gt;子网掩码: 255.255.255.0&amp;lt;br&amp;gt;默认网关: 192.168.4.1&amp;lt;br&amp;gt;自动获取DNS];
    A --&amp;gt;|无线网卡| Internet;
    B --&amp;gt;|无线网卡| Internet;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;두-네트워크-구간-속도-측정&#34;&gt;두 네트워크 구간 속도 측정
&lt;/h2&gt;&lt;h3 id=&#34;라우터-로컬-네트워크&#34;&gt;라우터 로컬 네트워크
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\core\Desktop\iperf-3.1.3-win32&amp;gt;iperf3.exe -c 192.168.3.237
Connecting to host 192.168.3.237, port 5201
[  4] local 192.168.3.122 port 1656 connected to 192.168.3.237 port 5201
[ ID] Interval           Transfer     Bandwidth
[  4]   0.00-1.00   sec  9.17 MBytes  76.7 Mbits/sec
[  4]   1.00-2.00   sec  9.91 MBytes  83.2 Mbits/sec
[  4]   2.00-3.00   sec  8.74 MBytes  73.3 Mbits/sec
[  4]   3.00-4.00   sec  10.2 MBytes  85.2 Mbits/sec
[  4]   4.00-5.00   sec  9.23 MBytes  77.1 Mbits/sec
[  4]   5.00-6.00   sec  8.80 MBytes  73.9 Mbits/sec
[  4]   6.00-7.01   sec  8.00 MBytes  66.8 Mbits/sec
[  4]   7.01-8.00   sec  7.69 MBytes  64.9 Mbits/sec
[  4]   8.00-9.01   sec  9.72 MBytes  81.1 Mbits/sec
[  4]   9.01-10.01  sec  7.63 MBytes  63.6 Mbits/sec
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bandwidth
[  4]   0.00-10.01  sec  89.0 MBytes  74.6 Mbits/sec                  sender
[  4]   0.00-10.01  sec  89.0 MBytes  74.6 Mbits/sec                  receiver

iperf Done.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;직결-lan&#34;&gt;직결 LAN
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\core\Desktop\iperf-3.1.3-win32&amp;gt;iperf3.exe -c 192.168.4.1
Connecting to host 192.168.4.1, port 5201
[  4] local 192.168.4.2 port 1524 connected to 192.168.4.1 port 5201
[ ID] Interval           Transfer     Bandwidth
[  4]   0.00-1.01   sec   178 MBytes  1.48 Gbits/sec
[  4]   1.01-2.00   sec   204 MBytes  1.72 Gbits/sec
[  4]   2.00-3.00   sec   214 MBytes  1.80 Gbits/sec
[  4]   3.00-4.00   sec   229 MBytes  1.92 Gbits/sec
[  4]   4.00-5.00   sec   202 MBytes  1.69 Gbits/sec
[  4]   5.00-6.00   sec   213 MBytes  1.79 Gbits/sec
[  4]   6.00-7.00   sec   230 MBytes  1.93 Gbits/sec
[  4]   7.00-8.00   sec   192 MBytes  1.61 Gbits/sec
[  4]   8.00-9.00   sec   220 MBytes  1.84 Gbits/sec
[  4]   9.00-10.00  sec   230 MBytes  1.93 Gbits/sec
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bandwidth
[  4]   0.00-10.00  sec  2.06 GBytes  1.77 Gbits/sec                  sender
[  4]   0.00-10.00  sec  2.06 GBytes  1.77 Gbits/sec                  receiver

iperf Done.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>華碩 마더보드 Z490 설치 시 디스크가 너무 많아 가끔 인식되지 않음</title>
        <link>https://blog.ttf248.life/ko/p/asus-motherboard-z490-too-many-disks-intermittent-disk-recognition/</link>
        <pubDate>Fri, 10 Jan 2025 00:08:51 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/asus-motherboard-z490-too-many-disks-intermittent-disk-recognition/</guid>
        <description>&lt;p&gt;앞선 내용에 이어, 무심하게 무선 네트워크 카드가 인식되지 않는 문제가 발생했는데, 파티션을 재건하기 전에 온라인에서 다른 해결책을 찾아봤습니다. 예를 들어 메인보드 배터리를 제거하거나 전원을 15분 동안 끊는 방법, 최신 버전의 BOIS 드라이버로 업그레이드하는 방법 등이 있었지만 모두 효과가 없었습니다.&lt;/p&gt;
&lt;p&gt;처리할 일이 더 있다고 생각하며 제한된 네트워크로 전환하고, 거실에서 인터넷 랜선을 방으로 끌어왔는데, 이 순간 또 문제가 발생했다. 유선 네트워크도 인식되지 않는다. 큰 결정을 내리고 시스템을 재설치했더니 가이드 파티션이 손상되었다. 계속해서 문제가 발생하지 않았다면 이렇게 오래까지 끙끙거리지 않았을 것이다. ASUS의 디스크 충돌은 일시적인 문제이며, 시스템 재부팅 시 불안정성을 유발한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;지난주 데스크탑에 새로운 디스크를 추가했는데, 장양(Changjiang)의 2TB M.2 SSD였고, 어제 전원을 껐을 때까지 재부팅이 되지 않았다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/asus-motherboard-z490-too-many-disks-intermittent-disk-recognition/20250110002801.png&#34;
	width=&#34;553&#34;
	height=&#34;322&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;磁盘全家福&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;171&#34;
		data-flex-basis=&#34;412px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;시스템-재설치&#34;&gt;시스템 재설치
&lt;/h2&gt;&lt;p&gt;시간을 세어보면 시스템을 다시 설치한 지 2년이나 됐고, C 드라이브는 이미 용량이 부족하다. 윈도우즈의 오래된 문제로, 각종 소프트웨어가 습관적으로 C 드라이브에 데이터를 저장한다. 그래서 시스템 재설치를 결정했다. 시스템 재설치 후 네트워크 카드 문제는 정상 작동했지만, 다음 날 일상적인 개발 환경을 복원하고 시스템 백업을 준비하던 중 새로운 문제가 발생했는데, 시스템 재부팅 후 부트 파티션이 사라졌다.&lt;/p&gt;
&lt;p&gt;이전 글의 단계를 따라 부트 파티션을 재건했지만 불안정해서, 재부팅 후에는 부트 파티션이 로드되지 않을 수도 있습니다. 케이스를 건드리는 것을 의심하기 시작했을 때 하드 드라이브 선이 느슨해진 것 같았지만 여러 번 확인해도 문제는 없었습니다.&lt;/p&gt;
&lt;h2 id=&#34;기억-회복&#34;&gt;기억 회복
&lt;/h2&gt;&lt;p&gt;몇 년 전 이 기계에 한 번 SSD를 추가한 적이 있는데, 당시에는 PCIe 어댑터(그래픽 카드 슬롯에 연결)를 사용해서 직접 메인보드에 장착하지 않았습니다. 이번에는 바로 메인보드에 설치했는데, 혹시 메인보드 문제일 수도 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/asus-motherboard-z490-too-many-disks-intermittent-disk-recognition/20250110002148.png&#34;
	width=&#34;325&#34;
	height=&#34;545&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;固态转换器&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;59&#34;
		data-flex-basis=&#34;143px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;메인보드-설명서&#34;&gt;메인보드 설명서
&lt;/h2&gt;&lt;p&gt;메인보드 설명서에 오류가 있어, 표시된 SATA 포트 위치와 실제 위치가 다릅니다. 디스크가 많아 포트에 모두 장착되어 있는데다, 기존 SSD들은 모두 SATA 방식이라 설명서에 명시된 충돌이 발생합니다. 실제로 테스트해 보니 이 충돌은 불안정하게 발생하는 것으로 보이며, 발생 시 해당 디스크를 로드하지 못하고 시스템 부팅 시 부트 로딩 실패가 발생합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/asus-motherboard-z490-too-many-disks-intermittent-disk-recognition/20250110002401.png&#34;
	width=&#34;807&#34;
	height=&#34;847&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Z490&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;95&#34;
		data-flex-basis=&#34;228px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;해결책&#34;&gt;해결책
&lt;/h2&gt;&lt;p&gt;PCIE 변환기에 SSD를 다시 장착하니, 메인보드의 SATA 포트 충돌이 사라지고 시스템이 정상적으로 부팅되었습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>ESP 파티션, GPT 파티션 테이블과 윈도우 운영체제의 협력 원리 탐구</title>
        <link>https://blog.ttf248.life/ko/p/exploring-esp-gpt-and-windows-cooperation/</link>
        <pubDate>Thu, 09 Jan 2025 23:58:20 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/exploring-esp-gpt-and-windows-cooperation/</guid>
        <description>&lt;p&gt;어제 퇴근해서 집에 도착하자마자, 늘 하던 대로 데스크탑을 켰는데 시스템은 정상적으로 시작되었지만 무선 네트워크 카드가 로드되지 않았습니다. 카드 연결이 풀렸다고 생각하고 분해 후 무선 네트워크 카드를 다시 장착했는데, 문제가 더 커져서 시스템이 아예 부팅되지 않고 부트 로더가 실패했습니다.&lt;/p&gt;
&lt;p&gt;오랜만에 데스크톱을 만지작거려보니 파티션 부팅이 좀 낯설다. DisGenius로 빈 파티션을 다시 분할하고(보통 디스크 앞부분에), ESP 파티션으로 할당(기본 300M)한 후 PE 시스템에서 부트 설정을 재건했다. 관련 자료는 인터넷에서 찾아볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/exploring-esp-gpt-and-windows-cooperation/20250110000433.png&#34;
	width=&#34;330&#34;
	height=&#34;269&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;新建ESP分区&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;122&#34;
		data-flex-basis=&#34;294px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/exploring-esp-gpt-and-windows-cooperation/20250110000509.png&#34;
	width=&#34;433&#34;
	height=&#34;355&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;可以去掉MSR分区&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;121&#34;
		data-flex-basis=&#34;292px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;컴퓨터 저장 공간의 세계에서 ESP 파티션, GPT 파티션 테이블, 그리고 Windows 운영체제는 밀접하게 연결되어 있으며, 각자 고유하고 중요한 역할을 수행하며 시스템의 안정적인 작동과 효율적인 관리를 지원합니다. 하지만 이들을 자세히 알아보기 전에, 컴퓨터 파티션 역사의 “선배”라고 할 수 있는 MBR 파티션 테이블 형식을 언급하지 않을 수 없는데, 이는 후대의 기술들과 서로 상호 반영되어 기술 진화의 맥락을 더욱 돋보이게 합니다. 오늘 우리는 이러한 요소들의 내재적 연관성과 정교함에 대해 심층적으로 분석해 보겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;일반적인-하드-디스크-파티션의-기초-mbr-파티션-테이블&#34;&gt;일반적인 하드 디스크 파티션의 “기초”, MBR 파티션 테이블
&lt;/h2&gt;&lt;p&gt;MBR은 주부트 레코드(Master Boot Record)의 약자로, 개인용 컴퓨터 초기부터 존재하며 수십 년간 하드 디스크 파티션 영역을 지배해왔습니다&lt;/p&gt;
&lt;h3 id=&#34;기본-구조&#34;&gt;기본 구조
&lt;/h3&gt;&lt;p&gt;이것은 하드 디스크의 첫 번째 섹터, 즉 0번 섹터에 위치하며 512바이트 공간을 차지합니다. 이 512바이트는 주로 세 부분으로 나뉘는데, 첫째는 컴퓨터 시작 시 운영체제의 부트 로더를 로드하는 데 책임이 있는 부트 프로그램 코드이며, 일반적으로 446바이트입니다. 둘째는 디스크 파티션 테이블로, 64바이트를 차지하며 최대 4개의 주 파티션 정보를 정의할 수 있습니다. 각 파티션 설명은 16바이트를 차지하며 파티션의 시작 헤드, 섹터, 실린더 및 파티션 유형, 크기와 같은 중요한 매개변수를 기록합니다. 마지막 2바이트는 MBR 종료 플래그 &amp;ldquo;55 AA&amp;quot;이며, 이 섹터를 유효한 MBR로 식별하는 데 사용됩니다.&lt;/p&gt;
&lt;h3 id=&#34;역사적-성과와-한계&#34;&gt;역사적 성과와 한계
&lt;/h3&gt;&lt;p&gt;초기에 MBR 파티션 테이블은 개인용 컴퓨터의 비교적 단순한 저장 요구 사항을 충분히 충족했습니다. 운영 체제가 하드 디스크 파티션을 원활하게 인식하고 데이터를 순서대로 저장하고 읽을 수 있도록 했습니다. 그러나 시대가 발전함에 따라 그 한계가 더욱 뚜렷해졌습니다. 한 가지는 64바이트의 파티션 테이블 공간으로 인해 최대 4개의 기본 파티션만 분할할 수 있다는 점이며, 더 많은 파티션을 만들려면 다소 복잡한 확장 파티션 및 논리 파티션과 같은 방법을 사용해야 하므로 디스크 관리에 불편을 초래합니다. 다른 한 가지는 최대 2TB의 하드 드라이브 용량만 지원한다는 점으로, 현재 수 TB에서 수십 TB에 달하는 대용량 하드 드라이브 앞에서 힘이 부족하며, 이는 저장 기술의 추가적인 발전을 제약하는 병목 현상이 되었습니다.&lt;/p&gt;
&lt;h2 id=&#34;두-번째-esp-파티션--시스템의-보이지-않는-부팅-키&#34;&gt;두 번째, ESP 파티션 — 시스템의 “보이지 않는 부팅 키”
&lt;/h2&gt;&lt;p&gt;ESP는 EFI System Partition의 약자로, UEFI(통합 확장 펌웨어 인터페이스) 표준을 사용하는 컴퓨터에 필수적인 특수 파티션입니다&lt;/p&gt;
&lt;h3 id=&#34;기능-특징&#34;&gt;기능 특징
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;启动引导&lt;/strong&gt;: 컴퓨터가 전원을 켜면 UEFI 펌웨어는 먼저 하드 디스크의 ESP 파티션을 찾아 Windows Boot Manager와 같은 부트 로더를 읽어 운영체제를 시작합니다. 마치 정확한 열쇠로 시스템 부팅의 문을 여는 것과 같습니다. 없으면 시스템은 부팅 시 혼란에 빠져 어디로 가야 할지 모릅니다.&lt;/li&gt;
&lt;li&gt;ESP 파티션은 시스템 부팅 과정에 필수적인 드라이버들을 저장하여 초기 부팅 단계에서 하드웨어 장치(하드 디스크 컨트롤러, 그래픽 카드 등)가 정상적으로 작동하도록 하고, 이후 운영체제의 원활한 전환을 위한 기반을 마련합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;공간-요구사항-및-형식&#34;&gt;공간 요구사항 및 형식
&lt;/h3&gt;&lt;p&gt;일반적으로 ESP 파티션의 권장 크기는 100MB ~ 500MB 사이이며, 보통 200MB 정도 할당하면 기본적인 요구사항을 충족할 수 있습니다. 파일 시스템 형식은 반드시 FAT32여야 합니다. 이는 UEFI 펌웨어에서 부팅 파일을 읽기 위해 FAT32 형식을 인식하기 때문이며, 호환성과 플랫폼 간 상호 운용성을 보장합니다.&lt;/p&gt;
&lt;h2 id=&#34;세-번째-gpt-파티션-테이블--하드-디스크의-스마트-관리자&#34;&gt;세 번째, GPT 파티션 테이블 — 하드 디스크의 “스마트 관리자”
&lt;/h2&gt;&lt;p&gt;GPT(Global Unique Identifier Partition Table)는 기존 MBR 파티션 테이블을 대체하는 새로운 파티션 방식입니다&lt;/p&gt;
&lt;h3 id=&#34;장점-부각&#34;&gt;장점 부각
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;大容量支持&lt;/strong&gt;: 현재 데이터 폭발의 시대에 고용량 하드 디스크가 끊임없이 등장하고 있습니다. GPT 파티션 테이블은 MBR의 2TB 용량 제한을 돌파하여 이론적으로 최대 9.4ZB(제타바이트, 1ZB = 1024 EB, 1EB = 1024 PB, 1PB = 1024 TB)의 초대형 저장 공간을 지원하며, 막대한 양의 데이터를 저장할 수 있는 가능성을 열었습니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分区数量多&lt;/strong&gt;: MBR과 달리 최대 4개의 주 파티션만 분할할 수 있는 GPT는 사용자와 시스템 관리자에게 훨씬 더 큰 유연성을 제공하여 여러 시스템 파티션, 데이터 파티션을 나누거나 특정 용도로 공간을 예약하는 데 매우 효과적입니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可靠性高&lt;/strong&gt;: GPT 파티션 테이블은 중복 백업 메커니즘을 사용하여 하드 디스크 헤드와 테일 각각에 파티션 테이블 정보를 저장합니다. 한 곳의 파티션 테이블이 손상되면 시스템은 자동으로 다른 백업에서 복구하여 파티션 테이블 오류로 인한 데이터 손실 위험을 크게 줄이고 데이터 보안을 보장합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;구조-분석&#34;&gt;구조 분석
&lt;/h3&gt;&lt;p&gt;GPT 파티션 테이블은 보호 MBR(전통 BIOS와의 호환성을 위해 보존된 MBR 구조의 일부이지만 실제 파티션 관리에 사용되지는 않음), GPT 헤더(파티션 테이블 버전, 파티션 수, 파티션 테이블 크기 등 GPT 파티션 테이블의 기본 정보를 저장), 그리고 파티션 항목 배열(각 파티션 항목은 파티션의 시작 섹터, 종료 섹터, 파티션 유형 GUID, 파티션 고유 식별자 등의 주요 정보를 상세히 기록)로 구성되어 있습니다. 이러한 구조들은 서로 협력하여 하드 디스크 공간을 정확하게 계획하고 관리합니다.&lt;/p&gt;
&lt;h2 id=&#34;네-알겠습니다-windows-운영체제--사용자의-디지털-소통-공간&#34;&gt;네, 알겠습니다. Windows 운영체제 — 사용자의 “디지털 소통 공간”
&lt;/h2&gt;&lt;p&gt;윈도우는 전 세계적으로 널리 사용되는 운영체제로, 사용자(사람)와 컴퓨터 하드웨어 간의 친근한 연결고리를 형성합니다&lt;/p&gt;
&lt;h3 id=&#34;esp-파티션-및-gpt-파티션-테이블-통합&#34;&gt;ESP 파티션 및 GPT 파티션 테이블 통합
&lt;/h3&gt;&lt;p&gt;UEFI 기반 Windows 시스템 설치 과정에서, 설치 프로그램은 자동으로 ESP 파티션을 생성하고 부트 파일을 배포합니다. 동시에 디스크는 GPT 파티션 테이블 형식으로 초기화되며, 시스템 예약 파티션(시스템 핵심 파일 저장 공간, 기존 BIOS의 시스템 부팅 파일 영역과 유사), Windows 시스템 파티션(시스템 핵심 파일이 설치되는 곳) 및 기타 사용자 정의 데이터 파티션 등이 구성됩니다. Windows 시스템은 GPT 파티션 테이블을 통해 각 파티션을 정확하게 식별하고 ESP 파티션을 통해 원활하게 부팅되며, 이 세 가지 요소는 매끄럽게 연결되어 사용자에게 쾌적한 부팅 및 사용 경험을 제공합니다.&lt;/p&gt;
&lt;h3 id=&#34;시스템-관리-및-최적화-기반&#34;&gt;시스템 관리 및 최적화 기반
&lt;/h3&gt;&lt;p&gt;Windows는 실행 중 GPT 파티션 테이블의 장점을 활용하여 디스크 관리를 수행합니다. 예를 들어, 디스크 관리 도구에서 GPT 파티션을 쉽게 식별하고 사용자는 파티션 생성, 삭제, 포맷, 크기 조정 등 다양한 단계의 데이터 저장 요구 사항을 충족할 수 있습니다. 또한 시스템 업데이트 및 소프트웨어 설치와 같은 프로세스도 파티션 레이아웃과 밀접하게 관련되어 있으며, 합리적인 파티션 계획은 시스템 성능 및 안정성을 향상시키고 디스크 공간 부족 또는 파티션 혼란으로 인한 문제를 줄이는 데 도움이 됩니다.&lt;/p&gt;
&lt;h2 id=&#34;다섯째-실전-팁-유지보수-및-문제-해결&#34;&gt;다섯째, 실전 팁: 유지보수 및 문제 해결
&lt;/h2&gt;&lt;p&gt;이들의 밀접한 관계를 파악하면 일상 유지 보수 및 문제 해결에 대한 절차가 갖춰진다&lt;/p&gt;
&lt;h3 id=&#34;디스크-공간-관리&#34;&gt;디스크 공간 관리
&lt;/h3&gt;&lt;p&gt;ESP 파티션 공간을 정기적으로 확인하여 과도한 부팅 항목 관련 소프트웨어 설치로 인한 공간 부족 문제를 예방하고, 시스템 시작에 영향을 미치지 않도록 합니다. GPT 파티션 내 데이터 파티션의 경우, 합리적인 저장 공간 계획을 세우고 불필요한 파일을 즉시 정리하여 단일 파티션이 가득 차서 시스템 운영에 영향을 미치는 것을 방지합니다.&lt;/p&gt;
&lt;h3 id=&#34;문제-해결-시작&#34;&gt;문제 해결 시작
&lt;/h3&gt;&lt;p&gt;시스템 부팅 실패 시, 먼저 ESP 파티션 손상 또는 파일 누락 여부를 확인하십시오. UEFI 펌웨어 내장 복구 도구나 Windows 설치 미디어를 이용한 복구 환경에서 ESP 파티션의 부트 파일을 재구성할 수 있습니다. GPT 파티션 테이블 오류가 의심되는 경우, 전문 디스크 도구(DiskGenius 등)를 사용하여 파티션 테이블 무결성을 확인하고 백업된 파티션 정보를 활용하여 분실된 파티션을 복구하십시오.&lt;/p&gt;
&lt;p&gt;ESP 파티션, GPT 파티션 테이블, 그리고 Windows 운영체제는 마치 정밀하게 협력하는 팀처럼 각자의 전문성을 발휘하여 안정적이고 효율적인 컴퓨터 사용 환경을 구축합니다. 이들을 깊이 이해하면 시스템 설치 및 유지 보수 시 능숙하게 대처할 수 있을 뿐만 아니라, 컴퓨터의 근본적인 작동 원리를 파악하고 디지털 세계를 자유롭게 탐험할 수 있습니다. 동시에 MBR 파티션 테이블의 흥망성쇠를 되돌아보면 기술 발전의 힘에 감탄하며, 저장 기술이 끊임없이 진보하여 증가하는 데이터 저장 요구에 부응해 온 역사를 깨닫게 됩니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>GCC, GLIBC 및 C&#43;&#43; 프로그램 호환성 문제 심층 이해</title>
        <link>https://blog.ttf248.life/ko/p/deep-understanding-gcc-glibc-cpp-compatibility-issues/</link>
        <pubDate>Mon, 06 Jan 2025 19:51:16 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/deep-understanding-gcc-glibc-cpp-compatibility-issues/</guid>
        <description>&lt;p&gt;C++ 개발 분야에서 GCC와 GLIBC는 피할 수 없는 핵심 요소이며, 프로그램 출시 후 호환성 문제는 개발자를 자주 괴롭힌다. 본 논문에서는 이들의 본질을 심층적으로 분석하고, 호환성 문제의 근원과 대응 전략을 탐구한다.&lt;/p&gt;
&lt;h2 id=&#34;일-gcc-강력한-컴파일러-기반&#34;&gt;일. GCC: 강력한 컴파일러 기반
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;定义与功能&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;GCC는 GNU 컴파일러 컬렉션으로, GNU 프로젝트에서 개발한 오픈 소스 컴파일러 모음입니다. 이는 단순한 컴파일러가 아닌, C, C++, Objective-C, Fortran, Ada, Go 등 다양한 주요 프로그래밍 언어를 지원하며, 여러 언어 간의 통합 개발을 위한 원스톱 솔루션을 제공합니다.&lt;/li&gt;
&lt;li&gt;C++를 예로 들면, GCC는 클래스, 템플릿, 함수 오버로딩과 같은 복잡한 특징을 포함하는 소스 파일을 C++의 엄격한 문법 및 의미 규칙에 따라 분석하여 하위 레벨 기계가 이해하고 실행할 수 있는 명령어 시퀀스로 변환합니다. 이 과정은 어휘 분석, 구문 분석, 의미 분석, 최적화 및 코드 생성과 같은 여러 정교한 단계를 거칩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;编译流程详解&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;GCC는 먼저 소스 파일을 전처리합니다. 이 과정에서 모든 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;, &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt;, &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt;, &lt;strong&gt;INLINE_CODE_3&lt;/strong&gt;, &lt;strong&gt;INLINE_CODE_4&lt;/strong&gt;, &lt;code&gt;PI&lt;/code&gt;, __INLINE_CODE_6__을 처리하고, 전처리 후 소스 파일은 초기 “확장”됩니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编译阶段&lt;/strong&gt;: 전처리된 파일은 컴파일 단계에 진입하며, GCC는 C++ 언어 표준에 따라 소스 파일을 어셈블리 언어 코드로 변환합니다. 클래스 상속, 다형성 구현의 정확성, 함수 호출 인자 일치 여부 등 코드 구조를 꼼꼼히 검사하고, 문법 및 의미 규칙에 위배되는 오류가 발견되면 즉시 에러를 발생시켜 컴파일을 중단합니다. 예를 들어, 함수 선언과 정의의 인자 목록이 불일치하는 경우, GCC는 문제 지점을 정확하게 지적합니다.&lt;/li&gt;
&lt;li&gt;어셈블러는 이전 단계에서 생성된 어셈블리 코드를 기계어로 변환하여 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 확장자를 가진 목적 파일을 생성합니다. 이러한 목적 파일에는 기계가 직접 실행할 수 있는 이진 명령어가 포함되지만, 일반적으로 완전한 프로그램은 여러 모듈로 구성되어 있으며 각 모듈 간의 함수 및 변수 참조 관계는 아직 해결되지 않았기 때문에 독립적으로 실행될 수 없습니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链接阶段&lt;/strong&gt;: 실행 파일 생성의 마지막 단계입니다. 링커는 여러 오브젝트 파일과 필요한 라이브러리 파일(정적 또는 동적 라이브러리)을 통합합니다. 예를 들어, C++ 표준 템플릿 라이브러리의 컨테이너 클래스를 사용할 때 링크 시 해당 라이브러리 구현 코드를 찾아 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;、&lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; 등 컨테이너 기능을 올바르게 호출할 수 있도록 보장하여 완전한 실행 파일을 생성합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;두-번째-glibc-c-프로그램-실행의-숨은-기반&#34;&gt;두 번째, GLIBC: C++ 프로그램 실행의 숨은 기반
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;本质与作用&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;GLIBC는 GNU C Library로, GNU 생태계에서 C 표준 라이브러리를 구체적으로 구현한 것입니다. 이름에 C가 강조되어 있지만, C++ 프로그램 역시 C의 기본 부분을 상속받기 때문에 GLIBC에 크게 의존합니다. 메모리 관리와 같은 방대한 기초 함수들을 제공하며, C++ 초기 개발 및 성능이 중요하고 간결함을 추구하는 환경에서 자주 사용됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;与操作系统的协同&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;GLIBC는 운영체제와 응용 프로그램 간의 핵심적인 연결고리 역할을 합니다. C++ 프로그램이 파일을 열기 위해 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 함수를 사용하는 등 시스템 호출을 시작하면 GLIBC는 이 요청을 운영체제가 규정한 방식으로 캡슐화하여 커널에 전달하고, 커널 처리 후 결과를 응용 프로그램으로 반환합니다. 이를 통해 응용 프로그램은 파일 시스템, 네트워크, 프로세스 관리와 같은 다양한 시스템 리소스를 복잡한 시스템 호출 인터페이스 세부 사항을 몰라도 편리하게 사용할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;세-번째-c-프로그램-배포-후-호환성-문제-분석&#34;&gt;세 번째, C++ 프로그램 배포 후 호환성 문제 분석
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;GLIBC 版本差异引发的兼容困境&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;다양한 Linux 배포판은 종종 서로 다른 버전의 GLIBC를 탑재합니다. C++ 프로그램이 높은 버전의 GLIBC 환경에서 컴파일되면 새로운 기능이나 최적화된 함수 구현에 의존하게 될 수 있습니다. 예를 들어, 새로운 GLIBC 버전의 메모리 할당 알고리즘 개선을 활용하여 성능을 향상시키는 경우가 있습니다. 이러한 프로그램이 낮은 버전의 GLIBC 시스템으로 이식될 경우 해당 기능을 찾을 수 없거나(낮은 버전에서 도입되지 않았기 때문입니다) 함수 동작에 이상이 발생할 수 있으며(구현 로직이 새 버전과 차이가 있기 때문입니다), 이는 프로그램 충돌이나 오류를 유발할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;编译器差异导致的兼容性隐患&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;비록 모두 GCC 컴파일러를 사용하더라도, 서로 다른 버전의 GCC는 코드 생성, 표준 라이브러리 지원 및 C++ 기능 구현 방식에 차이가 있습니다. 최신 GCC 버전은 C++20과 같은 최신 표준의 새로운 기능(예: 모듈, 코루틴 등)을 완벽하게 지원할 수 있지만, 이러한 최첨단 기능을 사용하는 프로그램이 구버전 GCC에서 컴파일하면 컴파일러가 새로운 문법 구조를 인식하지 못해 오류가 발생합니다. 심지어 문법 오류가 없더라도, 각 GCC 버전별 최적화 전략이 다르기 때문에 생성되는 기계 코드의 실행 효율성 및 메모리 사용량에 큰 차이가 있을 수 있으며, 성능이 중요한 환경에서는 프로그램의 동작 양상이 크게 달라질 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;系统架构差异带来的挑战&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;C++ 프로그램은 x86, ARM, PowerPC 등 다양한 하드웨어 시스템 아키텍처에서 실행될 수 있습니다. 각 아키텍처는 고유한 명령어 집합, 메모리 레이아웃 및 데이터 정렬 요구 사항을 가지고 있습니다. 예를 들어 데이터 정렬의 경우, x86 아키텍처에서 정상적으로 작동하는 구조체 데이터 저장 방식이 ARM 아키텍처에서는 정렬 규칙이 다르기 때문에 메모리 접근 이상을 일으켜 프로그램 오류를 유발할 수 있습니다. 또한 GCC는 서로 다른 아키텍처로 컴파일될 때 생성되는 기계 코드의 차이가 매우 크며, 프로그램에 하드 코딩된 아키텍처 관련 명령어 또는 가정이 있는 경우, 여러 아키텍처에서 실행 시 빈번한 장애가 발생합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;네-가지-호환성-문제-대응-전략&#34;&gt;네 가지, 호환성 문제 대응 전략
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;静态链接库的运用&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;정적 링크 라이브러리 사용을 고려해 볼 수 있습니다. 프로그램이 필요로 하는 GLIBC와 같은 라이브러리 코드를 실행 파일에 직접 패키징하는 방식입니다. 이렇게 하면 프로그램 실행 시 대상 시스템의 특정 GLIBC 버전에 의존하지 않으므로, GLIBC 버전 불일치로 인한 문제를 효과적으로 피할 수 있습니다. 하지만 정적 링크는 실행 파일 크기를 크게 증가시키므로 저장 공간이 제한적인 환경에서는 장단점을 신중하게 고려해야 합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;容器化部署&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Docker와 같은 컨테이너화 기술을 활용하여 C++ 프로그램과 필요한 런타임 환경(특정 버전의 GCC, GLIBC 등)을 독립적인 컨테이너 내에 패키징합니다. 컨테이너 내부에서는 개발 환경과의 일관성을 유지하므로 어떤 기본 운영체제로 배포하든 프로그램이 예상대로 실행되며, 이로써 다양한 환경으로의 배포 복잡성이 크게 줄어듭니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;兼容性测试与持续集成&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;다양한 GLIBC 버전, GCC 버전 및 일반적인 시스템 아키텍처를 포괄하는 종합적인 호환성 테스트 체계를 구축한다. 프로그램 개발 과정에서 지속적 통합 도구를 활용하여 다양한 환경에서 정기적으로 자동화된 테스트를 실시하고, 호환성 문제가 발견되면 즉시 수정하여 잠재적인 위험을 초기 단계에서 제거함으로써 프로그램 출시 후 안정성을 확보한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;결론적으로, GCC와 GLIBC의 작동 방식을 깊이 이해하고, C++ 프로그램 호환성 문제의 근원을 정확히 파악하며, 유연하게 대응 전략을 활용하는 것은 모든 C++ 개발자가 안정적이고 플랫폼 간 애플리케이션을 구축하기 위한 필수적인 기술입니다. 그래야만 우리의 C++ 작품은 다양한 기술 생태계에서 자유롭게 이동할 수 있습니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>Windows에 내장된 디스크 정리 도구: 저장 공간</title>
        <link>https://blog.ttf248.life/ko/p/windows-disk-cleanup-storage/</link>
        <pubDate>Mon, 06 Jan 2025 19:29:45 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/windows-disk-cleanup-storage/</guid>
        <description>&lt;p&gt;어떤 버전부터인지는 정확히 기억나지 않지만, __INLINE_CODE_0__에서 디스크 정리 도구가 크게 개선되어 훨씬 더 스마트해졌습니다&lt;/p&gt;
&lt;p&gt;중요한 것은 공식 도구이기 때문에 파일 삭제 오류가 없고, 광고나 팝업창, 백그라운드 프로세스 등 불필요한 기능이 전혀 없습니다&lt;/p&gt;
&lt;p&gt;디스크 정리 도구를 열려면 &lt;code&gt;Windows 11&lt;/code&gt;中，可以通过__INLINE_CODE_1__-&lt;code&gt;系统&lt;/code&gt;-&lt;strong&gt;INLINE_CODE_3&lt;/strong&gt;-__INLINE_CODE_4__에서 실행하세요&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/windows-disk-cleanup-storage/20250106194453.png&#34;
	width=&#34;1041&#34;
	height=&#34;775&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;存储界面&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;134&#34;
		data-flex-basis=&#34;322px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;일반 사용자는 __INLINE_CODE_0__을 선택하면 되며, 시스템은 사용 상황에 따라 몇 가지 제안을 제공합니다&lt;/p&gt;
&lt;p&gt;개발자로서 저의 디스크에는 임시 파일이 많기 때문에 &lt;code&gt;临时文件&lt;/code&gt;，里面包含了很多临时文件，比如__INLINE_CODE_1__的临时文件，&lt;strong&gt;INLINE_CODE_2&lt;/strong&gt; 임시 파일을 선택했습니다&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/windows-disk-cleanup-storage/Snipaste_2024-12-19_13-39-51.png&#34;
	width=&#34;465&#34;
	height=&#34;980&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;临时文件&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;47&#34;
		data-flex-basis=&#34;113px&#34;
	
&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>도커 국내 이미지 프록시 만료</title>
        <link>https://blog.ttf248.life/ko/p/docker-domestic-mirror-failure/</link>
        <pubDate>Sat, 04 Jan 2025 18:29:25 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/docker-domestic-mirror-failure/</guid>
        <description>&lt;p&gt;국내 서버에 도커를 배포했는데, 회사에서 이미지 센터를 제공하지 않으므로 개발자는 먼저 국내 이미지 가속 주소를 설정해야 합니다. 오늘 우연히 서버 한 대가 있고 이미지 가속 주소를 설정했지만 이미지를 가져오려고 하면 계속 실패합니다.&lt;/p&gt;
&lt;p&gt;오류 정보: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;20250106 时隔两天，所有的服务器都恢复了，这事居然不上热搜，国内所有的镜像代理都挂了&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;오류-해결-및-복구-시도&#34;&gt;오류 해결 및 복구 시도
&lt;/h2&gt;&lt;p&gt;처음 다른 미러 주소로 전환해 문제를 해결하려 했지만, 기대와 달리 문제는 여전히 발생했습니다&lt;/p&gt;
&lt;p&gt;곧바로 로컬 DNS 설정을 수정하여 네트워크 해상도 수준에서 돌파구를 찾으려 했으나, 여러 차례 디버깅했음에도 불구하고 문제는 여전히 발생했다&lt;/p&gt;
&lt;p&gt;현재 로컬 네트워크 안정성에 의문이 제기되자, 즉시 휴대폰 핫스팟으로 전환하여 가능한 로컬 네트워크 오류를 우회하려 했으나, 결과는 낙담스러웠고 문제 해결의 여지는 보이지 않았다&lt;/p&gt;
&lt;h2 id=&#34;문제-확산&#34;&gt;문제 확산
&lt;/h2&gt;&lt;p&gt;현재 &lt;strong&gt;几台部署于国内的服务器&lt;/strong&gt;이 남아 있으며, 모두 Docker 환경이 설치되어 있습니다. 이러한 서버에서 이미지를 가져오려고 시도했지만, 예상치 못한 문제로 인해 단 한 대의 장비에서도 성공적으로 가져올 수 없었습니다. 오류 메시지는 동일했으며, 이는 문제가 특정 장비에 국한된 것이 아님을 나타냅니다.&lt;/p&gt;
&lt;p&gt;더 자세히 조사해 보니 미러 에이전트가 갑자기 작동하지 않았습니다. 다행히 긴박한 순간에 해외 머신으로 빠르게 전환하여 시도했고, 미러 이미지를 가져오는 데 문제가 해결되어 정상적으로 복구되었습니다. 이는 문제의 원인이 국내 네트워크 링크나 관련 설정에 있을 가능성이 높다는 것을 의미합니다.&lt;/p&gt;
&lt;h2 id=&#34;전략-조정-우회-해결&#34;&gt;전략 조정: 우회 해결
&lt;/h2&gt;&lt;p&gt;국내 직접 이미지 가져오기가 여러 제약으로 인해 어려워지고 해외 이미지는 정상적으로 접근 가능한 상황이므로, 프로젝트를 신속히 진행하기 위해 우회 전략을 채택합니다. 먼저 해외 서버로 전환하여 필요한 이미지를 가져온 후 국내 이미지 저장소에 푸시하여 “데이터 브릿지”를 구축할 예정입니다.&lt;/p&gt;
&lt;p&gt;동시에 Dockerfile 파일을 수정하여 이미지 주소를 국내 환경에 적합한 주소로 변경하고, 다시 이미지를 빌드하여 최종적으로 성공적으로 배포했습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>CentOS 8 Stream EOL</title>
        <link>https://blog.ttf248.life/ko/p/centos-8-stream-eol/</link>
        <pubDate>Sat, 16 Nov 2024 23:24:50 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/centos-8-stream-eol/</guid>
        <description>&lt;p&gt;출시 전 상류 오픈소스 개발 플랫폼
오픈소스 운영체제 수명 주기 최초로 주목&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;만료되었는데, 문제가 있나요? 보안 문제 외에 dnf를 사용할 수 없게 되었고, 최근 도구를 설치할 때 dnf가 실패했는데, 확인해 보니 이미지 소스가 만료되었습니다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;centos-스트림-소개&#34;&gt;CentOS 스트림 소개
&lt;/h2&gt;&lt;h3 id=&#34;위치와-역할&#34;&gt;위치와 역할
&lt;/h3&gt;&lt;p&gt;CentOS Stream은 Fedora Linux(상위 개발)과 RHEL(Red Hat Enterprise Linux, 하위 개발) 사이에 위치하여 다리 역할을 합니다&lt;/p&gt;
&lt;p&gt;최신 Red Hat Linux 기능을 경험해 볼 수 있는 버전이며, 얼리 액세스 사용자에게 적합합니다&lt;/p&gt;
&lt;h3 id=&#34;탄생과-배경&#34;&gt;탄생과 배경
&lt;/h3&gt;&lt;p&gt;시간이 지나면서, Red Hat 사는 기업용 Linux 플랫폼을 더욱 효과적으로 발전시키기 위해 CentOS Stream 을 출시했습니다&lt;/p&gt;
&lt;p&gt;CentOS 8은 2021년 말 지원 종료 후, CentOS Stream이 그 뒤를 이어 업데이트되고 있으며, CentOS 프로젝트의 미래 발전 방향이 되고 있습니다&lt;/p&gt;
&lt;h3 id=&#34;특징-및-장점&#34;&gt;특징 및 장점
&lt;/h3&gt;&lt;p&gt;CentOS Stream은 더 빠른 업데이트를 제공하는 롤링 릴리스 Linux 배포판입니다. 커뮤니티, 파트너 및 고객의 참여를 위한 투명성과 기회를 높여 사용자에게 Red Hat Enterprise Linux에 더욱 빠르고 직접적으로 기여할 수 있도록 합니다.&lt;/p&gt;
&lt;p&gt;CentOS Stream의 내용은 Red Hat이 다음 안정 버전 RHEL에 포함할 소프트웨어이며, 따라서 커뮤니티 구성원에게 개발 및 테스트를 위한 안정적인 ABI/API를 제공합니다&lt;/p&gt;
&lt;h3 id=&#34;사용-시나리오-및-대상-사용자&#34;&gt;사용 시나리오 및 대상 사용자
&lt;/h3&gt;&lt;p&gt;CentOS Stream은 최신 Linux 기능 업데이트를 계속 받고자 하는 CentOS 사용자, 그리고 Red Hat Enterprise Linux 개발에 참여하고자 하는 개발자와 파트너에게 적합합니다&lt;/p&gt;
&lt;p&gt;커뮤니티 구성원, Red Hat 파트너 및 기타 사용자들이 보다 안정적이고 예측 가능한 Linux 환경에서 혁신적인 오픈소스 프로그램을 최대한 활용할 수 있도록 지원하는 것을 목표로 합니다&lt;/p&gt;
&lt;h2 id=&#34;죄송합니다-번역할-중국어-텍스트가-제공되지-않았습니다-텍스트를-제공해-주시면-번역해-드리겠습니다&#34;&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Release&lt;/th&gt;
&lt;th&gt;Released&lt;/th&gt;
&lt;th&gt;Active Support&lt;/th&gt;
&lt;th&gt;Security Support&lt;/th&gt;
&lt;th&gt;Latest&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;3 years ago (15 Sep 2021)&lt;/td&gt;
&lt;td&gt;Ends in 2 years and 6 months (31 May 2027)&lt;/td&gt;
&lt;td&gt;Ends in 2 years and 6 months (31 May 2027)&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;5 years ago (24 Sep 2019)&lt;/td&gt;
&lt;td&gt;Ended 5 months and 3 weeks ago (31 May 2024)&lt;/td&gt;
&lt;td&gt;Ended 5 months and 3 weeks ago (31 May 2024)&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;해결책&#34;&gt;해결책
&lt;/h2&gt;&lt;p&gt;업그레이드 문제에 신경 쓰고 싶지 않아, 장기 지원 버전을 선택했습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>Hugo 모듈 커스텀 수정 테마: 아이디어 설명</title>
        <link>https://blog.ttf248.life/ko/p/hugo-module-custom-theme-ideas/</link>
        <pubDate>Fri, 15 Nov 2024 22:01:17 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/hugo-module-custom-theme-ideas/</guid>
        <description>&lt;p&gt;과거 커밋 기록을 살펴보니, 사이트는 여러 번 테마를 변경해 왔고, 매번 변경 시마다 사용자 정의 수정 사항이 있었습니다. 여기 사용자 정의 테마 수정에 대한 아이디어를 기록합니다. 작성자의 &lt;code&gt;Github&lt;/code&gt;BOLD_3&lt;code&gt;hugo&lt;/code&gt;编译器到最新版本，导致even主题不兼容，所以又切换到了&lt;code&gt;stack&lt;/code&gt; 테마입니다.&lt;/p&gt;
&lt;h2 id=&#34;후고의-모듈화&#34;&gt;후고의 모듈화
&lt;/h2&gt;&lt;p&gt;모듈화를 언급하면 Nginx 모듈이나 IDEA 플러그인 등이 떠오르곤 합니다. 보통은 몇몇 모듈을 업로드하여 차별화된 요구사항을 충족할 수 있습니다. 이러한 모듈이 선호되는 주된 이유는 충분히 유연하기 때문이며, 큰 노력을 들이지 않고도 자체적인 요구사항을 충족할 수 있기 때문입니다. 많은 경우 전체적으로는 비슷하더라도 세부적인 차이가 존재합니다. 이는 기술적 복잡성 외에도 비즈니스 복잡성을 보여주는 것이기도 합니다. 대부분의 경우 우리는 비즈니스 복잡성에 직면하며, 이것이 소프트웨어 분야에서 “동업자 간에도 산과 같다는” 속담을 가장 잘 설명하는 것입니다. 현재는 인터넷 산업뿐만 아니라 금융 산업, 심지어 전통적인 제조업까지 정보화 시스템을 활용하여 기업의 생산 및 관리를 돕고 있습니다. 동일한 휴가 시스템이라 할지라도 같은 업계 내에서도 회사마다 차이가 있을 수 있습니다.&lt;/p&gt;
&lt;p&gt;모듈은 일반적인 모듈과 달리 기능별로 차별화된 요구사항을 충족하기보다는 디렉토리 구조를 중심으로 동일한 구조를 식별합니다&lt;/p&gt;
&lt;p&gt;자료 링크: &lt;a class=&#34;link&#34; href=&#34;https://medium.com/@sunwei.xyz/07-hugo%E6%9E%B6%E6%9E%84-hugo%E7%9A%84%E6%A8%A1%E5%9D%97-8ef5a520a822&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;07. Hugo架构 — Hugo的模块&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[[imports]]
path = &amp;quot;github.com/CaiJimmy/hugo-theme-stack/v3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 방식은 여전히 사용할 수 있지만, 본문에서는 권장하지 않습니다. 주제에 업데이트가 발생하면 유지 관리가 복잡해지므로 별도의 Git 저장소로 관리해야 합니다.&lt;/p&gt;
&lt;h2 id=&#34;죄송합니다-번역할-중국어-텍스트가-제공되지-않았습니다-텍스트를-제공해-주시면-번역해-드리겠습니다&#34;&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.
&lt;/h2&gt;&lt;p&gt;앞선 모듈화 기반 개념에 대한 이해가 있으면 사용자 정의 테마를 이해하는 것은 훨씬 쉬워집니다. &lt;code&gt;hugo&lt;/code&gt; 현재의 테마 역시 여러 개의 다른 모듈로 조립된 것이며, 원하는 모듈을 찾아서 해당 템플릿 파일을 수정하면 됩니다.&lt;/p&gt;
&lt;p&gt;__INLINE_CODE_0__공식 문서에서 발췌:&lt;/p&gt;
&lt;p&gt;Using this method, there won&amp;rsquo;t be any file under &lt;code&gt;themes&lt;/code&gt; directory. In order to modify the theme, you will have to copy the file you want to modify to the same directory under &lt;code&gt;layouts&lt;/code&gt; directory.&lt;/p&gt;
&lt;p&gt;For example, in order to modify the &lt;code&gt;themes/hugo-theme-stack/layouts/partials/head/custom.html&lt;/code&gt; file, you will have to copy it to &lt;code&gt;layouts/partials/head/custom.html&lt;/code&gt; and modify it there (copy the code from theme&amp;rsquo;s repository). The same applies to &lt;code&gt;assets&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt; directories。&lt;/p&gt;
&lt;h2 id=&#34;템플릿-파일을-어떻게-찾을-수-있나요&#34;&gt;템플릿 파일을 어떻게 찾을 수 있나요?
&lt;/h2&gt;&lt;h3 id=&#34;정통적-관점&#34;&gt;정통적 관점
&lt;/h3&gt;&lt;p&gt;테마 소스 파일을 살펴보며 디자인 의도를 파악하고, 해당 템플릿 파일을 찾아 수정하면 됩니다&lt;/p&gt;
&lt;h3 id=&#34;거친-사고방식&#34;&gt;거친 사고방식
&lt;/h3&gt;&lt;p&gt;저는 프론트엔드 코드를 잘 알지 못해서 때로는 직접 브라우저에서 해당 페이지를 열어 수정할 부분을 찾고, &lt;code&gt;审查元素&lt;/code&gt;BOLD_2&lt;code&gt;css name&lt;/code&gt;을 사용하여 테마 소스 코드 내에서 검색하여 해당 파일을 찾아 사이트 디렉토리에 복사한 후 수정하는 방식으로 작업합니다&lt;/p&gt;
&lt;h2 id=&#34;작은-팁&#34;&gt;작은 팁
&lt;/h2&gt;&lt;p&gt;기본적으로 제공되는 스타일 사용자 정의 파일을 활용하여, 수정이 필요한 부분을 여러 파일로 분할하고 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 파일을 통해 다른 파일들을 불러와 스타일 파일을 더 효과적으로 관리할 수 있습니다&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/hugo-module-custom-theme-ideas/image.png&#34;
	width=&#34;141&#34;
	height=&#34;375&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;37&#34;
		data-flex-basis=&#34;90px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;수정-내용-요약-6시간&#34;&gt;수정 내용 요약 (6시간)
&lt;/h2&gt;&lt;p&gt;지금은 __INLINE_CODE_0__编码的元年，详细的内容，这里就不详细贴出来了，只是简单的列举一下，本站点的一些修改内容，比如调整复制按钮的样式，重新设置代码的块的样式，&lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; 모두 쉽게 처리할 수 있습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;전체: 전체 텍스트 스타일은 이전 __INLINE_CODE_0__BOLD_2&lt;code&gt;info cn&lt;/code&gt; 표시 스타일을 유지하며, 중국어 사용자를 고려함&lt;/li&gt;
&lt;li&gt;홈페이지 오른쪽 네비게이션에 마우스 인터랙션 애니메이션 추가&lt;/li&gt;
&lt;li&gt;처음 페이지: 논문에 요약 미리 보기 추가 (시간이 많이 소요되어 편리한 방법을 사용함)&lt;/li&gt;
&lt;li&gt;스크롤바: 스크롤바 스타일을 개선했습니다&lt;/li&gt;
&lt;li&gt;코드 블록에 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 코드 하이라이트 플러그인이 도입되어 코드 블록 스타일이 개선되었습니다&lt;/li&gt;
&lt;li&gt;일부 내용은 재게시되었으며, 원저자 정보 및 원본 링크가 추가되었습니다&lt;/li&gt;
&lt;li&gt;아카이브 페이지: 상단의 분류 이미지, 테마 자체 색상 오버레이 제거 후 원본 이미지 표시&lt;/li&gt;
&lt;li&gt;분류별 연도별 통계 표시 패널이 추가되었습니다&lt;/li&gt;
&lt;li&gt;기록 페이지: 두 열 레이아웃&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;스크립트를 통해 사용자 정의 특수 변수를 활용하여 요약 미리보기를 구현합니다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;때로는 코드 재사용성이 너무 높아 문제인 경우도 있는데, 한 부분을 수정하면 다른 부분에도 영향을 미칠 수 있으므로 테마를 수정할 때는 기존 로직을 훼손하지 않도록 주의해야 합니다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;댓글-영역&#34;&gt;댓글 영역
&lt;/h3&gt;&lt;p&gt;이 친구의 수정은 더 완벽해졌어: &lt;a class=&#34;link&#34; href=&#34;https://blog.reincarnatey.net/2024/0719-better-waline/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.reincarnatey.net/2024/0719-better-waline/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;파업_11&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;추천, 홈페이지, 이메일 연락처. 본 사이트는 댓글 기능을 제공하지 않습니다.&lt;/p&gt;
&lt;/blockquote&gt;</description>
        </item>
        <item>
        <title>리눅스 백엔드 서비스 문자열 데이터 처리 - 속도 느림</title>
        <link>https://blog.ttf248.life/ko/p/linux-backend-slow-string-processing/</link>
        <pubDate>Wed, 13 Nov 2024 19:42:59 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/linux-backend-slow-string-processing/</guid>
        <description>&lt;p&gt;C++ 개발 프로젝트에서 사용자 정의 프로토콜을 사용하여 통신했는데, 이 프로토콜은 2차원 배열 패턴을 채택했습니다. 대량의 데이터를 처리할 때 프로토콜 내부에서 배열을 순회하고 시리얼화하여 로그를 생성하는 과정이 비효율적이었고, 이는 고부하 상황에서 시스템 응답 지연을 야기했습니다. 이로 인해 사업 부서로부터 시스템 멈춤 현상에 대한 피드백을 받았습니다.&lt;/p&gt;
&lt;h2 id=&#34;문제-파악&#34;&gt;문제 파악
&lt;/h2&gt;&lt;p&gt;문제 해결 과정에서 우선 시스템 성능을 분석한 결과, 대량의 데이터를 처리할 때 CPU 사용률이 눈에 띄게 증가하고 응답 시간이 길어지는 것을 확인했습니다. 시스템 로그를 분석한 결과, 2차원 배열 처리에 비효율적인 많은 양의 직렬화 작업이 수행되고 있었고, 이로 인해 시스템 성능이 저하되었습니다.&lt;/p&gt;
&lt;p&gt;도구 캡처 서비스의 스레드 정보를 분석한 결과, 로그 스레드는 대부분의 시간을 문자열 연결 처리에 소비하는 것으로 나타났다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;여기 오늘의 핵심인데, 다른 누적 방식에 따라 효율성의 차이가 엄청나다. 기존 코드에서는 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 연산자를 사용했는데, 이 방식은 빈번하게 임시 객체를 생성하므로 효율이 매우 낮다. 얼마나 심각한지 모르는 수준으로 비효율적이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;데모-검증&#34;&gt;데모 검증
&lt;/h2&gt;&lt;p&gt;프로젝트 코드를 기반으로 비즈니스 로직을 분리하고, 문자열 연결 효율성 문제를 검증하기 위한 간단한 데모를 작성했습니다. &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 下的 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; 编译器，__INLINE_CODE_2__BOLD_7&lt;code&gt;gcc8.5&lt;/code&gt; 编译器，&lt;strong&gt;INLINE_CODE_4&lt;/strong&gt; 모드에서 컴파일 및 실행하여 효율성을 비교했습니다.&lt;/p&gt;
&lt;h3 id=&#34;주요-사항-안내&#34;&gt;주요 사항 안내
&lt;/h3&gt;&lt;p&gt;프로젝트는 방법 네 가지를 사용하고 있는데, 테스트 데이터를 받기 전 독자들은 어떤 방식이 가장 효율적이고 어떤 방식이 가장 비효율적인지 먼저 생각해 볼 수 있습니다. 결과를 보고 저는 여전히 놀랐습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;각 필드를 문자열에 직접 연결합니다&lt;/li&gt;
&lt;li&gt;스트림(Stream)을 사용하여 각 필드를 연결하면 더 효율적이며, 특히 대량 데이터를 연결할 때 더욱 그렇습니다&lt;/li&gt;
&lt;li&gt;**方法 3（预分配内存的 &lt;strong&gt;인라인_4&lt;/strong&gt; &lt;em&gt;이탤릭체_3&lt;/em&gt;_： 미리 문자열에 충분한 메모리를 할당하면 메모리 재할당 비용을 줄여 성능을 향상시킬 수 있습니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法 4 (&lt;strong&gt;인라인__이탤릭_3&lt;/strong&gt; __)&lt;/strong&gt;: 매번 연결할 때마다 새로운 임시 문자열 객체를 생성하므로, 특히 대규모 연결 시 성능 저하가 발생합니다. 이는 매번 연결 시 새로운 메모리 할당 및 복사가 수반되기 때문입니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;참고 결과, 프로젝트가 효율이 가장 낮은 방식을 선택한 것을 알 수 있습니다&lt;/p&gt;
&lt;p&gt;더 나아가, 다양한 플랫폼 컴파일러의 최적화 효율을 분석해 보면, 마이크로소프트의 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 一如既往的优秀，针对字符串的优化效率很高，而 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; 컴파일러는 이 부분에서 최적화 효율이 다소 떨어지는 편입니다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;코드 실행 환경이 다른 기기에서 이루어지므로 데이터 간 직접적인 비교는 무의미하며, 각각의 조립 방식별 차이를 비교하는 것이 좋습니다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;windows 平台下的 vs2022 编译器

----------------------------------------
Data Generation Time: 0.054 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.053 seconds.
+ ostringstream Data merging took: 0.054 seconds.
+ Pre-reserved Data merging took: 0.045 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 16.108 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;linux 平台下的 gcc8.5 编译器
----------------------------------------
Data Generation Time: 0.108 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.100 seconds.
+ ostringstream Data merging took: 0.083 seconds.
+ Pre-reserved Data merging took: 0.057 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 29.298 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;전체-코드&#34;&gt;전체 코드
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;random&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;iomanip&amp;gt;

typedef std::vector&amp;lt;std::string&amp;gt; DataRow;
typedef std::vector&amp;lt;DataRow&amp;gt; DataGroup;

struct ResponsePackage
{
    std::string ErrorInfo;
    DataRow Head;
    std::string ClientId;
    std::string UUID;
    std::string MsgID;
    std::string SessionID;
    std::string ExtraInfo1;
    std::string ExtraInfo2;
    DataGroup DataBody;
};

// Generate specified length of random string
std::string generateRandomString(size_t length)
{
    const char charset[] = &amp;quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&amp;quot;;
    const size_t max_index = sizeof(charset) - 1;
    std::string random_string;
    random_string.reserve(length);

    std::random_device rd;
    std::mt19937 generator(rd());
    std::uniform_int_distribution&amp;lt;&amp;gt; distribution(0, max_index);

    for (size_t i = 0; i &amp;lt; length; ++i)
    {
        random_string += charset[distribution(generator)];
    }

    return random_string;
}

void create_large_string()
{
    // Example request package with 50 fields
    ResponsePackage requestPackage;

    requestPackage.Head = {
        &amp;quot;Field1&amp;quot;, &amp;quot;Field2&amp;quot;, &amp;quot;Field3&amp;quot;, &amp;quot;Field4&amp;quot;, &amp;quot;Field5&amp;quot;,
        &amp;quot;Field6&amp;quot;, &amp;quot;Field7&amp;quot;, &amp;quot;Field8&amp;quot;, &amp;quot;Field9&amp;quot;, &amp;quot;Field10&amp;quot;,
        &amp;quot;Field11&amp;quot;, &amp;quot;Field12&amp;quot;, &amp;quot;Field13&amp;quot;, &amp;quot;Field14&amp;quot;, &amp;quot;Field15&amp;quot;,
        &amp;quot;Field16&amp;quot;, &amp;quot;Field17&amp;quot;, &amp;quot;Field18&amp;quot;, &amp;quot;Field19&amp;quot;, &amp;quot;Field20&amp;quot;,
        &amp;quot;Field21&amp;quot;, &amp;quot;Field22&amp;quot;, &amp;quot;Field23&amp;quot;, &amp;quot;Field24&amp;quot;, &amp;quot;Field25&amp;quot;,
        &amp;quot;Field26&amp;quot;, &amp;quot;Field27&amp;quot;, &amp;quot;Field28&amp;quot;, &amp;quot;Field29&amp;quot;, &amp;quot;Field30&amp;quot;,
        &amp;quot;Field31&amp;quot;, &amp;quot;Field32&amp;quot;, &amp;quot;Field33&amp;quot;, &amp;quot;Field34&amp;quot;, &amp;quot;Field35&amp;quot;,
        &amp;quot;Field36&amp;quot;, &amp;quot;Field37&amp;quot;, &amp;quot;Field38&amp;quot;, &amp;quot;Field39&amp;quot;, &amp;quot;Field40&amp;quot;,
        &amp;quot;Field41&amp;quot;, &amp;quot;Field42&amp;quot;, &amp;quot;Field43&amp;quot;, &amp;quot;Field44&amp;quot;, &amp;quot;Field45&amp;quot;,
        &amp;quot;Field46&amp;quot;, &amp;quot;Field47&amp;quot;, &amp;quot;Field48&amp;quot;, &amp;quot;Field49&amp;quot;, &amp;quot;Field50&amp;quot;
    };

    requestPackage.ClientId = &amp;quot;ClientID&amp;quot;;
    requestPackage.UUID = &amp;quot;UUID&amp;quot;;
    requestPackage.MsgID = &amp;quot;MsgID&amp;quot;;
    requestPackage.SessionID = &amp;quot;SessionID&amp;quot;;
    requestPackage.ExtraInfo1 = &amp;quot;ExtraInfo1&amp;quot;;
    requestPackage.ExtraInfo2 = &amp;quot;ExtraInfo2&amp;quot;;

    // Start timing for data generation
    auto start_gen = std::chrono::high_resolution_clock::now();

    // Generate 10,000 rows of data, each with 50 fields
    for (size_t i = 0; i &amp;lt; 10000; ++i)
    {
        DataRow dataRow(50, &amp;quot;This is a test string&amp;quot;);
        requestPackage.DataBody.push_back(dataRow);
    }

    // End timing for data generation
    auto end_gen = std::chrono::high_resolution_clock::now();
    std::chrono::duration&amp;lt;double&amp;gt; duration_gen = end_gen - start_gen;

    // Display result generation time
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Generation Time: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_gen.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    // Data merging using different methods
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Performance:\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    {
        // Method 1: Using &#39;+=&#39; string concatenation
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (+=) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 2: Using ostringstream
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::ostringstream bodys;
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::ostringstream body;
            body &amp;lt;&amp;lt; &amp;quot;This is a test string&amp;quot;;
            for (auto&amp;amp; item : vec)
            {
                body &amp;lt;&amp;lt; item &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            }
            bodys &amp;lt;&amp;lt; body.str() &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ ostringstream Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 3: Pre-allocated memory
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys;
        bodys.reserve(1000 * 50 * 20); // Pre-allocate enough memory
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            body.reserve(50 * 20); // Pre-allocate memory for each row
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Pre-reserved Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 4: Using &#39;bodys = bodys + body + &amp;quot;\n&amp;quot;&#39;
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body = body + item + &amp;quot; &amp;quot;; // Note the use of &#39;body = body + item&#39;
            }
            bodys = bodys + body + &amp;quot;\n&amp;quot;; // Again, using &#39;bodys = bodys + body&#39;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (bodys = bodys + body + \&amp;quot;\\n\&amp;quot;) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Complete.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;
}

int main()
{
    try
    {
        create_large_string();
    }
    catch (const std::exception&amp;amp; e)
    {
        std::cerr &amp;lt;&amp;lt; &amp;quot;Caught exception: &amp;quot; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\nProgram finished.\n&amp;quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43; 람다 표현식 매개변수 생명 주기</title>
        <link>https://blog.ttf248.life/ko/p/cpp-lambda-parameter-lifetime/</link>
        <pubDate>Wed, 13 Nov 2024 19:23:02 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/cpp-lambda-parameter-lifetime/</guid>
        <description>&lt;p&gt;C++에서 람다 표현식은 외부 변수를 캡처하여 사용할 수 있는 편리한 익명 함수입니다. 이는 람다를 유연한 프로그래밍 도구로 만듭니다. 하지만 람다 표현식의 매개변수 생명 주기는 특히 캡처 및 전달 시 특별히 주의해야 할 측면입니다.&lt;/p&gt;
&lt;h3 id=&#34;람다-표현식의-매개변수-생명-주기&#34;&gt;람다 표현식의 매개변수 생명 주기
&lt;/h3&gt;&lt;p&gt;람다 표현식의 매개변수 수명은 일반적으로 다른 C++ 함수와 동일합니다. 함수의 매개변수는 함수 호출 시 존재하며, 호출이 종료되면 수명이 끝납니다. 하지만 람다 표현식이 외부 변수를 캡처할 수 있기 때문에 매개변수의 수명은 캡처 방식에 영향을 받기도 합니다.&lt;/p&gt;
&lt;h3 id=&#34;포획과-매개변수-생명주기의-관계&#34;&gt;포획과 매개변수 생명주기의 관계
&lt;/h3&gt;&lt;h4 id=&#34;21-외부-변수-캡처&#34;&gt;2.1 외부 변수 캡처
&lt;/h4&gt;&lt;p&gt;C++ 람다 표현식은 외부 변수를 두 가지 방식으로 캡처할 수 있습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;값 캡처를 통해 외부 변수의 값이 람다 내부에 복사되고, 람다 내부의 복사본은 람다의 생명주기에 의해 제어됩니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按引用捕获&lt;/strong&gt;: 클로저를 통해 외부 변수 참조가 유지되며, 람다 내부의 참조는 원본 외부 변수를 가리키고, 생명 주기는 외부 변수에 의존합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda_by_value = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };  // 捕获x的副本
auto lambda_by_reference = [&amp;amp;x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };  // 捕获x的引用

lambda_by_value();  // 打印10
lambda_by_reference();  // 打印10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;캡처된 변수는 다음과 같은 수명을 갖습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;按值捕获&lt;/strong&gt;: 캡처된 시점에 외부 변수의 값이 lambda에 복사되고, lambda의 수명이 종료될 때 복사본이 파괴됩니다&lt;/li&gt;
&lt;li&gt;람다가 외부 변수의 참조를 보유합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;람다-매개변수&#34;&gt;람다 매개변수
&lt;/h4&gt;&lt;p&gt;람다 함수의 파라미터는 일반 함수 파라미터와 유사하며, 그 수명은 람다 함수 내에서만 유효합니다. 즉, 람다 호출 시 파라미터가 생성되고, 호출이 끝나면 파라미터의 수명이 종료됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto lambda = [](int a, int b) {
    std::cout &amp;lt;&amp;lt; a + b &amp;lt;&amp;lt; std::endl;
};
lambda(5, 10);  // a和b在这里是lambda的参数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 예제에서 __INLINE_CODE_0__BOLD_2&lt;code&gt;b&lt;/code&gt;은 람다 표현식의 매개변수이며, 람다 호출 시 생성되고 람다 실행 종료 후 파괴됩니다&lt;/p&gt;
&lt;h3 id=&#34;외부-변수-캡처-시-라이프사이클-문제&#34;&gt;외부 변수 캡처 시 라이프사이클 문제
&lt;/h3&gt;&lt;h4 id=&#34;람다-외부에서-캡처된-변수가-유효한가&#34;&gt;람다 외부에서 캡처된 변수가 유효한가?
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;람다 호출 후 외부 변수가 파괴되더라도 람다 내부에서는 여전히 외부 변수의 복사본을 보유합니다. 따라서 외부 변수가 더 이상 존재하지 않더라도 람다 내부의 복사본은 안전하게 사용할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x 在lambda调用后修改
lambda();  // 打印10，捕获的是x的副本
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;按引用捕获&lt;/strong&gt;: 람다가 외부 변수의 참조를 캡처하는 경우, 람다 내부에서 해당 참조에 대한 접근은 외부 변수의 수명 주기(lifetime)에 의존합니다. 만약 외부 변수가 람다 실행 전에 소멸된다면, dangling reference 문제가 발생하여 정의되지 않은 동작을 초래할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [&amp;amp;x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x 在lambda调用前修改
lambda();  // 打印20，捕获的是x的引用
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;람다 함수의 실행 순서가 불확실하다면, 람다 함수가 실행될 때 캡처된 외부 변수가 유효한지 확인하는 것이 중요합니다&lt;/p&gt;
&lt;/blockquote&gt;</description>
        </item>
        <item>
        <title>Win11 로지텍 G431 헤드셋 드라이버 설치</title>
        <link>https://blog.ttf248.life/ko/p/win11-logitech-g431-headphone-driver-installation/</link>
        <pubDate>Wed, 05 Jun 2024 07:20:17 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/win11-logitech-g431-headphone-driver-installation/</guid>
        <description>&lt;p&gt;책 이어받아, 돌아와 보니 Ghub 업데이트가 있네. 좀 기뻤는데, 고객센터에서 해결했다고 하는 문제 드라이브 로딩 오류 문제는 고쳤다고 했는데, 결과적으로 설치하고 제거하고 또 설치해도 제대로 안 된다.&lt;/p&gt;
&lt;h2 id=&#34;배경&#34;&gt;배경
&lt;/h2&gt;&lt;p&gt;계속 고객 지원에 문의하여 해결 방안을 알아보니, 엔지니어의 원격 지원이 가능하다는 답변을 받았지만, 엔지니어의 근무 시간과 제 근무 시간이 겹쳐 어쩔 수 없이 포기했습니다. 이전 문제 해결 과정에서 남겨둔 자료를 다시 살펴보고, 직접 드라이버를 설치해 보려고 합니다.&lt;/p&gt;
&lt;h2 id=&#34;드라이버-설치-패키지-받기&#34;&gt;드라이버 설치 패키지 받기
&lt;/h2&gt;&lt;p&gt;로지텍 공식에서 별도의 장치 드라이버 설치 파일을 제공하지 않습니다. 드라이버 파일은 어떻게 얻을 수 있나요?&lt;/p&gt;
&lt;p&gt;이전 시스템 재설치 시 남겨진 시스템 이미지 설치 패키지를 활용하여, 로컬 가상 머신에서 시스템을 다시 설치할 수 있습니다. 깨끗한 환경에서 Ghub를 개별적으로 배포하고 헤드셋 장치를 가상 머신에 연결한 후, 드라이버 경로를 찾아 복사하면 됩니다.&lt;/p&gt;
&lt;p&gt;관련 경로:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C:\ProgramData\LGHUB&lt;/li&gt;
&lt;li&gt;C:\Windows\System32\DriverStore\FileRepository\logi_audio.inf_amd64_010b035044e24be4&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장치-관리자&#34;&gt;장치 관리자
&lt;/h2&gt;&lt;p&gt;두 번째 경로를 찾는 것이 중요하며, 먼저 Win11 시스템에서 드라이버 파일을 수동으로 관리하는 방법을 간단히 정리해 보겠습니다. 이 부분은 &lt;strong&gt;通过控制变量法来识别的，通过不断的插拔设备，在虚拟机里面分析设备管理器中的设备信息，识别到耳机合计有三个驱动需要处理&lt;/strong&gt;입니다. 그중 두 개의 드라이버는 시스템에 내장되어 있고, 하나는 로지텍에서 제공합니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/win11-logitech-g431-headphone-driver-installation/20240605073331.png&#34;
	width=&#34;433&#34;
	height=&#34;904&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;驱动管理器&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;47&#34;
		data-flex-basis=&#34;114px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;위 그림의 두 번째 드라이버는 로지텍에서 제공하는 것으로, 현재 장치 드라이버를 분석하고 가상 머신 내 모든 드라이버 경로를 뒤져서 logi로 시작하는 파일을 먼저 찾아 파일 비교를 하면 드라이버 파일을 찾을 수 있습니다. 전체 폴더를 복사하면 드라이버 설치 패키지를 얻게 됩니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/win11-logitech-g431-headphone-driver-installation/20240605073933.png&#34;
	width=&#34;946&#34;
	height=&#34;645&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;驱动安装包&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;146&#34;
		data-flex-basis=&#34;352px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;드라이버-설치&#34;&gt;드라이버 설치
&lt;/h2&gt;&lt;p&gt;장치 관리자 인터페이스에서 &amp;lsquo;드라이버 업데이트&amp;rsquo;를 클릭한 다음, &amp;lsquo;내 컴퓨터에서 드라이버 찾아보기&amp;rsquo;를 클릭하면 다음과 같은 화면으로 진입합니다&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/win11-logitech-g431-headphone-driver-installation/20240605074130.png&#34;
	width=&#34;528&#34;
	height=&#34;381&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;驱动安装&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;138&#34;
		data-flex-basis=&#34;332px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;물론 열면 드라이버 하나만 보일 텐데, 그것은 일반 USB 드라이버입니다. &amp;ldquo;디스크에서 설치&amp;quot;를 선택하고 경로를 앞서 복사해둔 폴더로 지정하면 됩니다. 설치 후에는 드롭다운 목록에 로지텍 특유의 드라이버가 추가될 것이고, 장치 드라이버를 새로 설치된 드라이버로 전환하면 됩니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/win11-logitech-g431-headphone-driver-installation/20240605074208.png&#34;
	width=&#34;593&#34;
	height=&#34;423&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;磁盘安装&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;140&#34;
		data-flex-basis=&#34;336px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;인체학-장비-드라이버&#34;&gt;인체학 장비 드라이버
&lt;/h2&gt;&lt;p&gt;이 장치의 드라이버 파일은 시스템에서 제공하는 것이므로, 장치 드라이버 앞에 느낌표가 있는지 확인하고, 있다면 드라이버 선택 화면으로 들어가 다른 유형의 드라이버로 임시로 변경한 후 다시 원래대로 돌리면 정상적으로 복구됩니다&lt;/p&gt;
&lt;h2 id=&#34;완료&#34;&gt;완료
&lt;/h2&gt;&lt;p&gt;헤드폰 마이크 음량은 정상으로 돌아왔고, 익숙한 이어모니터 기능도 다시 작동합니다&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/win11-logitech-g431-headphone-driver-installation/20240605074823.png&#34;
	width=&#34;485&#34;
	height=&#34;739&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;侧音&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;65&#34;
		data-flex-basis=&#34;157px&#34;
	
&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>로지텍 헤드셋 드라이버 설치 실패</title>
        <link>https://blog.ttf248.life/ko/p/logitech-headset-driver-installation-failed/</link>
        <pubDate>Fri, 31 May 2024 21:46:12 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/logitech-headset-driver-installation-failed/</guid>
        <description>&lt;p&gt;이런 것들을 전혀 모르면, 처음부터 공식 고객센터에 연락하면 몇 시간 낭비할 일 없었을 텐데&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/logitech-headset-driver-installation-failed/20240531220709.png&#34;
	width=&#34;693&#34;
	height=&#34;489&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;GHUB&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;141&#34;
		data-flex-basis=&#34;340px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;최근에 집에서 개발용으로 쓰던 데스크탑 C드라이브 용량이 부족해져서, 256GB의 반납된 SSD를 따로 분리해서 사용했는데, 자꾸 이것저것 만지작거려서 제대로 안 됐습니다. 상하이로 이사 온 후 여러 일들로 바빴는데, 드디어 지난주에 시간을 내서 시스템을 다시 설치했습니다.&lt;/p&gt;
&lt;p&gt;시스템 재설치는 문제 없이 진행되었고, 평소 사용하던 소프트웨어 설치나 개발 환경 구축에도 별다른 문제가 없었다. 며칠 뒤 휴식을 취하며 게임을 즐기려는데, 마우스와 헤드셋 드라이버가 아직 설치되지 않은 것을 알게 되었다. 이 두 장비는 모두 로지텍 제품이기에 GHUB 소프트웨어를 다운로드하여 하드웨어를 자동으로 인식하고 드라이버를 설치했다.&lt;/p&gt;
&lt;p&gt;하지만, 예상치 못한 문제가 발생했다. 마우스 드라이버는 문제없이 설치되었지만, 헤드셋 드라이버는 계속해서 &amp;ldquo;로딩 중&amp;rdquo; 상태였다. 최신 Windows 11 시스템과 로지텍 드라이버 간의 호환성 문제일 가능성을 의심하며 자료를 찾아보고 수동으로 드라이버를 설치하려 했지만, 문제는 해결되지 않았다.&lt;/p&gt;
&lt;p&gt;두 장비의 드라이버는 각각 어떤 역할을 하는지 간단히 설명해 줄 수 있나요?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;마우스 드라이버는 주로 마우스 이동 속도 조절 등의 기능을 담당합니다. 매크로 기능은 거의 사용하지 않으며, 저장된 설정을 불러오기만 하면 됩니다.&lt;/li&gt;
&lt;li&gt;이어폰 드라이버는 주로 이어모니터링 기능에 사용되며, 팀 음성 채팅 시 내 목소리를 들을 수 있어서 매우 유용합니다. 시스템 마이크 설정에도 비슷한 모니터링 기능이 있지만, 드라이버가 구현한 것만큼 효과적이지 않습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;몇 번이고 시도했음에도 이어폰 드라이버가 제대로 로드되지 않습니다. 오늘야말로 고객센터에 문의해서 해결책이 있는지 알아봐야겠다고 생각했습니다. 고객센터에서는 최근 서버 문제로 인해 드라이버 다운로드에 이상이 있다고 했습니다. 현재 문제를 처리 중이며, 다음 업데이트 후에 문제가 해결될 것이라고 하셨습니다.&lt;/p&gt;
&lt;p&gt;문제는 아직 해결되지 않았지만, 원인이 파악되었으니 조속히 해결되기를 바랍니다&lt;/p&gt;
&lt;h2 id=&#34;마우스-드라이버-설정&#34;&gt;마우스 드라이버 설정
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/logitech-headset-driver-installation-failed/20240531220930.png&#34;
	width=&#34;1024&#34;
	height=&#34;768&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;G502&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;133&#34;
		data-flex-basis=&#34;320px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/logitech-headset-driver-installation-failed/20240531220903.png&#34;
	width=&#34;1024&#34;
	height=&#34;768&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;G502&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;133&#34;
		data-flex-basis=&#34;320px&#34;
	
&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>파이썬 딕셔너리에 사용자 정의 객체 저장 시 참조와 깊은 복사의 중요성</title>
        <link>https://blog.ttf248.life/ko/p/python-dictionary-custom-objects-reference-vs-deepcopy/</link>
        <pubDate>Fri, 22 Mar 2024 01:08:05 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/python-dictionary-custom-objects-reference-vs-deepcopy/</guid>
        <description>&lt;p&gt;파이썬 프로그래밍에서 딕셔너리는 키-값 쌍을 연결하고 데이터를 효율적으로 검색하고 조작할 수 있는 매우 강력한 자료 구조입니다. 사용자 정의 객체를 딕셔너리에 저장하려고 할 때, 중요한 개념은 파이썬의 객체 할당이 실제로는 객체의 깊은 복사라기보다는 참조 할당이라는 것입니다. 즉, 사용자 정의 객체를 딕셔너리에 넣으면 딕셔너리에는 해당 객체의 참조가 저장되고 객체의 새로운 복사본이 저장되는 것이 아닙니다.&lt;/p&gt;
&lt;h2 id=&#34;사용자-정의-객체-저장의-기본-예제&#34;&gt;사용자 정의 객체 저장의 기본 예제
&lt;/h2&gt;&lt;p&gt;가정해 봅시다, 간단한 &lt;code&gt;Person&lt;/code&gt; 클래스가 있다고 하면:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

# 创建一个 Person 对象
p1 = Person(&amp;quot;Alice&amp;quot;, 30)

# 将对象存储到字典中
people_dict = {}
people_dict[&amp;quot;alice&amp;quot;] = p1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 예제에서 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 字典现在包含一个键为 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; 的项，其值是对 __INLINE_CODE_2__BOLD_7&lt;code&gt;p1&lt;/code&gt;BOLD_8__INLINE_CODE_4__의 속성:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;p1.age = 31
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그러면 딕셔너리로 해당 객체에 접근하면 나이가 업데이트된 것을 확인할 수 있습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(people_dict[&amp;quot;alice&amp;quot;].age)  # 输出：31
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;사전에는 &lt;code&gt;Person&lt;/code&gt; 객체의 독립적인 복사본이 저장되는 것이 아니라, 동일한 메모리 주소를 가리키는 참조가 저장되기 때문입니다&lt;/p&gt;
&lt;h2 id=&#34;깊은-복사와-얕은-복사의-차이점&#34;&gt;깊은 복사와 얕은 복사의 차이점
&lt;/h2&gt;&lt;p&gt;중첩된 데이터 구조나 사용자 정의 객체를 다룰 때는 이러한 참조 동작으로 인해 예기치 않은 결과가 발생할 수 있습니다. 예를 들어, 사용자 정의 객체에 변경 가능한 속성(예: 리스트나 다른 사용자 정의 객체)이 포함되어 있으면, 딕셔너리에 그런 객체를 직접 저장하고 수정하면 딕셔너리를 통해 접근한 객체에도 영향을 미칩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Address:
    def __init__(self, street, city):
        self.street = street
        self.city = city

class Person:
    def __init__(self, name, age, address):
        self.name = name
        self.age = age
        self.address = address

address = Address(&amp;quot;Main St.&amp;quot;, &amp;quot;Springfield&amp;quot;)
p1 = Person(&amp;quot;Bob&amp;quot;, 40, address)
people_dict[&amp;quot;bob&amp;quot;] = p1

# 修改原始地址对象
address.city = &amp;quot;Shelbyville&amp;quot;

# 字典中的人的地址也变了
print(people_dict[&amp;quot;bob&amp;quot;].address.city)  # 输出：Shelbyville
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解决办法：深拷贝&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;이러한 공유 상태로 인한 문제를 피하기 위해 때로는 딕셔너리에 객체의 완전한 복사본을 저장하도록 해야 하며, 이를 위해 Python은 &lt;strong&gt;copy&lt;/strong&gt;() 함수를 제공합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import copy

# 使用深拷贝存储对象
people_dict[&amp;quot;bob_deepcopy&amp;quot;] = copy.deepcopy(p1)

# 此时即使修改原始地址对象，深拷贝的对象不会受影响
address.city = &amp;quot;Capital City&amp;quot;
print(people_dict[&amp;quot;bob&amp;quot;].address.city)  # 输出：Capital City
print(people_dict[&amp;quot;bob_deepcopy&amp;quot;].address.city)  # 输出：Shelbyville
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;파이썬에서 딕셔너리로 사용자 정의 객체를 저장할 때는 기본적으로 객체 참조가 저장된다는 점에 유의해야 합니다. 독립적인 상태를 유지해야 하는 경우에는 공유 참조로 인한 예기치 않은 데이터 변경을 피하기 위해 깊은 복사(&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;)를 사용하십시오.&lt;/p&gt;</description>
        </item>
        <item>
        <title>새로 설치한 기가급 광케이블, 속도 측정 시 100메가에 그치는 이유는 무엇인가요?</title>
        <link>https://blog.ttf248.life/ko/p/new-gigabit-fiber-slow-speed/</link>
        <pubDate>Mon, 18 Mar 2024 00:29:02 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/new-gigabit-fiber-slow-speed/</guid>
        <description>&lt;p&gt;집안 네트워크를 번개처럼 빠뜨리고 싶으신가요? 핵심은 랜 케이블 선택, 광모뎀 및 공유기 설정, 그리고 눈에 띄지 않는 작은 디테일을 이해하는 것입니다. 이 블로그는 6급 랜 케이블로 기가비트 네트워크를 구축하고 간단한 장치 점검과 설정을 통해 네트워크 속도를 제약 없이 유지하는 방법을 쉽게 알려드립니다. 함께 탐색하며 집안 인터넷 속도를 높여 봅시다!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/new-gigabit-fiber-slow-speed/image.png&#34;
	width=&#34;1001&#34;
	height=&#34;590&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;手动修复&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;169&#34;
		data-flex-basis=&#34;407px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;제1장-네트워크-전송-매체-심층-분석&#34;&gt;제1장: 네트워크 전송 매체 심층 분석
&lt;/h2&gt;&lt;p&gt;기가비트급 네트워크 접근을 논할 때, 정보를 고속으로 전송하는 매개체인 랜 케이블이 매우 중요한 역할을 합니다. 다음은 5급, 6급 및 7급 랜 케이블에 대한 자세한 설명입니다.&lt;/p&gt;
&lt;h3 id=&#34;죄송합니다-번역할-중국어-텍스트가-제공되지-않았습니다-텍스트를-제공해-주시면-번역해-드리겠습니다&#34;&gt;죄송합니다. 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.
&lt;/h3&gt;&lt;p&gt;다섯 종류의 네트워크 케이블, CAT5라고도 하며, 비교적 초기에 널리 사용된 트위스트 페어 케이블입니다. 각 선 코어는 정밀한 나선 구조 설계로 인한 신호 간섭을 줄입니다. 주로 10/100Mbps의 빠른 이더넷에 적용되며 최대 전송 주파수는 약 100MHz입니다. 과거에는 널리 사용되었지만, 현재 기가비트 이상의 속도를 요구하는 경우 다섯 종류의 네트워크 케이블은 물리적인 한계로 인해 충족하지 못합니다.&lt;/p&gt;
&lt;h3 id=&#34;두-번째&#34;&gt;두 번째
&lt;/h3&gt;&lt;p&gt;기술 발전과 함께 6류 네트워크 케이블이 등장했습니다. 5류 케이블보다 더 엄격한 제조 기준과 첨단 구조 설계로 제작되어, 전반적인 내성능과 데이터 전송 효율을 크게 향상시켰으며, 최대 1Gbps의 전송 속도를 지원합니다. 이상적인 환경에서는 100미터까지 전송이 가능하여, 기가비트 네트워크 접속 요구 사항에 정확히 부합합니다.&lt;/p&gt;
&lt;h3 id=&#34;3&#34;&gt;3
&lt;/h3&gt;&lt;p&gt;7가지 규격의 네트워크 케이블은 현재 트위스트 페어 기술의 최첨단을 나타냅니다. 전송 속도가 획기적으로 향상되었을 뿐만 아니라 이론적으로 최대 10Gbps의 초고속을 지원하며, 각 선 쌍 간 및 전체 외부를 포함한 완벽한 차폐 시스템이 적용되어 외부 전자파 간섭과 근접 교차 누화를 크게 줄여 데이터 전송의 안정성과 정확성을 보장합니다. 하지만 7가지 규격의 네트워크 케이블은 주로 미래의 10기가비트 이더넷 또는 특정 고성능 환경에서 사용됩니다.&lt;/p&gt;
&lt;p&gt;기가비트 가정 네트워크 환경에서 기가 광섬유의 잠재력을 최대한 활용하기 위해서는 6급 랜 케이블을 선택하는 것이 가장 경제적이고 효율적인 방법입니다. 또한, 모든 연결 케이블의 품질이 양호한지 확인하고 표준 접선 방식으로 엄격하게 작업하는 것도 중요한 과정입니다.&lt;/p&gt;
&lt;h2 id=&#34;제2장-네트워크-핵심-장비---광모뎀-라우터-lan-포트-대역폭-영향-심층-분석&#34;&gt;제2장: 네트워크 핵심 장비 - 광모뎀, 라우터 LAN 포트 대역폭 영향 심층 분석
&lt;/h2&gt;&lt;h3 id=&#34;광촉매와-lan-포트-대역폭의-중요성&#34;&gt;광촉매와 LAN 포트 대역폭의 중요성
&lt;/h3&gt;&lt;p&gt;광촉매, 정식 명칭 광섬유 모뎀은 가정용 초고속 인터넷 접속의 핵심 장비이며, 광섬유 내의 광 신호를 디지털 신호로 변환하여 가정 네트워크 장비에서 사용하도록 하는 기능을 수행합니다. 기가급 광섬유 사용자에게 있어 광촉매가 기가 전송을 지원하는지 여부가 특히 중요합니다. 만약 광촉매의 WAN 포트가 100메가를 지원한다면, 입구 광섬유 속도가 아무리 높아도 이 병목 현상으로 인해 100메가 이하로 제한됩니다. 마찬가지로 광촉매의 LAN 포트 또한 기가 출력 능력을 갖춰야 하며, 그렇지 않으면 연결된 라우터나 다른 장비는 진정한 기가 속도를 얻을 수 없습니다.&lt;/p&gt;
&lt;h3 id=&#34;라우터-lan-포트-대역폭의-역할&#34;&gt;라우터 LAN 포트 대역폭의 역할
&lt;/h3&gt;&lt;p&gt;라우터의 LAN 포트는 수신된 데이터를 각 단말 장치로 분배하는 역할을 합니다. 라우터의 LAN 포트가 100Mbps인 경우, 다른 장비 설정이 아무리 좋아도 100Mbps 속도의 로컬 네트워크 통신만 가능합니다. 따라서 기가홈 네트워크를 구축할 때는 라우터의 WAN 포트가 기가 데이터를 수신하고, LAN 포트 또한 기가 수준의 데이터 출력 능력을 제공해야 모든 스마트 기기가 고속 네트워크의 원활한 경험을 누릴 수 있습니다.&lt;/p&gt;
&lt;p&gt;또한, 주의해야 할 점은 일부 구형 또는 저가형 라우터는 LAN 포트 자동 협상 기능이 있을 수 있으며, 이는 라우터 자체는 기가비트를 지원하더라도 케이블, 장치 호환성 등의 이유로 속도가 100Mbps 모드로 낮아질 수 있다는 의미입니다. 따라서 기가비트 네트워크를 구현하기 위해서는 라우터 설정을 올바르게 구성하고 강제 기가비트 모드를 활성화하며 기가비트 스위치나 직접 연결된 장치를 함께 사용하는 것이 중요한 단계 중 하나입니다.&lt;/p&gt;
&lt;p&gt;기가급 광섬유로 업그레이드한 후에는 반드시 기가급 ONT와 기가급 공유기로 교체하고, 모든 장비 인터페이스가 기가급 수준인지 확인하십시오&lt;/p&gt;
&lt;h2 id=&#34;제3장-잠재된-미스터리---끊어진-서브-라인이-어떻게-테라비트급-네트워크-속도에-영향을-미치는가&#34;&gt;제3장: 잠재된 미스터리 - 끊어진 서브 라인이 어떻게 테라비트급 네트워크 속도에 영향을 미치는가
&lt;/h2&gt;&lt;h3 id=&#34;서브-라인-장애-및-네트워크-성능-저하&#34;&gt;서브 라인 장애 및 네트워크 성능 저하
&lt;/h3&gt;&lt;p&gt;측정 기간 동안 네트워크 연결은 안정적이었고, 명백한 단절 현상은 없었습니다. 신규 입주형 광대역 회선이라 분배함 내부가 복잡하고, 가끔씩 광모뎀 배선이나 전원 인터페이스 위치를 조정하다 보니 간혹 기가 속도가 측정된 적도 있습니다.&lt;/p&gt;
&lt;p&gt;앞선 자료를 바탕으로 점검한 결과, 랜 케이블 모델과 광케이블 LAN 포트 속도를 분석했더니, 결국 범인은 랜 케이블 내부의 갈색 서브 라인이 끊어진 것이었습니다&lt;/p&gt;
&lt;p&gt;설치 기사님이 크리스탈 헤드를 설치할 때 이 랜선에 조금 세게 힘을 가했고, 그 결과 한 선이 반쯤 끊어졌습니다. 완전히 끊어지지는 않았지만, 이후 광모뎀 위치를 계속 조정하면서 위치를 옮기니 결국 완전히 끊어졌습니다.&lt;/p&gt;
&lt;h3 id=&#34;6가지-네트워크-케이블-8선-기능-분석&#34;&gt;6가지 네트워크 케이블 8선 기능 분석
&lt;/h3&gt;&lt;p&gt;여섯 종류의 네트워크 케이블은 TIA/EIA-568-B 표준을 따르며, 8개의 트위스트 페어 전선으로 구성되어 있으며, 색상 코딩은 다음과 같습니다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;백청 / 청&lt;/li&gt;
&lt;li&gt;백록 / 녹&lt;/li&gt;
&lt;li&gt;흰색 파란색 / 파란색&lt;/li&gt;
&lt;li&gt;갈색&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;기가비트 이더넷(1000BASE-T) 표준 하에, 이 8개의 선 중 4쌍의 선이 동시에 작동하며, 각 역할은 다음과 같습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;백오렌지와 오렌지 이 두 선(1&amp;amp;2)은 데이터 전송(Tx+/-)에 사용됩니다&lt;/li&gt;
&lt;li&gt;백록과 녹색 이 두 선(3&amp;amp;6)은 데이터 수신(Rx+/-)에 사용됩니다&lt;/li&gt;
&lt;li&gt;백란과 남색 쌍(4&amp;amp;5) 및 백갈색과 갈색 쌍(7&amp;amp;8)은 기가비트 이더넷에서 원래 주 용도로 사용되지는 않지만, 일부 고급 애플리케이션(예: 특정 PoE 전원 공급 또는 향후 기술 확장)에서는 활성화될 수 있습니다. 반면 전통적인 100메가비트 네트워크에서는 1, 2, 3, 6번 선만 사용하는 것으로 충분합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;절단된-서브넷이-네트워크-속도에-미치는-영향&#34;&gt;절단된 서브넷이 네트워크 속도에 미치는 영향
&lt;/h3&gt;&lt;p&gt;위와 같은 상황에서 갈색의 부선(갈색 선 또는 갈색 흰색 선)이 끊어지면 이론적으로는 1Gbps 네트워크 환경에서 속도 저하가 발생할 수 있습니다. 왜냐하면 1Gbps 네트워크는 최대 속도를 달성하기 위해 모든 4쌍의 선이 양방향으로 동시에 전송해야 하기 때문입니다. 하지만 가정용 네트워크 장비는 종종 자동 협상 기능을 가지고 있어 케이블 문제를 감지하면 정상적으로 작동하는 낮은 속도 모드, 즉 100Mbps 모드로 전환합니다. 따라서 부선이 끊어져도 네트워크 연결은 유지되고 100Mbps 속도로 작동하는 이유를 설명합니다.&lt;/p&gt;
&lt;p&gt;간단히 말해서, 단일 갈색 보조 광섬유가 끊어진다고 백메가 비트 네트워크의 기본 작동에는 영향을 미치지 않지만, 기가비트 네트워크 환경에서는 네트워크 속도를 제한하는 주요 요인이 될 수 있습니다. 심층적인 진단과 복구 작업을 거쳐야만 기가 광섬유의 잠재력을 완전히 발휘할 수 있습니다. 이는 유사한 상황에 직면했을 때, 기본적인 연결에는 영향을 미치지 않는 것처럼 보이는 작은 결함이라 할지라도 고속 네트워크 경험을 저해하는 숨겨진 장애물이 될 수 있으므로 잠재적인 네트워크 인프라 문제를 간과해서는 안 된다는 점을 시사합니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>WPF UI 스레드와 멈춤 문제 및 해결책</title>
        <link>https://blog.ttf248.life/ko/p/wpf-ui-thread-and-freezing-issues-solutions/</link>
        <pubDate>Tue, 12 Mar 2024 07:12:21 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/wpf-ui-thread-and-freezing-issues-solutions/</guid>
        <description>&lt;p&gt;데스크톱 애플리케이션을 개발할 때, 특히 Windows Presentation Foundation (WPF) 프레임워크를 사용하여 리치 클라이언트 앱을 구축할 때는 UI 스레드를 올바르게 처리하는 것이 애플리케이션의 원활성과 응답성을 보장하는 데 매우 중요합니다. UI 스레드, 또는 메인 스레드는 창 및 컨트롤 이벤트 처리, 레이아웃 계산, 그리고 인터페이스 렌더링을 담당하는 핵심 스레드입니다. UI 요소와의 모든 상호 작용은 UI 스레드에서 실행되어야 하며, 이는 WPF를 비롯한 대부분의 GUI 프레임워크가 따르는 기본 원칙입니다.&lt;/p&gt;
&lt;h2 id=&#34;ui-스레드가-무엇인가요&#34;&gt;UI 스레드가 무엇인가요?
&lt;/h2&gt;&lt;p&gt;WPF 애플리케이션 시작 시 UI 스레드는 운영체제에 의해 생성되고 애플리케이션 주 창을 초기화합니다. 이 스레드만이 직접적으로 UI 구성 요소를 액세스하고 수정할 수 있으며, 버튼 클릭, 텍스트 상자 입력, 창 크기 변경 등 모든 사용자 인터랙션 이벤트는 이 스레드 컨텍스트 내에서 처리됩니다. 또한 WPF의 종속 속성 시스템, 데이터 바인딩 메커니즘 및 레이아웃 로직도 UI 스레드 위에서 동기적으로 실행됩니다.&lt;/p&gt;
&lt;h2 id=&#34;끊김-현상-및-원인&#34;&gt;끊김 현상 및 원인
&lt;/h2&gt;&lt;p&gt;UI 스레드가 장시간 점유되거나 차단될 때, 예를 들어 시간이 오래 걸리는 계산, 대량 데이터 로딩, 데이터베이스 쿼리 또는 기타 I/O 집약적인 작업을 수행할 경우 사용자 상호 작용 요청에 즉시 응답하지 못하여 화면이 응답하지 않는 것처럼 보이는 &amp;ldquo;멈춤&amp;rdquo; 현상이 발생합니다. 이 경우 사용자는 앱의 지연과 끊김을 느끼며 심각한 경우 &amp;ldquo;응답 없음(ANR)&amp;rdquo; 경고가 표시될 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;ui-스레드의-두-가지-기본-규칙&#34;&gt;UI 스레드의 두 가지 기본 규칙
&lt;/h2&gt;&lt;p&gt;위와 같은 상황을 피하기 위해, WPF 개발자는 다음 두 가지 주요 규칙을 준수해야 합니다&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;UI 스레드가 사용자 입력에 즉시 대응하고 화면 렌더링을 처리할 수 있도록, UI 스레드를 일시 중단할 수 있는 작업은 가능한 한 백그라운드 스레드로 옮겨야 합니다&lt;/li&gt;
&lt;li&gt;WPF의 보안 메커니즘 설계상 UI 스레드만이 UI 요소를 수정할 권한을 가지고 있습니다. 다른 스레드에서 직접 UI 상태를 변경하려고 하면 예외가 발생합니다. 따라서 백그라운드 스레드에서 계산이나 데이터 준비가 완료되더라도 적절한 크로스 스레드 통신 메커니즘을 통해 결과를 UI에 표시해야 합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;비동기-프로그래밍-및-스레드-안전-업데이트&#34;&gt;비동기 프로그래밍 및 스레드 안전 업데이트
&lt;/h2&gt;&lt;p&gt;UI의 응답성을 유지하면서도 시간이 오래 걸리는 작업을 수행하기 위해, WPF는 개발자가 이 목표를 달성하도록 돕기 위한 다양한 비동기 프로그래밍 모델과 도구를 제공합니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WPF의 Dispatcher 클래스는 작업 항목을 UI 스레드의 작업 큐에 배치하여 실행할 수 있습니다. __INLINE_CODE_0BOLD_3&lt;code&gt;Dispatcher.BeginInvoke&lt;/code&gt; 메서드를 사용하여 백그라운드 스레드에서 안전하게 UI를 업데이트할 수 있습니다.&lt;/li&gt;
&lt;li&gt;C# 언어의 비동기 기능을 활용하면 비동기 메서드를 작성하고 그 안에서 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 키워드를 사용하여 백그라운드 작업 완료를 기다린 후, 완료되면 자동으로 UI 스레드에서 후속 UI 업데이트 코드를 실행할 수 있습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;사례&#34;&gt;사례
&lt;/h2&gt;&lt;h3 id=&#34;__inline_code_0__-방법을-사용하여-ui를-업데이트합니다&#34;&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 방법을 사용하여 UI를 업데이트합니다
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private void Button_Click(object sender, RoutedEventArgs e)
{
    // 假设这是一个耗时操作
    Task.Run(() =&amp;gt;
    {
        var result = LongRunningOperation(); // 这里是模拟一个耗时计算的方法
        
        // 当耗时操作完成后，在UI线程上更新UI
        Application.Current.Dispatcher.Invoke(() =&amp;gt;
        {
            LabelStatus.Text = $&amp;quot;计算结果: {result}&amp;quot;;
        });
    });
}

private string LongRunningOperation()
{
    // 模拟耗时操作
    Thread.Sleep(5000);
    return &amp;quot;已完成&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;사용-asyncawaitbold_2taskrun&#34;&gt;사용 &lt;code&gt;async/await&lt;/code&gt;BOLD_2&lt;code&gt;Task.Run&lt;/code&gt;
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private async void Button_ClickAsync(object sender, RoutedEventArgs e)
{
    Button button = sender as Button;
    button.IsEnabled = false; // 防止用户重复点击

    try
    {
        // 开启后台任务
        var result = await Task.Run(() =&amp;gt; LongRunningOperation());

        // 在后台任务完成后，自动切换回UI线程更新UI
        LabelStatus.Text = $&amp;quot;计算结果: {result}&amp;quot;;
    }
    catch (Exception ex)
    {
        MessageBox.Show($&amp;quot;发生错误: {ex.Message}&amp;quot;);
    }
    finally
    {
        button.IsEnabled = true; // 重新启用按钮
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>GCC 버전 업그레이드로 인한 프로그램 충돌: 비표준 코드의 잠재적 위험</title>
        <link>https://blog.ttf248.life/ko/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</link>
        <pubDate>Sun, 10 Mar 2024 23:19:06 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</guid>
        <description>&lt;p&gt;동일한 비즈니스 코드의 경우, CentOS 7 환경에서 컴파일 및 실행은 정상적으로 이루어졌지만, CentOS 8로 전환하고 최신 버전의 GCC를 사용하여 컴파일했을 때 프로그램이 충돌했습니다. 주목할 점은 문제가 &lt;strong&gt;Release 模式&lt;/strong&gt;에서만 발생하며, &lt;strong&gt;Debug 模式&lt;/strong&gt;에서는 전혀 문제가 없다는 것입니다. 이와 같은 상황은 처음 경험했으며, 사흘간의 조사 끝에 문제의 근본 원인을 찾았습니다.&lt;/p&gt;
&lt;h3 id=&#34;문제-파악&#34;&gt;문제 파악
&lt;/h3&gt;&lt;p&gt;일련의 점검 결과, 문제의 근본 원인은 &lt;strong&gt;函数缺少返回值&lt;/strong&gt;에 있습니다. Release 모드에서 GCC 최신 버전은 더 많은 최적화를 수행하며, 이로 인해 명시적인 반환 값이 없는 함수의 실행 과정에서 예상치 못한 로직이 발생하여 충돌을 일으킵니다. 결론으로는, &lt;strong&gt;编译器的警告不容忽视，尤其是在老项目中，部分警告可能被无视，但也应当避免屏蔽所有警告&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;h3 id=&#34;환경-설명&#34;&gt;환경 설명
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CentOS 7 GCC版本：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39)
Copyright © 2015 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CentOS 8 GCC版本：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 8.5.0 20210514 (Red Hat 8.5.0-21)
Copyright (C) 2018 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;붕괴-현상&#34;&gt;붕괴 현상
&lt;/h3&gt;&lt;p&gt;프로그램 충돌 스택을 분석하는 과정에서 다음과 같은 스택 정보를 확인했습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[New LWP 1385902]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib64/libthread_db.so.1&amp;quot;.
Core was generated by `./pstack_main`.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007ffe894b4420 in ?? ()
(gdb) bt
#0  0x00007ffe894b4420 in ?? ()
#1  0x00000000004008e9 in main ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 스택은 직관적이지 않아 보이며, 충돌 함수의 스택 정보가 &lt;code&gt;??&lt;/code&gt;으로 표시되어 문제 해결을 더욱 어렵게 만들고 있습니다&lt;/p&gt;
&lt;h3 id=&#34;코드-예시&#34;&gt;코드 예시
&lt;/h3&gt;&lt;p&gt;문제 이해를 돕기 위해, 재현을 위한 최소 코드 예제는 다음과 같습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int test() {
    std::cout &amp;lt;&amp;lt; &amp;quot;1&amp;quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    test();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;해당 코드에서 &lt;code&gt;__INLINE_CODE_0__ 函数显然没有显式返回一个值，而它的返回类型是 __INLINE_CODE_1__BOLD_4&lt;/code&gt;int`` 유형의 경우, 반드시 반환 값이 있어야 하며, 그렇지 않으면 정의되지 않은 동작이 발생할 수 있습니다&lt;/p&gt;
&lt;h3 id=&#34;컴파일-경고&#34;&gt;컴파일 경고
&lt;/h3&gt;&lt;p&gt;프로젝트에서 CMake 스크립트가 여러 컴파일 경고를 숨겼는데, 그중에는 다음과 같은 경고 메시지도 포함되어 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/root/pstack/main.cpp: In function ‘int test()’:
/root/pstack/main.cpp:7:1: warning: no return statement in function returning non-void [-Wreturn-type]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 경고는 &lt;code&gt;test()&lt;/code&gt; 함수가 반환값을 가지지 않는다는 것을 나타내며, 이것이 문제의 근원입니다. GCC의 높은 버전(예: 8.5.0)은 코드를 최적화할 때 이러한 정의되지 않은 동작에 대해 불안정한 최적화를 수행하여 프로그램 충돌을 일으킬 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;어셈블리-코드-차이&#34;&gt;어셈블리 코드 차이
&lt;/h3&gt;&lt;p&gt;GCC 컴파일러 최적화 동작의 차이를 설명하기 위해, 다양한 버전의 GCC가 생성한 어셈블리 코드를 비교했습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GCC 4.8.5 生成的汇编代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;어셈블리 코드는 다소 장황하며, 표준 출력 스트림(예: &lt;code&gt;std::cout&lt;/code&gt;）的处理逻辑。这表明编译器进行了更保守的优化，未对 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; 함수에서 누락된 반환값 문제)에 대한 과도한 최적화를 포함하고 있어, 이로 인해 런타임 오류를 피했을 가능성이 있습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GCC 8.5.0 生成的汇编代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;새 버전의 GCC는 더 많은 최적화를 수행하여 코드 양을 줄였습니다. 하지만 이러한 최적화로 인해 반환 값이 없는 함수의 실행 동작이 정의되지 않아 프로그램이 충돌할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;결론&#34;&gt;결론
&lt;/h3&gt;&lt;p&gt;이번 문제 해결 과정을 통해 C++에서 &lt;strong&gt;函数返回值必须明确&lt;/strong&gt;, 특히 함수 선언이 &lt;code&gt;int&lt;/code&gt;BOLD_2__일 때, 모든 경고를 숨기지 않고, 특히 반환 값, 타입 매칭 등 흔히 발생하는 문제에 대해 선택적으로 처리해야 한다는 것을 깊이 인식하게 되었습니다&lt;/p&gt;
&lt;p&gt;마침내 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 함수에 반환값을 추가하여 문제를 해결하고 프로그램이 정상적으로 작동하게 되었습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>VMware 가상 머신 CPU 리소스 사용량 이상</title>
        <link>https://blog.ttf248.life/ko/p/vmware-virtual-machine-cpu-resource-usage-anomaly/</link>
        <pubDate>Sun, 10 Mar 2024 22:14:59 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/vmware-virtual-machine-cpu-resource-usage-anomaly/</guid>
        <description>&lt;p&gt;로컬 머신에 배포된 Windows 버전 업무 시스템은 CPU 자원 점유율이 약 5% 정도인데, VMware에 설치된 CentOS8 환경의 Linux 버전 업무 시스템은 자원 점유율이 비정상적입니다&lt;/p&gt;
&lt;h2 id=&#34;문제-설명&#34;&gt;문제 설명
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;호스트 시스템: Win10 기업판&lt;/li&gt;
&lt;li&gt;vmware：17.5&lt;/li&gt;
&lt;li&gt;가상 머신: CentOS 8&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;가상 머신 리소스 할당은 &lt;code&gt;4C8GB&lt;/code&gt;이며, 비즈니스 시스템을 시작합니다. 비즈니스 시스템은 가상 머신 Linux 시스템에 배포되어 있으며, 가상 머신 내부의 top 명령어를 통해 시스템 리소스 사용량을 관찰한 결과 CPU 사용량은 높지 않습니다. 하지만 외부 Windows 시스템에서 작업 관리자를 통해 확인했을 때 CPU 리소스 사용량이 매우 높았고, 프로세스를 확인해 보니 VMware 프로세스가 CPU 리소스를 많이 사용하고 있었습니다.&lt;/p&gt;
&lt;p&gt;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+
|         Windows           |
|                           |
|   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+  |
|   |      VMware        |  |
|   |      Program       |  |
|   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+  |
|                           |
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+&lt;/p&gt;
&lt;h2 id=&#34;핵심-개념&#34;&gt;핵심 개념
&lt;/h2&gt;&lt;p&gt;이 문제 해결은 순탄치 않았는데, 도화선이 비즈니스 시스템 자체가 아니라 가상 머신 자체의 문제였기 때문이다. 어떻게 하면 일반적인 비즈니스 코드에서 벗어나 시스템 부하로 사고를 전환하고, 부하 데이터의 이상 현상을 통해 소프트 인터럽트를 찾아내어 결국 핵심에 다다를 수 있을까? 무엇이 VMware 소프트 인터럽트의 효율성을 저해하는 것일까? 본 글에서는 먼저 관련 지식을 설명하고 마지막으로 해결책을 제시한다.&lt;/p&gt;
&lt;h3 id=&#34;hyper-v&#34;&gt;hyper-v
&lt;/h3&gt;&lt;p&gt;윈도우 운영 체제의 가상화 기술에 큰 변화가 있었습니다. 마이크로소프트가 WSL을 처음 출시했을 때 Hyper-V 서비스를 활성화하면 VMware 가상 머신을 동시에 사용할 수 없었습니다. 이후 버전에서 VMware는 Hyper-V 서비스와 호환되게 되었습니다.&lt;/p&gt;
&lt;h3 id=&#34;시스템-부하&#34;&gt;시스템 부하
&lt;/h3&gt;&lt;p&gt;리눅스 시스템에서 &amp;ldquo;로드(load)&amp;ldquo;는 실행 중이거나 실행을 기다리는 프로세스의 수를 의미합니다. 로드는 일반적으로 1분, 5분, 15분 동안의 실행 대기열에 있는 평균 프로세스 수를 나타내는 세 자리 숫자로 표시됩니다. 이러한 숫자는 &amp;ldquo;uptime&amp;rdquo; 또는 &amp;ldquo;top&amp;rdquo; 명령어를 실행하여 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;구체적으로, 이 세 숫자는 각각을 의미합니다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;1分钟负载&lt;/strong&gt;: 시스템이 지난 1분 동안 실행한 평균 프로세스 수입니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;5分钟负载&lt;/strong&gt;: 시스템은 지난 5분 동안 실행 중인 프로세스 평균 수를 나타냅니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;15分钟负载&lt;/strong&gt;: 시스템은 지난 15분 동안 실행 중인 프로세스 평균 수를 나타냅니다&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;부하란 시스템에서 실행을 기다리는 프로세스 수를 의미합니다. 이 숫자가 시스템의 논리 CPU 수보다 높으면 시스템 부하가 높다는 뜻이며, 많은 프로세스가 프로세서 자원을 기다리고 있음을 나타냅니다. 이는 시스템이 느려지거나 응답하지 않을 수 있으며, 부하 정도와 시스템 구성 및 성능에 따라 달라집니다.&lt;/p&gt;
&lt;p&gt;이상적으로는, 부하가 시스템의 논리 CPU 수 범위 내에 유지되어야 시스템 성능을 최적화할 수 있습니다. 부하가 지속적으로 CPU 수보다 높다면, 시스템 프로세스를 추가적으로 분석하여 높은 부하의 원인을 파악하고, 시스템 리소스 할당 조정 또는 프로세스 실행 방식 최적화를 위한 조치를 취해야 합니다.&lt;/p&gt;
&lt;h3 id=&#34;mpstat-로드-분석&#34;&gt;mpstat 로드 분석
&lt;/h3&gt;&lt;p&gt;부하 분석 절차:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;安装 sysstat&lt;/strong&gt;:
__INLINE_CODE_0__이 설치되어 있지 않다면, 시스템에 적합한 패키지 관리 도구를 사용하여 설치할 수 있습니다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;运行 mpstat&lt;/strong&gt;:
자원 사용을 나타냄&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;01:32:33 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
01:32:35 PM  all    0.00    0.00    0.26    0.00    3.73    0.26    0.00    0.00    0.00   95.76
01:32:35 PM    0    0.00    0.00    0.51    0.00    3.57    0.00    0.00    0.00    0.00   95.92
01:32:35 PM    1    0.00    0.00    0.00    0.00    3.59    0.51    0.00    0.00    0.00   95.90
01:32:35 PM    2    0.00    0.00    0.00    0.00    4.15    0.00    0.00    0.00    0.00   95.85
01:32:35 PM    3    0.00    0.00    0.52    0.00    3.61    0.52    0.00    0.00    0.00   95.36
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分析输出&lt;/strong&gt;:
__INLINE_CODE_0__의 출력은 각 CPU 사용률과 시스템 평균 부하를 포함합니다. 평균 부하와 각 CPU 사용률에 특히 주의하면 시스템 부하 상황을 파악하는 데 도움이 됩니다. 부하가 높다면, 어떤 프로세스가 원인인지 추가 분석하고 성능 병목 현상이 있는지 확인할 수 있습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;结合其他工具&lt;/strong&gt;:
다양한 도구들을 활용하여 시스템 성능을 종합적으로 분석합니다. 여러 도구의 결과를 결합하면 시스템 부하 상황을 보다 포괄적으로 파악하고, 성능 문제의 근본 원인을 찾아낼 수 있습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;중단&#34;&gt;중단
&lt;/h3&gt;&lt;p&gt;여기 내용은 너무 자세히 설명하지 않겠습니다
추천: &lt;a class=&#34;link&#34; href=&#34;https://www.codedump.info/post/20200522-sgfap-softirq/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《面向应用开发者的系统指南》CPU篇之软中断&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;잦은 소프트웨어 인터럽트 발생은 시스템 부하에도 반영된다&lt;/p&gt;
&lt;h2 id=&#34;문제-해결&#34;&gt;문제 해결
&lt;/h2&gt;&lt;p&gt;CPU 관점만으로는 문제 위치를 파악하기 어렵다면, 시스템에 이상이 발생했을 가능성을 의심해야 할까요? Linux 운영체제의 과도한 부하로 인해 VMware가 지나치게 많은 CPU 자원을 사용하고 있을 수도 있습니다. &lt;code&gt;mpstat&lt;/code&gt;分析本地虚拟机，我们发现&lt;code&gt;irq&lt;/code&gt;占用异常，单核接近25%，而在正常情况下，启动业务进程空跑时，&lt;code&gt;irq&lt;/code&gt;의 비율은 약 5% 정도여야 합니다.&lt;/p&gt;
&lt;p&gt;팀 내 동료의 개발 환경에서 그의 CentOS 7은 VMware에 배포되었으며, 자원 사용량은 정상적으로 표시됩니다. 반면 상하이 개발 환경에서는 동일하게 VMware이지만 호스트 CPU 자원 상황을 직접 관찰할 수 없습니다. 이 때 우리는 VMware 가상 머신, Linux 운영체제 및 GCC 버전을 포함한 여러 변수를 고려해야 합니다.&lt;/p&gt;
&lt;p&gt;물리 서버에 배포되고, 저 버전 GCC 컴파일 서비스가 실행 중이며, CentOS 8 위에서 운영되는 선전 테스트 환경으로 분석을 전환해 보면, __INLINE_CODE_0__의 사용량은 정상입니다&lt;/p&gt;
&lt;p&gt;문제 해결을 위해 GCC 최신 버전으로 컴파일된 프로그램을 선전 환경에 배포하여 테스트한 결과 모두 정상 작동했습니다&lt;/p&gt;
&lt;p&gt;문제는 좀 더 명확해지는 듯하고, 운영체제에 문제가 있는 건 아닌지 의심하기 시작했습니다. 결국 CentOS 8은 공식 지원이 종료되었으니까요. 하지만 깨끗한 CentOS 7과 CentOS 8을 다시 배포해도 문제는 여전히 발생합니다.&lt;/p&gt;
&lt;p&gt;지금, VMware 가상화 소프트웨어가 유일한 불확실성 요소인 것 같다는 의심이 들기 시작했다. 갑자기 아이디어가 떠올랐다. 혹시 Hyper-V 기술을 이전에 활성화했지만 완전히 종료하지 않아 이런 문제가 발생했을까? 결국, 소프트 인터럽트도 가상화 소프트웨어를 통해 구현되므로, 서로 다른 가상화 기술에 버그가 있을 가능성은 없는지 심층적인 고민과 조사가 필요하다.&lt;/p&gt;
&lt;h2 id=&#34;결론&#34;&gt;결론
&lt;/h2&gt;&lt;p&gt;마이크로소프트 공식 매뉴얼에 따르면, 로컬 Hyper-V 서비스를 완전히 종료한 후 VMware가 호스트에서 정상적으로 복구되었습니다. 덕분에 문제는 마침내 해결되었습니다. 처음 설명했듯이, 이 경험은 굴곡지고 고되었으며 종합적인 분석과 판단이 필요했습니다. 또한, 이번 문제 해결 과정에서 처음으로 VM 수준까지 추적하게 되었습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Disable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V-Hypervisor
bcdedit /set hypervisorlaunchtype off
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/application-management/virtualization-apps-not-work-with-hyper-v&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/application-management/virtualization-apps-not-work-with-hyper-v&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43; 프로그래밍의 함정: `std::map` 오용으로 인한 프로그램 충돌 상세 분석</title>
        <link>https://blog.ttf248.life/ko/p/cpp-programming-traps-std-map-crash-details/</link>
        <pubDate>Sun, 10 Mar 2024 22:03:06 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/cpp-programming-traps-std-map-crash-details/</guid>
        <description>&lt;p&gt;C++ 프로그래밍에서 &lt;code&gt;std::map&lt;/code&gt; 컨테이너를 잘못 사용하면 프로그램이 충돌할 수 있습니다. 대괄호 연산자로 존재하지 않는 키에 접근하려 할 때 자동으로 빈 요소가 추가되기 때문입니다. 이 오해를 자세히 분석하고 예제 코드를 통해 잠재적인 위험을 보여드리겠습니다.&lt;/p&gt;
&lt;p&gt;저장하는 값이 단순한 값이라면 문제가 없지만, 포인터라면 문제가 발생할 수 있습니다. 포인터는 주소이고, 초기화되지 않은 주소는 불확실하기 때문에 프로그램이 충돌할 수 있습니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;C++ 표준 라이브러리에서 __INLINE_CODE_0__是一种关联容器，它按照键（key）的升序存储元素，并提供了高效的关键字查找功能。然而，新手开发者有时会因为对__INLINE_CODE_1__中括号操作符 &lt;code&gt;[]&lt;/code&gt; 的行为理解有误而陷入困境。实际上，当使用 __INLINE_CODE_3__BOLD_8&lt;code&gt;std::map&lt;/code&gt;은 새로운 키-값 쌍을 삽입하고, 기본 생성자를 사용하여 해당 키에 대응하는 값 타입의 초기화를 수행합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int main() {
    std::map&amp;lt;std::string, int&amp;gt; myMap;
    
    // 错误的用法：假设这里试图访问一个不存在的键并认为会得到0
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for &#39;nonexistent_key&#39;: &amp;quot; &amp;lt;&amp;lt; myMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;

    // 实际上，上述行代码创建了一个新的键值对，其中值被默认初始化为int的默认值（通常是0）
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 코드 자체는 프로그램 충돌을 직접적으로 유발하지는 않지만, 이러한 암묵적인 삽입 동작은 특정 상황에서 예상치 못한 부작용(예: 리소스 누수 또는 예기치 않은 상태 변경)을 초래할 수 있습니다. 더 나쁜 경우, 다중 스레드 환경에서 초기화되지 않은 메모리 영역에 대한 동시 접근은 프로그램 충돌로 이어질 수도 있습니다.&lt;/p&gt;
&lt;p&gt;이러한 문제가 발생하는 것을 방지하기 위해, &lt;code&gt;std::map::find()&lt;/code&gt;BOLD_3&lt;code&gt;std::map::count()&lt;/code&gt;BOLD_4&lt;code&gt;std::map::insert()&lt;/code&gt; 요소를 명시적으로 삽입하는 것이 좋습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::map&amp;lt;std::string, int&amp;gt; safeMap;
if (safeMap.count(&amp;quot;nonexistent_key&amp;quot;) == 0) {
    std::cout &amp;lt;&amp;lt; &amp;quot;Key does not exist.&amp;quot; &amp;lt;&amp;lt; std::endl;
} else {
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for existing key: &amp;quot; &amp;lt;&amp;lt; safeMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;
}

// 或者明确插入一个键值对，指定初始值
safeMap.insert({ &amp;quot;new_key&amp;quot;, 0 });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;만약 map 컨테이너 내부에 저장된 객체가 포인터 타입이라면, 자동 삽입 동작은 초기화되지 않은 포인터를 저장하며, 이 포인터를 사용하는 모든 작업은 프로그램 충돌을 야기할 수 있습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>pstack으로 프로세스 멈춤 현상 진단</title>
        <link>https://blog.ttf248.life/ko/p/pstack-troubleshooting-process-hang/</link>
        <pubDate>Sat, 24 Feb 2024 23:55:59 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/pstack-troubleshooting-process-hang/</guid>
        <description>&lt;p&gt;소프트웨어 개발 및 운영 환경에서 프로세스 응답 없음 현상이 자주 발생하는데, 이로 인해 시스템 성능 저하나 서비스 중단이 발생할 수 있습니다. 본 문서에서는 pstack 도구를 사용하여 프로세스 응답 없음 문제를 진단하고, 프로세스 스택 정보를 분석하여 문제 원인을 파악하고 해결하는 방법을 설명합니다.&lt;/p&gt;
&lt;p&gt;배경: 위험 관리 시스템 하위 서비스가 응답하지 않는 상태로 멈춰 위험 관리 서비스를 사용할 수 없게 되었습니다. 서비스 가용성 모니터링 부족으로 인해 프로세스 응답 없음 상황을 즉시 파악하지 못해 시스템이 중단되었습니다.&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;프로세스 응답 없음은 프로세스가 중단되어 응답하지 않지만 종료되지 않은 상태를 의미합니다. 이는 데드락, 리소스 고갈, 예외 등 다양한 원인으로 발생할 수 있습니다. 이러한 문제를 해결하기 위해 pstack 도구를 사용하여 프로세스의 스택 정보를 분석하고 문제의 근본 원인을 파악할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;단계&#34;&gt;단계
&lt;/h2&gt;&lt;p&gt;pstack은 일반적으로 gdb(GNU 디버거)와 함께 제공되는 유용한 도구입니다. 다음 명령어를 통해 설치할 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt-get install gdb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;프로세스 ID 획득: 먼저, 응답하지 않는 프로세스의 프로세스 ID(PID)를 얻어야 합니다. ps 명령어를 사용하여 모든 프로세스를 나열하고, 문제 해결이 필요한 프로세스 ID를 찾을 수 있습니다.
pstack 도구를 사용하여 프로세스 스택을 분석할 수 있습니다. 프로세스 ID를 얻은 후에는 pstack 도구를 사용하여 해당 프로세스의 스택 정보를 가져올 수 있습니다. 다음 명령어를 실행하세요:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pstack &amp;lt;PID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 프로세스의 스택 정보를 출력하여 현재 실행 중인 함수 호출 시퀀스를 보여줍니다. 이러한 정보를 분석하면 프로세스가 멈춘 위치를 파악하고 문제를 진단할 수 있습니다.&lt;/p&gt;
&lt;p&gt;스택 정보를 분석하면 프로세스가 멈추는 원인을 파악할 수 있습니다. 데드락, 무한 루프 또는 기타 예외 상황이 발견될 수 있으며, 잠금 해제나 코드 로직 수정 등 구체적인 상황에 맞는 조치를 취해야 합니다.&lt;/p&gt;
&lt;h2 id=&#34;사례&#34;&gt;사례
&lt;/h2&gt;&lt;p&gt;간단한 데모인데, 메인 함수 실행 후 서브 스레드를 새로 생성하고 실제 실행 함수가 무한 루프에 들어가 프로그램이 정상적으로 종료되지 않고 멈춰버리는 상태입니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cmake_minimum_required(VERSION 3.0.0)
project(pstack_main VERSION 0.1.0 LANGUAGES C CXX)

include(CTest)
enable_testing()

# 查找线程库
find_package(Threads REQUIRED)

add_executable(pstack_main main.cpp)

# 链接线程库
target_link_libraries(pstack_main PRIVATE Threads::Threads)

set(CPACK_PROJECT_NAME ${PROJECT_NAME})
set(CPACK_PROJECT_VERSION ${PROJECT_VERSION})
include(CPack)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;
#include &amp;lt;chrono&amp;gt;

void infiniteLoop() {
    while (true) {
        // 主线程进入死循环
    }
}

int main() {
    std::thread thread(infiniteLoop); // 创建一个线程，执行死循环函数
    thread.join(); // 等待线程结束
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;프로그램 시작, pstack 결과:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Thread 2 (Thread 0x7eff3619b700 (LWP 1315017)):
#0  infiniteLoop () at /root/pstack/main.cpp:6
#1  0x0000000000402ca9 in std::__invoke_impl&amp;lt;void, void (*)()&amp;gt; (__f=@0x2260eb8: 0x4029a6 &amp;lt;infiniteLoop()&amp;gt;) at /usr/include/c++/8/bits/invoke.h:60
#2  0x0000000000402b02 in std::__invoke&amp;lt;void (*)()&amp;gt; (__fn=@0x2260eb8: 0x4029a6 &amp;lt;infiniteLoop()&amp;gt;) at /usr/include/c++/8/bits/invoke.h:95
#3  0x0000000000403150 in std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt;::_M_invoke&amp;lt;0ul&amp;gt; (this=0x2260eb8) at /usr/include/c++/8/thread:244
#4  0x0000000000403126 in std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt;::operator() (this=0x2260eb8) at /usr/include/c++/8/thread:253
#5  0x000000000040310a in std::thread::_State_impl&amp;lt;std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt; &amp;gt;::_M_run (this=0x2260eb0) at /usr/include/c++/8/thread:196
#6  0x00007eff36bceb23 in execute_native_thread_routine () from /lib64/libstdc++.so.6
#7  0x00007eff36ea91ca in start_thread () from /lib64/libpthread.so.0
#8  0x00007eff361d58d3 in clone () from /lib64/libc.so.6
Thread 1 (Thread 0x7eff372e1740 (LWP 1315016)):
#0  0x00007eff36eaa6cd in __pthread_timedjoin_ex () from /lib64/libpthread.so.0
#1  0x00007eff36bceda7 in std::thread::join() () from /lib64/libstdc++.so.6
#2  0x00000000004029d2 in main () at /root/pstack/main.cpp:13
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;프로세스 응결의 원인은 데드루프이며, 메인 스레드가 데드루프에 진입하면 서브 스레드가 종료되지 않아 프로세스가 응결됩니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43; 함수 호출 시간</title>
        <link>https://blog.ttf248.life/ko/p/cpp-function-call-timing/</link>
        <pubDate>Wed, 24 Jan 2024 14:11:33 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/cpp-function-call-timing/</guid>
        <description>&lt;p&gt;다양한 콜백 함수 구현 방식에 맞춰 설계 시나리오 SDK를 위한 시간 소모적인 테스트를 진행했습니다. 최근 C++ 함수 프로그래밍을 살펴보고 있는데, 함수가 일급 시민이 되어 프로그램 내에서 자유롭게 흐르는 경우 성능 차이가 있을까요?&lt;/p&gt;
&lt;p&gt;이전 링크: &lt;a class=&#34;link&#34; href=&#34;https://blog.ttf248.life/ko/p/compiler-callback-function-performance-testing/&#34; &gt;编译器、回调函数、性能测试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大佬刚好也做了类似的测试，借代码一用。 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 비슷한 테스트를 이미 해 두신 분에게 코드를 빌려 썼다&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;실행 플랫폼은 여전히 우리의 든든한 친구, &lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;cassert&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

int add_one(int input) { return input + 1; }

bool validate_vector_add_one(std::vector&amp;lt;int&amp;gt; const&amp;amp; input_vector,
                             std::vector&amp;lt;int&amp;gt; const&amp;amp; output_vector)
{
    bool is_valid{true};
    for (size_t i{0}; i &amp;lt; input_vector.size(); ++i)
    {
        if (output_vector.at(i) != input_vector.at(i) + 1)
        {
            is_valid = false;
            break;
        }
    }
    return is_valid;
}

void reset_vector(std::vector&amp;lt;int&amp;gt;&amp;amp; input_vector)
{
    for (size_t i{0}; i &amp;lt; input_vector.size(); ++i)
    {
        input_vector.at(i) = 0;
    }
}

template &amp;lt;typename T, typename Func&amp;gt;
void unitary_function_pass_by_lambda_function(T&amp;amp; output, T const&amp;amp; input,
                                              Func const func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_std_function_value(T&amp;amp; output, T const&amp;amp; input,
                                                 std::function&amp;lt;T(T)&amp;gt; const func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_std_function_reference(
    T&amp;amp; output, T const&amp;amp; input, std::function&amp;lt;T(T)&amp;gt; const&amp;amp; func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_function_pointer(T&amp;amp; output, T const&amp;amp; input,
                                               T (*func)(T))
{
    output = func(input);
}

int main()
{
    // Set floating point format std::cout with 3 decimal places.
    std::cout.precision(3);

    size_t const num_elements{10000000};
    std::vector&amp;lt;int&amp;gt; input_vector(num_elements, 0);
    std::vector&amp;lt;int&amp;gt; output_vector(num_elements, 0);

    auto const lambda_function_add_one{[](int const&amp;amp; input) -&amp;gt; int
                                       { return input + 1; }};
    std::function&amp;lt;int(int)&amp;gt; const std_function_add_one{lambda_function_add_one};

    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a function pointer: &amp;quot; &amp;lt;&amp;lt; sizeof(&amp;amp;add_one)
              &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a std::function pointer: &amp;quot;
              &amp;lt;&amp;lt; sizeof(&amp;amp;std_function_add_one) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a std::function: &amp;quot; &amp;lt;&amp;lt; sizeof(std_function_add_one)
              &amp;lt;&amp;lt; std::endl;

    // Call function frequently in a vanilla way.
    // The compiler knows what function to call at compile time and can optimize
    // the code.
    // This is the best performance we could get.
    std::chrono::steady_clock::time_point const time_start_vanilla{
        std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        output_vector.at(i) = add_one(input_vector.at(i));
    }
    std::chrono::steady_clock::time_point const time_end_vanilla{
        std::chrono::steady_clock::now()};
    auto const time_elapsed_vanilla{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(time_end_vanilla -
                                                             time_start_vanilla)
            .count()};
    float const latency_vanilla{time_elapsed_vanilla /
                                static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass Vanilla: &amp;quot; &amp;lt;&amp;lt; latency_vanilla &amp;lt;&amp;lt; &amp;quot; ns&amp;quot;
              &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // Sometimes, we don&#39;t know what function to call at compile time.
    // We can use std::function to pass a function as an argument.
    // In this case, we pass the std::function by value.
    // Because the size of a std::function is 32 bytes, passing by value
    // results in a lot of copying and bad performance.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_std_function_value{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_std_function_value(
            output_vector.at(i), input_vector.at(i), std_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_std_function_value{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_std_function_value{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_std_function_value -
            time_start_pass_by_std_function_value)
            .count()};
    float const latency_pass_by_std_function_value{
        time_elapsed_pass_by_std_function_value /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Std Function Value: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_std_function_value &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // Instead of passing the std::function by value, we can pass it by
    // reference (pointer). In this case, object copying is eliminated. The
    // performance is better than passing the std::function by value. However,
    // the performance is still not as good as the vanilla way.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_std_function_reference{
            std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_std_function_reference(
            output_vector.at(i), input_vector.at(i), std_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_std_function_reference{
            std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_std_function_reference{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_std_function_reference -
            time_start_pass_by_std_function_reference)
            .count()};
    float const latency_pass_by_std_function_reference{
        time_elapsed_pass_by_std_function_reference /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Std Function Reference: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_std_function_reference &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // std::function is a general purpose wrapper for function pointers,
    // callable objects, and lambda functions. Because it&#39;s general purpose,
    // it&#39;s not as efficient as a function pointer. In this case, we pass a
    // function pointer to a function. The performance is better than passing
    // the std::function by reference.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_function_pointer{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_function_pointer(output_vector.at(i),
                                                  input_vector.at(i), &amp;amp;add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_function_pointer{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_function_pointer{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_function_pointer -
            time_start_pass_by_function_pointer)
            .count()};
    float const latency_pass_by_function_pointer{
        time_elapsed_pass_by_function_pointer /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Function Pointer: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_function_pointer &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // We can also pass a lambda function to a function.
    // The compiler knows what function to call at compile time and can optimize
    // the code. The performance is also better than passing the std::function
    // by reference.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_lambda_function{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_lambda_function(
            output_vector.at(i), input_vector.at(i), lambda_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_lambda_function{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_lambda_function{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_lambda_function -
            time_start_pass_by_lambda_function)
            .count()};
    float const latency_pass_by_lambda_function{
        time_elapsed_pass_by_lambda_function /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Lambda Function: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_lambda_function &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 组里常规也就开启 O2 优化，编译选用了 gcc13，不同版本的 gcc 性能耗时略有不同，版本越高 lambda 效果越好
The size of a function pointer: 8
The size of a std::function pointer: 8
The size of a std::function: 32
Latency Pass Vanilla: 0.418 ns
Latency Pass By Std Function Value: 3.47 ns
Latency Pass By Std Function Reference: 1.36 ns
Latency Pass By Function Pointer: 0.396 ns
Latency Pass By Lambda Function: 0.44 ns
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leimao.github.io/blog/CPP-Function-Call-Performance/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://leimao.github.io/blog/CPP-Function-Call-Performance/&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>디버깅을 어떻게 막아야 할까요?</title>
        <link>https://blog.ttf248.life/ko/p/program-how-to-anti-debug/</link>
        <pubDate>Tue, 23 Jan 2024 19:46:36 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/program-how-to-anti-debug/</guid>
        <description>&lt;p&gt;뜻밖에도 새로운 배경화면을 찾아보게 됐는데, 역시 검은색 계열이 좋고, 부분적으로 색감을 넣으면 좋겠다. 바탕 화면에 아이콘을 배치해야 하니 다른 색상의 배경화면을 사용하면 아이콘이 잘 보이지 않을 것 같아.&lt;/p&gt;
&lt;p&gt;위에 있는 어셈블리 코드 보고 생각 좀 해봤는데, 무슨 말인지 모르겠어. __INLINE_CODE_0__에게 맡겨서 명령어를 설명받았지만, 상황은 설명 안 해주네. 분명 특수한 상황에서만 쓰이는 명령어인 것 같아. 일반적인 코드는 이런식으로 생기지 않아.&lt;/p&gt;
&lt;p&gt;지금은 검색 엔진이 더 나을 것 같아요, 어셈블리 지식이 부족하니까요&lt;/p&gt;
&lt;h2 id=&#34;벽지&#34;&gt;벽지
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/program-how-to-anti-debug/Snipaste_2024-01-23_19-50-53.png&#34;
	width=&#34;1020&#34;
	height=&#34;470&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;黑色汇编壁纸&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;217&#34;
		data-flex-basis=&#34;520px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;어셈블리-코드&#34;&gt;어셈블리 코드
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;PUSHFD
MOV DWORD PTR [ESP],0X100
POPFD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;실제 사용 시나리오&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool IsDebugged()
{
    __try
    {
        __asm
        {
            pushfd
            mov dword ptr [esp], 0x100
            popfd
            nop
        }
        return true;
    }
    __except(GetExceptionCode() == EXCEPTION_SINGLE_STEP
        ? EXCEPTION_EXECUTE_HANDLER
        : EXCEPTION_CONTINUE_EXECUTION)
    {
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;설명&#34;&gt;설명
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;TrapFlag&lt;/code&gt;강조_2&lt;code&gt;SINGLE_STEP&lt;/code&gt;，우리가 코드를 추적하면 이 플래그는 디버거에 의해 초기화되므로 예외를 볼 수 없습니다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;실제 테스트 결과, 검사 디버깅 함수를 직접 건너뛰면 디버깅이 감지되지 않지만, 검사 함수 실행 시에만 감지되는 것으로 나타났다 (자료 조사 중이며 아직 실제 확인은 되지 않았다)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;p&gt;관련 자료는 웹사이트의 영문 원본을 번역한 것이며, 사이트에서는 다양한 디버깅 방지 기술에 대해 설명하고 있습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://anti-debug.checkpoint.com/techniques/assembly.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://anti-debug.checkpoint.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://song-10.gitee.io/2021/08/08/Reverse-2021-08-08-anti-debug/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://song-10.gitee.io/2021/08/08/Reverse-2021-08-08-anti-debug/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>초점 인터뷰/CCTV 비디오 파일을 어떻게 다운로드하나요?</title>
        <link>https://blog.ttf248.life/ko/p/how-to-download-focus-interview-cctv-video-files/</link>
        <pubDate>Tue, 23 Jan 2024 19:23:35 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/how-to-download-focus-interview-cctv-video-files/</guid>
        <description>&lt;p&gt;최근에 누가 물어봤는데, 시사 인터뷰 영상 다운로드하는 방법이 있냐고. 머리 속에는 거의 틀림없이 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 방식으로 암호화되어 있을 거라고 생각했는데, 간단히 처리했다.&lt;/p&gt;
&lt;h2 id=&#34;다운로더&#34;&gt;다운로더
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/nilaoda/N_m3u8DL-CLI&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/nilaoda/N_m3u8DL-CLI&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;오픈 소스 명령줄 m3u8/HLS/dash 다운로더입니다. 일반적인 AES-128-CBC 복호화, 멀티 스레드, 사용자 지정 헤더 등을 지원합니다. 간체 중국어, 번체 중국어 및 영어를 지원합니다.&lt;/p&gt;
&lt;h2 id=&#34;브라우저-플러그인&#34;&gt;브라우저 플러그인
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://microsoftedge.microsoft.com/addons/detail/ngjclnbcdbahekojpkhancmiobdahemb&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Live Stream Downloader&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;달콤한-자신감&#34;&gt;달콤한 자신감
&lt;/h2&gt;&lt;p&gt;주소를 받았다고 생각했는데, 아무것도 아니었고, 분단 내용을 정상적으로 파싱할 수 없었습니다. 자료를 검색해 보니 공식에서 다운로드 주소를 처리해서, 플러그인이 해석한 __INLINE_CODE_0__을 아래 링크에 수동으로 복사하여 교체해야 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;https://newcntv.qcloudcdn.com/asp/hls/2000/0303000a/3/default/***********************/2000.m3u8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2024년 1월까지 주소 테스트는 유효하며, 이후 변경 사항은 웹페이지에서 직접 확인하시기 바랍니다&lt;/p&gt;
&lt;p&gt;이전 주소 백업: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://jln.cn/post/517.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://jln.cn/post/517.html&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>SQL Server 데이터베이스 디스크 파일 권한 일괄 수정</title>
        <link>https://blog.ttf248.life/ko/p/bulk-modify-sqlserver-database-disk-file-permissions/</link>
        <pubDate>Tue, 23 Jan 2024 19:06:36 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/bulk-modify-sqlserver-database-disk-file-permissions/</guid>
        <description>&lt;p&gt;회사 보안 정책 변경으로 인해 &lt;strong&gt;이탤릭체_5__굵게_3__이탤릭체_6__굵게_4__이탤릭체_7&lt;/strong&gt;, 활성화 방법이 비정규적이어서, 집에서는 활성화하지 않아도 괜찮은 것 같습니다&lt;/p&gt;
&lt;p&gt;비정상적인 방식으로 활성화하여 마이크로소프트의 검사를 트리거했는데 (반달 동안 정상적으로 실행되었음), 서버는 부팅 한 시간 후 자동으로 종료되었습니다. 시스템 로그를 뒤져보니 불법 복제본 문제였습니다.&lt;/p&gt;
&lt;p&gt;방법이 없네요, 시스템을 다시 설치해야겠어요. __INLINE_CODE_0__도 재설치를 해야 하고, 할 때마다 골치 아파요. 파일 권한 관리가 엄격해서 데이터베이스를 정상적으로 추가할 수 없네요.&lt;/p&gt;
&lt;h2 id=&#34;오류-정보&#34;&gt;오류 정보
&lt;/h2&gt;&lt;p&gt;시스템을 재설치한 후, &lt;code&gt;SqlServer&lt;/code&gt; 부가 데이터베이스에서 5120 오류, 운영체제 접근 거부 발생할 수 있습니다&lt;/p&gt;
&lt;h2 id=&#34;스크립트-처리&#34;&gt;스크립트 처리
&lt;/h2&gt;&lt;p&gt;이전 링크: &lt;a class=&#34;link&#34; href=&#34;https://blog.ttf248.life/ko/p/bulk-update-local-git-repository-and-legacy-permission-issues/&#34; &gt;批量更新本地Git仓库&lt;/a&gt;, 변함없이 익숙한 스크립트입니다. 폴더를 순회하면서 파일 권한을 수정하는데, 현재는 완전 편집 권한을 부여합니다.&lt;/p&gt;
&lt;p&gt;온라인 튜토리얼은 대부분 수동 수정인데, 그들은 몇 개의 파일만 수정하는 건가? 나는 항상 한꺼번에 많은 파일을 처리해야 하고, 전부 수동으로 하려니 사람이 지쳐&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$currentUserName = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8
$rootDirectory = &amp;quot;D:\data\2013_RujiaInfo&amp;quot;

Get-ChildItem -Path $rootDirectory -Recurse | ForEach-Object {
    $itemPath = $_.FullName

    if ($_ -is [System.IO.DirectoryInfo]) {
        $icaclsResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            Write-Host &amp;quot;已更改文件夹 $itemPath 的所有者为 $currentUserName&amp;quot;
            # 授予当前用户写入权限
            Invoke-Expression &amp;quot;icacls `&amp;quot;$itemPath`&amp;quot; /grant `&amp;quot;$($currentUserName):(OI)(CI)F`&amp;quot;&amp;quot;
            Write-Host &amp;quot;已授予 $currentUserName 编辑文件夹的权限&amp;quot;
        } else {
            Write-Host &amp;quot;无法更改文件夹 $itemPath 的所有者。错误信息: $icaclsResult&amp;quot;
        }
    } else {
        $takeownResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            # 授予当前用户写入权限
            Invoke-Expression &amp;quot;icacls `&amp;quot;$itemPath`&amp;quot; /grant `&amp;quot;$($currentUserName):(F)`&amp;quot;&amp;quot;
            Write-Host &amp;quot;已授予 $currentUserName 编辑文件的权限&amp;quot;
        } else {
            Write-Host &amp;quot;无法更改文件 $itemPath 的所有者。错误信息: $takeownResult&amp;quot;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>리눅스 시스템 벤치마크 테스트</title>
        <link>https://blog.ttf248.life/ko/p/linux-system-benchmark-test/</link>
        <pubDate>Tue, 09 Jan 2024 10:56:23 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/linux-system-benchmark-test/</guid>
        <description>&lt;p&gt;윈도우 플랫폼에는 루마스터(유희 마스터)라는 프로그램이 있는데, 데이터가 정확하다고는 할 수 없지만 참고 자료 정도는 된다. 물론 다른 전문 벤치마크 소프트웨어도 있고, 리눅스 시스템에서는 특별히 적합한 벤치마크 프로그램을 찾은 적은 없는 것 같다.&lt;/p&gt;
&lt;p&gt;Sysbench는 CPU, 메모리, 파일 I/O, 스레드 성능 등 다양한 기능을 테스트할 수 있는 다목적 벤치마크 도구입니다. 다양한 성능 테스트 작업을 수행하는 데 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;테스트에 사용할 기기가 세 대 있습니다: 메커니즘 미니 로컬 호스트, 알리바바 클라우드 개발 클라우드 서버, 화웨이 클라우드 개발 서버&lt;/p&gt;
&lt;h2 id=&#34;sysbench-설치&#34;&gt;Sysbench 설치
&lt;/h2&gt;&lt;p&gt;대부분의 Linux 배포판에서 패키지 관리 도구를 사용하여 Sysbench를 설치할 수 있습니다. 예를 들어 CentOS 8에서는 다음 명령어를 사용하여 설치할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo dnf install sysbench
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sysbench-사용-예시&#34;&gt;Sysbench 사용 예시
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CPU 성능 테스트: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;메모리 읽기 성능 테스트: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;테스트 파일 I/O 성능:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysbench --test=fileio --file-test-mode=rndrw prepare
sysbench --test=fileio --file-test-mode=rndrw run
sysbench --test=fileio --file-test-mode=rndrw cleanup
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;멀티스레드 성능 테스트: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;MySQL 데이터베이스 성능 테스트 (최대 연결 수 조정 필요):&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword --oltp-table-size=1000000 prepare
sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword --max-time=60 --oltp-read-only=off --oltp-test-mode=complex --max-requests=0 run
sysbench --test=oltp --db-driver=mysql --mysql-db=test --mysql-user=yourusername --mysql-password=yourpassword cleanup
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;분포-데이터-보고서&#34;&gt;분포 데이터 보고서
&lt;/h2&gt;&lt;meta http-equiv=&#34;Content-Type&#34; content=&#34;text/html; charset=utf-8&#34;&gt;&lt;link type=&#34;text/css&#34; rel=&#34;stylesheet&#34; href=&#34;resources/sheet.css&#34; &gt;
&lt;style type=&#34;text/css&#34;&gt;.ritz .waffle a { color: inherit; }.ritz .waffle .s0{background-color:#ffffff;text-align:left;color:#000000;font-family:&#39;Arial&#39;;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}&lt;/style&gt;&lt;div class=&#34;ritz grid-container&#34; dir=&#34;ltr&#34;&gt;&lt;table class=&#34;waffle&#34; cellspacing=&#34;0&#34; cellpadding=&#34;0&#34;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th class=&#34;row-header freezebar-origin-ltr&#34;&gt;&lt;/th&gt;&lt;th id=&#34;0C0&#34; style=&#34;width:100px;&#34; class=&#34;column-headers-background&#34;&gt;A&lt;/th&gt;&lt;th id=&#34;0C1&#34; style=&#34;width:421px;&#34; class=&#34;column-headers-background&#34;&gt;B&lt;/th&gt;&lt;th id=&#34;0C2&#34; style=&#34;width:398px;&#34; class=&#34;column-headers-background&#34;&gt;C&lt;/th&gt;&lt;th id=&#34;0C3&#34; style=&#34;width:422px;&#34; class=&#34;column-headers-background&#34;&gt;D&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R0&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;1&lt;/div&gt;&lt;/th&gt;&lt;td&gt;&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;本地机械师&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;阿里云&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;华为云&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R1&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;2&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;系统配置&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;System Information&lt;br&gt;  Operating System              Ubuntu 23.04&lt;br&gt;  Kernel                        Linux 6.2.0-36-generic x86_64&lt;br&gt;  Model                         Machenike Machenike DT Computer&lt;br&gt;  Motherboard                   Machenike Machenike DT Computer&lt;br&gt;  BIOS                          American Megatrends International, LLC.&lt;br&gt;DB19V012&lt;br&gt;&lt;br&gt;CPU Information&lt;br&gt;  Name                          Intel Core i7-12650H&lt;br&gt;  Topology                      1 Processor, 10 Cores, 16 Threads&lt;br&gt;  Identifier                    GenuineIntel Family 6 Model 154 Stepping 3&lt;br&gt;  Base Frequency                4.60 GHz&lt;br&gt;  L1 Instruction Cache          32.0 KB x 8&lt;br&gt;  L1 Data Cache                 48.0 KB x 8&lt;br&gt;  L2 Cache                      1.25 MB x 2&lt;br&gt;  L3 Cache                      24.0 MB&lt;br&gt;&lt;br&gt;Memory Information&lt;br&gt;  Size                          62.6 GB&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;System Information&lt;br&gt;  Operating System              CentOS Stream 8&lt;br&gt;  Kernel                        Linux 4.18.0-513.el8.x86_64 x86_64&lt;br&gt;  Model                         Alibaba Cloud Alibaba Cloud ECS&lt;br&gt;  Motherboard                   N/A&lt;br&gt;  BIOS                          SeaBIOS 449e491&lt;br&gt;&lt;br&gt;CPU Information&lt;br&gt;  Name                          Intel(R) Xeon(R) Platinum&lt;br&gt;  Topology                      1 Processor, 1 Core, 2 Threads&lt;br&gt;  Identifier                    GenuineIntel Family 6 Model 85 Stepping 4&lt;br&gt;  Base Frequency                2.50 GHz&lt;br&gt;  L1 Instruction Cache          32.0 KB&lt;br&gt;  L1 Data Cache                 32.0 KB&lt;br&gt;  L2 Cache                      1.00 MB&lt;br&gt;  L3 Cache                      33.0 MB&lt;br&gt;&lt;br&gt;Memory Information&lt;br&gt;  Size                          1.65 GB&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;System Information&lt;br&gt;  Operating System              Ubuntu 22.04.1 LTS&lt;br&gt;  Kernel                        Linux 5.15.0-60-generic x86_64&lt;br&gt;  Model                         OpenStack Foundation OpenStack Nova&lt;br&gt;  Motherboard                   N/A&lt;br&gt;  BIOS                          SeaBIOS&lt;br&gt;rel-1.10.2-0-g5f4c7b1-20181220_000000-szxrtosci10000&lt;br&gt;&lt;br&gt;CPU Information&lt;br&gt;  Name                          Intel(R) Xeon(R) Gold 6278C CPU @ 2.60GHz&lt;br&gt;  Topology                      1 Processor, 1 Core, 2 Threads&lt;br&gt;  Identifier                    GenuineIntel Family 6 Model 85 Stepping 7&lt;br&gt;  Base Frequency                2.60 GHz&lt;br&gt;  L1 Instruction Cache          32.0 KB&lt;br&gt;  L1 Data Cache                 32.0 KB&lt;br&gt;  L2 Cache                      1.00 MB&lt;br&gt;  L3 Cache                      35.8 MB&lt;br&gt;&lt;br&gt;Memory Information&lt;br&gt;  Size                          3.64 GB&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R2&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;3&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;CPU&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Prime numbers limit: 10000&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;CPU speed:&lt;br&gt;    events per second:  4032.48&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0004s&lt;br&gt;    total number of events:              40330&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.25&lt;br&gt;         avg:                                    0.25&lt;br&gt;         max:                                    0.73&lt;br&gt;         95th percentile:                        0.25&lt;br&gt;         sum:                                 9997.55&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           40330.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9975/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Prime numbers limit: 10000&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;CPU speed:&lt;br&gt;    events per second:  1062.51&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0008s&lt;br&gt;    total number of events:              10628&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.91&lt;br&gt;         avg:                                    0.94&lt;br&gt;         max:                                   22.84&lt;br&gt;         95th percentile:                        1.06&lt;br&gt;         sum:                                 9993.46&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           10628.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9935/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Prime numbers limit: 10000&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;CPU speed:&lt;br&gt;    events per second:  1125.56&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0005s&lt;br&gt;    total number of events:              11258&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.86&lt;br&gt;         avg:                                    0.89&lt;br&gt;         max:                                    1.70&lt;br&gt;         95th percentile:                        0.99&lt;br&gt;         sum:                                 9995.40&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           11258.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9954/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R3&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;4&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;内存&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Running memory speed test with the following options:&lt;br&gt;  block size: 1KiB&lt;br&gt;  total size: 102400MiB&lt;br&gt;  operation: write&lt;br&gt;  scope: global&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;Total operations: 101993199 (10198146.52 per second)&lt;br&gt;&lt;br&gt;99602.73 MiB transferred (9959.13 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0001s&lt;br&gt;    total number of events:              101993199&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.00&lt;br&gt;         max:                                    0.03&lt;br&gt;         95th percentile:                        0.00&lt;br&gt;         sum:                                 4059.50&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           101993199.0000/0.00&lt;br&gt;    execution time (avg/stddev):   4.0595/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Running memory speed test with the following options:&lt;br&gt;  block size: 1KiB&lt;br&gt;  total size: 102400MiB&lt;br&gt;  operation: write&lt;br&gt;  scope: global&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;Total operations: 48418803 (4841004.79 per second)&lt;br&gt;&lt;br&gt;47283.99 MiB transferred (4727.54 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0001s&lt;br&gt;    total number of events:              48418803&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.00&lt;br&gt;         max:                                   25.26&lt;br&gt;         95th percentile:                        0.00&lt;br&gt;         sum:                                 4578.95&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           48418803.0000/0.00&lt;br&gt;    execution time (avg/stddev):   4.5789/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Running memory speed test with the following options:&lt;br&gt;  block size: 1KiB&lt;br&gt;  total size: 102400MiB&lt;br&gt;  operation: write&lt;br&gt;  scope: global&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;Total operations: 57056904 (5704765.11 per second)&lt;br&gt;&lt;br&gt;55719.63 MiB transferred (5571.06 MiB/sec)&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0001s&lt;br&gt;    total number of events:              57056904&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.00&lt;br&gt;         max:                                    0.06&lt;br&gt;         95th percentile:                        0.00&lt;br&gt;         sum:                                 4556.06&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           57056904.0000/0.00&lt;br&gt;    execution time (avg/stddev):   4.5561/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R4&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;5&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;硬盘&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;2147483648 bytes written in 1.81 seconds (1129.59 MiB/sec).&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Extra file open flags: (none)&lt;br&gt;128 files, 16MiB each&lt;br&gt;2GiB total file size&lt;br&gt;Block size 16KiB&lt;br&gt;Number of IO requests: 0&lt;br&gt;Read/Write ratio for combined random IO test: 1.50&lt;br&gt;Periodic FSYNC enabled, calling fsync() each 100 requests.&lt;br&gt;Calling fsync() at the end of test, Enabled.&lt;br&gt;Using synchronous I/O mode&lt;br&gt;Doing random r/w test&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;File operations:&lt;br&gt;    reads/s:                      3373.41&lt;br&gt;    writes/s:                     2248.94&lt;br&gt;    fsyncs/s:                     7201.80&lt;br&gt;&lt;br&gt;Throughput:&lt;br&gt;    read, MiB/s:                  52.71&lt;br&gt;    written, MiB/s:               35.14&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0127s&lt;br&gt;    total number of events:              128288&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.08&lt;br&gt;         max:                                    5.14&lt;br&gt;         95th percentile:                        0.34&lt;br&gt;         sum:                                 9977.78&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           128288.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9778/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;2147483648 bytes written in 19.29 seconds (106.16 MiB/sec).&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Extra file open flags: (none)&lt;br&gt;128 files, 16MiB each&lt;br&gt;2GiB total file size&lt;br&gt;Block size 16KiB&lt;br&gt;Number of IO requests: 0&lt;br&gt;Read/Write ratio for combined random IO test: 1.50&lt;br&gt;Periodic FSYNC enabled, calling fsync() each 100 requests.&lt;br&gt;Calling fsync() at the end of test, Enabled.&lt;br&gt;Using synchronous I/O mode&lt;br&gt;Doing random r/w test&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;File operations:&lt;br&gt;    reads/s:                      1593.12&lt;br&gt;    writes/s:                     1062.08&lt;br&gt;    fsyncs/s:                     3406.64&lt;br&gt;&lt;br&gt;Throughput:&lt;br&gt;    read, MiB/s:                  24.89&lt;br&gt;    written, MiB/s:               16.60&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0164s&lt;br&gt;    total number of events:              60600&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.16&lt;br&gt;         max:                                   31.32&lt;br&gt;         95th percentile:                        0.54&lt;br&gt;         sum:                                 9956.30&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           60600.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9563/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;2147483648 bytes written in 18.29 seconds (111.98 MiB/sec).&lt;br&gt;&lt;br&gt;Running the test with following options:&lt;br&gt;Number of threads: 1&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Extra file open flags: (none)&lt;br&gt;128 files, 16MiB each&lt;br&gt;2GiB total file size&lt;br&gt;Block size 16KiB&lt;br&gt;Number of IO requests: 0&lt;br&gt;Read/Write ratio for combined random IO test: 1.50&lt;br&gt;Periodic FSYNC enabled, calling fsync() each 100 requests.&lt;br&gt;Calling fsync() at the end of test, Enabled.&lt;br&gt;Using synchronous I/O mode&lt;br&gt;Doing random r/w test&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;File operations:&lt;br&gt;    reads/s:                      1665.88&lt;br&gt;    writes/s:                     1110.59&lt;br&gt;    fsyncs/s:                     3563.77&lt;br&gt;&lt;br&gt;Throughput:&lt;br&gt;    read, MiB/s:                  26.03&lt;br&gt;    written, MiB/s:               17.35&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0112s&lt;br&gt;    total number of events:              63355&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.00&lt;br&gt;         avg:                                    0.16&lt;br&gt;         max:                                  205.01&lt;br&gt;         95th percentile:                        0.78&lt;br&gt;         sum:                                 9972.64&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           63355.0000/0.00&lt;br&gt;    execution time (avg/stddev):   9.9726/0.00&lt;/td&gt;&lt;/tr&gt;&lt;tr style=&#34;height: 20px&#34;&gt;&lt;th id=&#34;0R5&#34; style=&#34;height: 20px;&#34; class=&#34;row-headers-background&#34;&gt;&lt;div class=&#34;row-header-wrapper&#34; style=&#34;line-height: 20px&#34;&gt;6&lt;/div&gt;&lt;/th&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;多线程&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 4&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0002s&lt;br&gt;    total number of events:              197956&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.16&lt;br&gt;         avg:                                    0.20&lt;br&gt;         max:                                    0.34&lt;br&gt;         95th percentile:                        0.21&lt;br&gt;         sum:                                39970.47&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           49489.0000/5.70&lt;br&gt;    execution time (avg/stddev):   9.9926/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 4&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0174s&lt;br&gt;    total number of events:              18360&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.57&lt;br&gt;         avg:                                    2.18&lt;br&gt;         max:                                   32.77&lt;br&gt;         95th percentile:                        2.61&lt;br&gt;         sum:                                40050.41&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           4590.0000/94.36&lt;br&gt;    execution time (avg/stddev):   10.0126/0.00&lt;/td&gt;&lt;td class=&#34;s0&#34; dir=&#34;ltr&#34;&gt;Running the test with following options:&lt;br&gt;Number of threads: 4&lt;br&gt;Initializing random number generator from current time&lt;br&gt;&lt;br&gt;&lt;br&gt;Initializing worker threads...&lt;br&gt;&lt;br&gt;Threads started!&lt;br&gt;&lt;br&gt;&lt;br&gt;General statistics:&lt;br&gt;    total time:                          10.0004s&lt;br&gt;    total number of events:              28536&lt;br&gt;&lt;br&gt;Latency (ms):&lt;br&gt;         min:                                    0.23&lt;br&gt;         avg:                                    1.40&lt;br&gt;         max:                                    3.56&lt;br&gt;         95th percentile:                        1.47&lt;br&gt;         sum:                                39975.16&lt;br&gt;&lt;br&gt;Threads fairness:&lt;br&gt;    events (avg/stddev):           7134.0000/39.87&lt;br&gt;    execution time (avg/stddev):   9.9938/0.01&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ChatGPT&lt;/code&gt;**BOLD_2&lt;code&gt;Markdown&lt;/code&gt;완전히 표 형태로 만들 수 없으며, 그렇게 하지 않으면 효과가 매우 나쁩니다. 사용자 정의 테마는 페이지 최대 너비를 제한하고, 페이지 설정이 동기화되어 너비가 퍼센트 제한으로 변경되었습니다.__&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;간단한 방법은 TablesGenerator와 같은 온라인 도구를 사용하여 HTML 테이블을 생성하는 것입니다(복잡한 내용은 적합하지 않음)&lt;/li&gt;
&lt;li&gt;또는 구글 온라인 문서로 작성한 후 HTML 문서로 다운로드하여 저장하고, 블로그에 바로 복사하는 방법이 있습니다 (간단하고 직접적이며, 최종적으로 이 방법을 사용했습니다)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;config 설정에서 unsafe 옵션이 활성화되어 있는지 확인하고, 페이지별로 너비를 개별적으로 지정하세요&lt;/p&gt;
&lt;p&gt;Hugo에서 페이지별로 너비를 설정할 수 있습니다. 이는 페이지의 프론트 매터에 사용자 지정 파라미터를 추가하여 구현할 수 있습니다. 다음은 예시입니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;마크다운 페이지의 프론트 매터 부분(일반적으로 파일 시작 부분)에 사용자 지정 파라미터를 추가하세요. 예를 들어, &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;---
title: &amp;quot;我的页面&amp;quot;
date: 2024-01-09
custom_width: &amp;quot;800px&amp;quot;  # 设置宽度为 800 像素
---

正文内容...
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;귀하의 Hugo 테마에서 해당 단일 페이지 템플릿 파일(예: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;)을 찾거나 생성하십시오&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;단일 페이지 템플릿에서, 페이지의 프론트 매터에 &lt;code&gt;custom_width&lt;/code&gt;BOLD_2&lt;code&gt;div&lt;/code&gt;가 있는지 확인하세요:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{{ define &amp;quot;main&amp;quot; }}
  &amp;lt;div style=&amp;quot;max-width: {{ with .Params.custom_width }}{{ . }}{{ else }}100%{{ end }}; margin: 0 auto;&amp;quot;&amp;gt;
    {{ .Content }}
  &amp;lt;/div&amp;gt;
{{ end }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 예제에서는 인라인 스타일(&lt;strong&gt;INLINE_CODE_0__属性）为 &lt;code&gt;div&lt;/code&gt; 元素设置了 &lt;code&gt;max-width&lt;/code&gt;BOLD_8__INLINE_CODE_3&lt;/strong&gt; 参数时，宽度默认为100%。&lt;code&gt;margin: 0 auto;&lt;/code&gt; 用于将 &lt;code&gt;div&lt;/code&gt;) 요소들을 가운데 정렬했습니다&lt;/p&gt;
&lt;p&gt;실제 적용 시에는 주제 구조와 CSS 스타일의 세부 사항에 따라 위 예시를 조정해야 할 수 있습니다. 스타일을 조정할 때는 일관성과 가독성을 유지하는 것이 중요합니다.&lt;/p&gt;
&lt;p&gt;활성화된 테마가 약간 달라서, 사이트 사용자 정의의 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 설정을 최종적으로 조정했습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>Git 비활성화 http 저장소</title>
        <link>https://blog.ttf248.life/ko/p/git-disable-http-repositories/</link>
        <pubDate>Mon, 08 Jan 2024 21:22:04 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/git-disable-http-repositories/</guid>
        <description>&lt;p&gt;소프트웨어 버전 업데이트를 습관화했지만, 어떤 버전의 &lt;strong&gt;INLINE_CODE_0__开始，禁止从__INLINE_CODE_1&lt;/strong&gt; 저장소에서 코드를 가져와야 할지 모르겠네요&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;fatal: Unencrypted HTTP is not supported for GitLab. Ensure the repository remote URL is using HTTPS
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;배경-소개&#34;&gt;배경 소개
&lt;/h2&gt;&lt;p&gt;환경: Windows 플랫폼, 항상 작은 거북이로 git을 사용하고 있었고, 키 설정도 작은 거북이로 처리했으며, 이전에 스크립트를 통해 로컬 저장소를 일괄적으로 업데이트한 적이 있습니다&lt;/p&gt;
&lt;p&gt;이전 링크: &lt;a class=&#34;link&#34; href=&#34;https://blog.ttf248.life/ko/p/bulk-update-local-git-repository-and-legacy-permission-issues/&#34; &gt;批量更新本地Git仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;오늘 코드 업데이트를 하려는데, 앞서 발생했던 오류가 발생해서 저장소를 정상적으로 업데이트할 수 없게 됐습니다. __INLINE_CODE_0__应该提供了配置，让我继续使用__INLINE_CODE_1__의 프로토콜 업데이트 저장소를 찾으려고 했는데, 관련 설정 항목을 찾을 수가 없네요.&lt;/p&gt;
&lt;p&gt;가장 간단한 해결책은 당연히 __INLINE_CODE_0__BOLD_3&lt;code&gt;gitlab&lt;/code&gt;BOLD_4&lt;code&gt;https&lt;/code&gt;프로토콜로 전환하는 것입니다&lt;/p&gt;
&lt;h2 id=&#34;미결-문제&#34;&gt;미결 문제
&lt;/h2&gt;&lt;p&gt;앞서 작성한 로컬 저장소 일괄 업데이트 스크립트에서 __INLINE_CODE_0__BOLD_2&lt;code&gt;git&lt;/code&gt; 설정 정보가 config에 동기화되지 않아 명령줄 실행 시 발생했습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git pull #提示没有权限，无法正常更新仓库
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;명령을 통해 키 설정도 확인하는 것은 올바르다: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TortoiseGit으로 코드를 정상적으로 가져올 수 있지만 명령줄에서 git pull 명령을 사용할 때 키가 올바르지 않다고 표시되면 TortoiseGit이 PuTTY의 SSH 키를 사용하는 반면 명령줄은 OpenSSH의 SSH 키를 사용하기 때문일 수 있습니다&lt;/p&gt;
&lt;p&gt;작은 거북이의 키 설정은 시스템 .ssh 폴더에서 키 파일 정보를 읽어오는 대신, 인터페이스 저장소 구성 시 별도로 키 파일 경로를 설정합니다. 유용한 팁: 첫 번째 저장소를 가져오기 위한 키를 설정하면 나머지 저장소는 이 키 파일을 재사용할 수 있습니다. PuTTY가 키를 로드한 후 즉시 종료되지 않고 프록시 서비스를 시작합니다.&lt;/p&gt;
&lt;p&gt;전역 설정을 조정하여 시스템 기본 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 설정 대신, 이렇게 설정하면 Git Bash는 TortoisePlink를 사용하여 SSH 작업을 수행합니다. 이 설정은 TortoiseGit에 포함된 PuTTY 도구를 사용하는 경우에 적합합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global core.sshCommand &amp;quot;&#39;C:/Program Files/TortoiseGit/bin/TortoisePlink.exe&#39; -batch -ssh&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위에 설정된 실행 파일 경로를 해당 작은 거북이 경로로 직접 수정하면 시스템 환경 변수에 경로를 추가할 필요가 없습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>AI 프로그래밍 및 작업 분할</title>
        <link>https://blog.ttf248.life/ko/p/ai-programming-and-task-decomposition/</link>
        <pubDate>Fri, 22 Dec 2023 08:44:26 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/ai-programming-and-task-decomposition/</guid>
        <description>&lt;p&gt;2년 전 사이트에 코드 영역 복사 기능을 추가하려고 했는데, 반쯤 날로 붙들여 놓은 듯했고, 렌더링 효과도 만족스럽지 않았습니다. 반쪽짜리 프론트엔드 개발자였으니 개선할 생각도 없이 그냥 쓰고 있었는데, 올해 __INLINE_CODE_0__으로 미니 프로그램을 개발하면서 프론트엔드 개발에 더 익숙해졌고, AI를 활용하여 다시 디자인했습니다.&lt;/p&gt;
&lt;p&gt;깨달음: 임무 분해, 여러 소임들, &lt;em&gt;이탤릭 강조&lt;/em&gt; 굵게 표시_ 또 다른 소임들_&lt;/p&gt;
&lt;h2 id=&#34;전문&#34;&gt;전문
&lt;/h2&gt;&lt;p&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;promot&lt;/strong&gt;: CSS 및 JavaScript 코드를 설계하여, 클래스가 &amp;ldquo;highlight&amp;quot;인 웹 요소의 컨테이너 내에 복사 버튼을 추가하고 코드 복사 기능을 구현합니다&lt;/p&gt;
&lt;p&gt;제공된 첫 번째 초안 코드에는 문제가 있어 보입니다. 다시 생성한 두 번째 초안은 기본적으로 사용 가능하지만, 복사된 내용이 정확하지 않고 불필요한 텍스트가 있습니다. 핵심 색상 디자인과 포함될 효과를 지정하여 추가 최적화를 유도합니다.&lt;/p&gt;
&lt;p&gt;버튼 크기 및 색상에 대한 특정 요구 사항을 파악했습니다. 이러한 요구 사항에 맞게 버튼 스타일을 재설계할 수 있으며, 제공해주신 색상 구성표를 포함하고 버튼 크기를 최적화한 CSS 스타일이 아래와 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.copy-btn {
  position: absolute;
  top: 2px; /* 调整位置 */
  right: 2px;
  padding: 3px 6px; /* 缩小尺寸 */
  font-size: 12px; /* 减小字体大小 */
  background-color: #8FD1E1; /* 按钮背景色 */
  color: #272822; /* 文字颜色 */
  border: 1px solid #272822; /* 边框颜色 */
  border-radius: 3px; /* 圆角 */
  cursor: pointer;
  opacity: 0.7; /* 默认半透明 */
  transition: opacity 0.3s ease, background-color 0.3s ease; /* 平滑过渡效果 */
}

.copy-btn:hover {
  opacity: 1; /* 鼠标悬停时不透明 */
  background-color: #A3D4E5; /* 鼠标悬停时的背景色 */
}

.highlight {
  position: relative;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 스타일에서 버튼 크기와 글꼴 크기를 줄여 더욱 세련되게 만들었습니다. 또한, 버튼의 기본 상태는 반투명하며, 마우스가 올라오면 불투명해지고 배경색이 약간 밝아져 시각적인 피드백을 제공합니다. 이러한 디자인은 귀하의 색상 요구 사항을 충족하면서도 현대적이고 사용자 친화적인 특징을 유지합니다.&lt;/p&gt;
&lt;p&gt;해당하는 더 간단한 ____이 제공되었습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;document.addEventListener(&#39;DOMContentLoaded&#39;, function() {
  // 查找所有 .highlight 元素
  const highlights = document.querySelectorAll(&#39;.highlight&#39;);

  highlights.forEach(function(highlight) {
    // 创建复制按钮
    const copyBtn = document.createElement(&#39;button&#39;);
    copyBtn.textContent = &#39;复制&#39;;
    copyBtn.classList.add(&#39;copy-btn&#39;);

    // 将按钮添加到每个 .highlight 元素中
    highlight.appendChild(copyBtn);

    // 添加点击事件监听器
    copyBtn.addEventListener(&#39;click&#39;, function() {
      // 假设 .highlight 下的第一个 &amp;lt;code&amp;gt; 元素包含要复制的代码
      const code = highlight.querySelector(&#39;code&#39;) ? highlight.querySelector(&#39;code&#39;).textContent : &#39;&#39;;

      navigator.clipboard.writeText(code).then(() =&amp;gt; {
        // 显示复制成功信息
        copyBtn.textContent = &#39;已复制!&#39;;
        setTimeout(() =&amp;gt; {
          copyBtn.textContent = &#39;复制&#39;;
        }, 2000);
      }).catch(err =&amp;gt; {
        console.error(&#39;复制失败: &#39;, err);
      });
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;p&gt;비록 코드 영역 오른쪽 상단에 복사 버튼을 추가하기를 더 바라지만, 프론트엔드에 대한 이해 부족으로 정확한 기능 설명을 위한 키워드를 제시하지 못했고, __INLINE_CODE_0__과 여러 차례 시도했음에도 기대했던 결과를 얻지 못했습니다&lt;/p&gt;
&lt;p&gt;시간이 지남에 따라 &lt;code&gt;AI&lt;/code&gt;이 프로그램 개발에 얼마나 영향을 미칠지 모르겠다&lt;/p&gt;</description>
        </item>
        <item>
        <title>클라우드 서버와 스크립트 키즈</title>
        <link>https://blog.ttf248.life/ko/p/cloud-servers-and-script-kids/</link>
        <pubDate>Mon, 20 Nov 2023 15:08:53 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/cloud-servers-and-script-kids/</guid>
        <description>&lt;p&gt;더블 11 프로모션으로 알리바이가 새 서버를 구매했습니다. 경제 버전이라 구성은 높지 않지만, 집안 서비스의 게이트웨이 역할을 하기에 좋고, 내년 2026년까지 프로모션이 진행 중입니다.&lt;/p&gt;
&lt;p&gt;특别히 상하이 지역 서버를 선택해서 집의 컴퓨터에 낮은 지연 시간 프록시로 연결했는데, win11과 windows server 2022를 사용하고 있습니다. 서버 버전은 나중에 배포되었고, 사용할 때 갑자기 접근 거부 메시지를 받았습니다. 서버 업데이트라고 생각하며 잠시 기다리니 정상적으로 복구될 줄 알았는데, 5분 후에 다시 시도해도 여전히 로그인되지 않습니다. 관련 오류를 검색해 보니 누군가가 로그인을 시도하고 있고, 비밀번호가 틀린 횟수가 너무 많아 현재 로그인이 불가능하다고 합니다.&lt;/p&gt;
&lt;p&gt;이전에 보안 공격 스크립트를 다뤄본 경험이 있어 바로 알 수 있었다. 이 로그인 시도는 정상적인 행동이 아니며, 누군가 서비스를 공격하고 로그인 서버를 무차별 대입하려고 하는 것이다. 방화벽 설정은 간단하게 해놓았고, 화이트리스트 설정도 되어 있지 않다. 두 대의 기계의 3389 포트를 프록시했는데, 이 포트가 공공 네트워크에 노출되어 있는 상황이었다. 마치 연못 속 미끼와 같다. 스크립트 키드의 공격이라는 것을 알았으니, 다음 단계는 간단하다. 방화벽 화이트리스트를 설정하여 회사 IP 주소와 집 IP 주소만 프록시 서비스에 접속하도록 허용한다.&lt;/p&gt;
&lt;p&gt;__INLINE_CODE_0__대리 서버는 이전에도 실행 로그를 설정하지 않았는데, 로그를 켜니 정말 다행이다. 전국 각지의 대리 IP들이 우리 집 서버에 접속을 시도하고 있었네. 다행히 server 버전이라 문제점을 깨달았고, 그렇지 않으면 win11 머신은 결국 해킹당할 것이다. 비밀번호가 너무 단순했어.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;2023/11/17 16:51:14 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [101.43.98.211:50486]
2023/11/17 16:51:14 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [218.93.202.63:56970]
2023/11/17 16:51:14 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [222.179.106.174:60812]
2023/11/17 16:51:15 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [58.16.204.238:2839]
2023/11/17 16:51:15 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [124.223.47.24:50274]
2023/11/17 16:51:16 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [43.248.128.22:55883]
2023/11/17 16:51:16 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [43.143.53.138:56955]
2023/11/17 16:51:16 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [43.228.7.250:61550]
2023/11/17 16:51:16 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [125.76.228.9:55842]
2023/11/17 16:51:17 [I] [proxy.go:204] [4dfcc2259937dcb9] [winserver-remote] get a user connection [91.240.118.187:49326]
2023/11/17 16:51:17 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [91.240.118.187:49324]
2023/11/17 16:51:17 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [89.248.163.79:51712]
2023/11/17 16:51:18 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [218.63.75.24:62387]
2023/11/17 16:51:19 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [103.186.109.227:51396]
2023/11/17 16:51:20 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [116.233.234.104:51567]
2023/11/17 16:51:20 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [222.187.193.202:51585]
2023/11/17 16:51:20 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [59.48.98.42:57489]
2023/11/17 16:51:20 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [146.56.241.134:53558]
2023/11/17 16:51:21 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [222.179.106.174:30620]
2023/11/17 16:51:23 [I] [proxy.go:204] [639d8947325142ac] [host-remote] get a user connection [183.14.214.51:62128]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;훑이로 Linux 서비스 로그인 로그를 확인해 보니, 알리바바 클라우드 이 서버 외에 친구가 쓰는 화웨이 클라우드 서버도 있네&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo grep &amp;quot;Failed password&amp;quot; /var/log/secure  centos系列
sudo grep &amp;quot;Failed password&amp;quot; /var/log/auth.log  ubuntu系列
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Nov 16 04:46:34 aliyun-sh sshd[156625]: Failed password for root from 120.55.164.64 port 53410 ssh2
Nov 16 04:46:34 aliyun-sh sshd[156623]: Failed password for root from 111.16.215.122 port 36548 ssh2
Nov 16 04:46:58 aliyun-sh sshd[156630]: Failed password for invalid user share from 139.9.233.78 port 53872 ssh2
Nov 16 04:47:23 aliyun-sh sshd[156634]: Failed password for invalid user spark from 139.9.233.78 port 36134 ssh2
Nov 16 04:47:26 aliyun-sh sshd[156636]: Failed password for root from 120.55.164.64 port 46142 ssh2
Nov 16 04:47:47 aliyun-sh sshd[156640]: Failed password for root from 111.16.215.122 port 42962 ssh2
Nov 16 04:48:24 aliyun-sh sshd[156652]: Failed password for root from 120.55.164.64 port 38868 ssh2
Nov 16 04:48:25 aliyun-sh sshd[156654]: Failed password for root from 111.16.215.122 port 46164 ssh2
Nov 16 04:48:39 aliyun-sh sshd[156657]: Failed password for invalid user test from 139.9.233.78 port 39386 ssh2
Nov 16 04:48:50 aliyun-sh sshd[156659]: Failed password for root from 111.16.215.122 port 38892 ssh2
Nov 16 04:48:53 aliyun-sh sshd[156662]: Failed password for root from 120.55.164.64 port 49348 ssh2
Nov 16 04:48:53 aliyun-sh sshd[156664]: Failed password for invalid user test from 139.9.233.78 port 49864 ssh2
Nov 16 04:50:02 aliyun-sh sshd[156672]: Failed password for root from 111.16.215.122 port 45294 ssh2
Nov 16 04:50:30 aliyun-sh sshd[156680]: Failed password for invalid user zabbix from 139.9.233.78 port 52206 ssh2
Nov 16 04:50:50 aliyun-sh sshd[156683]: Failed password for root from 120.55.164.64 port 34820 ssh2
Nov 16 04:50:51 aliyun-sh sshd[156685]: Failed password for root from 111.16.215.122 port 58978 ssh2
Nov 16 04:51:18 aliyun-sh sshd[156689]: Failed password for root from 120.55.164.64 port 45306 ssh2
Nov 16 04:51:25 aliyun-sh sshd[156692]: Failed password for root from 111.16.215.122 port 33938 ssh2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 화웨이 클라우드 머신은 켜진 지 시간이 꽤 돼서, 이제 사변 공격의 중간 단계에 접어들고 있으며 이상한 사용자들도 나타나기 시작했다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Nov 16 20:30:35 hecs-411458 sshd[182965]: Failed password for invalid user oeh from 39.129.9.180 port 26459 ssh2
Nov 16 20:32:17 hecs-411458 sshd[182967]: Failed password for invalid user dnu from 39.129.9.180 port 27079 ssh2
Nov 16 20:34:12 hecs-411458 sshd[182971]: Failed password for invalid user rq from 39.129.9.180 port 27742 ssh2
Nov 16 20:36:07 hecs-411458 sshd[182979]: Failed password for invalid user zw from 39.129.9.180 port 28415 ssh2
Nov 16 20:37:59 hecs-411458 sshd[182981]: Failed password for invalid user egi from 39.129.9.180 port 29068 ssh2
Nov 16 20:39:52 hecs-411458 sshd[182984]: Failed password for invalid user bjb from 39.129.9.180 port 29723 ssh2
Nov 16 20:41:53 hecs-411458 sshd[182988]: Failed password for invalid user hna from 39.129.9.180 port 30375 ssh2
Nov 16 20:43:46 hecs-411458 sshd[182994]: Failed password for invalid user gar from 39.129.9.180 port 31036 ssh2
Nov 16 20:45:40 hecs-411458 sshd[183003]: Failed password for invalid user mze from 39.129.9.180 port 31703 ssh2
Nov 16 20:47:35 hecs-411458 sshd[183007]: Failed password for invalid user tmh from 39.129.9.180 port 32381 ssh2
Nov 16 21:23:01 hecs-411458 sshd[183047]: Failed password for invalid user amax from 112.4.65.118 port 41188 ssh2
Nov 16 22:31:20 hecs-411458 sshd[183116]: Failed password for root from 211.228.203.123 port 60213 ssh2
Nov 16 22:53:44 hecs-411458 sshd[183162]: Failed password for root from 112.132.249.164 port 39272 ssh2
Nov 17 11:44:26 hecs-411458 sshd[184811]: Failed password for invalid user jsh from 43.157.103.27 port 54608 ssh2
Nov 17 11:47:23 hecs-411458 sshd[184818]: Failed password for invalid user mrunal from 43.157.103.27 port 50448 ssh2
Nov 17 11:48:46 hecs-411458 sshd[184820]: Failed password for invalid user robertsheen from 43.157.103.27 port 50560 ssh2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;p&gt;자가 개발 서버는 Windows의 경우 공용 네트워크 접속 시 화이트리스트 설정이 필요하며, Linux는 비밀번호 로그인을 비활성화하고 키 파일 로그인 기능을 활성화하는 것이 좋습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>대량 업데이트 및 기존 권한 문제 해결</title>
        <link>https://blog.ttf248.life/ko/p/bulk-update-local-git-repository-and-legacy-permission-issues/</link>
        <pubDate>Thu, 19 Oct 2023 14:16:22 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/bulk-update-local-git-repository-and-legacy-permission-issues/</guid>
        <description>&lt;p&gt;팀 내 프로젝트 간 의존 관계가 존재하며, 과거의 사유로 인해 __INLINE_CODE_0__을 사용하여 의존성을 관리하지 않아, 일상적인 개발 시 코드 업데이트를 수동으로 순차적으로 진행해야 합니다. 그렇지 않으면 다양한 문제가 발생할 수 있습니다.&lt;/p&gt;
&lt;p&gt;온라인 자료를 참고하여 구조가 기본적으로 유사하므로, 로컬에서 &lt;strong&gt;git_list.txt&lt;/strong&gt;라는 저장소 디렉터리를 수동으로 관리하고, 스크립트를 작성하여 디렉터리를 순회하며 한 번에 업데이트합니다. 이후 작업 전에 스크립트를 실행하세요.&lt;/p&gt;
&lt;h2 id=&#34;linux&#34;&gt;linux
&lt;/h2&gt;&lt;p&gt;create new file: batch_pull.sh&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash

echo &amp;quot;============ 更新仓库 ===================&amp;quot;

# 检查 git_list.txt 是否存在
if [ ! -f &amp;quot;git_list.txt&amp;quot; ]; then
  echo &amp;quot;git_list.txt 文件不存在！请创建并添加要拉取的 git 仓库 URL。&amp;quot;
  exit 1
else
  echo &amp;quot;============ 检测到了 git 仓库清单文件 ====&amp;quot;
fi

# 逐行读取 git_list.txt 中的 URL，并执行拉取操作
while read -r url; do
  if [ -d &amp;quot;$url&amp;quot; ]; then
    cd &amp;quot;$url&amp;quot; || continue
    git pull
    cd ..
    echo &amp;quot;Pull $url 完成！&amp;quot;
    echo &amp;quot;========================================&amp;quot;
  else
    echo &amp;quot;目录 $url 不存在，跳过拉取。&amp;quot;
  fi
done &amp;lt; &amp;quot;git_list.txt&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;windows&#34;&gt;windows
&lt;/h2&gt;&lt;p&gt;create a new file: batch_pull.bat&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bat&#34;&gt;@echo off
chcp 65001 &amp;gt; nul
rem 进入脚本所在目录
cd /d &amp;quot;%~dp0&amp;quot;

rem 检查 git_list.txt 是否存在
if not exist &amp;quot;git_list.txt&amp;quot; (
  echo git_list.txt 文件不存在！请创建并添加要拉取的 git 仓库 URL。
  exit /b 1
) else (
  echo ============ 检测到了 git 仓库清单文件 ====
)

rem 逐行读取 git_list.txt 中的 URL，并执行拉取操作
for /f %%i in (git_list.txt) do (
  if exist &amp;quot;%%i&amp;quot; (
    pushd &amp;quot;%%i&amp;quot;
    git pull
    popd
    echo Pull %%i 完成！
    echo ========================================
  ) else (
    echo 目录 %%i 不存在，跳过拉取。
  )
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;역사-유산-문제&#34;&gt;역사 유산 문제
&lt;/h3&gt;&lt;p&gt;시스템 재설치 후 발생한 &lt;strong&gt;인라인 이탤릭 2&lt;/strong&gt; &lt;strong&gt;볼드 1&lt;/strong&gt; 치명적인 오류(&amp;ldquo;안전하지 않은 저장소(&amp;rsquo;/home/repon&amp;rsquo;은 다른 사용자가 소유함&amp;rdquo;)&lt;/p&gt;
&lt;p&gt;온라인 제안의 대부분은 __INLINE_CODE_0__에서 비롯됩니다&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;창고 목록 신뢰 추가:&lt;/li&gt;
&lt;li&gt;수동으로 설정 파일 __INLINE_CODE_0__을 수정하여, 디렉터리 추가 신뢰&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[safe]
    directory = /home/repon
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 방식으로 처리한 후, 창고 업데이트는 정상적으로 이루어지지만, &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 콘솔에서 사용자 소유권 오류를 포함한 많은 경고 메시지가 표시됩니다&lt;/p&gt;
&lt;h3 id=&#34;데스크톱-재설치&#34;&gt;데스크톱 재설치
&lt;/h3&gt;&lt;p&gt;개발한 기계가 너무 오래돼서 시스템을 재설치하지 않았더니, 쓰레기 파일이 폭발해서 해결할 방법이 없었습니다. 시간을 내어 시스템을 재설치했는데 또 권한 문제가 발생했고, 기존 스크립트가 실행되지 않으며, 수정된 권한이 불완전합니다.&lt;/p&gt;
&lt;p&gt;새로운 방식에 따라 &lt;code&gt;*&lt;/code&gt;BOLD_2&lt;code&gt;git&lt;/code&gt;을 직접 추가하면 모든 디렉터리를 자동으로 신뢰합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global --add safe.directory &amp;quot;*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;알 수 없는 사용자 권한 문제인지, 아니면 다들 &lt;strong&gt;INLINE_CODE_0__平台其实也有类似__INLINE_CODE_1&lt;/strong&gt; 명령에 익숙하지 않은 건지 모를 것 같습니다. 폴더 소유자를 수정하려고 했는데, 만약 디렉토리가 많지 않다면 수동으로 소유자를 변경하는 것도 괜찮습니다. 하지만 이 업무용 컴퓨터에는 도메인 정보가 추가되어 있는데, 회사에서 배포한 도메인에 문제가 있는 걸까요, 아니면 로컬 시스템 설정에 문제가 있는 걸까요? 사용자 목록에서 로그인에 사용된 사용자를 찾을 수 없었고, 결국 명령줄로 처리했습니다.&lt;/p&gt;
&lt;p&gt;관리자 권한으로 &lt;code&gt;powershell&lt;/code&gt;脚本__INLINE_CODE_1__，记得调整脚本文件编码为__INLINE_CODE_2__을 실행하고, 중국어 운영체제를 사용해야 인코딩 문제가 발생하지 않습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;# 获取当前用户的用户名
$currentUserName = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name

# 设置 PowerShell 的字符编码为 UTF-8
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8

# 要更改所有者的根目录路径
$rootDirectory = &amp;quot;G:\workspace&amp;quot;  # 替换为实际的目录路径

# 递归遍历目录并更改文件和文件夹的所有者
Get-ChildItem -Path $rootDirectory -Recurse | ForEach-Object {
    $itemPath = $_.FullName

    # 检查是文件还是文件夹
    if ($_ -is [System.IO.DirectoryInfo]) {
        # 如果是文件夹，使用 icacls 更改所有者权限
        $icaclsResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            Write-Host &amp;quot;已更改文件夹 $itemPath 的所有者为 $currentUserName&amp;quot;
        } else {
            Write-Host &amp;quot;无法更改文件夹 $itemPath 的所有者。错误信息: $icaclsResult&amp;quot;
        }
    } else {
        # 如果是文件，使用 icacls 更改所有者权限
        $takeownResult = icacls $itemPath /setowner &amp;quot;$currentUserName&amp;quot; 2&amp;gt;&amp;amp;1
        if ($LASTEXITCODE -eq 0) {
            # Write-Host &amp;quot;已更改文件 $itemPath 的所有者为 $currentUserName&amp;quot;
        } else {
            Write-Host &amp;quot;无法更改文件 $itemPath 的所有者。错误信息: $takeownResult&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;예상치 못한 상황이 발생했는데, 스크립트 실행 시 출력되는 중국어 정보가 엉망이고, 콘솔 문자 인코딩을 설정하고 스크립트 인코딩을 조정해도 여전히 깨져서 머리가 제대로 작동하지 않는 것 같았습니다. 제어판-지역-언어 설정의 베타 기능을 활성화하고 전역적으로 유니코드 인코딩을 켰더니 스크립트는 정상적으로 실행되었지만, 여러 개발 소프트웨어가 제대로 작동하지 않았습니다. 뒤돌아보니 자료를 정리하면서 스크립트 파일의 인코딩을 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 로 설정해야 한다는 것을 깨달았습니다.&lt;/p&gt;
&lt;h2 id=&#34;자료&#34;&gt;자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://ganzhixiong.com/p/f1b9f4fc/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ganzhixiong.com/p/f1b9f4fc/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/71901632/fatal-error-unsafe-repository-home-repon-is-owned-by-someone-else&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stackoverflow.com/questions/71901632/fatal-error-unsafe-repository-home-repon-is-owned-by-someone-else&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>WPF 학습 자료</title>
        <link>https://blog.ttf248.life/ko/p/wpf-learning-resources/</link>
        <pubDate>Tue, 17 Oct 2023 10:49:24 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/wpf-learning-resources/</guid>
        <description>&lt;p&gt;미니 프로그램 개발 설계의 함정은 아직 메워지지 않았는데, 또 다른 &lt;strong&gt;WPF&lt;/strong&gt;을 새로 파고 있고, 최근 회사도 시끄러운 상황이라, 여러 지역 간 협업 업무 소통은 효율이 어딘가 만족스럽지 않다. 그래서 클라이언트 인터페이스 개발을 맡기로 했다.&lt;/p&gt;
&lt;h2 id=&#34;wpf&#34;&gt;WPF
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;추천&lt;/li&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 界面设计用到的很多概念，类似于网页前端设计，尽可能的剥离UI设计和业务逻辑，让UI的设计能独立出来，也是互联网公司期望的分工方式。今年刚好折腾过小程序，很多概念上的东西都是通用的，上手也就比较轻松，这些算是现代UI设计中的**길을 &lt;strong&gt;잡으면&lt;/strong&gt;, 기본적인 틀 개념을 익혔으니, 이후로 쉽게 길을 잃지 않을 것이다&lt;/p&gt;
&lt;p&gt;이전에 __INLINE_CODE_0__BOLD_2&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/zh7791/p/11502696.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 基础总结(学习建议)&lt;/a&gt;이라는 자료가 있었는데, 분량이 길지 않아 경험 있는 독자들이 학습 경로를 계획하기에 적합합니다&lt;/p&gt;
&lt;p&gt;초보 독자라면 &lt;a class=&#34;link&#34; href=&#34;http://www.wpfsoft.com/introduction&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF 中文网&lt;/a&gt;을 추천합니다. 기본 개념, 발전 역사, 하위 계층의 인지 논리를 처음부터 설명합니다. 이 웹사이트는 우연히 올해 8월에 저자가 새로 게시한 것이었고, 제 시간과 딱 맞아떨어졌습니다. 조금만 더 늦었다면 아마도 인연은 없었을 겁니다.&lt;/p&gt;
&lt;p&gt;가장 정통적인 학습 자료를 원한다면 당연히 마이크로소프트 공식 자료여야 합니다. 다소 지루할 수 있지만, 새로운 독자들은 인내심을 가져야 합니다.&lt;/p&gt;
&lt;p&gt;고전적인 전자책도 많지만, 크게 추천하지는 않아요. 일상 업무가 많아서 책을 읽을 시간이 많지 않고, 한 번에 몰입하기 어렵네요. 프로젝트 연습이 더 적합할 것 같아요.&lt;/p&gt;
&lt;h2 id=&#34;c-및-net-출시-기록&#34;&gt;C# 및 .NET 출시 기록
&lt;/h2&gt;&lt;p&gt;이전 학습했던 언어에 비해 최근 몇 년간 새롭게 추가된 기능이 조금 많아지고, 매년 문법 버전이 업데이트되고 있습니다&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/C_Sharp_%28programming_language%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://en.wikipedia.org/wiki/C_Sharp_(programming_language)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;공식 학습 자료:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/dotnet/csharp/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/dotnet/csharp/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/dotnet/core/tutorials/with-visual-studio?pivots=dotnet-7-0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/dotnet/core/tutorials/with-visual-studio?pivots=dotnet-7-0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>지리적 분산 환경의 ZeroTier</title>
        <link>https://blog.ttf248.life/ko/p/zero-tier-remote-lan/</link>
        <pubDate>Tue, 19 Sep 2023 04:58:03 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/zero-tier-remote-lan/</guid>
        <description>&lt;p&gt;사무실에 새 __INLINE_CODE_0__主机，想着配置配置环境方便，在家偶尔也有访问的需求，临时部署内网穿透。按照以往的经验，部署__INLINE_CODE_1__服务，指定端口转发，需要一台公网的服务器，连接的质量取决于公网服务器的宽带质量。折腾一点新鲜的__INLINE_CODE_2__虚拟机局域网，类似于__INLINE_CODE_3__을 구입했고, 로컬에서 가상 네트워크 어댑터를 새로 만들어서 모든 장비를 하나의 가상 네트워크에 연결했습니다&lt;/p&gt;
&lt;h2 id=&#34;제로티어는-무엇인가요&#34;&gt;제로티어는 무엇인가요?
&lt;/h2&gt;&lt;p&gt;__INLINE_CODE_0__BOLD_3&lt;code&gt;SD-WAN&lt;/code&gt;BOLD_4&lt;code&gt;ZeroTier&lt;/code&gt;，여러 대의 컴퓨터, 서버 및 장치를 마치 동일한 로컬 네트워크에 있는 것처럼 가상적이고 암호화된 네트워크로 쉽게 연결할 수 있습니다. 이를 통해 프로그래머와 IT 전문가는 복잡한 네트워크 설정이나 VPN 구성 없이 서로 다른 위치에서 데이터와 리소스를 안전하게 공유할 수 있습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;제로티어 네트워크는 가상 전역 LAN으로, 서로 다른 장치들이 인터넷을 통해 연결되어 마치 동일한 물리 네트워크에 있는 것처럼 작동합니다. 이 네트워크는 여러 서브넷을 포함할 수 있으며, 모든 장치는 제로티어 기술을 통해 연결됩니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;行星服务器&lt;/strong&gt;: 행성 서버는 Zerotier 네트워크의 핵심 구성 요소 중 하나입니다. 이 서버는 글로벌 네트워크로서 Zerotier 네트워크 전체의 토폴로지 구조, 라우팅 정보 및 네트워크 상태를 유지하고 관리합니다. 행성 서버는 네트워크 제어 센터 역할을 하지만 데이터를 직접 전송하지 않습니다. 사용자 장치는 Zerotier 네트워크에 참여하기 위해 최소한 하나의 행성 서버에 연결해야 합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;중계 서버는 Zerotier 네트워크에서 보조 노드로, 장치 간 직접 통신 채널을 설정하는 데 도움을 줍니다. 장치가 서로 직접 연결할 수 없을 때 중계 서버를 통해 데이터를 전송할 수 있습니다. 이는 네트워크의 가용성과 성능을 향상시키는 데 도움이 됩니다. 중계 서버는 일반적으로 전 세계 곳곳에 위치하여 데이터 전송의 경유지가 됩니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;전반적으로 Zerotier는 행성 서버와 중계 서버의 도움을 받아 전 세계에 가상 로컬 네트워크를 구축하여 장치 간 안전하고 빠른 통신을 가능하게 합니다. 행성 서버는 전체 네트워크 관리를 담당하며, 중계 서버는 필요 시 장치 간 통신 연결을 돕습니다.&lt;/p&gt;
&lt;h2 id=&#34;설치-배포&#34;&gt;설치 배포
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;ZeroTier 공식 웹사이트(&lt;a class=&#34;link&#34; href=&#34;https://www.zerotier.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.zerotier.com/&lt;/a&gt;)에서 설치 파일 및 문서를 확인하세요&lt;/li&gt;
&lt;li&gt;귀하의 운영 체제에 따라 ZeroTier One 클라이언트를 다운로드하여 설치하십시오. Windows, macOS, Linux 및 기타 여러 플랫폼을 지원합니다.&lt;/li&gt;
&lt;li&gt;설치 후 ZeroTier One 클라이언트를 시작합니다&lt;/li&gt;
&lt;li&gt;ZeroTier 계정이 아직 없으시다면, 계정을 만드세요. 클라이언트에서 계정 생성이 가능합니다.&lt;/li&gt;
&lt;li&gt;제로티어 계정에 로그인하여 새 네트워크를 만드세요. 네트워크에는 고유한 16자리 ID가 있으며, 이를 기억해야 합니다.&lt;/li&gt;
&lt;li&gt;귀하의 장치에 이 네트워크를 추가합니다. 클라이언트에서 네트워크 ID를 입력하거나 QR 코드 스캔 기능을 사용할 수 있습니다.&lt;/li&gt;
&lt;li&gt;ZeroTier 클라이언트가 설치 및 구성된 장치는 동일한 가상 네트워크에 추가됩니다. 이제 이러한 장치들은 마치 동일한 로컬 영역 네트워크에 있는 것처럼 직접 통신할 수 있습니다.&lt;/li&gt;
&lt;li&gt;ZeroTier 제어판에서 네트워크 설정 관리, 장치 추가 및 네트워크 트래픽 모니터링 등을 할 수 있습니다&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;문-설치-배포&#34;&gt;문 설치 배포
&lt;/h2&gt;&lt;p&gt;국내 통신사들은 대부분 &lt;code&gt;UDP&lt;/code&gt;BOLD_5__INLINE_CODE_1__服务稳定，由于走的__INLINE_CODE_2__BOLD_7&lt;code&gt;Zerotier&lt;/code&gt;部署中转服务器也能实现类似的效果，防火墙需要开放__INLINE_CODE_4__을 금지하고 있습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -s https://install.zerotier.com/ | sudo bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;설치 성공 여부 확인&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zerotier-cli info
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;로컬 네트워크에 연결하기&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zerotier-cli join network-id
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;생성&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd /var/lib/zerotier-one &amp;amp;&amp;amp; sudo zerotier-idtool initmoon identity.public &amp;gt; moon.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;설정 파일을 편집하여 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 노드를 &amp;ldquo;서버 공공 IP/9993&amp;quot;으로 조정합니다&lt;/p&gt;
&lt;p&gt;서명 구성 생성, &lt;code&gt;moons.d&lt;/code&gt; 폴더 생성 후 해당 파일들을 옮긴 뒤 서비스를 재시작합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo zerotier-idtool genmoon moon.json
mkdir moons.d &amp;amp;&amp;amp; mv 000000eb444ec0d8.moon moons.d/
systemctl restart zerotier-one.service
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;클라이언트 노드가 문(moon) 서버에 접속하며, ID는 앞선 JSON 설정 파일의 ID 필드에서 가져옵니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zerotier-cli.bat orbit ztaddr ztaddr
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 观察是否出现新的 mooon 节点，id 和信息为服务器配置的相同
[root@idv-36f9d5 ~]# zerotier-cli listpeers
200 listpeers &amp;lt;ztaddr&amp;gt; &amp;lt;path&amp;gt; &amp;lt;latency&amp;gt; &amp;lt;version&amp;gt; &amp;lt;role&amp;gt;
200 listpeers 0cccb***** 35.236.*.*/64393;110;10726 327 1.6.3 LEAF
200 listpeers 3a46f***** 185.180.*.*/9993;110;757 -1 - PLANET
200 listpeers 3ed7c***** 39.97.*.*/9993;172;79 32 1.6.3 MOON
200 listpeers 4f838***** - -1 - LEAF
200 listpeers 62f86***** 50.7.*.*/9993;110;4796 351 - PLANET
200 listpeers 778cd***** 103.195.*.*/9993;5148;4887 253 - PLANET
200 listpeers 992fc***** 195.181.*.*/9993;10161;4921 226 - PLANET
200 listpeers 9d2b5***** - -1 - LEAF
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Windows 플랫폼에서는 관리자 권한으로 터미널을 실행하고 zerotier-cli.bat 명령줄 도구를 사용하여 운영하며, Linux 플랫폼에서는 zerotier-cli를 사용합니다. peers 서브 명령어는 연결 상태를 확인하고, listpeers는 모든 노드를 표시하며, &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 노드가 정상적으로 표시되면 성공적으로 추가된 것을 의미합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;어떻게-제거하나요&#34;&gt;어떻게 제거하나요
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Windows&lt;/code&gt;平台如何卸载不再赘述，常规操作，通过控制面板卸载即可，我们重点说下&lt;code&gt;ubuntu&lt;/code&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;dpkg를 통해 zerotier-one 서비스 삭제&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo dpkg -P zerotier-one
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;zerotier-one 폴더를 삭제하면 주소가 저장된 파일이 제거되고, 다시 설치하면 새로운 주소를 얻을 수 있습니다&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo rm -rf /var/lib/zerotier-one/
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;p&gt;원래 다 이미 삭제했는데, 서버는 도착했고 적절한 프록시 노드 역할을 할 서비스가 없었다. 알리바바 클라우드는 실적을 위해 개발 전용 서버를 제공했는데, 사양이 높지 않고 99원에 1년 구독이라 가격이 저렴해서 두 년 정도 사용했다. 서버에서 제공하는 대역폭이 마음에 들어서였다.&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.wnark.com/archives/152.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.wnark.com/archives/152.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/Yogile/p/12642423.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cnblogs.com/Yogile/p/12642423.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>VMware 가상 머신 디스크 공간 최적화</title>
        <link>https://blog.ttf248.life/ko/p/vmware-virtual-disk-space-optimization/</link>
        <pubDate>Wed, 21 Jun 2023 18:35:41 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/vmware-virtual-disk-space-optimization/</guid>
        <description>&lt;p&gt;가상 머신을 설치하고 개발 시스템을 사용할 때, 보통 디스크 공간을 넉넉히 확보해두는데, 시간이 지나면 실제 파일 내용보다 훨씬 더 많은 로컬 디스크 공간을 차지하게 됩니다&lt;/p&gt;
&lt;h2 id=&#34;장면-묘사&#34;&gt;장면 묘사
&lt;/h2&gt;&lt;p&gt;명령을 내린 후, 현재 기계의 디스크 정보를 확인하니 실제 사용량은 60GB였고, 모든 스냅샷과 클론 이미지를 삭제했음에도 불구하고 로컬 가상 머신이 차지하는 디스크 공간은 여전히 60GB를 훨씬 넘었다. 본래 부족한 하드디스크에 더 큰 부담을 주게 되었다.&lt;/p&gt;
&lt;h2 id=&#34;전제-조건&#34;&gt;전제 조건
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;가상 머신 설치 시, 미리 할당된 디스크 옵션을 선택하지 않았습니다&lt;/li&gt;
&lt;li&gt;가상 머신이 사용하는 공간보다 남은 디스크 공간이 더 큰 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;남은 공간이 부족하므로, 임시로 가상 머신을 외장 하드로 옮긴 후 디스크를 최적화한 다음 다시 이전하는 것을 고려해 볼 수 있습니다&lt;/p&gt;
&lt;h2 id=&#34;도구&#34;&gt;도구
&lt;/h2&gt;&lt;p&gt;공식적으로 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 패키지를 제공하며, yum을 통해 설치하거나 VMware Tools 이미지 패키지로 설치할 수 있습니다&lt;/p&gt;
&lt;h2 id=&#34;명령&#34;&gt;명령
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vmware-toolbox-cmd disk shrink /
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;실행하면 가상 머신이 자동으로 종료되고 VMware 호스트 프로그램은 디스크 압축을 실행합니다. 실행 시간은 가상 머신의 크기와 디스크 액세스 속도에 따라 달라집니다.&lt;/p&gt;
&lt;p&gt;가상 머신의 디스크 공간 점유는 __INLINE_CODE_0__의 디스크 정보와 거의 동일합니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>스테이블 디퓨전 - 제로베이스 설치의 흥망성쇠</title>
        <link>https://blog.ttf248.life/ko/p/stable-diffusion-zero-install-saga/</link>
        <pubDate>Thu, 13 Apr 2023 00:23:54 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/stable-diffusion-zero-install-saga/</guid>
        <description>&lt;p&gt;국내 자료들을 보니, 기본적으로 &lt;strong&gt;秋叶&lt;/strong&gt; 전문가의 원클릭 배포 패키지를 추천하는 것 같아. &lt;code&gt;Python&lt;/code&gt; 기반 오픈소스 프로젝트라서 복잡하지 않을 테니, 일단 처음부터 시작해 보려고 해.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;AI 생성 이미지 만들려고 그래픽 카드까지 바꿨는데, &lt;strong&gt;INLINE_CODE_0__入门版本；服役七年的__INLINE_CODE_1&lt;/strong&gt; 영광스럽게 종료되네요&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;핵심 암호화가 계속 활성화되지 않습니다&lt;/p&gt;
&lt;h2 id=&#34;미처리&#34;&gt;미처리
&lt;/h2&gt;&lt;p&gt;기사 구조를 재구성하여 pytorch, 버전 호환성, 버전을 확인하는 방법을 먼저 소개합니다
로컬에서 어떻게 처음부터 가상 환경을 만들고 PyTorch를 배포할 수 있나요?
3. 번역 작업, Stable Diffusion 설치부터 시작 &lt;a class=&#34;link&#34; href=&#34;https://stable-diffusion-art.com/install-windows/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stable-diffusion-art.com/install-windows/&lt;/a&gt;
자료 정리&lt;/p&gt;
&lt;h2 id=&#34;단계&#34;&gt;단계
&lt;/h2&gt;&lt;p&gt;중국어로 검색해도 관련 단계별 설치 튜토리얼을 찾기 어려울 수 있습니다. __INLINE_CODE_0__BOLD_3&lt;code&gt;git&lt;/code&gt;BOLD_4&lt;code&gt;python&lt;/code&gt; 후, 저장소를 다운로드하고 스크립트를 더블 클릭하면 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/AUTOMATIC1111/stable-diffusion-webui&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;자세한 사용법 및 Q&amp;amp;A는 &lt;code&gt;issues&lt;/code&gt;，&lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki&lt;/a&gt;에서 확인하세요&lt;/p&gt;
&lt;p&gt;저도 왜인지 모르겠지만 이 창고가 뭐하는 곳인지 설명해 주는 사람이 없네요. 사실 이름만 봐도 알 수 있습니다. 인터페이스 콘솔이고, 우리를 더 편리하게 사용할 수 있도록 해 줍니다. 실제로 설치할 때, 그는 공식 저장소 내용을 다운로드하여 실제 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 코드를 가져옵니다.&lt;/p&gt;
&lt;p&gt;저장소와 함께 설치 시작 스크립트도 만들었습니다. 현재 폴더에 __INLINE_CODE_0__虚拟环境。如果有的话默认使用当前路径的的__INLINE_CODE_1__이 있는지 자동으로 인식합니다.&lt;/p&gt;
&lt;p&gt;순수 백지 사용자라면, &lt;a class=&#34;link&#34; href=&#34;https://stable-diffusion-art.com/install-windows/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stable-diffusion-art.com/install-windows/&lt;/a&gt;을 확인해 보세요&lt;/p&gt;
&lt;h2 id=&#34;pytorch&#34;&gt;pytorch
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://pytorch.org/get-started/locally/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pytorch.org/get-started/locally/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;여기서 제가 오늘 말씀드리고 싶은 건, 우선 그들의 단계대로 스크립트를 바로 실행하지 마세요. Python은 requirement 파일로 의존성 라이브러리를 설치하는데, 이건 별거 아니에요. 핵심은 그래픽 카드 드라이버 버전이 PyTorch와 호환되는지 확인하는 겁니다. 이 부분에 대한 정보도 많은 자료가 있으니 인터넷에서 찾아보시면 됩니다.&lt;/p&gt;
&lt;p&gt;참조: &lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/weixin_40660408/article/details/129896700&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/weixin_40660408/article/details/129896700&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;가상 환경을 하나 만들고, 빈 가상 환경에서 바로 공식 웹사이트 스크립트를 실행하여 pytorch를 설치하면 됩니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python -c &amp;quot;import torch; print(torch.version.cuda)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python -c &amp;quot;import torch; print(torch.__version__, torch.cuda.is_available())&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위에 두 스크립트는 설치해야 할 CUDA 버전을 확인하고, 설치 성공 여부를 확인할 수 있습니다&lt;/p&gt;
&lt;p&gt;여기 화려한 조작은 권장하지 않습니다. 공식 페이지의 로직을 그대로 복사해서 설치하면 되고, pip으로 설치하면 실패하거나 CUDA가 활성화되지 않을 가능성이 높습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;중요: 폴더 경로에 불필요한 내용이 있으면 pytorch 사용이 어려워질 수 있습니다&lt;/p&gt;
&lt;p&gt;중간에 여러 번 설치하고, 공식 설치 파일을 다운로드하여 수동으로 설치하는 방법도 시도했습니다. 2.0 버전으로 업그레이드하려고 했는데, 공식 문서에는 2.0 버전이 속도가 빠르다고 되어 있습니다. 하지만 이전에는 많이 사용하지 않았고, Python 버전과 이것이 영향을 미치는지도 모르겠습니다. 중간에 공식 매뉴얼을 살펴보니 3.8 버전을 사용하는 것이 좋다고 합니다. 이로 인해 약간의 충돌이 발생했는데, 기존에 원클릭 설치 패키지를 사용했더니 그 안에 3.10 버전이 포함되어 있었습니다. 결국 처음부터 다시 시작하여 새 폴더를 만들고 가상 환경을 생성하고 torch가 성공적으로 설치되었는지 확인했습니다.&lt;/p&gt;
&lt;p&gt;그런 다음 이 설치된 가상 환경을 웹 UI 폴더 안으로 이동하세요. 그러면 스크립트 설치 시 다른 의존성 문제는 크게 줄어들 겁니다.&lt;/p&gt;
&lt;p&gt;이동 후에는 다음을 실행하세요: python -m pip install &amp;ndash;upgrade &amp;ndash;force-reinstall pip로 pip를 수정합니다&lt;/p&gt;
&lt;p&gt;꽤 엉뚱해 보일 수도 있지만, 이 부분은 한참을 고생했어요. 제 torch를 제대로 인식하지 못해서요. 모든 간섭 요소를 배제하기 위해 먼저 이걸 설치한 다음에 다른 의존성 라이브러리를 설치하려고 했어요.&lt;/p&gt;
&lt;h2 id=&#34;xformers&#34;&gt;Xformers
&lt;/h2&gt;&lt;p&gt;권장 설정입니다. 이미지 생성 속도를 높이고 기존 사용량을 줄여줍니다. 부작용은 &lt;strong&gt;生成的图像相对不是那么稳定&lt;/strong&gt; 입니다.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Xformers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;stable-diffusion-webui:Xformers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://huggingface.co/docs/diffusers/optimization/xformers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;huggingface optimization&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Optimization Ratio&lt;/th&gt;
&lt;th&gt;Time taken&lt;/th&gt;
&lt;th&gt;Torch active/reserved&lt;/th&gt;
&lt;th&gt;Sys VRAM&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;100.00%&lt;/td&gt;
&lt;td&gt;2m 57.03s&lt;/td&gt;
&lt;td&gt;7440/10058 MiB&lt;/td&gt;
&lt;td&gt;12288/12288 MiB (100.0%)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;51.02%&lt;/td&gt;
&lt;td&gt;1m 29.21s&lt;/td&gt;
&lt;td&gt;4547/7164 MiB&lt;/td&gt;
&lt;td&gt;9298/12288 MiB (75.67%)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;((masterpiece)),((best quality)),((high detial)),((realistic,))
Industrial age city, deep canyons in the middle,chinese architectural streets,bazaars, Bridges, (rainy days:1.2), (steampunk:0.8), chinese architecture
Negative prompt: nsfw,((cowboy)),(((pubic))), ((((pubic_hair))))sketch, duplicate, ugly, huge eyes, text, logo, monochrome, worst face, (bad and mutated hands:1.3), (worst quality:2.0), (low quality:2.0), (blurry:2.0), horror, geometry, bad_prompt, (bad hands), (missing fingers), multiple limbs, bad anatomy, (interlocked fingers:1.2), Ugly Fingers, (extra digit and hands and fingers and legs and arms:1.4), crown braid, ((2girl)), (deformed fingers:1.2), (long fingers:1.2),succubus wings,horn,succubus horn,succubus hairstyle, (bad-artist-anime), bad-artist, bad hand, borrowed character, text focus, watermark, sample watermark, character watermark, lofter username, photo date watermark, movie poster, magazine cover, journal, cover, cover page, doujin cover, album cover, manga cover, brand name imitation, EasyNegative,Tights, silk stockings,shorts
Steps: 35, Sampler: DPM adaptive, CFG scale: 5.5, Seed: 2223996555, Size: 1088x1088, Model hash: 543bcbc212, Model: base_Anything-V3.0-pruned, Clip skip: 2, ENSD: 31337
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;p&gt;원래 추천하는 원클릭 배포 패키지가 아니라서요. 그 패키지 안에는 작성자가 개인적으로 설정한 부분이 있어서, 공식 버전과 완전히 동일하지 않거든요. 초보자라면 왜 그런 설정을 해야 하는지 모를 수 있으니, 일단은 공식 버전을 사용하는 게 좋습니다. 사용 시간이 늘어날수록 공식 매뉴얼을 살펴보면 어떤 파라미터를 조정해야 할지 알게 될 거예요.&lt;/p&gt;
&lt;h2 id=&#34;그래픽카드-선택&#34;&gt;그래픽카드 선택
&lt;/h2&gt;&lt;p&gt;데이터 화폐 채굴 이후, 그래픽카드 가격이 상대적으로 많이 내렸고, 일반적인 초보 유저라면 &lt;strong&gt;INLINE_CODE_0__BOLD_4&lt;code&gt;3060ti&lt;/code&gt;BOLD_5__INLINE_CODE_2__版本的3060，毕竟能生成更大分辨率的图，为什么需要更大的分辨率，因为你可以在生成的时候，把分辨率调大，这样生成的图像就会更加清晰，更加细腻。如果你是想要生成一些小图，那么__INLINE_CODE_3&lt;/strong&gt; VRAM도 충분합니다&lt;/p&gt;
&lt;p&gt;아직 한 가지 더 있는데, &lt;strong&gt;高清放大&lt;/strong&gt; 옵션은 디테일을 구체화하여 화면의 디테일을 더욱 풍부하게 만들지만, 더 많은 비디오 메모리가 필요합니다&lt;/p&gt;
&lt;p&gt;다음은 NVIDIA GeForce GTX 970, GeForce RTX 3060 Ti, GeForce RTX 3060, GeForce RTX 3080 및 GeForce RTX 3080 Ti의 단정밀도(FP32), 반정밀도(FP16) 및 배정밀도(FP64) 부동소수점 연산 능력 사양 요약표입니다&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;그래픽 카드 모델&lt;/th&gt;
&lt;th&gt;출시 연도&lt;/th&gt;
&lt;th&gt;단정밀도 부동소수점 연산 능력 (TFLOPS)&lt;/th&gt;
&lt;th&gt;반정밀도 부동소수점 연산 능력 (TFLOPS)&lt;/th&gt;
&lt;th&gt;배정밀도 부동소수점 연산 능력 (TFLOPS)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GeForce GTX 970&lt;/td&gt;
&lt;td&gt;2014&lt;/td&gt;
&lt;td&gt;3.49&lt;/td&gt;
&lt;td&gt;87.2&lt;/td&gt;
&lt;td&gt;0.109&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3060 Ti&lt;/td&gt;
&lt;td&gt;2020&lt;/td&gt;
&lt;td&gt;16.2&lt;/td&gt;
&lt;td&gt;32.4&lt;/td&gt;
&lt;td&gt;0.51&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3060&lt;/td&gt;
&lt;td&gt;2021&lt;/td&gt;
&lt;td&gt;12.7&lt;/td&gt;
&lt;td&gt;25.4&lt;/td&gt;
&lt;td&gt;0.39&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3080&lt;/td&gt;
&lt;td&gt;2020&lt;/td&gt;
&lt;td&gt;29.8&lt;/td&gt;
&lt;td&gt;58.9&lt;/td&gt;
&lt;td&gt;0.93&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GeForce RTX 3080 Ti&lt;/td&gt;
&lt;td&gt;2021&lt;/td&gt;
&lt;td&gt;34.8&lt;/td&gt;
&lt;td&gt;68.7&lt;/td&gt;
&lt;td&gt;1.36&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;링크된 내용입니다&lt;/p&gt;
&lt;h2 id=&#34;업데이트&#34;&gt;업데이트
&lt;/h2&gt;&lt;p&gt;반년 정도의 공백을 두고, 설치 단계 정리나 기초 개념 설명도 하고 싶었지만, 결국 일반인들은 AI 그림을 그리는 것이 고수들이 제공한 이미지 파라미터를 기반으로 조정하거나, 기존 이미지를 바탕으로 형식화된 재렌더링에 불과하다는 것을 알게 되었다&lt;/p&gt;
&lt;p&gt;중간에 AI로 미니 프로그램 UI 소재를 그리는 프로젝트가 있었는데, 반쯤 포기하고 직접 공식 미니 프로그램에서 리소스를 가져오는 게 더 나은 것 같아&lt;/p&gt;</description>
        </item>
        <item>
        <title>프로그램 최적화는 하드웨어를 상대하려 하지 마세요</title>
        <link>https://blog.ttf248.life/ko/p/program-optimization-dont-fight-hardware/</link>
        <pubDate>Fri, 07 Apr 2023 16:30:15 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/program-optimization-dont-fight-hardware/</guid>
        <description>&lt;p&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;，耗时已经在**마이크로초 &lt;strong&gt;수준에서, 서버 교체 시 최대 6만 개의 데이터 패킷이 지연되던 것이 거의 지연되지 않게 되었습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;단일 스레드 루프 처리 시 CPU 성능은 클럭 속도, 캐시 크기, 명령어 집합 아키텍처 등의 요인에 따라 달라진다. 일반적으로 클럭 속도가 높고, 캐시가 크며, 명령어 집합 아키텍처가 발전할수록 단일 스레드 데이터 처리 성능이 향상된다.&lt;/p&gt;
&lt;h2 id=&#34;단일-스레드&#34;&gt;단일 스레드
&lt;/h2&gt;&lt;p&gt;성능 향상을 위해 스레드를 늘리는 것은 필수가 아니며, 프로젝트 흐름을 정리하고 병목 지점을 파악해야 합니다. 단일 스레드가 요구사항을 충족하는지 확인하고, 단일 스레드는 고려할 사항이 적고 문제 발생 가능성도 낮습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;바로 스레드를 추가하자는 말인데, 좀 이상하다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;사건&#34;&gt;사건
&lt;/h2&gt;&lt;p&gt;처리하는 것은 모두 &lt;strong&gt;行情数据，延迟敏感&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;죽어라 야근해서 새로운 최적화 버전 배포했고, 로컬 분리 인터페이스 테스트 결과 속도도 괜찮아, TPS: 4.2만&lt;/p&gt;
&lt;p&gt;서버에 배포 후 TPS가 급감했습니다: 21,000. 집에서 데스크톱으로 시도했을 때 TPS는 79,000이었습니다. 내부 서비스 가상화 환경에 문제가 있는 것 같아 의심되기 시작했는데, 우선 CPU 클럭 속도가 원인일 가능성이 높습니다. 가정용 데스크톱과 서버의 가장 큰 차이점은 바로 CPU 클럭 속도입니다.&lt;/p&gt;
&lt;p&gt;테스트 서버 A&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;processor	: 7
vendor_id	: GenuineIntel
cpu family	: 6
model		: 47
model name	: Intel(R) Xeon(R) CPU E7- 4807  @ 1.87GHz
stepping	: 2
microcode	: 0x34
cpu MHz		: 1866.733
cache size	: 18432 KB
physical id	: 1
siblings	: 4
core id		: 3
cpu cores	: 4
apicid		: 7
initial apicid	: 7
fpu		: yes
fpu_exception	: yes
cpuid level	: 11
wp		: yes
flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss ht syscall nx rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc cpuid aperfmperf pni pclmulqdq ssse3 cx16 sse4_1 sse4_2 popcnt aes hypervisor lahf_lm pti dtherm arat
bugs		: clflush_monitor cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit
bogomips	: 3733.46
clflush size	: 64
cache_alignment	: 64
address sizes	: 40 bits physical, 48 bits virtual
power management:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;테스트 서버 B&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;processor	: 7
vendor_id	: GenuineIntel
cpu family	: 6
model		: 63
model name	: Intel(R) Xeon(R) CPU E5-2640 v3 @ 2.60GHz
stepping	: 2
microcode	: 0x3c
cpu MHz		: 2599.998
cache size	: 20480 KB
physical id	: 14
siblings	: 1
core id		: 0
cpu cores	: 1
apicid		: 14
initial apicid	: 14
fpu		: yes
fpu_exception	: yes
cpuid level	: 15
wp		: yes
flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc cpuid aperfmperf pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand hypervisor lahf_lm cpuid_fault epb pti fsgsbase smep xsaveopt cqm_llc cqm_occup_llc dtherm ida arat pln pts
bugs		: cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit
bogomips	: 5199.99
clflush size	: 64
cache_alignment	: 64
address sizes	: 40 bits physical, 48 bits virtual
power management:
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;openai에-문의하세요&#34;&gt;OpenAI에 문의하세요
&lt;/h2&gt;&lt;p&gt;먼저 코어 수와 클럭 속도 측면에서 Intel(R) Xeon(R) CPU E7-4807 @ 1.87GHz는 6개의 물리 코어와 12개의 논리 코어를 가지고 있으며, 클럭 속도는 1.87GHz입니다. 반면에 Intel(R) Xeon(R) CPU E5-2640 v3 @ 2.60GHz는 8개의 물리 코어와 16개의 논리 코어를 가지고 있으며, 클럭 속도는 2.60GHz입니다. 따라서 코어 수와 클럭 속도 측면에서 볼 때, E5-2640 v3가 단일 스레드 처리 시 E7-4807보다 더 유리할 것으로 예상됩니다.&lt;/p&gt;
&lt;p&gt;둘째, 캐시 크기 측면에서 E7-4807은 12MB의 캐시를 가지고 있는 반면, E5-2640 v3은 20MB의 캐시를 가지고 있습니다. 따라서 E5-2640 v3이 더 큰 캐시 공간을 제공하여 데이터 접근 속도와 캐시 히트율을 향상시킬 수 있습니다.&lt;/p&gt;
&lt;p&gt;마지막으로 아키텍처 측면에서 E5-2640 v3는 더 발전된 Haswell 아키텍처를 채택한 반면, E7-4807은 구형 Nehalem 아키텍처를 사용합니다. Haswell 아키텍처는 Nehalem 아키텍처에 비해 성능이 향상되었으며, 이는 E5-2640 v3의 단일 스레드 데이터 처리 성능 향상에 영향을 미칠 수 있습니다.&lt;/p&gt;
&lt;p&gt;따라서 종합적으로 고려했을 때, 단일 스레드 루프 처리 시나리오에서는 E5-2640 v3가 E7-4807보다 더 나은 성능을 보여줄 것으로 예상됩니다. 하지만 실제 성능 차이는 데이터 처리 알고리즘, 메모리 대역폭, 시스템 부하 등 다양한 요인의 영향을 받으므로, 구체적인 상황에 따라 분석해야 합니다.&lt;/p&gt;
&lt;h2 id=&#34;하드웨어-자료&#34;&gt;하드웨어 자료
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cpubenchmark.net/compare/3786.2vs2365.2/%5BDual-CPU%5D-Intel-Xeon-E7%e2%80%934807-vs-%5BDual-CPU%5D-Intel-Xeon-E5-2640-v3&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cpubenchmark.net/compare/3786.2vs2365.2/%5BDual-CPU%5D-Intel-Xeon-E7–4807-vs-%5BDual-CPU%5D-Intel-Xeon-E5-2640-v3&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Specification&lt;/th&gt;
&lt;th&gt;Xeon E7-4807 (LGA1567)&lt;/th&gt;
&lt;th&gt;Xeon E5-2640 v3 (LGA2011-v3)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Price&lt;/td&gt;
&lt;td&gt;Search Online  $78 - BUY&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Socket Type&lt;/td&gt;
&lt;td&gt;LGA1567&lt;/td&gt;
&lt;td&gt;LGA2011-v3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU Class&lt;/td&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Clockspeed&lt;/td&gt;
&lt;td&gt;1.9 GHz&lt;/td&gt;
&lt;td&gt;2.6 GHz&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Turbo Speed&lt;/td&gt;
&lt;td&gt;Not Supported&lt;/td&gt;
&lt;td&gt;Up to 3.4 GHz&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;# of Physical Cores&lt;/td&gt;
&lt;td&gt;6 (Threads: 12)&lt;/td&gt;
&lt;td&gt;8 (Threads: 16)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Cache&lt;/td&gt;
&lt;td&gt;NA2&lt;/td&gt;
&lt;td&gt;NA2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Max TDP&lt;/td&gt;
&lt;td&gt;95W x 2&lt;/td&gt;
&lt;td&gt;90W x 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Yearly Running Cost&lt;/td&gt;
&lt;td&gt;$34.68&lt;/td&gt;
&lt;td&gt;$32.85&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Other&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;First Seen on Chart&lt;/td&gt;
&lt;td&gt;Q3 2020&lt;/td&gt;
&lt;td&gt;Q3 2014&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;# of Samples&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;46&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU Value&lt;/td&gt;
&lt;td&gt;69.1&lt;/td&gt;
&lt;td&gt;225.6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Single Thread Rating&lt;/td&gt;
&lt;td&gt;721 (-59.2%)&lt;/td&gt;
&lt;td&gt;1767 (0.0%)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU Mark&lt;/td&gt;
&lt;td&gt;6223 (-64.6%)&lt;/td&gt;
&lt;td&gt;17600 (0.0%)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description>
        </item>
        <item>
        <title>프롬프트 엔지니어</title>
        <link>https://blog.ttf248.life/ko/p/prompt-engineer/</link>
        <pubDate>Sun, 26 Mar 2023 20:46:53 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/prompt-engineer/</guid>
        <description>&lt;p&gt;마치 과거 검색 엔진 사용법을 배운 것처럼, 우리는 __INLINE_CODE_0__과 소통하는 방법, 합리적이고 충분한 조건을 제시하여 필요한 답변을 효율적으로 얻는 방법을 배워야 합니다&lt;/p&gt;
&lt;p&gt;만약 다른 각도에서 접근해 본다면, 현재의 __INLINE_CODE_0__属于一个记忆力很好的小孩子，它拥有过目不忘的能力，有抄作业的能力。我们需要做的是学会如何正确、有效的和__INLINE_CODE_1__沟通，精准的描述需求，帮助__INLINE_CODE_2__이 예상하는 결과를 낼 수 있을 것이다&lt;/p&gt;
&lt;h2 id=&#34;과학-대중화&#34;&gt;과학 대중화
&lt;/h2&gt;&lt;p&gt;발사되는 듯 하늘을 찌르는 &lt;code&gt;AI&lt;/code&gt;确切的说__INLINE_CODE_1__은 직역하면 생성적 사전 훈련이다. 이는 인터넷에서 구할 수 있는 데이터로 학습된 텍스트 생성 심층 학습 모델이며, 질의응답, 텍스트 요약 생성, 기계 번역, 분류, 코드 생성 및 대화형 AI와 같은 작업에 사용된다. 현재 GPT-1, GPT-2, GPT-3 및 GPT-4 등 다양한 버전의 모델이 있으며, 각 버전은 이전 버전에 비해 더 크고 강력하다.&lt;/p&gt;
&lt;h2 id=&#34;정말-인공지능이-있을까&#34;&gt;정말 인공지능이 있을까?
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;유사도가 높을수록 정확도 또한 높아진다&lt;/li&gt;
&lt;li&gt;기본적이고 반복적인 업무는 특정 훈련을 거치면 더 이상 인공의 개입이 필요하지 않다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;생성형 AI는 기존의 텍스트, 오디오, 이미지 등 데이터를 활용하여 새로운 콘텐츠를 생성하는 기술입니다. 텍스트 생성, 음성 합성, 이미지 생성, 대화 시스템 등 다양한 작업에 사용될 수 있습니다. 생성형 AI의 논리성은 학습 데이터와 모델 구조에 따라 달라지며, 일반적으로 문법, 논리 및 상식을 어느 정도 따르지만 오류, 편향 또는 부정확한 내용을 포함할 수도 있습니다. 따라서 생성형 AI의 출력은 인간의 판단과 검증이 필요하며 맹목적으로 믿거나 사용할 수 없습니다.&lt;/p&gt;
&lt;h2 id=&#34;프롬프트-엔지니어&#34;&gt;프롬프트 엔지니어
&lt;/h2&gt;&lt;p&gt;시간의 흐름은 거슬러갈 수 없고, 사람은 변화에 적응해야 합니다. 당신이 __INLINE_CODE_0__을 비효율적이고 논리성이 없다고 생각할 수도 있습니다. 그것은 종종 쓸모없는 코드를 생성합니다.&lt;/p&gt;
&lt;p&gt;만약 다른 각도에서 접근해 본다면, 현재의 &lt;code&gt;AI&lt;/code&gt;属于一个记忆力很好的小孩子，它拥有过目不忘的能力，有抄作业的能力。我们需要做的是学会如何正确、有效的和&lt;code&gt;AI&lt;/code&gt;沟通，精准的描述需求，帮助&lt;code&gt;AI&lt;/code&gt;이 예상하는 결과를 낼 수 있을 것이다&lt;/p&gt;
&lt;h2 id=&#34;대화-모드&#34;&gt;대화 모드
&lt;/h2&gt;&lt;p&gt;두 해 전 __发布，谁也想不到两年后，__INLINE_CODE_0__이 __INLINE_CODE_1__과 함께 등장하여 인간에게 거대 언어 모델의 능력을 각인시켰다&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于注释的编程&lt;/strong&gt;와 &lt;strong&gt;基于对话的编程&lt;/strong&gt;를 기반으로, 상호 작용 방식이 완전히 다르며, 대화 모드는 초보 사용자에게 친숙한 경험을 제공합니다. 여기서는 반드시 &lt;code&gt;NewBing&lt;/code&gt;BOLD_4&lt;code&gt;AI&lt;/code&gt; 지식 데이터베이스 내 더 많은 내용을 언급해야 합니다.&lt;/p&gt;
&lt;h2 id=&#34;예시로-말하자면&#34;&gt;예시로 말하자면
&lt;/h2&gt;&lt;p&gt;고속철도 여행 시간은 길지만, 코딩이 좋은 선택이다. 데이터 사용량이 제한적인 상황에서 몇 장의 사진을 처리하고 이미지 자료를 얻었더니, 사진 편집 프로그램을 다운로드하여 처리하는 것은 다소 사치스럽고 네트워크 환경도 허락하지 않는다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt;: 이미지 자료 모음이 있는데, 투명 배경으로 되어 있고, 앱의 내비게이션 바에 사용하기 위한 것입니다. 선택된 상태는 컬러이고, 선택되지 않은 상태는 흑백입니다. 자료들은 모두 컬러로 되어 있으므로, 사전 처리 과정이 필요합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Prompt&lt;/strong&gt;: 폴더 내 모든 이미지를 읽어와서 흑백으로 변환하고, 투명 배경을 유지하며, 이미지 품질을 최적화하여 파일 크기를 줄인 후 저장하는 Python 코드를 작성하세요. 콘솔에 최적 전후 파일 크기 비교를 표시합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 导入必要的库
import os
import PIL
from PIL import Image

# 定义一个函数，将图片转换成黑白，维持透明背景，保存图片，并返回文件体积
def convert_and_save(image_file):
    # 打开图片
    image = Image.open(image_file)
    # 获取图片的模式，如果是 RGBA 模式，说明有透明背景
    mode = image.mode
    if mode == &amp;quot;RGBA&amp;quot;:
        # 创建一个和图片大小一致的白色背景图片
        background = Image.new(&amp;quot;RGB&amp;quot;, image.size, (255, 255, 255))
        # 将原图片粘贴到白色背景上，忽略透明像素
        background.paste(image, mask=image.split()[3])
        # 将合成的图片转换成灰度模式
        gray_image = background.convert(&amp;quot;L&amp;quot;)
        # 将灰度图片再转换成 RGBA 模式，以便保留透明背景
        final_image = gray_image.convert(&amp;quot;RGBA&amp;quot;)
    else:
        # 如果不是 RGBA 模式，直接将图片转换成灰度模式
        final_image = image.convert(&amp;quot;L&amp;quot;)
    # 获取原图片的文件名和扩展名
    file_name, file_ext = os.path.splitext(image_file)
    # 定义新图片的文件名，添加 _bw 后缀表示黑白
    new_file_name = file_name + &amp;quot;_bw&amp;quot; + file_ext
    # 保存新图片，并优化质量，减少文件体积
    final_image.save(new_file_name, optimize=True)
    # 获取原图片和新图片的文件体积，并返回
    old_size = os.path.getsize(image_file)
    new_size = os.path.getsize(new_file_name)
    return old_size, new_size

# 定义一个文件夹路径，存放所有的图片
folder_path = &amp;quot;images&amp;quot;
# 遍历文件夹中的所有文件
for file in os.listdir(folder_path):
    # 拼接完整的文件路径
    file_path = os.path.join(folder_path, file)
    # 判断是否是图片文件，根据扩展名判断，可以根据需要添加或修改扩展名
    if file_path.endswith((&amp;quot;.png&amp;quot;, &amp;quot;.jpg&amp;quot;, &amp;quot;.jpeg&amp;quot;, &amp;quot;.gif&amp;quot;)):
        # 调用函数，转换并保存图片，并获取文件体积
        old_size, new_size = convert_and_save(file_path)
        # 在控制台展示优化前后的文件体积大小对比
        print(f&amp;quot;{file}: {old_size} bytes -&amp;gt; {new_size} bytes&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빠르게 답을 내놓았지만, 보기에는 괜찮고 사용에도 문제는 없으나, 경험이 많은 프로그래머라면 아래 코드가 충분히 일반적이지 않으며 프로덕션 환경에 적용하기 어렵다고 느낄 것이다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;매개변수 고정됨&lt;/li&gt;
&lt;li&gt;로그 파일이 없고, 정보는 모두 콘솔에 출력됩니다&lt;/li&gt;
&lt;li&gt;이미지 처리는 멀티스레드 모델에 적합합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 코드 개선할 부분 있을까요?&lt;/p&gt;
&lt;p&gt;제공된 답변은 솔직히 기대 이상이었고, 일반 프로그래머가 생각할 수 있는 최적화 방안에 대한 구체적인 제안들이 모두 포함되어 있습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;这段代码可能还有一些可以改进的地方，比如：

可以使用 argparse 库，让用户可以通过命令行参数指定文件夹路径和扩展名，而不是写死在代码里。
可以使用 logging 库，记录程序的运行情况，而不是直接打印到控制台。
可以使用 try-except 语句，捕获可能出现的异常，比如文件打开失败，图片转换失败等，并做相应的处理。
可以使用 multiprocessing 库，利用多核处理器，加速图片的转换和保存过程。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;매우 친절한 응답입니다. 배포 환경의 차이를 고려하여 다중 프로세스를 지원하지 않아도 괜찮습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;当然，我很乐意帮你修改一下代码。我尝试添加了 argparse, logging 和 try-except 语句，但没有添加 multiprocessing 库，因为我不确定你的电脑是否支持多核处理。修改后的代码如下：
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 导入必要的库
import argparse
import logging
import multiprocessing
import os

from PIL import Image


# 定义一个函数，将图片转换成黑白，维持透明背景，保存图片，并返回文件体积
def convert_and_save(image_file):
    # 打开图片
    try:
        image = Image.open(image_file)
    except Exception as e:
        logging.error(f&amp;quot;Failed to open {image_file}: {e}&amp;quot;)
        return None, None
    # 获取图片的模式，如果是 RGBA 模式，说明有透明背景
    mode = image.mode
    if mode == &amp;quot;RGBA&amp;quot;:
        # 创建一个和图片大小一致的白色背景图片
        background = Image.new(&amp;quot;RGB&amp;quot;, image.size, (255, 255, 255))
        # 将原图片粘贴到白色背景上，忽略透明像素
        background.paste(image, mask=image.split()[3])
        # 将合成的图片转换成灰度模式
        gray_image = background.convert(&amp;quot;L&amp;quot;)
        # 将灰度图片再转换成 RGBA 模式，以便保留透明背景
        final_image = gray_image.convert(&amp;quot;RGBA&amp;quot;)
    else:
        # 如果不是 RGBA 模式，直接将图片转换成灰度模式
        final_image = image.convert(&amp;quot;L&amp;quot;)
    # 获取原图片的文件名和扩展名
    file_name, file_ext = os.path.splitext(image_file)
    # 定义新图片的文件名，添加 _bw 后缀表示黑白
    new_file_name = file_name + &amp;quot;_bw&amp;quot; + file_ext
    # 保存新图片，并优化质量，减少文件体积
    try:
        final_image.save(new_file_name, optimize=True)
    except Exception as e:
        logging.error(f&amp;quot;Failed to save {new_file_name}: {e}&amp;quot;)
        return None, None
    # 获取原图片和新图片的文件体积，并返回
    old_size = os.path.getsize(image_file)
    new_size = os.path.getsize(new_file_name)
    return file_name, old_size, new_size

# 定义一个函数，解析命令行参数，并返回文件夹路径和扩展名列表
def parse_args():
    # 创建一个解析器对象
    parser = argparse.ArgumentParser(description=&amp;quot;Convert images to black and white and optimize quality.&amp;quot;)
    # 添加一个必选的位置参数，表示文件夹路径
    parser.add_argument(&amp;quot;folder_path&amp;quot;, help=&amp;quot;The path of the folder that contains the images.&amp;quot;)
    # 添加一个可选的参数，表示扩展名列表，默认为 png, jpg, jpeg 和 gif
    parser.add_argument(&amp;quot;-e&amp;quot;, &amp;quot;--extensions&amp;quot;, nargs=&amp;quot;+&amp;quot;, default=[&amp;quot;.png&amp;quot;, &amp;quot;.jpg&amp;quot;, &amp;quot;.jpeg&amp;quot;, &amp;quot;.gif&amp;quot;], help=&amp;quot;The extensions of the image files.&amp;quot;)
    # 解析命令行参数，并返回结果对象
    args = parser.parse_args()
    return args.folder_path, args.extensions

# 定义一个函数，打印优化前后的文件体积大小对比
def print_result(result):
    # 如果结果不为空，说明转换和保存成功
    if result:
        # 解包结果为文件名和文件体积元组
        if len(result) == 3:
            file, old_size, new_size = result
            # 在控制台展示优化前后的文件体积大小对比
            logging.info(f&amp;quot;{file}: {old_size} bytes -&amp;gt; {new_size} bytes&amp;quot;)
        else:
            logging.info(f&amp;quot;{result}&amp;quot;)

# 配置日志记录器，将日志输出到控制台和文件中，设置日志等级为 INFO
logging.basicConfig(level=logging.INFO,
                    format=&amp;quot;%(asctime)s %(levelname)s %(message)s&amp;quot;,
                    handlers=[logging.StreamHandler(),
                              logging.FileHandler(&amp;quot;log.txt&amp;quot;)])

# 调用函数，获取文件夹路径和扩展名列表
folder_path, extensions = parse_args()

if __name__ == &amp;quot;__main__&amp;quot;:
    # Windows 需要这个函数的原因是 Windows 缺乏 fork() 函数（这不完全正确）。
    # 因此，在 Windows 上，fork() 是通过创建一个新的进程来模拟的，这个新的进程中运行的代码，在 Linux 上是在子进程中运行的。
    # 由于这些代码要在技术上无关的进程中运行，所以它必须在运行之前被传递到那里。
    # 传递的方式是先将它们序列化，然后通过管道从原始进程发送到新的进程。
    # 另外，这个新的进程被通知它必须运行通过管道传递的代码，通过向它传递 --multiprocessing-fork 命令行参数。
    # 如果你看一下 freeze_support() 函数的实现，它的任务是检查它运行在哪个进程中，是否应该运行通过管道传递的代码
    multiprocessing.freeze_support()

    # 创建一个进程池，根据电脑的核心数自动分配进程
    pool = multiprocessing.Pool()
    # 创建一个空列表，用于存放异步任务的结果对象
    results = []
    # 遍历文件夹中的所有文件
    for file in os.listdir(folder_path):
        # 拼接完整的文件路径
        file_path = os.path.join(folder_path, file)
        # 判断是否是图片文件，根据扩展名判断，可以根据需要修改扩展名列表
        if any(file_path.endswith(ext) for ext in extensions):
            # 调用函数，转换并保存图片，并获取文件体积，使用异步方式，不阻塞主进程
            result = pool.apply_async(convert_and_save, args=(file_path,), callback=print_result)
            # 将结果对象添加到列表中
            results.append((file, result))
    # 关闭进程池，不再接受新的任务
    pool.close()
    # 等待所有的任务完成
    pool.join()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;p&gt;로컬 개발 중 __系统，__INLINE_CODE_0__第一次给出的答案，并没有加上__INLINE_CODE_1__函数，也没有__INLINE_CODE_2__BOLD_5&lt;code&gt;multiprocessing.freeze_support&lt;/code&gt; 오류가 발생하여, 질문을 통해 오류를 추적하고 코드를 수정했습니다&lt;/p&gt;
&lt;p&gt;마치 과거 검색 엔진 사용법을 배운 것처럼, 우리는 __INLINE_CODE_0__과 소통하는 방법, 합리적이고 충분한 조건을 제시하여 필요한 답변을 효율적으로 얻는 방법을 배워야 합니다&lt;/p&gt;
&lt;p&gt;주의:&lt;/p&gt;</description>
        </item>
        <item>
        <title>위챗 미니 프로그램 배경 및 개발 환경</title>
        <link>https://blog.ttf248.life/ko/p/wechat-mini-program-background-and-development-environment/</link>
        <pubDate>Fri, 24 Mar 2023 21:59:11 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/wechat-mini-program-background-and-development-environment/</guid>
        <description>&lt;p&gt;위챗 미니 프로그램 소개 및 개발 준비&lt;/p&gt;
&lt;h2 id=&#34;왜-소규모-프로그램이-있을까&#34;&gt;왜 소규모 프로그램이 있을까?
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;더 나은 경험: 내장된 웹 페이지 로딩 속도 저하, 백 화면 발생; 네이티브 앱의 경험은 더 빠른 로딩을 제공합니다&lt;/li&gt;
&lt;li&gt;규범과 관리: 위챗의 경우, 접속 및 관리&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;출시 전, 위챗은 __이탤릭체__굵게__인라인__이탤릭체__를 발표했습니다. 이는 위챗 결제 및 쿠폰과 같은 개방된 기능들을 제공합니다. 하지만 개발자들은 웹 페이지 개발 언어의 로직을 사용하여 위챗의 일부 규제를 우회할 수 있었습니다. 미니 프로그램은 자체적인 설명 언어를 사용합니다.&lt;/p&gt;
&lt;h2 id=&#34;무엇이-미니-프로그램인가&#34;&gt;무엇이 미니 프로그램인가?
&lt;/h2&gt;&lt;p&gt;소규모 프로그램은 다운로드나 설치 없이 사용할 수 있는 애플리케이션으로, 애플리케이션 &lt;strong&gt;触手可及&lt;/strong&gt;의 꿈을 실현했습니다&lt;/p&gt;
&lt;p&gt;사용자가 스캔하거나 검색하기만 하면 앱이 열리도록 하는 것도 &lt;strong&gt;用完即走&lt;/strong&gt;의 철학을 반영합니다&lt;/p&gt;
&lt;p&gt;사용자는 너무 많은 앱을 설치했는지 여부에 대해 걱장할 필요가 없다. 앱은 어디에나 존재하고 언제든 사용 가능하지만, 동시에 &lt;strong&gt;无需安装卸载&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&#34;小程序와-모바일-앱의-차이점&#34;&gt;小程序와 모바일 앱의 차이점
&lt;/h2&gt;&lt;p&gt;설치 불필요, 메모리 차지 없음, 간편한 공유: QR 코드, 미니 프로그램 카드, 검색&lt;/p&gt;
&lt;h2 id=&#34;小程序로-무엇을-할-수-있나요&#34;&gt;小程序로 무엇을 할 수 있나요?
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;콘텐츠 도구: 지식, 웨이보 인기 게시물, 모바이 자전거, 오늘 당사표, 텐센트 지도, 텐센트 번역&lt;/li&gt;
&lt;li&gt;소매: 핀두어두오, 징둥 구매, 무궁가게, 메이리우션, 샤오미 쇼핑몰, 퀄스천스&lt;/li&gt;
&lt;li&gt;게임: 점프, 신나는 섯다, 신나는 마작, 투유 라이브, YY 라이브&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;강의 내용은 2018년 것이고, 현재는 일부 적용 업체가 폐업했습니다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;개발-준비&#34;&gt;개발 준비
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;소규모 프로그램 계정 등록: 일반적인 정보 입력으로 등록 가능하며, 이메일에서 활성화 링크를 클릭하세요&lt;/li&gt;
&lt;li&gt;정보 등록&lt;/li&gt;
&lt;li&gt;소규모 프로그램 관리자 접속&lt;/li&gt;
&lt;li&gt;완료된 소규모 프로그램 정보&lt;/li&gt;
&lt;li&gt;개발자 연동: 개인 개발자의 경우, 로그인한 위챗 계정이 관리자 계정으로 설정되어 있어 별도의 연동 작업이 필요 없습니다&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이메일에는 제한이 있어 새로운 이메일이 필요하지만, &lt;code&gt;QQ&lt;/code&gt; 이메일은 별칭을 신청할 수 있고 微信 백엔드는 이를 검증하지 않습니다. 시도해 보니 소규모 프로그램 이름이 까다롭고, 상표와 관련된 경우 심사에서 실패하기 쉽습니다.&lt;/p&gt;
&lt;p&gt;서비스 카테고리를 선택하거나 직접 추가할 수 있으며, 하나의 미니 프로그램은 최대 다섯 가지 카테고리를 추가할 수 있습니다&lt;/p&gt;
&lt;p&gt;설정에서 미니 프로그램 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 정보를 확인하고 메시지 푸시를 활성화할 수 있습니다. 메시지 푸시를 사용하면 메시지 템플릿 기능을 사용할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;개발-도구-필자-주&#34;&gt;개발 도구 (필자 주)
&lt;/h2&gt;&lt;p&gt;정상적으로 다운로드 및 설치하면 특별한 주의사항은 없고, 간단히 이해하고 방문자 모드로 들어가면 됩니다. 휴대폰 디버깅을 사용하려면, 즉 휴대폰으로 소규모 프로그램 개발 버전을 보려면 소규모 프로그램 개발자 계정에 로그인한 다음 설정에서 프로젝트 상세 정보 내에서 지정된 소규모 프로그램을 __INLINE_CODE_0__로 전환해야 합니다.&lt;/p&gt;
&lt;h2 id=&#34;코드-구조&#34;&gt;코드 구조
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;JS: 상호작용 로직&lt;/li&gt;
&lt;li&gt;JSON: 데이터 설정&lt;/li&gt;
&lt;li&gt;인터페이스의 요소&lt;/li&gt;
&lt;li&gt;인터페이스 스타일&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>사무실 이전으로 서버 접속이 안 됩니다</title>
        <link>https://blog.ttf248.life/ko/p/office-migration-server-unavailable/</link>
        <pubDate>Sat, 11 Mar 2023 01:42:05 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/office-migration-server-unavailable/</guid>
        <description>&lt;p&gt;업무 공간 변경 안내입니다. 기존 2층에서 15층으로 이전되었습니다. 평범한 자리 이동입니다.&lt;/p&gt;
&lt;h2 id=&#34;디자인-감각&#34;&gt;디자인 감각
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/office-migration-server-unavailable/20230311014537.png&#34;
	width=&#34;511&#34;
	height=&#34;916&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;办公楼&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;55&#34;
		data-flex-basis=&#34;133px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;이주&#34;&gt;이주
&lt;/h2&gt;&lt;p&gt;퇴근 시 정리, 익숙한 이동 경로, 새로운 자리, 컴퓨터 배선 정리 후 편안한 자세로 업무 시작&lt;/p&gt;
&lt;p&gt;(ÒωÓױ)！ 인터넷 연결했는데, 팀에서 주로 사용하는 서버에 접속이 안 돼요. 무선 네트워크로 바꾸니 다시 정상적으로 접속되네요.&lt;/p&gt;
&lt;p&gt;처음에는 서버 네트워크 설정 문제라고 생각했습니다. 새로운 작업 공간의 유선 네트워크가 방화벽 구성 목록에 없어서 IT 동료에게 연락해 조정하면 될 거라고 봤습니다. 그런데 이 네트워크는 한 대의 서버뿐 아니라 다른 서버에도 접속해보니 모두 정상이었고, 점차 의아해졌습니다. 전문적인 일은 전문가에게 맡기기로 하고, 결국 운영팀 동료가 확인해보니 해당 서버에 &lt;code&gt;docker&lt;/code&gt;，服务的默认网络&lt;code&gt;docker0&lt;/code&gt;和办公室有线网络配置的网段冲突了，导致发过去的数据包，都收不到应答，被路由给了__INLINE_CODE_2__ 서비스가 배포되어 있었던 것이었습니다.&lt;/p&gt;
&lt;p&gt;다른 서버에 배포된 __INLINE_CODE_0__服务，也就这台，我比较常用，偶尔用容器部署一些测试服务，没想到还能碰到这个场景。后来细想想，由于整个集团都在一个办公大楼里面，IT部门的同事划分网段，用到了__INLINE_CODE_1__로 시작하는 주소는 이상하지 않다&lt;/p&gt;
&lt;h2 id=&#34;docker0&#34;&gt;docker0
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# vim /etc/docker/daemon.json
{
    &amp;quot;bip&amp;quot;:&amp;quot;172.200.0.1/24&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;서비스를 재시작하고 새로운 네트워크로 전환하면 서버가 정상적으로 접속됩니다&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;p&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>임베디드 입문 1 - 전문 용어</title>
        <link>https://blog.ttf248.life/ko/p/embedded-introduction-professional-terms/</link>
        <pubDate>Tue, 07 Mar 2023 13:42:36 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/embedded-introduction-professional-terms/</guid>
        <description>&lt;p&gt;임베디드 시스템을 떠올리면 아직도 학교 연구실의 51 단일칩 회로와 프리스칼이 생각난다&lt;/p&gt;
&lt;p&gt;LPA3399Pro는 루신(Rockchip) RK3399Pro 플랫폼을 기반으로 개발된 비전 호스트로, 대규모 시각 연산이 필요한 휴대용 컴퓨팅 장치에 적합합니다. 내장 NPU 계산 유닛을 통해 3.0TOPS의 연산 능력을 제공하며, 다양한 알고리즘 모델을 지원합니다.&lt;/p&gt;
&lt;p&gt;RV1109은 루신(Realtek) 인공지능 및 머신 비전 분기 SoC로, 내장된 독립 NPU를 갖추고 있습니다. RV1109은 1TOPS의 연산 능력을 제공합니다.&lt;/p&gt;
&lt;h2 id=&#34;system-on-chip&#34;&gt;System on Chip
&lt;/h2&gt;&lt;p&gt;SoC는 &amp;ldquo;System on a Chip&amp;quot;의 약자로, “칩 상 시스템”을 의미합니다. 이는 여러 전자 시스템을 하나의 칩에 통합하는 기술입니다. 이 기술은 전자 제품의 크기와 무게를 크게 줄이면서 성능을 향상시키고 전력 소비를 낮춥니다.&lt;/p&gt;
&lt;p&gt;SoC(시스템 온 칩)와 CPU(중앙 처리 장치)는 모두 컴퓨터 시스템의 중요한 구성 요소이지만, 몇 가지 차이가 있습니다&lt;/p&gt;
&lt;p&gt;CPU는 컴퓨터 시스템의 핵심 프로세서로서 프로그램 명령어를 실행하는 역할을 담당합니다. 일반적으로 연산 장치, 제어 장치 및 레지스터와 같은 기본 부품으로 구성됩니다.&lt;/p&gt;
&lt;p&gt;SoC는 여러 전자 시스템을 하나의 칩에 통합한 것으로, CPU 외에도 메모리, 그래픽 프로세서, 입출력 인터페이스 등 다양한 구성 요소를 포함할 수 있습니다. 이를 통해 전자 제품의 크기와 무게를 크게 줄이고 성능을 향상시키며 전력 소비를 낮출 수 있습니다.&lt;/p&gt;
&lt;p&gt;결론적으로, CPU는 SoC의 구성 요소이며, SoC는 더욱 복잡하고 통합된 전자 시스템입니다&lt;/p&gt;
&lt;h2 id=&#34;microcontroller-unit&#34;&gt;Microcontroller Unit
&lt;/h2&gt;&lt;p&gt;SoC(시스템 온 칩)와 MCU(마이크로컨트롤러 유닛)는 여러 전자 시스템을 하나의 칩에 통합하는 기술이지만, 몇 가지 차이점이 있습니다&lt;/p&gt;
&lt;p&gt;MCU는 일반적으로 CPU, 메모리, 입출력 인터페이스 등의 기본 부품을 포함하는 마이크로컨트롤러입니다. 가전제품, 자동차 전자 시스템 등 다른 전자 장치를 제어하는 데 주로 사용됩니다.&lt;/p&gt;
&lt;p&gt;SoC는 더 많은 전자 시스템을 하나의 칩에 통합한 것으로, MCU의 기본 구성 요소 외에도 그래픽 프로세서, 무선 통신 모듈과 같은 다른 구성 요소를 통합할 수 있습니다. 이를 통해 전자 제품의 크기와 무게를 크게 줄이고 성능을 향상시키며 전력 소비를 낮출 수 있습니다.&lt;/p&gt;
&lt;p&gt;요컨대, MCU는 간단한 마이크로컨트롤러이고, SoC는 더욱 복잡하고 통합된 전자 시스템입니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>AI 지원 프로그래밍, 생산성 진화</title>
        <link>https://blog.ttf248.life/ko/p/ai-assisted-programming-productivity-evolution/</link>
        <pubDate>Tue, 28 Feb 2023 17:05:17 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/ai-assisted-programming-productivity-evolution/</guid>
        <description>&lt;p&gt;&lt;code&gt;GitHub Copilot&lt;/code&gt;BOLD_2&lt;code&gt;ChatGPT&lt;/code&gt;이 세상에 나왔는데, 작동 원리는 잘 모르지만 한동안 사용했다. 두 도구는 생산성 향상에 있어 완전히 다른 수준의 도움을 주지만, 모두 큰 효과를 발휘한다.&lt;/p&gt;
&lt;p&gt;너무 복잡한 일은, ⁠_강조_⁠의 효과는 아홉할 정도일 뿐이다&lt;/p&gt;
&lt;h2 id=&#34;github-copilot&#34;&gt;github copilot
&lt;/h2&gt;&lt;p&gt;발표할 때, 홈페이지 소개__INLINE_CODE_0__를 보니 그렇게 똑똑해 보이지 않았고, 사용해 봤는데 잘 안 돼서 포기했다&lt;/p&gt;
&lt;p&gt;2022년 이전에는, 시간 날 때마다 새로운 버전으로 바꿔서 사용해 보는데, 효과는 꽤 괜찮은 편이다. 다만 국내 속도가 좀 느린데, 아마 네트워크 문제인 것 같다. &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 같은 언어로 작성된 코드는 주석을 참고해서 따라 하면 나보다 자료를 찾아 직접 짜는 것보다 훨씬 빠르다.&lt;/p&gt;
&lt;h2 id=&#34;chatgpt&#34;&gt;ChatGPT
&lt;/h2&gt;&lt;p&gt;여전히 프로그래머, 즉 개발 관점에서 제품을 설계하고 있으며, 프로그래밍 방법을 이해해야 하고, 주석을 통해 AI 지원 프로그래밍을 점진적으로 유도해야 합니다&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 走到了下一个层面，**외지인도 빠르게 시작할 수 있습니다. 대화형 챗 인터페이스로 설계되어, 질문하고 요구사항을 설명하며, 이해가 안 되는 부분은 계속 질문할 수 있습니다.&lt;/p&gt;
&lt;p&gt;간단한 예시로, 토큰화 개념은 알지만 코딩 방법은 모르고 문자열 유사도를 계산하고 싶습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Python 分词计算 維天運通 LOGORY 和 合肥維天運通信息科技股份有限公司 两个字符串的相似度；
比较前，统一处理字符串，英文转换为小写；
第二个字符中如果能找到第一个字符的首字符，将第二个字符串截位，截位的长度为第一个字符串的长度
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;안녕하세요, 빙입니다. 😊&lt;/p&gt;
&lt;p&gt;온라인 정보에 따르면 123, Python 분단 계산은 jieba 라이브러리를 사용하여 구현할 수 있습니다. jieba 라이브러리는 정확 모드, 전체 모드 및 검색 엔진 모드의 세 가지 분단 모드를 지원합니다. 필요에 따라 적절한 모드를 선택할 수 있습니다.&lt;/p&gt;
&lt;p&gt;두 문자열의 유사도를 비교하려면 먼저 토큰화한 다음 단어 벡터 또는 편집 거리 등의 지표를 계산해야 합니다. 수학 연산에는 numpy나 scipy 같은 라이브러리를 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;문자열을 일관되게 처리하기 위해 영문자를 소문자로 변환하려면 Python의 내장 함수 lower()를 사용할 수 있습니다&lt;/p&gt;
&lt;p&gt;두 번째 문자열을 추출하려면 Python의 슬라이스 연산자 []를 사용할 수 있습니다&lt;/p&gt;
&lt;p&gt;다음은 가능한 코드 예제입니다:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import jieba
import numpy as np
from scipy.spatial.distance import cosine

# 定义两个字符串
str1 = &amp;quot;維天運通 LOGORY&amp;quot;
str2 = &amp;quot;合肥維天運通信息科技股份有限公司&amp;quot;

# 统一处理字符串，英文转换为小写
str1 = str1.lower()
str2 = str2.lower()

# 找到第二个字符串中第一个字符的位置
index = str2.find(str1[0])

# 如果找到了，截取第二个字符串
if index != -1:
    str2 = str2[index:index+len(str1)]

# 使用 jieba 库进行分词
words1 = list(jieba.cut(str1))
words2 = list(jieba.cut(str2))

# 计算两个字符串的词向量（以词频作为权重）
vector1 = np.zeros(len(words1))
vector2 = np.zeros(len(words1))

for i, word in enumerate(words1):
    vector1[i] += 1 # 统计第一个字符串中每个词出现的次数
    if word in words2:
        vector2[i] += 1 # 统计第二个字符串中每个词出现的次数

# 计算两个字符串的相似度（以余弦距离作为指标）
similarity = 1 - cosine(vector1, vector2)

print(&amp;quot;两个字符串的相似度是：&amp;quot;, similarity)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;更进一步，咨询运行的结果，恭喜你，发现问题了，结果是瞎编的，它并没有实际运行代码，但是会给你一个不错的结果&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;밤&#34;&gt;밤
&lt;/h3&gt;&lt;p&gt;SQL 쿼리, 제품 코드 테이블에서 제품 코드 범위가 80000부터 89999까지인 레코드 검색&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;你好，这是 Bing。😊

根据搜索结果12，你可以使用 SQL BETWEEN 运算符来选择给定区间内的值。BETWEEN 运算符包含了开始和结束的值。

你需要先指定要查询的表名和列名，然后在 WHERE 子句中使用 BETWEEN 运算符和区间值。

例如，如果你要查询产品代码表中，产品代码在 80000 到 89999 之间的记录，你可以使用以下语句：

SELECT * FROM product_code
WHERE code BETWEEN 80000 AND 89999;
这里，* 表示选择所有列3。如果你只想选择特定的列，比如产品名称和价格，你可以用逗号分隔它们，如下：

SELECT name, price FROM product_code
WHERE code BETWEEN 80000 AND 89999;
希望这能帮助到你。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;계속 질문하고 반박하세요: 제품 코드는 문자열이고, 당신의 코드가 잘못되었습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;抱歉，我没有注意到产品代码是字符串。如果是这样的话，你需要在区间值两边加上单引号，如下：

SELECT * FROM product_code
WHERE code BETWEEN &#39;80000&#39; AND &#39;89999&#39;;
请原谅我的错误。🙏
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;축하해요, 틀릴 거예요&lt;/p&gt;</description>
        </item>
        <item>
        <title>자주 사용하지 않는 GIT 명령어 몇 가지 정리</title>
        <link>https://blog.ttf248.life/ko/p/git-less-common-commands-summary/</link>
        <pubDate>Fri, 17 Feb 2023 10:08:57 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/git-less-common-commands-summary/</guid>
        <description>&lt;p&gt;자주 사용하지는 않지만 유용한 &lt;code&gt;git&lt;/code&gt; 명령&lt;/p&gt;
&lt;h3 id=&#34;시스템-재설치로-인해-__inline_code_0__-폴더-소유자-정보가-변경되었습니다&#34;&gt;시스템 재설치로 인해 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 폴더 소유자 정보가 변경되었습니다
&lt;/h3&gt;&lt;p&gt;새 버전은 보안 검사를 추가하여 위험을 알리고, 이로 인해 작업을 계속할 수 없습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global --add safe.directory
git config --global --add safe.directory &amp;quot;*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;새-컴퓨터-계정-정보-저장&#34;&gt;새 컴퓨터 계정 정보 저장
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global credential.helper store
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;정보를 업데이트하기 전에 먼저 기존 증거를 정리하세요&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --system --unset credential.helper
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>컴파일러, 콜백 함수, 성능 테스트</title>
        <link>https://blog.ttf248.life/ko/p/compiler-callback-function-performance-testing/</link>
        <pubDate>Wed, 15 Feb 2023 13:59:25 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/compiler-callback-function-performance-testing/</guid>
        <description>&lt;p&gt;지난해 __INLINE_CODE_0__을 설계했는데, 이 기능은 이벤트 캡처를 처리하고 외부에는 클래스 인터페이스를 제공합니다. 서비스 초기화 시 호출하는 쪽에서 해당 클래스를 구현하고 객체 포인터를 모듈에 전달합니다.
접촉한 __，好奇心害死猫，就想着这些接口都用__INLINE_CODE_1__함수 객체 콜백을 통해 얻는 결과는 순수 가상 함수의 인터페이스 정의 방법과 비교하여 더 유연하다
질문이 생겼다. 두 가지 다른 문법 중 성능 면에서 어느 것이 더 빠른가? 컴파일 원리를 모르는 사람이 코드를 조금 작성해서 확인해 보았다.&lt;/p&gt;
&lt;h2 id=&#34;서론&#34;&gt;서론
&lt;/h2&gt;&lt;p&gt;온라인 주소에서 다양한 컴파일러와 컴파일 옵션을 선택하고, &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 플랫폼에서 코드를 실행하거나 해당 어셈블리 코드를 확인할 수 있습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기술 검증을 할 때, 웹 페이지에서 짧은 코드 조각을 실행하는 것이 편리합니다&lt;/li&gt;
&lt;li&gt;다양한 색상으로 다른 어셈블리 코드에 해당하는 부분을 구분하면 로컬 디버거보다 훨씬 편리합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;표준위원회에서 문법 규칙을 제정했으며, 컴파일 단계에서 어떻게 구현할지는 각 컴파일러에 달려 있습니다. 이 점에서는 마이크로소프트의 컴파일러가 꽤 강력하다고 말씀드릴 수 있습니다. 문법적 설탕이 만능은 아니며, 콜백 인터페이스가 많지 않으므로 __INLINE_CODE_0__을 사용하면 더욱 편리하고 빈 콜백 함수 인터페이스를 정의할 필요도 없습니다. 콜백 인터페이스 종류가 다양할 때는 전통적인 가상 함수가 비즈니스 인터페이스 정의의 통일성을 높이는 데 더 유리합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;플랫폼인데, 성능이 비슷하고 큰 차이는 없습니다&lt;/li&gt;
&lt;li&gt;__INLINE_CODE_0__굵게_2__INLINE_CODE_1__비교 시 1.35ns 증가&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;일반적인 비즈니스 시스템 개발에서는 이 정도의 성능 손실은 무시할 수 있으며, &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;，在设计的上，能带来更多的便捷。在设计多信号处理时，尤为明显，底层有事件触发，如果需要落地日志，出入日志对象的的处理函数。当需要更多的业务处理接口时，底层用__INLINE_CODE_1__BOLD_5&lt;code&gt;lambda&lt;/code&gt;BOLD_6__INLINE_CODE_3__ 내의 신호와 슬롯, 로깅, 모니터링, 비즈니스 1, 비즈니스 2는 서로 완전히 분리되어 있습니다&lt;/p&gt;
&lt;h2 id=&#34;코드&#34;&gt;코드
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Counter: 1000000
Time: 3966us
Counter: 1000000
Time: 5316us
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;memory&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;atomic&amp;gt;
#include &amp;lt;string&amp;gt;

std::atomic_int64_t counter = 0;

// 定义回调接口
class UserInterface
{
public:
    virtual void name() = 0;
    virtual void full_name() = 0;
};

class User : public UserInterface
{
public:
    void name() {}
    void full_name() { counter++; }
};

void to_string(UserInterface* user)
{
    user-&amp;gt;name();
    user-&amp;gt;full_name();
}

using name_handler = std::function&amp;lt;void()&amp;gt;;
using full_name_handler = std::function&amp;lt;void()&amp;gt;;

class Test
{
    name_handler name_;
    full_name_handler full_name_;

public:
    void set_name_handler(name_handler name)
    {
        name_ = name;
    }

    void set_full_name_handler(full_name_handler full_name)
    {
        full_name_ = full_name;
    }

    void to_string()
    {
        name_();
        full_name_();
    }
};

int main()
{
    User user;

    auto start = std::chrono::high_resolution_clock::now();

    for (int i = 0; i &amp;lt; 1000000; i++)
    {
        to_string(&amp;amp;user);
    }

    auto end = std::chrono::high_resolution_clock::now();
    std::cout &amp;lt;&amp;lt; &amp;quot;Counter: &amp;quot; &amp;lt;&amp;lt; counter &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;Time: &amp;quot; &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(end - start).count() &amp;lt;&amp;lt; &amp;quot;us&amp;quot; &amp;lt;&amp;lt; std::endl;

    counter = 0;
    auto name = []() {};
    auto full_name = []() { counter++; };

    Test test;
    test.set_name_handler(name);
    test.set_full_name_handler(full_name);

    start = std::chrono::high_resolution_clock::now();

    for (int i = 0; i &amp;lt; 1000000; i++)
    {
        test.to_string();
    }

    end = std::chrono::high_resolution_clock::now();
    std::cout &amp;lt;&amp;lt; &amp;quot;Counter: &amp;quot; &amp;lt;&amp;lt; counter &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;Time: &amp;quot; &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(end - start).count() &amp;lt;&amp;lt; &amp;quot;us&amp;quot; &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;p&gt;자료를 찾다가 비슷한 코드 조각을 발견했습니다. &lt;a class=&#34;link&#34; href=&#34;https://gist.githubusercontent.com/benloong/8050171/raw/fa577ec923b460862078b8b40233a42a1c619eeb/functionperformance.cpp&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;functionperformance.cpp&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;memory&amp;gt;
#include &amp;lt;functional&amp;gt;

using namespace std;
using namespace std::chrono;

class Base
{
public:
	Base(){}
	virtual ~Base(){}
	virtual int func(int i) = 0;
};

class Derived : public Base
{
public:
	Derived(int base = 10) : base{base}
	{

	}
	~Derived(){}

	virtual int func(int i)
	{
		return i*base;
	}
private:
	int base;
};

struct Func
{
	int base;
	int operator()(int i)
	{
		return i*base;
	}
	Func(int base) : base {base}
	{

	}
};
const int base = 10;
int calculate(int i)
{
	return base*i;
}

int main()
{
	const int num = 10000;
	Base *p = new Derived{10};
	int total = 0;
	auto start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += p-&amp;gt;func(i);
	}
	auto end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nvirtual call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;

	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += calculate(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\ndirect function call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;

	Func functor{10};
	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += functor(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nfunctor call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;
	int base = 10;
	function&amp;lt;int(int)&amp;gt; lambda = [base](int i)
	{
		return i*base;
	};
	total = 0;
	start = high_resolution_clock::now();
	for (int i = 0; i &amp;lt; num; ++i)
	{
		total += lambda(i);
	}
	end = high_resolution_clock::now();
	std::cout&amp;lt;&amp;lt;&amp;quot;result: &amp;quot;&amp;lt;&amp;lt;total&amp;lt;&amp;lt;&amp;quot;\nlambda call elapsed: \t&amp;quot;&amp;lt;&amp;lt;duration_cast&amp;lt;nanoseconds&amp;gt;(end-start).count()&amp;lt;&amp;lt;&amp;quot; nanoseconds.\n&amp;quot;&amp;lt;&amp;lt;std::endl;
	return 0;
}

/*
test on mac mini i7 2.7GHz
clang++ -std=c++11 chronotest.cpp -O0
output:
result: 499950000
virtual call elapsed: 	43171 nanoseconds.

result: 499950000
direct function call elapsed: 	31379 nanoseconds.

result: 499950000
functor call elapsed: 	41497 nanoseconds.

result: 499950000
lambda call elapsed: 	207416 nanoseconds.
===================================================
clang++ -std=c++11 chronotest.cpp -O1
output:
result: 499950000
virtual call elapsed: 	26144 nanoseconds.

result: 499950000
direct function call elapsed: 	22384 nanoseconds.

result: 499950000
functor call elapsed: 	33477 nanoseconds.

result: 499950000
lambda call elapsed: 	55799 nanoseconds.
===================================================
clang++ -std=c++11 chronotest.cpp -O2
result: 499950000
virtual call elapsed: 	22284 nanoseconds.

result: 499950000
direct function call elapsed: 	36 nanoseconds.

result: 499950000
functor call elapsed: 	30 nanoseconds.

result: 499950000
lambda call elapsed: 	28292 nanoseconds.

===================================================
clang++ -std=c++11 chronotest.cpp -O3
result: 499950000
virtual call elapsed: 	18975 nanoseconds.

result: 499950000
direct function call elapsed: 	29 nanoseconds.

result: 499950000
functor call elapsed: 	30 nanoseconds.

result: 499950000
lambda call elapsed: 	22542 nanoseconds.
===================================================
clang++ -std=c++11 chronotest.cpp -O4

result: 499950000
virtual call elapsed: 	22141 nanoseconds.

result: 499950000
direct function call elapsed: 	30 nanoseconds.

result: 499950000
functor call elapsed: 	30 nanoseconds.

result: 499950000
lambda call elapsed: 	22584 nanoseconds.
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기에는 일반 함수와 람다 함수라는 두 가지 모드가 추가되었으며, 인터페이스 콜백 방식과 직접 호출 방식을 비교하여 성능 손실이 수치적인 차이를 보인다. 람다 함수의 성능은 함수에 근접하며 때로는 더 우수하다. 컴파일 원리에 대한 지식 부족으로 추측컨대, 접근하는 변수 주소와 함수가 인접해 있어 &lt;strong&gt;INLINE&lt;/strong&gt; 처리 효율을 높이는 것으로 보인다.&lt;/p&gt;
&lt;p&gt;첨부된 실행 결과&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;result: 499950000
virtual call elapsed: 6143 nanoseconds.

result: 499950000
direct function call elapsed: 30 nanoseconds.

result: 499950000
functor call elapsed: 31 nanoseconds.

result: 499950000
lambda call elapsed: 15134 nanoseconds.
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>호스트 순서, 네트워크 순서를 디버거를 통해 직접 관찰</title>
        <link>https://blog.ttf248.life/ko/p/host-order-network-order-debugger-observation/</link>
        <pubDate>Tue, 10 Jan 2023 14:18:12 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/host-order-network-order-debugger-observation/</guid>
        <description>&lt;p&gt;컴퓨터 발전 역사에서 데이터를 저장하는 방법에 대한 통일된 표준은 없었습니다&lt;/p&gt;
&lt;p&gt;바이트 정렬 방식에는 두 가지 일반적인 규칙이 있습니다. 예를 들어, 다중 자릿수의 하위 바이트를 작은 주소에 배치하고 상위 바이트를 큰 주소에 배치하는 것을 리틀 엔디언이라고 하며, 그 반대는 빅 엔디언이라고 합니다. 네트워크 애플리케이션에서는 다양한 기기 유형이 서로 다른 표준의 바이트 정렬을 채택할 수 있으므로 바이트 순서가 반드시 고려되어야 하며, 모두 네트워크 표준으로 변환됩니다.&lt;/p&gt;
&lt;p&gt;읽기 습관에 따라 빅 엔디안 바이트 순서가 왼쪽에서 오른쪽으로 읽는 방식과 더 일치합니다&lt;/p&gt;
&lt;h2 id=&#34;죄송합니다-번역할-중국어-텍스트가-제공되지-않았습니다-텍스트를-제공해-주시면-번역해-드리겠습니다&#34;&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;x86, MOS Technology 6502, Z80, VAX, PDP-11 등 프로세서는 리틀 엔디언 방식입니다&lt;/li&gt;
&lt;li&gt;모토로라 6800, 모토로라 68000, PowerPC 970 등 프로세서는 빅 엔디언 방식입니다&lt;/li&gt;
&lt;li&gt;ARM, PowerPC(PowerPC 970 제외), DEC Alpha, SPARC V9, MIPS, PA-RISC 및 IA64의 바이트 순서는 설정 가능합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;네트워크-서론&#34;&gt;네트워크 서론
&lt;/h2&gt;&lt;p&gt;네트워크 전송은 일반적으로 빅 엔디안을 사용하며, 네트워크 바이트 오더 또는 네트워크 순서라고도 합니다. IP 프로토콜에서 빅 엔디안을 네트워크 바이트 오더로 정의합니다.
소켓은 16비트 및 32비트 정수를 네트워크 바이트 순서와 로컬 바이트 순서 간에 변환하는 일련의 변환 함수를 정의합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;arpa/inet.h&amp;gt;

uint32_t htonl(uint32_t hostlong); //把uint32_t类型从主机序转换到网络序
uint16_t htons(uint16_t hostshort); //把uint16_t类型从主机序转换到网络序
uint32_t ntohl(uint32_t netlong); //把uint32_t类型从网络序转换到主机序
uint16_t ntohs(uint16_t netshort); //把uint16_t类型从网络序转换到主机序
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;__INLINE_CODE_0__를 네트워크 라이브러리로 선택하면, 내장된 네임스페이스에 플랫폼 독립적인 함수 이름이 있습니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;boost::asio::detail::socket_ops::network_to_host_long&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::network_to_host_short&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::host_to_network_long&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::host_to_network_short&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;비주얼-스튜디오-디버거&#34;&gt;비주얼 스튜디오 디버거
&lt;/h2&gt;&lt;p&gt;디버그 모드에서 디버그 메뉴, 창을 선택하고 메모리 윈도우를 체크하세요&lt;/p&gt;
&lt;p&gt;__INLINE_CODE_0__에서 디버거 내에서 메모리 데이터를 직접 확인할 수 있습니다(아래 그림 참조)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/host-order-network-order-debugger-observation/Snipaste_2023-01-10_14-44-00.png&#34;
	width=&#34;535&#34;
	height=&#34;147&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;调试器菜单&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;363&#34;
		data-flex-basis=&#34;873px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;메모리-확인-방법&#34;&gt;메모리 확인 방법
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;창에서 변수 이름을 직접 출력하고 해당 변수의 주소로 이동합니다&lt;/li&gt;
&lt;li&gt;변수가 이미 포인터라면, 변수를 더블 클릭하여 선택한 후 메모리 윈도우로 드래그하면 해당 주소의 내용을 확인할 수 있습니다&lt;/li&gt;
&lt;li&gt;변수가 포인터가 아니면 계산 창에 추가하고, 주소를 가져온 다음 메모리 창에 수동으로 복사합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;예시로-말하자면&#34;&gt;예시로 말하자면
&lt;/h3&gt;&lt;p&gt;데이터를 받아 __INLINE_CODE_0__对象中，将网络序转成主机序，得到__INLINE_CODE_1__가 30으로 설정되었고, 서버는 이 데이터를 전송하기 위해 네 개의 바이트를 할당했습니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool NetworkMessage::decode_header()
{
    // 网络序转成主机序
    body_length_ = boost::asio::detail::socket_ops::network_to_host_long(*(int *)buffer_.data());
    return auto_reserve(body_length_);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;메모리 창에서 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 의 내용을 관찰하십시오&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/host-order-network-order-debugger-observation/buffer_.png&#34;
	width=&#34;603&#34;
	height=&#34;318&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;buffer_&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;189&#34;
		data-flex-basis=&#34;455px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;메모리 창에서 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 의 내용을 관찰하십시오&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/host-order-network-order-debugger-observation/body_length_.png&#34;
	width=&#34;581&#34;
	height=&#34;333&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;body_length_&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;174&#34;
		data-flex-basis=&#34;418px&#34;
	
&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>C11: sleep for vs yield</title>
        <link>https://blog.ttf248.life/ko/p/c11-sleep-for-vs-yield/</link>
        <pubDate>Tue, 20 Sep 2022 20:54:51 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/c11-sleep-for-vs-yield/</guid>
        <description>&lt;p&gt;코드를 살펴보는데, &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 猛的引入眼帘，__INLINE_CODE_1__BOLD_4&lt;code&gt;yield&lt;/code&gt;이 처음 보는 것 같고, 예전엔 눈에 띄지 않았던 것 같아요&lt;/p&gt;
&lt;p&gt;매뉴얼을 확인하지 않고 가장 먼저 떠오르는 것은 비동기 변환과 관련이 있는지인데, __INLINE_CODE_0__boost 라이브러리의 코루틴 구현에 이 단어가 사용되었으므로 여기서는 코루틴과는 상관없고, 제어 로직은 일반 스레드와 관련이 있는 것 같습니다&lt;/p&gt;
&lt;h2 id=&#34;문서&#34;&gt;문서
&lt;/h2&gt;&lt;h3 id=&#34;yield&#34;&gt;yield
&lt;/h3&gt;&lt;p&gt;이 함수의 정확성은 구현에 의존하며, 특히 사용 중인 OS 스케줄러 메커니즘과 시스템 상태에 따라 달라집니다. 예를 들어, 먼저 온(FIFO) 실시간 스케줄러(Linux의 SCHED_FIFO)는 현재 스레드를 일시 중단하고 동일 우선순위의 다른 스레드가 없는 경우 큐의 맨 뒤로 배치합니다 (다른 스레드가 없으면 yield 효과 없음).&lt;/p&gt;
&lt;h3 id=&#34;sleep_for&#34;&gt;sleep_for
&lt;/h3&gt;&lt;p&gt;지정된 sleep_duration 동안 현재 스레드의 실행을 차단합니다
이 함수는 스케줄링 지연이나 리소스 충돌로 인해 sleep_duration보다 오래 블록될 수 있습니다
표준 라이브러리는 안정적인 클럭으로 시간을 측정하는 것을 권장합니다. 구현에서 시스템 시간을 사용하면 대기 시간 또한 클럭 조정에 민감할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;분석&#34;&gt;분석
&lt;/h3&gt;&lt;p&gt;두 함수 모두 현재 스레드를 더 이상 점유하지 않도록 하는 것인데, 실행 결과는 플랫폼에 따라 다를 수 있나? 여기서도 여전히 엉망진창이다. 코드를 실행해서 결과를 확인해 보자.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ThinkPad 노트북(Visual Studio 커뮤니티 에디션 2022), 텐센트 클라우드 S2 표준 서버 (gcc8.5)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;실행 플랫폼&lt;/th&gt;
&lt;th&gt;함수&lt;/th&gt;
&lt;th&gt;1회/μs&lt;/th&gt;
&lt;th&gt;2회/μs&lt;/th&gt;
&lt;th&gt;3회/μs&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;sleep_for&lt;/td&gt;
&lt;td&gt;9872&lt;/td&gt;
&lt;td&gt;1884&lt;/td&gt;
&lt;td&gt;11302&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;yield&lt;/td&gt;
&lt;td&gt;119&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;sleep_for&lt;/td&gt;
&lt;td&gt;171&lt;/td&gt;
&lt;td&gt;168&lt;/td&gt;
&lt;td&gt;167&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;yield&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;td&gt;102&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;운영체제 구현 방식에 따라 고정밀 슬립 모드에서는 __INLINE_CODE_0__稳定性差异巨大，如果想要高精度的休眠，使用__INLINE_CODE_1__이 더 적합합니다&lt;/p&gt;
&lt;p&gt;시간 정밀도가 __INLINE_CODE_0__일 때, 두 차이는 뚜렷하지 않다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;thread&amp;gt;
 
// 建议其他线程运行一小段时间的“忙睡眠”
void little_sleep(std::chrono::microseconds us)
{
    auto start = std::chrono::high_resolution_clock::now();
    auto end = start + us;
    do {
        std::this_thread::yield();
    } while (std::chrono::high_resolution_clock::now() &amp;lt; end);
}
 
int main()
{
    auto start = std::chrono::high_resolution_clock::now();
 
    little_sleep(std::chrono::microseconds(100));
    std::this_thread::sleep_for(std::chrono::microseconds(100));
 
    auto elapsed = std::chrono::high_resolution_clock::now() - start;
    std::cout &amp;lt;&amp;lt; &amp;quot;waited for &amp;quot;
              &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(elapsed).count()
              &amp;lt;&amp;lt; &amp;quot; microseconds\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;참조&#34;&gt;참조
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/header/thread.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/header/thread.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/thread/sleep_for.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/thread/sleep_for.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>리눅스 서버, MySQL 비밀번호 재설정</title>
        <link>https://blog.ttf248.life/ko/p/linux-server-reset-mysql-password/</link>
        <pubDate>Tue, 20 Sep 2022 14:27:35 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/linux-server-reset-mysql-password/</guid>
        <description>&lt;p&gt;유휴 상태인 텐센트 클라우드 서버가 있는데, 연말에 만료되므로 갱신할 생각은 없었고, 개발용 데이터베이스로 MySQL을 설치했습니다. 시스템 재설치 시 편하기 위해 텐센트 클라우드가 제공하는 써드파티 이미지를 선택했는데, MySQL 데이터베이스가 이미 설치되어 있었습니다. 시스템 내부에 비밀번호나 배포 경로를 설명하는 Readme 파일이 있을 줄 알았는데.&lt;/p&gt;
&lt;p&gt;텐센트 클라우드 시스템 재설치는 정말 빠르네요, 1분 정도 지나니 재설치가 완료되었다는 알림이 왔어요. 로그인하니 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 서비스가 이미 시작되어 있네요. 비밀번호를 찾아봐야겠는데, 아무리 찾아도 안 보여요. 점점 짜증나기 시작합니다.&lt;/p&gt;
&lt;p&gt;이때 생각하니 이미 서버에 접근했고 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 권한을 가지고 있으니, 방법이 있을 거야. 자료를 뒤져보니 알리바바 클라우드 포럼에 관련 글이 있네, 계속 시도해 봐야겠다.&lt;/p&gt;
&lt;h2 id=&#34;비밀번호-재설정&#34;&gt;비밀번호 재설정
&lt;/h2&gt;&lt;p&gt;설정 파일 편집&lt;/p&gt;
&lt;p&gt;다시 사용한 __直接登录数据，接来下就是正常操作了，重置&lt;code&gt;mysql&lt;/code&gt;대기 사용자 비밀번호로 원격 로그인을 허용하세요&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;USE mysql;
UPDATE user SET authentication_string = password (&#39;pass&#39;) WHERE User = &#39;root&#39;;
grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;pass&#39; with grant option;
flush privileges;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;설정 파일을 되돌리고, 데이터베이스를 재시작하면 끝&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://help.aliyun.com/document_detail/42520.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://help.aliyun.com/document_detail/42520.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>자동화 테스트에 대한 간략한 고찰</title>
        <link>https://blog.ttf248.life/ko/p/shallow-discussion-on-automation-testing/</link>
        <pubDate>Thu, 04 Aug 2022 11:39:18 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/shallow-discussion-on-automation-testing/</guid>
        <description>&lt;p&gt;금융 거래 시스템 테스트에 대한 투자는 다른 시스템보다 훨씬 많지만, 복잡한 테스트 단계가 반복되고, __INLINE_CODE_0__은 너무 낮습니다. 프로젝트 및 인력 교체로 인해 피할 수 없는 변수가 발생하고, 흔히 A 인터페이스의 특정 필드를 수정하면 B 인터페이스 결과에 영향을 미치는 경우가 발생합니다. 버전 출시 때마다 위험이 누적됩니다.&lt;/p&gt;
&lt;h2 id=&#34;이론적-지식&#34;&gt;이론적 지식
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如何衡量自动化的价值？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;자동화 테스트 사례 ROI = (수동 실행 시간) * (실행 횟수) / (개발 비용 + 유지 보수 비용)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;哪些功能需要做自动化测试？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;사용자가 자주 사용하는 기능, 자주 변경되지 않는 기능에 대한 자동화 테스트 코드를 작성하는 것이 가장 효과적입니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;为什么选择这个时间点推动自动化测试？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;프로젝트 출시 임박 시점이 아니라 지금이 가장 적절합니다. 장거리 물은 당장의 갈증을 해소하지 못하고, 자동화는 장기적인 효과 모델입니다. 프로젝트가 &lt;strong&gt;生产环境&lt;/strong&gt;에 이미 출시되었고 안정적인 배포 주기를 맞이하고 있으므로, 지금이 가장 적합합니다.&lt;/p&gt;
&lt;h2 id=&#34;프레임-선택&#34;&gt;프레임 선택
&lt;/h2&gt;&lt;p&gt;관련 경험이 부족한 상태에서 자동화 테스트라는 업무를 맡았으니, 일반적인 시작은 다음과 같다: 검색 엔진을 열어 현재 시스템에 적용 가능한 도구와 프레임워크를 찾아 사용 설명서를 훑어보고 작업을 시작한다. 바로 적합한 도구를 찾았다면 축하한다, &lt;strong&gt;完美开局&lt;/strong&gt; .&lt;/p&gt;
&lt;p&gt;먼저 잘못했다고 말씀드립니다. 관련 자료를 확인해 보니 없다는 게 아니라 프레임워크 자체가 너무 복잡하고, 배포에 필요한 리소스도 과도합니다. 초보자 입문에는 작고 간결한 것이 필요하며, 테스트팀 동료들과 상의 결과 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 자체 프레임워크를 구축하는 것이 좋다는 의견이 나왔습니다. 간단히 말해 기존 유닛 테스트 프레임워크를 활용하여 자동화 테스트 프레임워크로 묶는 방식입니다.&lt;/p&gt;
&lt;p&gt;참고할 프로젝트 디자인 아이디어: &lt;a class=&#34;link&#34; href=&#34;https://github.com/wintests/pytestDemo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/wintests/pytestDemo&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;프레임워크가-왜-필요할까요&#34;&gt;프레임워크가 왜 필요할까요?
&lt;/h2&gt;&lt;p&gt;서비스는 개발 환경, 테스트 환경, 온라인 테스트 환경 등 다양한 배포 환경을 가지고 있으며, 프레임워크는 계층 분리 및 테스트 케이스와 데이터 분리에 역할을 합니다. 각 환경에 맞는 사례 데이터를 구성하고 공통 데이터도 지원합니다.&lt;/p&gt;
&lt;p&gt;핵심적인 논리는 자동화 활용률을 높이기 위한 것이다. 시나리오가 더 복잡해지고, 환경별 데이터가 서로 다르고 관련이 없다면, 설정 사례 데이터를 추가할 때 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 태그를 사용하여 현재 데이터가 지원하는 환경을 지정하면 된다.&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;p&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>새로운 언어를 배워야 하는 이유는 무엇인가?</title>
        <link>https://blog.ttf248.life/ko/p/why-learn-a-new-language/</link>
        <pubDate>Thu, 04 Aug 2022 11:27:30 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/why-learn-a-new-language/</guid>
        <description>&lt;p&gt;학창 시절부터 시작해서 &lt;code&gt;C++&lt;/code&gt;을 접한 지 벌써 10년이 넘었으니, 다른 프로그래밍 언어를 배울 필요가 있을까요?&lt;/p&gt;
&lt;p&gt;세련된 모듈 설계 경험은 부족하지만, 문법은 자유롭고 다른 언어를 학습하면서 더 세련된 설계를 유도할 수 있습니다&lt;/p&gt;
&lt;p&gt;도구들을 만들 때 자주 사용하게 된다&lt;/p&gt;
&lt;p&gt;설계 원칙은 하위 레이어 라이브러리든, 비즈니스 모듈 구현이든 모두 통일되어 있습니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>비주얼 스튜디오 컴파일 문자집합 [번역]</title>
        <link>https://blog.ttf248.life/ko/p/visual-studio-compilation-character-set-translation/</link>
        <pubDate>Thu, 04 Aug 2022 10:51:43 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/visual-studio-compilation-character-set-translation/</guid>
        <description>&lt;p&gt;__INLINE_CODE_0__굵게_2__INLINE_CODE_1__상수 내 줄 바꿈 문자&lt;/p&gt;
&lt;h2 id=&#34;visual-studio&#34;&gt;visual studio
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;cmake&lt;/code&gt;BOLD_3&lt;code&gt;windows&lt;/code&gt;BOLD_4&lt;code&gt;utf-8&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;출처 자료에서 원리부터 시작하여 문제의 발생 원인을 상세히 설명하고 있습니다&lt;/p&gt;
&lt;p&gt;인코딩 관련해서는 __INLINE_CODE_0__有专门的编译选项__INLINE_CODE_1__BOLD_4&lt;code&gt;/execution-charset&lt;/code&gt; 두 가지 옵션으로 해결할 수 있는데, 전자는 파일 자체의 인코딩을 나타내고 후자는 컴파일 이후 문자 배열 내 바이트가 어떤 인코딩인지 나타냅니다&lt;/p&gt;
&lt;p&gt;예를 들어, 콘솔에서 한자가 정상적으로 표시된다&lt;/p&gt;
&lt;h2 id=&#34;cmake-빌드-설정-visual-studio&#34;&gt;CMake 빌드 설정 (Visual Studio)
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;if( WIN32 )
    message( STATUS &amp;quot;Configuring trade on WIN32&amp;quot;)
    set( CMAKE_CXX_FLAGS &amp;quot;${CMAKE_CXX_FLAGS} /source-charset:utf-8 /execution-charset:gbk&amp;quot;)
endif()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/146543940&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/146543940&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>윈도우 플랫폼에서 폴더 크기 빠르게 통계</title>
        <link>https://blog.ttf248.life/ko/p/windows-platform-quick-folder-size-statistics/</link>
        <pubDate>Mon, 01 Aug 2022 19:54:18 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/windows-platform-quick-folder-size-statistics/</guid>
        <description>&lt;p&gt;어떻게 해야 할까? 디스크가 많고, 파일을 정리하고 싶은데, 파일이 많은 상태에서 시스템 자체의 리소스 관리자로 폴더 크기를 확인하려고 하면 너무 느려서 포기하고 싶을 정도다&lt;/p&gt;
&lt;h2 id=&#34;everything&#34;&gt;Everything
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 平台下做开发的朋友，没有亲手用过 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; 또한 친구에게서 들었을 수도 있을 것입니다. 검색 속도는 시스템 기본 파일 탐색기보다 훨씬 빠릅니다. 시스템 수준에서 빠른 파일 인덱싱을 지원한다면, 분명히 유사한 도구를 찾아 파일 인덱스를 구축하고 파일 크기를 함께 통계적으로 산출할 수 있을 것입니다.&lt;/p&gt;
&lt;h2 id=&#34;wiztree&#34;&gt;WizTree
&lt;/h2&gt;&lt;p&gt;공식 웹사이트: &lt;a class=&#34;link&#34; href=&#34;https://www.diskanalyzer.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.diskanalyzer.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;일반 설치 모드 또는 압축 해제 후 실행&lt;/p&gt;
&lt;p&gt;빠른 속도, 다양한 데이터 표시 유형, 왼쪽은 트리 형태, 오른쪽은 파일 형식, 물론 그래픽 표현도 소프트웨어 하단에 있습니다&lt;/p&gt;
&lt;h2 id=&#34;spacesniffer-업데이트-2023년-중단됨&#34;&gt;SpaceSniffer (업데이트 2023년 중단됨)
&lt;/h2&gt;&lt;p&gt;소프트웨어 공식 웹사이트: &lt;a class=&#34;link&#34; href=&#34;http://www.uderzo.it/main_products/space_sniffer/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.uderzo.it/main_products/space_sniffer/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;조작은 간단합니다. 해당 디스크를 선택하면 소프트웨어가 시각적으로 폴더 크기를 표시하는데, 크기가 클수록 이미지 내 해당 매트릭스도 커집니다. 나머지는 클릭 몇 번으로 이해할 수 있으며, 조건 필터를 입력하여 파일을 지원합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;파일 크기 필터링&lt;/li&gt;
&lt;li&gt;파일 날짜 필터&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/windows-platform-quick-folder-size-statistics/space_sniffer.gif&#34;
	width=&#34;960&#34;
	height=&#34;540&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;基础用法&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;177&#34;
		data-flex-basis=&#34;426px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/windows-platform-quick-folder-size-statistics/advance.gif&#34;
	width=&#34;960&#34;
	height=&#34;540&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;高级用法&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;177&#34;
		data-flex-basis=&#34;426px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://moe.best/software/spacesniffer.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://moe.best/software/spacesniffer.html&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>웹 페이지 스타일 시트(CSS) 복사 방법: 요소 검사</title>
        <link>https://blog.ttf248.life/ko/p/how-to-copy-webpage-css-element-inspection/</link>
        <pubDate>Sun, 31 Jul 2022 23:36:48 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/how-to-copy-webpage-css-element-inspection/</guid>
        <description>&lt;p&gt;정적인 블로그 테마는 주로 해외 템플릿을 기반으로 수정 및 조정하며, 중국어 콘텐츠의 레이아웃에 대한 고려는 충분하지 않다&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;반달 전 블로그 스타일시트를 조정했는데, 오랜 기간 백엔드 서비스 개발만 해와서 프론트엔드는 완전 초보라 할 수 있습니다. 며칠 동안 이것저것 만져봤지만 디자인이 영 마음에 들지 않았습니다. 문득 떠올라서 자주 보는 기술 블로그인 infoq나 오픈소스 중국의 레이아웃을 참고하면 어떨까 싶었습니다. 관련 요소들을 찾아봤더니 소스 코드를 보니까 머리가 엉망이 되었습니다.&lt;/p&gt;
&lt;p&gt;프론트엔드 개발자라면 여기서 웃을 수도 있겠네요&amp;hellip; 특정 요소를 찾는 것조차 모르는군요. 모르는 건 괜찮아요, 주말에 시간도 많으니 잠시 멈춰서 생각해보니, 예전에 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 크롤러를 만들 때 비슷한 걸 사용했던 것 같아요.&lt;/p&gt;
&lt;h3 id=&#34;요소-검토&#34;&gt;요소 검토
&lt;/h3&gt;&lt;p&gt;맞아요, 브라우저 자체의 요소 검사 도구로 스타일 시트를 복사하고 특정 요소를 찾기는 정말 간단한 일이죠&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;요소 복사&lt;/li&gt;
&lt;li&gt;복사 outerHTML&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;复制 selector&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;JS 경로 복사&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;复制样式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;XPath 복사&lt;/li&gt;
&lt;li&gt;전체 XPath 복사&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>윈도우 플랫폼 편집용 초대형 파일 편집기: EmEditor (텍스트 에디터)</title>
        <link>https://blog.ttf248.life/ko/p/windows-platform-editing-large-files-emeditor-text-editor/</link>
        <pubDate>Sun, 31 Jul 2022 23:21:24 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/windows-platform-editing-large-files-emeditor-text-editor/</guid>
        <description>&lt;p&gt;상하이 국안 데이터베이스 사건은 해커 커뮤니티에서 떠들썩하게 번지고 있지만, 진실 여부는 알 수 없다. 2년 뒤에 다시 한번 살펴보자. 기존 경험을 바탕으로 로컬 소셜 엔지니어링 데이터베이스 자료를 업데이트했는데, 17.9G의 거대한 SQL 파일이 있었다. 일반적인 텍스트 편집기로는 미리 보기조차 어렵고 열기는 더더욱 불가능했다. 다른 사용자와 대화하던 중 EmEditor라는 프로그램을 언급했다.&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;공식 웹사이트: &lt;a class=&#34;link&#34; href=&#34;https://www.emeditor.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.emeditor.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;주말에 시간 내서 사용해 봤는데, 꽤 편리하고 디자인 자체가 큰 파일을 편집할 수 있게 되어 있네요. 메모리가 충분하면 파일 전체를 메모리에 로드해서 검색 및 편집 속도도 빠르고, 파일 분할 기능도 지원합니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>생각보다 간단해 보이는 일인데, 코드 복사 버튼을 추가하는 것</title>
        <link>https://blog.ttf248.life/ko/p/add-code-copy-button/</link>
        <pubDate>Fri, 25 Feb 2022 01:23:39 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/add-code-copy-button/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;네 시간이나 붙잡고 있었는데, 이 문장을 보고는 웃겼다. 어떻게 이렇게 오래 걸릴 수 있지? 자세히 보니 시간이 세 시간밖에 안 갔네.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이것은 2022년의 첫 번째 초안인데, 크게 복잡한 것은 아니고 제목 그대로입니다 (그때는 제가 어렸었죠). &lt;a class=&#34;link&#34; href=&#34;https://ouuan.github.io/post/from-hexo-to-hugo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;作业&lt;/a&gt;을 그냥 베껴서 즐겨찾기에 넣어두고 미루다 보니 한 달 넘게 지나서야 비로소 이 일을 기억했습니다.&lt;/p&gt;
&lt;p&gt;__INLINE_CODE_0__로 이사했을 때 플러그인이 너무 부족하다고 생각했고, 코드 복사 기능이 없어 많은 노트들을 에버노트에서 블로그로 옮기는 과정에서 코드를 복사하는 작업이 번거로워져서 블로그에 글을 쓰는 의욕을 크게 저해했습니다&lt;/p&gt;
&lt;h2 id=&#34;서론&#34;&gt;서론
&lt;/h2&gt;&lt;p&gt;원저자의 초고를 꼼꼼히 살펴보고, 일단 쭉 읽어본 뒤에 작가 소개도 확인해 봤는데, 대단한 분이시야. 칭화대 재학 중인 학부생이고, 어릴 때부터 컴퓨터와 접촉했네. 아, 잠깐만, 이 블로그부터 먼저 살펴보자. 무슨 일 하려고 했던지 기억조차 안 나. 그리고 작가의 &lt;code&gt;Github&lt;/code&gt;仓库，这个修改后的__INLINE_CODE_1__ 주제가 훨씬 낫고 기능도 많으니, 일단 관련 코드를 합쳐보자.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/add-code-copy-button/2022-02-25-02-08-19.png&#34;
	width=&#34;215&#34;
	height=&#34;150&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;143&#34;
		data-flex-basis=&#34;344px&#34;
	
&gt; &lt;img src=&#34;https://blog.ttf248.life/p/add-code-copy-button/2022-02-25-02-08-40.png&#34;
	width=&#34;217&#34;
	height=&#34;167&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;129&#34;
		data-flex-basis=&#34;311px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;새-기능-기사-이력-및-연관-제출-기록-확인&#34;&gt;새 기능: 기사 이력 및 연관 제출 기록 확인
&lt;/h3&gt;&lt;p&gt;효과는 괜찮은 편이야, 글 뒤쪽에 보면 알 수 있어&lt;/p&gt;
&lt;p&gt;작업하기 전에 원본 저장소의 기록을 자세히 보지 않고 간단하게 병합하면 될 줄 알았는데, 결국 많은 코드를 병합했고, 충돌도 여러 번 발생하고 무식하게 덮어썼다. 모두 프론트엔드와 렌더링 템플릿 코드인데, 내 것을 기준으로 했다.&lt;/p&gt;
&lt;p&gt;창고 주소: &lt;a class=&#34;link&#34; href=&#34;https://github.com/TianlongXiang/hugo-theme-even&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/TianlongXiang/hugo-theme-even&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;중국어의 한 문제점, &lt;strong&gt;인라인 이탤릭 3____굵게 2____인라인 이탤릭 4&lt;/strong&gt;__ 때문에 과거 링크 생성에 실패합니다. 기사 전체 과거를 생성할 때도 자동 통합 스크립트를 수정해야 하며, 현재 저장소의 모든 과거 기록을 가져오도록 해야 합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;name: Build Github
run: git config --global core.quotePath false &amp;amp;&amp;amp; hugo -b &amp;quot;https://www.xiangtianlong.com/&amp;quot; -d &amp;quot;github_public&amp;quot; &amp;amp;&amp;amp; ls
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;스타일-조정&#34;&gt;스타일 조정
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;사이트 콘텐츠 폭을 조정합니다. 이전 디자인은 모바일과 PC 모두에 적합했지만, 실제로는 아무도 휴대폰으로 보지 않고 저조차도 PC로 보는 경우가 많습니다.&lt;/li&gt;
&lt;li&gt;목록 열 지원 자동 확장/축소&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;참고 코드 기록을 한 시간 반 넘게 봤는데, 복사 버튼을 어떻게 추가하는지 도통 이해가 안 된다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;시간이 흘러 한 달쯤 지나서도 이 일이 생각난다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 과제가 이해가 안 되면 다른 문제로 베끼고, 어쨌든 따라 할 수 있을 거야. 검색 결과는 꽤 예상외였는데, __INLINE_CODE_0__官方的论坛里面就有个帖子提到了如何增加复制按钮，跑过去一看，逻辑清晰。懵逼的事情来了，回到的站点一看__INLINE_CODE_1__에서 생성된 코드 블록 스타일이 자료 설명과 달라서 이 부분은 좀 복잡하니까 간단히 기록해 둔다.&lt;/p&gt;
&lt;p&gt;기본적인 프론트엔드 개발 지식이 부족해서 이해가 안 되는 부분은 브라우저를 __INLINE_CODE_0__BOLD_2&lt;code&gt;JavaScript&lt;/code&gt;켜두고, 콘솔에 로그를 확인했다. 많이 모르는 부분이 있었지만 차분히 마음을 가다듬고 논리를 천천히 분해하니 결국 해결책을 찾을 수 있었다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;__INLINE_CODE_0__노드가 여러 개 있는데, 여기서 말하는 것은 단일 코드 블록이고, 테마가 자체적으로 라인 넘버를 생성하여 복사 버튼이 두 개로 나타나는 현상입니다&lt;/li&gt;
&lt;li&gt;관심 있는 주제의 코드 하이라이트 렌더링을 구현하고 싶지만, 해당 테마 설정에 익숙하지 않다&lt;/li&gt;
&lt;li&gt;코드 하이라이트 제어 설정&lt;/li&gt;
&lt;li&gt;설정 파일을 조정해도 계속 안 되고, 렌더링 결과가 예상과 다릅니다&lt;/li&gt;
&lt;li&gt;이 설정들 발견하고 자료를 다시 뒤적거리며 설정을 조정해 보는데, 일단 행 번호는 제거할게요&lt;/li&gt;
&lt;li&gt;맞춤 설정된 __INLINE_CODE_0__BOLD_2&lt;code&gt;js&lt;/code&gt; 스크립트&lt;/li&gt;
&lt;li&gt;이렇게까지 일을 벌였으니, 문득 최근에 봤던 색상 조합이 괜찮다는 생각이 들어서 버튼 스타일을 중국풍 천청색으로 바꿔보자&lt;/li&gt;
&lt;/ol&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:20%&#34; src=&#34;2022-02-25-02-01-22.png&#34; /&gt;
&lt;img class=&#34;special-img-class&#34; style=&#34;width:20%&#34; src=&#34;2022-02-25-02-01-33.png&#34; /&gt;
&lt;p&gt;네 시간이나 붙였다가, 이 문장을 보고는 웃겼다. 어떻게 이렇게 오래 걸릴 수가 있지? 마지막에 보니 시간이 세 시간이었다.&lt;/p&gt;
&lt;h2 id=&#34;참조-링크&#34;&gt;참조 링크
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://ouuan.github.io/post/from-hexo-to-hugo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ouuan.github.io/post/from-hexo-to-hugo/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://gohugobrasil.netlify.app/content-management/syntax-highlighting/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://gohugobrasil.netlify.app/content-management/syntax-highlighting/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://gohugo.io/getting-started/configuration-markup#highlight&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://gohugo.io/getting-started/configuration-markup#highlight&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.dannyguo.com/blog/how-to-add-copy-to-clipboard-buttons-to-code-blocks-in-hugo/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.dannyguo.com/blog/how-to-add-copy-to-clipboard-buttons-to-code-blocks-in-hugo/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>혼돈 엔지니어링</title>
        <link>https://blog.ttf248.life/ko/p/chaos-engineering/</link>
        <pubDate>Wed, 28 Jul 2021 14:35:07 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/chaos-engineering/</guid>
        <description>&lt;p&gt;시스템 안정성 테스트를 위한 시스템 파괴 모드&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;p&gt;국내 인터넷 업계는 늘 새로운 것을 만들어내려고 하고, 가끔 용어를 들어도 뭔지 떠올리기 어려운 경우가 많다&lt;/p&gt;
&lt;p&gt;부분적으로 기사를 봤는데, 혼돈 엔지니어링 초기 정의는 비교적 받아들이기 쉬웠다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;혼돈 엔지니어링의 초기 탐색은 사실 업계에서 꾸준히 있어 왔으며, 장애 테스트나 재해 훈련과 같은 형태로 존재했습니다. 하지만 마이크로서비스 아키텍처의 발전과 분산 시스템의 규모가 커짐에 따라 혼돈 엔지니어링이 부상하기 시작하며 점점 더 중요해지고 있습니다. 넷플릭스가 혼돈 엔지니어링 개념을 공식적으로 제안하면서 관련 이론도 빠르게 풍부해졌고, 넷플릭스의 실증은 안정성 분야에서 혼돈 엔지니어링이 갖는 엄청난 의미를 증명했습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;참조-링크&#34;&gt;참조 링크
&lt;/h2&gt;&lt;p&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>컨테이너 일시 중지</title>
        <link>https://blog.ttf248.life/ko/p/kubernetes-pause-pod/</link>
        <pubDate>Mon, 12 Jul 2021 11:23:09 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/kubernetes-pause-pod/</guid>
        <description>&lt;p&gt;배포 컨트롤러는 Kubernetes 클러스터에서 매우 중요한 기능인 Pod의 수평 확장 및 축소 기능을 제공합니다. 이 기능은 기존 클라우드 시대 플랫폼에 필수적인 역량입니다.&lt;/p&gt;
&lt;p&gt;비즈니스 시나리오에서 데이터베이스 데이터를 수정하고, 조정 후 Pod 노드를 재시작해야 합니다. 하지만 Pod 실행 중에 계속해서 테이블 필드를 수정하므로, 일시적으로 애플리케이션의 테이블 업데이트를 중단한 다음 데이터를 조정하고 Pod를 복원해야 합니다.&lt;/p&gt;
&lt;p&gt;배포 삭제 외에 유사한 일시 중지 효과를 내는 다른 방법이 있을까요?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl scale --replicas=0 deployment/&amp;lt;your-deployment&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;답을 보기 전에는 많은 사람이 상상도 못했을 텐데, 보니까 미소를 지어지네. 머리는 아직 안 돌아가고, 여전히 프로세스를 직접 조작하던 시대에 머물러서, 비즈니스 프로세스를 바로 제어하려 하는 걸 보니 말이야.&lt;/p&gt;
&lt;h2 id=&#34;참조-링크&#34;&gt;참조 링크
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/54821044/how-to-stop-pause-a-pod-in-kubernetes&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;how to stop/pause a pod in kubernetes&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>도커에 대한 몇 가지 이야기</title>
        <link>https://blog.ttf248.life/ko/p/docker-two-three-things/</link>
        <pubDate>Thu, 21 Jan 2021 09:26:07 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/docker-two-three-things/</guid>
        <description>&lt;p&gt;오랫동안 일하면서 접했던 __操作系统，如果是__사용자__用户或者__의 일부 내용이 적용되지 않습니다&lt;/p&gt;
&lt;p&gt;설치 부분은 칭화대학교의 매뉴얼을 참고하세요: &lt;a class=&#34;link&#34; href=&#34;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;설치&#34;&gt;설치
&lt;/h2&gt;&lt;p&gt;알 수 없는 불가사의한 힘으로 인해, 국내 설치 시에는 클라우드 공급업체가 제공하는 저장소 주소를 사용하는 것이 좋습니다. 여기서는 &lt;strong&gt;阿里云&lt;/strong&gt;를 추천합니다.&lt;/p&gt;
&lt;h3 id=&#34;저장소-소스-주소-설정&#34;&gt;저장소 소스 주소 설정
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install yum-utils device-mapper-persistent-data lvm2 &amp;amp;&amp;amp; \
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;최신-버전-배포&#34;&gt;최신 버전 배포
&lt;/h3&gt;&lt;p&gt;도커는 일반적으로 사용되는 백그라운드 서비스이므로, 부팅 시 자동 시작으로 설정하는 것을 권장하며, 현재 명령어는 CentOS 7에 적용 가능합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum install -y docker-ce docker-ce-cli containerd.io &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;지정-버전-배포&#34;&gt;지정 버전 배포
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;kubernetes&lt;/code&gt;和__INLINE_CODE_1__的发布并没与完全同步，如果接下来需要部署&lt;code&gt;kubernetes&lt;/code&gt;，请参考&lt;code&gt;kubernetes&lt;/code&gt;部署说明，安装指定版本的&lt;code&gt;docker&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum list docker-ce --showduplicates | sort -r
sudo yum install -y docker-ce-18.09.2-3.el7 docker-ce-cli-18.09.2-3.el7 containerd.io-18.09.2-3.el7 &amp;amp;&amp;amp; systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;일반-사용자에-docker-권한-추가&#34;&gt;일반 사용자에 Docker 권한 추가
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo usermod -aG docker ${USER}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;제거&#34;&gt;제거
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum erase -y docker-ce docker-ce-cli containerd.io
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;일상-사용&#34;&gt;일상 사용
&lt;/h2&gt;&lt;h3 id=&#34;미러-가속&#34;&gt;미러 가속
&lt;/h3&gt;&lt;p&gt;여전히 예측할 수 없는 미지의 힘으로 인해 이미지 다운로드 속도가 느리지만, 국내 클라우드 제공업체들이 다양한 가속 서비스를 제공하고 있으므로 &lt;strong&gt;阿里云&lt;/strong&gt;을 추천합니다&lt;/p&gt;
&lt;p&gt;가속된 주소는 직접 알리바바 클라우드 계정을 등록하여 확인하시기 바랍니다. 이 서비스는 무료이며, 알리바바 클라우드는 무료 이미지 빌드 서비스도 제공합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt; /etc/docker/daemon.json &amp;lt;&amp;lt;EOF
{
  &amp;quot;registry-mirrors&amp;quot;: [
    &amp;quot;https://docker.nju.edu.cn&amp;quot;,
    &amp;quot;https://mirror.baidubce.com&amp;quot;,
    &amp;quot;https://docker.m.daocloud.io&amp;quot;,
    &amp;quot;https://docker.mirrors.sjtug.sjtu.edu.cn&amp;quot;
  ]
}
EOF
systemctl daemon-reload &amp;amp;&amp;amp; \
systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;강력-추천-제어판&#34;&gt;강력 추천 제어판
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker volume create portainer_data &amp;amp;&amp;amp; \
docker run -d --name=portainer --restart=always -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:2.20.3-alpine
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;자주-사용하는-이미지-모음&#34;&gt;자주 사용하는 이미지 모음
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker pull rancher/rancher:stable &amp;amp;&amp;amp; docker pull  portainer/portainer-ce:2.0.1 &amp;amp;&amp;amp; \
docker pull centos:7 &amp;amp;&amp;amp; docker pull ubuntu:20.04 &amp;amp;&amp;amp; docker pull ubuntu:18.04 &amp;amp;&amp;amp; \
docker pull redis:5 &amp;amp;&amp;amp; docker pull redis:6 &amp;amp;&amp;amp; \
docker pull alpine:3.11 &amp;amp;&amp;amp; docker pull busybox:1.32 &amp;amp;&amp;amp; \
docker pull rabbitmq:3.7-management &amp;amp;&amp;amp; \
docker pull mariadb:10.2 &amp;amp;&amp;amp; \
docker pull nginx:1.18 &amp;amp;&amp;amp; docker pull nginx:1.19 &amp;amp;&amp;amp; \
docker pull mysql:5.6 &amp;amp;&amp;amp; docker pull mysql:8 &amp;amp;&amp;amp; \
docker pull elasticsearch:6.8.11 &amp;amp;&amp;amp; docker pull logstash:6.8.11 &amp;amp;&amp;amp; docker pull kibana:6.8.11 &amp;amp;&amp;amp; \
docker pull zookeeper:3.4 &amp;amp;&amp;amp; \
docker pull influxdb:1.7 &amp;amp;&amp;amp; docker pull grafana/grafana:7.3.1 &amp;amp;&amp;amp; \
docker pull percona:8 &amp;amp;&amp;amp; docker pull percona:5.6 &amp;amp;&amp;amp; \
docker pull cloverzrg/frps-docker:0.34.3 &amp;amp;&amp;amp; docker pull cloverzrg/frpc-docker:0.34.3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;자주-사용되는-명령어-조합&#34;&gt;자주 사용되는 명령어 조합
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.docker.com/engine/reference/commandline/docker/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.docker.com/engine/reference/commandline/docker/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;컨테이너 실행 상태를 확인하고 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 매개변수를 추가하여 자세한 컨테이너 정보를 확인합니다. 이때는 이미지 정보는 무시합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker ps --format &amp;quot;{{.Names}}: {{.Ports}}: {{.Size}}&amp;quot;
#portainer: 0.0.0.0:8000-&amp;gt;8000/tcp, 0.0.0.0:9000-&amp;gt;9000/tcp: 0B (virtual 172MB)
#influxdb: 0.0.0.0:8086-&amp;gt;8086/tcp: 183B (virtual 311MB)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;모든 컨테이너 중지&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker stop $(docker ps -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;모든 이미지를 한 번에 삭제합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dokcer rmi $(docker images -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;이미지 내보내기&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; &amp;gt; -o XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이미지 내보내기 및 압축&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker save &amp;lt;IMAGE NAME&amp;gt;:&amp;lt;IMAGE TAG&amp;gt; | gzip &amp;gt; XXX.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이미지 가져오기&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker load -i XXX.tar
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>리눅스 기반 Jmeter 부하 테스트 환경 구축</title>
        <link>https://blog.ttf248.life/ko/p/linux-setup-jmeter-testing-environment/</link>
        <pubDate>Tue, 22 Dec 2020 10:12:50 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/linux-setup-jmeter-testing-environment/</guid>
        <description>&lt;p&gt;저자는 하드웨어에 대한 높은 관심을 가지고 있으며, Jmeter를 사용하여 성능 테스트를 진행하고 CentOS 7에 Jmeter, InfluxDB 및 Grafana를 배포하는 과정을 기록했습니다. Jmeter 설치 및 명령어 사용법, InfluxDB의 특징 및 Docker 설치 방법, 그리고 Grafana의 간단한 배포 및 구성 방법을 공유하며, 고성능 프로그램 패턴 경험과 참고 자료를 정리했습니다.&lt;/p&gt;
&lt;h2 id=&#34;배경&#34;&gt;배경
&lt;/h2&gt;&lt;p&gt;데이터 시현 외에 웹 패널을 추가로 구성하는 것이 무슨 소용이 있나요?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;생각은 자기만 생각하는 대로인데, 직접 해봐야 알 수 있어
Don&amp;rsquo;t use GUI mode for load testing! only for Test creation and Test debuggin.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;공식적으로 추천하는 방식은 명령줄을 통해 부하 테스트 보고서를 얻고 GUI 방식으로 표시하는데, 데이터 오류가 발생할 수 있나요? JMeter에 대한 이해는 깊지 않지만, 적어도 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 버전의 콘솔 패널을 굴려볼 만한 이유를 찾았습니다&lt;/p&gt;
&lt;p&gt;오픈소스 차이나 게시글인데, 핵심 컴포넌트 배포 방식이 썩 좋지 않고, 설치에 필요한 파일도 다운로드하려면 공중계정을 팔로우해야 한다. 새세대 사용자로서 당연히 __INLIN_ITALIC_1____으로 대체했다. 결국 서버가 국내에 있어야 하고, 해외 소스 주소 접근 속도는 매우 느리다. 적어도 미러 서비스는 알리바바 클라우드에 무료 가속 기능이 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 설치 배포에 대한 내용은 여기서는 더 이상 다루지 않으며, 이전 자료를 참고하시기를 권장합니다&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;다음 내용은 크게 두 부분으로 나뉩니다: 기본 테스트 환경 구성 요소 구축 및 각 요소에 대한 간단한 설명입니다&lt;/p&gt;
&lt;h2 id=&#34;jmeter&#34;&gt;Jmeter
&lt;/h2&gt;&lt;p&gt;Apache JMeter는 Apache 재단에서 개발한 Java 기반의 성능 테스트 도구입니다. 소프트웨어에 대한 부하 테스트를 위해 설계되었으며, 처음에는 웹 애플리케이션 테스트용으로 만들어졌지만 이후 다른 테스트 영역으로 확장되었습니다. 정적 파일, Java 마이크로 서비스, CGI 스크립트, Java 객체, 데이터베이스, FTP 서버 등 정적 및 동적 리소스를 테스트하는 데 사용할 수 있습니다. JMeter는 다양한 압력 범주에서 서버, 네트워크 또는 객체에 대한 막대한 부하를 시뮬레이션하여 강점을 테스트하고 전체 성능을 분석할 수 있습니다. 또한 JMeter는 어설션을 사용하여 스크립트를 생성하여 프로그램이 예상 결과를 반환하는지 확인하여 기능/회귀 테스트를 수행할 수 있습니다. 최대의 유연성을 위해 JMeter는 정규 표현식을 사용하여 어설션을 만들 수 있습니다.&lt;/p&gt;
&lt;p&gt;Apache JMeter는 정적 및 동적 리소스(파일, 서블릿, Perl 스크립트, Java 객체, 데이터베이스 쿼리, FTP 서버 등)의 성능 테스트에 사용될 수 있습니다. 서버, 네트워크 또는 객체에 과도한 부하를 가하여 강도를 테스트하거나 다양한 압력 유형에서 전체적인 성능을 분석하는 데 활용할 수 있으며, 성능 그래프 분석이나 고동시 부하 테스트에도 적합합니다.&lt;/p&gt;
&lt;h3 id=&#34;jmeter-배포-centos7&#34;&gt;JMeter 배포 CentOS7
&lt;/h3&gt;&lt;p&gt;설치 패키지&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install java-1.8.0-openjdk -y &amp;amp;&amp;amp; \
wget https://mirrors.bfsu.edu.cn/apache//jmeter/binaries/apache-jmeter-5.4.tgz &amp;amp;&amp;amp; tar -xf apache-jmeter-5.4.tgz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;환경 변수 설정&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export JMETER_HOME=$HOME/jmeter/apache-jmeter-5.4
export PATH=$JMETER_HOME/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;지메터-명령어&#34;&gt;지메터 명령어
&lt;/h3&gt;&lt;p&gt;최종적으로 __控制面板，可以不输入&lt;code&gt;Grafana&lt;/code&gt;参数，在__INLINE_CODE_2__제어판 관측 데이터&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;jmeter -n -t /tmp/order-500-10s.jmx -l /tmp/jmeter-order-report-20200109/order-500-10s.jtl
# 一般不用测试结果和测试报告，简化命令
jmeter -n -t /tmp/order-500-10s.jmx
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;influxdb&#34;&gt;InfluxDB
&lt;/h2&gt;&lt;p&gt;InfluxDB는 Go 언어로 작성된 오픈 소스 분산 시계열, 이벤트 및 지표 데이터베이스이며 외부 의존성이 필요 없습니다. 현재 DevOps 모니터링 데이터, APP 메트릭, IoT 센서 데이터 및 실시간 분석 데이터를 포함한 대량의 타임스탬프 데이터를 저장하는 데 주로 사용됩니다.&lt;/p&gt;
&lt;h3 id=&#34;인플럭스db-특징&#34;&gt;인플럭스DB 특징
&lt;/h3&gt;&lt;p&gt;인플럭스DB의 특징은 다음과 같이 9가지로 요약할 수 있습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;구조(패턴) 없음: 열의 개수가 임의일 수 있습니다&lt;/li&gt;
&lt;li&gt;메트릭 저장 기간을 설정할 수 있습니다&lt;/li&gt;
&lt;li&gt;통계 편의를 위해 시간 관련 함수(최소, 최대, 합계, 개수, 평균, 중앙값 등) 지원;&lt;/li&gt;
&lt;li&gt;지원되는 저장 정책: 데이터의 삭제 및 수정에 사용 가능합니다.(InfluxDB는 데이터 삭제 및 수정 방법을 제공하지 않습니다.)&lt;/li&gt;
&lt;li&gt;연속 쿼리 지원: 데이터베이스에서 자동으로 주기적으로 실행되는 일련의 문이며, 저장 정책과 함께 사용하면 InfluxDB 시스템 점유량을 줄일 수 있습니다&lt;/li&gt;
&lt;li&gt;네이티브 HTTP 지원, 내장된 HTTP API;&lt;/li&gt;
&lt;li&gt;SQL과 유사한 구문을 지원합니다&lt;/li&gt;
&lt;li&gt;클러스터 내 데이터 복제본 수를 설정할 수 있습니다&lt;/li&gt;
&lt;li&gt;정기 샘플링 데이터를 지원하고, 별도의 measurement에 기록하여 세분화된 데이터 저장 기능을 제공합니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;인플럭스db-도커-설치&#34;&gt;인플럭스DB 도커 설치
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir influxdb &amp;amp;&amp;amp; cd influxdb &amp;amp;&amp;amp; \
docker run -p 8086:8086 -d --name influxdb -v $PWD:/var/lib/influxdb influxdb:1.7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;컨테이너에 진입하여 명령을 실행하고, 수동으로 데이터베이스를 생성합니다&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;root@bce0a55bbc72:/# influx
Connected to http://localhost:8086 version 1.7.10
InfluxDB shell version: 1.7.10
&amp;gt; 交互面板执行命令
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;인플럭스db-데이터베이스-및-사용자-생성&#34;&gt;인플럭스DB 데이터베이스 및 사용자 생성
&lt;/h3&gt;&lt;p&gt;데이터베이스 생성: create database jmeter_t2
데이터베이스 확인:
데이터베이스 전환: use jmeter_t2
관리자 권한으로 비밀번호가 &amp;lsquo;admin&amp;rsquo;인 사용자 &amp;ldquo;admin&amp;quot;을 생성합니다
사용자 보기&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; show users
user  admin
----  -----
admin true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;사용자 권한이 표시되면 데이터베이스 준비가 완료되었습니다&lt;/p&gt;
&lt;h2 id=&#34;grafana&#34;&gt;Grafana
&lt;/h2&gt;&lt;p&gt;테스트 케이스를 작성하다 보니 차트 표시가 크게 필요하지 않다는 것을 알게 되었고, 인터페이스의 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 데이터는 명령줄에서 실행하면 이미 관찰할 수 있으며, 더 중요한 것은 프로그램 내부의 소요 시간이다&lt;/p&gt;
&lt;p&gt;간단한 배포&lt;/p&gt;
&lt;p&gt;테스트 결과를 태그로 필터링할 수 있으며, 일반적으로 &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 데이터베이스 하나만 구성하면 됩니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;애플리케이션 이름&lt;/li&gt;
&lt;li&gt;테스트 사례 이름&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/linux-setup-jmeter-testing-environment/Snipaste_2021-03-09_19-44-22.png&#34;
	width=&#34;861&#34;
	height=&#34;357&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;grafana&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;241&#34;
		data-flex-basis=&#34;578px&#34;
	
&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -d --name=grafana -p 3000:3000 grafana/grafana:7.3.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;웹 버전은 샘플러 간격으로 인해 계산된 __INLINE_CODE_0__和相关数值与__INLINE_CODE_1__聚合报告不相符，参考链接：&lt;strong&gt;링크_2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;자료에서는 __INLINE_CODE_0__을 사용자 정의하는 방법도 설명하고 있습니다&lt;/p&gt;
&lt;h2 id=&#34;사후기&#34;&gt;사후기
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;고성능 프로그램 모드는 단일 루프 스레드여야 하며, 잠금, 큐에 넣기 및 큐에서 제거하는 작업은 불필요한 성능 저하를 야기한다&lt;/li&gt;
&lt;li&gt;핵심 비즈니스 로직의 처리 시간은 다른 코드 도입에 필요한 시간보다 길기 때문에, 동시성으로 효율을 높이는 것이 효과적이다. 핵심 처리 시간이 충분히 짧다면 다른 코드를 신중하게 도입하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@jasonli.studio/to-install-apache-jmeter-in-centos7-294bc72a97ba&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;To install Apache JMeter in CentOS7&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>레드햇과 CentOS 라이프사이클</title>
        <link>https://blog.ttf248.life/ko/p/redhat-centos-lifecycle/</link>
        <pubDate>Tue, 21 Jul 2020 20:02:35 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/redhat-centos-lifecycle/</guid>
        <description>&lt;p&gt;온라인 생산 환경 운영체제는 Red Hat과 CentOS가 주류 선택입니다. 두 시스템의 라이프사이클에 대한 공식 웹사이트 링크를 기록하고 CentOS 8에서 CentOS 8 Stream으로 업그레이드 경험을 공유합니다.&lt;/p&gt;
&lt;h2 id=&#34;서론&#34;&gt;서론
&lt;/h2&gt;&lt;p&gt;온라인 생산 환경 운영체제는 현재 국내에서 Red Hat과 CentOS가 주류 선택입니다. 지난 2년간 Red Hat 6의 지원 종료를 겪었기에, 두 시스템의 라이프사이클 공식 웹사이트 링크를 기록합니다.&lt;/p&gt;
&lt;h2 id=&#34;본문&#34;&gt;본문
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://access.redhat.com/support/policy/updates/errata&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Red Hat Enterprise Linux Life Cycle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;레드햇 엔터프라이즈 리눅스(RHEL)와 CentOS는 기업용 서버 운영체제에서 널리 사용되는 선택입니다. RHEL은 안정적인 지원 및 업데이트 주기를 제공하여 기업 환경에 적합하며, CentOS는 RHEL의 커뮤니티 버전으로서 유사한 기능과 안정성을 제공하지만 공식 지원은 없습니다.&lt;/p&gt;
&lt;h2 id=&#34;계속-봐&#34;&gt;계속 봐
&lt;/h2&gt;&lt;p&gt;이 글을 게시할 때, 두 년 후 업데이트를 하게 될 줄은 상상도 못 했습니다. 이틀 전까지만 해도 일상적으로 사용하는 가상 머신을 CentOS 8에서 CentOS 8 Stream으로 업그레이드했습니다. 생산 환경에 어떻게 선택할지는 논하지 않겠습니다만, 로컬 환경에서는 최신 버전을 추구합니다.&lt;/p&gt;
&lt;p&gt;CentOS 8 Stream은 지속적인 업데이트를 제공하는 롤링 릴리스 버전으로, 개발 및 테스트 환경에 적합합니다&lt;/p&gt;</description>
        </item>
        <item>
        <title>컴퓨터 조립에 관한 일들</title>
        <link>https://blog.ttf248.life/ko/p/computer-assembly-tips/</link>
        <pubDate>Sat, 18 Jul 2020 14:33:46 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/computer-assembly-tips/</guid>
        <description>&lt;p&gt;저자는 어릴 적부터 컴퓨터 조립에 대한 관심이 많았으며, 대학 이후로 하드웨어 조립을 접하기 시작했다. CPU, SSD, HDD, 메모리 클럭 속도 등 하드웨어 성능 비교 웹사이트 및 구매 추천 정보를 제공하고, 하드웨어 선택 경험과 주의사항을 공유한다.&lt;/p&gt;
&lt;h3 id=&#34;인연-말로-다-할-수-없네&#34;&gt;인연, 말로 다 할 수 없네
&lt;/h3&gt;&lt;p&gt;어릴 때부터 내 컴퓨터를 조립하고 싶었는데, 경제적인 상황이 허락하지 않았다. 어렵게 대학교에 들어서서는 휴대성을 고려해서 노트북을 샀다. 정확한 시점을 꼽자면, 고향의 도서관에서 시작되었는데. 그곳은 시내 수준의 도서관이었고 전자 열람실(사실 가본 적 없고 유료였다)과 잡지 열람실이 있었는데, 바로 그곳에서 《大众软件》이나 《电脑报》 같은 잡지를 보게 되었고, 컴퓨터를 접할 기회가 많지 않았던 나에게는 거의 신격에 가까운 과학 지식 자료였다. 몬스터 사냥하는 장면을 보면 내 컴퓨터도 만들어서 같이 레이드하고 공격수로 활약하고 싶었고, 첨단 기술을 보면 책에서 따라 해서 설명된 효과를 낼 수 있을 거라고 상상했다(해킹 도구 사용에 대한 이야기). 물론 고등학교 과제가 많았고, 내가 알던 한계 안에서 책은 읽어야 하고 놀이는 해야 하니까, 순진무구하게 지냈다고 할까. 핑계로 도서관에 가서 책을 보러 가는 척하면, 작은 가방 하나 들고 시내를 걸어가서 도서관에 갔다. 도착해서 에어컨을 틀고 소설, 만화, 게임 잡지를 보거나 가끔은 진지한 책도 읽었다.&lt;/p&gt;
&lt;p&gt;나이가 들면 건망증이 쉬운데, 도서관에서 벌어진 일은 처음도 아니었다. 중학교 때 친척 집에서 컴퓨터를 조립한 적 있는데, 그때 그 기계를 왜 조립했는지 기억도 안 난다. 운영체제는 윈도우 2003이었고, 게임은 기본으로 있는 카드 게임과 문명 시리즈였다. 온갖 방법으로 열쇠를 훔쳐서 동생이랑 같이 게임을 하곤 했다.&lt;/p&gt;
&lt;p&gt;방금 중학교에 입학했는데 바로 컴퓨터 기초 교육이 있었고, 나중에 전학하면서 컴퓨터 경시대회 개념을 조금 접하게 됐습니다. 고등학교 때에는 NOIP 한 번 치른 적도 있고요. 여기서 얘기를 하면 빼놓을 수 없는 게, 동문들의 힘입니다. 고등학교의 컴퓨터 건물은 동문의 기부로 지어졌는데, 컴퓨터 교실과 도서관이 함께 있습니다. 그때는 국내 인터넷 물결의 초기 단계였기도 하고요. 학교 관계자들도 컴퓨터 경시대회 참여를 지원했는데, 결국 앞선 두 학년 선배 여러 명이 컴퓨터 실력으로 명문 대학에 진학했으니까요.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;나와 컴퓨터에 대한 일들을 이렇게 되돌아본 적은 없었다. 졸업 후 자동화 전공을 과감하게 포기하고 컴퓨터 분야로 온 것도 어찌 보면 당연한 일이었을 것이다. 씨앗은 이미 뿌려져 있었고, 다만 주변 사람들은 그 사실을 모를 뿐이었다. 어릴 때부터 많이 접해 두었던 덕분에 자신이 대단하다고 생각했지만, 실상은 겉핱기만 할 뿐이고, 가장 큰 장점은 처음의 열정뿐이었다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;하드웨어-조립&#34;&gt;하드웨어 조립
&lt;/h3&gt;&lt;p&gt;카드바, 칩헬, 지후 컴퓨터 조립 게시판을 많이 둘러보면 초보자도 비교적 간단하게 필요한 기계 목록을 작성할 수 있습니다. 2019년 이후 CPU를 구매하는데 경제적인 여유가 없다면 더 높은 성능을 원한다면 AMD를 우선적으로 고려하세요.&lt;/p&gt;
&lt;p&gt;자주 사용하는 하드웨어 성능 비교 웹사이트를 추천합니다: &lt;a class=&#34;link&#34; href=&#34;https://cpu.userbenchmark.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cpu.userbenchmark.com/&lt;/a&gt;. 가격 정보는 중고나라 미국 버전과 비교하기에 거의 충분합니다. 진정한 고수라면 중고나라에서 중고 제품을 구매하면 훨씬 저렴하게 살 수 있습니다. 하지만 잘 모르는 분들은 중고나라 이용을 비추천합니다. 본인은 가짜 메모리를 구매했는데, 현재 사용에는 문제가 없는 것 같지만 정확하지는 않습니다. 모델과 파라미터가 완전히 일치하지 않습니다.&lt;/p&gt;
&lt;h4 id=&#34;sn550-vs-sn750&#34;&gt;SN550 VS SN750
&lt;/h4&gt;&lt;p&gt;SN550 1TB와 SN750 1TB의 차이는 지속적인 읽기/쓰기 속도가 두 배 정도 다르다는 것인데, 850MB 대 1.6GB입니다. 하지만 일상 사용에서는 차이가 없는데, 둘 다 4K 성능은 동일하기 때문입니다. 물론 여기서 말하는 것은 1TB 용량의 SN550이고, 500G나 250G 모델은 순차 읽기/쓰기 속도가 더 느립니다. 돈을 신경 쓰지 않는다면 상관없겠지만, 저는 일상 사용에는 SN550로 충분하다고 생각합니다. 제가 이 제품을 사지 않은 가장 큰 이유는 순차 읽기/쓰기 속도 때문이 아니라 최대 용량이 1TB라는 점이고, SN750은 2TB 용량을 제공하기 때문입니다. 저에게는 추가 확장 없이 메인보드의 M.2 Nvme 슬롯이 이러한 SSD의 가격 차이보다 더 가치 있다고 생각합니다.&lt;/p&gt;
&lt;p&gt;여러 의견을 종합해 볼 때, 어댑터만 있으면 B150 메인보드도 M.2 SSD를 지원할 수 있습니다&lt;/p&gt;
&lt;h4 id=&#34;기계식-하드-선택-가이드&#34;&gt;기계식 하드 선택 가이드
&lt;/h4&gt;&lt;p&gt;기계식 하드디스크는 현재 가격이 안정적인 추세이며, 대용량 저장 공간이 필요한 사용자라면 적절한 기계식 하드디스크를 선택해야 합니다. 자주 자료를 다운로드하는 사용자에게는 엔터프라이즈급 하드디스크를 추천하며, 흔히 볼 수 있는 제품은 다음과 같습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서부 데이터 디스크&lt;/li&gt;
&lt;li&gt;시게 exos&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;大容量的机械硬盘推荐进行分区，频繁的下载操作固定在某个分区进行，日后出现坏道，可以集中在某个分区，废弃当前分区即可，能有效延长机械硬盘寿命。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;시지(Seagate) 시리즈&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/computer-assembly-tips/%E5%B8%8C%E6%8D%B7exos1.png&#34;
	width=&#34;589&#34;
	height=&#34;659&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;希捷企业级硬盘概述&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;89&#34;
		data-flex-basis=&#34;214px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/computer-assembly-tips/%E5%B8%8C%E6%8D%B7exos2.png&#34;
	width=&#34;588&#34;
	height=&#34;661&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;希捷企业级硬盘概述&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;88&#34;
		data-flex-basis=&#34;213px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;메모리-주파수&#34;&gt;메모리 주파수
&lt;/h4&gt;&lt;p&gt;일상 업무 관점에서는 빈도가 성능에 큰 영향을 미치지 않습니다&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/computer-assembly-tips/%E5%86%85%E5%AD%98.png&#34;
	width=&#34;407&#34;
	height=&#34;404&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;内存时序&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;100&#34;
		data-flex-basis=&#34;241px&#34;
	
&gt;굵게_2&lt;a class=&#34;link&#34; href=&#34;%e5%92%b8%e9%b1%bc%e5%86%85%e5%ad%98.png&#34; &gt;咸鱼内存&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;메모리 타이밍(Memory timings 또는 RAM timings)은 동기식 DRAM(SDRAM) 성능을 설명하는 CL, TRCD, TRP 및 TRAS의 네 가지 매개변수로, 클럭 주기 단위로 표시됩니다. 이들은 일반적으로 7-8-8-24와 같이 하이픈으로 구분된 네 개의 숫자로 표기되며, 네 번째 매개변수(RAS)는 종종 생략되고 때로는 Command rate(명령 속도), 보통 2T 또는 1T (또는 2N, 1N으로 표기)라는 다섯 번째 매개변수가 추가되기도 합니다. 이러한 매개변수는 무작위 접근 메모리 속도에 영향을 미치는 레이턴시(지연 시간)를 지정합니다. 일반적으로 숫자가 낮을수록 성능이 향상됩니다. 시스템 성능을 결정하는 최종 요소는 실제 레이턴시이며, 보통 나노초 단위로 표시됩니다.&lt;/p&gt;
&lt;p&gt;메모리 타이밍을 실제 지연으로 변환할 때는 시계 주기 단위로 측정된다는 점이 가장 중요합니다. 시계 주기의 시간을 모르면 숫자 세트가 다른 숫자 세트보다 빠른지 알 수 없습니다.&lt;/p&gt;
&lt;p&gt;예를 들어, DDR3-2000 메모리의 클럭 주파수는 1000MHz이고 클럭 주기는 1ns입니다. 이 1ns 클럭을 기준으로 CL=7의 절대 지연은 7ns입니다. 반면 더 빠른 DDR3-2666(클럭 1333MHz, 주기 0.75ns)은 더 큰 CL=9를 사용할 수 있지만, 결과적으로 6.75ns의 더 짧은 절대 지연을 발생시킵니다.&lt;/p&gt;
&lt;p&gt;현대 DIMM은 자동 구성에 권장되는 메모리 타이밍이 포함된 시리얼 존재 감지(SPD) ROM 칩을 포함합니다. PC의 BIOS는 성능 향상을 위해 타이밍을 조정할 수 있지만(안정성 저하 위험 있음), 특정 상황에서는 안정성을 높일 수도 있습니다(권장 타이밍 사용 시).&lt;/p&gt;
&lt;p&gt;주의: 메모리 대역폭은 메모리의 처리량을 측정하며, 일반적으로 지연 시간보다는 전송 속도에 의해 제한됩니다. SDRAM의 여러 내부 뱅크를 교차 접근하면 이론적으로 최고 속도로 연속적인 데이터 전송이 가능합니다. 대역폭을 늘리기 위해 지연 시간을 늘릴 수 있습니다. 구체적으로 말해, 새로운 DDR 메모리 세대는 높은 전송 속도를 가지고 있지만 절대 지연 시간은 크게 변하지 않습니다. 특히 시장에 처음 출시된 제품들은 이전 세대보다 더 긴 지연 시간을 보이는 경향이 있습니다.&lt;/p&gt;
&lt;p&gt;메모리 지연이 늘어나더라도 메모리 대역폭을 늘리면 다중 프로세서 또는 다중 실행 스레드를 가진 컴퓨터 시스템의 성능을 개선할 수 있다. 더 높은 대역폭은 전용 그래픽 메모리가 없는 통합 그래픽 카드의 성능도 향상시킬 것이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/computer-assembly-tips/%E5%86%85%E5%AD%98%E6%97%B6%E5%BA%8F%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E.png&#34;
	width=&#34;731&#34;
	height=&#34;477&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;内存时序参数说明&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;153&#34;
		data-flex-basis=&#34;367px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>사이트 가속 및 도메인 설정</title>
        <link>https://blog.ttf248.life/ko/p/website-acceleration-and-domain-setup/</link>
        <pubDate>Sat, 20 Jun 2020 10:36:27 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/website-acceleration-and-domain-setup/</guid>
        <description>&lt;p&gt;국내 접속이 느린 GitHub Pages 때문에, 저자는 개인 도메인을 신청하고 국내 클라우드 호스트 제공업체의 CDN 가속 서비스를 구매했습니다. 설정 과정에서 www 서브도메인에 접근할 수 없는 문제가 발생했는데, 최종적으로 와일드카드 도메인 해석을 삭제하고 2차 도메인을 개별적으로 설정하여 해결했습니다. 저자는 또한 CDN 가속 원리 및 설정 경험과 Nginx 리버스 프록시를 사용한 시도와 그 교훈을 공유했습니다.&lt;/p&gt;
&lt;h3 id=&#34;배경&#34;&gt;배경
&lt;/h3&gt;&lt;p&gt;GitHub Pages에 호스팅되어 있어, 몇 가지 이유로 인해 국내 접속이 다소 느립니다. 그래서 개인 도메인을 신청하고 국내 클라우드 호스트 제공업체의 CDN 가속 서비스를 구매했습니다. 가속 서비스를 설정하면서 개발 머신에 Docker, frp, k8s 등 여러 서비스가 배포되어 있고, 이 서비스들에 대한 대시보드가 있다는 점을 떠올랐습니다. 낭비하지 않겠다는 생각으로 몇 개의 리버스 프록시를 구성하고 모두 2차 도메인에 연결했습니다.&lt;/p&gt;
&lt;p&gt;二级 도메인을 사용하던 중 갑자기 www 서브도메인에 접속할 수 없게 되었고, 알리바바 클라우드에서 DNS 설정이 &lt;a class=&#34;link&#34; href=&#34;https://www.xiangtianlong.com&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;www.xiangtianlong.com&lt;/a&gt;과 xiangtianlong.com으로 동시에 해석되도록 되어 있었으며, CDN 가속을 적용하기 전에는 두 도메인이 모두 정상적으로 작동했습니다&lt;/p&gt;
&lt;p&gt;CDN 설정 시, 2차 도메인이 너무 많아 일반 도메인 규칙을 적용하고 개발 머신으로 통합 라우팅했는데, 결과적으로 www 2차 도메인도 함께 접속이 안 되게 됐습니다. 네, 맞아요, www 접두사도 2차 도메인입니다. 실제 웹사이트는 GitHub Pages에 배포되어 있고, 개발 머신에는 웹사이트 캐시 정보가 없습니다.&lt;/p&gt;
&lt;p&gt;개발 환경에 사이트 배포 안 하고, GitHub Actions으로 자동 통합해서 배포하는 게 훨씬 편하네요&lt;/p&gt;
&lt;h3 id=&#34;도메인&#34;&gt;도메인
&lt;/h3&gt;&lt;p&gt;비전문적인 웹 개발에서는 도메인 이해가 SEO나 크로스 도메인 문제와 관련이 없습니다. 블로그 사이트로서 누드 도메인은 블로거의 사이트를 돋보이게 하며, 제처럼 한자 병음으로 된 도메인을 사용하는 초보에게 유리하고, 현재 모바일 접속이 많으므로 입력할 수 있는 문자 수를 줄일 수 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;컴퓨터에서 단축키를 사용하면 www와 com을 입력할 필요가 없습니다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;cdn&#34;&gt;CDN
&lt;/h3&gt;&lt;p&gt;알리바다 클라우드와 텐센트 클라우드를 모두 사용해 봤는데, 신규 사용자도 쉽게 시작할 수 있습니다. 텐센트 클라우드는 관련 개념을 설명하는 비디오도 제공합니다. CDN 가속 원리는 제이동 창고와 같은 이치입니다. 신상품 판매 시 전국 각지에 미리 배송하여 배송 요청 발생 시 가장 가까운 창고에서 배송합니다.&lt;/p&gt;
&lt;p&gt;원래 주소: 웹사이트 리소스가 원래 보관된 주소&lt;/p&gt;
&lt;p&gt;캐시 파일 설정, 브라우저 F12, 관리 콘솔, 정적 및 동적 리소스 간략 분석&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;전부 0일 유효기간&lt;/li&gt;
&lt;li&gt;유효기간 0일&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; 1일 유효&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;텐센트 클라우드 설정 규칙:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;최대 10개의 캐시 만료 규칙을 구성할 수 있습니다&lt;/li&gt;
&lt;li&gt;하위 규칙 우선&lt;/li&gt;
&lt;li&gt;캐시 만료 시간은 최대 365일까지 설정할 수 있습니다&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;비참한-자수지어&#34;&gt;비참한 자수지어
&lt;/h3&gt;&lt;p&gt;이전에 Nginx를 사용해 본 적이 없어 웹사이트 검색만으로 리버스 프록시 설정을 이해할 수 있을 줄 알았는데, 결과가 좀 혼란스러웠다. 반나절을 끙끙거려도 302 리디렉션은 제대로 설정하지 못했고 결국 아무 소용 없었다. 그래서 어리석은 방법으로 해결하기 위해 DNS 파싱의 와일드카드 도메인 파싱을 삭제하고 개별 2차 도메인을 독립적으로 설정했다. 그때 갑자기 알리바바 클라우드 DNS 파싱에 &amp;ldquo;표시 URL 리디렉션&amp;quot;이라는 모드가 있다는 것을 알아차렸고, 시도해 보니 이게 바로 내가 원하는 302 리디렉션이었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;첫차 단계별 도메인 설정은 잘 되는데, 둘째 도메인을 설정하려니 안 되고 거의 좌절할 지경이었어요. 잠시 기다리니까 갑자기 되는 걸 보니, 알리바바 클라우드 DNS 전파가 가끔씩 오류를 일으키는 것 같네요.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;참고-자료&#34;&gt;참고 자료
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>블로그 IDE 환경과 잡담</title>
        <link>https://blog.ttf248.life/ko/p/blog-ide-environment-and-ramblings/</link>
        <pubDate>Tue, 31 Mar 2020 13:54:27 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/blog-ide-environment-and-ramblings/</guid>
        <description>&lt;p&gt;이 글은 Markdown의 기본 개념과 다양한 소프트웨어에서의 활용을 소개하고, VSCode를 IDE로 추천하며 관련 플러그인을 제시합니다. 또한 Hexo에서 Hugo로 전환한 경험을 공유하며 Hugo의 유연성과 사용자 정의 기능을 강조합니다. 마지막으로 새로운 기술을 빠르게 시작하기 위한 팁과 함께 Hugo 테마 스타일 업데이트 문제 해결 방법도 제공합니다.&lt;/p&gt;
&lt;h2 id=&#34;서론&#34;&gt;서론
&lt;/h2&gt;&lt;h3 id=&#34;markdown&#34;&gt;Markdown
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;가볍고 사람이 읽기 쉽고 쓰기 쉬운 일반 텍스트 형식으로 문서를 작성할 수 있게 해주는 경량 마크업 언어입니다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;상세한 Markdown 문법 설명은 생략하고, 전자책을 추천합니다. &lt;a class=&#34;link&#34; href=&#34;https://markdown-zh.readthedocs.io/en/latest/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;点击此处&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;시판되는 많은 소프트웨어들이 이미 md를 작성 방식으로 지원합니다. csdn 블로그 시스템은 md 문법을 지원하는 온라인 편집기를 출시했으며, 처음 사용할 때 md 문법에 대한 소개 글이 있는데 괜찮습니다. 에버노트도 2018년에 md 노트 지원을 추가했고, 단축키 바에 다양한 md 마크업 옵션이 있어 일반 문서 편집과 거의 비슷하며 전반적인 인터페이스는 초보자에게 친숙합니다.&lt;/p&gt;
&lt;h3 id=&#34;ide-추천&#34;&gt;IDE 추천
&lt;/h3&gt;&lt;p&gt;글을 쓰고 있을 때 2020년이었고, vscode는 이미 많이 들어봤을 것이다. git page를 사용하여 블로그 시스템을 구축할 생각을 하는 사람은 어차피 업계 관계자일 테니까. 과거에는 sublime이나 atom도 괜찮은 선택이었지만, 2년간의 오픈소스 커뮤니티 주도로 vscode가 빠르게 발전하여 초보자가 입문하기에 가장 좋은 선택이 되었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;마이크로소프트의 거대한 변화와 오픈소스 커뮤니티와의 관계가 단절 상태에서 훈정기로 성공적으로 전환되었습니다. 오픈소스에 대한 포용적인 태도죠. 저희 회사 역시 최근 2년간 Java 생태계를 적극적으로 도입했습니다. 바꿔 말하면, 현재 국내에서의 Java 환경은 정말 매력적입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;vs-code-플러그인-추천&#34;&gt;VS Code 플러그인 추천
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/blog-ide-environment-and-ramblings/2020-03-31-14-07-17.png&#34;
	width=&#34;310&#34;
	height=&#34;306&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;插件清单&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;101&#34;
		data-flex-basis=&#34;243px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;플러그인에는 자체 Readme 파일이 있어 기본 사용법과 핵심 기능을 설명하고 있으며, 일부 플러그인 제작자는 동적 효과 시연 이미지를 제공합니다&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;, Hugo의 이미지 플러그인 방식과 함께 사용하면 간편하게 이미지를 추가할 수 있습니다&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;단축키를 외우지 못해서, VS Code 단축키 관리 메뉴에서 md를 검색하고 여러 번 보고, 플러그인 사용 설명서를 다시 확인해 봐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;hugo&#34;&gt;hugo
&lt;/h2&gt;&lt;p&gt;글쓰는 일이 내 본성과는 거리가 멀다. 참지 못하고 덤비는 성향 때문이다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Hugo는 이미지와 md 문서를 별도의 폴더에 배치하는 것을 지원합니다&lt;/li&gt;
&lt;li&gt;학술 주제는 디자인에서 다양한 문서 스타일을 지원합니다&lt;/li&gt;
&lt;li&gt;다양한 맞춤형 확장 기능&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;academic&#34;&gt;academic
&lt;/h2&gt;&lt;p&gt;공식 웹사이트 기본 &lt;strong&gt;인라인_5&lt;/strong&gt; 굵게_3__인라인__인라인_6__ 굵게_4__인라인__&lt;/p&gt;
&lt;p&gt;URL 패턴은 클릭하면 단일 페이지로 이동하고, 홈페이지에서 스크롤하는 방식이 아니라서 개인적인 취향입니다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스타일별: 에세이, 강연, 전자책&lt;/li&gt;
&lt;li&gt;유연성: 전체 스타일 사용자 정의, CSS 스타일 사용자 정의&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 테마는 중국어 지원이 아직 완벽하지 않은데, 주로 시각적인 측면에서 폰트 크기가 중국어 읽기 습관에 잘 맞지 않습니다. Hexo 개발팀의 대부분이 중국인이므로 이 점에서는 Hugo보다 우수합니다.&lt;/p&gt;
&lt;p&gt;하지만, 직접 만들어서 입고 먹는 것처럼, 브라우저에서 요소들을 검사합니다. 요소를 찾았으면 수정해야 할 CSS 스타일 이름이 궁금할 때 사이드바에서 &lt;strong&gt;Insert Style Rule Below&lt;/strong&gt;을 클릭하면 여러 겹으로 중첩된 CSS에서도 노드 이름을 쉽게 얻을 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;li&gt;죄송합니다, 번역할 중국어 텍스트가 제공되지 않았습니다. 텍스트를 제공해 주시면 번역해 드리겠습니다.&lt;/li&gt;
&lt;li&gt;주제 내장 문법 강조 설정, &lt;a class=&#34;link&#34; href=&#34;https://sourcethemes.com/academic/docs/writing-markdown-latex/#highlighting-options.&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;마무리&#34;&gt;마무리
&lt;/h2&gt;&lt;p&gt;애가 또 뭐라 하네, 처음부터 끝까지 얼버무려 말하고 구체적인 내용은 하나도 안 짚어주잖아&lt;/p&gt;
&lt;p&gt;이것들만 있으면 충분할 거예요:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;공식 매뉴얼&lt;/li&gt;
&lt;li&gt;플러그인 설명&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;새로운 기술을 빠르게 익히려면 먼저 공식 문서를 읽어보는 것이 좋습니다. 한 번에 다 이해하려고 하기보다는, 적어도 대략적인 내용을 파악하는 것이 중요합니다. 검색 엔진 결과는 최신 버전과 일치하지 않아 오해를 불러일으킬 수도 있습니다. 새 책도 마찬가지입니다. 목차를 살펴보고 저자가 무엇을 설명하려 하는지 파악한 후 읽으면 좋습니다. 때로는 서문을 먼저 읽는 것도 좋은데, 일부 외국 저작물의 경우 번역자의 서문이 책의 핵심 내용을 담고 있는 경우도 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;이스터-에그&#34;&gt;이스터 에그
&lt;/h2&gt;&lt;p&gt;Hugo Academic 내장 스타일 시선을 변경하고 사이트에 게시했지만, 방문했을 때 스타일이 변하지 않았습니다. 똑똑한 분들은 이미 생각했을 겁니다. 로컬 브라우저 캐시를 지우면 문제가 해결됩니다. 저의 기발한 방법은 F12 개발자 모드로 들어가 __INLINE_CODE_0__BOLD_2&lt;code&gt;disable cache&lt;/code&gt;로 변경 후 새로 고침하면 됩니다!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/blog-ide-environment-and-ramblings/2020-03-31-14-27-15.png&#34;
	width=&#34;399&#34;
	height=&#34;142&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;network&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;280&#34;
		data-flex-basis=&#34;674px&#34;
	
&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>자동 통합 시스템 전환</title>
        <link>https://blog.ttf248.life/ko/p/auto-integration-system-switch/</link>
        <pubDate>Sun, 29 Mar 2020 02:11:33 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/auto-integration-system-switch/</guid>
        <description>&lt;p&gt;GitHub Actions를 사용하여 Hugo 블로그를 GitHub Pages 및 Gitee에 자동으로 배포합니다&lt;/p&gt;
&lt;h4 id=&#34;배경-소개&#34;&gt;배경 소개
&lt;/h4&gt;&lt;p&gt;블로그 업데이트 중 Travis 서비스가 작동하지 않는 것을 발견했는데, Travis 웹페이지를 확인해보니 소스 코드 가져오기 단계에서 멈춰있었습니다. 그때 GitHub에서 출시한 Action 서비스가 떠올랐습니다.&lt;/p&gt;
&lt;p&gt;비교적 바쁠 것 같고, 사용하려면 신청도 해야 해서, 지금부터 정식으로 출시되었으니 주말에 시간 나면 새로운 장난감을 한번 해볼까요?&lt;/p&gt;
&lt;p&gt;공식 자료는 웹사이트에서 직접 확인하시면 되고, 이 글은 더 이상 인용하지 않겠습니다. 이전부터 Kubernetes를 사용해 보신 분들은 action의 YAML 파일 설정이 Kubernetes와 비슷하다고 느끼실 겁니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阮一峰的博客&lt;/strong&gt;을 검색해 보세요. 두 개의 기사가 있는데, 첫 번째는 기초 문법 소개이고, 두 번째는 실제 사례입니다.&lt;/p&gt;
&lt;h4 id=&#34;본문&#34;&gt;본문
&lt;/h4&gt;&lt;p&gt;필요한 지식점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;github secrets&lt;/li&gt;
&lt;li&gt;행동 구문&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;기존 컴포넌트를 활용하여 핵심 작업이 완료되었고, 명령어를 사용하여 국내 gitee에 푸시했습니다. 명령어 부분은 다소 거칠며 강제 푸시 방식으로 구현되어 있으며, travis 사용 로직을 이어받았습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;name: github pages and gitee pages

on:
  push:
    branches:
      - hugo

jobs:
  deploy:
    runs-on: ubuntu-18.04
    steps:
      - uses: actions/checkout@v2
        with:
          submodules: true

      - name: Setup Hugo
        uses: peaceiris/actions-hugo@v2
        with:
          hugo-version: &#39;latest&#39;
          extended: true

      - name: Build Github and Gitee ## 单个step只能写一个run命令
        run: hugo -b &amp;quot;https://www.xiangtianlong.com/&amp;quot; -d &amp;quot;github_public&amp;quot; &amp;amp;&amp;amp; hugo -b &amp;quot;https://www.xiangtianlong.com/&amp;quot; -d &amp;quot;gitee_public&amp;quot; &amp;amp;&amp;amp; ls

      - name: Deploy Github
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.BLOG_TOKEN }}
          publish_dir: ./github_public
          publish_branch: master
          cname: xiangtianlong.com

      - name: Deploy Gitee
        run: cd ./gitee_public &amp;amp;&amp;amp; git init &amp;amp;&amp;amp; git config user.name &amp;quot;TianlongXiang&amp;quot; &amp;amp;&amp;amp; git config user.email &amp;quot;tianlongxiang51@gmail.com&amp;quot; &amp;amp;&amp;amp; git add . &amp;amp;&amp;amp; git commit -m &amp;quot;Update TianlongXiang&#39;s Blog&amp;quot; &amp;amp;&amp;amp; git push --force &amp;quot;https://xiangtianlong:${{ secrets.GITEE_PASSWORD }}@gitee.com/xiangtianlong/xiangtianlong.git&amp;quot; master:master   
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;사후기&#34;&gt;사후기
&lt;/h4&gt;&lt;p&gt;공식 시장에서 제공하는 기능들을 보면 현재 지원되는 플레이 방식이 꽤 많고, Docker 이미지 빌드 후에는 더 이상 Docker Hub의 서비스를 의존하지 않아도 된다&lt;/p&gt;
&lt;p&gt;Hugo 이슈를 확인해 보니, GitHub Actions을 사용하여 Git Pages를 자동 배포하려면 최종적으로 게시되는 웹 페이지가 master 브랜치에 있어야 합니다. 다른 브랜치에 배포하면 설정 인터페이스에서 GitHub가 배포된 웹 페이지에 구문 오류가 있다는 것을 알립니다.&lt;/p&gt;
&lt;p&gt;실제로 hugo의 원본 파일이 master 브랜치에 위치하여 github가 jelly 블로그 소스 코드로 간주하고 검사를 진행하면서, 검사 및 통과 실패로 인한 오류가 발생한 것입니다&lt;/p&gt;
&lt;p&gt;솔루션도 간단합니다. Hugo 소스 파일은 다른 분기에 두고, 정적 파일은 master 분기를 통해 배포하면 됩니다.&lt;/p&gt;</description>
        </item>
        <item>
        <title>표준 라이브러리 컨테이너의 메모리 할당자: allocator</title>
        <link>https://blog.ttf248.life/ko/p/standard-library-container-memory-allocator/</link>
        <pubDate>Mon, 30 Dec 2019 13:26:19 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/ko/p/standard-library-container-memory-allocator/</guid>
        <description>&lt;p&gt;사용자 정의 할당자는 성능 향상, 메모리 사용 효율성 증대, 그리고 빈번한 소량 메모리 할당 문제를 해결할 수 있습니다&lt;/p&gt;
&lt;h4 id=&#34;전인&#34;&gt;전인
&lt;/h4&gt;&lt;p&gt;최근 네트워크 데이터 패킷 개발을 진행하면서 빈번하게 작은 메모리 블록을 할당하고 해제해야 하는데, 메모리 풀을 사용하려 했더니 기존 메모리 풀들을 살펴보니 이런 것을 발견했다&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/cacay/MemoryPool&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/cacay/MemoryPool&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;인터페이스를 보니까 좀 이상하다, 이 메모리 풀 구현이 어떻게 이렇게 특이할까. &lt;code&gt;MemoryPool&lt;/code&gt;的实现逻辑，是在申请固定大小的内存空间。看过boost的内存池接口，提供的是一个模板，用的时候进行实例化。正巧这个库已经有文章进行过介绍，提到了&lt;code&gt;allocator&lt;/code&gt; 개념 말이야.&lt;/p&gt;
&lt;h4 id=&#34;wikihttpszhwikipediaorgwikie58886e9858de599a8_c2b2b&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_%28C%2B%2B%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wiki&lt;/a&gt;
&lt;/h4&gt;&lt;p&gt;C++ 프로그래밍에서 할당자(allocator)는 C++ 표준 라이브러리의 중요한 구성 요소입니다. C++ 라이브러리에는 연결 리스트, 집합 등 다양한 “컨테이너” 데이터 구조가 정의되어 있으며, 이 컨테이너들의 공통적인 특징 중 하나는 프로그램 실행 시간에 크기를 변경할 수 있다는 것입니다. 이를 구현하기 위해 동적 메모리 할당이 필수적이므로, 할당자는 컨테이너의 메모리 할당 및 해제 요청을 처리하는 데 사용됩니다. 다시 말해, 할당자는 표준 템플릿 라이브러리(STL) 컨테이너의 메모리 관리에 대한 저수준 세부 사항을 캡슐화합니다. 기본적으로 C++ 표준 라이브러리는 자체 제공하는 범용 할당자를 사용하지만, 필요에 따라 프로그래머는 자신만의 할당자를 정의하여 대체할 수 있습니다.&lt;/p&gt;
&lt;p&gt;분포자는 원래 C++ 표준 템플릿 라이브러리(STL)의 일부로 알렉산드르 스테파노프가 “라이브러리를 더욱 유연하게 만들고, 하위 데이터 모델에 의존하지 않는 방법”을 목표로 발명했지만, C++ 표준 위원회는 STL을 표준으로 채택하는 과정에서 완전한 데이터 모델 추상화가 용납할 수 없는 성능 저하를 야기한다는 것을 깨달았습니다. 이러한 절충안으로 인해 표준에서 할당자에 대한 제약이 더욱 엄격해졌고, 결과적으로 현재 표준에 설명된 할당자의 사용자 정의 가능성은 스테파노프의 원래 구상에 비해 크게 제한되었습니다.&lt;/p&gt;
&lt;p&gt;할당기 사용자 정의는 제한적일 수 있지만, 많은 경우 다양한 메모리 공간(공유 메모리 및 재활용 메모리와 같은)에 대한 접근 방식을 캡슐화하거나 메모리 풀을 사용한 메모리 할당 시 성능을 향상시키기 위해 여전히 사용자 정의 할당기가 필요합니다. 또한, 빈번하게 소량의 메모리를 할당하는 프로그램에서는 메모리 점유 및 실행 시간 측면에서 전용으로 최적화된 할당기를 도입하면 상당한 이점을 얻을 수 있습니다.&lt;/p&gt;
&lt;h4 id=&#34;使用需求httpszhwikipediaorgwikie58886e9858de599a8_c2b2b&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_%28C%2B%2B%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;使用需求&lt;/a&gt;
&lt;/h4&gt;&lt;p&gt;사용자 정의 할당기를 사용하는 주된 이유 중 하나는 성능 향상입니다. 전용 사용자 정의 할당기는 프로그램의 성능을 높이거나, 메모리 사용 효율성을 개선하거나, 이 둘 모두를 달성할 수 있습니다 [4][8]. 기본 할당기는 new 연산자를 사용하여 저장 공간을 할당하는데, 이는 종종 C 언어의 힙 할당 함수(malloc())를 통해 구현됩니다 [9]. 힙 할당 함수는 일반적으로 일시적으로 많은 메모리를 할당하는 데 최적화되어 있으므로, 대량의 메모리를 한 번에 할당해야 하는 컨테이너(예: 벡터, 양방향 큐)의 경우 기본 할당기는 효율적인 경향이 있습니다 [8]. 그러나 연결 리스트와 같이 빈번하게 소량의 메모리를 할당해야 하는 컨테이너의 경우 기본 할당기를 사용하면 일반적으로 효율성이 매우 낮습니다 [4][9]. 또한 malloc() 기반의 기본 할당기는 낮은 지역성[4] 및 메모리 조각화 발생 가능성[4][9]과 같은 여러 가지 문제점을 가지고 있습니다.&lt;/p&gt;
&lt;p&gt;간단히 말해서, 이 부분은 (……)이 해당 표준의 할당기 관련 《나에게 꿈이 있어요》와 같습니다. 꿈이 실현되기 전에는 이식성을 중시하는 프로그래머들은 상태 없는 사용자 정의 할당기를 사용할 수밖에 없을 것입니다.
——스코트 메이스, 《Effective STL》
이러한 점을 감안하여, 이 경우에 사람들은 빈번한 소량 할당 문제를 해결하기 위해 메모리 풀 기반 할당기를 자주 사용한다[8]. 기본 “요청 시 할당” 방식과 달리, 메모리 풀 기반 할당기를 사용하는 경우 프로그램은 미리 대용량 메모리(즉, &amp;ldquo;메모리 풀&amp;rdquo;)를 할당하고, 필요할 때 사용자 정의 할당기는 요청자에게 풀 내 메모리의 포인터를 반환하기만 한다. 객체 소멸 시에는 실제로 메모리를 해제하지 않고, 메모리 풀의 수명이 종료될 때 비로소 해제를 지연시킨다[주 1][8].&lt;/p&gt;
&lt;p&gt;“사용자 정의 할당기”라는 주제에 대해 스콧 메이어스의 “Effective STL”과 안드레이 알렉산더레스쿠의 “Modern C++ Design”과 같이 여러 C++ 전문가 및 관련 저자들이 참여하여 논의해 왔습니다. 메이어스는 특정 타입 T에 대한 모든 할당기 인스턴스가 동일해야 한다면 이식 가능한 할당기 인스턴스는 상태를 포함해서는 안 된다고 지적했습니다. C++ 표준은 라이브러리 구현자가 상태 기반 할당기를 지원하도록 권장하지만[문헌 4], 메이어스는 관련 단락이 “（보이는 듯한）아름다운 관점”이지만 거의 말도 안 되는 소리이며, 할당기 제한이 “지나치게 엄격하다”고 주장했습니다[4]. 예를 들어, STL의 list는 splice 메서드를 허용하는데, 이는 list 객체 A의 노드가 다른 list 객체 B로 직접 이동될 수 있다는 의미입니다. 이는 A의 할당기가 할당한 메모리가 B의 할당기에 의해 해제될 수 있어야 하므로 A와 B의 할당기 인스턴스가 동일해야 함을 시사합니다. 메이어스의 결론은 할당기를 정적 메서드를 사용하는 타입으로 정의하는 것이 가장 좋다는 것입니다. 예를 들어, C++ 표준에 따르면 할당기는 rebind 메서스를 구현한 other 클래스 템플릿을 제공해야 합니다.&lt;/p&gt;
&lt;p&gt;또 다른 예로, Bjarne Stroustrup는 그의 저서 《C++ 프로그램 설계 언어》에서 “각 객체 정보가 다를 수 없도록 할당자를 엄격하게 제한하는 것은 큰 문제가 아니다.”라고 주장하며 대부분의 할당자는 상태를 필요로 하지 않으며, 심지어 상태가 없는 경우 성능이 더 좋을 수도 있다고 지적합니다. 그는 메모리 풀 할당자, 공유 메모리 할당자 및 가비지 컬렉션 할당자의 세 가지 사용자 정의 할당자 사용 사례를 제시하고 내부 메모리 풀을 활용하여 소량의 메모리를 빠르게 할당/해제하는 할당자 구현을 보여줍니다. 하지만 이러한 최적화는 이미 그가 제공한 예시 할당자에서 구현되었을 수도 있다고 언급합니다[3].&lt;/p&gt;
&lt;p&gt;사용자 정의 할당기의 또 다른 용도는 메모리 관련 오류를 디버깅하는 것입니다[10]. 이를 위해 추가 메모리를 할당하여 디버그 정보를 저장하는 할당기를 작성할 수 있습니다. 이러한 할당기는 메모리가 동일한 할당기에서 할당 및 해제되도록 보장할 뿐만 아니라, 캐시 오버플로로부터 프로그램의 안전을 어느 정도 보호할 수도 있습니다[11].&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
