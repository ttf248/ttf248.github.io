<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>TCP on Uncle Xiang&#39;s Notebook</title>
        <link>https://ttf248.life/en/tags/tcp/</link>
        <description>Recent content in TCP on Uncle Xiang&#39;s Notebook</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <lastBuildDate>Sun, 25 May 2025 02:57:45 +0800</lastBuildDate><atom:link href="https://ttf248.life/en/tags/tcp/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Troubleshooting TCP Communication Abnormalities in Backend Services</title>
        <link>https://ttf248.life/en/p/backend-service-tcp-communication-troubleshooting/</link>
        <pubDate>Fri, 14 Feb 2025 22:54:13 +0800</pubDate>
        
        <guid>https://ttf248.life/en/p/backend-service-tcp-communication-troubleshooting/</guid>
        <description>&lt;p&gt;The business model involves backend services establishing a connection with the group&amp;rsquo;s market gateway via TCP. Each connection requires sending an authorization request first, followed by continuously sending heartbeat packets to maintain the connection status.
However, one day, we received an alert message indicating a service disconnection. After carefully checking the logs, we discovered that the backend service was continuously sending heartbeat packets, but there was no response from the other party, yet the connection never disconnected.&lt;/p&gt;
&lt;h2 id=&#34;brief-description-of-the-scene&#34;&gt;Brief description of the scene
&lt;/h2&gt;&lt;p&gt;I was originally working overtime at the company to push forward project progress when an alarm message suddenly popped up in the work group. At first glance, I thought it was just the usual issue – likely a network timeout causing heartbeat failures and subsequently disconnecting the service. However, after carefully checking the logs, I found that the actual situation was not like that. The backend had sent authorization login messages, but received no response. Meanwhile, heartbeats continued to be sent incessantly, yet the other party never replied with any heartbeat data. In-depth analysis of the logs revealed the following key issues:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Authorization message received no response: It is very likely that the other party&amp;rsquo;s system is restarting, preventing the authorization message from being processed in a timely manner&lt;/li&gt;
&lt;li&gt;The heartbeat data was sent even though authorization failed: After investigation, we found a flaw in the program logic. The judgment logic of the heartbeat sending function is flawed; it only checks the connection status but overlooks the authorization status check.&lt;/li&gt;
&lt;li&gt;If the service can be disconnected, it will trigger a reconnection mechanism and resend the authorization message&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Currently, there remains one last urgent issue that needs resolving—why the connection has not been disconnected. Solving this problem requires more in-depth and detailed troubleshooting work.&lt;/p&gt;
&lt;h2 id=&#34;analyzing-network-packets&#34;&gt;Analyzing network packets
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;tcpdump&lt;/code&gt; is a very powerful network packet capture tool that can be used to capture network data packets. By analyzing these network data packets, we can gain a more intuitive understanding of the details of network communication. Here, we can use &lt;code&gt;tcpdump&lt;/code&gt; to capture network data packets for further analysis.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/backend-service-tcp-communication-troubleshooting/20250220151952.png&#34;
	width=&#34;1126&#34;
	height=&#34;202&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;tcpdump&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;557&#34;
		data-flex-basis=&#34;1337px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;Analyzing the data in the graph, I can see that the heartbeat is consistently being sent, but the other server isn&amp;rsquo;t responding with any data, yet it’s sending an &lt;code&gt;ACK&lt;/code&gt;. This prevents the connection from disconnecting on its own.&lt;/p&gt;
&lt;h2 id=&#34;common-flag-explanations&#34;&gt;Common Flag Explanations
&lt;/h2&gt;&lt;p&gt;In the TCP protocol, &lt;code&gt;PSH&lt;/code&gt; (Push) and &lt;code&gt;ACK&lt;/code&gt; (Acknowledgment) are two important flags used to control data transmission and flow confirmation. Their functions are as follows:&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;1-pshpush-flag&#34;&gt;&lt;strong&gt;1. PSH（Push Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Features
The purpose of the &lt;code&gt;PSH&lt;/code&gt; flag is to &lt;strong&gt;request that the receiver immediately push data from the buffer to the upper layer application&lt;/strong&gt; (instead of waiting for the buffer to fill up). This means that once a data segment with the &lt;code&gt;PSH&lt;/code&gt; flag is received, the receiver will process and pass it to the application as quickly as possible, rather than storing it in the operating system buffer.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Typical Scenarios&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP/HTTPS requests: When a client sends a request (such as &lt;code&gt;GET /index.html&lt;/code&gt;), it sets the &lt;code&gt;PSH&lt;/code&gt; flag, hoping that the server will respond immediately&lt;/li&gt;
&lt;li&gt;The SSH protocol: Each keyboard input triggers a &lt;code&gt;PSH&lt;/code&gt;, ensuring that input characters are transmitted in real-time&lt;/li&gt;
&lt;li&gt;Real-time communication: Low-latency scenarios such as video streams and online games may use &lt;code&gt;PSH&lt;/code&gt; to reduce latency&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PSH is not mandatory; the receiving party can choose to ignore this flag (but still needs to process the data normally)&lt;/li&gt;
&lt;li&gt;The sender may not set the &lt;code&gt;PSH&lt;/code&gt;, in which case the receiver will decide when to push data based on its own buffering strategy&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2-ackacknowledgment-flag&#34;&gt;&lt;strong&gt;2. ACK（Acknowledgment Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Features
The ACK flag indicates that &lt;strong&gt;the preceding segment of data has been received correctly&lt;/strong&gt;. Each ACK contains an acknowledgment number (Acknowledgment Number), which represents the next expected byte sequence number. It is a core mechanism for reliable transmission in TCP.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Working principle:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When the sender sends a data segment, it carries the expected receiver&amp;rsquo;s &lt;code&gt;ACK&lt;/code&gt; value (for example, &lt;code&gt;ACK = sequence number + data length&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Upon receiving data, the receiver generates an &lt;code&gt;ACK&lt;/code&gt; segment confirming the received sequence number&lt;/li&gt;
&lt;li&gt;The sender will only retransmit unacknowledged data after receiving the corresponding ACK&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Example&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the sender sends a data segment with sequence number &lt;code&gt;100~199&lt;/code&gt;, the expected &lt;code&gt;ACK&lt;/code&gt; from the receiver should be &lt;code&gt;200&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;If the receiving party fails to receive some of the data within the range of &lt;code&gt;100~199&lt;/code&gt;, it will inform the sending party to retransmit via &lt;code&gt;ACK=150&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;the-combination-of-psh-and-ack&#34;&gt;The combination of PSH and ACK
&lt;/h3&gt;&lt;p&gt;In TCP packets, &lt;code&gt;PSH&lt;/code&gt; and &lt;code&gt;ACK&lt;/code&gt; can appear simultaneously, commonly seen in the following scenarios:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;HTTP request response
When the client sends a &lt;code&gt;POST&lt;/code&gt; request (with data), it sets &lt;code&gt;PSH&lt;/code&gt; and &lt;code&gt;ACK&lt;/code&gt; (acknowledgment of previous responses)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Client → Server: SYN, ACK=1 → 建立连接
Client → Server: PSH, ACK=1, 数据 → 发送请求数据
Server → Client: PSH, ACK=数据长度+1 → 返回响应
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Transmit commands after SSH handshake
After the client enters a command, it sends a data segment with &lt;code&gt;PSH&lt;/code&gt; and &lt;code&gt;ACK&lt;/code&gt; to ensure that the command is immediately transmitted and processed by the server&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;other-flag-bit-associations&#34;&gt;Other flag bit associations
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Flag&lt;/th&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Brief Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SYN Synchronization Initialization Connection (Three-Way Handshake)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FIN&lt;/td&gt;
&lt;td&gt;End&lt;/td&gt;
&lt;td&gt;Gracefully close connection&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Reset&lt;/td&gt;
&lt;td&gt;Force connection termination (abnormal situation)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mark urgent pointer (rarely used)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h3 id=&#34;summary&#34;&gt;Summary
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;PSH focuses on getting data to the application layer as quickly as possible, reducing latency&lt;/li&gt;
&lt;li&gt;ACK focuses on reliable data transmission, avoiding packet loss or out-of-order delivery&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;They work together to balance the efficiency and reliability of the TCP protocol&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
