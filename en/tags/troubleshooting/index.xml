<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Troubleshooting on Uncle Xiang&#39;s Notebook</title>
        <link>https://blog.ttf248.life/en/tags/troubleshooting/</link>
        <description>Recent content in Troubleshooting on Uncle Xiang&#39;s Notebook</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <lastBuildDate>Wed, 28 May 2025 09:47:38 +0800</lastBuildDate><atom:link href="https://blog.ttf248.life/en/tags/troubleshooting/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Protobuf Zero-Value Trap: When Defaults Become Silent Killers of Business Logic</title>
        <link>https://blog.ttf248.life/en/p/protobuf-zero-value-traps/</link>
        <pubDate>Thu, 20 Feb 2025 15:26:51 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/en/p/protobuf-zero-value-traps/</guid>
        <description>&lt;p&gt;US stocks have three trading periods: pre-market, intra-market, and post-market. The data push logic (to minimize bandwidth usage) sends the full dataset once initially, then pushes incremental updates for all subsequent fields.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Why not use the optimal solution? It involves different project teams, some of which have been live for many years. We are newly integrated, so we can only try to maintain compatibility.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;a-series-of-questions&#34;&gt;A series of questions
&lt;/h2&gt;&lt;p&gt;Looking at the abstract alone, there might not seem to be a problem. However, bringing this system architecture into the problem-solving process has triggered a series of issues. Just as one issue was resolved, another arose, stemming from the previous ones.&lt;/p&gt;
&lt;h3 id=&#34;unable-to-identify-trading-period&#34;&gt;Unable to identify trading period
&lt;/h3&gt;&lt;p&gt;Whether the in-memory stage is defined as the default value or the actual business value&lt;/p&gt;
&lt;p&gt;A simple understanding: Receiving a 0 each time makes it impossible to determine whether it&amp;rsquo;s a new quote setting or the default value of Protobuf&lt;/p&gt;
&lt;h3 id=&#34;introduce-optional&#34;&gt;Introduce optional
&lt;/h3&gt;&lt;p&gt;Since protobuf release 3.15, proto3 supports using the optional keyword (just as in proto2) to give a scalar field presence information&lt;/p&gt;
&lt;p&gt;The internal communication protocol is based on &lt;code&gt;protobuf&lt;/code&gt;BOLD_3&lt;code&gt;optional&lt;/code&gt;BOLD_4&lt;code&gt;protobuf&lt;/code&gt;, and the project&amp;rsquo;s underlying implementation uses a static library, which requires upgrading the entire compilation chain. This cost is very high.&lt;/p&gt;
&lt;h3 id=&#34;gcc-version-issue&#34;&gt;GCC version issue
&lt;/h3&gt;&lt;p&gt;After much deliberation, we devised a plan to release two different versions at the underlying level, aiming to carefully control new features&lt;/p&gt;
&lt;p&gt;Commonly used server types within the group: CentOS 7, CentOS 8. The default version of CentOS 7 is above 7.4, so CentOS 7 is not supported.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=82461&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Bug 82461 - [7 Regression] Temporary required for brace-initializing (non-literal-type) member variable&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;After some troubleshooting, moving the related services and compilation server to CentOS 8 resolved the issue&lt;/p&gt;
&lt;h2 id=&#34;reasonable-enumeration&#34;&gt;Reasonable Enumeration
&lt;/h2&gt;&lt;p&gt;Looking back at the entire issue, there&amp;rsquo;s a simpler and more efficient solution: adjust the enumeration definition to start numbering from 1 instead of 0. This effectively distinguishes default values from business values, avoiding the aforementioned series of problems.&lt;/p&gt;
&lt;h3 id=&#34;why-is-starting-from-1-more-reasonable&#34;&gt;Why is starting from 1 more reasonable?
&lt;/h3&gt;&lt;p&gt;In C++, the default value of an enumeration type is fixed at 0. If we define a meaningful business value as 0 (e.g., &amp;ldquo;in-plate&amp;rdquo;), the downstream system cannot determine whether the received 0 represents a business value or an unset default value during incremental push. However, if enumerations are defined starting from 1, 0 can be reserved for a meaningless default value or an &amp;ldquo;unknown&amp;rdquo; state, resolving the issue.&lt;/p&gt;
&lt;p&gt;Suggested practices:&lt;/p&gt;
&lt;p&gt;When designing Protobuf enums, always define 0 as a meaningless default value
Assign actual business values starting from 1, ensuring distinction from the default value of 0&lt;/p&gt;
&lt;p&gt;This small adjustment not only resolved the trading period identification issue but also provided a valuable lesson for future protocol design&lt;/p&gt;</description>
        </item>
        <item>
        <title>Troubleshooting TCP Communication Anomalies in Backend Services</title>
        <link>https://blog.ttf248.life/en/p/backend-service-tcp-communication-troubleshooting/</link>
        <pubDate>Fri, 14 Feb 2025 22:54:13 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/en/p/backend-service-tcp-communication-troubleshooting/</guid>
        <description>&lt;p&gt;Business model: The backend service establishes a connection with the group&amp;rsquo;s market gateway via TCP. Each connection requires an initial authorization request, followed by continuous heartbeat packets to maintain connection status.
However, one day, an alert about a service disconnection was received. After carefully checking the logs, it was discovered that the backend service continuously sent heartbeat packets, but there was no response from the other party, yet the connection never disconnected.&lt;/p&gt;
&lt;h2 id=&#34;brief-overview&#34;&gt;Brief Overview
&lt;/h2&gt;&lt;p&gt;I was working late at the office, pushing forward project progress, when an alert suddenly popped up in our work group. At first glance, I thought it was just a network timeout causing heartbeat failures and service disconnections. However, after carefully checking the logs, the situation proved to be different. The backend had sent authorization login messages, but received no response. Meanwhile, heartbeats continued to be sent, yet there was no reply whatsoever. In-depth analysis of the logs revealed several key issues:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Authorization message failed due to no response: This is likely because the other system is restarting, preventing timely processing of the authorization message&lt;/li&gt;
&lt;li&gt;The heartbeat data was sent despite unsuccessful authorization. Investigation revealed a flaw in the program logic: the heartbeat sending function&amp;rsquo;s judgment logic is defective, only checking connection status but omitting authorization status verification.&lt;/li&gt;
&lt;li&gt;If the service can disconnect, it will trigger a reconnection mechanism to resend authorization messages&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Currently, one last critical issue remains: why the connection has not been disconnected. Resolving this requires more in-depth and detailed troubleshooting.&lt;/p&gt;
&lt;h2 id=&#34;analyze-network-packets&#34;&gt;Analyze network packets
&lt;/h2&gt;&lt;p&gt;To capture network packets for further analysis&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.ttf248.life/p/backend-service-tcp-communication-troubleshooting/20250220151952.png&#34;
	width=&#34;1126&#34;
	height=&#34;202&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;tcpdump&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;557&#34;
		data-flex-basis=&#34;1337px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;Analyzing the data in the graph, I can see that the heartbeat was consistently being sent, but no data was received from the other server. However, it provided &lt;code&gt;ACK&lt;/code&gt;, which prevented the connection from disconnecting automatically.&lt;/p&gt;
&lt;h2 id=&#34;common-flag-explanations&#34;&gt;Common Flag Explanations
&lt;/h2&gt;&lt;p&gt;In the TCP protocol, &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;（Push）和 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; (Acknowledgments) are two important flags used to control data transmission and flow confirmation. Their functions are as follows:&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;1-pshpush-flag&#34;&gt;&lt;strong&gt;1. PSH（Push Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;:
Request that the receiver immediately push the data from the buffer to the upper-layer application&amp;rsquo;s data segment, processing and forwarding it as quickly as possible rather than storing it in the operating system buffer&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;典型场景&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Clients expect immediate responses from the server when sending requests (e.g., ping)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Each keyboard input triggers &lt;code&gt;PSH&lt;/code&gt;, ensuring real-time character transmission&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Low-latency scenarios such as video streaming and online games may use &lt;em&gt;edge computing&lt;/em&gt; to reduce latency&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;This flag is not mandatory; the recipient can choose to ignore it (but should still process the data normally)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The sender may not set &lt;code&gt;PSH&lt;/code&gt;, in which case the receiver will decide when to push data based on its own buffering strategy&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2-ackacknowledgment-flag&#34;&gt;&lt;strong&gt;2. ACK（Acknowledgment Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;:
Confirmation that the preceding data segment has been correctly received (indicated by the expected next byte sequence number). It is a core mechanism for reliable transmission in TCP.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;工作原理&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When sending a data segment, the sender will carry the expected recipient&amp;rsquo;s (ID)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Upon receiving the data, the receiver generates an acknowledgment segment confirming the received sequence number&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The sender will only retransmit unacknowledged data after receiving the corresponding confirmation&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the sender sent sequence number 5, 6, and 7&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the recipient does not receive confirmation from the sender regarding retransmission&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;please-provide-the-chinese-text-you-want-me-to-translate-i-am-ready-when-you-are&#34;&gt;Please provide the Chinese text you want me to translate. I am ready when you are!
&lt;/h3&gt;&lt;p&gt;INLINE_CODE_0__ 和 &lt;strong&gt;INLINE_CODE_1&lt;/strong&gt; can occur simultaneously in a TCP message, commonly seen in the following scenarios:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;HTTP 请求响应&lt;/strong&gt;:
The client sends (confirmation of the previous response)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Client → Server: SYN, ACK=1 → 建立连接
Client → Server: PSH, ACK=1, 数据 → 发送请求数据
Server → Client: PSH, ACK=数据长度+1 → 返回响应
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SSH 握手后传输命令&lt;/strong&gt;:
After the client enters a command, it sends a data segment with &lt;code&gt;PSH&lt;/code&gt;BOLD_2&lt;code&gt;ACK&lt;/code&gt; to ensure immediate transmission and processing by the server&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;please-provide-the-chinese-text-you-want-me-to-translate-i-am-ready-when-you-are-1&#34;&gt;Please provide the Chinese text you want me to translate. I am ready when you are!
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Flag&lt;/th&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Brief Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Synchronization&lt;/td&gt;
&lt;td&gt;Establish Connection (Three-Way Handshake)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FIN&lt;/td&gt;
&lt;td&gt;End&lt;/td&gt;
&lt;td&gt;Gracefully close connection&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Reset&lt;/td&gt;
&lt;td&gt;Force connection termination (abnormal situation)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;URG&lt;/td&gt;
&lt;td&gt;Emergency&lt;/td&gt;
&lt;td&gt;Marks emergency pointer (rarely used)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h3 id=&#34;please-provide-the-chinese-text-you-want-me-to-translate-i-am-ready-when-you-are-2&#34;&gt;Please provide the Chinese text you want me to translate. I am ready when you are!
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Focusing on stability, reducing latency&lt;/li&gt;
&lt;li&gt;The focus is on reliability, avoiding dropped or out-of-order packets&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;They work together to balance the efficiency and reliability of the TCP protocol&lt;/p&gt;</description>
        </item>
        <item>
        <title>Monitoring Linux System Metrics with atop: A Complete Guide to Installation, Configuration, and Usage</title>
        <link>https://blog.ttf248.life/en/p/using-atop-to-monitor-linux-system-metrics-installation-configuration-and-usage-guide/</link>
        <pubDate>Thu, 06 Feb 2025 22:48:55 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/en/p/using-atop-to-monitor-linux-system-metrics-installation-configuration-and-usage-guide/</guid>
        <description>&lt;p&gt;Real-time and comprehensive monitoring of system resources and process status is crucial in Linux system maintenance. The atop tool, as a powerful monitoring utility, can help us achieve this goal easily. This article will detail how to install, configure, and use the atop monitoring tool on a Linux instance.&lt;/p&gt;
&lt;h2 id=&#34;introduction-to-atop-tool&#34;&gt;Introduction to atop tool
&lt;/h2&gt;&lt;p&gt;Atop is a tool dedicated to monitoring Linux system resources and processes. It records system and process activity, reporting on the status of all running processes. Data collected includes resource usage (CPU, memory, disk, network) and process states, which can be saved as log files. For each process, we obtain key information such as CPU utilization, memory growth, disk usage, priority, username, status, and exit code. Furthermore, through the Atop configuration file, users can customize parameters like logging frequency, storage path, and rotation policy.&lt;/p&gt;
&lt;h2 id=&#34;installing-atop-tool&#34;&gt;Installing atop tool
&lt;/h2&gt;&lt;p&gt;Installation methods for atop vary slightly across different Linux distributions; the following explanation uses a common operating system as an example&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Alibaba Cloud Linux 3/2、CentOS 7/8、Fedora、Rocky Linux 9&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Execute installation command:&lt;/li&gt;
&lt;li&gt;Start atop service:&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;Ubuntu / Debian&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Update software source list:&lt;/li&gt;
&lt;li&gt;Execute installation command:&lt;/li&gt;
&lt;li&gt;Start atop service:&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;CentOS Stream 9&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Download and install:&lt;/li&gt;
&lt;li&gt;Start atop service:&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;openSUSE&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Execute installation command:&lt;/li&gt;
&lt;li&gt;Start atop service:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If your operating system distribution is not listed above, please visit the atop official website for installation information&lt;/p&gt;
&lt;h2 id=&#34;configure-monitoring-cycle-and-log-retention-time&#34;&gt;Configure monitoring cycle and log retention time
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;In Alibaba Cloud Linux 3/2, CentOS 7/8, and Fedora systems, the atop configuration file is __；在Ubuntu、Debian和openSUSE系统中，配置文件是__INLINE_CODE_1&lt;/li&gt;
&lt;li&gt;Please provide the Chinese text you want me to translate. I am ready when you are!&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Used to control log file recording options; defaults to empty&lt;/li&gt;
&lt;li&gt;Monitoring cycle, default 600 seconds. To collect historical logs for troubleshooting, adjust this frequency as needed.&lt;/li&gt;
&lt;li&gt;Log retention period, default 28 days&lt;/li&gt;
&lt;li&gt;It appears you&amp;rsquo;ve provided a string of formatting codes rather than actual Chinese text. Without the Chinese characters, I cannot translate. Please provide the Chinese text you want translated.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Please provide the Chinese text you want me to translate. I am ready when you are!&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Execute command to open configuration file:&lt;/li&gt;
&lt;li&gt;On Alibaba Cloud Linux 3/2, CentOS 7/8, and Fedora systems:&lt;/li&gt;
&lt;li&gt;In Ubuntu, Debian, openSUSE, CentOS Stream 9, Rocky Linux 9 systems:&lt;/li&gt;
&lt;li&gt;Enter edit mode by pressing &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;, then adjust the configuration parameters as needed. For example, change the monitoring cycle to 30 seconds, set the log retention time to 7 days, and keep the default log path:&lt;/li&gt;
&lt;li&gt;Press, save, and exit editing&lt;/li&gt;
&lt;li&gt;Restarting the atop service applies the configuration&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;LOGOPTS=&amp;quot;&amp;quot;
LOGINTERVAL=30
LOGGENERATIONS=7
LOGPATH=/var/log/atop 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;using-the-atop-tool&#34;&gt;Using the atop tool
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;The following are common commands in interactive command mode:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Switch back to the default combined output view&lt;/li&gt;
&lt;li&gt;Display the full command line of processes&lt;/li&gt;
&lt;li&gt;Sort by process memory usage in descending order&lt;/li&gt;
&lt;li&gt;Sort processes by disk usage in descending order&lt;/li&gt;
&lt;li&gt;Sort by process resource utilization in descending order&lt;/li&gt;
&lt;li&gt;Sort by process network usage in descending order&lt;/li&gt;
&lt;li&gt;Go to the next monitoring point&lt;/li&gt;
&lt;li&gt;Go to the previous monitoring point&lt;/li&gt;
&lt;li&gt;It appears you&amp;rsquo;ve provided a string of formatting codes rather than actual Chinese text. Without the Chinese characters, I cannot translate. Please provide the Chinese text you want translated.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Please provide the Chinese text you want me to translate. I am ready when you are!&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Hostname, information sampling date and time&lt;/li&gt;
&lt;li&gt;Overall process runtime information, including kernel and user space execution time, total number of processes, and the count of processes in different states&lt;/li&gt;
&lt;li&gt;Overall CPU utilization, the sum of values for each field equals &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; (N being the number of CPU cores), including kernel time, user time, interrupts, idle time, and wait for disk I/O&lt;/li&gt;
&lt;li&gt;CPU load information, such as the average number of processes in the run queue over the past 1, 5, and 15 minutes, context switch count, and interrupt occurrence count&lt;/li&gt;
&lt;li&gt;Memory usage, including total physical memory, idle memory, page cache memory, file cache memory, and kernel occupied memory&lt;/li&gt;
&lt;li&gt;Swap space usage, including total swap area and free swap space size&lt;/li&gt;
&lt;li&gt;Virtual memory paging information, such as page swap in and swap out counts&lt;/li&gt;
&lt;li&gt;Disk usage, with each disk device represented by a column, displaying device identifier, busy time ratio, and read/write request count&lt;/li&gt;
&lt;li&gt;Network conditions, displaying receive and send packet sizes for TCP/UDP, IP layer, and active network interfaces&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Please provide the Chinese text you want me to translate. I am ready when you are!&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Check system metrics every 5 seconds&lt;/li&gt;
&lt;li&gt;Check system metrics within the next 5 minutes (30 times, 10-second intervals): &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Check system metrics 10 minutes after the current time (10 times, with 60-second intervals) and write the results to a file: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;After &lt;strong&gt;查看历史指标日志&lt;/strong&gt; starts, log records are saved by default in the &lt;code&gt;/var/log/atop&lt;/code&gt; directory. When viewing, ensure the log file for the specified date exists, otherwise an error will occur.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;View daily history indicator logs&lt;/li&gt;
&lt;li&gt;View yesterday&amp;rsquo;s historical metric logs:&lt;/li&gt;
&lt;li&gt;View historical metric logs for a specified date, such as November 6, 2024&lt;/li&gt;
&lt;li&gt;View historical indicator logs from a specified time within a designated date range, such as from 2:00 PM on November 6, 2024&lt;/li&gt;
&lt;li&gt;View historical indicator logs for a specified date and time period, such as from 00:04 to 00:08 on November 5, 2024&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Please provide the Chinese text you want me to translate. I am ready when you are!&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;View the CPU utilization report for the current system over 1 minute (12 times, with 5-second intervals): &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;View memory indicator reports for a specified time period on a given day, such as 18:00 to 18:01&lt;/li&gt;
&lt;li&gt;View memory metrics reports for specified dates and time periods, such as 6:00 PM to 6:01 PM on November 5, 2024&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;other-operations&#34;&gt;Other Operations
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;To generate an atop index log file daily, you can do the following:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Adjust monitoring cycle, log retention time, and log storage path as needed&lt;/li&gt;
&lt;li&gt;Start the daily log rotation service and enable it to start automatically at boot&lt;/li&gt;
&lt;li&gt;If the business has more complex requirements for log processing, it can be combined with logrotate or custom scripts to implement log management&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;If network usage monitoring is required, you can install the netatop module (which is not installed by default in atop). For example, using Alibaba Cloud Linux 3 system:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Install the kernel development package and software environment required for compilation&lt;/li&gt;
&lt;li&gt;Download the latest version of netatop source code to the designated directory&lt;/li&gt;
&lt;li&gt;Unzip the source code and enter the source directory: &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Build and install modules and daemons from source code&lt;/li&gt;
&lt;li&gt;Start netatop service:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The atop tool is powerful and flexible. With proper installation, configuration, and usage, we can better understand the status of a Linux system, promptly identify and resolve potential issues. We hope this article helps everyone improve their Linux system monitoring skills.&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Please provide the Chinese text you want me to translate. I am ready when you are! Just paste the text here.&lt;/li&gt;
&lt;li&gt;Please provide the Chinese text you want me to translate. I am ready when you are! Just paste the text here.&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Loading mismatched PDB files in Visual Studio</title>
        <link>https://blog.ttf248.life/en/p/visual-studio-loading-unmatched-pdb-files/</link>
        <pubDate>Thu, 23 Jan 2025 20:04:33 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/en/p/visual-studio-loading-unmatched-pdb-files/</guid>
        <description>&lt;p&gt;When debugging a program in Visual Studio on Windows, if the PDB file doesn&amp;rsquo;t match the executable, you’ll receive a &amp;ldquo;Failed to load symbol file&amp;rdquo; error. Program crashes and resulting dump files will also fail to allow smooth entry into the crash scene if the PDB is mismatched.&lt;/p&gt;
&lt;h2 id=&#34;what-is-a-pdb-file&#34;&gt;What is a pdb file?
&lt;/h2&gt;&lt;p&gt;PDB files are debugging information files created by Microsoft, used for program debugging. They contain information such as symbol tables, source file names, and line numbers. PDB files are generated during compilation to aid in debugging.&lt;/p&gt;
&lt;h2 id=&#34;debugging-with-windbg&#34;&gt;Debugging with WinDbg
&lt;/h2&gt;&lt;p&gt;WinDbg is a debugging tool from Microsoft that can be used to debug Windows programs. WinDbg can load mismatched PDB files, but requires manual loading. The __INLINE_CODE_0 command can force the loading of mismatched PDB files.&lt;/p&gt;
&lt;p&gt;However, WinDbg is less convenient than Visual Studio, so we want Visual Studio to also load mismatched PDB files&lt;/p&gt;
&lt;h2 id=&#34;visual-studio-loading-mismatched-pdb-file&#34;&gt;Visual Studio loading mismatched PDB file
&lt;/h2&gt;&lt;p&gt;Source code is now typically managed using Git, allowing you to easily find corresponding versions, recompile them, and generate the associated PDB files. Why can&amp;rsquo;t they be loaded? Primarily due to metadata mismatches.&lt;/p&gt;
&lt;p&gt;A small tool can modify metadata, generate a new PDB file based on executable information, allowing Visual Studio to load it&lt;/p&gt;
&lt;p&gt;Download address for chkmatch: &lt;a class=&#34;link&#34; href=&#34;https://www.debuginfo.com/tools/chkmatch.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.debuginfo.com/tools/chkmatch.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Site cache address: &lt;a class=&#34;link&#34; href=&#34;chkmatch.zip&#34; &gt;chkmatch.zip&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ChkMatch utility can be used to check whether an executable and debug information file match. It can also be used to enforce matching between an executable and debug information file, if they are compatible.

For more information about debug information matching and related issues, see this article.

Supported debug information formats: DBG, PDB 2.0, PDB 7.0.

chkmatch [-c ExeFile DebugInfoFile ] |
         [-m ExeFile DebugInfoFile]
-c
Check matching between the executable and the debug information file.
-m
Make the executable and the debug information file match.
ExeFile
The name of the executable file.
DebugInfoFile
The name of the debug information file.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;use-chkmatch&#34;&gt;Use chkmatch
&lt;/h2&gt;&lt;p&gt;First, perform a verification check, analyze the reason for the mismatch, and prompt that the signature does not match&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\tianlong.xiang\Downloads\chkmatch&amp;gt;ChkMatch.exe -c &amp;quot;D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe&amp;quot; E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb
ChkMatch - version 1.0
Copyright (C) 2004 Oleg Starodumov
http://www.debuginfo.com/


Executable: D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe
Debug info file: E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb

Executable:
TimeDateStamp: c26d9be3
Debug info: 2 ( CodeView )
TimeStamp: f86b0a4f  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 122  RVA: 001cdc44  FileOffset: 001cbe44
CodeView format: RSDS
Signature: {428c9b95-39a3-4a8d-a8e5-7be453684757}  Age: 1
PdbFile: D:\stock_UAT\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\obj\Release\YinTrade.Main.pdb
Debug info: 16 ( Unknown )
TimeStamp: 00000000  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 0  RVA: 00000000  FileOffset: 00000000

Debug information file:
Format: PDB 7.00
Signature: {06fae08e-c0a2-4f3d-9c7c-dfc684445dd1}  Age: 1

Result: Unmatched (reason: Signature mismatch)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then perform modification operations to match the PDB file with the EXE file&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\tianlong.xiang\Downloads\chkmatch&amp;gt;ChkMatch.exe -m &amp;quot;D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe&amp;quot; E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb
ChkMatch - version 1.0
Copyright (C) 2004 Oleg Starodumov
http://www.debuginfo.com/


Executable: D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe
Debug info file: E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb

Executable:
TimeDateStamp: c26d9be3
Debug info: 2 ( CodeView )
TimeStamp: f86b0a4f  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 122  RVA: 001cdc44  FileOffset: 001cbe44
CodeView format: RSDS
Signature: {428c9b95-39a3-4a8d-a8e5-7be453684757}  Age: 1
PdbFile: D:\stock_UAT\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\obj\Release\YinTrade.Main.pdb
Debug info: 16 ( Unknown )
TimeStamp: 00000000  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 0  RVA: 00000000  FileOffset: 00000000

Debug information file:
Format: PDB 7.00
Signature: {06fae08e-c0a2-4f3d-9c7c-dfc684445dd1}  Age: 1

Writing to the debug information file...
Result: Success.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;references&#34;&gt;References
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/38147487/forcing-to-load-unmatched-symbols-in-visual-studio-2015-debugger&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;forcing-to-load-unmatched-symbols-in-visual-studio-2015-debugger&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Slow efficiency when processing large string data in Linux backend services</title>
        <link>https://blog.ttf248.life/en/p/linux-backend-slow-string-processing/</link>
        <pubDate>Wed, 13 Nov 2024 19:42:59 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/en/p/linux-backend-slow-string-processing/</guid>
        <description>&lt;p&gt;In past C++ development projects, we used a custom protocol for communication that employed a two-dimensional array structure. Due to inefficient traversal and serialization of this array when handling large amounts of data, the system experienced noticeable lag under high load, prompting feedback from the business department regarding these slowdowns.&lt;/p&gt;
&lt;h2 id=&#34;issue-identification&#34;&gt;Issue identification
&lt;/h2&gt;&lt;p&gt;During troubleshooting, we first performed a performance analysis of the system. We found that CPU usage increased significantly and response times lengthened when processing large amounts of data. Analyzing system logs revealed numerous serialization operations, which were inefficient when handling two-dimensional arrays, leading to decreased system performance.&lt;/p&gt;
&lt;p&gt;The tool&amp;rsquo;s thread analysis revealed that the logging thread spends most of its time string concatenation&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The key takeaway today is that different accumulation methods have vastly different efficiencies. Legacy code used the &lt;code&gt;__INLINE_CODE_0&lt;/code&gt; operator, which frequently creates temporary objects and is very inefficient—the kind of inefficiency you know is bad but don&amp;rsquo;t realize just how bad it is.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;demo-verification&#34;&gt;Demo verification
&lt;/h2&gt;&lt;p&gt;We extracted the business logic based on the project code and created a simple demo to verify the efficiency of string concatenation. We compared the efficiency while compiling and running it in &lt;code&gt;windows&lt;/code&gt; 下的 &lt;code&gt;vs2022&lt;/code&gt; 编译器，&lt;strong&gt;INLINE_CODE_2&lt;/strong&gt; 下的 &lt;strong&gt;INLINE_CODE_3&lt;/strong&gt; 编译器，&lt;strong&gt;INLINE_CODE_4&lt;/strong&gt; mode.&lt;/p&gt;
&lt;h3 id=&#34;key-points&#34;&gt;Key points
&lt;/h3&gt;&lt;p&gt;The project uses method four. Before receiving the test data, readers can first consider which approach is most efficient and which is least efficient. I was still surprised by the results.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Concatenate each field directly into a string&lt;/li&gt;
&lt;li&gt;Using streams (concatenating) to join each field is more efficient, especially when dealing with large amounts of data&lt;/li&gt;
&lt;li&gt;Pre-allocating sufficient memory for strings reduces the overhead of memory reallocation, thereby improving performance&lt;/li&gt;
&lt;li&gt;Creating a new temporary string object for each concatenation degrades performance, especially during large-scale concatenations, as it involves repeated memory allocation and copying&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Based on the results, the project selected the least efficient method&lt;/p&gt;
&lt;p&gt;Furthermore, let&amp;rsquo;s analyze the optimization efficiency of different platforms&amp;rsquo; compilers. Microsoft&amp;rsquo;s compiler falls short in this regard.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Running the code on different machines makes direct comparison of the data meaningless; instead, compare the differences between different concatenation methods&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;windows 平台下的 vs2022 编译器

----------------------------------------
Data Generation Time: 0.054 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.053 seconds.
+ ostringstream Data merging took: 0.054 seconds.
+ Pre-reserved Data merging took: 0.045 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 16.108 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;linux 平台下的 gcc8.5 编译器
----------------------------------------
Data Generation Time: 0.108 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.100 seconds.
+ ostringstream Data merging took: 0.083 seconds.
+ Pre-reserved Data merging took: 0.057 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 29.298 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;complete-code&#34;&gt;Complete code
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;random&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;iomanip&amp;gt;

typedef std::vector&amp;lt;std::string&amp;gt; DataRow;
typedef std::vector&amp;lt;DataRow&amp;gt; DataGroup;

struct ResponsePackage
{
    std::string ErrorInfo;
    DataRow Head;
    std::string ClientId;
    std::string UUID;
    std::string MsgID;
    std::string SessionID;
    std::string ExtraInfo1;
    std::string ExtraInfo2;
    DataGroup DataBody;
};

// Generate specified length of random string
std::string generateRandomString(size_t length)
{
    const char charset[] = &amp;quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&amp;quot;;
    const size_t max_index = sizeof(charset) - 1;
    std::string random_string;
    random_string.reserve(length);

    std::random_device rd;
    std::mt19937 generator(rd());
    std::uniform_int_distribution&amp;lt;&amp;gt; distribution(0, max_index);

    for (size_t i = 0; i &amp;lt; length; ++i)
    {
        random_string += charset[distribution(generator)];
    }

    return random_string;
}

void create_large_string()
{
    // Example request package with 50 fields
    ResponsePackage requestPackage;

    requestPackage.Head = {
        &amp;quot;Field1&amp;quot;, &amp;quot;Field2&amp;quot;, &amp;quot;Field3&amp;quot;, &amp;quot;Field4&amp;quot;, &amp;quot;Field5&amp;quot;,
        &amp;quot;Field6&amp;quot;, &amp;quot;Field7&amp;quot;, &amp;quot;Field8&amp;quot;, &amp;quot;Field9&amp;quot;, &amp;quot;Field10&amp;quot;,
        &amp;quot;Field11&amp;quot;, &amp;quot;Field12&amp;quot;, &amp;quot;Field13&amp;quot;, &amp;quot;Field14&amp;quot;, &amp;quot;Field15&amp;quot;,
        &amp;quot;Field16&amp;quot;, &amp;quot;Field17&amp;quot;, &amp;quot;Field18&amp;quot;, &amp;quot;Field19&amp;quot;, &amp;quot;Field20&amp;quot;,
        &amp;quot;Field21&amp;quot;, &amp;quot;Field22&amp;quot;, &amp;quot;Field23&amp;quot;, &amp;quot;Field24&amp;quot;, &amp;quot;Field25&amp;quot;,
        &amp;quot;Field26&amp;quot;, &amp;quot;Field27&amp;quot;, &amp;quot;Field28&amp;quot;, &amp;quot;Field29&amp;quot;, &amp;quot;Field30&amp;quot;,
        &amp;quot;Field31&amp;quot;, &amp;quot;Field32&amp;quot;, &amp;quot;Field33&amp;quot;, &amp;quot;Field34&amp;quot;, &amp;quot;Field35&amp;quot;,
        &amp;quot;Field36&amp;quot;, &amp;quot;Field37&amp;quot;, &amp;quot;Field38&amp;quot;, &amp;quot;Field39&amp;quot;, &amp;quot;Field40&amp;quot;,
        &amp;quot;Field41&amp;quot;, &amp;quot;Field42&amp;quot;, &amp;quot;Field43&amp;quot;, &amp;quot;Field44&amp;quot;, &amp;quot;Field45&amp;quot;,
        &amp;quot;Field46&amp;quot;, &amp;quot;Field47&amp;quot;, &amp;quot;Field48&amp;quot;, &amp;quot;Field49&amp;quot;, &amp;quot;Field50&amp;quot;
    };

    requestPackage.ClientId = &amp;quot;ClientID&amp;quot;;
    requestPackage.UUID = &amp;quot;UUID&amp;quot;;
    requestPackage.MsgID = &amp;quot;MsgID&amp;quot;;
    requestPackage.SessionID = &amp;quot;SessionID&amp;quot;;
    requestPackage.ExtraInfo1 = &amp;quot;ExtraInfo1&amp;quot;;
    requestPackage.ExtraInfo2 = &amp;quot;ExtraInfo2&amp;quot;;

    // Start timing for data generation
    auto start_gen = std::chrono::high_resolution_clock::now();

    // Generate 10,000 rows of data, each with 50 fields
    for (size_t i = 0; i &amp;lt; 10000; ++i)
    {
        DataRow dataRow(50, &amp;quot;This is a test string&amp;quot;);
        requestPackage.DataBody.push_back(dataRow);
    }

    // End timing for data generation
    auto end_gen = std::chrono::high_resolution_clock::now();
    std::chrono::duration&amp;lt;double&amp;gt; duration_gen = end_gen - start_gen;

    // Display result generation time
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Generation Time: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_gen.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    // Data merging using different methods
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Performance:\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    {
        // Method 1: Using &#39;+=&#39; string concatenation
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (+=) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 2: Using ostringstream
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::ostringstream bodys;
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::ostringstream body;
            body &amp;lt;&amp;lt; &amp;quot;This is a test string&amp;quot;;
            for (auto&amp;amp; item : vec)
            {
                body &amp;lt;&amp;lt; item &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            }
            bodys &amp;lt;&amp;lt; body.str() &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ ostringstream Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 3: Pre-allocated memory
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys;
        bodys.reserve(1000 * 50 * 20); // Pre-allocate enough memory
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            body.reserve(50 * 20); // Pre-allocate memory for each row
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Pre-reserved Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 4: Using &#39;bodys = bodys + body + &amp;quot;\n&amp;quot;&#39;
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body = body + item + &amp;quot; &amp;quot;; // Note the use of &#39;body = body + item&#39;
            }
            bodys = bodys + body + &amp;quot;\n&amp;quot;; // Again, using &#39;bodys = bodys + body&#39;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (bodys = bodys + body + \&amp;quot;\\n\&amp;quot;) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Complete.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;
}

int main()
{
    try
    {
        create_large_string();
    }
    catch (const std::exception&amp;amp; e)
    {
        std::cerr &amp;lt;&amp;lt; &amp;quot;Caught exception: &amp;quot; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\nProgram finished.\n&amp;quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Installing Win11 Logitech G431 Headset Drivers</title>
        <link>https://blog.ttf248.life/en/p/win11-logitech-g431-headphone-driver-installation/</link>
        <pubDate>Wed, 05 Jun 2024 07:20:17 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/en/p/win11-logitech-g431-headphone-driver-installation/</guid>
        <description>&lt;p&gt;Picking up where we left off, I came back to find an update for Ghub. It was a little exciting that the customer service issue of not being able to load properly seemed to be resolved. However, after a lot of troubleshooting – reinstalling and uninstalling – it still doesn&amp;rsquo;t work correctly.&lt;/p&gt;
&lt;h2 id=&#34;background&#34;&gt;Background
&lt;/h2&gt;&lt;p&gt;I contacted customer service for a solution, but was told an engineer could provide remote assistance. Unfortunately, their working hours are the same as mine, so I had to give up. Now I&amp;rsquo;m reviewing previous troubleshooting records and preparing to manually install the driver.&lt;/p&gt;
&lt;h2 id=&#34;get-the-driver-installation-package&#34;&gt;Get the driver installation package
&lt;/h2&gt;&lt;p&gt;How can I obtain the driver files since Logitech doesn&amp;rsquo;t provide standalone driver installation packages?&lt;/p&gt;
&lt;p&gt;Using the system image installation package left over from the previous system reinstall, we can reinstall the system in a local virtual machine. In a clean environment, deploy Ghub separately, integrate the headset device into the virtual machine, locate the driver path, and copy it out.&lt;/p&gt;
&lt;p&gt;Related paths:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C:\ProgramData\LGHUB&lt;/li&gt;
&lt;li&gt;C:\Windows\System32\DriverStore\FileRepository\logi_audio.inf_amd64_010b035044e24be4&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;device-manager&#34;&gt;Device Manager
&lt;/h2&gt;&lt;p&gt;The key is how to find the second path. Let&amp;rsquo;s briefly review how to manually manage driver files in Windows 11. This area covers two system-provided drivers and one from Logitech.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Please provide the Chinese text you want me to translate. I am ready when you are.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;The second driver in the image is from Logitech. We analyze the current device drivers, searching all driver paths within the virtual machine. First, you need to find files starting with &amp;ldquo;logi,&amp;rdquo; then compare them. You&amp;rsquo;ll be able to locate the driver file; copy the entire folder and you’ll have the installation package.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Please provide the Chinese text you want me to translate. I am ready when you are.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;install-driver&#34;&gt;Install driver
&lt;/h2&gt;&lt;p&gt;While still in Device Manager, click &amp;ldquo;Update Driver,&amp;rdquo; then &amp;ldquo;Browse my computer for drivers.&amp;rdquo; This will take you to the following screen:&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Please provide the Chinese text you want me to translate. I am ready when you are.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;When you open it, you&amp;rsquo;ll only see one drive – a standard USB drive. Choose &amp;ldquo;Install from disk&amp;rdquo; and select the folder we copied earlier. After installation, a Logitech-specific driver will appear in the dropdown list; switch the device driver to this newly installed one.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Please provide the Chinese text you want me to translate. I am ready when you are.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;anatomy-equipment-drivers&#34;&gt;Anatomy equipment drivers
&lt;/h2&gt;&lt;p&gt;The drivers for this device are provided by the system. You only need to check if there&amp;rsquo;s an exclamation mark next to the driver; if so, enter the driver selection interface and switch to a different type of driver before switching back to restore normal functionality.&lt;/p&gt;
&lt;h2 id=&#34;completed&#34;&gt;Completed
&lt;/h2&gt;&lt;p&gt;The headphone microphone volume is back to normal, and the familiar ear monitoring function has returned&lt;/p&gt;
&lt;p&gt;Please provide the Chinese text you want me to translate. I am ready when you are.&lt;/p&gt;</description>
        </item>
        <item>
        <title>Why is the speed only 100 Mbps despite having newly installed gigabit fiber?</title>
        <link>https://blog.ttf248.life/en/p/new-gigabit-fiber-slow-speed/</link>
        <pubDate>Mon, 18 Mar 2024 00:29:02 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/en/p/new-gigabit-fiber-slow-speed/</guid>
        <description>&lt;p&gt;Want lightning-fast home internet? It all comes down to choosing the right network cable, configuring your ONT and router, and paying attention to those subtle details. This blog will guide you through creating a gigabit network with Cat6 cables and how to ensure optimal speed through simple device checks and configurations. Let&amp;rsquo;s explore together and boost your home internet!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Please provide the Chinese text you want me to translate. I am ready when you are.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;chapter-1-in-depth-analysis-of-network-transmission-media&#34;&gt;Chapter 1: In-depth Analysis of Network Transmission Media
&lt;/h2&gt;&lt;p&gt;When discussing achieving gigabit network access, the carrier—network cables—plays a crucial role in transmitting high-speed information. The following provides a detailed explanation of Cat 5, Cat 6, and Cat 7 cables.&lt;/p&gt;
&lt;h3 id=&#34;the-provided-text-is-empty-please-provide-the-chinese-text-you-want-me-to-translate&#34;&gt;The provided text is empty. Please provide the Chinese text you want me to translate.
&lt;/h3&gt;&lt;p&gt;Category 5 Ethernet cable, also known as CAT5, is an early type of twisted-pair cabling that uses a precise spiral structure to reduce crosstalk. It&amp;rsquo;s primarily suitable for 10/100Mbps Fast Ethernet with a maximum transmission frequency of approximately 100MHz. While widely used in the past, it cannot meet current demands for gigabit and higher speeds due to physical limitations.&lt;/p&gt;
&lt;h3 id=&#34;heading&#34;&gt;
&lt;/h3&gt;&lt;p&gt;With technological advancements, Cat6 cabling emerged. Compared to Cat5 cabling, Cat6 utilizes stricter manufacturing standards and more advanced structural designs, significantly improving interference resistance and transmission efficiency. It supports transfer rates up to 1Gbps and can achieve a distance of 100 meters under ideal conditions – perfectly meeting the access requirements for Gigabit networks.&lt;/p&gt;
&lt;h3 id=&#34;3&#34;&gt;3
&lt;/h3&gt;&lt;p&gt;Category 7 cabling represents the pinnacle of current twisted-pair technology. It offers a significant increase in transmission rates, theoretically supporting up to 10Gbps, and incorporates a complete shielding system—shielding for each pair of wires as well as overall outer shielding—to greatly reduce external electromagnetic interference and near-end crosstalk, ensuring data transmission stability and accuracy. However, Category 7 cabling is primarily intended for future 10 Gigabit Ethernet or specific high-demand applications.&lt;/p&gt;
&lt;p&gt;When building a Gigabit home network, using Cat6 cabling is the most economical and efficient choice to fully leverage the potential of Gigabit fiber. Ensuring all connection cables are of qualified quality and strictly following standard wiring practices are also crucial for network performance.&lt;/p&gt;
&lt;h2 id=&#34;chapter-2-delving-into-network-core-devices--the-impact-of-optical-network-terminal-ont-and-router-lan-port-bandwidth&#34;&gt;Chapter 2: Delving into Network Core Devices – The Impact of Optical Network Terminal (ONT) and Router LAN Port Bandwidth
&lt;/h2&gt;&lt;h3 id=&#34;the-importance-of-the-optical-network-terminal-ont-and-its-lan-port-bandwidth&#34;&gt;The importance of the optical network terminal (ONT) and its LAN port bandwidth
&lt;/h3&gt;&lt;p&gt;The Optical Network Terminal (ONT), also known as an optical modem, is the core device for home broadband access. Its function is to convert the light signal from fiber optic cables into digital signals for use by home network devices. For gigabit fiber users, it&amp;rsquo;s crucial that the ONT supports gigabit transmission. If the ONT’s WAN port only supports 100 Mbps, even with a higher-speed fiber connection, the speed will be limited to 100 Mbps due to this bottleneck. Similarly, the ONT’s LAN port also needs to have gigabit output capabilities; otherwise, routers or other connected devices won&amp;rsquo;t achieve true gigabit speeds.&lt;/p&gt;
&lt;h3 id=&#34;the-role-of-bandwidth-for-router-lan-ports&#34;&gt;The role of bandwidth for router LAN ports
&lt;/h3&gt;&lt;p&gt;The router&amp;rsquo;s LAN port distributes received data to terminal devices. When the LAN port is limited to Gigabit, even with well-configured devices, network communication will be restricted to a 100Mbps speed. Therefore, when building a Gigabit home network, ensure the router’s WAN port can receive Gigabit data and that its LAN port also offers Gigabit output capabilities so all smart devices can enjoy a smooth experience thanks to high-speed networking.&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s important to note that some older or lower-end routers may have a LAN port auto-negotiation mechanism. This means they might operate in 100Mbps mode instead of Gigabit, even if the router itself supports it, due to factors like cabling or device compatibility. Therefore, correctly configuring router parameters, enabling forced Gigabit mode, and using a Gigabit switch or direct connection are crucial steps for achieving a full Gigabit network.&lt;/p&gt;
&lt;p&gt;After upgrading to fiber optic internet, be sure to check and replace your optical network terminal (ONT) and router with gigabit-compatible devices to ensure all interfaces meet the gigabit standard&lt;/p&gt;
&lt;h2 id=&#34;chapter-3-the-hidden-mystery--how-a-broken-sub-thread-impacts-gigabit-network-speed&#34;&gt;Chapter 3: The Hidden Mystery – How a Broken Sub-Thread Impacts Gigabit Network Speed
&lt;/h2&gt;&lt;h3 id=&#34;subnet-cable-failure-and-network-performance-degradation&#34;&gt;Subnet cable failure and network performance degradation
&lt;/h3&gt;&lt;p&gt;The network remained connected throughout the speed test, with no apparent disconnections. As this is a newly installed broadband connection, the utility box is cluttered and adjustments to the optical network terminal&amp;rsquo;s cabling and power outlet placement occasionally result in speeds reaching gigabit levels.&lt;/p&gt;
&lt;p&gt;Based on previous data, we analyzed and eliminated potential issues such as network cable model and optical modem LAN port speed, ultimately discovering that a broken brown internal wire within the network cable was the culprit&lt;/p&gt;
&lt;p&gt;The cable broke because the installer pulled on it too hard when installing the crystal head, partially severing a wire. Subsequent movement while adjusting the optical network terminal&amp;rsquo;s location eventually caused it to break completely.&lt;/p&gt;
&lt;h3 id=&#34;functionality-of-eight-wires-in-six-categories-of-network-cables&#34;&gt;Functionality of Eight Wires in Six Categories of Network Cables
&lt;/h3&gt;&lt;p&gt;Six-category network cables follow the TIA/EIA-568-B standard, consisting of eight twisted pairs with the following color coding:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;White Orange / Orange&lt;/li&gt;
&lt;li&gt;White-green / Green&lt;/li&gt;
&lt;li&gt;Blue / Light Blue&lt;/li&gt;
&lt;li&gt;Brown&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Under Gigabit Ethernet (1000BASE-T) standards, these eight wires operate with four pairs working simultaneously, each with a specific function&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;These wires (1 &amp;amp; 2), labeled white-orange and orange, are used for data transmission (Tx+/–)&lt;/li&gt;
&lt;li&gt;These wires (3 &amp;amp; 6) – white/green and green – are used for data reception (Rx+/–)&lt;/li&gt;
&lt;li&gt;These pairs of wires—white-blue and blue (4&amp;amp;5) and white-brown and brown (7&amp;amp;8)—are not typically used in Gigabit Ethernet, but may be enabled in certain advanced applications like partial PoE power or future technology extensions. In traditional 100Mbps networks, only the four wires 1, 2, 3, and 6 are required.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;the-impact-of-broken-chains-on-network-speed&#34;&gt;The impact of broken chains on network speed
&lt;/h3&gt;&lt;p&gt;In the described scenario, if a brown sub-line (brown or brown-white) is broken, it can theoretically reduce speed in a Gigabit network because Gigabit networks require simultaneous bidirectional transmission on all four pairs of wires to achieve full speed. However, due to the auto-negotiation feature often found in home network devices, when a cable issue is detected, they will revert to a lower, functional rate – typically 100Mbps. This explains why the connection remains active and operates at 100Mbps even with one sub-line broken.&lt;/p&gt;
&lt;p&gt;In short, while a single broken brown fiber strand doesn&amp;rsquo;t affect basic gigabit network operation, it can be a key factor limiting speed in a terabit environment. Only through thorough diagnosis and repair can the full potential of the terabit fiber be realized. This serves as a reminder that we shouldn’t overlook any potential network infrastructure issues, even seemingly minor faults that don&amp;rsquo;t impact basic connectivity, as they may become hidden obstacles to high-speed network performance.&lt;/p&gt;</description>
        </item>
        <item>
        <title>UI Thread Issues and Solutions in WPF</title>
        <link>https://blog.ttf248.life/en/p/wpf-ui-thread-and-freezing-issues-solutions/</link>
        <pubDate>Tue, 12 Mar 2024 07:12:21 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/en/p/wpf-ui-thread-and-freezing-issues-solutions/</guid>
        <description>&lt;p&gt;Correctly handling the user interface (UI) thread is crucial for ensuring application smoothness and responsiveness, especially when developing desktop applications and building rich client applications using the Windows Presentation Foundation (WPF) framework. The UI thread, also known as the main thread, is the core thread responsible for processing window and control events, layout calculations, and rendering the interface. All interactions with UI elements should be performed on the UI thread; this is a fundamental principle followed by WPF and most other GUI frameworks.&lt;/p&gt;
&lt;h2 id=&#34;what-is-the-ui-thread&#34;&gt;What is the UI thread?
&lt;/h2&gt;&lt;p&gt;The UI thread is created and initialized by the operating system when a WPF application starts, and it&amp;rsquo;s the only thread that can directly access and modify the state of UI components. All user interactions—such as button clicks, text box input, and window resizing—are handled within this thread’s context. Furthermore, WPF’s dependency property system, data binding mechanism, and layout logic all execute synchronously on the UI thread.&lt;/p&gt;
&lt;h2 id=&#34;lag-and-its-causes&#34;&gt;Lag and its causes
&lt;/h2&gt;&lt;p&gt;When the UI thread is occupied or blocked for an extended period—for example, due to lengthy calculations, large data loads, database queries, or other I/O-intensive tasks—it can fail to respond promptly to user interactions, resulting in a frozen interface (freeze), commonly known as &amp;ldquo;lag.&amp;rdquo; This causes noticeable application latency and sluggishness; severe cases may trigger an “Application Not Responding” (ANR) warning&lt;/p&gt;
&lt;h2 id=&#34;two-basic-rules-of-the-ui-thread&#34;&gt;Two basic rules of the UI thread
&lt;/h2&gt;&lt;p&gt;To avoid these situations, WPF developers should follow two key rules:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Any operation that may cause the UI thread to hang should be moved to a background thread as much as possible to ensure the UI thread can promptly respond to user input and render screen changes&lt;/li&gt;
&lt;li&gt;Due to WPF&amp;rsquo;s security mechanism, only the UI thread is authorized to modify UI elements. Attempting to directly change the UI state from another thread will result in an exception. Therefore, even after background threads complete calculations or data preparation, results must be displayed on the UI through appropriate cross-thread communication mechanisms.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;solution-asynchronous-programming-and-thread-safe-updates&#34;&gt;Solution: Asynchronous Programming and Thread-Safe Updates
&lt;/h2&gt;&lt;p&gt;WPF offers various asynchronous programming models and tools to help developers achieve this while maintaining a smooth UI&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The WPF Dispatcher class allows you to schedule work items for execution in the UI thread&amp;rsquo;s task queue. You can use the &lt;code&gt;Invoke&lt;/code&gt; method to safely update the UI from background threads.&lt;/li&gt;
&lt;li&gt;By leveraging C#&amp;rsquo;s asynchronous features, you can write asynchronous methods and use the &lt;code&gt;__INLINE_CODE_0__&lt;/code&gt; keyword to wait for background tasks to complete, automatically returning to the UI thread to execute subsequent UI update code upon completion&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;case-study&#34;&gt;Case study
&lt;/h2&gt;&lt;h3 id=&#34;update-ui-using-the-__inline_code_0__-method&#34;&gt;Update UI using the &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; method
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private void Button_Click(object sender, RoutedEventArgs e)
{
    // 假设这是一个耗时操作
    Task.Run(() =&amp;gt;
    {
        var result = LongRunningOperation(); // 这里是模拟一个耗时计算的方法
        
        // 当耗时操作完成后，在UI线程上更新UI
        Application.Current.Dispatcher.Invoke(() =&amp;gt;
        {
            LabelStatus.Text = $&amp;quot;计算结果: {result}&amp;quot;;
        });
    });
}

private string LongRunningOperation()
{
    // 模拟耗时操作
    Thread.Sleep(5000);
    return &amp;quot;已完成&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;use-__inline_code_0__bold_2taskrun&#34;&gt;Use __INLINE_CODE_0__BOLD_2&lt;code&gt;Task.Run&lt;/code&gt;
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private async void Button_ClickAsync(object sender, RoutedEventArgs e)
{
    Button button = sender as Button;
    button.IsEnabled = false; // 防止用户重复点击

    try
    {
        // 开启后台任务
        var result = await Task.Run(() =&amp;gt; LongRunningOperation());

        // 在后台任务完成后，自动切换回UI线程更新UI
        LabelStatus.Text = $&amp;quot;计算结果: {result}&amp;quot;;
    }
    catch (Exception ex)
    {
        MessageBox.Show($&amp;quot;发生错误: {ex.Message}&amp;quot;);
    }
    finally
    {
        button.IsEnabled = true; // 重新启用按钮
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Upgrading GCC version leads to program crashes: Hidden dangers of non-compliant code</title>
        <link>https://blog.ttf248.life/en/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</link>
        <pubDate>Sun, 10 Mar 2024 23:19:06 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/en/p/upgrade-gcc-version-causes-program-crash-code-irregularities/</guid>
        <description>&lt;p&gt;The program compiled and ran normally in the CentOS 7 environment, but crashed when switched to CentOS 8 and compiled with a newer version of GCC. Notably, this issue only occurred under &lt;strong&gt;Release 模式&lt;/strong&gt;, while &lt;strong&gt;Debug 模式&lt;/strong&gt; was unaffected. This was the first time we encountered such a situation, and after three days of troubleshooting, we finally found the root cause.&lt;/p&gt;
&lt;h3 id=&#34;issue-identification&#34;&gt;Issue identification
&lt;/h3&gt;&lt;p&gt;The root cause of the problem lies in &lt;strong&gt;函数缺少返回值&lt;/strong&gt;. The increased optimization performed by newer versions of GCC in Release mode has introduced unknown logic into functions without explicit return values, leading to crashes. Our conclusion is that &lt;strong&gt;编译器的警告不容忽视，尤其是在老项目中，部分警告可能被无视，但也应当避免屏蔽所有警告&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;environmental-description&#34;&gt;Environmental Description
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Please provide the Chinese text you want me to translate. I am ready when you are!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39)
Copyright © 2015 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Please provide the Chinese text you want me to translate. I am ready when you are!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 8.5.0 20210514 (Red Hat 8.5.0-21)
Copyright (C) 2018 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;crash-phenomenon&#34;&gt;Crash phenomenon
&lt;/h3&gt;&lt;p&gt;When analyzing the program crash stack, we observed the following stack information:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[New LWP 1385902]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib64/libthread_db.so.1&amp;quot;.
Core was generated by `./pstack_main`.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007ffe894b4420 in ?? ()
(gdb) bt
#0  0x00007ffe894b4420 in ?? ()
#1  0x00000000004008e9 in main ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This stack trace isn&amp;rsquo;t intuitive; the crash information shows as a &lt;code&gt;__INLINE_CODE_0&lt;/code&gt;, making debugging more difficult&lt;/p&gt;
&lt;h3 id=&#34;code-example&#34;&gt;Code example
&lt;/h3&gt;&lt;p&gt;To better understand the issue, here&amp;rsquo;s a minimal code example to reproduce the crash:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int test() {
    std::cout &amp;lt;&amp;lt; &amp;quot;1&amp;quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    test();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When a ``test()&lt;code&gt; 函数显然没有显式返回一个值，而它的返回类型是 __INLINE_CODE_1__。根据 C++ 规范，当一个函数声明为 __INLINE_CODE_2__&lt;/code&gt; type is used, it must have a return value; otherwise, undefined behavior may occur&lt;/p&gt;
&lt;h3 id=&#34;compilation-warning&#34;&gt;Compilation warning
&lt;/h3&gt;&lt;p&gt;In our project, CMake scripts suppress many compile-time warnings, including the following message:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/root/pstack/main.cpp: In function ‘int test()’:
/root/pstack/main.cpp:7:1: warning: no return statement in function returning non-void [-Wreturn-type]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This warning indicates that the &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; function has no return value, which is the root of the problem. High-version GCC (such as 8.5.0) may perform unstable optimizations on this undefined behavior during code optimization, leading to program crashes.&lt;/p&gt;
&lt;h3 id=&#34;assembly-code-differences&#34;&gt;Assembly code differences
&lt;/h3&gt;&lt;p&gt;To explain the differences in GCC compiler optimization behavior, we compared assembly code generated by different versions of GCC&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Please provide the Chinese text you want me to translate. I am ready when you are!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The assembly code is lengthy and includes excessive optimizations for issues like the missing return value in functions such as __INLINE_CODE_0__BOLD_2&lt;code&gt;test()&lt;/code&gt;, which may have prevented a crash&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Please provide the Chinese text you want me to translate. I am ready when you are!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The new version of GCC includes more optimizations that reduce code size. However, these optimizations can lead to undefined behavior when executing functions lacking return values, potentially causing program crashes.&lt;/p&gt;
&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion
&lt;/h3&gt;&lt;p&gt;This troubleshooting has highlighted the importance of carefully addressing warnings in C++, particularly when functions are declared inline. It&amp;rsquo;s crucial to selectively handle these warnings, especially those related to function return values and type matching, rather than suppressing them all.&lt;/p&gt;
&lt;p&gt;The issue was resolved by adding a return value to the &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt; function, and the program returned to normal operation&lt;/p&gt;</description>
        </item>
        <item>
        <title>VMware virtual machine CPU resource usage anomaly</title>
        <link>https://blog.ttf248.life/en/p/vmware-virtual-machine-cpu-resource-usage-anomaly/</link>
        <pubDate>Sun, 10 Mar 2024 22:14:59 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/en/p/vmware-virtual-machine-cpu-resource-usage-anomaly/</guid>
        <description>&lt;p&gt;The local machine runs a Windows-based business system with approximately 5% CPU usage. A Linux-based business system deployed in VMware&amp;rsquo;s CentOS8 experiences abnormal resource utilization.&lt;/p&gt;
&lt;h2 id=&#34;problem-description&#34;&gt;Problem description
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Host machine: Windows 10 Enterprise Edition&lt;/li&gt;
&lt;li&gt;vmware：17.5&lt;/li&gt;
&lt;li&gt;Virtual machine: CentOS 8&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Virtual machine resource allocation is &lt;strong&gt;INLINE_CODE_0&lt;/strong&gt;, enabling the business system. The business system is deployed in a virtual machine Linux environment. Observing system resource usage within the VM using the top command shows low CPU utilization. However, the outer Windows system&amp;rsquo;s Task Manager indicates high CPU usage; investigating processes reveals that the VMware process consumes significant CPU resources.&lt;/p&gt;
&lt;p&gt;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+
|         Windows           |
|                           |
|   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+  |
|   |      VMware        |  |
|   |      Program       |  |
|   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+  |
|                           |
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+&lt;/p&gt;
&lt;h2 id=&#34;key-points&#34;&gt;Key points
&lt;/h2&gt;&lt;p&gt;Troubleshooting this issue proved difficult, as the root cause wasn&amp;rsquo;t in the business system itself but rather a problem with the virtual machine. This article will first explain relevant concepts, then provide a solution, detailing how to shift focus from typical business code to system load, identify anomalies in load data, pinpoint soft interrupts, and ultimately determine what factors impact VMware soft interrupt efficiency.&lt;/p&gt;
&lt;h3 id=&#34;hyper-v&#34;&gt;hyper-v
&lt;/h3&gt;&lt;p&gt;Virtualization technology for Windows has undergone a significant change. When Microsoft first released WSL, enabling the Hyper-V service would prevent the simultaneous use of VMware virtual machines. Compatibility between VMware and Hyper-V services wasn&amp;rsquo;t achieved until later versions.&lt;/p&gt;
&lt;h3 id=&#34;system-load&#34;&gt;System load
&lt;/h3&gt;&lt;p&gt;In a Linux system, &amp;ldquo;load&amp;rdquo; refers to the number of processes running or waiting to execute. It&amp;rsquo;s typically represented by three numbers indicating the average number of processes in the run queue over 1, 5, and 15-minute intervals. These figures can be viewed using commands like &amp;ldquo;uptime&amp;rdquo; or &amp;ldquo;top.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Specifically, these three numbers represent:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The average number of processes in the system&amp;rsquo;s run queue over the past minute&lt;/li&gt;
&lt;li&gt;Average number of processes in the running queue over the past 5 minutes&lt;/li&gt;
&lt;li&gt;Average number of processes in the running queue over the past 15 minutes&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Load refers to the number of processes waiting to run in a system. If this number exceeds the logical CPU count, it indicates high system load, meaning many processes are competing for processor resources. This can lead to sluggishness or unresponsiveness, depending on the severity of the load and the system&amp;rsquo;s configuration and performance.&lt;/p&gt;
&lt;p&gt;Ideally, the load should remain within the logical CPU count of the system to optimize performance. If the load consistently exceeds the CPU count, further analysis of processes is needed to identify the cause and take appropriate measures to adjust resource allocation or optimize process execution.&lt;/p&gt;
&lt;h3 id=&#34;analyzing-load-with-mpstat&#34;&gt;Analyzing load with mpstat
&lt;/h3&gt;&lt;p&gt;Steps for conducting a load analysis:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;安装 sysstat&lt;/strong&gt;:
If it is not installed on your system, you can install it using a package management tool suitable for your system&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;运行 mpstat&lt;/strong&gt;:
Indicates resource consumption&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;01:32:33 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
01:32:35 PM  all    0.00    0.00    0.26    0.00    3.73    0.26    0.00    0.00    0.00   95.76
01:32:35 PM    0    0.00    0.00    0.51    0.00    3.57    0.00    0.00    0.00    0.00   95.92
01:32:35 PM    1    0.00    0.00    0.00    0.00    3.59    0.51    0.00    0.00    0.00   95.90
01:32:35 PM    2    0.00    0.00    0.00    0.00    4.15    0.00    0.00    0.00    0.00   95.85
01:32:35 PM    3    0.00    0.00    0.52    0.00    3.61    0.52    0.00    0.00    0.00   95.36
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分析输出&lt;/strong&gt;:
The output includes the utilization rate of each CPU and the system&amp;rsquo;s average load. Monitoring the average load and individual CPU utilization can help you understand system load. High loads warrant further analysis to identify contributing processes and potential performance bottlenecks.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;结合其他工具&lt;/strong&gt;:
In addition to tools like these, we can comprehensively analyze system performance. Combining the outputs of various tools allows for a more thorough understanding of system load and helps identify the root causes of performance issues.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;interruption&#34;&gt;Interruption
&lt;/h3&gt;&lt;p&gt;I won&amp;rsquo;t elaborate on the details here
Recommended: [LINK_0]&lt;/p&gt;
&lt;p&gt;Frequent triggering of soft interrupts will be reflected in system load&lt;/p&gt;
&lt;h2 id=&#34;troubleshooting&#34;&gt;troubleshooting
&lt;/h2&gt;&lt;p&gt;Given that analyzing the issue solely from a CPU perspective is insufficient, should we suspect a system anomaly? It could be due to excessive load on the Linux operating system, causing VMware to consume an excessive amount of CPU resources. The utilization percentage should be approximately 5%.&lt;/p&gt;
&lt;p&gt;His CentOS 7 deployment on VMware in the team&amp;rsquo;s development environment shows normal resource usage. However, in the Shanghai development environment, although also using VMware, we cannot directly observe the host CPU resources. This presents multiple variables: the VMware virtual machine, the Linux operating system, and the GCC version.&lt;/p&gt;
&lt;p&gt;Shifting focus to the testing environment, Shenzhen&amp;rsquo;s testing environment is deployed on physical machines running a low-version GCC compilation service and operating on CentOS 8. Interestingly, in the Shenzhen environment, &lt;code&gt;irq&lt;/code&gt; usage is normal.&lt;/p&gt;
&lt;p&gt;To investigate issues introduced by newer GCC versions, we deployed programs compiled with a higher version of GCC to the Shenzhen environment for testing, and the results were all normal&lt;/p&gt;
&lt;p&gt;The issue appears to be becoming clearer; we&amp;rsquo;re starting to suspect a problem with the operating system. After all, CentOS 8 is no longer officially supported. However, even after redeploying clean installations of both CentOS 7 and CentOS 8, the problem persists.&lt;/p&gt;
&lt;p&gt;At this point, we began to suspect the sole uncertainty: VMware virtualization software. Then it occurred to us – Hyper-V technology. Could Hyper-V have been previously enabled but not fully shut down, causing this issue? After all, soft interrupts are implemented through virtualization software. Are there bugs in different virtualization technologies? These questions warrant further consideration and investigation.&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion
&lt;/h2&gt;&lt;p&gt;According to Microsoft&amp;rsquo;s official documentation, we completely shut down the local Hyper-V service and found that VMware then functioned normally on the host. This resolved the issue. As mentioned earlier, this experience was complex and arduous, requiring comprehensive analysis and judgment. It also marked our first time troubleshooting a problem and identifying it at the virtual machine level.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Disable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V-Hypervisor
bcdedit /set hypervisorlaunchtype off
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/application-management/virtualization-apps-not-work-with-hyper-v&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/application-management/virtualization-apps-not-work-with-hyper-v&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Traps in C&#43;&#43; Programming: Detailed Explanation of Program Crashes Due to Misusing `std::map`</title>
        <link>https://blog.ttf248.life/en/p/cpp-programming-traps-std-map-crash-details/</link>
        <pubDate>Sun, 10 Mar 2024 22:03:06 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/en/p/cpp-programming-traps-std-map-crash-details/</guid>
        <description>&lt;p&gt;This article aims to reveal how improper use of C++ containers can lead to program crashes. Attempting to access a non-existent key using the bracket operator automatically adds an empty element. We will analyze this misunderstanding and demonstrate its potential risks with example code.&lt;/p&gt;
&lt;p&gt;Storing simple values is fine, but problems arise when storing pointers. Since a pointer is an address, if it&amp;rsquo;s not initialized, the address is undefined, which can lead to program crashes.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;main-body&#34;&gt;Main body
&lt;/h2&gt;&lt;p&gt;In the C++ standard library, &lt;code&gt;_ITERATOR_categories&lt;/code&gt; inserts a new key-value pair, and the default constructor will be used to initialize the value type corresponding to that key&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int main() {
    std::map&amp;lt;std::string, int&amp;gt; myMap;
    
    // 错误的用法：假设这里试图访问一个不存在的键并认为会得到0
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for &#39;nonexistent_key&#39;: &amp;quot; &amp;lt;&amp;lt; myMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;

    // 实际上，上述行代码创建了一个新的键值对，其中值被默认初始化为int的默认值（通常是0）
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While this code doesn&amp;rsquo;t directly cause the program to crash, such implicit insertion behavior can potentially lead to unexpected side effects in certain situations, like resource leaks or state changes that don&amp;rsquo;t meet expectations. Worse still, concurrent access to uninitialized memory regions in a multithreaded environment could even trigger a program crash.&lt;/p&gt;
&lt;p&gt;To prevent such issues, it is recommended to explicitly insert elements using ____&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::map&amp;lt;std::string, int&amp;gt; safeMap;
if (safeMap.count(&amp;quot;nonexistent_key&amp;quot;) == 0) {
    std::cout &amp;lt;&amp;lt; &amp;quot;Key does not exist.&amp;quot; &amp;lt;&amp;lt; std::endl;
} else {
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for existing key: &amp;quot; &amp;lt;&amp;lt; safeMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;
}

// 或者明确插入一个键值对，指定初始值
safeMap.insert({ &amp;quot;new_key&amp;quot;, 0 });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the objects stored in a &lt;code&gt;map&lt;/code&gt; container are of pointer type, the automatic insertion behavior will save an uninitialized pointer, and any operation on this pointer will lead to program crashes&lt;/p&gt;</description>
        </item>
        <item>
        <title>Troubleshooting process hangs using pstack</title>
        <link>https://blog.ttf248.life/en/p/pstack-troubleshooting-process-hang/</link>
        <pubDate>Sat, 24 Feb 2024 23:55:59 +0800</pubDate>
        
        <guid>https://blog.ttf248.life/en/p/pstack-troubleshooting-process-hang/</guid>
        <description>&lt;p&gt;In software development and operations, process freezes are frequently encountered, leading to system performance degradation or service unavailability. This article introduces the use of the &lt;code&gt;pstack&lt;/code&gt; tool to troubleshoot frozen processes by analyzing stack information to identify and resolve root causes.&lt;/p&gt;
&lt;p&gt;The risk control system&amp;rsquo;s sub-service experienced a freeze, rendering the risk control service unavailable. Due to a lack of service availability monitoring, the frozen process was not detected promptly, leading to system unavailability.&lt;/p&gt;
&lt;h2 id=&#34;main-body&#34;&gt;Main body
&lt;/h2&gt;&lt;p&gt;A hung process is a state where the process stops responding but does not exit. This can be caused by various factors, such as deadlocks, resource exhaustion, or exceptions. To resolve these issues, we can use the pstack tool to analyze the process&amp;rsquo;s stack information and identify the root cause.&lt;/p&gt;
&lt;h2 id=&#34;steps&#34;&gt;Steps
&lt;/h2&gt;&lt;p&gt;pstack is a commonly used tool, typically provided with gdb (the GNU debugger). You can install it using the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt-get install gdb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To obtain the process ID: First, we need to get the process ID (PID) of the frozen process. You can use the &lt;code&gt;ps&lt;/code&gt; command to list all processes and find the PID you want to troubleshoot.
Use the pstack tool to analyze process stacks. Once you have obtained the process ID, you can use pstack to retrieve stack information for that process. Run the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pstack &amp;lt;PID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will output the process&amp;rsquo;s stack information, displaying the current sequence of function calls. Analyzing this information can reveal where the process is stalled and help locate the issue.&lt;/p&gt;
&lt;p&gt;Analyzing stack information can help identify the cause of process freezes. This may reveal deadlocks, infinite loops, or other anomalies. Take appropriate measures based on the specific situation, such as releasing locks or fixing code logic.&lt;/p&gt;
&lt;h2 id=&#34;case-study&#34;&gt;Case study
&lt;/h2&gt;&lt;p&gt;A simple demo where, after the main function starts, a new sub-thread is created. The actual execution function enters an infinite loop, causing the program to fail to terminate normally and enter a frozen state.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cmake_minimum_required(VERSION 3.0.0)
project(pstack_main VERSION 0.1.0 LANGUAGES C CXX)

include(CTest)
enable_testing()

# 查找线程库
find_package(Threads REQUIRED)

add_executable(pstack_main main.cpp)

# 链接线程库
target_link_libraries(pstack_main PRIVATE Threads::Threads)

set(CPACK_PROJECT_NAME ${PROJECT_NAME})
set(CPACK_PROJECT_VERSION ${PROJECT_VERSION})
include(CPack)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;
#include &amp;lt;chrono&amp;gt;

void infiniteLoop() {
    while (true) {
        // 主线程进入死循环
    }
}

int main() {
    std::thread thread(infiniteLoop); // 创建一个线程，执行死循环函数
    thread.join(); // 等待线程结束
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Starting program, pstack result:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Thread 2 (Thread 0x7eff3619b700 (LWP 1315017)):
#0  infiniteLoop () at /root/pstack/main.cpp:6
#1  0x0000000000402ca9 in std::__invoke_impl&amp;lt;void, void (*)()&amp;gt; (__f=@0x2260eb8: 0x4029a6 &amp;lt;infiniteLoop()&amp;gt;) at /usr/include/c++/8/bits/invoke.h:60
#2  0x0000000000402b02 in std::__invoke&amp;lt;void (*)()&amp;gt; (__fn=@0x2260eb8: 0x4029a6 &amp;lt;infiniteLoop()&amp;gt;) at /usr/include/c++/8/bits/invoke.h:95
#3  0x0000000000403150 in std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt;::_M_invoke&amp;lt;0ul&amp;gt; (this=0x2260eb8) at /usr/include/c++/8/thread:244
#4  0x0000000000403126 in std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt;::operator() (this=0x2260eb8) at /usr/include/c++/8/thread:253
#5  0x000000000040310a in std::thread::_State_impl&amp;lt;std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)()&amp;gt; &amp;gt; &amp;gt;::_M_run (this=0x2260eb0) at /usr/include/c++/8/thread:196
#6  0x00007eff36bceb23 in execute_native_thread_routine () from /lib64/libstdc++.so.6
#7  0x00007eff36ea91ca in start_thread () from /lib64/libpthread.so.0
#8  0x00007eff361d58d3 in clone () from /lib64/libc.so.6
Thread 1 (Thread 0x7eff372e1740 (LWP 1315016)):
#0  0x00007eff36eaa6cd in __pthread_timedjoin_ex () from /lib64/libpthread.so.0
#1  0x00007eff36bceda7 in std::thread::join() () from /lib64/libstdc++.so.6
#2  0x00000000004029d2 in main () at /root/pstack/main.cpp:13
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The process froze because of a deadlock loop. The main thread entered a deadlock loop, preventing the child threads from exiting, which resulted in the process freeze.&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
