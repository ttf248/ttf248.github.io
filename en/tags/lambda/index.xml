<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Lambda on Uncle Xiang&#39;s Notebook</title>
        <link>https://ttf248.life/en/tags/lambda/</link>
        <description>Recent content in Lambda on Uncle Xiang&#39;s Notebook</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <lastBuildDate>Sun, 25 May 2025 02:57:45 +0800</lastBuildDate><atom:link href="https://ttf248.life/en/tags/lambda/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Lambda expression parameter lifetime in C&#43;&#43;</title>
        <link>https://ttf248.life/en/p/cpp-lambda-parameter-lifetime/</link>
        <pubDate>Wed, 13 Nov 2024 19:23:02 +0800</pubDate>
        
        <guid>https://ttf248.life/en/p/cpp-lambda-parameter-lifetime/</guid>
        <description>&lt;p&gt;In C++, lambda expressions are convenient anonymous functions that can capture external variables and use them within their bodies. This makes lambdas a flexible programming tool. However, the lifetime of lambda expression parameters is an aspect that requires special attention, especially when capturing and passing parameters.&lt;/p&gt;
&lt;h3 id=&#34;the-lifecycle-of-parameters-in-lambda-expressions&#34;&gt;The lifecycle of parameters in lambda expressions
&lt;/h3&gt;&lt;p&gt;The lifetime of lambda expression parameters is typically the same as that of other C++ functions. Function parameters exist during the function call and end when the function call completes. However, because lambda expressions may capture external variables, the lifetime of the parameters can also be affected by the capturing method.&lt;/p&gt;
&lt;h3 id=&#34;the-relationship-between-capture-and-parameter-lifecycle&#34;&gt;The relationship between capture and parameter lifecycle
&lt;/h3&gt;&lt;h4 id=&#34;21-capturing-external-variables&#34;&gt;2.1 Capturing External Variables
&lt;/h4&gt;&lt;p&gt;C++ lambda expressions allow capturing external variables in two ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Value capturing: Through value capture, the values of external variables are copied into the lambda, and the lifecycle of these copies is controlled by the lifecycle of the lambda&lt;/li&gt;
&lt;li&gt;Closure: Through closure capturing, references to external variables are preserved; references within a lambda point to the original external variables, and their lifecycle depends on the external variables&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda_by_value = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };  // 捕获x的副本
auto lambda_by_reference = [&amp;amp;x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };  // 捕获x的引用

lambda_by_value();  // 打印10
lambda_by_reference();  // 打印10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The lifecycle of captured variables is as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;By-value capture: When capturing, the values of external variables are copied into the lambda, and when the lambda&amp;rsquo;s lifecycle ends, these copies are destroyed&lt;/li&gt;
&lt;li&gt;Capture by reference: A lambda holding a reference to an external variable must have the external variable be valid before the lambda is used, otherwise it can lead to undefined behavior&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;22-lambda-parameters&#34;&gt;2.2 Lambda Parameters
&lt;/h4&gt;&lt;p&gt;Lambda parameters are similar to regular function parameters, their lifecycle is limited to within the lambda function. That is, lambda parameters are created when the lambda is called and their lifecycle ends after the lambda call is completed.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto lambda = [](int a, int b) {
    std::cout &amp;lt;&amp;lt; a + b &amp;lt;&amp;lt; std::endl;
};
lambda(5, 10);  // a和b在这里是lambda的参数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are parameters of the lambda expression, they are created when the lambda is called and destroyed after the lambda execution ends&lt;/p&gt;
&lt;h3 id=&#34;lifecycle-issues-when-capturing-external-variables&#34;&gt;Lifecycle issues when capturing external variables
&lt;/h3&gt;&lt;h4 id=&#34;whether-captured-variables-can-be-valid-outside-of-a-lambda&#34;&gt;Whether captured variables can be valid outside of a lambda
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Capture by value: Even if external variables are destroyed after a lambda call, the lambda still holds a copy of the external variable. Therefore, the copy inside the lambda can be used safely, even if the external variable no longer exists.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x 在lambda调用后修改
lambda();  // 打印10，捕获的是x的副本
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;By reference capture: If a variable is captured by reference, the lambda&amp;rsquo;s access to that reference depends on the lifetime of the external variable. If the external variable is destroyed before the lambda executes, this can lead to a dangling reference and undefined behavior.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [&amp;amp;x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x 在lambda调用前修改
lambda();  // 打印20，捕获的是x的引用
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;It is very important to ensure that captured external variables remain valid when the lambda function executes if the order of execution of lambdas is uncertain&lt;/p&gt;
&lt;/blockquote&gt;</description>
        </item>
        
    </channel>
</rss>
