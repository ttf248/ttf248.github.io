<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Chatgtp on Uncle Xiang&#39;s Notebook</title>
        <link>https://ttf248.life/en/tags/chatgtp/</link>
        <description>Recent content in Chatgtp on Uncle Xiang&#39;s Notebook</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <lastBuildDate>Mon, 02 Jun 2025 19:00:25 +0800</lastBuildDate><atom:link href="https://ttf248.life/en/tags/chatgtp/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Prompt Engineer</title>
        <link>https://ttf248.life/en/p/prompt-engineer/</link>
        <pubDate>Sun, 26 Mar 2023 20:46:53 +0800</pubDate>
        
        <guid>https://ttf248.life/en/p/prompt-engineer/</guid>
        <description>&lt;p&gt;Just as we needed to learn the techniques of searching engines back then, we also need to learn some techniques for communicating with &lt;code&gt;AI&lt;/code&gt;, providing reasonable and sufficient constraints, and efficiently obtaining the desired answers.&lt;/p&gt;
&lt;p&gt;If you look at it from a different angle, current &lt;code&gt;AI&lt;/code&gt; is like a very good student with excellent memory – it has the ability to memorize everything. What we need to do is learn how to communicate with &lt;code&gt;AI&lt;/code&gt; correctly, effectively, and precisely describe our needs to help &lt;code&gt;AI&lt;/code&gt; generate the expected results.&lt;/p&gt;
&lt;p&gt;##科普
The incredibly popular &lt;code&gt;AI&lt;/code&gt; – specifically &lt;code&gt;Generative Pre-Training&lt;/code&gt; – literally translates to generative pre-training. It’s a deep learning model that trains text generation based on internet-available data, used for tasks such as question answering, text summarization generation, machine translation, classification, code generation, and conversational AI. Currently, there have been various versions of models like GPT-1, GPT-2, GPT-3, and GPT-4, each larger and more powerful than the previous one.&lt;/p&gt;
&lt;h2 id=&#34;does-it-really-have-intelligence&#34;&gt;Does it Really Have Intelligence?
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Similarity is high, accuracy increases accordingly.&lt;/li&gt;
&lt;li&gt;Basic, repetitive tasks, after specific training, no longer require human intervention.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Generative AI is a technology that utilizes existing data such as text, audio, and images to create new content. It can be used for various tasks including text generation, speech synthesis, image generation, and dialogue systems. The logical reasoning of Generative AI depends on its training data and model structure. Generally, Generative AI can follow grammar, logic, and common sense to a certain extent, but it may also produce errors, biases, or unrealistic content. Therefore, the output of Generative AI requires human judgment and verification; it should not be blindly trusted or used.&lt;/p&gt;
&lt;h2 id=&#34;prompt-engineer&#34;&gt;Prompt Engineer
&lt;/h2&gt;&lt;p&gt;Time flows only forward, and people need to learn to adapt to the current. You can think of &lt;code&gt;AI&lt;/code&gt; as not intelligent, lacking logic, and frequently producing unusable code.&lt;/p&gt;
&lt;p&gt;If you shift your perspective, the current &lt;code&gt;AI&lt;/code&gt; is like a child with excellent memory – it has the ability to memorize after reading something repeatedly, much like copying homework. What we need to do is learn how to communicate correctly, effectively, and with &lt;code&gt;AI&lt;/code&gt;, precisely describing our needs to help &lt;code&gt;AI&lt;/code&gt; generate the desired results.&lt;/p&gt;
&lt;h2 id=&#34;dialogue-patterns&#34;&gt;Dialogue Patterns
&lt;/h2&gt;&lt;p&gt;Two years ago, when GitHub Copilot was released, no one could have imagined that two years later, OpenAI would appear out of nowhere, allowing humans to recognize the capabilities of large language models.&lt;/p&gt;
&lt;p&gt;Based on &lt;strong&gt;comment-based programming&lt;/strong&gt; and &lt;strong&gt;conversational programming&lt;/strong&gt;, the interaction logic is completely different. The dialogue pattern is friendly for novice users, and it’s crucial to mention NewBing providing follow-up prompts after each question. Microsoft is attempting to guide users to obtain more content from the AI knowledge base.&lt;/p&gt;
&lt;h2 id=&#34;lets-illustrate-with-an-example&#34;&gt;Let&amp;rsquo;s illustrate with an example
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Scenario:&lt;/strong&gt; A long high-speed train journey, coding is a good choice. With limited traffic, processing a few images, obtaining image materials, downloading software to process the images is a bit extravagant, and network conditions are not ideal.
&lt;strong&gt;Requirements:&lt;/strong&gt; There’s a batch of image materials with transparent backgrounds that will be used as navigation bars for small programs. The selected state is colored, and the unselected state is black and white. All the materials are in color, and they need to be preprocessed.
&lt;strong&gt;Prompt:&lt;/strong&gt; Write a Python code snippet to read all images from a folder, convert the images to black and white while maintaining the transparent background, save the images, optimize image quality, reduce file size, and simultaneously display the comparison of the file sizes before and after optimization in the console.&lt;/p&gt;
&lt;h2 id=&#34;lets-illustrate-with-an-example-1&#34;&gt;Let&amp;rsquo;s illustrate with an example
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Import necessary libraries
import os
import PIL
from PIL import Image
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;lets-illustrate-with-an-example-2&#34;&gt;Let&amp;rsquo;s illustrate with an example
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Define a function to convert images to black and white, maintain the transparent background, save the image, and return the file size.
def convert_and_save(image_file):
    # Open the image
    image = Image.open(image_file)
    # Get the image mode, if it&#39;s RGBA mode, it means there is a transparent background
    mode = image.mode
    if mode == &amp;quot;RGBA&amp;quot;:
        # Create a white background image with the same size as the image
        background = Image.new(&amp;quot;RGB&amp;quot;, image.size, (255, 255, 255))
        # Paste the original image onto the white background, ignoring transparent pixels
        background.paste(image, mask=image.split()[3])
        # Convert the composite image to grayscale mode
        gray_image = background.convert(&amp;quot;L&amp;quot;)
        # Convert the grayscale image back to RGBA mode to preserve the transparent background
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;lets-illustrate-with-an-example-3&#34;&gt;Let&amp;rsquo;s illustrate with an example
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;gray_image = background.convert(&amp;quot;L&amp;quot;)
        # Convert the grayscale image to RGBA mode to preserve the transparent background
        final_image = gray_image.convert(&amp;quot;RGBA&amp;quot;)
    else:
        # If it&#39;s not in RGBA mode, directly convert the image to grayscale mode
        final_image = image.convert(&amp;quot;L&amp;quot;)
    # Get the original image file name and extension
    file_name, file_ext = os.path.splitext(image_file)
    # Define the new image file name, adding _bw suffix to indicate black and white
    new_file_name = file_name + &amp;quot;_bw&amp;quot; + file_ext
    # Save the new image, optimizing quality to reduce file size
    final_image.save(new_file_name, optimize=True)
    # Get the file sizes of the original and new images and return
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;lets-illustrate-with-an-example-4&#34;&gt;Let&amp;rsquo;s illustrate with an example
&lt;/h2&gt;&lt;h1 id=&#34;save-the-new-image-and-optimize-quality-reducing-file-size&#34;&gt;Save the new image and optimize quality, reducing file size
&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;final_image.save(new_file_name, optimize=True)
# Get the file sizes of the original and new images and return them
old_size = os.path.getsize(image_file)
new_size = os.path.getsize(new_file_name)
return old_size, new_size
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Example:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Define a folder path to store all images:
&lt;code&gt;folder_path = &amp;quot;images&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Iterate through all files in the folder:
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for file in os.listdir(folder_path):
  # Construct the full file path
  file_path = os.path.join(folder_path, file)
  # Check if it&#39;s an image file (based on extension; add or modify extensions as needed)
  if file_path.endswith((&amp;quot;.png&amp;quot;, &amp;quot;.jpg&amp;quot;, &amp;quot;.jpeg&amp;quot;, &amp;quot;.gif&amp;quot;)):
    # Call the function to convert and save the image, and get the file size
    old_size, new_size = convert_and_save(file_path)
    # Display the comparison of file sizes before and after optimization in the console
    print(f&amp;quot;{file}: {old_size} bytes -&amp;gt; {new_size} bytes&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;lets-illustrate-this-with-an-example&#34;&gt;Let&amp;rsquo;s illustrate this with an example:
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;AI&lt;/code&gt; quickly provided the answer, which looked very beautiful and worked well. Experienced program sources would find the following code not generic enough and unable to be deployed to production:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Parameters were fixed&lt;/li&gt;
&lt;li&gt;There were no log files; information was printed to the console&lt;/li&gt;
&lt;li&gt;The image processing task was suitable for a multi-threaded model&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;NewBing&lt;/code&gt; appeared, based on the prompt, selecting a question: &lt;strong&gt;What improvements can be made to this code?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The answer given this time was truly beyond expectations. General optimization measures that most programmers could think of were provided by &lt;code&gt;AI&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;This code may still have some areas for improvement, such as:

You could use the argparse library to allow users to specify the folder path and extension through command-line parameters instead of hardcoding them in the code.
``` You can use the logging library to record the program&#39;s runtime instead of directly printing to the console.
You can use try-except blocks to catch potential exceptions, such as file opening failures or image conversion failures, and handle them appropriately.
You can utilize the multiprocessing library to leverage multi-core processors and accelerate the image conversion and saving processes.

Friendly responses are considered, taking into account differences in the deployment environment and allowing for non-support of multi-processing.

## Let&#39;s illustrate with an example

```shell
Of course, I’m happy to help you modify your code. I added argparse, logging, and try-except statements, but I didn’t add the multiprocessing library because I wasn’t sure if your computer supported multi-core processing. The modified code is as follows:
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;lets-illustrate-with-an-example-5&#34;&gt;Let&amp;rsquo;s illustrate with an example
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Import necessary libraries
import argparse
import logging
import multiprocessing
import os

from PIL import Image
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;lets-illustrate-with-an-example-6&#34;&gt;Let&amp;rsquo;s illustrate with an example
&lt;/h2&gt;&lt;h1 id=&#34;define-a-function-to-convert-images-to-black-and-white-while-maintaining-the-transparent-background-save-the-image-and-return-the-file-size&#34;&gt;Define a function to convert images to black and white while maintaining the transparent background, save the image, and return the file size
&lt;/h1&gt;&lt;p&gt;def convert_and_save(image_file):
# Open the image
try:
image = Image.open(image_file)
except Exception as e:
logging.error(f&amp;quot;Failed to open {image_file}: {e}&amp;quot;)
return None, None
# Get the image mode; if it&amp;rsquo;s RGBA mode, it means there is a transparent background
mode = image.mode
if mode == &amp;ldquo;RGBA&amp;rdquo;:
# Create a white background image with the same size as the image
background = Image.new(&amp;ldquo;RGB&amp;rdquo;, image.size, (255, 255, 255))
# Paste the original image onto the white background, ignoring transparent pixels
background.paste(image, mask=image.split()[3])&lt;/p&gt;
&lt;h2 id=&#34;lets-illustrate-with-an-example-7&#34;&gt;Let&amp;rsquo;s illustrate with an example
&lt;/h2&gt;&lt;h1 id=&#34;paste-the-original-image-onto-a-white-background-ignoring-transparent-pixels&#34;&gt;Paste the original image onto a white background, ignoring transparent pixels:
&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;    background.paste(image, mask=image.split()[3])
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;convert-the-composite-image-to-grayscale-mode&#34;&gt;Convert the composite image to grayscale mode:
&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;    gray_image = background.convert(&amp;quot;L&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;convert-the-grayscale-image-back-to-rgba-mode-to-preserve-the-transparent-background&#34;&gt;Convert the grayscale image back to RGBA mode to preserve the transparent background:
&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;    final_image = gray_image.convert(&amp;quot;RGBA&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;else:&lt;/p&gt;
&lt;h1 id=&#34;if-its-not-in-rgba-mode-simply-convert-the-image-to-grayscale&#34;&gt;If it&amp;rsquo;s not in RGBA mode, simply convert the image to grayscale:
&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;    final_image = image.convert(&amp;quot;L&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;get-the-original-images-filename-and-extension&#34;&gt;Get the original image&amp;rsquo;s filename and extension:
&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;file_name, file_ext = os.path.splitext(image_file)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;define-the-new-images-filename-adding-_bw-suffix-to-indicate-black-and-white&#34;&gt;Define the new image&amp;rsquo;s filename, adding &amp;ldquo;_bw&amp;rdquo; suffix to indicate black and white:
&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;new_file_name = file_name + &amp;quot;_bw&amp;quot; + file_ext
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;save-the-new-image-optimizing-quality-to-reduce-file-size&#34;&gt;Save the new image, optimizing quality to reduce file size
&lt;/h1&gt;&lt;h2 id=&#34;lets-illustrate-this-with-an-example-1&#34;&gt;Let&amp;rsquo;s illustrate this with an example
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;new_file_name = file_name + &amp;quot;_bw&amp;quot; + file_ext
    # Save the new image and optimize quality to reduce file size
    try:
        final_image.save(new_file_name, optimize=True)
    except Exception as e:
        logging.error(f&amp;quot;Failed to save {new_file_name}: {e}&amp;quot;)
        return None, None
    # Get the file sizes of the original and new images and return them
    old_size = os.path.getsize(image_file)
    new_size = os.path.getsize(new_file_name)
    return file_name, old_size, new_size
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;lets-illustrate-with-an-example-8&#34;&gt;Let&amp;rsquo;s illustrate with an example
&lt;/h2&gt;&lt;h1 id=&#34;define-a-function-to-parse-command-line-arguments-and-return-a-list-of-folder-paths-and-file-extensions&#34;&gt;Define a function to parse command-line arguments and return a list of folder paths and file extensions.
&lt;/h1&gt;&lt;p&gt;def parse_args():
# Create a parser object
parser = argparse.ArgumentParser(description=&amp;ldquo;Convert images to black and white and optimize quality.&amp;rdquo;)
# Add a required positional argument to represent the folder path
parser.add_argument(&amp;ldquo;folder_path&amp;rdquo;, help=&amp;ldquo;The path of the folder that contains the images.&amp;rdquo;)
# Add an optional argument to represent the list of extensions, defaulting to png, jpg, jpeg and gif
parser.add_argument(&amp;quot;-e&amp;quot;, &amp;ldquo;&amp;ndash;extensions&amp;rdquo;, nargs=&amp;quot;+&amp;quot;, default=[&amp;quot;.png&amp;quot;, &amp;ldquo;.jpg&amp;rdquo;, &amp;ldquo;.jpeg&amp;rdquo;, &amp;ldquo;.gif&amp;rdquo;], help=&amp;ldquo;The extensions of the image files.&amp;rdquo;)
# Parse command-line arguments and return the result object&lt;/p&gt;
&lt;h2 id=&#34;lets-illustrate-this-with-an-example-2&#34;&gt;Let&amp;rsquo;s illustrate this with an example
&lt;/h2&gt;&lt;h1 id=&#34;parse-command-line-arguments-and-return-the-result-object&#34;&gt;Parse command-line arguments and return the result object
&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;args = parser.parse_args()
return args.folder_path, args.extensions
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;lets-illustrate-with-an-example-9&#34;&gt;Let&amp;rsquo;s illustrate with an example
&lt;/h2&gt;&lt;h1 id=&#34;define-a-function-to-print-the-comparison-of-file-sizes-before-and-after-optimization&#34;&gt;Define a function to print the comparison of file sizes before and after optimization
&lt;/h1&gt;&lt;p&gt;def print_result(result):
# If the result is not empty, it indicates that the conversion and saving were successful
if result:
# Unpack the result into a tuple of filename and file size
if len(result) == 3:
file, old_size, new_size = result
# Display the comparison of file sizes before and after optimization in the console
logging.info(f&amp;quot;{file}: {old_size} bytes -&amp;gt; {new_size} bytes&amp;quot;)
else:
logging.info(f&amp;quot;{result}&amp;quot;)&lt;/p&gt;
&lt;h2 id=&#34;lets-illustrate-with-an-example-10&#34;&gt;Let&amp;rsquo;s illustrate with an example
&lt;/h2&gt;&lt;h1 id=&#34;configure-the-logger-to-output-logs-to-both-the-console-and-files-setting-the-log-level-to-info&#34;&gt;Configure the logger to output logs to both the console and files, setting the log level to INFO
&lt;/h1&gt;&lt;p&gt;logging.basicConfig(level=logging.INFO,
format=&amp;quot;%(asctime)s %(levelname)s %(message)s&amp;quot;,
handlers=[logging.StreamHandler(),
logging.FileHandler(&amp;ldquo;log.txt&amp;rdquo;)])&lt;/p&gt;
&lt;h1 id=&#34;call-the-function-to-get-the-folder-path-and-extension-list&#34;&gt;Call the function to get the folder path and extension list
&lt;/h1&gt;&lt;p&gt;folder_path, extensions = parse_args()&lt;/p&gt;
&lt;h2 id=&#34;lets-illustrate-with-an-example-11&#34;&gt;Let&amp;rsquo;s illustrate with an example
&lt;/h2&gt;&lt;h1 id=&#34;calling-a-function-to-get-the-folder-path-and-extension-list&#34;&gt;Calling a function to get the folder path and extension list
&lt;/h1&gt;&lt;p&gt;folder_path, extensions = parse_args()&lt;/p&gt;
&lt;p&gt;if &lt;strong&gt;name&lt;/strong&gt; == &amp;ldquo;&lt;strong&gt;main&lt;/strong&gt;&amp;rdquo;:
# Windows needs this function because Windows lacks the fork() function (this is not entirely accurate).
# Therefore, on Windows, fork() is simulated by creating a new process. The code running in this new process, which is what runs in the child process on Linux,
# Because this code must run in unrelated processes, it must be passed to them before execution.
# The way to pass it is to serialize it first and then send it through a pipe from the original process to the new process.
# Furthermore, the new process is notified that it must execute the code passed through the pipe by passing the &amp;ndash;multiprocessing-fork command line parameter to it.&lt;/p&gt;
&lt;h2 id=&#34;lets-illustrate-with-an-example-12&#34;&gt;Let&amp;rsquo;s illustrate with an example
&lt;/h2&gt;&lt;h1 id=&#34;create-a-process-pool-automatically-assigning-processes-based-on-the-number-of-computer-cores&#34;&gt;Create a process pool, automatically assigning processes based on the number of computer cores
&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;pool = multiprocessing.Pool()
# Create an empty list to store the result objects of asynchronous tasks
results = []
# Iterate through all files in the folder
for file in os.listdir(folder_path):
    # Construct the full file path
    file_path = os.path.join(folder_path, file)
    # Check if it&#39;s an image file, judging by the extension (you can modify the list of extensions as needed)
    if any(file_path.endswith(ext) for ext in extensions):
        # Call the function to convert and save the image, getting the file size, using asynchronous mode without blocking the main process
        result = pool.apply_async(convert_and_save, args=(file_path,), callback=print_result)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;lets-illustrate-with-an-example-13&#34;&gt;Let&amp;rsquo;s illustrate with an example
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;result = pool.apply_async(convert_and_save, args=(file_path,), callback=print_result)
            # Add the result object to the list
            results.append((file, result))
    # Close the process pool, no longer accepting new tasks
    pool.close()
    # Wait for all tasks to complete
    pool.join()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;epilogue&#34;&gt;Epilogue
&lt;/h2&gt;&lt;p&gt;Due to local development being on a &lt;code&gt;windows&lt;/code&gt; system, the first answer given by &lt;code&gt;AI&lt;/code&gt; did not include the &lt;code&gt;main&lt;/code&gt; function and also lacked &lt;code&gt;multiprocessing.freeze_support&lt;/code&gt;. The code was fixed after following up and encountering an error.
Just as learning the techniques of search engines required skill, we also need to learn how to communicate with &lt;code&gt;AI&lt;/code&gt;, providing reasonable and sufficient constraints to efficiently obtain the desired answers.
Note: &lt;strong&gt;If you are a programming beginner, if you still don&amp;rsquo;t understand certain parts of the code based on the given comments, please continue to ask related questions.&lt;/strong&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
