<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Byte-Order on Uncle Xiang&#39;s Notebook</title>
        <link>https://ttf248.life/en/tags/byte-order/</link>
        <description>Recent content in Byte-Order on Uncle Xiang&#39;s Notebook</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <lastBuildDate>Mon, 02 Jun 2025 06:00:45 +0800</lastBuildDate><atom:link href="https://ttf248.life/en/tags/byte-order/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Why do computers generally use little-endian storage?</title>
        <link>https://ttf248.life/en/p/little-endian-storage-why/</link>
        <pubDate>Wed, 24 Jan 2024 10:43:05 +0800</pubDate>
        
        <guid>https://ttf248.life/en/p/little-endian-storage-why/</guid>
        <description>&lt;p&gt;Regarding byte order: A layman&amp;rsquo;s explanation &lt;a class=&#34;link&#34; href=&#34;https://example.com/post/2023/01-10-%e4%b8%bb%e6%9c%ba%e5%ba%8f%e3%80%81%e7%bd%91%e7%bb%9c%e5%ba%8f%ef%bc%8c%e9%80%9a%e8%bf%87%e8%b0%83%e8%af%95%e5%99%a8%ef%bc%8c%e7%9b%b4%e6%8e%a5%e8%a7%82%e5%af%9f&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Host Order, Network Order, observed directly through debugger&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In the field of computer science, certain design habits have formed due to historical reasons, just like the width of a person&amp;rsquo;s buttocks determines the width of a rocket’s thrusters – there’s no need to rigidly analyze their “advantages” and “disadvantages”; it’s simply a matter of historical convention.&lt;/p&gt;
&lt;h2 id=&#34;original-link&#34;&gt;Original Link
&lt;/h2&gt;&lt;p&gt;Author: Beiji (North Pole)
Link: &lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/question/637413724/answer/3346032134&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.zhihu.com/question/637413724/answer/3346032134&lt;/a&gt;
Source: Zhihu
Copyright belongs to the author. For commercial reprints, please contact the author for permission. Non-commercial reprints must indicate the source.&lt;/p&gt;
&lt;h2 id=&#34;text-translation&#34;&gt;Text Translation
&lt;/h2&gt;&lt;p&gt;Nowadays, the current situation is a result of historical habits + commercialization, and has little to do with technology itself. ARM can be set up in big-endian or little-endian format. The TCP/IP header still uses big-endian (network byte order). There are also many storage protocols/specifications in the storage field that save data in a big-endian manner.&lt;/p&gt;
&lt;p&gt;Therefore, the three questions posed by the user seem to be incorrect in today&amp;rsquo;s view:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Why do computers generally adopt little-endian storage? –&amp;gt; Incorrect.&lt;/li&gt;
&lt;li&gt;Why is low-byte storage more efficient in a little-endian way than in a big-endian way? –&amp;gt; Efficiency will not be higher.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;Any argument about these three questions using current technology belongs to shooting first and drawing the target.&lt;/p&gt;
&lt;h2 id=&#34;translated-text&#34;&gt;Translated Text
&lt;/h2&gt;&lt;p&gt;However, when it comes to the choice between big-endian and little-endian, there were indeed certain objective factors in the history of computer development: The advantage of host byte order (little-endian) is that little-endian adders are easier to implement. If you create an 8-bit * 4 adder, you only need one 8-bit adder and sequentially add all bytes from low to high. The carry circuit is very simple. In contrast, if using big-endian, you would need to load a 32-bit value at once, otherwise it wouldn’t be possible to perform calculations. Looking back now, the difference between loading 8 bits or 32 bits is not significant; however, in the decades of the past, memory prices were high, so simplicity was paramount. Therefore, the host byte order selection for little-endian was based on cost considerations. The advantages of network big-endian byte order: In the early days, caches on devices were very small. Receiving the high byte first allowed for a quick determination of message information: packet length (how much cache to prepare), address range (IP addresses are matched from front to back). Early network devices’ caches were at the byte level; taking the high byte first was indeed slightly faster. Therefore, network devices used big-endian due to cost considerations.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Therefore, the choice of byte order was primarily influenced by application scenarios and costs (such as PPC/MIPS being more suitable for networking equipment), while later technological developments were driven by compatibility reasons, leading to the continued use of big-endian. In today’s view, these advantages no longer exist; they are simply historical habits.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Host byte, network byte, observe directly through debugger</title>
        <link>https://ttf248.life/en/p/host-order-network-order-debugger-observation/</link>
        <pubDate>Tue, 10 Jan 2023 14:18:12 +0800</pubDate>
        
        <guid>https://ttf248.life/en/p/host-order-network-order-debugger-observation/</guid>
        <description>&lt;p&gt;Throughout the history of computer development, there has been no unified standard for data storage. There are two commonly used rules for byte arrangement. For example, if the low-order bits of a multi-digit number are placed at smaller addresses and the high-order bits are placed at larger addresses, it is referred to as little-endian; conversely, it is called big-endian. In network applications, byte order is a factor that must be considered because different types of machines may adopt different standards, so they are all converted according to the network standard.
According to reading habits, big-endian byte order is more consistent with the left-to-right reading order.&lt;/p&gt;
&lt;h2 id=&#34;processor-architecturehttpszhwikipediaorgwikie5ad97e88a82e5ba8f&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Processor Architecture&lt;/a&gt;
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Processors such as x86, MOS Technology 6502, Z80, VAX, and PDP-11 use little-endian byte order.&lt;/li&gt;
&lt;li&gt;Processors like Motorola 6800, Motorola 68000, PowerPC 970 use big-endian byte order.&lt;/li&gt;
&lt;li&gt;The byte order of processors such as ARM, PowerPC (excluding PowerPC 970), DEC Alpha, SPARC V9, MIPS, PA-RISC and IA64 is configurable.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;network-byte-order&#34;&gt;Network Byte Order
&lt;/h2&gt;&lt;p&gt;Network transmission generally uses big-endian order, also known as network byte order or network order. The IP protocol defines big-endian as the network byte order.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;Berkeley&lt;/code&gt; sockets API defined a set of conversion functions to convert 16 and 32-bit integers between network byte order and host byte order.&lt;/p&gt;
&lt;p&gt;If using &lt;code&gt;asio&lt;/code&gt; as a networking library, its internal namespaces contain cross-platform adapted function names:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;boost::asio::detail::socket_ops::network_to_host_long&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::network_to_host_short&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::host_to_network_long&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::host_to_network_short&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;visual-studio-debugger&#34;&gt;Visual Studio Debugger
&lt;/h2&gt;&lt;p&gt;In debugging mode, select the Debug menu, Window, and checkmark the Memory window.  Within &lt;code&gt;Visual Studio&lt;/code&gt;, you can directly view data in memory using the debugger, as shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/host-network-byte-order-debugger/Snipaste_2023-01-10_14-44-00.png&#34;
	width=&#34;535&#34;
	height=&#34;147&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Debugger Menu&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;363&#34;
		data-flex-basis=&#34;873px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;ways-to-view-memory&#34;&gt;Ways to View Memory
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;The window directly outputs &amp;amp;variable name and jumps to the corresponding variable address.&lt;/li&gt;
&lt;li&gt;If the variable is originally a pointer, double-click on the variable to select it and drag it to the memory window to display the content at the corresponding address.&lt;/li&gt;
&lt;li&gt;If the variable is not a pointer, add it to the calculation window to obtain its address, then manually copy it to the memory window.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lets-illustrate-with-an-example&#34;&gt;Let&amp;rsquo;s illustrate with an example
&lt;/h3&gt;&lt;p&gt;Receive a piece of data and store it in the &lt;code&gt;buffer&lt;/code&gt; object, convert network byte order to host byte order, resulting in &lt;code&gt;body_length&lt;/code&gt; being equal to 30. The server allocates four bytes for transmitting this data.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Big-Endian Byte Order&lt;/strong&gt;: Observing the content of &lt;code&gt;buffer_&lt;/code&gt; in the memory window
&lt;img src=&#34;https://ttf248.life/p/host-network-byte-order-debugger/buffer_.png&#34;
	width=&#34;603&#34;
	height=&#34;318&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;buffer_&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;189&#34;
		data-flex-basis=&#34;455px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Little-Endian Byte Order&lt;/strong&gt;: Observing the content of &lt;code&gt;body_length_&lt;/code&gt; in the memory window
&lt;img src=&#34;https://ttf248.life/p/host-network-byte-order-debugger/body_length_.png&#34;
	width=&#34;581&#34;
	height=&#34;333&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;body_length_&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;174&#34;
		data-flex-basis=&#34;418px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
