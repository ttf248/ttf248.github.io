<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Byte Order on Uncle Xiang&#39;s Notebook</title>
        <link>https://ttf248.life/en/tags/byte-order/</link>
        <description>Recent content in Byte Order on Uncle Xiang&#39;s Notebook</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <lastBuildDate>Sun, 25 May 2025 02:57:45 +0800</lastBuildDate><atom:link href="https://ttf248.life/en/tags/byte-order/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Why do computers generally use little-endian storage?</title>
        <link>https://ttf248.life/en/p/little-endian-storage-why/</link>
        <pubDate>Wed, 24 Jan 2024 10:43:05 +0800</pubDate>
        
        <guid>https://ttf248.life/en/p/little-endian-storage-why/</guid>
        <description>&lt;p&gt;An Explanation of Byte Order [Host Order, Network Order, Observing Directly Through a Debugger]&lt;/p&gt;
&lt;p&gt;Some design habits formed due to historical reasons in the computer field are like the principle that the width of a horse&amp;rsquo;s rear end determines the width of a rocket engine – there’s no need to analyze their “advantages” and “disadvantages”; they’re simply historical conventions&lt;/p&gt;
&lt;h2 id=&#34;original-link&#34;&gt;Original link
&lt;/h2&gt;&lt;p&gt;Author: Arctic
Link: [https://www.zhihu.com/question/637413724/answer/3346032134]
Source: Zhihu
Copyright belongs to the author. For commercial reproduction, please contact the author for authorization; for non-commercial reproduction, please indicate the source.&lt;/p&gt;
&lt;h2 id=&#34;reprint-of-the-main-text&#34;&gt;Reprint of the main text
&lt;/h2&gt;&lt;p&gt;The current endianness situation is a result of historical habits and commercialization, not really related to the technology itself. ARM can be configured as either big-endian or little-endian. The TCP/IP header still uses big-endian (network byte order). There are also many storage protocols/specifications in the storage field that save data in big-endian format.&lt;/p&gt;
&lt;p&gt;So, the three questions raised by the original poster, looking back today:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Why do computers generally use little-endian storage? &amp;ndash;&amp;gt; Incorrect&lt;/li&gt;
&lt;li&gt;Efficiency is not necessarily higher&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;Any attempt to justify these three issues based on current technology is like drawing a target before shooting an arrow&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;However, when it comes to the choice between big-endian and little-endian, there were indeed certain objective factors in the history of computer development: Advantages of host byte order (little-endian): Little-endian adders are easier to implement. If you want to build an 8-bit * 4 adder, you only need one 8-bit adder and can simply loop through all bytes from low to high and add them. The carry circuit is very simple. However, with big-endian, you need to load 32 bits at once, otherwise the calculation cannot be performed. Looking at it now, there’s not much difference between loading 8 bits or 32 bits, but decades ago, memory was expensive, so simplicity was preferred. Therefore, the choice of little-endian for host byte order was based on cost considerations. Advantages of network byte order (big-endian): Early devices had very small caches, and receiving the high byte first allowed for quick determination of packet information: package length (how much cache to prepare), address range (IP addresses are matched from front to back). Early networking devices used bytes as their unit, so taking the high byte first was indeed faster. Therefore, network devices use big-endian, also based on cost considerations.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Therefore, the choice of byte order has historically been driven more by application scenarios and cost considerations (such as PPC/MIPS being better suited for network devices), and later, due to compatibility reasons, the endian configuration has continued to be used until today&lt;/p&gt;
&lt;p&gt;Looking at it today, these advantages no longer exist at all; they are merely historical habits&lt;/p&gt;</description>
        </item>
        <item>
        <title>Host order, network order, observe directly through a debugger</title>
        <link>https://ttf248.life/en/p/host-order-network-order-debugger-observation/</link>
        <pubDate>Tue, 10 Jan 2023 14:18:12 +0800</pubDate>
        
        <guid>https://ttf248.life/en/p/host-order-network-order-debugger-observation/</guid>
        <description>&lt;p&gt;In the history of computer development, there has not been a unified standard for how to store data&lt;/p&gt;
&lt;p&gt;There are two common rules for arranging bytes. For example, if the low-order digits of a multi-digit number are placed at smaller addresses and the high-order digits are placed at larger addresses, it is called little-endian; otherwise, it is called big-endian. In network applications, byte order is a factor that must be considered because different machine types may adopt different standards, so they are all converted according to the network standard.&lt;/p&gt;
&lt;p&gt;Following reading habits, big-endian byte order is more consistent with the left-to-right reading sequence&lt;/p&gt;
&lt;h2 id=&#34;processor-architecture&#34;&gt;Processor architecture
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Processors such as x86, MOS Technology 6502, Z80, VAX, and PDP-11 are little-endian&lt;/li&gt;
&lt;li&gt;Processors such as Motorola 6800, Motorola 68000, and PowerPC 970 are big-endian&lt;/li&gt;
&lt;li&gt;The byte order is configurable for ARM, PowerPC (except PowerPC 970), DEC Alpha, SPARC V9, MIPS, PA-RISC, and IA64&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;network-preface&#34;&gt;Network Preface
&lt;/h2&gt;&lt;p&gt;Network transmission generally uses big-endian order, also known as network byte order or network order. Big-endian is defined as the network byte order in the IP protocol.
Berkeley sockets define a set of conversion functions for converting between network byte order and host byte order for 16- and 32-bit integers&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;arpa/inet.h&amp;gt;

uint32_t htonl(uint32_t hostlong); //把uint32_t类型从主机序转换到网络序
uint16_t htons(uint16_t hostshort); //把uint16_t类型从主机序转换到网络序
uint32_t ntohl(uint32_t netlong); //把uint32_t类型从网络序转换到主机序
uint16_t ntohs(uint16_t netshort); //把uint16_t类型从网络序转换到主机序
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you choose &lt;code&gt;asio&lt;/code&gt; as your networking library, there are cross-platform compatible function names in the built-in namespace&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;boost::asio::detail::socket_ops::network_to_host_long&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::network_to_host_short&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::host_to_network_long&lt;/li&gt;
&lt;li&gt;boost::asio::detail::socket_ops::host_to_network_short&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;visual-studio-debugger&#34;&gt;Visual Studio debugger
&lt;/h2&gt;&lt;p&gt;In debug mode, select the Debug menu, then Window, and check Memory Window&lt;/p&gt;
&lt;p&gt;In &lt;code&gt;Visual Studio&lt;/code&gt;, you can directly view data in memory within the debugger, as shown in the figure below&lt;/p&gt;
&lt;p&gt;Debugger Menu&lt;/p&gt;
&lt;h3 id=&#34;how-to-check-memory&#34;&gt;How to check memory
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Prints the variable name directly in the window and jumps to its corresponding address&lt;/li&gt;
&lt;li&gt;If the variable is already a pointer, double-click on the variable, drag it to the memory window, and display the contents at that address&lt;/li&gt;
&lt;li&gt;If the variable is not a pointer, add it to the calculation window, get its address, and then manually copy it to the memory window&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;for-example&#34;&gt;For example
&lt;/h3&gt;&lt;p&gt;Received a data segment, stored in the &lt;code&gt;buffer&lt;/code&gt; object, converted from network byte order to host byte order, resulting in &lt;code&gt;body_length&lt;/code&gt; equal to 30. The server has allocated four bytes for transmitting this data.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool NetworkMessage::decode_header()
{
    // 网络序转成主机序
    body_length_ = boost::asio::detail::socket_ops::network_to_host_long(*(int *)buffer_.data());
    return auto_reserve(body_length_);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;Big-endian byte order: Observe the contents of &lt;code&gt;buffer_&lt;/code&gt; in the memory window&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/host-order-network-order-debugger-observation/buffer_.png&#34;
	width=&#34;603&#34;
	height=&#34;318&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;buffer_&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;189&#34;
		data-flex-basis=&#34;455px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Little-endian byte order: Observe the contents of &lt;code&gt;body_length_&lt;/code&gt; in the memory window&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/host-order-network-order-debugger-observation/body_length_.png&#34;
	width=&#34;581&#34;
	height=&#34;333&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;body_length_&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;174&#34;
		data-flex-basis=&#34;418px&#34;
	
&gt;&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
