<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>C# on Uncle Xiang&#39;s Notebook</title>
        <link>https://ttf248.life/en/tags/c/</link>
        <description>Recent content in C# on Uncle Xiang&#39;s Notebook</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <lastBuildDate>Sun, 25 May 2025 02:57:45 +0800</lastBuildDate><atom:link href="https://ttf248.life/en/tags/c/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>UI thread issues and solutions in WPF</title>
        <link>https://ttf248.life/en/p/wpf-ui-thread-and-freezing-issues-solutions/</link>
        <pubDate>Tue, 12 Mar 2024 07:12:21 +0800</pubDate>
        
        <guid>https://ttf248.life/en/p/wpf-ui-thread-and-freezing-issues-solutions/</guid>
        <description>&lt;p&gt;When developing desktop applications, especially when building rich client applications using the Windows Presentation Foundation (WPF) framework, correctly handling the user interface (UI) thread is crucial for ensuring application smoothness and responsiveness. The UI thread, also known as the main thread, is the core thread responsible for processing window and control events, layout calculations, and rendering the interface. Any operation that interacts with UI elements should be executed on the UI thread; this is a fundamental principle followed by WPF and most other GUI frameworks.&lt;/p&gt;
&lt;h2 id=&#34;what-is-the-ui-thread&#34;&gt;What is the UI thread?
&lt;/h2&gt;&lt;p&gt;The UI thread is created and initialized by the operating system when a WPF application starts, and it initializes the application&amp;rsquo;s main window. It’s the only thread that can directly access and modify the state of UI components in the application. This means all user interactions, such as button clicks, text box input, and window resizing, are handled within this thread&amp;rsquo;s context. Simultaneously, WPF&amp;rsquo;s dependency property system, data binding mechanism, and layout logic also execute synchronously on the UI thread.&lt;/p&gt;
&lt;h2 id=&#34;stuttering-phenomenon-and-its-causes&#34;&gt;Stuttering phenomenon and its causes
&lt;/h2&gt;&lt;p&gt;When the UI thread is occupied or blocked for an extended period, such as when performing time-consuming calculations, loading large amounts of data, querying databases, or other I/O-intensive tasks, it can prevent the UI thread from responding to user interactions in a timely manner, resulting in a frozen interface (Freeze), which we commonly refer to as &amp;ldquo;lag.&amp;rdquo; In this situation, users will noticeably feel the application&amp;rsquo;s delay and sluggishness, and severe cases may even trigger an “Application Not Responding” (ANR) warning&lt;/p&gt;
&lt;h2 id=&#34;the-two-basic-rules-of-the-ui-thread&#34;&gt;The two basic rules of the UI thread
&lt;/h2&gt;&lt;p&gt;To avoid these situations, WPF developers should follow these two key rules:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Avoid performing time-consuming operations on the UI thread. Any operation that may cause the UI thread to freeze should be moved to a background thread as much as possible to ensure that the UI thread can respond to user input and render screen changes in a timely manner.&lt;/li&gt;
&lt;li&gt;Do not directly update UI elements on non-UI threads. Due to the security mechanism design of WPF, only the UI thread is authorized to modify UI elements. Attempting to change the UI state directly from another thread will throw an exception. Therefore, even if a background thread has completed calculations or data preparation, it needs to display the results on the UI through appropriate cross-thread communication mechanisms.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;solution-asynchronous-programming-and-thread-safe-updates&#34;&gt;Solution: Asynchronous Programming and Thread-Safe Updates
&lt;/h2&gt;&lt;p&gt;To maintain a smooth UI while executing time-consuming tasks, WPF provides various asynchronous programming models and tools to help developers achieve this goal&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The Dispatcher object: The WPF Dispatcher class allows you to schedule work items for execution in the UI thread&amp;rsquo;s task queue. You can safely update the UI from background threads using the &lt;code&gt;Dispatcher.Invoke&lt;/code&gt; or &lt;code&gt;Dispatcher.BeginInvoke&lt;/code&gt; methods.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;async/await&lt;/code&gt; keywords allow you to write asynchronous methods and use the &lt;code&gt;await&lt;/code&gt; keyword to wait for background tasks to complete, automatically returning to the UI thread to execute subsequent UI update code upon completion&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;case-study&#34;&gt;Case study
&lt;/h2&gt;&lt;h3 id=&#34;use-the-dispatcherinvoke-method-to-update-the-ui&#34;&gt;Use the &lt;code&gt;Dispatcher.Invoke&lt;/code&gt; method to update the UI
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private void Button_Click(object sender, RoutedEventArgs e)
{
    // 假设这是一个耗时操作
    Task.Run(() =&amp;gt;
    {
        var result = LongRunningOperation(); // 这里是模拟一个耗时计算的方法
        
        // 当耗时操作完成后，在UI线程上更新UI
        Application.Current.Dispatcher.Invoke(() =&amp;gt;
        {
            LabelStatus.Text = $&amp;quot;计算结果: {result}&amp;quot;;
        });
    });
}

private string LongRunningOperation()
{
    // 模拟耗时操作
    Thread.Sleep(5000);
    return &amp;quot;已完成&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;use-asyncawait-keywords-with-taskrun&#34;&gt;Use &lt;code&gt;async/await&lt;/code&gt; keywords with &lt;code&gt;Task.Run&lt;/code&gt;
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private async void Button_ClickAsync(object sender, RoutedEventArgs e)
{
    Button button = sender as Button;
    button.IsEnabled = false; // 防止用户重复点击

    try
    {
        // 开启后台任务
        var result = await Task.Run(() =&amp;gt; LongRunningOperation());

        // 在后台任务完成后，自动切换回UI线程更新UI
        LabelStatus.Text = $&amp;quot;计算结果: {result}&amp;quot;;
    }
    catch (Exception ex)
    {
        MessageBox.Show($&amp;quot;发生错误: {ex.Message}&amp;quot;);
    }
    finally
    {
        button.IsEnabled = true; // 重新启用按钮
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        
    </channel>
</rss>
