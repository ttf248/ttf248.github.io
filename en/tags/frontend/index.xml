<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Frontend on Uncle Xiang&#39;s Notebook</title>
        <link>https://ttf248.life/en/tags/frontend/</link>
        <description>Recent content in Frontend on Uncle Xiang&#39;s Notebook</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <lastBuildDate>Tue, 27 May 2025 00:12:34 +0800</lastBuildDate><atom:link href="https://ttf248.life/en/tags/frontend/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Old habits, dazzling flowers distract the eye</title>
        <link>https://ttf248.life/en/p/old-ailment-stunning-flowers/</link>
        <pubDate>Mon, 26 May 2025 23:54:12 +0800</pubDate>
        
        <guid>https://ttf248.life/en/p/old-ailment-stunning-flowers/</guid>
        <description>&lt;p&gt;Having focused on backend development for many years, I recently started exploring AI programming and dabbling in frontend-related content. However, during this experimentation, I&amp;rsquo;ve gradually realized I’m falling back into an old habit – being distracted by shiny things. I constantly want to use AI to build a frontend interface, but these attempts offer little practical benefit for my current work and instead disperse my focus.&lt;/p&gt;
&lt;p&gt;AI application scenarios&lt;/p&gt;
&lt;p&gt;AI tools can be particularly effective in small projects, especially when writing functions that are independent, have low system coupling, and feature simple business logic. These tasks typically involve clear input/output with limited context, making them well-suited for current AI-assisted programming capabilities.&lt;/p&gt;
&lt;p&gt;However, the limitations of AI become apparent when dealing with complex system architectures or deep business logic. It may generate code that appears reasonable but is actually detached from the project&amp;rsquo;s actual needs, and even introduce potential issues difficult to debug. In these scenarios, AI is better suited as an assistive tool rather than a fully relied-upon code generator. We need to rigorously review and test the generated code to ensure it meets practical requirements.&lt;/p&gt;
&lt;p&gt;The Cost of Mistakes and Learning&lt;/p&gt;
&lt;p&gt;While attempting to generate frontend code using AI, I encountered numerous challenges. As frontend isn&amp;rsquo;t my area of expertise, troubleshooting issues proved time-consuming and draining. Even with prompt adjustments for AI rewrites, low-level errors were difficult to avoid. This repeated trial and error not only wasted time but also highlighted that my efforts are better focused on backend business logic rather than exploring unfamiliar territory.&lt;/p&gt;
&lt;p&gt;Reflecting on the project completed this weekend, I&amp;rsquo;m even more convinced that focusing on backend development and user interaction logic—achieving functionality through the console—is currently the most efficient approach. Systematically learning frontend knowledge later, when I have more time and energy, might be a better strategy.&lt;/p&gt;
&lt;p&gt;Frontend Learning Plan&lt;/p&gt;
&lt;p&gt;The front-end tech stack is complex and diverse, making a quick start unrealistic. I plan to focus on one framework initially, such as Vue.js or React.js, and deeply learn its core concepts and usage. Only after mastering the fundamentals should I attempt AI-assisted code generation for the front-end, effectively avoiding errors and wasted time due to unfamiliarity.&lt;/p&gt;
&lt;p&gt;For now, the focus should remain on backend development and steadily building core skills. Explore the combination of frontend and AI when the time is right; that may yield greater rewards.&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
