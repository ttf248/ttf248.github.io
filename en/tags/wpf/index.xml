<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Wpf on Uncle Xiang&#39;s Notebook</title>
        <link>https://ttf248.life/en/tags/wpf/</link>
        <description>Recent content in Wpf on Uncle Xiang&#39;s Notebook</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <lastBuildDate>Sun, 25 May 2025 02:57:45 +0800</lastBuildDate><atom:link href="https://ttf248.life/en/tags/wpf/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>UI thread issues and solutions in WPF</title>
        <link>https://ttf248.life/en/p/wpf-ui-thread-and-freezing-issues-solutions/</link>
        <pubDate>Tue, 12 Mar 2024 07:12:21 +0800</pubDate>
        
        <guid>https://ttf248.life/en/p/wpf-ui-thread-and-freezing-issues-solutions/</guid>
        <description>&lt;p&gt;When developing desktop applications, especially when building rich client applications using the Windows Presentation Foundation (WPF) framework, correctly handling the user interface (UI) thread is crucial for ensuring application smoothness and responsiveness. The UI thread, also known as the main thread, is the core thread responsible for processing window and control events, layout calculations, and rendering the interface. Any operation that interacts with UI elements should be executed on the UI thread; this is a fundamental principle followed by WPF and most other GUI frameworks.&lt;/p&gt;
&lt;h2 id=&#34;what-is-the-ui-thread&#34;&gt;What is the UI thread?
&lt;/h2&gt;&lt;p&gt;The UI thread is created and initialized by the operating system when a WPF application starts, and it initializes the application&amp;rsquo;s main window. It’s the only thread that can directly access and modify the state of UI components in the application. This means all user interactions, such as button clicks, text box input, and window resizing, are handled within this thread&amp;rsquo;s context. Simultaneously, WPF&amp;rsquo;s dependency property system, data binding mechanism, and layout logic also execute synchronously on the UI thread.&lt;/p&gt;
&lt;h2 id=&#34;stuttering-phenomenon-and-its-causes&#34;&gt;Stuttering phenomenon and its causes
&lt;/h2&gt;&lt;p&gt;When the UI thread is occupied or blocked for an extended period, such as when performing time-consuming calculations, loading large amounts of data, querying databases, or other I/O-intensive tasks, it can prevent the UI thread from responding to user interactions in a timely manner, resulting in a frozen interface (Freeze), which we commonly refer to as &amp;ldquo;lag.&amp;rdquo; In this situation, users will noticeably feel the application&amp;rsquo;s delay and sluggishness, and severe cases may even trigger an “Application Not Responding” (ANR) warning&lt;/p&gt;
&lt;h2 id=&#34;the-two-basic-rules-of-the-ui-thread&#34;&gt;The two basic rules of the UI thread
&lt;/h2&gt;&lt;p&gt;To avoid these situations, WPF developers should follow these two key rules:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Avoid performing time-consuming operations on the UI thread. Any operation that may cause the UI thread to freeze should be moved to a background thread as much as possible to ensure that the UI thread can respond to user input and render screen changes in a timely manner.&lt;/li&gt;
&lt;li&gt;Do not directly update UI elements on non-UI threads. Due to the security mechanism design of WPF, only the UI thread is authorized to modify UI elements. Attempting to change the UI state directly from another thread will throw an exception. Therefore, even if a background thread has completed calculations or data preparation, it needs to display the results on the UI through appropriate cross-thread communication mechanisms.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;solution-asynchronous-programming-and-thread-safe-updates&#34;&gt;Solution: Asynchronous Programming and Thread-Safe Updates
&lt;/h2&gt;&lt;p&gt;To maintain a smooth UI while executing time-consuming tasks, WPF provides various asynchronous programming models and tools to help developers achieve this goal&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The Dispatcher object: The WPF Dispatcher class allows you to schedule work items for execution in the UI thread&amp;rsquo;s task queue. You can safely update the UI from background threads using the &lt;code&gt;Dispatcher.Invoke&lt;/code&gt; or &lt;code&gt;Dispatcher.BeginInvoke&lt;/code&gt; methods.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;async/await&lt;/code&gt; keywords allow you to write asynchronous methods and use the &lt;code&gt;await&lt;/code&gt; keyword to wait for background tasks to complete, automatically returning to the UI thread to execute subsequent UI update code upon completion&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;case-study&#34;&gt;Case study
&lt;/h2&gt;&lt;h3 id=&#34;use-the-dispatcherinvoke-method-to-update-the-ui&#34;&gt;Use the &lt;code&gt;Dispatcher.Invoke&lt;/code&gt; method to update the UI
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private void Button_Click(object sender, RoutedEventArgs e)
{
    // 假设这是一个耗时操作
    Task.Run(() =&amp;gt;
    {
        var result = LongRunningOperation(); // 这里是模拟一个耗时计算的方法
        
        // 当耗时操作完成后，在UI线程上更新UI
        Application.Current.Dispatcher.Invoke(() =&amp;gt;
        {
            LabelStatus.Text = $&amp;quot;计算结果: {result}&amp;quot;;
        });
    });
}

private string LongRunningOperation()
{
    // 模拟耗时操作
    Thread.Sleep(5000);
    return &amp;quot;已完成&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;use-asyncawait-keywords-with-taskrun&#34;&gt;Use &lt;code&gt;async/await&lt;/code&gt; keywords with &lt;code&gt;Task.Run&lt;/code&gt;
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;private async void Button_ClickAsync(object sender, RoutedEventArgs e)
{
    Button button = sender as Button;
    button.IsEnabled = false; // 防止用户重复点击

    try
    {
        // 开启后台任务
        var result = await Task.Run(() =&amp;gt; LongRunningOperation());

        // 在后台任务完成后，自动切换回UI线程更新UI
        LabelStatus.Text = $&amp;quot;计算结果: {result}&amp;quot;;
    }
    catch (Exception ex)
    {
        MessageBox.Show($&amp;quot;发生错误: {ex.Message}&amp;quot;);
    }
    finally
    {
        button.IsEnabled = true; // 重新启用按钮
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>WPF learning materials</title>
        <link>https://ttf248.life/en/p/wpf-learning-resources/</link>
        <pubDate>Tue, 17 Oct 2023 10:49:24 +0800</pubDate>
        
        <guid>https://ttf248.life/en/p/wpf-learning-resources/</guid>
        <description>&lt;p&gt;The pitfalls of mini-program development weren&amp;rsquo;t resolved yet, and now I’m diving into &lt;strong&gt;WPF&lt;/strong&gt;, on top of recent turbulence at the company. Inter-location collaboration and communication have been inefficient, so I’ve taken on client interface development.&lt;/p&gt;
&lt;h2 id=&#34;wpf&#34;&gt;WPF
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Recommended &lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/dotnet/desktop/wpf/introduction-to-wpf?view=netframeworkdesktop-4.8&amp;amp;preserve-view=true&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF Microsoft Official Learning Resources&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Summary of WPF Basics (Learning Suggestions)&lt;/li&gt;
&lt;li&gt;WPF Chinese Website&lt;/li&gt;
&lt;li&gt;Summary and Learning Recommendations for WPF&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Many concepts used in WPF interface design are similar to those in web frontend design. The goal is to separate UI design from business logic as much as possible, allowing the UI to be independent—this is also how internet companies expect tasks to be divided. I just spent some time working on mini-programs this year, and many of the concepts are universal, making it relatively easy to get started. These are considered the &lt;strong&gt;principles&lt;/strong&gt; in modern UI design. Mastering the basic framework concepts will keep you from going astray later on.&lt;/p&gt;
&lt;p&gt;Readers with prior experience in &lt;code&gt;Winform&lt;/code&gt; development are recommended to read: &lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/zh7791/p/11502696.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF Basics Summary (Learning Suggestions)&lt;/a&gt;. It&amp;rsquo;s not a long article and suitable for experienced readers planning their learning path.&lt;/p&gt;
&lt;p&gt;For readers with no prior knowledge, it is recommended to read: &lt;a class=&#34;link&#34; href=&#34;http://www.wpfsoft.com/introduction&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WPF Chinese Net&lt;/a&gt;, which introduces basic concepts, the history of development, and the logic of understanding underlying classes from scratch. It&amp;rsquo;s quite a coincidence that this website was just released by the author in August this year, and it aligns perfectly with our timeline. If it were any later, we probably wouldn’t have had the chance to connect.&lt;/p&gt;
&lt;p&gt;If you want the most authentic learning materials, of course it&amp;rsquo;s the documentation from Microsoft’s official website; it can be a bit dry, so new readers need to have patience&lt;/p&gt;
&lt;p&gt;There are also many classic e-books, but I don&amp;rsquo;t really recommend them. I have a lot of work to do every day, so I don’t have much time to sit down and read. It&amp;rsquo;s difficult to get into the reading mood; practicing with projects is more suitable.&lt;/p&gt;
&lt;h2 id=&#34;c-and-net-release-history&#34;&gt;C# and .NET release history
&lt;/h2&gt;&lt;p&gt;In recent years, there have been quite a few new features released, and the language&amp;rsquo;s version is iterating annually, similar to previously learned languages&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/C_Sharp_%28programming_language%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://en.wikipedia.org/wiki/C_Sharp_(programming_language)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Official learning materials:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/dotnet/csharp/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/dotnet/csharp/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/dotnet/core/tutorials/with-visual-studio?pivots=dotnet-7-0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/dotnet/core/tutorials/with-visual-studio?pivots=dotnet-7-0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        
    </channel>
</rss>
