<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Github Copilot on Uncle Xiang&#39;s Notebook</title>
        <link>https://ttf248.life/en/tags/github-copilot/</link>
        <description>Recent content in Github Copilot on Uncle Xiang&#39;s Notebook</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <lastBuildDate>Mon, 02 Jun 2025 19:00:25 +0800</lastBuildDate><atom:link href="https://ttf248.life/en/tags/github-copilot/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>AI-assisted programming, the evolution of productivity</title>
        <link>https://ttf248.life/en/p/ai-assisted-programming-productivity-evolution/</link>
        <pubDate>Tue, 28 Feb 2023 17:05:17 +0800</pubDate>
        
        <guid>https://ttf248.life/en/p/ai-assisted-programming-productivity-evolution/</guid>
        <description>&lt;p&gt;‚ÄúGitHub Copilot‚Äù was released less than two years ago, and ‚ÄúChatGPT‚Äù has appeared. I don‚Äôt fully understand the underlying principles; I&amp;rsquo;ve been using them for a while. The two tools‚Äô levels of assistance are completely different, but they have both achieved a significant increase in productivity.&lt;/p&gt;
&lt;p&gt;For things that are too complex, AI still can‚Äôt do it ‚Äì after all, they lack logic, or they rely on patterns or fixed frameworks; the training data is sufficient, and AI‚Äôs effect is nine out of ten.&lt;/p&gt;
&lt;h2 id=&#34;github-copilot&#34;&gt;GitHub Copilot
&lt;/h2&gt;&lt;p&gt;When publishing, I looked at the official introduction‚Äôs ‚Äúdemo‚Äù and found it wasn&amp;rsquo;t very smart. After trying it out, it wasn‚Äôt great, so I gave up on it.&lt;/p&gt;
&lt;p&gt;Before 2022, when I had some free time, I switched to the new version to try it out, and the effect was already quite good. The only issue was that the speed in China was a bit slow, which was probably due to network reasons. For languages like &lt;code&gt;Python&lt;/code&gt;, the code generated based on comments was pretty good, and much faster than researching and writing code myself.&lt;/p&gt;
&lt;h2 id=&#34;chatgpt&#34;&gt;ChatGPT
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Github Copilot&lt;/code&gt; still focused on developers, i.e., from a development perspective when designing the product. You need to understand how programming works and guide AI assistance through comments gradually. &lt;code&gt;ChatGPT&lt;/code&gt; has moved to the next level, &lt;strong&gt;allowing non-experts to quickly get started&lt;/strong&gt;. With its conversational chat interface, you can simply pose questions, describe requirements, and ask for clarification if you don&amp;rsquo;t understand something. Here‚Äôs a translation of the provided text into English:&lt;/p&gt;
&lt;p&gt;‚ÄúLet&amp;rsquo;s take an example to understand the concept of tokenization, but don&amp;rsquo;t know how to code it. We want to calculate the similarity between two strings:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Python tokenize and calculate the similarity between &amp;quot;Weitian Yuntong&amp;quot;, &amp;quot;LOGORY&amp;quot; and &amp;quot;Hefei Weitian Yuntong Information Technology Co., Ltd.&amp;quot;;
Before comparison, standardize the strings by converting English to lowercase;
If the second string contains the first string&#39;s starting character, truncate the second string to a length equal to the first string‚Äôs length.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hello, this is Bing. üòä&lt;/p&gt;
&lt;p&gt;According to online information 123, Python tokenization can be implemented using the jieba library. The jieba library supports three tokenization modes: precise mode, full-potential mode, and search engine mode. You can choose an appropriate mode based on your needs.‚Äù To compare the similarity of two strings, you first need to tokenize them and then calculate metrics such as word vectors or edit distance. You can use libraries like NumPy or SciPy for performing mathematical operations.&lt;/p&gt;
&lt;h2 id=&#34;chatgpt-1&#34;&gt;ChatGPT
&lt;/h2&gt;&lt;p&gt;To standardize string processing, converting to lowercase in English can be achieved using Python&amp;rsquo;s built-in &lt;code&gt;lower()&lt;/code&gt; function.
To extract the second string, you can use Python‚Äôs slicing operator [ ] to achieve this.
Below is a possible code example:&lt;/p&gt;
&lt;h2 id=&#34;chatgpt-2&#34;&gt;ChatGPT
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import jieba
import numpy as np
from scipy.spatial.distance import cosine

# Define two strings
str1 = &amp;quot;Á∂≠Â§©ÈÅãÈÄö LOGORY&amp;quot;
str2 = &amp;quot;ÂêàËÇ•Á∂≠Â§©ÈÅãÈÄö‰ø°ÊÅØÁßëÊäÄËÇ°‰ªΩÊúâÈôêÂÖ¨Âè∏&amp;quot;

# Normalize strings, convert English to lowercase
str1 = str1.lower()
str2 = str2.lower()

# Find the position of the first character of str1 in str2
index = str2.find(str1[0])

# If found, slice str2
if index != -1:
    str2 = str2[index:index+len(str1)]

# Use jieba library to tokenize strings
words1 = list(jieba.cut(str1))
words2 = list(jieba.cut(str2))

# Calculate word vectors (using frequency as weights)
vector1 = np.zeros(len(words1))
vector2 = np.zeros(len(words1))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;chatgpt-3&#34;&gt;ChatGPT
&lt;/h2&gt;&lt;h1 id=&#34;calculate-the-word-vectors-of-two-strings-with-frequency-as-weight&#34;&gt;Calculate the word vectors of two strings (with frequency as weight)
&lt;/h1&gt;&lt;p&gt;vector1 = np.zeros(len(words1))
vector2 = np.zeros(len(words1))&lt;/p&gt;
&lt;p&gt;for i, word in enumerate(words1):
vector1[i] += 1  # Count the number of times each word appears in the first string
if word in words2:
vector2[i] += 1  # Count the number of times each word appears in the second string&lt;/p&gt;
&lt;h1 id=&#34;calculate-the-similarity-between-the-two-strings-using-cosine-distance-as-an-index&#34;&gt;Calculate the similarity between the two strings (using cosine distance as an index)
&lt;/h1&gt;&lt;p&gt;similarity = 1 - cosine(vector1, vector2)&lt;/p&gt;
&lt;p&gt;print(&amp;ldquo;The similarity between the two strings is:&amp;rdquo;, similarity)&lt;/p&gt;
&lt;h2 id=&#34;chatgpt-4&#34;&gt;ChatGPT
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Going Further ‚Äì Consult the Execution Results. Congratulations, you‚Äôve identified an issue! The result was hallucinated; it didn&amp;rsquo;t actually run the code, but will provide a good-looking response.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;example&#34;&gt;Example
&lt;/h3&gt;&lt;p&gt;Question: SQL statement to retrieve records from the product code table where the product code is within the range of 80000-89999.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;Hello, this is Bing. üòä

Based on search result 12, you can use the SQL BETWEEN operator to select values within a given range. The BETWEEN operator includes both the start and end values.

You need to first specify the table name and column name that you want to query, and then use the BETWEEN operator and the range values in the WHERE clause.

For example, if you want to retrieve records from the product code table where the product code is between 80000 and 89999, you can use the following statement:

SELECT * FROM product_code
WHERE code BETWEEN 80000 AND 89999;
Here, * represents selecting all columns 3.
``` If you only want to select specific columns, such as product name and price, you can separate them with commas like this:

SELECT name, price FROM product_code
WHERE code BETWEEN 80000 AND 89999;

Hopefully, this helps.

Please note that product codes are strings, and your code is incorrect.

### Example

```markdown
Sorry, I didn‚Äôt realize the product code was a string. If that‚Äôs the case, you need to add single quotes around both ends of the range values, as follows:

SELECT * FROM product_code
WHERE code BETWEEN &#39;80000&#39; AND &#39;89999&#39;;
Please forgive my mistake. üôè
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Congratulations, it recognizes errors!&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
