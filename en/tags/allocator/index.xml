<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Allocator on Uncle Xiang&#39;s Notebook</title>
        <link>https://ttf248.life/en/tags/allocator/</link>
        <description>Recent content in Allocator on Uncle Xiang&#39;s Notebook</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <lastBuildDate>Sun, 25 May 2025 02:57:45 +0800</lastBuildDate><atom:link href="https://ttf248.life/en/tags/allocator/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Allocator for standard library containers</title>
        <link>https://ttf248.life/en/p/standard-library-container-memory-allocator/</link>
        <pubDate>Mon, 30 Dec 2019 13:26:19 +0800</pubDate>
        
        <guid>https://ttf248.life/en/p/standard-library-container-memory-allocator/</guid>
        <description>&lt;p&gt;Custom allocators can improve performance, increase memory efficiency, and solve problems related to frequent small memory allocations&lt;/p&gt;
&lt;h4 id=&#34;cause&#34;&gt;Cause
&lt;/h4&gt;&lt;p&gt;Recently, I&amp;rsquo;ve been working on network packet development and frequently need to allocate and release small blocks of memory. I initially thought about using a memory pool, but after reviewing several existing ones, I found this&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/cacay/MemoryPool&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/cacay/MemoryPool&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Seeing the interface, I was a bit puzzled – the implementation of this memory pool seems a little strange. The &lt;code&gt;MemoryPool&lt;/code&gt;&amp;rsquo;s implementation logic allocates fixed-size memory spaces. Having looked at the boost memory pool interface, it provides a template that is instantiated when used. Fortunately, there are already articles introducing this library, mentioning the concept of &lt;code&gt;allocator&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;wikihttpszhwikipediaorgwikie58886e9858de599a8_c2b2b&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_%28C%2B%2B%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wiki&lt;/a&gt;
&lt;/h4&gt;&lt;p&gt;In C++ programming, an allocator (in English: allocator) is an important component of the C++ standard library. The C++ library defines various data structures collectively referred to as &amp;ldquo;containers&amp;rdquo; (such as linked lists, sets, etc.), and a common feature of these containers is that their size can change at runtime; to achieve this, dynamic memory allocation becomes particularly necessary, and allocators are used to handle the container&amp;rsquo;s memory allocation and release requests. In other words, an allocator encapsulates the low-level details of memory management for Standard Template Library (STL) containers. By default, the C++ standard library uses its own built-in general allocator, but according to specific needs, programmers can also customize allocators to replace it.&lt;/p&gt;
&lt;p&gt;The allocator was originally invented by Alexander Stepanov as part of the C++ Standard Template Library (STL), with the initial goal of creating a way to &amp;ldquo;make the library more flexible and independent of the underlying data model,&amp;rdquo; allowing programmers to utilize custom pointer and reference types within the library; however, when incorporating the Standard Template Library into the C++ standard, the C++ Standards Committee realized that complete abstraction of the data model would result in unacceptable performance losses. As a compromise, the restrictions on allocators in the standard became stricter, and as a result, the current standard describes allocators with significantly less customizability than Stepanov originally envisioned.&lt;/p&gt;
&lt;p&gt;Although there are limitations on allocator customization, custom allocators are often necessary in many cases, typically to encapsulate access methods for different types of memory spaces (such as shared memory and recycled memory) or to improve performance when using memory pools for memory allocation. In addition, introducing a dedicated custom allocator in programs that frequently allocate small amounts of memory can also be greatly beneficial from the perspectives of memory usage and runtime.&lt;/p&gt;
&lt;h4 id=&#34;requirements&#34;&gt;Requirements
&lt;/h4&gt;&lt;p&gt;One of the primary reasons for defining custom allocators is to improve performance. Utilizing a dedicated custom allocator can enhance program performance, or increase memory efficiency, or both [4][8]. The default allocator allocates storage space using the new operator, which is often implemented using C language heap allocation functions (malloc()) [Wen 5]. Because heap allocation functions are often optimized for occasional large memory allocations, the default allocator generally performs well when allocating memory for containers that require a large amount of memory to be allocated at once (such as vectors and double-ended queues) [8]. However, for associative containers and doubly linked lists, which require frequent allocation of small amounts of memory, using the default allocator can often result in low efficiency [4][9]. In addition, malloc()-based default allocators have many problems, such as poor locality of reference [4] and potential memory fragmentation [4][9].&lt;/p&gt;
&lt;p&gt;In short, this section (……) is like a &amp;ldquo;I Have a Dream&amp;rdquo; speech for this standard regarding allocators. Before the dream comes true, programmers concerned with portability will limit themselves to stateless custom allocators.
——Scott Meyers, 《Effective STL》
In light of this, in such situations, memory pool allocators are often used to address the problem of frequent small allocations [8]. Unlike the default &amp;ldquo;on-demand allocation&amp;rdquo; approach, when using a memory pool allocator, the program pre-allocates a large block of memory (the &amp;ldquo;memory pool&amp;rdquo;), and then, when memory is requested, the custom allocator simply returns a pointer to memory within the pool; during object destruction, no actual deallocation is required, but it is delayed until the end of the memory pool&amp;rsquo;s lifecycle [Note 1][8].&lt;/p&gt;
&lt;p&gt;The topic of &amp;ldquo;custom allocators&amp;rdquo; has seen considerable discussion among C++ experts and authors, such as Scott Meyers&amp;rsquo; work &amp;ldquo;Effective STL&amp;rdquo; and Andrei Alexandrescu&amp;rsquo;s &amp;ldquo;Modern C++ Design.&amp;rdquo; Meyers observed that if you require all instances of an allocator for a given type T to be equal, then the allocator instances must not contain state. Although the C++ standard encourages library implementers to support allocators with state [Reference 4], Meyers calls this related passage a “seemingly wonderful idea” but also almost empty talk, and he considers the restriction on allocators &amp;ldquo;too strict&amp;rdquo; [4]. For example, STL&amp;rsquo;s list allows the splice method, where nodes of one list object A can be directly moved into another list object B, which requires that the memory allocated by A’s allocator can be released by B’s allocator, thus inferring that the allocator instances of A and B must be equal. Meyers concludes that allocators are best defined as types using static methods. For example, according to the C++ standard, an allocator must provide an other class template that implements the rebind method.&lt;/p&gt;
&lt;p&gt;Additionally, in &amp;ldquo;The C++ Programming Language,&amp;rdquo; Bjarne Stroustrup argues that “&amp;lsquo;strictly limiting the allocator to avoid different object information&amp;rsquo; is clearly not a big deal” (in essence) and points out that most allocators do not need state, and performance may even be better in the absence of state. He proposes three use cases for custom allocators: memory pool-based allocators, shared memory allocators, and garbage collection allocators, and demonstrates an implementation of an allocator that utilizes an internal memory pool to quickly allocate/deallocate small amounts of memory. However, he also mentions that such optimization may already be implemented in the sample allocator he provides [3].&lt;/p&gt;
&lt;p&gt;Another use of a custom allocator is debugging memory-related errors [10]. To do this, you can write an allocator that allocates extra memory when allocating, and use it to store debug information. This type of allocator not only ensures that memory is allocated/deallocated by the same allocator, but also protects the program from cache overflows to a certain extent [11].&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
