<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>调试 on 向叔记事簿</title>
        <link>https://ttf248.life/tags/debugging/</link>
        <description>Recent content in 调试 on 向叔记事簿</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language><atom:link href="https://ttf248.life/tags/debugging/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>跨机器计算时间差</title>
        <link>https://ttf248.life/p/cross-machine-computation-time-difference/</link>
        <pubDate>Thu, 19 Jun 2025 09:45:36 +0800</pubDate>
        
        <guid>https://ttf248.life/p/cross-machine-computation-time-difference/</guid>
        <description>&lt;p&gt;组内现有通讯协议使用 &lt;code&gt;steady_clock&lt;/code&gt; 作为时间戳，计算单个节点的耗时，某个特殊场景，用到了消息包自带的时间戳，&lt;strong&gt;自带&lt;/strong&gt;的时间戳来自于其他机器，导致计算出来的耗时异常。&lt;/p&gt;
&lt;p&gt;题话外：Gemini2.5 Pro 有希望彻底超越 GPT-4&lt;/p&gt;
&lt;h2 id=&#34;问题排查&#34;&gt;问题排查
&lt;/h2&gt;&lt;p&gt;开始也没注意到底层时间戳计算的问题，就想着停掉所有服务，仅从本地接入，分析下日志。发现有个服务一直停不掉，持续的在发送业务数据，没辙，按照通讯端口抓包定位机器的位置。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo tcpdump -nni any -B 4096 -s 0 -w tmp.pcap port 13100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内部网络情况复杂，消息经过了代理转发，先从服务本机抓包，使用 &lt;code&gt;tcpdump&lt;/code&gt; 抓取端口 13100 的数据包。然后切换到代理服务器上，抓取端口 13100 的数据包。&lt;/p&gt;
&lt;p&gt;分析发现，耗时异常的请求，都来自深圳办公室，排查问题的服务，都部署在上海办公室。&lt;/p&gt;
&lt;h2 id=&#34;steady_clock-和-system_clock-的区别&#34;&gt;steady_clock 和 system_clock 的区别
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;std::steady_clock&lt;/code&gt; 和 &lt;code&gt;std::system_clock&lt;/code&gt; 是 C++ 中用于处理时间的两种主要时钟。它们有以下关键区别：&lt;/p&gt;
&lt;h3 id=&#34;stdsystem_clock&#34;&gt;std::system_clock
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;代表“墙上时间” (Wall Clock Time)&lt;/strong&gt;：它表示的是系统范围内的、现实世界的时间。这个时间与操作系统显示的时间是一致的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可以被调整&lt;/strong&gt;：这个时钟的时间可以被用户或系统服务（如 NTP 网络时间协议）向前或向后调整。例如，如果你手动修改系统时间，或者系统与时间服务器同步，&lt;code&gt;system_clock&lt;/code&gt; 的值会发生跳变。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不适合测量时间间隔&lt;/strong&gt;：由于它可能向后跳变，用它来计算两个时间点之间的时间差可能会得到负数或不准确的结果。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主要用途&lt;/strong&gt;：获取当前的日历时间，用于需要与现实世界时间对应的场景（例如，日志记录时间戳）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;stdsteady_clock&#34;&gt;std::steady_clock
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单调递增时钟 (Monotonic Clock)&lt;/strong&gt;：这个时钟从某个起点开始，只会稳定地向前移动，永远不会减少。它的速率可能是固定的，也可能不是（尽管通常是）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不可被调整&lt;/strong&gt;：&lt;code&gt;steady_clock&lt;/code&gt; 不受系统时间变化的影响。即使用户修改了系统时间，它也会继续稳定地向前走。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最适合测量时间间隔&lt;/strong&gt;：由于其单调性，它是测量代码执行时间、超时等待等场景的最佳选择，可以保证结果的准确性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;起点不确定&lt;/strong&gt;：它的起始时间点（epoch）通常是系统启动时，但这并没有被标准所保证。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;不同机器上的-steady_clock-一样吗&#34;&gt;不同机器上的 &lt;code&gt;steady_clock&lt;/code&gt; 一样吗？
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;不一样。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;steady_clock&lt;/code&gt; 的值在不同机器之间是&lt;strong&gt;没有可比性的&lt;/strong&gt;。甚至在同一台机器的两次不同启动之间，它的值也是不可比的。&lt;/p&gt;
&lt;p&gt;因为它的设计初衷就是为了在&lt;strong&gt;单次程序运行中&lt;/strong&gt;精确地测量时间段，而不是为了表示一个绝对的时间点。它的起点（epoch）是未定义的，并且在不同的系统或不同的启动会话中几乎肯定是不同的。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;特性&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;code&gt;system_clock&lt;/code&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;code&gt;steady_clock&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;类型&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;墙上时钟&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单调时钟&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;是否可调整&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;是，可以向前或向后跳变&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;否，只会向前移动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;主要用途&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;获取当前日历时间&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;测量时间间隔、超时&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;跨机器/重启比较&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可以（同步后）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;不可以&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;简单来说&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要知道“现在几点了？”，用 &lt;code&gt;system_clock&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;需要知道“这段代码运行了多久？”，用 &lt;code&gt;steady_clock&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>后台服务TCP通讯异常排查</title>
        <link>https://ttf248.life/p/backend-service-tcp-communication-troubleshooting/</link>
        <pubDate>Fri, 14 Feb 2025 22:54:13 +0800</pubDate>
        
        <guid>https://ttf248.life/p/backend-service-tcp-communication-troubleshooting/</guid>
        <description>&lt;p&gt;业务模型：后台服务借助 TCP 与集团的行情网关建立连接。每次连接时，需先行发送一个授权请求，随后持续发送心跳包以维持连接状态。
然而，某一天，收到了服务断开连接的告警信息。通过仔细排查日志后发现，后台服务一直在持续发送心跳包，但对方却毫无回应，可连接却始终未断开。&lt;/p&gt;
&lt;h2 id=&#34;现场简述&#34;&gt;现场简述
&lt;/h2&gt;&lt;p&gt;原本正在公司加班推进项目进度，工作群里突然弹出告警信息。乍一看，我还以为是老毛病，大概率是网络超时致使心跳发送失败，进而导致服务断开连接。可在仔细排查日志后，却发现实际情况并非如此。后台已发送了授权登录消息，然而一直未收到应答，与此同时，心跳包仍在持续不断地发送，对方却始终未回复任何心跳数据。经过对日志的深入分析，暴露出了以下几个关键问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;授权消息无应答：极有可能是对方系统正在重启，使得授权消息未能得到及时处理。&lt;/li&gt;
&lt;li&gt;未成功授权却发送心跳数据：经排查，发现这是程序逻辑上的漏洞。心跳发送函数的判断逻辑存在缺陷，仅仅校验了连接状态，却遗漏了对授权状态的校验。&lt;/li&gt;
&lt;li&gt;服务未断开连接：若服务能够断开连接，便可以触发重连机制，从而重新发送授权消息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前，还剩下最后一个亟待解决的问题——为何服务没有断开连接。这一问题的解决需要开展更为深入细致的排查工作。&lt;/p&gt;
&lt;h2 id=&#34;分析网络数据包&#34;&gt;分析网络数据包
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;tcpdump&lt;/code&gt; 是一个非常强大的网络抓包工具，可以用来捕获网络数据包。通过分析网络数据包，我们可以更加直观地了解网络通信的细节。在这里，我们可以使用 &lt;code&gt;tcpdump&lt;/code&gt; 来捕获网络数据包，以便进一步分析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/backend-service-tcp-communication-troubleshooting/20250220151952.png&#34;
	width=&#34;1126&#34;
	height=&#34;202&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;tcpdump&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;557&#34;
		data-flex-basis=&#34;1337px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;分析图中的数据，我可以看到心跳一直在正常发送，对方服务器并没有回复任何数据，但是给了 &lt;code&gt;ACK&lt;/code&gt;，这就导致连接不会主动断开了。&lt;/p&gt;
&lt;h2 id=&#34;常见标志位说明&#34;&gt;常见标志位说明
&lt;/h2&gt;&lt;p&gt;在 TCP 协议中，&lt;code&gt;PSH&lt;/code&gt;（Push）和 &lt;code&gt;ACK&lt;/code&gt;（Acknowledgment）是两个重要的标志位，分别用于控制数据传输和流量确认。它们的作用如下：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;1-pshpush-flag&#34;&gt;&lt;strong&gt;1. PSH（Push Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：&lt;br&gt;
&lt;code&gt;PSH&lt;/code&gt; 标志位的作用是&lt;strong&gt;请求接收方立即将缓冲区中的数据推送给上层应用&lt;/strong&gt;（而不是等待缓冲区填满）。这意味着一旦收到带有 &lt;code&gt;PSH&lt;/code&gt; 标志的数据段，接收方会尽可能快地处理并传递给应用程序，而非暂存于操作系统缓冲区中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;典型场景&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTTP/HTTPS 请求&lt;/strong&gt;：客户端发送请求时（如 &lt;code&gt;GET /index.html&lt;/code&gt;）会设置 &lt;code&gt;PSH&lt;/code&gt;，希望服务器立即响应。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SSH 协议&lt;/strong&gt;：每次键盘输入都会触发 &lt;code&gt;PSH&lt;/code&gt;，确保输入字符实时传输。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实时通信&lt;/strong&gt;：视频流、在线游戏等低延迟场景可能使用 &lt;code&gt;PSH&lt;/code&gt; 减少延迟。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PSH&lt;/code&gt; 并非强制要求，接收方可以选择忽略该标志位（但仍需正常处理数据）。&lt;/li&gt;
&lt;li&gt;发送方可能不设置 &lt;code&gt;PSH&lt;/code&gt;，此时接收方会根据自身缓冲策略决定何时推送数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2-ackacknowledgment-flag&#34;&gt;&lt;strong&gt;2. ACK（Acknowledgment Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：&lt;br&gt;
&lt;code&gt;ACK&lt;/code&gt; 标志位表示&lt;strong&gt;确认已正确接收前序数据段&lt;/strong&gt;。每个 &lt;code&gt;ACK&lt;/code&gt; 包含一个确认号（&lt;code&gt;Acknowledgment Number&lt;/code&gt;），表示期望接收的下一个字节序号。它是 TCP 可靠传输的核心机制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;工作原理&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送方发送数据段时，会携带期望接收方的 &lt;code&gt;ACK&lt;/code&gt; 值（例如 &lt;code&gt;ACK = 序列号 + 数据长度&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;接收方收到数据后，会生成一个 &lt;code&gt;ACK&lt;/code&gt; 报文段，确认已接收的数据序号。&lt;/li&gt;
&lt;li&gt;发送方只有在收到对应的 &lt;code&gt;ACK&lt;/code&gt; 后，才会重传未被确认的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若发送方发送了序号为 &lt;code&gt;100~199&lt;/code&gt; 的数据段，则期望接收方的 &lt;code&gt;ACK&lt;/code&gt; 应为 &lt;code&gt;200&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;若接收方未收到 &lt;code&gt;100~199&lt;/code&gt; 中的某些数据，会通过 &lt;code&gt;ACK=150&lt;/code&gt; 告知发送方重传。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;3-psh-和-ack-的组合&#34;&gt;&lt;strong&gt;3. PSH 和 ACK 的组合&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;在 TCP 报文中，&lt;code&gt;PSH&lt;/code&gt; 和 &lt;code&gt;ACK&lt;/code&gt; 可以同时出现，常见于以下场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;HTTP 请求响应&lt;/strong&gt;：&lt;br&gt;
客户端发送 &lt;code&gt;POST&lt;/code&gt; 请求时（含数据），会设置 &lt;code&gt;PSH&lt;/code&gt; 和 &lt;code&gt;ACK&lt;/code&gt;（确认之前的响应）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Client → Server: SYN, ACK=1 → 建立连接
Client → Server: PSH, ACK=1, 数据 → 发送请求数据
Server → Client: PSH, ACK=数据长度+1 → 返回响应
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SSH 握手后传输命令&lt;/strong&gt;：&lt;br&gt;
客户端输入命令后，发送带有 &lt;code&gt;PSH&lt;/code&gt; 和 &lt;code&gt;ACK&lt;/code&gt; 的数据段，确保命令立即传输并被服务器处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;4-其他标志位的关联&#34;&gt;&lt;strong&gt;4. 其他标志位的关联&lt;/strong&gt;
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标志位&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;简要说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SYN&lt;/td&gt;
&lt;td&gt;同步&lt;/td&gt;
&lt;td&gt;初始化连接（三次握手）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FIN&lt;/td&gt;
&lt;td&gt;结束&lt;/td&gt;
&lt;td&gt;优雅关闭连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RST&lt;/td&gt;
&lt;td&gt;复位&lt;/td&gt;
&lt;td&gt;强制终止连接（异常情况）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;URG&lt;/td&gt;
&lt;td&gt;紧急&lt;/td&gt;
&lt;td&gt;标记紧急指针（极少使用）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h3 id=&#34;总结&#34;&gt;&lt;strong&gt;总结&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;PSH&lt;/strong&gt; 关注的是&lt;strong&gt;数据尽快到达应用层&lt;/strong&gt;，降低延迟。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ACK&lt;/strong&gt; 关注的是&lt;strong&gt;数据的可靠传输&lt;/strong&gt;，避免丢包或乱序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两者协同工作，平衡了 TCP 协议的效率和可靠性。&lt;/p&gt;</description>
        </item>
        <item>
        <title>visual studio 加载“不配套”的 pdb 文件</title>
        <link>https://ttf248.life/p/visual-studio-load-unmatched-pdb/</link>
        <pubDate>Thu, 23 Jan 2025 20:04:33 +0800</pubDate>
        
        <guid>https://ttf248.life/p/visual-studio-load-unmatched-pdb/</guid>
        <description>&lt;p&gt;windows 下，使用 visual studio 调试程序时，如果 pdb 文件与可执行文件不匹配，visual studio 会提示“无法加载符号文件”。程序运行发生崩溃，落地 dump 文件，如果是不匹配的 pdb 文件，visual studio 也无法顺利的进入崩溃现场。&lt;/p&gt;
&lt;h2 id=&#34;什么是-pdb-文件&#34;&gt;什么是 pdb 文件
&lt;/h2&gt;&lt;p&gt;PDB 文件是微软的一种调试信息文件，用于调试程序。PDB 文件包含了程序的符号表、源代码文件名、行号等信息。在程序编译时，可以生成 PDB 文件，用于调试程序。&lt;/p&gt;
&lt;h2 id=&#34;windbg-调试&#34;&gt;WinDbg 调试
&lt;/h2&gt;&lt;p&gt;WinDbg 是微软的一款调试工具，可以用于调试 windows 程序。WinDbg 可以加载不匹配的 pdb 文件，但是需要手动加载。&lt;code&gt;.reload /f /i&lt;/code&gt; 命令可以强制加载不匹配的 pdb 文件。&lt;/p&gt;
&lt;p&gt;但是 WinDbg 使用起来不如 visual studio 方便，所以我们希望 visual studio 也能加载不匹配的 pdb 文件。&lt;/p&gt;
&lt;h2 id=&#34;visual-studio-加载不匹配的-pdb-文件&#34;&gt;visual studio 加载不匹配的 pdb 文件
&lt;/h2&gt;&lt;p&gt;源码现在一般都是通过 git 管理，完全能找到对应版本的代码，重新编译，生成对应的 pdb 文件。为什么无法加载呢？主要是一些元数据无法匹配。&lt;/p&gt;
&lt;p&gt;有个小工具，可以修改元数据，基于 exe 文件信息，生成一个新的 pdb 文件，使得 visual studio 能够加载。&lt;/p&gt;
&lt;p&gt;chkmatch 下载地址：&lt;a class=&#34;link&#34; href=&#34;https://www.debuginfo.com/tools/chkmatch.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.debuginfo.com/tools/chkmatch.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;站点缓存地址：&lt;a class=&#34;link&#34; href=&#34;chkmatch.zip&#34; &gt;chkmatch.zip&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ChkMatch utility can be used to check whether an executable and debug information file match. It can also be used to enforce matching between an executable and debug information file, if they are compatible.

For more information about debug information matching and related issues, see this article.

Supported debug information formats: DBG, PDB 2.0, PDB 7.0.

chkmatch [-c ExeFile DebugInfoFile ] |
         [-m ExeFile DebugInfoFile]
-c
Check matching between the executable and the debug information file.
-m
Make the executable and the debug information file match.
ExeFile
The name of the executable file.
DebugInfoFile
The name of the debug information file.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;使用-chkmatch&#34;&gt;使用 chkmatch
&lt;/h2&gt;&lt;p&gt;先执行检查操作，分析不匹配的原因，提示签名不匹配。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\tianlong.xiang\Downloads\chkmatch&amp;gt;ChkMatch.exe -c &amp;quot;D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe&amp;quot; E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb
ChkMatch - version 1.0
Copyright (C) 2004 Oleg Starodumov
http://www.debuginfo.com/


Executable: D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe
Debug info file: E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb

Executable:
TimeDateStamp: c26d9be3
Debug info: 2 ( CodeView )
TimeStamp: f86b0a4f  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 122  RVA: 001cdc44  FileOffset: 001cbe44
CodeView format: RSDS
Signature: {428c9b95-39a3-4a8d-a8e5-7be453684757}  Age: 1
PdbFile: D:\stock_UAT\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\obj\Release\YinTrade.Main.pdb
Debug info: 16 ( Unknown )
TimeStamp: 00000000  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 0  RVA: 00000000  FileOffset: 00000000

Debug information file:
Format: PDB 7.00
Signature: {06fae08e-c0a2-4f3d-9c7c-dfc684445dd1}  Age: 1

Result: Unmatched (reason: Signature mismatch)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后执行修改操作，使得 pdb 文件与 exe 文件匹配。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:\Users\tianlong.xiang\Downloads\chkmatch&amp;gt;ChkMatch.exe -m &amp;quot;D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe&amp;quot; E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb
ChkMatch - version 1.0
Copyright (C) 2004 Oleg Starodumov
http://www.debuginfo.com/


Executable: D:\Program Files\Rolan\trade\UAT_YinStrade\YinTrade.Main.exe
Debug info file: E:\YinTech\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\bin\Release\YinTrade.Main.pdb

Executable:
TimeDateStamp: c26d9be3
Debug info: 2 ( CodeView )
TimeStamp: f86b0a4f  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 122  RVA: 001cdc44  FileOffset: 001cbe44
CodeView format: RSDS
Signature: {428c9b95-39a3-4a8d-a8e5-7be453684757}  Age: 1
PdbFile: D:\stock_UAT\ykcz_securities_trading_client\Sec_Trade\YinTrade.Main\obj\Release\YinTrade.Main.pdb
Debug info: 16 ( Unknown )
TimeStamp: 00000000  Characteristics: 0  MajorVer: 0  MinorVer: 0
Size: 0  RVA: 00000000  FileOffset: 00000000

Debug information file:
Format: PDB 7.00
Signature: {06fae08e-c0a2-4f3d-9c7c-dfc684445dd1}  Age: 1

Writing to the debug information file...
Result: Success.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/38147487/forcing-to-load-unmatched-symbols-in-visual-studio-2015-debugger&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;forcing-to-load-unmatched-symbols-in-visual-studio-2015-debugger&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        
    </channel>
</rss>
