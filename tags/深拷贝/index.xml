<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>深拷贝 on 向叔记事簿</title>
        <link>https://ttf248.life/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/</link>
        <description>Recent content in 深拷贝 on 向叔记事簿</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Sat, 28 Feb 2026 18:34:49 +0800</lastBuildDate><atom:link href="https://ttf248.life/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Python 字典存储自定义对象：引用与深拷贝的重要性</title>
        <link>https://ttf248.life/p/python-dictionary-custom-objects-reference-vs-deepcopy/</link>
        <pubDate>Fri, 22 Mar 2024 01:08:05 +0800</pubDate>
        
        <guid>https://ttf248.life/p/python-dictionary-custom-objects-reference-vs-deepcopy/</guid>
        <description>&lt;p&gt;在 Python 编程中，字典是一种非常强大的数据结构，它允许我们将键值对关联起来，并以高效的方式查找和操作这些数据。当我们尝试在字典中存储自定义对象时，通常会遇到一个关键概念：Python 中的对象赋值实际上是引用赋值，而非对象本身的深拷贝。这意味着将自定义对象放入字典时，字典中存储的是对该对象的引用，而非对象的一个全新副本。&lt;/p&gt;
&lt;h2 id=&#34;存储自定义对象的基本示例&#34;&gt;存储自定义对象的基本示例
&lt;/h2&gt;&lt;p&gt;假设我们有一个简单的 &lt;code&gt;Person&lt;/code&gt; 类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

# 创建一个 Person 对象
p1 = Person(&amp;quot;Alice&amp;quot;, 30)

# 将对象存储到字典中
people_dict = {}
people_dict[&amp;quot;alice&amp;quot;] = p1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个例子中，&lt;code&gt;people_dict&lt;/code&gt; 字典现在包含一个键为 &lt;code&gt;&amp;quot;alice&amp;quot;&lt;/code&gt; 的项，其值是对 &lt;code&gt;Person&lt;/code&gt; 类型的 &lt;code&gt;p1&lt;/code&gt; 对象的引用。如果我们修改 &lt;code&gt;p1&lt;/code&gt; 的属性：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;p1.age = 31
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么通过字典访问这个对象时，我们会发现其年龄也被更新了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(people_dict[&amp;quot;alice&amp;quot;].age)  # 输出：31
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是因为字典中存储的并不是 &lt;code&gt;Person&lt;/code&gt; 对象的独立副本，而是指向同一内存地址的引用。&lt;/p&gt;
&lt;h2 id=&#34;深拷贝与浅拷贝的区别&#34;&gt;深拷贝与浅拷贝的区别
&lt;/h2&gt;&lt;p&gt;在涉及嵌套数据结构或自定义对象时，这种引用行为可能会导致意外的结果。例如，如果自定义对象中包含可变类型的属性（如列表或另一个自定义对象），直接将这样的对象存入字典并对其进行修改，会影响到通过字典获取的对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Address:
    def __init__(self, street, city):
        self.street = street
        self.city = city

class Person:
    def __init__(self, name, age, address):
        self.name = name
        self.age = age
        self.address = address

address = Address(&amp;quot;Main St.&amp;quot;, &amp;quot;Springfield&amp;quot;)
p1 = Person(&amp;quot;Bob&amp;quot;, 40, address)
people_dict[&amp;quot;bob&amp;quot;] = p1

# 修改原始地址对象
address.city = &amp;quot;Shelbyville&amp;quot;

# 字典中的人的地址也变了
print(people_dict[&amp;quot;bob&amp;quot;].address.city)  # 输出：Shelbyville
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解决办法：深拷贝&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了避免这种共享状态带来的问题，有时我们需要确保字典存储的是对象的一个完整副本，而不是引用。Python 提供了 &lt;code&gt;copy&lt;/code&gt; 模块中的 &lt;code&gt;deepcopy&lt;/code&gt; 函数来实现这一目标：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import copy

# 使用深拷贝存储对象
people_dict[&amp;quot;bob_deepcopy&amp;quot;] = copy.deepcopy(p1)

# 此时即使修改原始地址对象，深拷贝的对象不会受影响
address.city = &amp;quot;Capital City&amp;quot;
print(people_dict[&amp;quot;bob&amp;quot;].address.city)  # 输出：Capital City
print(people_dict[&amp;quot;bob_deepcopy&amp;quot;].address.city)  # 输出：Shelbyville
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总之，在 Python 中利用字典存储自定义对象时，务必注意默认情况下存储的是对象引用。对于那些需要保持独立状态的情况，请使用 &lt;code&gt;deepcopy&lt;/code&gt; 进行深拷贝，以避免因共享引用而导致的意料之外的数据变化。&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
