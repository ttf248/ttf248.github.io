<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>windows on 向叔记事簿</title>
        <link>https://ttf248.life/tags/windows/</link>
        <description>Recent content in windows on 向叔记事簿</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language><atom:link href="https://ttf248.life/tags/windows/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>本地开发之痛：为何 `nul` 文件删不掉？一个“复合型”文件系统难题的破解之道</title>
        <link>https://ttf248.life/p/local-development-pain-why-cant-you-delete-nul-files-a-solution-to-the-composite-file-system-problem/</link>
        <pubDate>Sat, 08 Nov 2025 16:37:46 +0800</pubDate>
        
        <guid>https://ttf248.life/p/local-development-pain-why-cant-you-delete-nul-files-a-solution-to-the-composite-file-system-problem/</guid>
        <description>&lt;p&gt;在软件开发的日常工作中，我们时常会遇到一些棘手的“小问题”，它们看似简单，却能耗费我们数小时的宝贵时间。其中，在 Windows 系统上删除特定文件（尤其是那些由开发工具链意外生成的文件）无疑是“重灾区”之一。&lt;/p&gt;
&lt;p&gt;我就遇到了这样一个“地狱级”的难题：在本地开发时，项目中莫名其妙地出现了一个名为 &lt;code&gt;nul&lt;/code&gt; 的文件。我尝试了 Windows 资源管理器、CMD 命令行，但系统都提示“找不到文件”或“无法删除”。这个文件就像一个幽灵，顽固地盘踞在我的项目目录中。&lt;/p&gt;
&lt;h2 id=&#34;阶段一常规尝试与标准的无效解法&#34;&gt;阶段一：常规尝试与“标准”的无效解法
&lt;/h2&gt;&lt;p&gt;当我遇到这个问题时，我的第一反应是“&lt;code&gt;nul&lt;/code&gt; 文件”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么 &lt;code&gt;nul&lt;/code&gt; 特殊？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;熟悉 Windows 历史的开发者可能知道，&lt;code&gt;nul&lt;/code&gt; 是一个“天坑”。在 Windows (及更早的 DOS) 系统中，&lt;code&gt;NUL&lt;/code&gt;、&lt;code&gt;CON&lt;/code&gt;、&lt;code&gt;PRN&lt;/code&gt;、&lt;code&gt;AUX&lt;/code&gt; 等是保留的设备名称。&lt;code&gt;NUL&lt;/code&gt; 代表“空设备”（类似于 Unix/Linux 中的 &lt;code&gt;/dev/null&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;当 Windows 的文件系统 API 看到你试图操作一个名为 &lt;code&gt;nul&lt;/code&gt; 的“文件”时，它会认为你是在尝试操作这个“空设备”，而不是一个同名的物理文件。因此，所有常规的文件操作（如删除、重命名）都会失败。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何产生 &lt;code&gt;nul&lt;/code&gt; 文件的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这通常是跨平台开发工具（如 Git、Node.js 脚本、Python 脚本等）的“锅”。这些工具可能基于 POSIX (Unix-like) 标准，在它们的眼中，&lt;code&gt;nul&lt;/code&gt; 只是一个普通的文件名。它们在 Windows 上运行时，有时会绕过常规的API，直接创建出这种 Windows “消化不良”的文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网上推荐的“标准解法”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我迅速在网上搜索，发现我不是第一个遇到这个问题的人。社区提供了几种公认的“高级”解决方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;使用 &lt;code&gt;\\.\&lt;/code&gt; 语法&lt;/strong&gt;：在 CMD 中使用特殊的“长路径”语法，绕过 Windows 的名称检查。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;del \\.\C:\your\project\path\nul
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;使用 Git Bash&lt;/strong&gt;：Git Bash 提供了一个轻量级的 Unix 环境，它不把 &lt;code&gt;nul&lt;/code&gt; 当作特殊设备&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rm nul
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;使用 WSL (Windows Subsystem for Linux)&lt;/strong&gt;：进入 WSL，挂载 Windows 磁盘，使用 Linux 的 &lt;code&gt;rm&lt;/code&gt; 命令删除。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rm /mnt/c/your/project/path/nul
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然而，&lt;strong&gt;这些方法对我全都不起作用！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无论是 WSL 还是 Git Bash，当我尝试 &lt;code&gt;rm nul&lt;/code&gt; 时，系统都报出了“No such file or directory”（没有那个文件或目录）的错误。这让我陷入了沉思，问题似乎比我想象的更复杂。&lt;/p&gt;
&lt;h2 id=&#34;阶段二灵光一现是不是多重问题叠加&#34;&gt;阶段二：灵光一现——是不是“多重问题叠加”？
&lt;/h2&gt;&lt;p&gt;如果 &lt;code&gt;nul&lt;/code&gt; 文件确实存在，为什么连 Unix 工具都说“找不到”它呢？&lt;/p&gt;
&lt;p&gt;我开始怀疑：&lt;strong&gt;是不是问题不仅出在 &lt;code&gt;nul&lt;/code&gt; 文件本身，还出在了它的“栖身之所”——它所在的目录？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我立刻打开 Git Bash（这是关键，因为 Windows 资源管理器可能不会显示异常），导航到 &lt;code&gt;nul&lt;/code&gt; 文件所在的&lt;strong&gt;上一级目录&lt;/strong&gt;，然后执行 &lt;code&gt;ls -la&lt;/code&gt; (列出所有文件，包括隐藏文件，并显示详细信息)。&lt;/p&gt;
&lt;p&gt;这时，我终于发现了“盲点”：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;那个存放 &lt;code&gt;nul&lt;/code&gt; 文件的目录，它的&lt;strong&gt;目录名本身就包含非法字符&lt;/strong&gt;！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在我的案例中，这个目录名可能是一个以空格或点（&lt;code&gt;.&lt;/code&gt;）结尾的名称，或者是包含 Windows 不允许的特殊符号（如 &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;:&lt;/code&gt;）——这些同样是开发工具在跨平台同步时“夹带的私货”。&lt;/p&gt;
&lt;p&gt;例如，一个目录在 Git Bash 中显示为 &lt;code&gt;&amp;quot;my-app &amp;quot;&lt;/code&gt; (注意末尾的空格)，或者 &lt;code&gt;&amp;quot;my-app.&amp;quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这就是问题所在！&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;问题A：&lt;/strong&gt; 我有一个名为 &lt;code&gt;nul&lt;/code&gt; 的“非法”文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;问题B：&lt;/strong&gt; 我有一个名为 &lt;code&gt;&amp;quot;my-app &amp;quot;&lt;/code&gt; 的“非法”目录。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当我尝试 &lt;code&gt;rm /path/to/&amp;quot;my-app &amp;quot;/nul&lt;/code&gt; 时，Windows 系统和 Unix 工具都“蒙圈”了。Windows API 无法正确解析这个包含非法字符的路径；而 Git Bash 或 WSL 虽然能“看到”这个非法目录，但在尝试访问它内部的 &lt;code&gt;nul&lt;/code&gt; 文件时，可能因为路径解析的复合问题而失败。&lt;/p&gt;
&lt;h2 id=&#34;阶段三釜底抽薪从路径下手一举歼灭&#34;&gt;阶段三：釜底抽薪——从路径下手，一举歼灭
&lt;/h2&gt;&lt;p&gt;既然确定了是“文件路径”和“文件名”的双重问题，解决方案就清晰了：&lt;strong&gt;不要试图去删除那个 &lt;code&gt;nul&lt;/code&gt; 文件，而是直接删除那个“非法”的父目录！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我的最终解决步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;打开 Git Bash&lt;/strong&gt;：这是唯一能正确“看到”并处理这些非法名称的工具。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;导航到“问题目录”的上一级&lt;/strong&gt;：
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 假设问题目录是 C:\projects\my-app 
cd /c/projects/
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;确认“问题目录”的真实名称&lt;/strong&gt;：
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ls -l
# 输出可能显示如下：
# drwxr-xr-x 1 MyUser 1049089 0 Nov 7 06:30 &#39;my-app &#39;/ 
# 注意到了吗？ls 命令用单引号把这个带空格的目录名括起来了。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行“终极删除”&lt;/strong&gt;：使用 &lt;code&gt;rm&lt;/code&gt; 命令的 &lt;code&gt;-r&lt;/code&gt; (递归) 和 &lt;code&gt;-f&lt;/code&gt; (强制) 选项，配合&lt;strong&gt;引号&lt;/strong&gt;，来删除整个目录。
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 必须使用引号（单引号或双引号）
# 并且，如果你在 Git Bash 中输入 &#39;my-app &#39; 然后按 Tab 键，它也能帮你自动补全

rm -rf &amp;quot;my-app &amp;quot;

# 或者

rm -rf &#39;my-app &#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;执行命令后，那个困扰我许久的、包含 &lt;code&gt;nul&lt;/code&gt; 文件的、本身命名也不合法的目录，终于从我的文件系统中被彻底清除了。&lt;/p&gt;</description>
        </item>
        <item>
        <title>vmware虚拟机cpu资源占用异常</title>
        <link>https://ttf248.life/p/vmware-virtual-machine-cpu-usage-anomaly/</link>
        <pubDate>Sun, 10 Mar 2024 22:14:59 +0800</pubDate>
        
        <guid>https://ttf248.life/p/vmware-virtual-machine-cpu-usage-anomaly/</guid>
        <description>&lt;p&gt;背景：本地机器部署 windows 版本的业务系统，cpu 资源占用 5% 左右。vmware安装的 centos8 中部署 linux 版本业务系统，资源占用异常。&lt;/p&gt;
&lt;h2 id=&#34;问题描述&#34;&gt;问题描述
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;宿主机：win10 企业版&lt;/li&gt;
&lt;li&gt;vmware：17.5&lt;/li&gt;
&lt;li&gt;虚拟机：centos8&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虚拟机资源分配为&lt;code&gt;4C8GB&lt;/code&gt;，启动业务系统。业务系统部署在虚拟机Linux系统中，虚拟机内部 top 命令观察系统资源占用，cpu 占用并不高，外层 windows 系统，任务管理器观察到的CPU资源占用很高，查看进程发现，vmware 进程占用CPU资源很高。&lt;/p&gt;
&lt;p&gt;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+
|         Windows           |
|                           |
|   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+  |
|   |      VMware        |  |
|   |      Program       |  |
|   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+  |
|                           |
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+&lt;/p&gt;
&lt;h2 id=&#34;知识点&#34;&gt;知识点
&lt;/h2&gt;&lt;p&gt;此问题的排查，并不顺利，由于导火索并不是业务系统本身，而是虚拟机本身的问题。如何将思路从常规的业务代码转移到系统负载，再从负载数据的异常，定位到软中断，最后来到关键点，什么东西会影响 Vmware 软中断的工作效率？本文将先科普各个知识点，最后给出解决方案。&lt;/p&gt;
&lt;h3 id=&#34;hyper-v&#34;&gt;hyper-v
&lt;/h3&gt;&lt;p&gt;Windows操作系统的虚拟化技术经历了一次重大变革。在微软首次发布WSL时，启用Hyper-V服务会导致无法同时使用VMware虚拟机。直到后续版本，VMware才能与Hyper-V服务兼容。&lt;/p&gt;
&lt;h3 id=&#34;系统负载&#34;&gt;系统负载
&lt;/h3&gt;&lt;p&gt;在Linux系统中，&amp;ldquo;负载&amp;rdquo;（load）是指系统中正在运行或等待执行的进程的数量。负载通常由三个数字表示，分别是1分钟、5分钟和15分钟内运行队列中的平均进程数量。这些数字可以通过运行&amp;quot;uptime&amp;quot;命令或&amp;quot;top&amp;quot;命令来查看。&lt;/p&gt;
&lt;p&gt;具体来说，这三个数字分别代表：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;1分钟负载&lt;/strong&gt;：系统在过去1分钟内运行队列中的平均进程数量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;5分钟负载&lt;/strong&gt;：系统在过去5分钟内运行队列中的平均进程数量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;15分钟负载&lt;/strong&gt;：系统在过去15分钟内运行队列中的平均进程数量。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;负载的含义是在系统中等待运行的进程数。如果这个数字高于系统的逻辑CPU数量，表明系统负载很高，意味着有许多进程正在等待处理器资源。这可能会导致系统变得缓慢或不响应，具体取决于负载的高低程度以及系统的配置和性能。&lt;/p&gt;
&lt;p&gt;在理想情况下，负载应该保持在系统的逻辑CPU数量范围内，这样系统的性能就能够得到最优化。如果负载持续高于CPU数量，可能需要进一步分析系统中的进程，找出导致负载高的原因，并采取相应的措施来调整系统资源分配或优化进程的运行方式。&lt;/p&gt;
&lt;h3 id=&#34;分析负载-mpstat&#34;&gt;分析负载 mpstat
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;mpstat&lt;/code&gt; 命令用于报告单个或多个处理器的多个信息，包括平均负载、CPU利用率、中断和上下文切换等。在 &lt;code&gt;sysstat&lt;/code&gt; 包中，&lt;code&gt;mpstat&lt;/code&gt; 是非常有用的工具，可以用来分析系统的负载情况。下面是使用 &lt;code&gt;mpstat&lt;/code&gt; 进行负载分析的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;安装 sysstat&lt;/strong&gt;：
如果您的系统上没有安装 &lt;code&gt;sysstat&lt;/code&gt;，可以使用适合您系统的包管理工具进行安装。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;运行 mpstat&lt;/strong&gt;：
使用 &lt;code&gt;mpstat&lt;/code&gt; 命令查看 CPU 的使用情况和负载。默认情况下，&lt;code&gt;mpstat&lt;/code&gt; 每秒钟显示一次 CPU 使用情况的平均值。您可以通过指定时间间隔来调整输出频率。例如，要以每秒钟一次的频率运行 &lt;code&gt;mpstat&lt;/code&gt;，可以使用以下命令：&lt;code&gt;mpstat -P ALL 2&lt;/code&gt;，&lt;code&gt;irq&lt;/code&gt; 表示占用资源占用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;01:32:33 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
01:32:35 PM  all    0.00    0.00    0.26    0.00    3.73    0.26    0.00    0.00    0.00   95.76
01:32:35 PM    0    0.00    0.00    0.51    0.00    3.57    0.00    0.00    0.00    0.00   95.92
01:32:35 PM    1    0.00    0.00    0.00    0.00    3.59    0.51    0.00    0.00    0.00   95.90
01:32:35 PM    2    0.00    0.00    0.00    0.00    4.15    0.00    0.00    0.00    0.00   95.85
01:32:35 PM    3    0.00    0.00    0.52    0.00    3.61    0.52    0.00    0.00    0.00   95.36
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分析输出&lt;/strong&gt;：
&lt;code&gt;mpstat&lt;/code&gt; 的输出包括了每个 CPU 的利用率，以及系统的平均负载。特别关注平均负载以及每个 CPU 的利用率，可以帮助您了解系统的负载情况。如果负载较高，可以进一步分析是哪些进程导致的，以及是否存在性能瓶颈。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;结合其他工具&lt;/strong&gt;：
除了 &lt;code&gt;mpstat&lt;/code&gt;，还可以使用 &lt;code&gt;sar&lt;/code&gt;、&lt;code&gt;pidstat&lt;/code&gt;、&lt;code&gt;iostat&lt;/code&gt; 等工具来综合分析系统性能。通过结合多种工具的输出，可以更全面地了解系统的负载情况，并找出性能问题的根源。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;中断&#34;&gt;中断
&lt;/h3&gt;&lt;p&gt;此处不展开讲解内容太多，
推荐: &lt;a class=&#34;link&#34; href=&#34;https://www.codedump.info/post/20200522-sgfap-softirq/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《面向应用开发者的系统指南》CPU篇之软中断&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;频繁的触发软中断，也会体现在系统负载中。&lt;/p&gt;
&lt;h2 id=&#34;问题排查&#34;&gt;问题排查
&lt;/h2&gt;&lt;p&gt;考虑到仅从CPU角度分析无法定位问题，我们是否应该开始怀疑系统是否出现了异常？可能是Linux操作系统的负载过高，导致VMware占用了过多的CPU资源。通过使用&lt;code&gt;mpstat&lt;/code&gt;分析本地虚拟机，我们发现&lt;code&gt;irq&lt;/code&gt;占用异常，单核接近25%，而在正常情况下，启动业务进程空跑时，&lt;code&gt;irq&lt;/code&gt;占比应该约为5%。&lt;/p&gt;
&lt;p&gt;在组内同事的开发环境中，他的CentOS 7部署在VMware上，资源占用显示正常。另一方面，在上海的开发环境中，虽然也是VMware，但我们无法直接观察宿主机的CPU资源情况。这时，我们面临着多个变量：VMware虚拟机、Linux操作系统和GCC版本。&lt;/p&gt;
&lt;p&gt;转而分析测试环境，深圳的测试环境部署在物理机上，运行着低版本GCC编译的服务，而且在CentOS 8上运行。有趣的是，在深圳环境中，&lt;code&gt;irq&lt;/code&gt;占用都是正常的。&lt;/p&gt;
&lt;p&gt;为了排查GCC版本引入的问题，我们将使用高版本GCC编译的程序部署到深圳环境进行测试，结果显示也都是正常的。&lt;/p&gt;
&lt;p&gt;问题似乎变得更加明朗，我们开始怀疑操作系统是否存在问题。毕竟，CentOS 8已经不再受到官方支持。但即便重新部署了纯净的CentOS 7和CentOS 8，问题依然存在。&lt;/p&gt;
&lt;p&gt;此时，我们开始怀疑唯一的不确定因素，即VMware虚拟机软件。突然间，灵光一现，我们想到了Hyper-V技术。是否之前启用了Hyper-V，但没有彻底关闭，从而导致了这个问题？毕竟，软中断也是通过虚拟机软件来实现的。不同的虚拟机虚拟技术是否存在BUG？这些问题值得深入思考和调查。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论
&lt;/h2&gt;&lt;p&gt;根据微软官方的手册，我们完全关闭了本机的Hyper-V服务后，发现VMware在宿主机上恢复了正常。至此，问题终于迎刃而解。正如一开始所述，这段经历曲折而艰辛，需要综合性的分析和判断。这也是我们首次排查问题，定位到了虚拟机这一层面。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Disable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V-Hypervisor
bcdedit /set hypervisorlaunchtype off
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/application-management/virtualization-apps-not-work-with-hyper-v&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/troubleshoot/windows-client/application-management/virtualization-apps-not-work-with-hyper-v&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Windows平台快速统计文件夹大小</title>
        <link>https://ttf248.life/p/windows-platform-quick-folder-size-statistics/</link>
        <pubDate>Mon, 01 Aug 2022 19:54:18 +0800</pubDate>
        
        <guid>https://ttf248.life/p/windows-platform-quick-folder-size-statistics/</guid>
        <description>&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt; 平台很简单 &lt;code&gt;du -sh *&lt;/code&gt; 一行代码就搞定了。&lt;code&gt;Windows&lt;/code&gt; 怎么办呢？磁盘很多，想清理一波，文件很多的情况下，系统自带的资源管理器，统计文件夹大小，速度慢的让你想放弃&lt;/p&gt;
&lt;h2 id=&#34;everything&#34;&gt;Everything
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;windows&lt;/code&gt; 平台下做开发的朋友，没有亲手用过 &lt;code&gt;everything&lt;/code&gt;，也应该听朋友提过。搜索速度远超系统自带的资源管理器。既然系统层面支持快速索引文件，肯定就能找到类似的工具，建立文件索引的同时，统计下文件的大小。&lt;/p&gt;
&lt;h2 id=&#34;wiztree&#34;&gt;WizTree
&lt;/h2&gt;&lt;p&gt;官网：&lt;a class=&#34;link&#34; href=&#34;https://www.diskanalyzer.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.diskanalyzer.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;普通的安装模式或者绿色版本解压运行&lt;/p&gt;
&lt;p&gt;速度快，数据展示类型丰富，左侧是树状图模式，右边是文件类型，当然也有图形化展示，在软件底栏。&lt;/p&gt;
&lt;h2 id=&#34;spacesnifferupdate-2023-不再维护更新了&#34;&gt;SpaceSniffer(update 2023 不再维护更新了)
&lt;/h2&gt;&lt;p&gt;软件官网：&lt;a class=&#34;link&#34; href=&#34;http://www.uderzo.it/main_products/space_sniffer/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.uderzo.it/main_products/space_sniffer/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;操作很简单，选择对应的盘符，软件会用图形化的方式，展示文件夹体积，体积越大，图像中对应的矩阵也就越大，其余操作，自己点点就明白了，支持输入条件过滤文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件体积过滤&lt;/li&gt;
&lt;li&gt;文件日期过滤&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/windows-platform-quick-folder-size-statistics/space_sniffer.gif&#34;
	width=&#34;960&#34;
	height=&#34;540&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;基础用法&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;177&#34;
		data-flex-basis=&#34;426px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/windows-platform-quick-folder-size-statistics/advance.gif&#34;
	width=&#34;960&#34;
	height=&#34;540&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;高级用法&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;177&#34;
		data-flex-basis=&#34;426px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://moe.best/software/spacesniffer.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://moe.best/software/spacesniffer.html&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>Windows平台编辑超大型文件：EmEditor (Text Editor)</title>
        <link>https://ttf248.life/p/windows-platform-edit-large-files-emeditor-text-editor/</link>
        <pubDate>Sun, 31 Jul 2022 23:21:24 +0800</pubDate>
        
        <guid>https://ttf248.life/p/windows-platform-edit-large-files-emeditor-text-editor/</guid>
        <description>&lt;p&gt;上海国安数据库事件，黑产圈子里面闹的沸沸扬扬，也不知道真假，过两年如果还记得，再回头看看。根据以往的经验，更新了一波本地的社工数据库资料，看到一个巨型SQL文件：17.9G，一般的文本编辑器，预览都是个问题，更别说打开了，和网友闲聊，提到了：EmEditor。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;官网：&lt;a class=&#34;link&#34; href=&#34;https://www.emeditor.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.emeditor.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;周末抽空试了一下，挺方便的，设计上就支持编辑大型文件，内存足够的情况下，整个文件都载入到内存中，搜索、编辑速度都挺快，也支持分割文件。&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
