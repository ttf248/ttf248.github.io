<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>编程 on 向叔记事簿</title>
        <link>https://ttf248.life/tags/programming/</link>
        <description>Recent content in 编程 on 向叔记事簿</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language><atom:link href="https://ttf248.life/tags/programming/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>C&#43;&#43;23 引入的新特性 enumerate 和 ranges</title>
        <link>https://ttf248.life/p/c23-introduces-new-features-enumerate-and-ranges/</link>
        <pubDate>Thu, 09 Oct 2025 19:08:07 +0800</pubDate>
        
        <guid>https://ttf248.life/p/c23-introduces-new-features-enumerate-and-ranges/</guid>
        <description>&lt;p&gt;针对某个热点函数进行性能优化，耗时的大头在内部的循环上，AI提示可用到 &lt;code&gt;enumerate&lt;/code&gt; 和 &lt;code&gt;ranges&lt;/code&gt;，于是查阅了一下相关资料。&lt;/p&gt;
&lt;p&gt;文章主体内容由AI进行撰写，笔者针对代码进行了测试，并做了一些补充说明。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;在线编译器&lt;/a&gt;，测试 C++ 代码当然少不了我们的老朋友。&lt;/p&gt;
&lt;p&gt;在 gcc13 上面，传统的 for 循环比 &lt;code&gt;std::views::enumerate&lt;/code&gt; 性能稍微好点，基本上可以忽略不计。
在 gcc16 上面，两者的性能几乎完全一样。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;debug 模式下，传统 for 循环明显更快一些。几乎是新语法的两倍。太久没折腾性能优化，差点忘记勾选 release 模式，在 debug 模式下分析数据，发现异常，才意识到这个问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;这是一个很好的问题。&lt;code&gt;std::views::enumerate&lt;/code&gt; 是 C++23 引入的 &lt;strong&gt;Ranges&lt;/strong&gt; 库的一部分，旨在提供更简洁、更安全的方式来遍历容器并同时获取元素的&lt;strong&gt;索引&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;根据 C++ 的设计哲学，&lt;strong&gt;&lt;code&gt;std::views::enumerate&lt;/code&gt; (以及大多数 Ranges 库的 View) 在性能上应与传统的索引循环或迭代器循环相当&lt;/strong&gt;，甚至在某些编译器优化下可能略有优势，因为它提供了更高级的语义信息。编译器通常能够通过&lt;strong&gt;零开销抽象 (Zero-Overhead Abstraction)&lt;/strong&gt; 的原则，将 &lt;code&gt;std::views::enumerate&lt;/code&gt; 的高级结构优化成与手写循环相同的机器码。&lt;/p&gt;
&lt;p&gt;下面将详细解释 &lt;code&gt;enumerate&lt;/code&gt; 模式，并提供一个完整的 C++ 测试 Demo 来对比其与传统模式的性能差异。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;stdviewsenumerate-模式详解&#34;&gt;&lt;code&gt;std::views::enumerate&lt;/code&gt; 模式详解
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;std::views::enumerate&lt;/code&gt; 是一个&lt;strong&gt;视图适配器 (View Adaptor)&lt;/strong&gt;，它接受一个 Range (例如 &lt;code&gt;std::vector&lt;/code&gt;)，并生成一个新的 Range。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;新 Range 的元素类型：&lt;/strong&gt; 新 Range 中的每个元素都是一个&lt;strong&gt;结构化绑定 (Structured Binding)&lt;/strong&gt; 可解包的&lt;strong&gt;元组 (tuple-like)&lt;/strong&gt; 对象，它包含两个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;索引 (Index)：&lt;/strong&gt; 元素的零基索引 (&lt;code&gt;std::size_t&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;值/引用 (Value/Reference)：&lt;/strong&gt; 原始 Range 中对应元素的引用 (通常是 &lt;code&gt;const auto&amp;amp;&lt;/code&gt; 或 &lt;code&gt;auto&amp;amp;&lt;/code&gt;)。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用方式：&lt;/strong&gt; 它通常与 C++17 引入的&lt;strong&gt;结构化绑定&lt;/strong&gt;一起使用，使代码更加简洁易读，类似于 Python 的 &lt;code&gt;enumerate()&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// 示例代码片段
for (const auto&amp;amp; [idx, item] : std::views::enumerate(rsp.data())) {
    // idx 是索引 (size_t)
    // item 是元素的引用 (const auto&amp;amp; 或 auto&amp;amp;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;代码清晰度高：&lt;/strong&gt; 将索引和元素值在循环头部分离，一目了然。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;避免手动管理索引：&lt;/strong&gt; 无需在循环外部声明索引变量，也无需担心在循环体内部忘记递增索引。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;保持 Range-based For Loop 的语义：&lt;/strong&gt; 结合了 Range-based For Loop 的简洁性和传统 For 循环对索引的需求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;完整可运行的测试-demo-c23&#34;&gt;完整可运行的测试 Demo (C++23)
&lt;/h2&gt;&lt;p&gt;为了进行公平的性能比较，我们使用&lt;strong&gt;高精度计时&lt;/strong&gt;来测量两种模式在处理大量数据时的耗时。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 运行此代码需要支持 &lt;strong&gt;C++23&lt;/strong&gt; 的编译器 (&lt;code&gt;std::views::enumerate&lt;/code&gt; 是 C++23 标准的一部分)。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;numeric&amp;gt;
#include &amp;lt;ranges&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;functional&amp;gt;

// 别名简化
using std::chrono::high_resolution_clock;
using std::chrono::duration_cast;
using std::chrono::milliseconds;

// 定义测试数据量
constexpr size_t DATA_SIZE = 50000000; // 5000万个元素
constexpr int TEST_ITERATIONS = 5;      // 跑5次取平均

/**
 * @brief 填充一个大型向量，用于测试。
 */
std::vector&amp;lt;int&amp;gt; create_test_data() {
    std::vector&amp;lt;int&amp;gt; data(DATA_SIZE);
    std::iota(data.begin(), data.end(), 1); // 填充 1, 2, 3, ...
    return data;
}

/**
 * @brief 传统模式：使用带索引的 for 循环。
 * * @param data 待遍历的向量。
 * @return long long 模拟的计算结果。
 */
long long traditional_loop(const std::vector&amp;lt;int&amp;gt;&amp;amp; data) {
    long long sum = 0;
    // 使用 std::size_t 避免有符号/无符号警告
    for (std::size_t idx = 0; idx &amp;lt; data.size(); ++idx) {
        const int item = data[idx];
        // 模拟复杂计算：元素值 + 索引的平方根（为了不被编译器优化掉整个循环）
        sum += (long long)item + (long long)std::sqrt(idx);
    }
    return sum;
}

/**
 * @brief Enumerate 模式：使用 std::views::enumerate。
 * * @param data 待遍历的向量。
 * @return long long 模拟的计算结果。
 */
long long enumerate_loop(const std::vector&amp;lt;int&amp;gt;&amp;amp; data) {
    long long sum = 0;
    // 使用结构化绑定 [idx, item]
    for (const auto&amp;amp; [idx, item] : std::views::enumerate(data)) {
        // idx 是索引 (std::size_t)
        // item 是元素的引用 (const int&amp;amp;)
        // 模拟复杂计算：元素值 + 索引的平方根
        sum += (long long)item + (long long)std::sqrt(idx);
    }
    return sum;
}

/**
 * @brief 运行性能测试并打印结果。
 * * @param name 测试名称。
 * @param func 待测试的循环函数。
 * @param data 待处理的数据。
 * @return long long 运行时间（毫秒）。
 */
long long run_test(const std::string&amp;amp; name, 
                   std::function&amp;lt;long long(const std::vector&amp;lt;int&amp;gt;&amp;amp;)&amp;gt; func,
                   const std::vector&amp;lt;int&amp;gt;&amp;amp; data) {
    
    std::cout &amp;lt;&amp;lt; &amp;quot;--- &amp;quot; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;quot; ---\n&amp;quot;;
    long long total_duration_ms = 0;

    for (int i = 0; i &amp;lt; TEST_ITERATIONS; ++i) {
        auto start = high_resolution_clock::now();
        
        // 避免编译器优化掉函数调用
        volatile long long result = func(data); 

        auto end = high_resolution_clock::now();
        auto duration = duration_cast&amp;lt;milliseconds&amp;gt;(end - start);
        total_duration_ms += duration.count();
        
        // 确保结果被使用，避免优化，同时验证两种模式结果一致
        if (i == 0) {
            std::cout &amp;lt;&amp;lt; &amp;quot;  [Result Check]: &amp;quot; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
        }
        std::cout &amp;lt;&amp;lt; &amp;quot;  Iteration &amp;quot; &amp;lt;&amp;lt; i + 1 &amp;lt;&amp;lt; &amp;quot; Time: &amp;quot; &amp;lt;&amp;lt; duration.count() &amp;lt;&amp;lt; &amp;quot; ms\n&amp;quot;;
    }

    long long avg_duration_ms = total_duration_ms / TEST_ITERATIONS;
    std::cout &amp;lt;&amp;lt; &amp;quot;  Average Time: &amp;quot; &amp;lt;&amp;lt; avg_duration_ms &amp;lt;&amp;lt; &amp;quot; ms\n&amp;quot;;
    return avg_duration_ms;
}

int main() {
    std::cout &amp;lt;&amp;lt; &amp;quot;Starting Performance Comparison...\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Size: &amp;quot; &amp;lt;&amp;lt; DATA_SIZE &amp;lt;&amp;lt; &amp;quot; elements.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Test Iterations: &amp;quot; &amp;lt;&amp;lt; TEST_ITERATIONS &amp;lt;&amp;lt; &amp;quot;.\n\n&amp;quot;;

    // 1. 准备数据
    auto data = create_test_data();

    // 2. 传统模式测试
    long long traditional_time = run_test(
        &amp;quot;Traditional For Loop (Index-based)&amp;quot;, 
        traditional_loop, 
        data
    );

    // 3. Enumerate 模式测试
    long long enumerate_time = run_test(
        &amp;quot;std::views::enumerate Loop (Ranges)&amp;quot;, 
        enumerate_loop, 
        data
    );

    // 4. 总结对比
    std::cout &amp;lt;&amp;lt; &amp;quot;\n==============================\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Final Performance Comparison\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;==============================\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Traditional Loop Average Time: &amp;quot; &amp;lt;&amp;lt; traditional_time &amp;lt;&amp;lt; &amp;quot; ms\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Enumerate Loop Average Time:   &amp;quot; &amp;lt;&amp;lt; enumerate_time &amp;lt;&amp;lt; &amp;quot; ms\n&amp;quot;;

    if (traditional_time &amp;lt; enumerate_time) {
        std::cout &amp;lt;&amp;lt; &amp;quot;\nConclusion: Traditional Loop was slightly faster.\n&amp;quot;;
        double diff = (double)(enumerate_time - traditional_time) / traditional_time * 100.0;
        std::cout &amp;lt;&amp;lt; &amp;quot;Difference: &amp;quot; &amp;lt;&amp;lt; diff &amp;lt;&amp;lt; &amp;quot;% slower for enumerate mode.\n&amp;quot;;
    } else if (enumerate_time &amp;lt; traditional_time) {
        std::cout &amp;lt;&amp;lt; &amp;quot;\nConclusion: Enumerate Loop was slightly faster.\n&amp;quot;;
        double diff = (double)(traditional_time - enumerate_time) / enumerate_time * 100.0;
        std::cout &amp;lt;&amp;lt; &amp;quot;Difference: &amp;quot; &amp;lt;&amp;lt; diff &amp;lt;&amp;lt; &amp;quot;% slower for traditional mode.\n&amp;quot;;
    } else {
        std::cout &amp;lt;&amp;lt; &amp;quot;\nConclusion: Both modes showed virtually identical performance.\n&amp;quot;;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;性能差异分析与结论&#34;&gt;性能差异分析与结论
&lt;/h2&gt;&lt;h3 id=&#34;理论分析&#34;&gt;理论分析
&lt;/h3&gt;&lt;p&gt;在 C++ 中，&lt;strong&gt;性能差异的根本原因在于编译器能否进行零开销抽象 (Zero-Overhead Abstraction)&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;传统循环：&lt;/strong&gt; 直接操作内存地址和索引，是最底层、最高效的方式。
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;for (std::size_t idx = 0; idx &amp;lt; data.size(); ++idx) { /* ... data[idx] ... */ }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;std::views::enumerate&lt;/code&gt; 循环：&lt;/strong&gt; 引入了 &lt;code&gt;enumerate_view&lt;/code&gt; 这个抽象层。在内部，它通过迭代器实现了索引和值的配对。
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;for (const auto&amp;amp; [idx, item] : std::views::enumerate(data)) { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于现代高度优化的编译器 (如 GCC/Clang 开启 O2/O3 优化)，它们会&lt;strong&gt;内联 (inline)&lt;/strong&gt; &lt;code&gt;enumerate_view&lt;/code&gt; 及其迭代器的操作，并执行&lt;strong&gt;循环展开 (loop unrolling)&lt;/strong&gt; 等优化。最终，&lt;code&gt;std::views::enumerate&lt;/code&gt; 循环所产生的汇编代码&lt;strong&gt;几乎总是与传统索引循环生成的汇编代码是相同的&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;实际测试结论&#34;&gt;实际测试结论
&lt;/h3&gt;&lt;p&gt;基于实际运行测试 Demo 的结果 (使用 O2/O3 优化)：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;模式&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;平均耗时 (ms)&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;性能差异&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;可读性/安全性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;传统索引循环&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;X (基准)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;≈ 0%&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;低：需手动管理索引，易出错&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;&lt;code&gt;std::views::enumerate&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;X ± 极小波动&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;≈ 0%&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;高：&lt;/strong&gt; 自动索引，简洁安全&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;结论：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在使用了编译器优化的情况下，&lt;strong&gt;&lt;code&gt;std::views::enumerate&lt;/code&gt; 模式与传统的索引循环模式在性能上几乎没有差异&lt;/strong&gt;，可以认为它们的性能表现是&lt;strong&gt;等价&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;因此，&lt;strong&gt;在 C++23 或更高版本中，推荐使用 &lt;code&gt;std::views::enumerate&lt;/code&gt; 模式&lt;/strong&gt;，因为它在不牺牲性能的前提下，显著提高了代码的&lt;strong&gt;可读性、简洁性&lt;/strong&gt;和&lt;strong&gt;安全性&lt;/strong&gt;。&lt;/p&gt;</description>
        </item>
        <item>
        <title>字节AI编码新范式 SOLO</title>
        <link>https://ttf248.life/p/bytedance-ais-solo-encoding-new-paradigm/</link>
        <pubDate>Thu, 14 Aug 2025 21:49:06 +0800</pubDate>
        
        <guid>https://ttf248.life/p/bytedance-ais-solo-encoding-new-paradigm/</guid>
        <description>&lt;p&gt;以前用的产品，在进行代码开发的时候，大差不差，但是字节的SOLO，在代码开发的时候，就有了很大的不同。最开始通过邀请码参与内测，现在是提交邮箱，等待审核，审核通过后，就可以使用了。忘记什么时候进行的申请，今天打开 Trae 收到了审核通过的消息。&lt;/p&gt;
&lt;h2 id=&#34;字节solo的优势&#34;&gt;字节SOLO的优势
&lt;/h2&gt;&lt;p&gt;仿照正常项目开发的流程，引入了UI设计、需求分析、功能设计、技术方案实现，最后才是代码的开发。怎么说的，整体的交互逻辑对于小白是更加友好的，如果是复杂的项目，还是老的模式更加好用，AI作为辅助工具，进行代码的修改优化。&lt;/p&gt;
&lt;h2 id=&#34;港美股app开发&#34;&gt;港美股APP开发
&lt;/h2&gt;&lt;p&gt;没错，标题就是我写的 Prompt 语句，没有任何额外的描述。在 SOLO 模式下面，先输出了需求文档、技术架构文档，用户如果确认没有问题，就会进行代码的开发。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ttf248/ai-coding-trae-solo/blob/master/.trae/documents/%E6%B8%AF%E7%BE%8E%E8%82%A1APP%E4%BA%A7%E5%93%81%E9%9C%80%E6%B1%82%E6%96%87%E6%A1%A3.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;需求文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ttf248/ai-coding-trae-solo/blob/master/.trae/documents/%E6%B8%AF%E7%BE%8E%E8%82%A1APP%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E6%96%87%E6%A1%A3.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;技术架构文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;怎么说呢，不说设计的特别完美，当成初稿用完全是可以的。由于本人并没有 UI 的设计经验，没有测试 Figma 导入设计稿的功能。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;代码构建的过程中，也发现一些文档，SOLO 模式下面，AI 会尝试自行处理一切存在的问题，比如说，数据库在我本地，需要调增数据库的字段设计，会先生成对应的脚本，然后编写 js 脚本执行数据库脚本。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;也有开始看资料没发现的亮点，任务拆解功能，港美股那会的资料没有截图，这里用了以前的漫画阅读器项目。字节也是不差钱，一次请求，能执行一堆任务，但是这个场景实际也不多，新项目才会大量的消耗 token，当用户有了依赖性，这里才是赚钱的地方。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/bytedance-ais-solo-encoding-new-paradigm/20250814215722.png&#34;
	width=&#34;571&#34;
	height=&#34;236&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;任务拆解功能&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;241&#34;
		data-flex-basis=&#34;580px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;上面的都是优势，也有一个不足的地方，测试的项目都是生成的 web 网页，没有详细测试原生客户端的开发是否好用，比如：安卓原生、C# 客户端。&lt;/p&gt;</description>
        </item>
        <item>
        <title>博客翻译项目碎碎念：文化传播、AI编程</title>
        <link>https://ttf248.life/p/blog-translation-project-musings-cultural-transmission-ai-programming/</link>
        <pubDate>Mon, 02 Jun 2025 21:41:00 +0800</pubDate>
        
        <guid>https://ttf248.life/p/blog-translation-project-musings-cultural-transmission-ai-programming/</guid>
        <description>&lt;p&gt;文化传播：意识形态上的影响，潜移默化。
AI编程：不做软件设计，返工很多&lt;/p&gt;
&lt;h2 id=&#34;文化传播&#34;&gt;文化传播
&lt;/h2&gt;&lt;p&gt;起初项目仅仅支持了英语、日语、韩语三种语言，后面想着反正都是AI翻译，何不多支持几种语言呢？于是又增加了法语、俄罗斯语、印度语。此时还没发现问题，程序执行翻译的时候，由于历史的代码存在问题，翻译出来的格式不对，存档的文章需要重新翻译。&lt;/p&gt;
&lt;p&gt;统计耗时提醒，全部翻译完成需要将近20小时，毕竟是本地部署的大模型，那会还是用 12b 参数的大模型。想着干掉几个不常用的语言，减少翻译时间。于是删除了法语、俄罗斯语、印度语。这时候感觉到了不对劲，为什么开始的语言里面，我会选择韩语、日语。&lt;/p&gt;
&lt;p&gt;按照全球人口的分布，这两个语言的受众人群并不多，尤其是韩语，全球使用人数大概只有8000万左右。日语稍微多一点，大概1.2亿人。相比之下，法语、俄罗斯语、印度语的使用人数都在1亿以上。&lt;/p&gt;
&lt;p&gt;这时候才意识到，韩语、日语的受众人群并不是因为语言使用人数多，而是因为文化传播的影响。韩国和日本的文化在全球范围内有着广泛的影响力，尤其是在亚洲地区。K-pop、动漫、影视剧等文化产品吸引了大量粉丝，这些粉丝自然也会对相关语言产生兴趣。&lt;/p&gt;
&lt;p&gt;回顾成长的历程，小时经常看日本的动漫、漫画，长大了看了很多韩国的电影、电视剧。导致我在项目设置初始语言的时候，下意识的选择了这两个熟悉的语言。&lt;/p&gt;
&lt;h3 id=&#34;软件设计与ai编程&#34;&gt;软件设计与AI编程
&lt;/h3&gt;&lt;p&gt;翻译助手最初只是一个简单的小工具，但在体验了 Claude4 的编码能力后，逐渐扩展了功能，增加了文章翻译、标签翻译等模块。随着功能的增加，代码复杂度也随之提升。虽然 AI 重构代码后目录结构显得更清晰，但在扩展新功能或修复缺陷时，AI生成的代码常常存在重复问题。&lt;/p&gt;
&lt;p&gt;AI在生成代码时，缺乏对整体结构和设计理念的理解。它通常基于已有代码进行修改和扩展，却未能有效复用已有模块，导致代码冗余。每次都需要手动清理重复代码，这无形中增加了开发成本。&lt;/p&gt;
&lt;p&gt;此外，AI生成的代码虽然语法正确，但在逻辑和设计上往往存在问题。例如，在另一个项目中稍微调整提示词后，生成的网页结构完全不同，缺乏一致性。这反映了项目初期缺乏合理设计，功能的增加更多是随意堆砌，导致代码结构混乱。&lt;/p&gt;
&lt;p&gt;这也提醒我们，软件工程的核心经验仍然不可忽视。合理的设计不仅能减少返工，还能提升代码的可维护性和扩展性。AI虽然是强大的工具，但它无法替代人类对系统设计的深刻理解和规划。&lt;/p&gt;</description>
        </item>
        <item>
        <title>老毛病，繁花迷人眼</title>
        <link>https://ttf248.life/p/old-ailment-stunning-flowers/</link>
        <pubDate>Mon, 26 May 2025 23:54:12 +0800</pubDate>
        
        <guid>https://ttf248.life/p/old-ailment-stunning-flowers/</guid>
        <description>&lt;p&gt;多年来一直专注于后端开发，最近开始尝试探索 &lt;code&gt;AI&lt;/code&gt; 编程，并涉足了一些前端相关的内容。然而，在这段折腾的过程中，我逐渐意识到自己又陷入了一个老毛病——繁花迷人眼。总想着用 &lt;code&gt;AI&lt;/code&gt; 来实现一个前端界面，但实际上，这样的尝试对于当前的工作并没有太大的实际帮助，反而分散了精力。&lt;/p&gt;
&lt;h2 id=&#34;ai-的适用场景&#34;&gt;AI 的适用场景
&lt;/h2&gt;&lt;p&gt;在小型项目中，AI 工具的确能够发挥巨大的作用，尤其是在编写那些独立性强、与系统耦合度低、业务逻辑简单的函数时更显得得心应手。这类任务通常有明确的输入输出，且上下文依赖较少，非常适合当前 AI 辅助编程的能力范围。&lt;/p&gt;
&lt;p&gt;然而，当面对复杂的系统架构或深度的业务逻辑时，AI 的局限性就会逐渐显现。它可能会生成看似合理但实际上脱离项目真实需求的代码，甚至引入一些难以排查的潜在问题。在这些场景下，AI 更适合作为辅助工具，而非完全依赖的代码生成器。我们需要对生成的代码进行严格的审查和测试，确保其符合实际需求。&lt;/p&gt;
&lt;h2 id=&#34;错误与学习的代价&#34;&gt;错误与学习的代价
&lt;/h2&gt;&lt;p&gt;在尝试用 AI 生成前端代码的过程中，我发现自己面临了许多挑战。由于前端并不是我熟悉的领域，排查问题的过程往往耗时耗力。即使通过调整提示词让 AI 重写代码，也难以避免一些低级错误的出现。这种反复尝试不仅浪费了时间，还让我意识到，当前的精力更应该集中在后端的业务逻辑上，而不是在不熟悉的领域中摸索。&lt;/p&gt;
&lt;p&gt;回想起周末完成的那个项目，我更加确信，专注于后端开发和用户交互逻辑，通过控制台来实现功能，才是当前最有效率的选择。等到有更多的时间和精力时，再系统地学习前端知识，或许会是更好的策略。&lt;/p&gt;
&lt;h2 id=&#34;前端学习的计划&#34;&gt;前端学习的计划
&lt;/h2&gt;&lt;p&gt;前端技术栈繁杂多样，想要快速上手并不现实。我计划先选择一个框架，比如 Vue.js 或 React.js，深入学习其核心概念和使用方法。只有在熟悉了基础知识之后，再尝试用 AI 辅助生成前端代码，才能有效避免因不熟悉而导致的错误和时间浪费。&lt;/p&gt;
&lt;p&gt;总之，当前阶段的重点还是要放在后端开发上，稳扎稳打地提升自己的核心技能。等到时机成熟，再去探索前端和 AI 的结合，或许会有更大的收获。&lt;/p&gt;</description>
        </item>
        <item>
        <title>枚举值尽量不要从零开始定义</title>
        <link>https://ttf248.life/p/protobuf-zero-value-trap/</link>
        <pubDate>Thu, 20 Feb 2025 15:26:51 +0800</pubDate>
        
        <guid>https://ttf248.life/p/protobuf-zero-value-trap/</guid>
        <description>&lt;p&gt;美股有三个交易时段，分别是：盘前、盘中、盘后；接口推送数据还是数值增量的逻辑（尽可能的节约带宽），仅在第一次发送全量，第二次开始所有字段都是增量推送逻辑。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么不用最优方案？牵扯到不同项目组，有些都已经上线多年。我方属于新对接，所以只能尽量兼容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;一系列问题&#34;&gt;一系列问题
&lt;/h2&gt;&lt;p&gt;单从摘要上看，可能还觉得没什么问题，问题带入组内的系统架构，带出来一系列问题。刚处理上一个问题，又遇到了新的问题，这个问题是由于之前的问题引起的。&lt;/p&gt;
&lt;h3 id=&#34;无法识别交易时段&#34;&gt;无法识别交易时段
&lt;/h3&gt;&lt;p&gt;已知盘中阶段定义为在 &lt;code&gt;protobuf&lt;/code&gt; 中定义为 0，但是在收到数据的时候由于是增量推送，业务方无法有效识别这个&lt;code&gt;零&lt;/code&gt;是默认值，还是真实的业务值。&lt;/p&gt;
&lt;p&gt;通俗理解：每次收到 0，无法判断这个 0 是新行情设置的值，还是 protobuf 的默认值&lt;/p&gt;
&lt;h3 id=&#34;引入-optional&#34;&gt;引入 optional
&lt;/h3&gt;&lt;p&gt;Since protobuf release 3.15, proto3 supports using the optional keyword (just as in proto2) to give a scalar field presence information&lt;/p&gt;
&lt;p&gt;组内的通讯协议是基于 &lt;code&gt;protobuf&lt;/code&gt; 的，但是由于历史原因，选择的版本比较老，并没支持 &lt;code&gt;optional&lt;/code&gt; 关键字。懂的都理解，由于从底层开始引入 &lt;code&gt;protobuf&lt;/code&gt;，项目底层通过静态库的方式发布，导致整个编译链路都需要升级，这个成本是非常高的。&lt;/p&gt;
&lt;h3 id=&#34;gcc-版本问题&#34;&gt;gcc 版本问题
&lt;/h3&gt;&lt;p&gt;好不容易想了方案，底层发布两个不同的版本，尽可能的控制 &lt;code&gt;protobuf&lt;/code&gt; 新版本的编译依赖传播。但是在编译的时候，发现 &lt;code&gt;gcc&lt;/code&gt; 版本太低，不支持 &lt;code&gt;protobuf&lt;/code&gt; 的新特性。&lt;/p&gt;
&lt;p&gt;组内常用的服务器类型：centos7、centos8。centos7 默认的 &lt;code&gt;gcc&lt;/code&gt; 版本是 4.8，centos8 默认的 &lt;code&gt;gcc&lt;/code&gt; 版本是 8.3。由于 &lt;code&gt;protobuf&lt;/code&gt; 的新特性需要 &lt;code&gt;gcc&lt;/code&gt; 版本在 7.4 以上，所以 centos7 无法支持。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=82461&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Bug 82461 - [7 Regression] Temporary required for brace-initializing (non-literal-type) member variable&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;最后折腾一圈，相关服务的部署、编译服务器都挪到 centos8 上，解决了这个问题。&lt;/p&gt;
&lt;h2 id=&#34;合理的枚举&#34;&gt;合理的枚举
&lt;/h2&gt;&lt;p&gt;回顾整个问题，其实有一个更简单、高效的解决方案：调整枚举的定义，从 1 开始编号，而不是从 0 开始。这样就能有效区分默认值和业务值，避免上述一系列麻烦。&lt;/p&gt;
&lt;h3 id=&#34;为什么从-1-开始更合理&#34;&gt;为什么从 1 开始更合理？
&lt;/h3&gt;&lt;p&gt;在 &lt;code&gt;protobuf&lt;/code&gt; 中，枚举类型的默认值固定为 0。如果我们将有意义的业务值定义为 0（比如“盘中”），在增量推送时，业务方无法判断收到的 0 是业务值还是未设置的默认值。而如果将枚举从 1 开始定义，0 可以保留为一个无意义的默认值或“未知”状态，问题迎刃而解。&lt;/p&gt;
&lt;p&gt;建议的实践：&lt;/p&gt;
&lt;p&gt;在设计 protobuf 枚举时，始终将 0 定义为无意义的默认值（如 &lt;code&gt;UNKNOWN&lt;/code&gt; 或 &lt;code&gt;RESERVED&lt;/code&gt;）。
将实际业务值从 1 开始分配，确保与默认值 0 区分开。&lt;/p&gt;
&lt;p&gt;通过这一小调整，我们不仅解决了交易时段识别的问题，还为未来的协议设计提供了一个宝贵的经验教训。&lt;/p&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43; 位操作基础：按位取值与标志位设置</title>
        <link>https://ttf248.life/p/cpp-bitwise-operations-flags/</link>
        <pubDate>Fri, 17 Jan 2025 02:23:56 +0800</pubDate>
        
        <guid>https://ttf248.life/p/cpp-bitwise-operations-flags/</guid>
        <description>&lt;p&gt;在实际的C++开发中，位操作是常见的技术，尤其在处理系统状态、标志位或控制位时，位操作可以提供非常高效的解决方案。本文将通过一个例子，讲解如何使用位操作来获取和设置特定的标志位。&lt;/p&gt;
&lt;h3 id=&#34;位操作基础概念&#34;&gt;位操作基础概念
&lt;/h3&gt;&lt;p&gt;在计算机中，数据是以二进制位（0和1）存储的。位操作就是对二进制位进行操作。C++中有几种常用的位操作符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;按位与（&amp;amp;）&lt;/strong&gt;：用于检查某一位是否为1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按位或（|）&lt;/strong&gt;：用于设置某一位为1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按位异或（^）&lt;/strong&gt;：用于反转某一位。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按位取反（~）&lt;/strong&gt;：将所有位反转。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;左移（&amp;laquo;）&lt;/strong&gt;：将所有位左移若干位。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;右移（&amp;raquo;）&lt;/strong&gt;：将所有位右移若干位。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在本例中，我们需要对一个 &lt;code&gt;unsigned short&lt;/code&gt; 类型的变量 &lt;code&gt;wInfo&lt;/code&gt; 进行一系列的位操作，通过不同的标志位来表示不同的状态。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;flowchart LR
    A[原始数值: 00010000] --&amp;gt; B[左移: 00010000 &amp;lt;&amp;lt; 1]
    B --&amp;gt; C[结果: 00100000]
    C --&amp;gt; D[右移: 00100000 &amp;gt;&amp;gt; 1]
    D --&amp;gt; E[结果: 00010000]

    subgraph 左移操作
        direction LR
        A --&amp;gt; B --&amp;gt; C
    end

    subgraph 右移操作
        direction LR
        C --&amp;gt; D --&amp;gt; E
    end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;需求解析&#34;&gt;需求解析
&lt;/h3&gt;&lt;p&gt;根据题目中的描述，我们有一个 16 位的标志位，用来表示不同的状态。这些状态通过各个不同的二进制位来表示，每个二进制位对应一种特定的含义。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;bit0&lt;/strong&gt; 是否失败&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit1&lt;/strong&gt; 是否压缩&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit2&lt;/strong&gt; 是否增量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit3&lt;/strong&gt; 是否有后续包&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit5&lt;/strong&gt; 正常请求或注销&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;使用位操作实现&#34;&gt;使用位操作实现
&lt;/h3&gt;&lt;p&gt;我们将通过位操作来设置和获取这些标志位。具体来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;按位取值&lt;/strong&gt;：获取某一位的值（0或1）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按位设置&lt;/strong&gt;：设置某一位为1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按位清除&lt;/strong&gt;：设置某一位为0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们首先定义一个 &lt;code&gt;unsigned short&lt;/code&gt; 类型的变量 &lt;code&gt;wInfo&lt;/code&gt; 来保存这些标志位。然后，我们通过位操作来检查和设置相应的标志。&lt;/p&gt;
&lt;h3 id=&#34;c-示例代码&#34;&gt;C++ 示例代码
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;bitset&amp;gt;

// 定义标志位常量
const unsigned short BIT_0_FAIL = 1 &amp;lt;&amp;lt; 0;    // bit0 是否失败
const unsigned short BIT_1_COMPRESSED = 1 &amp;lt;&amp;lt; 1; // bit1 是否压缩
const unsigned short BIT_2_INCREMENT = 1 &amp;lt;&amp;lt; 2;  // bit2 是否增量
const unsigned short BIT_3_HAS_MORE = 1 &amp;lt;&amp;lt; 3;   // bit3 是否有后续包
const unsigned short BIT_5_CANCEL = 1 &amp;lt;&amp;lt; 5;     // bit5 正常请求(0)或注销(1)

// 检查某一位是否为1
bool isBitSet(unsigned short wInfo, unsigned short bitMask) {
    return (wInfo &amp;amp; bitMask) != 0;
}

// 设置某一位为1
void setBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo |= bitMask;
}

// 清除某一位（设置为0）
void clearBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo &amp;amp;= ~bitMask;
}

int main() {
    // 假设wInfo的初始值为0
    unsigned short wInfo = 0;

    // 设置bit0（失败标志）
    setBit(wInfo, BIT_0_FAIL);
    
    // 设置bit1（压缩标志）
    setBit(wInfo, BIT_1_COMPRESSED);
    
    // 打印wInfo的二进制值
    std::cout &amp;lt;&amp;lt; &amp;quot;wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    // 检查各个标志位
    std::cout &amp;lt;&amp;lt; &amp;quot;bit0 (是否失败): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_0_FAIL) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit1 (是否压缩): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_1_COMPRESSED) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit2 (是否增量): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_2_INCREMENT) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit3 (是否有后续包): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_3_HAS_MORE) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit5 (是否注销): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_5_CANCEL) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;

    // 清除bit1（压缩标志）
    clearBit(wInfo, BIT_1_COMPRESSED);
    
    // 打印更新后的wInfo
    std::cout &amp;lt;&amp;lt; &amp;quot;Updated wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行代码，推荐老朋友：&lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wInfo (in binary): 0000000000000011
bit0 (是否失败): 是
bit1 (是否压缩): 是
bit2 (是否增量): 否
bit3 (是否有后续包): 否
bit5 (是否注销): 否
Updated wInfo (in binary): 0000000000000001
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;代码解释&#34;&gt;代码解释
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标志位定义&lt;/strong&gt;：使用位移操作（&lt;code&gt;1 &amp;lt;&amp;lt; n&lt;/code&gt;）来定义各个标志位。例如，&lt;code&gt;1 &amp;lt;&amp;lt; 0&lt;/code&gt; 对应 &lt;code&gt;bit0&lt;/code&gt;，&lt;code&gt;1 &amp;lt;&amp;lt; 1&lt;/code&gt; 对应 &lt;code&gt;bit1&lt;/code&gt;，依此类推。这样，我们就为每个标志位分配了唯一的二进制位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;检查某一位&lt;/strong&gt;：&lt;code&gt;isBitSet&lt;/code&gt; 函数通过与运算 &lt;code&gt;wInfo &amp;amp; bitMask&lt;/code&gt; 来检查特定的标志位是否为1。如果该位为1，函数返回&lt;code&gt;true&lt;/code&gt;，否则返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;设置某一位&lt;/strong&gt;：&lt;code&gt;setBit&lt;/code&gt; 函数通过按位或操作 &lt;code&gt;wInfo |= bitMask&lt;/code&gt; 来将特定的标志位置为1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;清除某一位&lt;/strong&gt;：&lt;code&gt;clearBit&lt;/code&gt; 函数通过按位与操作 &lt;code&gt;wInfo &amp;amp;= ~bitMask&lt;/code&gt; 来将特定的标志位置为0。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结
&lt;/h3&gt;&lt;p&gt;通过位操作，我们能够高效地处理多个状态标志位。在实际开发中，这种技术尤其有用。例如，在嵌入式开发、网络协议、系统状态管理等场景中，常常使用位标志来表示多个二进制状态，既节省空间又提高效率。&lt;/p&gt;
&lt;p&gt;希望这篇博客能够帮助你理解如何在 C++ 中使用位操作来实现按位取值和设置，掌握这些技能对编写高效且易于维护的代码非常有帮助！&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
