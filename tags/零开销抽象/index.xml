<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>零开销抽象 on 向叔记事簿</title>
        <link>https://ttf248.life/tags/%E9%9B%B6%E5%BC%80%E9%94%80%E6%8A%BD%E8%B1%A1/</link>
        <description>Recent content in 零开销抽象 on 向叔记事簿</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Thu, 29 Jan 2026 22:52:12 +0800</lastBuildDate><atom:link href="https://ttf248.life/tags/%E9%9B%B6%E5%BC%80%E9%94%80%E6%8A%BD%E8%B1%A1/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>C&#43;&#43;23 引入的新特性 enumerate 和 ranges</title>
        <link>https://ttf248.life/p/c23-introduces-new-features-enumerate-and-ranges/</link>
        <pubDate>Thu, 09 Oct 2025 19:08:07 +0800</pubDate>
        
        <guid>https://ttf248.life/p/c23-introduces-new-features-enumerate-and-ranges/</guid>
        <description>&lt;p&gt;针对某个热点函数进行性能优化，耗时的大头在内部的循环上，AI提示可用到 &lt;code&gt;enumerate&lt;/code&gt; 和 &lt;code&gt;ranges&lt;/code&gt;，于是查阅了一下相关资料。&lt;/p&gt;
&lt;p&gt;文章主体内容由AI进行撰写，笔者针对代码进行了测试，并做了一些补充说明。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;在线编译器&lt;/a&gt;，测试 C++ 代码当然少不了我们的老朋友。&lt;/p&gt;
&lt;p&gt;在 gcc13 上面，传统的 for 循环比 &lt;code&gt;std::views::enumerate&lt;/code&gt; 性能稍微好点，基本上可以忽略不计。
在 gcc16 上面，两者的性能几乎完全一样。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;debug 模式下，传统 for 循环明显更快一些。几乎是新语法的两倍。太久没折腾性能优化，差点忘记勾选 release 模式，在 debug 模式下分析数据，发现异常，才意识到这个问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;这是一个很好的问题。&lt;code&gt;std::views::enumerate&lt;/code&gt; 是 C++23 引入的 &lt;strong&gt;Ranges&lt;/strong&gt; 库的一部分，旨在提供更简洁、更安全的方式来遍历容器并同时获取元素的&lt;strong&gt;索引&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;根据 C++ 的设计哲学，&lt;strong&gt;&lt;code&gt;std::views::enumerate&lt;/code&gt; (以及大多数 Ranges 库的 View) 在性能上应与传统的索引循环或迭代器循环相当&lt;/strong&gt;，甚至在某些编译器优化下可能略有优势，因为它提供了更高级的语义信息。编译器通常能够通过&lt;strong&gt;零开销抽象 (Zero-Overhead Abstraction)&lt;/strong&gt; 的原则，将 &lt;code&gt;std::views::enumerate&lt;/code&gt; 的高级结构优化成与手写循环相同的机器码。&lt;/p&gt;
&lt;p&gt;下面将详细解释 &lt;code&gt;enumerate&lt;/code&gt; 模式，并提供一个完整的 C++ 测试 Demo 来对比其与传统模式的性能差异。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;stdviewsenumerate-模式详解&#34;&gt;&lt;code&gt;std::views::enumerate&lt;/code&gt; 模式详解
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;std::views::enumerate&lt;/code&gt; 是一个&lt;strong&gt;视图适配器 (View Adaptor)&lt;/strong&gt;，它接受一个 Range (例如 &lt;code&gt;std::vector&lt;/code&gt;)，并生成一个新的 Range。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;新 Range 的元素类型：&lt;/strong&gt; 新 Range 中的每个元素都是一个&lt;strong&gt;结构化绑定 (Structured Binding)&lt;/strong&gt; 可解包的&lt;strong&gt;元组 (tuple-like)&lt;/strong&gt; 对象，它包含两个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;索引 (Index)：&lt;/strong&gt; 元素的零基索引 (&lt;code&gt;std::size_t&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;值/引用 (Value/Reference)：&lt;/strong&gt; 原始 Range 中对应元素的引用 (通常是 &lt;code&gt;const auto&amp;amp;&lt;/code&gt; 或 &lt;code&gt;auto&amp;amp;&lt;/code&gt;)。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用方式：&lt;/strong&gt; 它通常与 C++17 引入的&lt;strong&gt;结构化绑定&lt;/strong&gt;一起使用，使代码更加简洁易读，类似于 Python 的 &lt;code&gt;enumerate()&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// 示例代码片段
for (const auto&amp;amp; [idx, item] : std::views::enumerate(rsp.data())) {
    // idx 是索引 (size_t)
    // item 是元素的引用 (const auto&amp;amp; 或 auto&amp;amp;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;代码清晰度高：&lt;/strong&gt; 将索引和元素值在循环头部分离，一目了然。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;避免手动管理索引：&lt;/strong&gt; 无需在循环外部声明索引变量，也无需担心在循环体内部忘记递增索引。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;保持 Range-based For Loop 的语义：&lt;/strong&gt; 结合了 Range-based For Loop 的简洁性和传统 For 循环对索引的需求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;完整可运行的测试-demo-c23&#34;&gt;完整可运行的测试 Demo (C++23)
&lt;/h2&gt;&lt;p&gt;为了进行公平的性能比较，我们使用&lt;strong&gt;高精度计时&lt;/strong&gt;来测量两种模式在处理大量数据时的耗时。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 运行此代码需要支持 &lt;strong&gt;C++23&lt;/strong&gt; 的编译器 (&lt;code&gt;std::views::enumerate&lt;/code&gt; 是 C++23 标准的一部分)。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;numeric&amp;gt;
#include &amp;lt;ranges&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;functional&amp;gt;

// 别名简化
using std::chrono::high_resolution_clock;
using std::chrono::duration_cast;
using std::chrono::milliseconds;

// 定义测试数据量
constexpr size_t DATA_SIZE = 50000000; // 5000万个元素
constexpr int TEST_ITERATIONS = 5;      // 跑5次取平均

/**
 * @brief 填充一个大型向量，用于测试。
 */
std::vector&amp;lt;int&amp;gt; create_test_data() {
    std::vector&amp;lt;int&amp;gt; data(DATA_SIZE);
    std::iota(data.begin(), data.end(), 1); // 填充 1, 2, 3, ...
    return data;
}

/**
 * @brief 传统模式：使用带索引的 for 循环。
 * * @param data 待遍历的向量。
 * @return long long 模拟的计算结果。
 */
long long traditional_loop(const std::vector&amp;lt;int&amp;gt;&amp;amp; data) {
    long long sum = 0;
    // 使用 std::size_t 避免有符号/无符号警告
    for (std::size_t idx = 0; idx &amp;lt; data.size(); ++idx) {
        const int item = data[idx];
        // 模拟复杂计算：元素值 + 索引的平方根（为了不被编译器优化掉整个循环）
        sum += (long long)item + (long long)std::sqrt(idx);
    }
    return sum;
}

/**
 * @brief Enumerate 模式：使用 std::views::enumerate。
 * * @param data 待遍历的向量。
 * @return long long 模拟的计算结果。
 */
long long enumerate_loop(const std::vector&amp;lt;int&amp;gt;&amp;amp; data) {
    long long sum = 0;
    // 使用结构化绑定 [idx, item]
    for (const auto&amp;amp; [idx, item] : std::views::enumerate(data)) {
        // idx 是索引 (std::size_t)
        // item 是元素的引用 (const int&amp;amp;)
        // 模拟复杂计算：元素值 + 索引的平方根
        sum += (long long)item + (long long)std::sqrt(idx);
    }
    return sum;
}

/**
 * @brief 运行性能测试并打印结果。
 * * @param name 测试名称。
 * @param func 待测试的循环函数。
 * @param data 待处理的数据。
 * @return long long 运行时间（毫秒）。
 */
long long run_test(const std::string&amp;amp; name, 
                   std::function&amp;lt;long long(const std::vector&amp;lt;int&amp;gt;&amp;amp;)&amp;gt; func,
                   const std::vector&amp;lt;int&amp;gt;&amp;amp; data) {
    
    std::cout &amp;lt;&amp;lt; &amp;quot;--- &amp;quot; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;quot; ---\n&amp;quot;;
    long long total_duration_ms = 0;

    for (int i = 0; i &amp;lt; TEST_ITERATIONS; ++i) {
        auto start = high_resolution_clock::now();
        
        // 避免编译器优化掉函数调用
        volatile long long result = func(data); 

        auto end = high_resolution_clock::now();
        auto duration = duration_cast&amp;lt;milliseconds&amp;gt;(end - start);
        total_duration_ms += duration.count();
        
        // 确保结果被使用，避免优化，同时验证两种模式结果一致
        if (i == 0) {
            std::cout &amp;lt;&amp;lt; &amp;quot;  [Result Check]: &amp;quot; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
        }
        std::cout &amp;lt;&amp;lt; &amp;quot;  Iteration &amp;quot; &amp;lt;&amp;lt; i + 1 &amp;lt;&amp;lt; &amp;quot; Time: &amp;quot; &amp;lt;&amp;lt; duration.count() &amp;lt;&amp;lt; &amp;quot; ms\n&amp;quot;;
    }

    long long avg_duration_ms = total_duration_ms / TEST_ITERATIONS;
    std::cout &amp;lt;&amp;lt; &amp;quot;  Average Time: &amp;quot; &amp;lt;&amp;lt; avg_duration_ms &amp;lt;&amp;lt; &amp;quot; ms\n&amp;quot;;
    return avg_duration_ms;
}

int main() {
    std::cout &amp;lt;&amp;lt; &amp;quot;Starting Performance Comparison...\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Size: &amp;quot; &amp;lt;&amp;lt; DATA_SIZE &amp;lt;&amp;lt; &amp;quot; elements.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Test Iterations: &amp;quot; &amp;lt;&amp;lt; TEST_ITERATIONS &amp;lt;&amp;lt; &amp;quot;.\n\n&amp;quot;;

    // 1. 准备数据
    auto data = create_test_data();

    // 2. 传统模式测试
    long long traditional_time = run_test(
        &amp;quot;Traditional For Loop (Index-based)&amp;quot;, 
        traditional_loop, 
        data
    );

    // 3. Enumerate 模式测试
    long long enumerate_time = run_test(
        &amp;quot;std::views::enumerate Loop (Ranges)&amp;quot;, 
        enumerate_loop, 
        data
    );

    // 4. 总结对比
    std::cout &amp;lt;&amp;lt; &amp;quot;\n==============================\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Final Performance Comparison\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;==============================\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Traditional Loop Average Time: &amp;quot; &amp;lt;&amp;lt; traditional_time &amp;lt;&amp;lt; &amp;quot; ms\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Enumerate Loop Average Time:   &amp;quot; &amp;lt;&amp;lt; enumerate_time &amp;lt;&amp;lt; &amp;quot; ms\n&amp;quot;;

    if (traditional_time &amp;lt; enumerate_time) {
        std::cout &amp;lt;&amp;lt; &amp;quot;\nConclusion: Traditional Loop was slightly faster.\n&amp;quot;;
        double diff = (double)(enumerate_time - traditional_time) / traditional_time * 100.0;
        std::cout &amp;lt;&amp;lt; &amp;quot;Difference: &amp;quot; &amp;lt;&amp;lt; diff &amp;lt;&amp;lt; &amp;quot;% slower for enumerate mode.\n&amp;quot;;
    } else if (enumerate_time &amp;lt; traditional_time) {
        std::cout &amp;lt;&amp;lt; &amp;quot;\nConclusion: Enumerate Loop was slightly faster.\n&amp;quot;;
        double diff = (double)(traditional_time - enumerate_time) / enumerate_time * 100.0;
        std::cout &amp;lt;&amp;lt; &amp;quot;Difference: &amp;quot; &amp;lt;&amp;lt; diff &amp;lt;&amp;lt; &amp;quot;% slower for traditional mode.\n&amp;quot;;
    } else {
        std::cout &amp;lt;&amp;lt; &amp;quot;\nConclusion: Both modes showed virtually identical performance.\n&amp;quot;;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;性能差异分析与结论&#34;&gt;性能差异分析与结论
&lt;/h2&gt;&lt;h3 id=&#34;理论分析&#34;&gt;理论分析
&lt;/h3&gt;&lt;p&gt;在 C++ 中，&lt;strong&gt;性能差异的根本原因在于编译器能否进行零开销抽象 (Zero-Overhead Abstraction)&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;传统循环：&lt;/strong&gt; 直接操作内存地址和索引，是最底层、最高效的方式。
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;for (std::size_t idx = 0; idx &amp;lt; data.size(); ++idx) { /* ... data[idx] ... */ }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;std::views::enumerate&lt;/code&gt; 循环：&lt;/strong&gt; 引入了 &lt;code&gt;enumerate_view&lt;/code&gt; 这个抽象层。在内部，它通过迭代器实现了索引和值的配对。
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;for (const auto&amp;amp; [idx, item] : std::views::enumerate(data)) { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于现代高度优化的编译器 (如 GCC/Clang 开启 O2/O3 优化)，它们会&lt;strong&gt;内联 (inline)&lt;/strong&gt; &lt;code&gt;enumerate_view&lt;/code&gt; 及其迭代器的操作，并执行&lt;strong&gt;循环展开 (loop unrolling)&lt;/strong&gt; 等优化。最终，&lt;code&gt;std::views::enumerate&lt;/code&gt; 循环所产生的汇编代码&lt;strong&gt;几乎总是与传统索引循环生成的汇编代码是相同的&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;实际测试结论&#34;&gt;实际测试结论
&lt;/h3&gt;&lt;p&gt;基于实际运行测试 Demo 的结果 (使用 O2/O3 优化)：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;模式&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;平均耗时 (ms)&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;性能差异&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;可读性/安全性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;传统索引循环&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;X (基准)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;≈ 0%&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;低：需手动管理索引，易出错&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;&lt;code&gt;std::views::enumerate&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;X ± 极小波动&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;≈ 0%&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;高：&lt;/strong&gt; 自动索引，简洁安全&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;结论：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在使用了编译器优化的情况下，&lt;strong&gt;&lt;code&gt;std::views::enumerate&lt;/code&gt; 模式与传统的索引循环模式在性能上几乎没有差异&lt;/strong&gt;，可以认为它们的性能表现是&lt;strong&gt;等价&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;因此，&lt;strong&gt;在 C++23 或更高版本中，推荐使用 &lt;code&gt;std::views::enumerate&lt;/code&gt; 模式&lt;/strong&gt;，因为它在不牺牲性能的前提下，显著提高了代码的&lt;strong&gt;可读性、简洁性&lt;/strong&gt;和&lt;strong&gt;安全性&lt;/strong&gt;。&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
