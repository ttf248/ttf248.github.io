<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>基础 on 向叔记事簿</title>
        <link>https://ttf248.life/tags/%E5%9F%BA%E7%A1%80/</link>
        <description>Recent content in 基础 on 向叔记事簿</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Sat, 28 Feb 2026 18:47:02 +0800</lastBuildDate><atom:link href="https://ttf248.life/tags/%E5%9F%BA%E7%A1%80/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>美股的合拆股理解起来不顺畅</title>
        <link>https://ttf248.life/p/understanding-spin-offs-and-splits-in-the-us-stock-market-can-be-challenging/</link>
        <pubDate>Wed, 13 Aug 2025 22:09:31 +0800</pubDate>
        
        <guid>https://ttf248.life/p/understanding-spin-offs-and-splits-in-the-us-stock-market-can-be-challenging/</guid>
        <description>&lt;p&gt;作为中国人，在看到英文财经资讯，美股公司行动相关的资料，为什么合股要这样写：NAOV reverse stock split: 1 for 10，是英文特有的语法吗，不符合中文的语法习惯，据此，你再解释下拆股&lt;/p&gt;
&lt;p&gt;您好！这是一个非常好的问题，很多以中文为母语的投资者在初次接触英文财经资讯时都会有同样的困惑。这确实是英文在财经领域的一种特定表达习惯，和中文的语序有很大不同。&lt;/p&gt;
&lt;p&gt;我来为您详细解释一下。&lt;/p&gt;
&lt;h2 id=&#34;为什么合股要写成-1-for-10&#34;&gt;为什么合股要写成 “1 for 10”？
&lt;/h2&gt;&lt;p&gt;首先，我们来拆解这个表达方式：&lt;strong&gt;&lt;code&gt;A for B&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这个结构里：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A&lt;/strong&gt; 代表你 &lt;strong&gt;将要得到的新东西&lt;/strong&gt; (the result)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;B&lt;/strong&gt; 代表你 &lt;strong&gt;需要付出的旧东西&lt;/strong&gt; (the cost/exchange)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;for&lt;/strong&gt; 这个词在这里的意思是“&lt;strong&gt;用来交换&lt;/strong&gt;”(in exchange for)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，&lt;strong&gt;“1 for 10 reverse stock split”&lt;/strong&gt; 的直接翻译就是：“&lt;strong&gt;1股新股，用来交换10股旧股&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;换句话说，就是您的 &lt;strong&gt;每10股旧股票，将被合并成1股新股票&lt;/strong&gt;。这正是中文里“&lt;strong&gt;10合1&lt;/strong&gt;”或“&lt;strong&gt;10股并1股&lt;/strong&gt;”的意思。&lt;/p&gt;
&lt;h3 id=&#34;语法习惯对比&#34;&gt;语法习惯对比
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;英文习惯 (结果 for 原因/代价)&lt;/strong&gt;：把“得到的结果”放在前面，把“付出的代价”放在后面。例如 &lt;code&gt;You get 1 new share for your 10 old shares.&lt;/code&gt; 新闻标题为了简洁，就缩写成了 &lt;code&gt;1 for 10&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中文习惯 (原因/代价 -&amp;gt; 结果)&lt;/strong&gt;：倾向于按时间或逻辑顺序，先把“原来的状态”说出来，再说“之后的结果”。例如“（原来的）10股合并成（现在的）1股”。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，这并不是一个普遍的英文语法，而是在商业和金融领域表示“交换比率”时非常常见的一种惯例和简写。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举例说明 (NAOV 1 for 10 Reverse Stock Split):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设在合股前，您持有1000股NAOV公司的股票，当时股价为$0.5美元/股。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;总资产价值&lt;/strong&gt;：1000股 * $0.5/股 = $500美元&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;合股（1 for 10）之后：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;您的持股数量&lt;/strong&gt;：1000股 / 10 = 100股&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;每股价格（理论上）&lt;/strong&gt;：$0.5/股 * 10 = $5美元/股&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;总资产价值&lt;/strong&gt;：100股 * $5/股 = $500美元&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;：合股的主要目的是提高单股的股价，它会减少您持有的股票数量，但（在不考虑市场波动的情况下）您的总资产价值是保持不变的。公司通常为了满足交易所最低股价要求（比如纳斯达克要求股价维持在$1以上）而进行合股。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;拆股-stock-split-的解释&#34;&gt;拆股 (Stock Split) 的解释
&lt;/h2&gt;&lt;p&gt;理解了合股的逻辑后，拆股就很容易明白了。拆股是合股的相反操作。&lt;/p&gt;
&lt;p&gt;英文通常会这样写：&lt;strong&gt;&lt;code&gt;2 for 1 stock split&lt;/code&gt;&lt;/strong&gt; 或者 &lt;strong&gt;&lt;code&gt;3 for 1 stock split&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;使用我们上面学到的 &lt;code&gt;A for B&lt;/code&gt; 结构来解读：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;2 for 1 stock split&lt;/code&gt;&lt;/strong&gt; 的意思就是：“&lt;strong&gt;你会得到2股新股，用来交换你手上的1股旧股&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;这正是中文里“&lt;strong&gt;1拆2&lt;/strong&gt;”或“&lt;strong&gt;1股拆为2股&lt;/strong&gt;”的意思。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举例说明 (某公司 2 for 1 Stock Split):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设在拆股前，您持有100股某公司的股票，当时股价为$200美元/股。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;总资产价值&lt;/strong&gt;：100股 * $200/股 = $20,000美元&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;拆股（2 for 1）之后：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;您的持股数量&lt;/strong&gt;：100股 * 2 = 200股&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;每股价格（理论上）&lt;/strong&gt;：$200/股 / 2 = $100美元/股&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;总资产价值&lt;/strong&gt;：200股 * $100/股 = $20,000美元&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;：拆股的目的是降低单股的股价，使其对小额投资者更具吸引力，从而增加股票的流动性。它会增加您的持股数量，但同样地，您的总资产价值保持不变。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;公司行动&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;中文说法&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;英文写法示例&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;英文含义&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;对持股数量的影响&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;对每股股价的影响&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;合股 (Reverse Split)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;10合1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;1 for 10&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用10股旧股换1股新股&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;减少&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;升高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;拆股 (Stock Split)&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1拆2&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;2 for 1&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用1股旧股换2股新股&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;增加&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;降低&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;希望这个解释能帮助您更好地理解英文财经资讯！这确实是一个需要转换一下思维方式才能习惯的表达。&lt;/p&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43; 位操作基础：按位取值与标志位设置</title>
        <link>https://ttf248.life/p/cpp-bitwise-operations-flags/</link>
        <pubDate>Fri, 17 Jan 2025 02:23:56 +0800</pubDate>
        
        <guid>https://ttf248.life/p/cpp-bitwise-operations-flags/</guid>
        <description>&lt;p&gt;在实际的C++开发中，位操作是常见的技术，尤其在处理系统状态、标志位或控制位时，位操作可以提供非常高效的解决方案。本文将通过一个例子，讲解如何使用位操作来获取和设置特定的标志位。&lt;/p&gt;
&lt;h3 id=&#34;位操作基础概念&#34;&gt;位操作基础概念
&lt;/h3&gt;&lt;p&gt;在计算机中，数据是以二进制位（0和1）存储的。位操作就是对二进制位进行操作。C++中有几种常用的位操作符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;按位与（&amp;amp;）&lt;/strong&gt;：用于检查某一位是否为1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按位或（|）&lt;/strong&gt;：用于设置某一位为1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按位异或（^）&lt;/strong&gt;：用于反转某一位。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按位取反（~）&lt;/strong&gt;：将所有位反转。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;左移（&amp;laquo;）&lt;/strong&gt;：将所有位左移若干位。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;右移（&amp;raquo;）&lt;/strong&gt;：将所有位右移若干位。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在本例中，我们需要对一个 &lt;code&gt;unsigned short&lt;/code&gt; 类型的变量 &lt;code&gt;wInfo&lt;/code&gt; 进行一系列的位操作，通过不同的标志位来表示不同的状态。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;flowchart LR
    A[原始数值: 00010000] --&amp;gt; B[左移: 00010000 &amp;lt;&amp;lt; 1]
    B --&amp;gt; C[结果: 00100000]
    C --&amp;gt; D[右移: 00100000 &amp;gt;&amp;gt; 1]
    D --&amp;gt; E[结果: 00010000]

    subgraph 左移操作
        direction LR
        A --&amp;gt; B --&amp;gt; C
    end

    subgraph 右移操作
        direction LR
        C --&amp;gt; D --&amp;gt; E
    end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;需求解析&#34;&gt;需求解析
&lt;/h3&gt;&lt;p&gt;根据题目中的描述，我们有一个 16 位的标志位，用来表示不同的状态。这些状态通过各个不同的二进制位来表示，每个二进制位对应一种特定的含义。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;bit0&lt;/strong&gt; 是否失败&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit1&lt;/strong&gt; 是否压缩&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit2&lt;/strong&gt; 是否增量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit3&lt;/strong&gt; 是否有后续包&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit5&lt;/strong&gt; 正常请求或注销&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;使用位操作实现&#34;&gt;使用位操作实现
&lt;/h3&gt;&lt;p&gt;我们将通过位操作来设置和获取这些标志位。具体来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;按位取值&lt;/strong&gt;：获取某一位的值（0或1）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按位设置&lt;/strong&gt;：设置某一位为1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按位清除&lt;/strong&gt;：设置某一位为0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们首先定义一个 &lt;code&gt;unsigned short&lt;/code&gt; 类型的变量 &lt;code&gt;wInfo&lt;/code&gt; 来保存这些标志位。然后，我们通过位操作来检查和设置相应的标志。&lt;/p&gt;
&lt;h3 id=&#34;c-示例代码&#34;&gt;C++ 示例代码
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;bitset&amp;gt;

// 定义标志位常量
const unsigned short BIT_0_FAIL = 1 &amp;lt;&amp;lt; 0;    // bit0 是否失败
const unsigned short BIT_1_COMPRESSED = 1 &amp;lt;&amp;lt; 1; // bit1 是否压缩
const unsigned short BIT_2_INCREMENT = 1 &amp;lt;&amp;lt; 2;  // bit2 是否增量
const unsigned short BIT_3_HAS_MORE = 1 &amp;lt;&amp;lt; 3;   // bit3 是否有后续包
const unsigned short BIT_5_CANCEL = 1 &amp;lt;&amp;lt; 5;     // bit5 正常请求(0)或注销(1)

// 检查某一位是否为1
bool isBitSet(unsigned short wInfo, unsigned short bitMask) {
    return (wInfo &amp;amp; bitMask) != 0;
}

// 设置某一位为1
void setBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo |= bitMask;
}

// 清除某一位（设置为0）
void clearBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo &amp;amp;= ~bitMask;
}

int main() {
    // 假设wInfo的初始值为0
    unsigned short wInfo = 0;

    // 设置bit0（失败标志）
    setBit(wInfo, BIT_0_FAIL);
    
    // 设置bit1（压缩标志）
    setBit(wInfo, BIT_1_COMPRESSED);
    
    // 打印wInfo的二进制值
    std::cout &amp;lt;&amp;lt; &amp;quot;wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    // 检查各个标志位
    std::cout &amp;lt;&amp;lt; &amp;quot;bit0 (是否失败): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_0_FAIL) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit1 (是否压缩): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_1_COMPRESSED) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit2 (是否增量): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_2_INCREMENT) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit3 (是否有后续包): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_3_HAS_MORE) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit5 (是否注销): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_5_CANCEL) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;

    // 清除bit1（压缩标志）
    clearBit(wInfo, BIT_1_COMPRESSED);
    
    // 打印更新后的wInfo
    std::cout &amp;lt;&amp;lt; &amp;quot;Updated wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行代码，推荐老朋友：&lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wInfo (in binary): 0000000000000011
bit0 (是否失败): 是
bit1 (是否压缩): 是
bit2 (是否增量): 否
bit3 (是否有后续包): 否
bit5 (是否注销): 否
Updated wInfo (in binary): 0000000000000001
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;代码解释&#34;&gt;代码解释
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标志位定义&lt;/strong&gt;：使用位移操作（&lt;code&gt;1 &amp;lt;&amp;lt; n&lt;/code&gt;）来定义各个标志位。例如，&lt;code&gt;1 &amp;lt;&amp;lt; 0&lt;/code&gt; 对应 &lt;code&gt;bit0&lt;/code&gt;，&lt;code&gt;1 &amp;lt;&amp;lt; 1&lt;/code&gt; 对应 &lt;code&gt;bit1&lt;/code&gt;，依此类推。这样，我们就为每个标志位分配了唯一的二进制位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;检查某一位&lt;/strong&gt;：&lt;code&gt;isBitSet&lt;/code&gt; 函数通过与运算 &lt;code&gt;wInfo &amp;amp; bitMask&lt;/code&gt; 来检查特定的标志位是否为1。如果该位为1，函数返回&lt;code&gt;true&lt;/code&gt;，否则返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;设置某一位&lt;/strong&gt;：&lt;code&gt;setBit&lt;/code&gt; 函数通过按位或操作 &lt;code&gt;wInfo |= bitMask&lt;/code&gt; 来将特定的标志位置为1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;清除某一位&lt;/strong&gt;：&lt;code&gt;clearBit&lt;/code&gt; 函数通过按位与操作 &lt;code&gt;wInfo &amp;amp;= ~bitMask&lt;/code&gt; 来将特定的标志位置为0。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结
&lt;/h3&gt;&lt;p&gt;通过位操作，我们能够高效地处理多个状态标志位。在实际开发中，这种技术尤其有用。例如，在嵌入式开发、网络协议、系统状态管理等场景中，常常使用位标志来表示多个二进制状态，既节省空间又提高效率。&lt;/p&gt;
&lt;p&gt;希望这篇博客能够帮助你理解如何在 C++ 中使用位操作来实现按位取值和设置，掌握这些技能对编写高效且易于维护的代码非常有帮助！&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
