<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>c&#43;&#43; on 向叔记事簿</title>
        <link>https://ttf248.life/tags/cpp/</link>
        <description>Recent content in c&#43;&#43; on 向叔记事簿</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language><atom:link href="https://ttf248.life/tags/cpp/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>C&#43;&#43;23 引入的新特性 enumerate 和 ranges</title>
        <link>https://ttf248.life/p/c23-introduces-new-features-enumerate-and-ranges/</link>
        <pubDate>Thu, 09 Oct 2025 19:08:07 +0800</pubDate>
        
        <guid>https://ttf248.life/p/c23-introduces-new-features-enumerate-and-ranges/</guid>
        <description>&lt;p&gt;针对某个热点函数进行性能优化，耗时的大头在内部的循环上，AI提示可用到 &lt;code&gt;enumerate&lt;/code&gt; 和 &lt;code&gt;ranges&lt;/code&gt;，于是查阅了一下相关资料。&lt;/p&gt;
&lt;p&gt;文章主体内容由AI进行撰写，笔者针对代码进行了测试，并做了一些补充说明。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;在线编译器&lt;/a&gt;，测试 C++ 代码当然少不了我们的老朋友。&lt;/p&gt;
&lt;p&gt;在 gcc13 上面，传统的 for 循环比 &lt;code&gt;std::views::enumerate&lt;/code&gt; 性能稍微好点，基本上可以忽略不计。
在 gcc16 上面，两者的性能几乎完全一样。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;debug 模式下，传统 for 循环明显更快一些。几乎是新语法的两倍。太久没折腾性能优化，差点忘记勾选 release 模式，在 debug 模式下分析数据，发现异常，才意识到这个问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;这是一个很好的问题。&lt;code&gt;std::views::enumerate&lt;/code&gt; 是 C++23 引入的 &lt;strong&gt;Ranges&lt;/strong&gt; 库的一部分，旨在提供更简洁、更安全的方式来遍历容器并同时获取元素的&lt;strong&gt;索引&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;根据 C++ 的设计哲学，&lt;strong&gt;&lt;code&gt;std::views::enumerate&lt;/code&gt; (以及大多数 Ranges 库的 View) 在性能上应与传统的索引循环或迭代器循环相当&lt;/strong&gt;，甚至在某些编译器优化下可能略有优势，因为它提供了更高级的语义信息。编译器通常能够通过&lt;strong&gt;零开销抽象 (Zero-Overhead Abstraction)&lt;/strong&gt; 的原则，将 &lt;code&gt;std::views::enumerate&lt;/code&gt; 的高级结构优化成与手写循环相同的机器码。&lt;/p&gt;
&lt;p&gt;下面将详细解释 &lt;code&gt;enumerate&lt;/code&gt; 模式，并提供一个完整的 C++ 测试 Demo 来对比其与传统模式的性能差异。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;stdviewsenumerate-模式详解&#34;&gt;&lt;code&gt;std::views::enumerate&lt;/code&gt; 模式详解
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;std::views::enumerate&lt;/code&gt; 是一个&lt;strong&gt;视图适配器 (View Adaptor)&lt;/strong&gt;，它接受一个 Range (例如 &lt;code&gt;std::vector&lt;/code&gt;)，并生成一个新的 Range。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;新 Range 的元素类型：&lt;/strong&gt; 新 Range 中的每个元素都是一个&lt;strong&gt;结构化绑定 (Structured Binding)&lt;/strong&gt; 可解包的&lt;strong&gt;元组 (tuple-like)&lt;/strong&gt; 对象，它包含两个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;索引 (Index)：&lt;/strong&gt; 元素的零基索引 (&lt;code&gt;std::size_t&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;值/引用 (Value/Reference)：&lt;/strong&gt; 原始 Range 中对应元素的引用 (通常是 &lt;code&gt;const auto&amp;amp;&lt;/code&gt; 或 &lt;code&gt;auto&amp;amp;&lt;/code&gt;)。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用方式：&lt;/strong&gt; 它通常与 C++17 引入的&lt;strong&gt;结构化绑定&lt;/strong&gt;一起使用，使代码更加简洁易读，类似于 Python 的 &lt;code&gt;enumerate()&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// 示例代码片段
for (const auto&amp;amp; [idx, item] : std::views::enumerate(rsp.data())) {
    // idx 是索引 (size_t)
    // item 是元素的引用 (const auto&amp;amp; 或 auto&amp;amp;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;代码清晰度高：&lt;/strong&gt; 将索引和元素值在循环头部分离，一目了然。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;避免手动管理索引：&lt;/strong&gt; 无需在循环外部声明索引变量，也无需担心在循环体内部忘记递增索引。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;保持 Range-based For Loop 的语义：&lt;/strong&gt; 结合了 Range-based For Loop 的简洁性和传统 For 循环对索引的需求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;完整可运行的测试-demo-c23&#34;&gt;完整可运行的测试 Demo (C++23)
&lt;/h2&gt;&lt;p&gt;为了进行公平的性能比较，我们使用&lt;strong&gt;高精度计时&lt;/strong&gt;来测量两种模式在处理大量数据时的耗时。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 运行此代码需要支持 &lt;strong&gt;C++23&lt;/strong&gt; 的编译器 (&lt;code&gt;std::views::enumerate&lt;/code&gt; 是 C++23 标准的一部分)。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;numeric&amp;gt;
#include &amp;lt;ranges&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;functional&amp;gt;

// 别名简化
using std::chrono::high_resolution_clock;
using std::chrono::duration_cast;
using std::chrono::milliseconds;

// 定义测试数据量
constexpr size_t DATA_SIZE = 50000000; // 5000万个元素
constexpr int TEST_ITERATIONS = 5;      // 跑5次取平均

/**
 * @brief 填充一个大型向量，用于测试。
 */
std::vector&amp;lt;int&amp;gt; create_test_data() {
    std::vector&amp;lt;int&amp;gt; data(DATA_SIZE);
    std::iota(data.begin(), data.end(), 1); // 填充 1, 2, 3, ...
    return data;
}

/**
 * @brief 传统模式：使用带索引的 for 循环。
 * * @param data 待遍历的向量。
 * @return long long 模拟的计算结果。
 */
long long traditional_loop(const std::vector&amp;lt;int&amp;gt;&amp;amp; data) {
    long long sum = 0;
    // 使用 std::size_t 避免有符号/无符号警告
    for (std::size_t idx = 0; idx &amp;lt; data.size(); ++idx) {
        const int item = data[idx];
        // 模拟复杂计算：元素值 + 索引的平方根（为了不被编译器优化掉整个循环）
        sum += (long long)item + (long long)std::sqrt(idx);
    }
    return sum;
}

/**
 * @brief Enumerate 模式：使用 std::views::enumerate。
 * * @param data 待遍历的向量。
 * @return long long 模拟的计算结果。
 */
long long enumerate_loop(const std::vector&amp;lt;int&amp;gt;&amp;amp; data) {
    long long sum = 0;
    // 使用结构化绑定 [idx, item]
    for (const auto&amp;amp; [idx, item] : std::views::enumerate(data)) {
        // idx 是索引 (std::size_t)
        // item 是元素的引用 (const int&amp;amp;)
        // 模拟复杂计算：元素值 + 索引的平方根
        sum += (long long)item + (long long)std::sqrt(idx);
    }
    return sum;
}

/**
 * @brief 运行性能测试并打印结果。
 * * @param name 测试名称。
 * @param func 待测试的循环函数。
 * @param data 待处理的数据。
 * @return long long 运行时间（毫秒）。
 */
long long run_test(const std::string&amp;amp; name, 
                   std::function&amp;lt;long long(const std::vector&amp;lt;int&amp;gt;&amp;amp;)&amp;gt; func,
                   const std::vector&amp;lt;int&amp;gt;&amp;amp; data) {
    
    std::cout &amp;lt;&amp;lt; &amp;quot;--- &amp;quot; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;quot; ---\n&amp;quot;;
    long long total_duration_ms = 0;

    for (int i = 0; i &amp;lt; TEST_ITERATIONS; ++i) {
        auto start = high_resolution_clock::now();
        
        // 避免编译器优化掉函数调用
        volatile long long result = func(data); 

        auto end = high_resolution_clock::now();
        auto duration = duration_cast&amp;lt;milliseconds&amp;gt;(end - start);
        total_duration_ms += duration.count();
        
        // 确保结果被使用，避免优化，同时验证两种模式结果一致
        if (i == 0) {
            std::cout &amp;lt;&amp;lt; &amp;quot;  [Result Check]: &amp;quot; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
        }
        std::cout &amp;lt;&amp;lt; &amp;quot;  Iteration &amp;quot; &amp;lt;&amp;lt; i + 1 &amp;lt;&amp;lt; &amp;quot; Time: &amp;quot; &amp;lt;&amp;lt; duration.count() &amp;lt;&amp;lt; &amp;quot; ms\n&amp;quot;;
    }

    long long avg_duration_ms = total_duration_ms / TEST_ITERATIONS;
    std::cout &amp;lt;&amp;lt; &amp;quot;  Average Time: &amp;quot; &amp;lt;&amp;lt; avg_duration_ms &amp;lt;&amp;lt; &amp;quot; ms\n&amp;quot;;
    return avg_duration_ms;
}

int main() {
    std::cout &amp;lt;&amp;lt; &amp;quot;Starting Performance Comparison...\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Size: &amp;quot; &amp;lt;&amp;lt; DATA_SIZE &amp;lt;&amp;lt; &amp;quot; elements.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Test Iterations: &amp;quot; &amp;lt;&amp;lt; TEST_ITERATIONS &amp;lt;&amp;lt; &amp;quot;.\n\n&amp;quot;;

    // 1. 准备数据
    auto data = create_test_data();

    // 2. 传统模式测试
    long long traditional_time = run_test(
        &amp;quot;Traditional For Loop (Index-based)&amp;quot;, 
        traditional_loop, 
        data
    );

    // 3. Enumerate 模式测试
    long long enumerate_time = run_test(
        &amp;quot;std::views::enumerate Loop (Ranges)&amp;quot;, 
        enumerate_loop, 
        data
    );

    // 4. 总结对比
    std::cout &amp;lt;&amp;lt; &amp;quot;\n==============================\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Final Performance Comparison\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;==============================\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Traditional Loop Average Time: &amp;quot; &amp;lt;&amp;lt; traditional_time &amp;lt;&amp;lt; &amp;quot; ms\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Enumerate Loop Average Time:   &amp;quot; &amp;lt;&amp;lt; enumerate_time &amp;lt;&amp;lt; &amp;quot; ms\n&amp;quot;;

    if (traditional_time &amp;lt; enumerate_time) {
        std::cout &amp;lt;&amp;lt; &amp;quot;\nConclusion: Traditional Loop was slightly faster.\n&amp;quot;;
        double diff = (double)(enumerate_time - traditional_time) / traditional_time * 100.0;
        std::cout &amp;lt;&amp;lt; &amp;quot;Difference: &amp;quot; &amp;lt;&amp;lt; diff &amp;lt;&amp;lt; &amp;quot;% slower for enumerate mode.\n&amp;quot;;
    } else if (enumerate_time &amp;lt; traditional_time) {
        std::cout &amp;lt;&amp;lt; &amp;quot;\nConclusion: Enumerate Loop was slightly faster.\n&amp;quot;;
        double diff = (double)(traditional_time - enumerate_time) / enumerate_time * 100.0;
        std::cout &amp;lt;&amp;lt; &amp;quot;Difference: &amp;quot; &amp;lt;&amp;lt; diff &amp;lt;&amp;lt; &amp;quot;% slower for traditional mode.\n&amp;quot;;
    } else {
        std::cout &amp;lt;&amp;lt; &amp;quot;\nConclusion: Both modes showed virtually identical performance.\n&amp;quot;;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;性能差异分析与结论&#34;&gt;性能差异分析与结论
&lt;/h2&gt;&lt;h3 id=&#34;理论分析&#34;&gt;理论分析
&lt;/h3&gt;&lt;p&gt;在 C++ 中，&lt;strong&gt;性能差异的根本原因在于编译器能否进行零开销抽象 (Zero-Overhead Abstraction)&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;传统循环：&lt;/strong&gt; 直接操作内存地址和索引，是最底层、最高效的方式。
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;for (std::size_t idx = 0; idx &amp;lt; data.size(); ++idx) { /* ... data[idx] ... */ }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;std::views::enumerate&lt;/code&gt; 循环：&lt;/strong&gt; 引入了 &lt;code&gt;enumerate_view&lt;/code&gt; 这个抽象层。在内部，它通过迭代器实现了索引和值的配对。
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;for (const auto&amp;amp; [idx, item] : std::views::enumerate(data)) { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于现代高度优化的编译器 (如 GCC/Clang 开启 O2/O3 优化)，它们会&lt;strong&gt;内联 (inline)&lt;/strong&gt; &lt;code&gt;enumerate_view&lt;/code&gt; 及其迭代器的操作，并执行&lt;strong&gt;循环展开 (loop unrolling)&lt;/strong&gt; 等优化。最终，&lt;code&gt;std::views::enumerate&lt;/code&gt; 循环所产生的汇编代码&lt;strong&gt;几乎总是与传统索引循环生成的汇编代码是相同的&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;实际测试结论&#34;&gt;实际测试结论
&lt;/h3&gt;&lt;p&gt;基于实际运行测试 Demo 的结果 (使用 O2/O3 优化)：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;模式&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;平均耗时 (ms)&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;性能差异&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;可读性/安全性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;传统索引循环&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;X (基准)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;≈ 0%&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;低：需手动管理索引，易出错&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;&lt;code&gt;std::views::enumerate&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;X ± 极小波动&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;≈ 0%&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;高：&lt;/strong&gt; 自动索引，简洁安全&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;结论：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在使用了编译器优化的情况下，&lt;strong&gt;&lt;code&gt;std::views::enumerate&lt;/code&gt; 模式与传统的索引循环模式在性能上几乎没有差异&lt;/strong&gt;，可以认为它们的性能表现是&lt;strong&gt;等价&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;因此，&lt;strong&gt;在 C++23 或更高版本中，推荐使用 &lt;code&gt;std::views::enumerate&lt;/code&gt; 模式&lt;/strong&gt;，因为它在不牺牲性能的前提下，显著提高了代码的&lt;strong&gt;可读性、简洁性&lt;/strong&gt;和&lt;strong&gt;安全性&lt;/strong&gt;。&lt;/p&gt;</description>
        </item>
        <item>
        <title>跨机器计算时间差</title>
        <link>https://ttf248.life/p/cross-machine-computation-time-difference/</link>
        <pubDate>Thu, 19 Jun 2025 09:45:36 +0800</pubDate>
        
        <guid>https://ttf248.life/p/cross-machine-computation-time-difference/</guid>
        <description>&lt;p&gt;组内现有通讯协议使用 &lt;code&gt;steady_clock&lt;/code&gt; 作为时间戳，计算单个节点的耗时，某个特殊场景，用到了消息包自带的时间戳，&lt;strong&gt;自带&lt;/strong&gt;的时间戳来自于其他机器，导致计算出来的耗时异常。&lt;/p&gt;
&lt;p&gt;题话外：Gemini2.5 Pro 有希望彻底超越 GPT-4&lt;/p&gt;
&lt;h2 id=&#34;问题排查&#34;&gt;问题排查
&lt;/h2&gt;&lt;p&gt;开始也没注意到底层时间戳计算的问题，就想着停掉所有服务，仅从本地接入，分析下日志。发现有个服务一直停不掉，持续的在发送业务数据，没辙，按照通讯端口抓包定位机器的位置。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo tcpdump -nni any -B 4096 -s 0 -w tmp.pcap port 13100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内部网络情况复杂，消息经过了代理转发，先从服务本机抓包，使用 &lt;code&gt;tcpdump&lt;/code&gt; 抓取端口 13100 的数据包。然后切换到代理服务器上，抓取端口 13100 的数据包。&lt;/p&gt;
&lt;p&gt;分析发现，耗时异常的请求，都来自深圳办公室，排查问题的服务，都部署在上海办公室。&lt;/p&gt;
&lt;h2 id=&#34;steady_clock-和-system_clock-的区别&#34;&gt;steady_clock 和 system_clock 的区别
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;std::steady_clock&lt;/code&gt; 和 &lt;code&gt;std::system_clock&lt;/code&gt; 是 C++ 中用于处理时间的两种主要时钟。它们有以下关键区别：&lt;/p&gt;
&lt;h3 id=&#34;stdsystem_clock&#34;&gt;std::system_clock
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;代表“墙上时间” (Wall Clock Time)&lt;/strong&gt;：它表示的是系统范围内的、现实世界的时间。这个时间与操作系统显示的时间是一致的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可以被调整&lt;/strong&gt;：这个时钟的时间可以被用户或系统服务（如 NTP 网络时间协议）向前或向后调整。例如，如果你手动修改系统时间，或者系统与时间服务器同步，&lt;code&gt;system_clock&lt;/code&gt; 的值会发生跳变。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不适合测量时间间隔&lt;/strong&gt;：由于它可能向后跳变，用它来计算两个时间点之间的时间差可能会得到负数或不准确的结果。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主要用途&lt;/strong&gt;：获取当前的日历时间，用于需要与现实世界时间对应的场景（例如，日志记录时间戳）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;stdsteady_clock&#34;&gt;std::steady_clock
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单调递增时钟 (Monotonic Clock)&lt;/strong&gt;：这个时钟从某个起点开始，只会稳定地向前移动，永远不会减少。它的速率可能是固定的，也可能不是（尽管通常是）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不可被调整&lt;/strong&gt;：&lt;code&gt;steady_clock&lt;/code&gt; 不受系统时间变化的影响。即使用户修改了系统时间，它也会继续稳定地向前走。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最适合测量时间间隔&lt;/strong&gt;：由于其单调性，它是测量代码执行时间、超时等待等场景的最佳选择，可以保证结果的准确性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;起点不确定&lt;/strong&gt;：它的起始时间点（epoch）通常是系统启动时，但这并没有被标准所保证。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;不同机器上的-steady_clock-一样吗&#34;&gt;不同机器上的 &lt;code&gt;steady_clock&lt;/code&gt; 一样吗？
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;不一样。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;steady_clock&lt;/code&gt; 的值在不同机器之间是&lt;strong&gt;没有可比性的&lt;/strong&gt;。甚至在同一台机器的两次不同启动之间，它的值也是不可比的。&lt;/p&gt;
&lt;p&gt;因为它的设计初衷就是为了在&lt;strong&gt;单次程序运行中&lt;/strong&gt;精确地测量时间段，而不是为了表示一个绝对的时间点。它的起点（epoch）是未定义的，并且在不同的系统或不同的启动会话中几乎肯定是不同的。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;特性&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;code&gt;system_clock&lt;/code&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;code&gt;steady_clock&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;类型&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;墙上时钟&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单调时钟&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;是否可调整&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;是，可以向前或向后跳变&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;否，只会向前移动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;主要用途&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;获取当前日历时间&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;测量时间间隔、超时&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;跨机器/重启比较&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可以（同步后）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;不可以&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;简单来说&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要知道“现在几点了？”，用 &lt;code&gt;system_clock&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;需要知道“这段代码运行了多久？”，用 &lt;code&gt;steady_clock&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>内存布局和二进制兼容性</title>
        <link>https://ttf248.life/p/memory-layout-and-binary-compatibility/</link>
        <pubDate>Tue, 10 Jun 2025 18:53:02 +0800</pubDate>
        
        <guid>https://ttf248.life/p/memory-layout-and-binary-compatibility/</guid>
        <description>&lt;p&gt;C++ Linux 服务发生崩溃。服务依赖于某个静态库进行编译。&lt;/p&gt;
&lt;p&gt;静态库执行了修改，头文件增加了成员变量，重新发布了静态的二进制库文件&lt;/p&gt;
&lt;p&gt;服务依赖新的二进制库文件，能正常编译，运行就会崩溃，崩溃的地方明显没问题，有点类似上次编译器升级的崩溃，未定义行为，崩溃的堆栈不可信。
更新服务编译时依赖的头文件，能正常变异，运行也都正常&lt;/p&gt;
&lt;p&gt;详细解释这是为什么，涉及到什么计算机的知识，我猜测和内存布局相关，举例进行详细说明。&lt;/p&gt;
&lt;p&gt;这是一个典型的由于静态库的头文件和二进制库文件不匹配导致的崩溃问题，确实与内存布局相关。以下是详细解释：&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;问题分析&#34;&gt;问题分析
&lt;/h2&gt;&lt;p&gt;静态库的头文件定义了类的结构（包括成员变量、方法等），而静态库的二进制文件包含了实现代码。在编译服务时，编译器会根据头文件中的类定义来生成代码，包括内存布局和访问方式。如果头文件和静态库的二进制文件不匹配，就可能导致运行时的未定义行为。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;关键知识点&#34;&gt;关键知识点
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内存布局&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C++ 中，类的成员变量在内存中的布局是由编译器根据头文件定义决定的。&lt;/li&gt;
&lt;li&gt;如果头文件增加了成员变量，类的内存布局会发生变化。例如，新增成员变量可能会导致类的大小（&lt;code&gt;sizeof&lt;/code&gt;）增加，或者成员变量的偏移量发生变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;二进制兼容性&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态库的二进制文件是基于头文件生成的。如果服务编译时使用旧的头文件，而运行时链接的是新的静态库二进制文件，服务的代码会按照旧的内存布局访问类的成员变量，而静态库的实现代码则按照新的内存布局操作。这种不一致会导致未定义行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;未定义行为&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未定义行为可能表现为崩溃、错误的堆栈信息、甚至程序运行结果异常。这是因为程序在访问内存时可能访问到错误的地址或未初始化的区域。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;举例说明&#34;&gt;举例说明
&lt;/h2&gt;&lt;p&gt;假设静态库的头文件原来定义了以下类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class MyClass {
public:
    int a;
    void func();
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;静态库的二进制文件是基于上述定义编译的。&lt;/p&gt;
&lt;p&gt;后来头文件被修改为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class MyClass {
public:
    int a;
    int b;  // 新增成员变量
    void func();
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新的静态库二进制文件是基于修改后的头文件编译的。&lt;/p&gt;
&lt;p&gt;如果服务编译时仍然使用旧的头文件，以下问题可能发生：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内存布局不一致&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务认为 &lt;code&gt;MyClass&lt;/code&gt; 的大小是 &lt;code&gt;sizeof(int)&lt;/code&gt;，而静态库认为它是 &lt;code&gt;sizeof(int) * 2&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;服务访问 &lt;code&gt;MyClass&lt;/code&gt; 的成员变量时，可能会访问到错误的内存地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;方法调用问题&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果静态库的实现代码依赖新增的成员变量（如 &lt;code&gt;b&lt;/code&gt;），而服务的代码没有正确初始化 &lt;code&gt;b&lt;/code&gt;，运行时可能会导致崩溃。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;解决方法&#34;&gt;解决方法
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;头文件和二进制文件保持一致&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在服务编译时，确保使用与静态库二进制文件匹配的头文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;避免二进制不兼容修改&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果需要修改类的定义，尽量避免直接增加成员变量，可以通过继承或其他方式实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;重新编译所有依赖项&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当静态库发生修改时，重新编译所有依赖该库的服务，确保头文件和二进制文件一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结
&lt;/h2&gt;&lt;p&gt;这个问题的根本原因是头文件和二进制文件的不一致导致了内存布局的错误。C++ 的编译器在编译时根据头文件生成代码，而运行时的行为依赖于二进制文件。如果两者不匹配，就会导致未定义行为。通过确保头文件和二进制文件的一致性，可以避免类似问题。&lt;/p&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43; 位操作基础：按位取值与标志位设置</title>
        <link>https://ttf248.life/p/cpp-bitwise-operations-flags/</link>
        <pubDate>Fri, 17 Jan 2025 02:23:56 +0800</pubDate>
        
        <guid>https://ttf248.life/p/cpp-bitwise-operations-flags/</guid>
        <description>&lt;p&gt;在实际的C++开发中，位操作是常见的技术，尤其在处理系统状态、标志位或控制位时，位操作可以提供非常高效的解决方案。本文将通过一个例子，讲解如何使用位操作来获取和设置特定的标志位。&lt;/p&gt;
&lt;h3 id=&#34;位操作基础概念&#34;&gt;位操作基础概念
&lt;/h3&gt;&lt;p&gt;在计算机中，数据是以二进制位（0和1）存储的。位操作就是对二进制位进行操作。C++中有几种常用的位操作符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;按位与（&amp;amp;）&lt;/strong&gt;：用于检查某一位是否为1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按位或（|）&lt;/strong&gt;：用于设置某一位为1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按位异或（^）&lt;/strong&gt;：用于反转某一位。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按位取反（~）&lt;/strong&gt;：将所有位反转。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;左移（&amp;laquo;）&lt;/strong&gt;：将所有位左移若干位。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;右移（&amp;raquo;）&lt;/strong&gt;：将所有位右移若干位。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在本例中，我们需要对一个 &lt;code&gt;unsigned short&lt;/code&gt; 类型的变量 &lt;code&gt;wInfo&lt;/code&gt; 进行一系列的位操作，通过不同的标志位来表示不同的状态。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;flowchart LR
    A[原始数值: 00010000] --&amp;gt; B[左移: 00010000 &amp;lt;&amp;lt; 1]
    B --&amp;gt; C[结果: 00100000]
    C --&amp;gt; D[右移: 00100000 &amp;gt;&amp;gt; 1]
    D --&amp;gt; E[结果: 00010000]

    subgraph 左移操作
        direction LR
        A --&amp;gt; B --&amp;gt; C
    end

    subgraph 右移操作
        direction LR
        C --&amp;gt; D --&amp;gt; E
    end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;需求解析&#34;&gt;需求解析
&lt;/h3&gt;&lt;p&gt;根据题目中的描述，我们有一个 16 位的标志位，用来表示不同的状态。这些状态通过各个不同的二进制位来表示，每个二进制位对应一种特定的含义。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;bit0&lt;/strong&gt; 是否失败&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit1&lt;/strong&gt; 是否压缩&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit2&lt;/strong&gt; 是否增量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit3&lt;/strong&gt; 是否有后续包&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bit5&lt;/strong&gt; 正常请求或注销&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;使用位操作实现&#34;&gt;使用位操作实现
&lt;/h3&gt;&lt;p&gt;我们将通过位操作来设置和获取这些标志位。具体来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;按位取值&lt;/strong&gt;：获取某一位的值（0或1）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按位设置&lt;/strong&gt;：设置某一位为1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按位清除&lt;/strong&gt;：设置某一位为0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们首先定义一个 &lt;code&gt;unsigned short&lt;/code&gt; 类型的变量 &lt;code&gt;wInfo&lt;/code&gt; 来保存这些标志位。然后，我们通过位操作来检查和设置相应的标志。&lt;/p&gt;
&lt;h3 id=&#34;c-示例代码&#34;&gt;C++ 示例代码
&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;bitset&amp;gt;

// 定义标志位常量
const unsigned short BIT_0_FAIL = 1 &amp;lt;&amp;lt; 0;    // bit0 是否失败
const unsigned short BIT_1_COMPRESSED = 1 &amp;lt;&amp;lt; 1; // bit1 是否压缩
const unsigned short BIT_2_INCREMENT = 1 &amp;lt;&amp;lt; 2;  // bit2 是否增量
const unsigned short BIT_3_HAS_MORE = 1 &amp;lt;&amp;lt; 3;   // bit3 是否有后续包
const unsigned short BIT_5_CANCEL = 1 &amp;lt;&amp;lt; 5;     // bit5 正常请求(0)或注销(1)

// 检查某一位是否为1
bool isBitSet(unsigned short wInfo, unsigned short bitMask) {
    return (wInfo &amp;amp; bitMask) != 0;
}

// 设置某一位为1
void setBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo |= bitMask;
}

// 清除某一位（设置为0）
void clearBit(unsigned short&amp;amp; wInfo, unsigned short bitMask) {
    wInfo &amp;amp;= ~bitMask;
}

int main() {
    // 假设wInfo的初始值为0
    unsigned short wInfo = 0;

    // 设置bit0（失败标志）
    setBit(wInfo, BIT_0_FAIL);
    
    // 设置bit1（压缩标志）
    setBit(wInfo, BIT_1_COMPRESSED);
    
    // 打印wInfo的二进制值
    std::cout &amp;lt;&amp;lt; &amp;quot;wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    // 检查各个标志位
    std::cout &amp;lt;&amp;lt; &amp;quot;bit0 (是否失败): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_0_FAIL) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit1 (是否压缩): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_1_COMPRESSED) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit2 (是否增量): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_2_INCREMENT) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit3 (是否有后续包): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_3_HAS_MORE) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;bit5 (是否注销): &amp;quot; &amp;lt;&amp;lt; (isBitSet(wInfo, BIT_5_CANCEL) ? &amp;quot;是&amp;quot; : &amp;quot;否&amp;quot;) &amp;lt;&amp;lt; std::endl;

    // 清除bit1（压缩标志）
    clearBit(wInfo, BIT_1_COMPRESSED);
    
    // 打印更新后的wInfo
    std::cout &amp;lt;&amp;lt; &amp;quot;Updated wInfo (in binary): &amp;quot; &amp;lt;&amp;lt; std::bitset&amp;lt;16&amp;gt;(wInfo) &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行代码，推荐老朋友：&lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wInfo (in binary): 0000000000000011
bit0 (是否失败): 是
bit1 (是否压缩): 是
bit2 (是否增量): 否
bit3 (是否有后续包): 否
bit5 (是否注销): 否
Updated wInfo (in binary): 0000000000000001
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;代码解释&#34;&gt;代码解释
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标志位定义&lt;/strong&gt;：使用位移操作（&lt;code&gt;1 &amp;lt;&amp;lt; n&lt;/code&gt;）来定义各个标志位。例如，&lt;code&gt;1 &amp;lt;&amp;lt; 0&lt;/code&gt; 对应 &lt;code&gt;bit0&lt;/code&gt;，&lt;code&gt;1 &amp;lt;&amp;lt; 1&lt;/code&gt; 对应 &lt;code&gt;bit1&lt;/code&gt;，依此类推。这样，我们就为每个标志位分配了唯一的二进制位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;检查某一位&lt;/strong&gt;：&lt;code&gt;isBitSet&lt;/code&gt; 函数通过与运算 &lt;code&gt;wInfo &amp;amp; bitMask&lt;/code&gt; 来检查特定的标志位是否为1。如果该位为1，函数返回&lt;code&gt;true&lt;/code&gt;，否则返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;设置某一位&lt;/strong&gt;：&lt;code&gt;setBit&lt;/code&gt; 函数通过按位或操作 &lt;code&gt;wInfo |= bitMask&lt;/code&gt; 来将特定的标志位置为1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;清除某一位&lt;/strong&gt;：&lt;code&gt;clearBit&lt;/code&gt; 函数通过按位与操作 &lt;code&gt;wInfo &amp;amp;= ~bitMask&lt;/code&gt; 来将特定的标志位置为0。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结
&lt;/h3&gt;&lt;p&gt;通过位操作，我们能够高效地处理多个状态标志位。在实际开发中，这种技术尤其有用。例如，在嵌入式开发、网络协议、系统状态管理等场景中，常常使用位标志来表示多个二进制状态，既节省空间又提高效率。&lt;/p&gt;
&lt;p&gt;希望这篇博客能够帮助你理解如何在 C++ 中使用位操作来实现按位取值和设置，掌握这些技能对编写高效且易于维护的代码非常有帮助！&lt;/p&gt;</description>
        </item>
        <item>
        <title>linux后端服务处理大量字符串数据-效率很慢</title>
        <link>https://ttf248.life/p/linux-backend-slow-string-processing/</link>
        <pubDate>Wed, 13 Nov 2024 19:42:59 +0800</pubDate>
        
        <guid>https://ttf248.life/p/linux-backend-slow-string-processing/</guid>
        <description>&lt;p&gt;在C++开发的历史项目中，我们使用自定义协议进行通信，协议采用了二维数组的模式。在处理大量数据时，协议内部需要遍历数组并进行序列化操作以生成日志，由于效率较低，导致了系统在高负载下出现明显的卡顿，业务部门反馈系统卡顿。&lt;/p&gt;
&lt;h2 id=&#34;问题定位&#34;&gt;问题定位
&lt;/h2&gt;&lt;p&gt;在排查问题时，我们首先对系统进行了性能分析，发现系统在处理大量数据时，CPU 占用率明显增加，且系统响应时间变长。通过分析系统的日志，我们发现了大量的序列化操作，这些操作在处理二维数组时效率较低，导致了系统性能下降。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pstack&lt;/code&gt;工具截取服务的线程信息，定位到日志线程大部分时间都在处理字符串的拼接。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里是今天的重点，不同的累加方式，效率差别巨大。历史代码中使用的是 &lt;code&gt;+&lt;/code&gt; 运算符，这种方式会频繁的创建临时对象，效率很低。你知道它效率很差，但你不知道它效率有多差的那种。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;demo-验证&#34;&gt;demo 验证
&lt;/h2&gt;&lt;p&gt;基于项目代码，我们抽离业务逻辑，编写了一个简单的 demo，用于验证字符串拼接的效率问题。&lt;code&gt;windows&lt;/code&gt; 下的 &lt;code&gt;vs2022&lt;/code&gt; 编译器，&lt;code&gt;linux&lt;/code&gt; 下的 &lt;code&gt;gcc8.5&lt;/code&gt; 编译器，&lt;code&gt;Release&lt;/code&gt;模式下编译运行，对比效率。&lt;/p&gt;
&lt;h3 id=&#34;关键点说明&#34;&gt;关键点说明
&lt;/h3&gt;&lt;p&gt;项目使用的是方法四，在尚未拿到测试数据的时候，读者可以先思考一下，哪种方式效率最高？哪种方式效率最低？看到结果的时候，我还是很惊讶的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;方法 1 (&lt;code&gt;+=&lt;/code&gt; 拼接)&lt;/strong&gt;：直接通过 &lt;code&gt;+=&lt;/code&gt; 将每个字段拼接到字符串中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法 2 (&lt;code&gt;std::ostringstream&lt;/code&gt; 拼接)&lt;/strong&gt;：使用流（&lt;code&gt;std::ostringstream&lt;/code&gt;）来拼接每个字段，这种方法更高效，特别是对于大量数据拼接时。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法 3（预分配内存的 &lt;code&gt;+=&lt;/code&gt; 拼接）&lt;/strong&gt;：通过 &lt;code&gt;reserve&lt;/code&gt; 提前为字符串分配足够的内存，减少了内存重新分配的开销，从而提升了性能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法 4 (&lt;code&gt;bodys = bodys + body + &amp;quot;\n&amp;quot;&lt;/code&gt;)&lt;/strong&gt;：每次拼接都创建一个新的临时字符串对象，这会导致性能下降，尤其是在大规模拼接时，因为每次拼接都会涉及一次新的内存分配和复制。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考结果，我们可以看到，项目刚好选中了效率最差的方式。&lt;/p&gt;
&lt;p&gt;再进一步，我们来分析不同平台编译器的优化效率，微软的 &lt;code&gt;visual studio&lt;/code&gt; 一如既往的优秀，针对字符串的优化效率很高，而 &lt;code&gt;gcc&lt;/code&gt; 编译器在这方面的优化效率就差了一些。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代码在不同的机器执行，两份数据没有直接的对比意义，可以分别对比不同拼接方法之间的差值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;windows 平台下的 vs2022 编译器

----------------------------------------
Data Generation Time: 0.054 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.053 seconds.
+ ostringstream Data merging took: 0.054 seconds.
+ Pre-reserved Data merging took: 0.045 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 16.108 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;linux 平台下的 gcc8.5 编译器
----------------------------------------
Data Generation Time: 0.108 seconds.
----------------------------------------

----------------------------------------
Data Merging Performance:
----------------------------------------
+ Data merging (+=) took: 0.100 seconds.
+ ostringstream Data merging took: 0.083 seconds.
+ Pre-reserved Data merging took: 0.057 seconds.
+ Data merging (bodys = bodys + body + &amp;quot;\n&amp;quot;) took: 29.298 seconds.

----------------------------------------
Data Merging Complete.
----------------------------------------

Program finished.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完整代码&#34;&gt;完整代码
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;random&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;iomanip&amp;gt;

typedef std::vector&amp;lt;std::string&amp;gt; DataRow;
typedef std::vector&amp;lt;DataRow&amp;gt; DataGroup;

struct ResponsePackage
{
    std::string ErrorInfo;
    DataRow Head;
    std::string ClientId;
    std::string UUID;
    std::string MsgID;
    std::string SessionID;
    std::string ExtraInfo1;
    std::string ExtraInfo2;
    DataGroup DataBody;
};

// Generate specified length of random string
std::string generateRandomString(size_t length)
{
    const char charset[] = &amp;quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&amp;quot;;
    const size_t max_index = sizeof(charset) - 1;
    std::string random_string;
    random_string.reserve(length);

    std::random_device rd;
    std::mt19937 generator(rd());
    std::uniform_int_distribution&amp;lt;&amp;gt; distribution(0, max_index);

    for (size_t i = 0; i &amp;lt; length; ++i)
    {
        random_string += charset[distribution(generator)];
    }

    return random_string;
}

void create_large_string()
{
    // Example request package with 50 fields
    ResponsePackage requestPackage;

    requestPackage.Head = {
        &amp;quot;Field1&amp;quot;, &amp;quot;Field2&amp;quot;, &amp;quot;Field3&amp;quot;, &amp;quot;Field4&amp;quot;, &amp;quot;Field5&amp;quot;,
        &amp;quot;Field6&amp;quot;, &amp;quot;Field7&amp;quot;, &amp;quot;Field8&amp;quot;, &amp;quot;Field9&amp;quot;, &amp;quot;Field10&amp;quot;,
        &amp;quot;Field11&amp;quot;, &amp;quot;Field12&amp;quot;, &amp;quot;Field13&amp;quot;, &amp;quot;Field14&amp;quot;, &amp;quot;Field15&amp;quot;,
        &amp;quot;Field16&amp;quot;, &amp;quot;Field17&amp;quot;, &amp;quot;Field18&amp;quot;, &amp;quot;Field19&amp;quot;, &amp;quot;Field20&amp;quot;,
        &amp;quot;Field21&amp;quot;, &amp;quot;Field22&amp;quot;, &amp;quot;Field23&amp;quot;, &amp;quot;Field24&amp;quot;, &amp;quot;Field25&amp;quot;,
        &amp;quot;Field26&amp;quot;, &amp;quot;Field27&amp;quot;, &amp;quot;Field28&amp;quot;, &amp;quot;Field29&amp;quot;, &amp;quot;Field30&amp;quot;,
        &amp;quot;Field31&amp;quot;, &amp;quot;Field32&amp;quot;, &amp;quot;Field33&amp;quot;, &amp;quot;Field34&amp;quot;, &amp;quot;Field35&amp;quot;,
        &amp;quot;Field36&amp;quot;, &amp;quot;Field37&amp;quot;, &amp;quot;Field38&amp;quot;, &amp;quot;Field39&amp;quot;, &amp;quot;Field40&amp;quot;,
        &amp;quot;Field41&amp;quot;, &amp;quot;Field42&amp;quot;, &amp;quot;Field43&amp;quot;, &amp;quot;Field44&amp;quot;, &amp;quot;Field45&amp;quot;,
        &amp;quot;Field46&amp;quot;, &amp;quot;Field47&amp;quot;, &amp;quot;Field48&amp;quot;, &amp;quot;Field49&amp;quot;, &amp;quot;Field50&amp;quot;
    };

    requestPackage.ClientId = &amp;quot;ClientID&amp;quot;;
    requestPackage.UUID = &amp;quot;UUID&amp;quot;;
    requestPackage.MsgID = &amp;quot;MsgID&amp;quot;;
    requestPackage.SessionID = &amp;quot;SessionID&amp;quot;;
    requestPackage.ExtraInfo1 = &amp;quot;ExtraInfo1&amp;quot;;
    requestPackage.ExtraInfo2 = &amp;quot;ExtraInfo2&amp;quot;;

    // Start timing for data generation
    auto start_gen = std::chrono::high_resolution_clock::now();

    // Generate 10,000 rows of data, each with 50 fields
    for (size_t i = 0; i &amp;lt; 10000; ++i)
    {
        DataRow dataRow(50, &amp;quot;This is a test string&amp;quot;);
        requestPackage.DataBody.push_back(dataRow);
    }

    // End timing for data generation
    auto end_gen = std::chrono::high_resolution_clock::now();
    std::chrono::duration&amp;lt;double&amp;gt; duration_gen = end_gen - start_gen;

    // Display result generation time
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Generation Time: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_gen.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    // Data merging using different methods
    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Performance:\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;

    {
        // Method 1: Using &#39;+=&#39; string concatenation
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (+=) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 2: Using ostringstream
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::ostringstream bodys;
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::ostringstream body;
            body &amp;lt;&amp;lt; &amp;quot;This is a test string&amp;quot;;
            for (auto&amp;amp; item : vec)
            {
                body &amp;lt;&amp;lt; item &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            }
            bodys &amp;lt;&amp;lt; body.str() &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ ostringstream Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 3: Pre-allocated memory
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys;
        bodys.reserve(1000 * 50 * 20); // Pre-allocate enough memory
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            body.reserve(50 * 20); // Pre-allocate memory for each row
            for (auto&amp;amp; item : vec)
            {
                body += item + &amp;quot; &amp;quot;;
            }
            bodys += body + &amp;quot;\n&amp;quot;;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Pre-reserved Data merging took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    {
        // Method 4: Using &#39;bodys = bodys + body + &amp;quot;\n&amp;quot;&#39;
        auto start_merge = std::chrono::high_resolution_clock::now();
        std::string bodys(&amp;quot;&amp;quot;);
        for (auto&amp;amp; vec : requestPackage.DataBody)
        {
            std::string body(&amp;quot;This is a test string&amp;quot;);
            for (auto&amp;amp; item : vec)
            {
                body = body + item + &amp;quot; &amp;quot;; // Note the use of &#39;body = body + item&#39;
            }
            bodys = bodys + body + &amp;quot;\n&amp;quot;; // Again, using &#39;bodys = bodys + body&#39;
        }
        auto end_merge = std::chrono::high_resolution_clock::now();
        std::chrono::duration&amp;lt;double&amp;gt; duration_merge = end_merge - start_merge;
        std::cout &amp;lt;&amp;lt; &amp;quot;+ Data merging (bodys = bodys + body + \&amp;quot;\\n\&amp;quot;) took: &amp;quot; &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(3) &amp;lt;&amp;lt; duration_merge.count() &amp;lt;&amp;lt; &amp;quot; seconds.\n&amp;quot;;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\n----------------------------------------\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;Data Merging Complete.\n&amp;quot;;
    std::cout &amp;lt;&amp;lt; &amp;quot;----------------------------------------\n&amp;quot;;
}

int main()
{
    try
    {
        create_large_string();
    }
    catch (const std::exception&amp;amp; e)
    {
        std::cerr &amp;lt;&amp;lt; &amp;quot;Caught exception: &amp;quot; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl;
    }

    std::cout &amp;lt;&amp;lt; &amp;quot;\nProgram finished.\n&amp;quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43;中lambd表达式参数生命周期</title>
        <link>https://ttf248.life/p/cpp-lambda-parameter-lifetime/</link>
        <pubDate>Wed, 13 Nov 2024 19:23:02 +0800</pubDate>
        
        <guid>https://ttf248.life/p/cpp-lambda-parameter-lifetime/</guid>
        <description>&lt;p&gt;在C++中，lambda表达式是一种方便的匿名函数，可以捕获外部变量并在其体内使用。这使得lambda成为一种灵活的编程工具。不过，lambda表达式的参数生命周期是一个需要特别关注的方面，尤其是在捕获和传递参数时&lt;/p&gt;
&lt;h3 id=&#34;1-lambda表达式的参数生命周期&#34;&gt;1. Lambda表达式的参数生命周期
&lt;/h3&gt;&lt;p&gt;Lambda表达式的参数生命周期通常与其他C++函数一样。函数的参数在函数调用时存在，函数调用结束时，参数生命周期结束。然而，由于lambda表达式可能会捕获外部变量，因此参数的生命周期也受到捕获方式的影响。&lt;/p&gt;
&lt;h3 id=&#34;2-捕获与参数生命周期的关系&#34;&gt;2. 捕获与参数生命周期的关系
&lt;/h3&gt;&lt;h4 id=&#34;21-捕获外部变量&#34;&gt;2.1 捕获外部变量
&lt;/h4&gt;&lt;p&gt;C++的lambda表达式允许通过两种方式捕获外部变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;按值捕获&lt;/strong&gt;：通过值捕获，外部变量的值被复制到lambda内部，lambda内的副本生命周期由lambda的生命周期控制。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按引用捕获&lt;/strong&gt;：通过引用捕获，外部变量的引用会保留，lambda内的引用指向原始外部变量，生命周期取决于外部变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda_by_value = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };  // 捕获x的副本
auto lambda_by_reference = [&amp;amp;x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };  // 捕获x的引用

lambda_by_value();  // 打印10
lambda_by_reference();  // 打印10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于捕获的变量，生命周期如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;按值捕获&lt;/strong&gt;：捕获时外部变量的值被复制到lambda，lambda生命周期结束时，复制的副本被销毁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按引用捕获&lt;/strong&gt;：lambda持有外部变量的引用，&lt;strong&gt;外部变量必须在lambda使用之前有效，否则会导致未定义行为&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;22-lambda参数&#34;&gt;2.2 Lambda参数
&lt;/h4&gt;&lt;p&gt;Lambda的参数与常规函数参数类似，它们的生命周期仅限于lambda函数体内。也就是说，lambda参数会在lambda调用时被创建，并且在lambda调用结束后，参数的生命周期也结束。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto lambda = [](int a, int b) {
    std::cout &amp;lt;&amp;lt; a + b &amp;lt;&amp;lt; std::endl;
};
lambda(5, 10);  // a和b在这里是lambda的参数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个例子中，&lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 是lambda表达式的参数，它们在lambda调用时创建，并在lambda执行结束后销毁。&lt;/p&gt;
&lt;h3 id=&#34;3-捕获外部变量时的生命周期问题&#34;&gt;3. 捕获外部变量时的生命周期问题
&lt;/h3&gt;&lt;h4 id=&#34;31-捕获的变量是否能在lambda外部有效&#34;&gt;3.1 捕获的变量是否能在lambda外部有效
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;按值捕获&lt;/strong&gt;：即使外部变量在lambda调用后销毁，lambda内部依然持有外部变量的副本。因此，lambda内部的副本可以安全使用，即使外部变量已经不再存在。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x 在lambda调用后修改
lambda();  // 打印10，捕获的是x的副本
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;按引用捕获&lt;/strong&gt;：如果捕获的是外部变量的引用，lambda内部对该引用的访问依赖于外部变量的生命周期。如果外部变量在lambda执行之前就销毁了，那么会出现悬空引用的问题，导致未定义行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 10;
auto lambda = [&amp;amp;x]() { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl; };
x = 20;  // x 在lambda调用前修改
lambda();  // 打印20，捕获的是x的引用
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;如果lambda的执行顺序不确定，确保捕获的外部变量在lambda执行时仍然有效非常重要。&lt;/p&gt;
&lt;/blockquote&gt;</description>
        </item>
        <item>
        <title>升级GCC版本导致程序崩溃：代码不规范的隐患</title>
        <link>https://ttf248.life/p/gcc-upgrade-causes-program-crash-code-irregularities/</link>
        <pubDate>Sun, 10 Mar 2024 23:19:06 +0800</pubDate>
        
        <guid>https://ttf248.life/p/gcc-upgrade-causes-program-crash-code-irregularities/</guid>
        <description>&lt;p&gt;在同一段业务代码的情况下，程序在 CentOS 7 环境下编译并运行正常，但当切换到 CentOS 8 并使用更新版的 GCC 进行编译时，程序却发生了崩溃。值得注意的是，问题只在 &lt;strong&gt;Release 模式&lt;/strong&gt;下出现，&lt;strong&gt;Debug 模式&lt;/strong&gt;则完全没有问题。这是我们第一次遇到类似的情况，经过三天的排查，最终找到了问题的根源。&lt;/p&gt;
&lt;h3 id=&#34;问题定位&#34;&gt;问题定位
&lt;/h3&gt;&lt;p&gt;通过一番排查，问题的症结在于 &lt;strong&gt;函数缺少返回值&lt;/strong&gt;。在 Release 模式下，GCC 新版本会进行更多的优化，这导致了原本没有显式返回值的函数在执行过程中出现了未知的逻辑，从而引发了崩溃。我们的结论是，&lt;strong&gt;编译器的警告不容忽视，尤其是在老项目中，部分警告可能被无视，但也应当避免屏蔽所有警告&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;环境说明&#34;&gt;环境说明
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CentOS 7 GCC版本：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39)
Copyright © 2015 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CentOS 8 GCC版本：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc (GCC) 8.5.0 20210514 (Red Hat 8.5.0-21)
Copyright (C) 2018 Free Software Foundation, Inc.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;崩溃现象&#34;&gt;崩溃现象
&lt;/h3&gt;&lt;p&gt;我们在分析程序崩溃的堆栈时，看到的堆栈信息如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[New LWP 1385902]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &amp;quot;/lib64/libthread_db.so.1&amp;quot;.
Core was generated by `./pstack_main`.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007ffe894b4420 in ?? ()
(gdb) bt
#0  0x00007ffe894b4420 in ?? ()
#1  0x00000000004008e9 in main ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个堆栈看上去并不直观，崩溃函数的栈信息居然显示为一个 &lt;code&gt;??&lt;/code&gt;，这让问题的排查变得更加复杂。&lt;/p&gt;
&lt;h3 id=&#34;代码示例&#34;&gt;代码示例
&lt;/h3&gt;&lt;p&gt;为了更好地理解问题，下面是重现崩溃的最小代码示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int test() {
    std::cout &amp;lt;&amp;lt; &amp;quot;1&amp;quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    test();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该代码中的 &lt;code&gt;test()&lt;/code&gt; 函数显然没有显式返回一个值，而它的返回类型是 &lt;code&gt;int&lt;/code&gt;。根据 C++ 规范，当一个函数声明为 &lt;code&gt;int&lt;/code&gt; 类型时，必须有一个返回值，否则就可能导致未定义行为。&lt;/p&gt;
&lt;h3 id=&#34;编译警告&#34;&gt;编译警告
&lt;/h3&gt;&lt;p&gt;在我们的项目中，CMake 脚本屏蔽了许多编译时警告，其中就包括了以下警告信息：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/root/pstack/main.cpp: In function ‘int test()’:
/root/pstack/main.cpp:7:1: warning: no return statement in function returning non-void [-Wreturn-type]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这一警告表明 &lt;code&gt;test()&lt;/code&gt; 函数没有返回值，而这正是问题的根源。高版本的 GCC（如 8.5.0）在优化代码时可能会对这种未定义的行为做出不稳定的优化，从而导致程序崩溃。&lt;/p&gt;
&lt;h3 id=&#34;汇编代码差异&#34;&gt;汇编代码差异
&lt;/h3&gt;&lt;p&gt;为了解释 GCC 编译器优化行为的差异，我们对比了不同版本 GCC 生成的汇编代码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;GCC 4.8.5 生成的汇编代码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;汇编代码较为冗长，且包含了对标准输出流（如 &lt;code&gt;std::cout&lt;/code&gt;）的处理逻辑。这表明编译器进行了更保守的优化，未对 &lt;code&gt;test()&lt;/code&gt; 函数中缺失返回值的问题做过多优化，可能因此避免了崩溃。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;GCC 8.5.0 生成的汇编代码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新版本的 GCC 进行了更多的优化，减少了代码量。然而，这种优化可能使得缺少返回值的函数执行时行为不确定，从而导致程序崩溃。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;结论&#34;&gt;结论
&lt;/h3&gt;&lt;p&gt;通过这次问题排查，我们深刻认识到，在 C++ 中，&lt;strong&gt;函数返回值必须明确&lt;/strong&gt;，特别是在函数声明为 &lt;code&gt;int&lt;/code&gt; 时，必须提供一个返回值。对于使用较旧版本编译器的项目，升级到新版本的 GCC 时，可能会遇到更多的优化和更严格的警告机制。因此，我们建议在编译时 &lt;strong&gt;不要屏蔽所有警告&lt;/strong&gt;，而是应该有选择性地处理它们，尤其是函数返回值、类型匹配等常见问题。&lt;/p&gt;
&lt;p&gt;最终，通过为 &lt;code&gt;test()&lt;/code&gt; 函数添加一个返回值，问题得以解决，程序恢复了正常的运行。&lt;/p&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43;编程中的陷阱：错误使用`std::map`导致程序崩溃详解</title>
        <link>https://ttf248.life/p/cpp-programming-traps-std-map-crash-details/</link>
        <pubDate>Sun, 10 Mar 2024 22:03:06 +0800</pubDate>
        
        <guid>https://ttf248.life/p/cpp-programming-traps-std-map-crash-details/</guid>
        <description>&lt;p&gt;本文旨在揭示在C++编程中不正确使用&lt;code&gt;std::map&lt;/code&gt;容器可能导致程序崩溃，通过中括号操作符尝试访问不存在的键时，会自动添加一个空元素。我们将深入剖析这一误解，并通过实例代码展示其潜在风险。&lt;/p&gt;
&lt;p&gt;存储简单值不会有什么问题，但如果存储的是指针，那么就会有问题。因为指针是一个地址，如果没有初始化，那么这个地址是不确定的，这样就会导致程序崩溃。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;在C++标准库中，&lt;code&gt;std::map&lt;/code&gt;是一种关联容器，它按照键（key）的升序存储元素，并提供了高效的关键字查找功能。然而，新手开发者有时会因为对&lt;code&gt;std::map&lt;/code&gt;中括号操作符 &lt;code&gt;[]&lt;/code&gt; 的行为理解有误而陷入困境。实际上，当使用 &lt;code&gt;[]&lt;/code&gt; 访问一个不存在的键时，&lt;code&gt;std::map&lt;/code&gt; 会插入一个新的键值对，且默认构造函数将会用来初始化该键对应的值类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;map&amp;gt;

int main() {
    std::map&amp;lt;std::string, int&amp;gt; myMap;
    
    // 错误的用法：假设这里试图访问一个不存在的键并认为会得到0
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for &#39;nonexistent_key&#39;: &amp;quot; &amp;lt;&amp;lt; myMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;

    // 实际上，上述行代码创建了一个新的键值对，其中值被默认初始化为int的默认值（通常是0）
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上代码虽然没有直接导致程序崩溃，但这种隐式的插入行为在某些情况下可能导致意料之外的副作用，例如资源泄漏或不符合预期的状态变更。更糟糕的是，在多线程环境下并发访问未初始化的内存区域，甚至可能导致程序崩溃。&lt;/p&gt;
&lt;p&gt;为了防止此类问题，推荐使用 &lt;code&gt;std::map::find()&lt;/code&gt; 或 &lt;code&gt;std::map::count()&lt;/code&gt; 方法来检查键是否存在，或者利用 &lt;code&gt;std::map::insert()&lt;/code&gt; 明确地插入元素：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::map&amp;lt;std::string, int&amp;gt; safeMap;
if (safeMap.count(&amp;quot;nonexistent_key&amp;quot;) == 0) {
    std::cout &amp;lt;&amp;lt; &amp;quot;Key does not exist.&amp;quot; &amp;lt;&amp;lt; std::endl;
} else {
    std::cout &amp;lt;&amp;lt; &amp;quot;Value for existing key: &amp;quot; &amp;lt;&amp;lt; safeMap[&amp;quot;nonexistent_key&amp;quot;] &amp;lt;&amp;lt; std::endl;
}

// 或者明确插入一个键值对，指定初始值
safeMap.insert({ &amp;quot;new_key&amp;quot;, 0 });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果 map 容器内部保存的对象为指针类型，自动插入元素的行为将保存一个未初始化的指针，调用到此指针的任何操作都将导致程序崩溃。&lt;/p&gt;</description>
        </item>
        <item>
        <title>C&#43;&#43;函数调用耗时</title>
        <link>https://ttf248.life/p/cpp-function-call-timing/</link>
        <pubDate>Wed, 24 Jan 2024 14:11:33 +0800</pubDate>
        
        <guid>https://ttf248.life/p/cpp-function-call-timing/</guid>
        <description>&lt;p&gt;设计行情 SDK，针对不同的回调函数实现方式，进行了一次耗时的测试。近期在看 C++ 函数编程，当函数变成了一等公民，在程序内部流转，耗时有什么不同？&lt;/p&gt;
&lt;p&gt;前文链接：&lt;a class=&#34;link&#34; href=&#34;https://ttf248.life/p/compiler-callback-performance-testing/&#34; &gt;编译器、回调函数、性能测试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;leimao&lt;/code&gt; 大佬刚好也做了类似的测试，借代码一用。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文
&lt;/h2&gt;&lt;p&gt;执行平台依旧是我们的老朋友，&lt;a class=&#34;link&#34; href=&#34;https://wandbox.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wandbox.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;cassert&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

int add_one(int input) { return input + 1; }

bool validate_vector_add_one(std::vector&amp;lt;int&amp;gt; const&amp;amp; input_vector,
                             std::vector&amp;lt;int&amp;gt; const&amp;amp; output_vector)
{
    bool is_valid{true};
    for (size_t i{0}; i &amp;lt; input_vector.size(); ++i)
    {
        if (output_vector.at(i) != input_vector.at(i) + 1)
        {
            is_valid = false;
            break;
        }
    }
    return is_valid;
}

void reset_vector(std::vector&amp;lt;int&amp;gt;&amp;amp; input_vector)
{
    for (size_t i{0}; i &amp;lt; input_vector.size(); ++i)
    {
        input_vector.at(i) = 0;
    }
}

template &amp;lt;typename T, typename Func&amp;gt;
void unitary_function_pass_by_lambda_function(T&amp;amp; output, T const&amp;amp; input,
                                              Func const func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_std_function_value(T&amp;amp; output, T const&amp;amp; input,
                                                 std::function&amp;lt;T(T)&amp;gt; const func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_std_function_reference(
    T&amp;amp; output, T const&amp;amp; input, std::function&amp;lt;T(T)&amp;gt; const&amp;amp; func)
{
    output = func(input);
}

template &amp;lt;typename T&amp;gt;
void unitary_function_pass_by_function_pointer(T&amp;amp; output, T const&amp;amp; input,
                                               T (*func)(T))
{
    output = func(input);
}

int main()
{
    // Set floating point format std::cout with 3 decimal places.
    std::cout.precision(3);

    size_t const num_elements{10000000};
    std::vector&amp;lt;int&amp;gt; input_vector(num_elements, 0);
    std::vector&amp;lt;int&amp;gt; output_vector(num_elements, 0);

    auto const lambda_function_add_one{[](int const&amp;amp; input) -&amp;gt; int
                                       { return input + 1; }};
    std::function&amp;lt;int(int)&amp;gt; const std_function_add_one{lambda_function_add_one};

    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a function pointer: &amp;quot; &amp;lt;&amp;lt; sizeof(&amp;amp;add_one)
              &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a std::function pointer: &amp;quot;
              &amp;lt;&amp;lt; sizeof(&amp;amp;std_function_add_one) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &amp;quot;The size of a std::function: &amp;quot; &amp;lt;&amp;lt; sizeof(std_function_add_one)
              &amp;lt;&amp;lt; std::endl;

    // Call function frequently in a vanilla way.
    // The compiler knows what function to call at compile time and can optimize
    // the code.
    // This is the best performance we could get.
    std::chrono::steady_clock::time_point const time_start_vanilla{
        std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        output_vector.at(i) = add_one(input_vector.at(i));
    }
    std::chrono::steady_clock::time_point const time_end_vanilla{
        std::chrono::steady_clock::now()};
    auto const time_elapsed_vanilla{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(time_end_vanilla -
                                                             time_start_vanilla)
            .count()};
    float const latency_vanilla{time_elapsed_vanilla /
                                static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass Vanilla: &amp;quot; &amp;lt;&amp;lt; latency_vanilla &amp;lt;&amp;lt; &amp;quot; ns&amp;quot;
              &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // Sometimes, we don&#39;t know what function to call at compile time.
    // We can use std::function to pass a function as an argument.
    // In this case, we pass the std::function by value.
    // Because the size of a std::function is 32 bytes, passing by value
    // results in a lot of copying and bad performance.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_std_function_value{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_std_function_value(
            output_vector.at(i), input_vector.at(i), std_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_std_function_value{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_std_function_value{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_std_function_value -
            time_start_pass_by_std_function_value)
            .count()};
    float const latency_pass_by_std_function_value{
        time_elapsed_pass_by_std_function_value /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Std Function Value: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_std_function_value &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // Instead of passing the std::function by value, we can pass it by
    // reference (pointer). In this case, object copying is eliminated. The
    // performance is better than passing the std::function by value. However,
    // the performance is still not as good as the vanilla way.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_std_function_reference{
            std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_std_function_reference(
            output_vector.at(i), input_vector.at(i), std_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_std_function_reference{
            std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_std_function_reference{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_std_function_reference -
            time_start_pass_by_std_function_reference)
            .count()};
    float const latency_pass_by_std_function_reference{
        time_elapsed_pass_by_std_function_reference /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Std Function Reference: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_std_function_reference &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // std::function is a general purpose wrapper for function pointers,
    // callable objects, and lambda functions. Because it&#39;s general purpose,
    // it&#39;s not as efficient as a function pointer. In this case, we pass a
    // function pointer to a function. The performance is better than passing
    // the std::function by reference.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_function_pointer{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_function_pointer(output_vector.at(i),
                                                  input_vector.at(i), &amp;amp;add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_function_pointer{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_function_pointer{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_function_pointer -
            time_start_pass_by_function_pointer)
            .count()};
    float const latency_pass_by_function_pointer{
        time_elapsed_pass_by_function_pointer /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Function Pointer: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_function_pointer &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);

    // We can also pass a lambda function to a function.
    // The compiler knows what function to call at compile time and can optimize
    // the code. The performance is also better than passing the std::function
    // by reference.
    std::chrono::steady_clock::time_point const
        time_start_pass_by_lambda_function{std::chrono::steady_clock::now()};
    for (size_t i{0}; i &amp;lt; num_elements; ++i)
    {
        unitary_function_pass_by_lambda_function(
            output_vector.at(i), input_vector.at(i), lambda_function_add_one);
    }
    std::chrono::steady_clock::time_point const
        time_end_pass_by_lambda_function{std::chrono::steady_clock::now()};
    auto const time_elapsed_pass_by_lambda_function{
        std::chrono::duration_cast&amp;lt;std::chrono::nanoseconds&amp;gt;(
            time_end_pass_by_lambda_function -
            time_start_pass_by_lambda_function)
            .count()};
    float const latency_pass_by_lambda_function{
        time_elapsed_pass_by_lambda_function /
        static_cast&amp;lt;float&amp;gt;(num_elements)};
    std::cout &amp;lt;&amp;lt; &amp;quot;Latency Pass By Lambda Function: &amp;quot;
              &amp;lt;&amp;lt; latency_pass_by_lambda_function &amp;lt;&amp;lt; &amp;quot; ns&amp;quot; &amp;lt;&amp;lt; std::endl;
    assert(validate_vector_add_one(input_vector, output_vector));
    reset_vector(output_vector);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 组里常规也就开启 O2 优化，编译选用了 gcc13，不同版本的 gcc 性能耗时略有不同，版本越高 lambda 效果越好
The size of a function pointer: 8
The size of a std::function pointer: 8
The size of a std::function: 32
Latency Pass Vanilla: 0.418 ns
Latency Pass By Std Function Value: 3.47 ns
Latency Pass By Std Function Reference: 1.36 ns
Latency Pass By Function Pointer: 0.396 ns
Latency Pass By Lambda Function: 0.44 ns
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leimao.github.io/blog/CPP-Function-Call-Performance/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://leimao.github.io/blog/CPP-Function-Call-Performance/&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>C11: sleep for vs yield</title>
        <link>https://ttf248.life/p/c11-sleep-for-vs-yield/</link>
        <pubDate>Tue, 20 Sep 2022 20:54:51 +0800</pubDate>
        
        <guid>https://ttf248.life/p/c11-sleep-for-vs-yield/</guid>
        <description>&lt;p&gt;翻看代码的时候，&lt;code&gt;std::this_thread::yield()&lt;/code&gt; 猛的引入眼帘，&lt;code&gt;C11&lt;/code&gt;里面的语法糖，用了不少，&lt;code&gt;yield&lt;/code&gt;还是第一次看到，以前都没注意。&lt;/p&gt;
&lt;p&gt;没查手册，首先想到的是不是和异步变成相关，&lt;code&gt;yield&lt;/code&gt;boost库的协程实现里面用到了这个单词，这里肯定和协程没关系，控制逻辑和普通线程相关。&lt;/p&gt;
&lt;h2 id=&#34;文档&#34;&gt;文档
&lt;/h2&gt;&lt;h3 id=&#34;yield&#34;&gt;yield
&lt;/h3&gt;&lt;p&gt;此函数的准确性为依赖于实现，特别是使用中的 OS 调度器机制和系统状态。例如，先进先出实时调度器（ Linux 的 SCHED_FIFO ）将悬挂当前线程并将它放到准备运行的同优先级线程的队列尾（而若无其他线程在同优先级，则 yield 无效果）&lt;/p&gt;
&lt;h3 id=&#34;sleep_for&#34;&gt;sleep_for
&lt;/h3&gt;&lt;p&gt;阻塞当前线程执行，至少经过指定的 sleep_duration
此函数可能阻塞长于 sleep_duration ，因为调度或资源争议延迟
标准库建议用稳定时钟度量时长。若实现用系统时间代替，则等待时间亦可能对时钟调节敏感&lt;/p&gt;
&lt;h3 id=&#34;分析&#34;&gt;分析
&lt;/h3&gt;&lt;p&gt;两个函数都是让当前线程不再占用线程，执行的效果按照平台情况而定？看到这里依旧有点云里雾里的，运行代码看看执行效果&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ThinkPad 笔记本（visual studio 社区版2022）、腾讯云S2标准服务器（gcc8.5）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运行平台&lt;/th&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;第一次/us&lt;/th&gt;
&lt;th&gt;第二次/us&lt;/th&gt;
&lt;th&gt;第三次/us&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;sleep_for&lt;/td&gt;
&lt;td&gt;9872&lt;/td&gt;
&lt;td&gt;1884&lt;/td&gt;
&lt;td&gt;11302&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;yield&lt;/td&gt;
&lt;td&gt;119&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;sleep_for&lt;/td&gt;
&lt;td&gt;171&lt;/td&gt;
&lt;td&gt;168&lt;/td&gt;
&lt;td&gt;167&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;yield&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;td&gt;102&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;从运行结果不难理解，由于操作系统实现的不同，高精度的休眠时，&lt;code&gt;sleep_for&lt;/code&gt;稳定性差异巨大，如果想要高精度的休眠，使用&lt;code&gt;yield&lt;/code&gt;更加合适&lt;/p&gt;
&lt;p&gt;时间精度提升到&lt;code&gt;ms&lt;/code&gt;时，两者差异并不明显&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;thread&amp;gt;
 
// 建议其他线程运行一小段时间的“忙睡眠”
void little_sleep(std::chrono::microseconds us)
{
    auto start = std::chrono::high_resolution_clock::now();
    auto end = start + us;
    do {
        std::this_thread::yield();
    } while (std::chrono::high_resolution_clock::now() &amp;lt; end);
}
 
int main()
{
    auto start = std::chrono::high_resolution_clock::now();
 
    little_sleep(std::chrono::microseconds(100));
    std::this_thread::sleep_for(std::chrono::microseconds(100));
 
    auto elapsed = std::chrono::high_resolution_clock::now() - start;
    std::cout &amp;lt;&amp;lt; &amp;quot;waited for &amp;quot;
              &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(elapsed).count()
              &amp;lt;&amp;lt; &amp;quot; microseconds\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/header/thread.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/header/thread.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/thread/sleep_for.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://qingcms.gitee.io/cppreference/20210212/zh/cpp/thread/sleep_for.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>为什么需要学习一门新语言</title>
        <link>https://ttf248.life/p/why-learn-a-new-language/</link>
        <pubDate>Thu, 04 Aug 2022 11:27:30 +0800</pubDate>
        
        <guid>https://ttf248.life/p/why-learn-a-new-language/</guid>
        <description>&lt;p&gt;从上学时期开始算，接触 &lt;code&gt;C++&lt;/code&gt; 已经十多年了，为什么需要学习其他的编程语言？&lt;/p&gt;
&lt;p&gt;工作经历：缺乏优雅的模块设计经验，&lt;code&gt;C++&lt;/code&gt; 语法是自由的，学习了其他的语言，也能引导写出更优雅的设计&lt;/p&gt;
&lt;p&gt;编写一些工具的时候，时常会用到&lt;/p&gt;
&lt;p&gt;底层库的设计也好、业务模块实现也好，设计的准则都是想通的&lt;/p&gt;</description>
        </item>
        <item>
        <title>标准库容器的内存分配器：allocator</title>
        <link>https://ttf248.life/p/standard-library-container-memory-allocator/</link>
        <pubDate>Mon, 30 Dec 2019 13:26:19 +0800</pubDate>
        
        <guid>https://ttf248.life/p/standard-library-container-memory-allocator/</guid>
        <description>&lt;p&gt;自定义分配器可以提升性能、提高内存使用效率，并解决频繁少量内存分配的问题。&lt;/p&gt;
&lt;h4 id=&#34;前因&#34;&gt;前因
&lt;/h4&gt;&lt;p&gt;近期接触到了网络网络数据包的开发，需要频繁的申请和释放小块的内存，原本想着使用内存池，查看了几个现有的内存池，发现了这个&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/cacay/MemoryPool&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/cacay/MemoryPool&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看到接口的时候，就比较纳闷，这个内存池的实现怎么有点奇怪。&lt;code&gt;MemoryPool&lt;/code&gt;的实现逻辑，是在申请固定大小的内存空间。看过boost的内存池接口，提供的是一个模板，用的时候进行实例化。正巧这个库已经有文章进行过介绍，提到了&lt;code&gt;allocator&lt;/code&gt;这个概念。&lt;/p&gt;
&lt;h4 id=&#34;wikihttpszhwikipediaorgwikie58886e9858de599a8_c2b2b&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_%28C%2B%2B%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wiki&lt;/a&gt;
&lt;/h4&gt;&lt;p&gt;在C++编程中，分配器（英语：allocator）是C++标准库的重要组成部分。C++的库中定义了多种被统称为“容器”的数据结构（如链表、集合等），这些容器的共同特征之一，就是其大小可以在程序的运行时改变；为了实现这一点，进行动态内存分配就显得尤为必要，在此分配器就用于处理容器对内存的分配与释放请求。换句话说，分配器用于封装标准模板库（STL）容器在内存管理上的低层细节。默认情况下，C++标准库使用其自带的通用分配器，但根据具体需要，程序员也可自行定制分配器以替代之。&lt;/p&gt;
&lt;p&gt;分配器最早由亚历山大·斯特潘诺夫作为C++标准模板库（Standard Template Library，简称STL）的一部分发明，其初衷是创造一种能“使库更加灵活，并能独立于底层数据模型的方法”，并允许程序员在库中利用自定义的指针和引用类型；但在将标准模板库纳入C++标准时，C++标准委员会意识到对数据模型的完全抽象化处理会带来不可接受的性能损耗，为作折中，标准中对分配器的限制变得更加严格，而有鉴于此，与斯特潘诺夫原先的设想相比，现有标准所描述的分配器可定制程度已大大受限。&lt;/p&gt;
&lt;p&gt;虽然分配器的定制有所限制，但在许多情况下，仍需要用到自定义的分配器，而这一般是为封装对不同类型内存空间（如共享内存与已回收内存）的访问方式，或在使用内存池进行内存分配时提高性能而为。除此以外，从内存占用和运行时间的角度看，在频繁进行少量内存分配的程序中，若引入为之专门定制的分配器，也会获益良多。&lt;/p&gt;
&lt;h4 id=&#34;使用需求httpszhwikipediaorgwikie58886e9858de599a8_c2b2b&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%88%86%E9%85%8D%E5%99%A8_%28C%2B%2B%29&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;使用需求&lt;/a&gt;
&lt;/h4&gt;&lt;p&gt;定义自定义分配器的主要原因之一是提升性能。利用专用的自定义分配器可以提高程序的性能，又或提高内存使用效率，亦或两者兼而有之[4][8]。默认分配器使用new操作符分配存储空间[文 5]，而这常利用C语言堆分配函数（malloc()）实现[9]。由于堆分配函数常针对偶发的内存大量分配作优化，因此在为需要一次分配大量内存的容器（如向量、双端队列）分配内存时，默认分配器一般效率良好[8]。但是，对于关联容器与双向链表这类需要频繁分配少量内存的容器来说，若采用默认分配器分配内存，则通常效率很低[4][9]。除此之外，基于malloc()的默认分配器还存在许多问题，诸如较差的引用局部性[4]，以及可能造成内存碎片化[4][9]。&lt;/p&gt;
&lt;p&gt;简言之，此段（……）（如同）是这一标准针对分配器的一场《我有一个梦想》的演讲。在梦想成真之前，关心可移植性的程序员将把自己局限于（使用）无状态的自定义分配器上。
——斯科特 梅耶斯，《Effective STL》
有鉴于此，在这一情况下，人们常使用基于内存池的分配器来解决频繁少量分配问题[8]。与默认的“按需分配”方式不同，在使用基于内存池的分配器时，程序会预先为之分配大块内存（即“内存池”），而后在需要分配内存时，自定义分配器只需向请求方返回一个指向池内内存的指针即可；而在对象析构时，并不需实际解除分配内存，而是延迟到内存池的生命周期完结时才真正解除分配[注 1][8]。&lt;/p&gt;
&lt;p&gt;在“自定义分配器”这一话题上，已有诸多C++专家与相关作者参与探讨，例如斯科特·梅耶斯的作品《Effective STL》与安德烈·亚历山德雷斯库的《Modern C++ Design》都有提及。梅耶斯洞察到，若要求针对某一类型T的分配器的所有实例都相等，则可移植的分配器的实例必须不包含状态。虽然C++标准鼓励库的实现者支持带状态的分配器[文 4]，但梅耶斯称，相关段落是“（看似）美妙的观点”，但也几乎是空话，并称分配器的限制“过于严苛”[4]。例如，STL的list允许splice方法，即一个list对象A的节点可以被直接移入另一个list对象B中，这就要求A的分配器申请到的内存，可被B的分配器释放掉，从而推导出A与B的分配器实例必须相等。梅耶斯的结论是，分配器最好定义为使用静态方法的类型。例如，根据C++标准，分配器必须提供一个实现了rebind方法的other类模板。&lt;/p&gt;
&lt;p&gt;另外，在《C++程序设计语言》中，比雅尼·斯特劳斯特鲁普则认为“‘严格限制分配器，以免各对象信息不同’，这点显然问题不大”（大意），并指出大部分分配器并不需要状态，甚至没有状态情形下性能反倒更佳。他提出了三个自定义分配器的用例：内存池型的分配器、共享内存型分配器与垃圾回收型分配器，并展示了一个分配器的实现，此间利用了一个内部内存池，以快速分配/解除分配少量内存。但他也提到，如此优化可能已经在他所提供的样例分配器中实现[3]。&lt;/p&gt;
&lt;p&gt;自定义分配器的另一用途是调试内存相关错误[10]。若要做到这一点，可以编写一个分配器，令之在分配时分配额外的内存，并借此存放调试信息。这类分配器不仅可以保证内存由同类分配器分配/解除分配内存，还可在一定程度上保护程序免受缓存溢出之害[11]。&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
