<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>故障排查 on 向叔记事簿</title>
        <link>https://ttf248.life/tags/%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/</link>
        <description>Recent content in 故障排查 on 向叔记事簿</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Sat, 28 Feb 2026 18:47:02 +0800</lastBuildDate><atom:link href="https://ttf248.life/tags/%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>本地开发之痛：为何 `nul` 文件删不掉？一个“复合型”文件系统难题的破解之道</title>
        <link>https://ttf248.life/p/local-development-pain-why-cant-you-delete-nul-files-a-solution-to-the-composite-file-system-problem/</link>
        <pubDate>Sat, 08 Nov 2025 16:37:46 +0800</pubDate>
        
        <guid>https://ttf248.life/p/local-development-pain-why-cant-you-delete-nul-files-a-solution-to-the-composite-file-system-problem/</guid>
        <description>&lt;p&gt;在软件开发的日常工作中，我们时常会遇到一些棘手的“小问题”，它们看似简单，却能耗费我们数小时的宝贵时间。其中，在 Windows 系统上删除特定文件（尤其是那些由开发工具链意外生成的文件）无疑是“重灾区”之一。&lt;/p&gt;
&lt;p&gt;我就遇到了这样一个“地狱级”的难题：在本地开发时，项目中莫名其妙地出现了一个名为 &lt;code&gt;nul&lt;/code&gt; 的文件。我尝试了 Windows 资源管理器、CMD 命令行，但系统都提示“找不到文件”或“无法删除”。这个文件就像一个幽灵，顽固地盘踞在我的项目目录中。&lt;/p&gt;
&lt;h2 id=&#34;阶段一常规尝试与标准的无效解法&#34;&gt;阶段一：常规尝试与“标准”的无效解法
&lt;/h2&gt;&lt;p&gt;当我遇到这个问题时，我的第一反应是“&lt;code&gt;nul&lt;/code&gt; 文件”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么 &lt;code&gt;nul&lt;/code&gt; 特殊？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;熟悉 Windows 历史的开发者可能知道，&lt;code&gt;nul&lt;/code&gt; 是一个“天坑”。在 Windows (及更早的 DOS) 系统中，&lt;code&gt;NUL&lt;/code&gt;、&lt;code&gt;CON&lt;/code&gt;、&lt;code&gt;PRN&lt;/code&gt;、&lt;code&gt;AUX&lt;/code&gt; 等是保留的设备名称。&lt;code&gt;NUL&lt;/code&gt; 代表“空设备”（类似于 Unix/Linux 中的 &lt;code&gt;/dev/null&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;当 Windows 的文件系统 API 看到你试图操作一个名为 &lt;code&gt;nul&lt;/code&gt; 的“文件”时，它会认为你是在尝试操作这个“空设备”，而不是一个同名的物理文件。因此，所有常规的文件操作（如删除、重命名）都会失败。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何产生 &lt;code&gt;nul&lt;/code&gt; 文件的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这通常是跨平台开发工具（如 Git、Node.js 脚本、Python 脚本等）的“锅”。这些工具可能基于 POSIX (Unix-like) 标准，在它们的眼中，&lt;code&gt;nul&lt;/code&gt; 只是一个普通的文件名。它们在 Windows 上运行时，有时会绕过常规的API，直接创建出这种 Windows “消化不良”的文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网上推荐的“标准解法”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我迅速在网上搜索，发现我不是第一个遇到这个问题的人。社区提供了几种公认的“高级”解决方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;使用 &lt;code&gt;\\.\&lt;/code&gt; 语法&lt;/strong&gt;：在 CMD 中使用特殊的“长路径”语法，绕过 Windows 的名称检查。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;del \\.\C:\your\project\path\nul
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;使用 Git Bash&lt;/strong&gt;：Git Bash 提供了一个轻量级的 Unix 环境，它不把 &lt;code&gt;nul&lt;/code&gt; 当作特殊设备&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rm nul
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;使用 WSL (Windows Subsystem for Linux)&lt;/strong&gt;：进入 WSL，挂载 Windows 磁盘，使用 Linux 的 &lt;code&gt;rm&lt;/code&gt; 命令删除。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rm /mnt/c/your/project/path/nul
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然而，&lt;strong&gt;这些方法对我全都不起作用！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无论是 WSL 还是 Git Bash，当我尝试 &lt;code&gt;rm nul&lt;/code&gt; 时，系统都报出了“No such file or directory”（没有那个文件或目录）的错误。这让我陷入了沉思，问题似乎比我想象的更复杂。&lt;/p&gt;
&lt;h2 id=&#34;阶段二灵光一现是不是多重问题叠加&#34;&gt;阶段二：灵光一现——是不是“多重问题叠加”？
&lt;/h2&gt;&lt;p&gt;如果 &lt;code&gt;nul&lt;/code&gt; 文件确实存在，为什么连 Unix 工具都说“找不到”它呢？&lt;/p&gt;
&lt;p&gt;我开始怀疑：&lt;strong&gt;是不是问题不仅出在 &lt;code&gt;nul&lt;/code&gt; 文件本身，还出在了它的“栖身之所”——它所在的目录？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我立刻打开 Git Bash（这是关键，因为 Windows 资源管理器可能不会显示异常），导航到 &lt;code&gt;nul&lt;/code&gt; 文件所在的&lt;strong&gt;上一级目录&lt;/strong&gt;，然后执行 &lt;code&gt;ls -la&lt;/code&gt; (列出所有文件，包括隐藏文件，并显示详细信息)。&lt;/p&gt;
&lt;p&gt;这时，我终于发现了“盲点”：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;那个存放 &lt;code&gt;nul&lt;/code&gt; 文件的目录，它的&lt;strong&gt;目录名本身就包含非法字符&lt;/strong&gt;！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在我的案例中，这个目录名可能是一个以空格或点（&lt;code&gt;.&lt;/code&gt;）结尾的名称，或者是包含 Windows 不允许的特殊符号（如 &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;:&lt;/code&gt;）——这些同样是开发工具在跨平台同步时“夹带的私货”。&lt;/p&gt;
&lt;p&gt;例如，一个目录在 Git Bash 中显示为 &lt;code&gt;&amp;quot;my-app &amp;quot;&lt;/code&gt; (注意末尾的空格)，或者 &lt;code&gt;&amp;quot;my-app.&amp;quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这就是问题所在！&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;问题A：&lt;/strong&gt; 我有一个名为 &lt;code&gt;nul&lt;/code&gt; 的“非法”文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;问题B：&lt;/strong&gt; 我有一个名为 &lt;code&gt;&amp;quot;my-app &amp;quot;&lt;/code&gt; 的“非法”目录。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当我尝试 &lt;code&gt;rm /path/to/&amp;quot;my-app &amp;quot;/nul&lt;/code&gt; 时，Windows 系统和 Unix 工具都“蒙圈”了。Windows API 无法正确解析这个包含非法字符的路径；而 Git Bash 或 WSL 虽然能“看到”这个非法目录，但在尝试访问它内部的 &lt;code&gt;nul&lt;/code&gt; 文件时，可能因为路径解析的复合问题而失败。&lt;/p&gt;
&lt;h2 id=&#34;阶段三釜底抽薪从路径下手一举歼灭&#34;&gt;阶段三：釜底抽薪——从路径下手，一举歼灭
&lt;/h2&gt;&lt;p&gt;既然确定了是“文件路径”和“文件名”的双重问题，解决方案就清晰了：&lt;strong&gt;不要试图去删除那个 &lt;code&gt;nul&lt;/code&gt; 文件，而是直接删除那个“非法”的父目录！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我的最终解决步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;打开 Git Bash&lt;/strong&gt;：这是唯一能正确“看到”并处理这些非法名称的工具。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;导航到“问题目录”的上一级&lt;/strong&gt;：
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 假设问题目录是 C:\projects\my-app 
cd /c/projects/
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;确认“问题目录”的真实名称&lt;/strong&gt;：
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ls -l
# 输出可能显示如下：
# drwxr-xr-x 1 MyUser 1049089 0 Nov 7 06:30 &#39;my-app &#39;/ 
# 注意到了吗？ls 命令用单引号把这个带空格的目录名括起来了。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行“终极删除”&lt;/strong&gt;：使用 &lt;code&gt;rm&lt;/code&gt; 命令的 &lt;code&gt;-r&lt;/code&gt; (递归) 和 &lt;code&gt;-f&lt;/code&gt; (强制) 选项，配合&lt;strong&gt;引号&lt;/strong&gt;，来删除整个目录。
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 必须使用引号（单引号或双引号）
# 并且，如果你在 Git Bash 中输入 &#39;my-app &#39; 然后按 Tab 键，它也能帮你自动补全

rm -rf &amp;quot;my-app &amp;quot;

# 或者

rm -rf &#39;my-app &#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;执行命令后，那个困扰我许久的、包含 &lt;code&gt;nul&lt;/code&gt; 文件的、本身命名也不合法的目录，终于从我的文件系统中被彻底清除了。&lt;/p&gt;</description>
        </item>
        <item>
        <title>台式机引导加载失败</title>
        <link>https://ttf248.life/p/desktop-boot-loader-failure/</link>
        <pubDate>Wed, 24 Sep 2025 21:25:37 +0800</pubDate>
        
        <guid>https://ttf248.life/p/desktop-boot-loader-failure/</guid>
        <description>&lt;p&gt;七月份的时候，心血来潮，周末没事干，想着给台式机清理下灰尘，四五年没有清理，灰尘也确实挺多的。弄完重启系统一切都是好好地，平常电脑不关机，长期开着，也就关下显示器，凑巧夫人过来常住，晚上她见得不各种光源，顺手就给电脑关机了。&lt;/p&gt;
&lt;h2 id=&#34;散热器&#34;&gt;散热器
&lt;/h2&gt;&lt;p&gt;原本当天就应该写稿子，重装系统各种事情掺杂进来，忘记了，人脑有时候就是这么神奇，今天突然想起来了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/desktop-boot-loader-failure/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250717180011_438_45.jpg&#34;
	width=&#34;1279&#34;
	height=&#34;2275&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;散热器&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;56&#34;
		data-flex-basis=&#34;134px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;开机失败&#34;&gt;开机失败
&lt;/h2&gt;&lt;p&gt;隔天尝试开机，系统蓝屏，报错的信息变化了几次，最后还是无法开机，想着是不是清灰的时候，硬盘安装没有固定好，掉盘了，找不到系统引导文件，导致开机失败。报错信息很明显的加载引导失败，U盘能正常进入PE系统，心里此时不慌，接下来就是一顿操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重新插拔硬盘线，硬盘很多，主要是引导盘&lt;/li&gt;
&lt;li&gt;放大招，格式化系统盘，重新安装&lt;/li&gt;
&lt;li&gt;切换其他磁盘作为硬盘，重新安装&lt;/li&gt;
&lt;li&gt;检查硬盘是否有问题，用硬盘检测工具检测一下&lt;/li&gt;
&lt;li&gt;更改 BOIS 设置，UEFI 和 兼容模式各种尝试&lt;/li&gt;
&lt;li&gt;基于上面的操作，尝试将硬盘调整为 MBR 格式，重新设置引导，安装系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;周末一整天，基本搭进去了，系统能正常开机，也没发现其他问题，但是为什么需要切换老的引导模式呢？&lt;/p&gt;
&lt;p&gt;华硕主板买来的时候，默认就是 UEFI 模式，中间那么多年，系统重装也都是用的 UEFI 模式，这次怎么都没搞定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/desktop-boot-loader-failure/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250719210311_537_45.jpg&#34;
	width=&#34;1279&#34;
	height=&#34;2275&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;蓝屏报错&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;56&#34;
		data-flex-basis=&#34;134px&#34;
	
&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>Win11专业版，远程桌面登录报错：登录失败</title>
        <link>https://ttf248.life/p/win11-pro-professional-remote-desktop-login-error-login-failed/</link>
        <pubDate>Tue, 22 Jul 2025 01:10:10 +0800</pubDate>
        
        <guid>https://ttf248.life/p/win11-pro-professional-remote-desktop-login-error-login-failed/</guid>
        <description>&lt;p&gt;主机莫名奇妙蓝屏无法启动，UEFI格式的引导，系统一直无法正常加载，切换到老的MBR格式的引导后，系统可以正常启动了。&lt;/p&gt;
&lt;p&gt;常规操作，开启系统的远程桌面，另外一台机器测试，网络什么的都是正常。登录和以前一样，用了微软的账户登录系统。&lt;/p&gt;
&lt;p&gt;远程桌面登录的时候，报错：&lt;strong&gt;登录失败&lt;/strong&gt;，没有其他的任何信息。&lt;/p&gt;
&lt;h2 id=&#34;解决方法&#34;&gt;解决方法
&lt;/h2&gt;&lt;p&gt;由于是微软账户登录的系统，远程桌面登录的时候，默认使用的是微软账户的邮箱地址作为用户名，系统推荐开启&lt;strong&gt;PIN&lt;/strong&gt;码登录。&lt;/p&gt;
&lt;p&gt;参考网上查来的资料，第一步先关闭安全设置，也就是登录设置中的&lt;code&gt;为了提高安全性，仅允许对此设备上的 Microsoft 帐户使用 Windows Hello 登录（推荐）&lt;/code&gt;，将其关闭。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/win11-pro-professional-remote-desktop-login-error-login-failed/20250721235800.png&#34;
	width=&#34;470&#34;
	height=&#34;259&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;登录设置&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;181&#34;
		data-flex-basis=&#34;435px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;关键的第二步，重启系统，此时能看到登录的界面除开&lt;code&gt;PIN&lt;/code&gt;码登录外，还多了一个&lt;code&gt;Microsoft 帐户&lt;/code&gt;的选项。选择账户登录，手动输入账号密码，此时再次尝试远程桌面登录，一切正常。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/zh-cn/answers/questions/2191955/question-2191955&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://learn.microsoft.com/zh-cn/answers/questions/2191955/question-2191955&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>微信备份工具局域网识别失败</title>
        <link>https://ttf248.life/p/wechat-backup-tool-local-network-recognition-failed/</link>
        <pubDate>Fri, 13 Jun 2025 23:04:42 +0800</pubDate>
        
        <guid>https://ttf248.life/p/wechat-backup-tool-local-network-recognition-failed/</guid>
        <description>&lt;p&gt;隔段时间就会清理手机上的资料，相册、微信聊天记录都会备份到电脑，手机上仅保留部分需要的聊天记录。&lt;/p&gt;
&lt;p&gt;以前都好好地，能轻松识别到手机和台式机在同一局域网内，直接备份聊天记录到电脑上，今天是各种失败。&lt;/p&gt;
&lt;h2 id=&#34;尝试过的解决方法&#34;&gt;尝试过的解决方法
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;电脑连接WIFI、手机连接WIFI，电脑和手机都在同一局域网内，依然无法识别。&lt;/li&gt;
&lt;li&gt;手机开启热点，电脑连接手机热点，依然无法识别。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;解决方案&#34;&gt;解决方案
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;台式机走的有线网络，手机走的无线网络，微信备份还原的时候，无法识别到这是局域网，我已经测试过了，台式能正常访问手机的IP地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想着是腾讯的东西，问问混元，是不是有思路，给的出来东西，没什么帮助。顺手扔给豆包，&lt;strong&gt;有惊喜&lt;/strong&gt;，提示我本地是不是有很多虚拟网络或者多网卡环境。&lt;/p&gt;
&lt;p&gt;这个倒是没错，台式机上有很多虚拟网卡，VMware、ZeroTier、Hyper-V、Docker Desktop 等等。台式机还有多个物理网卡，连接路由器的主网卡和另外一台机器组成子局域网的2.5G网卡。&lt;/p&gt;
&lt;p&gt;于是我在台式机上禁用了所有虚拟网卡和多余的物理网卡，保留了主网卡，重新尝试备份，果然成功了。&lt;/p&gt;</description>
        </item>
        <item>
        <title>10.243.52.68 也属于局域网</title>
        <link>https://ttf248.life/p/102435268-also-belongs-to-the-local-area-network/</link>
        <pubDate>Fri, 06 Jun 2025 18:46:55 +0800</pubDate>
        
        <guid>https://ttf248.life/p/102435268-also-belongs-to-the-local-area-network/</guid>
        <description>&lt;p&gt;紧接上文，今天继续聊聊局域网的 IP 地址。上次为了同步代码，服务器配置了代理，服务器和家里的台式机打通了网络，在一个局域网里面，代理程序部署在台式机上，服务器通过代理访问外网。同步代码很慢，扔那边就没管了，隔了半个月，到服务器验证代码，发现&lt;code&gt;Git&lt;/code&gt;代码同步失败，网络错误，也没太过脑子，细看报错信息。&lt;/p&gt;
&lt;h2 id=&#34;案发现场&#34;&gt;案发现场
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;fatal: unable to access &amp;lsquo;&lt;a class=&#34;link&#34; href=&#34;https://cnb.cool/ttf248/learn/cpp.git/%27&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cnb.cool/ttf248/learn/cpp.git/&#39;&lt;/a&gt;: Failed to connect to 10.243.52.68 port 7897 after 7 ms: Couldn&amp;rsquo;t connect to server&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相当然的以为是不是阿里云服务和腾讯云原生开发平台有网络隔离，导致代码无法同步，报错信息扔到群里，群里有大聪明看到了端口信息，说这个是不是代理的ip，然后马上有人接着说，你这个是局域网，域名解析的都不对，这会脑子还在失忆阶段，完全不记得自己配过代理。&lt;/p&gt;
&lt;p&gt;看到&lt;strong&gt;局域网&lt;/strong&gt;三个字，脑子正常了，马上想起来自己配置过代理的事情，报错的地址是家里台式机的局域网地址。&lt;/p&gt;
&lt;p&gt;惯性思维：192.168.x.x 是局域网地址。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在计算机网络中，&lt;strong&gt;局域网（LAN）IP地址&lt;/strong&gt;是指在本地网络中使用的私有IP地址，这类地址不会直接暴露在公网上，主要用于内部设备通信。你提到的 &lt;code&gt;10.243.52.68&lt;/code&gt; 和 &lt;code&gt;192.168.x.x&lt;/code&gt; 都属于&lt;strong&gt;私有IP地址段&lt;/strong&gt;，但它们属于不同的地址范围，适用场景和规划逻辑也有所不同。以下是详细对比：&lt;/p&gt;
&lt;h2 id=&#34;私有ip地址的分类与范围&#34;&gt;&lt;strong&gt;私有IP地址的分类与范围&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;根据 &lt;a class=&#34;link&#34; href=&#34;https://datatracker.ietf.org/doc/rfc1918/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RFC 1918&lt;/a&gt; 标准，私有IP地址分为三大段，分别适用于不同规模的局域网：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;地址段&lt;/th&gt;
&lt;th&gt;子网掩码&lt;/th&gt;
&lt;th&gt;可用IP数量&lt;/th&gt;
&lt;th&gt;适用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;10.0.0.0/8&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;255.0.0.0&lt;/td&gt;
&lt;td&gt;约1600万个&lt;/td&gt;
&lt;td&gt;大型企业、园区网络&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;172.16.0.0/12&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;255.240.0.0&lt;/td&gt;
&lt;td&gt;约100万个&lt;/td&gt;
&lt;td&gt;中型企业网络&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;192.168.0.0/16&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;255.255.0.0&lt;/td&gt;
&lt;td&gt;约6.5万个&lt;/td&gt;
&lt;td&gt;小型局域网（家庭、办公室）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;你的问题中的ip地址解析&#34;&gt;&lt;strong&gt;你的问题中的IP地址解析：&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;10.243.52.68&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
属于 &lt;strong&gt;&lt;code&gt;10.0.0.0/8&lt;/code&gt; 段&lt;/strong&gt;，是大型私有网络的典型地址，常用于企业级局域网或广域网（如跨多个分支机构的内部网络）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;192.168.x.x&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
属于 &lt;strong&gt;&lt;code&gt;192.168.0.0/16&lt;/code&gt; 段&lt;/strong&gt;，是最常见的小型私有网络地址，广泛用于家庭路由器、小型办公室等场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;两者的核心区别&#34;&gt;&lt;strong&gt;两者的核心区别&lt;/strong&gt;
&lt;/h2&gt;&lt;h3 id=&#34;地址空间大小&#34;&gt;&lt;strong&gt;地址空间大小&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;10.0.0.0/8&lt;/code&gt;&lt;/strong&gt;：&lt;br&gt;
整个网段的地址范围是 &lt;code&gt;10.0.0.0 ~ 10.255.255.255&lt;/code&gt;，包含 &lt;strong&gt;16,777,216 个可用IP地址&lt;/strong&gt;，适合需要大量IP地址的大型网络（如企业、学校、数据中心）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;192.168.0.0/16&lt;/code&gt;&lt;/strong&gt;：&lt;br&gt;
地址范围是 &lt;code&gt;192.168.0.0 ~ 192.168.255.255&lt;/code&gt;，仅包含 &lt;strong&gt;65,536 个可用IP地址&lt;/strong&gt;，适用于设备数量较少的小型网络（如家庭中通常只有几十台设备）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;子网划分灵活性&#34;&gt;&lt;strong&gt;子网划分灵活性&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;10.0.0.0/8&lt;/code&gt;&lt;/strong&gt;：&lt;br&gt;
由于地址空间大，可通过&lt;strong&gt;子网掩码&lt;/strong&gt;进一步划分为多个子网（如 &lt;code&gt;10.1.0.0/16&lt;/code&gt;、&lt;code&gt;10.2.0.0/16&lt;/code&gt; 等），便于大型网络的分层管理和流量隔离。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;192.168.0.0/16&lt;/code&gt;&lt;/strong&gt;：&lt;br&gt;
通常直接使用默认子网掩码 &lt;code&gt;255.255.0.0&lt;/code&gt;，划分子网的需求较少，适合简单的扁平网络结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;常见应用场景&#34;&gt;&lt;strong&gt;常见应用场景&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;10.xxx.xxx.xxx&lt;/code&gt;&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;企业内部网络：如跨国公司的多个分支机构通过VPN连接，每个分支可分配独立的子网（如 &lt;code&gt;10.1.1.0/24&lt;/code&gt;、&lt;code&gt;10.1.2.0/24&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;云服务商内部网络：如AWS、阿里云等私有云环境常使用 &lt;code&gt;10.&lt;/code&gt; 段地址。&lt;/li&gt;
&lt;li&gt;工业控制网络：部分工业设备默认使用 &lt;code&gt;10.&lt;/code&gt; 段地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;192.168.xxx.xxx&lt;/code&gt;&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;家庭/小型办公室：路由器默认分配的地址（如 &lt;code&gt;192.168.1.1&lt;/code&gt; 或 &lt;code&gt;192.168.0.1&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;小型局域网共享：如通过路由器组建的WiFi网络，设备数量通常不超过200台。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;与公网的隔离性&#34;&gt;&lt;strong&gt;与公网的隔离性&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;两者均为私有地址，&lt;strong&gt;无法直接被公网访问&lt;/strong&gt;，需通过 &lt;strong&gt;NAT（网络地址转换）&lt;/strong&gt; 或 &lt;strong&gt;VPN&lt;/strong&gt; 连接到公网。但在实际使用中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;10.&lt;/code&gt; 段常用于需要更复杂网络架构的场景（如多子网、VLAN划分）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;192.168.&lt;/code&gt; 段因地址空间小，更适合即插即用的简单网络。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;为什么你会看到-10-段地址&#34;&gt;&lt;strong&gt;为什么你会看到 &lt;code&gt;10.&lt;/code&gt; 段地址？&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;如果你在本地网络中发现 &lt;code&gt;10.243.52.68&lt;/code&gt; 这样的地址，可能原因包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;企业级网络环境&lt;/strong&gt;：&lt;br&gt;
你所在的公司或机构使用 &lt;code&gt;10.&lt;/code&gt; 段作为内部IP地址，用于区分不同部门或设备（如服务器、办公电脑）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟机或容器网络&lt;/strong&gt;：&lt;br&gt;
云计算平台（如VMware、Docker）常默认使用 &lt;code&gt;10.&lt;/code&gt; 段地址为虚拟机分配IP。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特殊设备默认配置&lt;/strong&gt;：&lt;br&gt;
部分网络设备（如工业交换机、防火墙）出厂时可能预设 &lt;code&gt;10.&lt;/code&gt; 段地址。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;总结如何选择使用&#34;&gt;&lt;strong&gt;总结：如何选择使用？&lt;/strong&gt;
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;小型网络（家庭/办公室）&lt;/strong&gt;：优先选择 &lt;code&gt;192.168.x.x&lt;/code&gt;，配置简单且足够用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中大型网络（企业/园区）&lt;/strong&gt;：使用 &lt;code&gt;10.x.x.x&lt;/code&gt; 或 &lt;code&gt;172.16.x.x&lt;/code&gt;，便于划分子网和管理大量设备。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两者本质上都是局域网地址，区别仅在于地址空间和适用场景，并无技术上的优劣之分，具体取决于网络规划需求。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Git子模块递交记录丢失</title>
        <link>https://ttf248.life/p/git-submodule-merge-history-lost/</link>
        <pubDate>Mon, 02 Jun 2025 16:44:58 +0800</pubDate>
        
        <guid>https://ttf248.life/p/git-submodule-merge-history-lost/</guid>
        <description>&lt;p&gt;本地有一个 Git 仓库，其中的子模块在拉取时处于一个临时分支。我在该临时分支上提交了一些代码，随后将子模块切换回了 &lt;code&gt;main&lt;/code&gt; 分支。然而，这些提交的代码似乎丢失了，无法在 &lt;code&gt;main&lt;/code&gt; 分支中找到。我也找不到那个临时分支的记录。&lt;/p&gt;
&lt;h2 id=&#34;解决方案&#34;&gt;解决方案
&lt;/h2&gt;&lt;p&gt;在Git子模块中提交到了临时分支，切换回&lt;code&gt;main&lt;/code&gt;分支后找不到这些提交。这种情况可以通过以下步骤解决：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;确认提交记录&lt;/strong&gt;：进入子模块目录，查看reflog找到丢失的提交&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;创建新分支保存提交&lt;/strong&gt;：基于丢失的提交创建新分支&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;合并或 cherry-pick 提交到 main&lt;/strong&gt;：将代码整合到主分支&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是具体的操作步骤：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 进入子模块目录
cd path/to/your/submodule

# 查看reflog记录所有HEAD变更（包括未关联分支的提交）
git reflog

PS F:\dev\notebook\scripts\hugo-content-suite&amp;gt; git reflog
de05175 (HEAD -&amp;gt; main, origin/main, origin/HEAD) HEAD@{0}: checkout: moving from c8d070651310e90d283cb64d98da088c5fe05e73 to main
c8d0706 HEAD@{1}: commit: feat: 添加Markdown标记符用法文档，提供详细语法示例与效果展示
48250f5 HEAD@{2}: commit: feat: 移除文章翻译预览功能，简化翻译流程
b8280b6 HEAD@{3}: commit: feat: 添加获取绝对路径功能，支持将相对路径转换为绝对路径
92c354b HEAD@{4}: commit: fix: 修复文章扫描逻辑，确保使用绝对路径进行扫描
de05175 (HEAD -&amp;gt; main, origin/main, origin/HEAD) HEAD@{5}: checkout: moving from main to de05175d4ec0828e3ae95d726b09dfff18f67a23
de05175 (HEAD -&amp;gt; main, origin/main, origin/HEAD) HEAD@{6}: clone: from https://cnb.cool/ttf248/hugo-content-suite.git

# 基于丢失的提交创建新分支（例如使用456def提交）
git checkout -b saved-work 456def

# 切换回main分支
git checkout main

# 将保存的工作合并到main（或使用cherry-pick选择特定提交）
git merge saved-work
# 或
git cherry-pick 456def

# 返回主项目目录并提交子模块更新
cd ..
git add path/to/your/submodule
git commit -m &amp;quot;Update submodule to include new changes&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;关键操作说明&#34;&gt;关键操作说明
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;git reflog&lt;/strong&gt;：显示HEAD的所有历史记录，包括未关联到分支的提交&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;git checkout -b&lt;/strong&gt;：从任意提交创建新分支，保存你的工作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;git merge/cherry-pick&lt;/strong&gt;：将保存的提交整合到目标分支&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果reflog中找不到记录，可能需要尝试使用&lt;code&gt;git fsck --lost-found&lt;/code&gt;查找 orphaned commits，但这种情况比较少见。&lt;/p&gt;</description>
        </item>
        <item>
        <title>后台服务TCP通讯异常排查</title>
        <link>https://ttf248.life/p/backend-service-tcp-communication-troubleshooting/</link>
        <pubDate>Fri, 14 Feb 2025 22:54:13 +0800</pubDate>
        
        <guid>https://ttf248.life/p/backend-service-tcp-communication-troubleshooting/</guid>
        <description>&lt;p&gt;业务模型：后台服务借助 TCP 与集团的行情网关建立连接。每次连接时，需先行发送一个授权请求，随后持续发送心跳包以维持连接状态。
然而，某一天，收到了服务断开连接的告警信息。通过仔细排查日志后发现，后台服务一直在持续发送心跳包，但对方却毫无回应，可连接却始终未断开。&lt;/p&gt;
&lt;h2 id=&#34;现场简述&#34;&gt;现场简述
&lt;/h2&gt;&lt;p&gt;原本正在公司加班推进项目进度，工作群里突然弹出告警信息。乍一看，我还以为是老毛病，大概率是网络超时致使心跳发送失败，进而导致服务断开连接。可在仔细排查日志后，却发现实际情况并非如此。后台已发送了授权登录消息，然而一直未收到应答，与此同时，心跳包仍在持续不断地发送，对方却始终未回复任何心跳数据。经过对日志的深入分析，暴露出了以下几个关键问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;授权消息无应答：极有可能是对方系统正在重启，使得授权消息未能得到及时处理。&lt;/li&gt;
&lt;li&gt;未成功授权却发送心跳数据：经排查，发现这是程序逻辑上的漏洞。心跳发送函数的判断逻辑存在缺陷，仅仅校验了连接状态，却遗漏了对授权状态的校验。&lt;/li&gt;
&lt;li&gt;服务未断开连接：若服务能够断开连接，便可以触发重连机制，从而重新发送授权消息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前，还剩下最后一个亟待解决的问题——为何服务没有断开连接。这一问题的解决需要开展更为深入细致的排查工作。&lt;/p&gt;
&lt;h2 id=&#34;分析网络数据包&#34;&gt;分析网络数据包
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;tcpdump&lt;/code&gt; 是一个非常强大的网络抓包工具，可以用来捕获网络数据包。通过分析网络数据包，我们可以更加直观地了解网络通信的细节。在这里，我们可以使用 &lt;code&gt;tcpdump&lt;/code&gt; 来捕获网络数据包，以便进一步分析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/backend-service-tcp-communication-troubleshooting/20250220151952.png&#34;
	width=&#34;1126&#34;
	height=&#34;202&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;tcpdump&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;557&#34;
		data-flex-basis=&#34;1337px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;分析图中的数据，我可以看到心跳一直在正常发送，对方服务器并没有回复任何数据，但是给了 &lt;code&gt;ACK&lt;/code&gt;，这就导致连接不会主动断开了。&lt;/p&gt;
&lt;h2 id=&#34;常见标志位说明&#34;&gt;常见标志位说明
&lt;/h2&gt;&lt;p&gt;在 TCP 协议中，&lt;code&gt;PSH&lt;/code&gt;（Push）和 &lt;code&gt;ACK&lt;/code&gt;（Acknowledgment）是两个重要的标志位，分别用于控制数据传输和流量确认。它们的作用如下：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;1-pshpush-flag&#34;&gt;&lt;strong&gt;1. PSH（Push Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：&lt;br&gt;
&lt;code&gt;PSH&lt;/code&gt; 标志位的作用是&lt;strong&gt;请求接收方立即将缓冲区中的数据推送给上层应用&lt;/strong&gt;（而不是等待缓冲区填满）。这意味着一旦收到带有 &lt;code&gt;PSH&lt;/code&gt; 标志的数据段，接收方会尽可能快地处理并传递给应用程序，而非暂存于操作系统缓冲区中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;典型场景&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTTP/HTTPS 请求&lt;/strong&gt;：客户端发送请求时（如 &lt;code&gt;GET /index.html&lt;/code&gt;）会设置 &lt;code&gt;PSH&lt;/code&gt;，希望服务器立即响应。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SSH 协议&lt;/strong&gt;：每次键盘输入都会触发 &lt;code&gt;PSH&lt;/code&gt;，确保输入字符实时传输。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实时通信&lt;/strong&gt;：视频流、在线游戏等低延迟场景可能使用 &lt;code&gt;PSH&lt;/code&gt; 减少延迟。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PSH&lt;/code&gt; 并非强制要求，接收方可以选择忽略该标志位（但仍需正常处理数据）。&lt;/li&gt;
&lt;li&gt;发送方可能不设置 &lt;code&gt;PSH&lt;/code&gt;，此时接收方会根据自身缓冲策略决定何时推送数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2-ackacknowledgment-flag&#34;&gt;&lt;strong&gt;2. ACK（Acknowledgment Flag）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：&lt;br&gt;
&lt;code&gt;ACK&lt;/code&gt; 标志位表示&lt;strong&gt;确认已正确接收前序数据段&lt;/strong&gt;。每个 &lt;code&gt;ACK&lt;/code&gt; 包含一个确认号（&lt;code&gt;Acknowledgment Number&lt;/code&gt;），表示期望接收的下一个字节序号。它是 TCP 可靠传输的核心机制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;工作原理&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送方发送数据段时，会携带期望接收方的 &lt;code&gt;ACK&lt;/code&gt; 值（例如 &lt;code&gt;ACK = 序列号 + 数据长度&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;接收方收到数据后，会生成一个 &lt;code&gt;ACK&lt;/code&gt; 报文段，确认已接收的数据序号。&lt;/li&gt;
&lt;li&gt;发送方只有在收到对应的 &lt;code&gt;ACK&lt;/code&gt; 后，才会重传未被确认的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若发送方发送了序号为 &lt;code&gt;100~199&lt;/code&gt; 的数据段，则期望接收方的 &lt;code&gt;ACK&lt;/code&gt; 应为 &lt;code&gt;200&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;若接收方未收到 &lt;code&gt;100~199&lt;/code&gt; 中的某些数据，会通过 &lt;code&gt;ACK=150&lt;/code&gt; 告知发送方重传。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;3-psh-和-ack-的组合&#34;&gt;&lt;strong&gt;3. PSH 和 ACK 的组合&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;在 TCP 报文中，&lt;code&gt;PSH&lt;/code&gt; 和 &lt;code&gt;ACK&lt;/code&gt; 可以同时出现，常见于以下场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;HTTP 请求响应&lt;/strong&gt;：&lt;br&gt;
客户端发送 &lt;code&gt;POST&lt;/code&gt; 请求时（含数据），会设置 &lt;code&gt;PSH&lt;/code&gt; 和 &lt;code&gt;ACK&lt;/code&gt;（确认之前的响应）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Client → Server: SYN, ACK=1 → 建立连接
Client → Server: PSH, ACK=1, 数据 → 发送请求数据
Server → Client: PSH, ACK=数据长度+1 → 返回响应
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SSH 握手后传输命令&lt;/strong&gt;：&lt;br&gt;
客户端输入命令后，发送带有 &lt;code&gt;PSH&lt;/code&gt; 和 &lt;code&gt;ACK&lt;/code&gt; 的数据段，确保命令立即传输并被服务器处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;4-其他标志位的关联&#34;&gt;&lt;strong&gt;4. 其他标志位的关联&lt;/strong&gt;
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标志位&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;简要说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SYN&lt;/td&gt;
&lt;td&gt;同步&lt;/td&gt;
&lt;td&gt;初始化连接（三次握手）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FIN&lt;/td&gt;
&lt;td&gt;结束&lt;/td&gt;
&lt;td&gt;优雅关闭连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RST&lt;/td&gt;
&lt;td&gt;复位&lt;/td&gt;
&lt;td&gt;强制终止连接（异常情况）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;URG&lt;/td&gt;
&lt;td&gt;紧急&lt;/td&gt;
&lt;td&gt;标记紧急指针（极少使用）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h3 id=&#34;总结&#34;&gt;&lt;strong&gt;总结&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;PSH&lt;/strong&gt; 关注的是&lt;strong&gt;数据尽快到达应用层&lt;/strong&gt;，降低延迟。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ACK&lt;/strong&gt; 关注的是&lt;strong&gt;数据的可靠传输&lt;/strong&gt;，避免丢包或乱序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两者协同工作，平衡了 TCP 协议的效率和可靠性。&lt;/p&gt;</description>
        </item>
        <item>
        <title>Docker 国内镜像代理失效</title>
        <link>https://ttf248.life/p/docker-domestic-image-proxy-failure/</link>
        <pubDate>Sat, 04 Jan 2025 18:29:25 +0800</pubDate>
        
        <guid>https://ttf248.life/p/docker-domestic-image-proxy-failure/</guid>
        <description>&lt;p&gt;国内服务器部署docker，部署以后，如果公司没有提供镜像中心，开发首先要做的就是配置一个国内的镜像加速地址。巧了今天有台服务器，配置了镜像加速地址，但是发现拉取镜像的时候，一直拉取不到。&lt;/p&gt;
&lt;p&gt;报错信息：&lt;code&gt;Error response from daemon: Get &amp;quot;https://registry-1.docker.io/v2/&amp;quot;: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;20250106 时隔两天，所有的服务器都恢复了，这事居然不上热搜，国内所有的镜像代理都挂了&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;故障排查与修复尝试&#34;&gt;故障排查与修复尝试
&lt;/h2&gt;&lt;p&gt;起初，尝试切换至其他镜像加速地址，期望借此解决问题，然而事与愿违，问题依旧。&lt;/p&gt;
&lt;p&gt;紧接着，着手修改本地 DNS 配置，试图从网络解析层面找到突破口，遗憾的是，经过一番调试，故障依然存在。&lt;/p&gt;
&lt;p&gt;此时，本地网络的稳定性已备受质疑，于是果断切换至手机热点，试图绕过可能存在的本地网络故障点，可结果还是令人沮丧，问题毫无改善迹象。&lt;/p&gt;
&lt;h2 id=&#34;问题蔓延&#34;&gt;问题蔓延
&lt;/h2&gt;&lt;p&gt;手头尚有&lt;strong&gt;几台部署于国内的服务器&lt;/strong&gt;，且均安装了 Docker 环境。尝试在这些服务器上拉取镜像，本以为能另辟蹊径，结果发现无一例外，均无法成功拉取，所反馈的报错信息如出一辙，这表明问题并非局限于某一台设备。&lt;/p&gt;
&lt;p&gt;进一步探究发现，镜像代理似乎瞬间失灵，在这紧急关头，迅速切换至境外机器进行尝试，令人稍感欣慰的是，镜像拉取在此处恢复正常，这意味着问题大概率出在国内的网络链路或相关配置上。&lt;/p&gt;
&lt;h2 id=&#34;策略调整迂回解决&#34;&gt;策略调整：迂回解决
&lt;/h2&gt;&lt;p&gt;鉴于国内直接拉取镜像的途径已被重重阻碍，而国外镜像却能正常访问，为尽快推进项目，决定采取迂回战术。首先切换至国外服务器，顺利拉取所需镜像，随后将其推送至国内镜像仓库，以此搭建起一座“数据桥梁”。&lt;/p&gt;
&lt;p&gt;与此同时，同步对 Dockerfile 文件进行修改，将镜像地址替换为适配国内环境的地址，再重新构建镜像，最终成功部署。&lt;/p&gt;</description>
        </item>
        <item>
        <title>办公室迁移，服务器无法访问了</title>
        <link>https://ttf248.life/p/office-move-server-inaccessible/</link>
        <pubDate>Sat, 11 Mar 2023 01:42:05 +0800</pubDate>
        
        <guid>https://ttf248.life/p/office-move-server-inaccessible/</guid>
        <description>&lt;p&gt;行政通知，办公位变动，从原本的二楼，迁移到十五楼，普普通通的一次工位迁移&lt;/p&gt;
&lt;h2 id=&#34;设计感&#34;&gt;设计感
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://ttf248.life/p/office-move-server-inaccessible/20230311014537.png&#34;
	width=&#34;511&#34;
	height=&#34;916&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;办公楼&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;55&#34;
		data-flex-basis=&#34;133px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;迁徙&#34;&gt;迁徙
&lt;/h2&gt;&lt;p&gt;收市打包、轻车熟路，新的工位，调整电脑布线，舒服的姿势开始工作&lt;/p&gt;
&lt;p&gt;(ÒωÓױ)！，接上网线，组里常用的服务器，不能访问了，试着切换无线网络，访问又正常了&lt;/p&gt;
&lt;p&gt;起初呢以为是服务器网段设置问题，新的工位的有线网络，不在防火墙配置的名单里面，联系IT同事调整下就好了；这个网段呢，不止一台服务器，试着访问其他服务器，都是正常的，逐渐产生疑惑？专业的事情交给专业的人来处理，最后运维部门的同事定位到，由于这台服务器部署了&lt;code&gt;docker&lt;/code&gt;，服务的默认网络&lt;code&gt;docker0&lt;/code&gt;和办公室有线网络配置的网段冲突了，导致发过去的数据包，都收不到应答，被路由给了&lt;code&gt;docker&lt;/code&gt;服务。&lt;/p&gt;
&lt;p&gt;其他服务器都没部署&lt;code&gt;docker&lt;/code&gt;服务，也就这台，我比较常用，偶尔用容器部署一些测试服务，没想到还能碰到这个场景。后来细想想，由于整个集团都在一个办公大楼里面，IT部门的同事划分网段，用到了&lt;code&gt;172&lt;/code&gt;打头的地址也不奇怪。&lt;/p&gt;
&lt;h2 id=&#34;docker0&#34;&gt;docker0
&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# vim /etc/docker/daemon.json
{
    &amp;quot;bip&amp;quot;:&amp;quot;172.200.0.1/24&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重启下服务，切换到新的网络，服务器恢复正常访问。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://yeasy.gitbook.io/docker_practice/advanced_network/docker0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Docker从入门到实践-docker0&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
